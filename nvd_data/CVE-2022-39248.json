{
  "cve_id": "CVE-2022-39248",
  "github_data": {
    "repository": "matrix-org/matrix-android-sdk2",
    "fix_commit": "77df720a238d17308deab83ecaa37f7a4740a17e",
    "related_commits": [
      "77df720a238d17308deab83ecaa37f7a4740a17e",
      "77df720a238d17308deab83ecaa37f7a4740a17e"
    ],
    "patch_url": "https://github.com/matrix-org/matrix-android-sdk2/commit/77df720a238d17308deab83ecaa37f7a4740a17e.patch",
    "fix_commit_details": {
      "sha": "77df720a238d17308deab83ecaa37f7a4740a17e",
      "commit_date": "2022-09-28T16:09:06Z",
      "author": {
        "login": "bmarty",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge branch 'release/1.5.1' into develop",
        "length": 41,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 1716,
        "additions": 1388,
        "deletions": 328
      },
      "files": [
        {
          "filename": "CHANGES.md",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -1,5 +1,16 @@\n Please also refer to the Changelog of Element Android: https://github.com/vector-im/element-android/blob/main/CHANGES.md\n \n+Changes in Matrix-SDK v1.5.1 (2022-09-28)\n+=======================================\n+\n+Imported from Element 1.5.1. (https://github.com/vector-im/element-android/releases/tag/v1.5.1)\n+\n+Security \u26a0\ufe0f\n+----------\n+\n+This update provides important security fixes, update now.\n+Ref: CVE-2022-39246 CVE-2022-39248\n+\n Changes in Matrix-SDK v1.4.36 (2022-09-13)\n =======================================\n "
        },
        {
          "filename": "dependencies.gradle",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -15,14 +15,14 @@ def gradle = \"7.1.3\"\n def kotlin = \"1.6.21\"\n def kotlinCoroutines = \"1.6.4\"\n def dagger = \"2.42\"\n-def appDistribution = \"16.0.0-beta03\"\n+def appDistribution = \"16.0.0-beta04\"\n def retrofit = \"2.9.0\"\n def arrow = \"0.8.2\"\n def markwon = \"4.6.2\"\n def moshi = \"1.13.0\"\n def lifecycle = \"2.5.1\"\n def flowBinding = \"1.2.0\"\n-def flipper = \"0.163.0\"\n+def flipper = \"0.164.0\"\n def epoxy = \"4.6.2\"\n def mavericks = \"2.7.0\"\n def glide = \"4.13.2\"\n@@ -86,7 +86,7 @@ ext.libs = [\n                 'appdistributionApi'      : \"com.google.firebase:firebase-appdistribution-api-ktx:$appDistribution\",\n                 'appdistribution'         : \"com.google.firebase:firebase-appdistribution:$appDistribution\",\n                 // Phone number https://github.com/google/libphonenumber\n-                'phonenumber'             : \"com.googlecode.libphonenumber:libphonenumber:8.12.54\"\n+                'phonenumber'             : \"com.googlecode.libphonenumber:libphonenumber:8.12.55\"\n         ],\n         dagger      : [\n                 'dagger'                  : \"com.google.dagger:dagger:$dagger\","
        },
        {
          "filename": "dependencies_groups.gradle",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -69,8 +69,6 @@ ext.groups = [\n                         'com.gabrielittner.threetenbp',\n                         'com.getkeepsafe.relinker',\n                         'com.github.bumptech.glide',\n-                        'com.github.filippudak',\n-                        'com.github.filippudak.progresspieview',\n                         'com.github.javaparser',\n                         'com.github.piasy',\n                         'com.github.shyiko.klob',"
        },
        {
          "filename": "gradle.properties",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -26,7 +26,7 @@ vector.httpLogLevel=NONE\n # Ref: https://github.com/vanniktech/gradle-maven-publish-plugin\n GROUP=org.matrix.android\n POM_ARTIFACT_ID=matrix-android-sdk2\n-VERSION_NAME=1.4.36\n+VERSION_NAME=1.5.1\n \n POM_PACKAGING=aar\n "
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/common/CommonTestHelper.kt",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -38,6 +38,7 @@ import org.matrix.android.sdk.api.MatrixCallback\n import org.matrix.android.sdk.api.MatrixConfiguration\n import org.matrix.android.sdk.api.auth.data.HomeServerConnectionConfig\n import org.matrix.android.sdk.api.auth.registration.RegistrationResult\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n import org.matrix.android.sdk.api.session.Session\n import org.matrix.android.sdk.api.session.events.model.EventType\n import org.matrix.android.sdk.api.session.events.model.toModel\n@@ -61,7 +62,7 @@ import java.util.concurrent.TimeUnit\n  * This class exposes methods to be used in common cases\n  * Registration, login, Sync, Sending messages...\n  */\n-class CommonTestHelper internal constructor(context: Context) {\n+class CommonTestHelper internal constructor(context: Context, val cryptoConfig: MXCryptoConfig? = null) {\n \n     companion object {\n         internal fun runSessionTest(context: Context, autoSignoutOnClose: Boolean = true, block: (CommonTestHelper) -> Unit) {\n@@ -75,8 +76,10 @@ class CommonTestHelper internal constructor(context: Context) {\n             }\n         }\n \n-        internal fun runCryptoTest(context: Context, autoSignoutOnClose: Boolean = true, block: (CryptoTestHelper, CommonTestHelper) -> Unit) {\n-            val testHelper = CommonTestHelper(context)\n+        internal fun runCryptoTest(context: Context, autoSignoutOnClose: Boolean = true,\n+                                   cryptoConfig: MXCryptoConfig? = null,\n+                                   block: (CryptoTestHelper, CommonTestHelper) -> Unit) {\n+            val testHelper = CommonTestHelper(context, cryptoConfig)\n             val cryptoTestHelper = CryptoTestHelper(testHelper)\n             return try {\n                 block(cryptoTestHelper, testHelper)\n@@ -103,7 +106,8 @@ class CommonTestHelper internal constructor(context: Context) {\n                     context,\n                     MatrixConfiguration(\n                             applicationFlavor = \"TestFlavor\",\n-                            roomDisplayNameFallbackProvider = TestRoomDisplayNameFallbackProvider()\n+                            roomDisplayNameFallbackProvider = TestRoomDisplayNameFallbackProvider(),\n+                            cryptoConfig = cryptoConfig ?: MXCryptoConfig()\n                     )\n             )\n         }"
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/common/CryptoTestHelper.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -529,7 +529,8 @@ class CryptoTestHelper(val testHelper: CommonTestHelper) {\n                                         payload = result.clearEvent,\n                                         senderKey = result.senderCurve25519Key,\n                                         keysClaimed = result.claimedEd25519Key?.let { mapOf(\"ed25519\" to it) },\n-                                        forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                                        forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                                        isSafe = result.isSafe\n                                 )\n                             }\n                         } catch (error: MXCryptoError) {"
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/internal/crypto/E2eeSanityTests.kt",
          "status": "modified",
          "additions": 39,
          "deletions": 34,
          "patch": "@@ -29,9 +29,9 @@ import org.junit.runner.RunWith\n import org.junit.runners.JUnit4\n import org.junit.runners.MethodSorters\n import org.matrix.android.sdk.InstrumentedTest\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n import org.matrix.android.sdk.api.session.Session\n import org.matrix.android.sdk.api.session.crypto.MXCryptoError\n-import org.matrix.android.sdk.api.session.crypto.RequestResult\n import org.matrix.android.sdk.api.session.crypto.keysbackup.KeysVersion\n import org.matrix.android.sdk.api.session.crypto.keysbackup.KeysVersionResult\n import org.matrix.android.sdk.api.session.crypto.keysbackup.MegolmBackupCreationInfo\n@@ -45,7 +45,6 @@ import org.matrix.android.sdk.api.session.crypto.verification.VerificationServic\n import org.matrix.android.sdk.api.session.crypto.verification.VerificationTransaction\n import org.matrix.android.sdk.api.session.events.model.EventType\n import org.matrix.android.sdk.api.session.events.model.content.EncryptedEventContent\n-import org.matrix.android.sdk.api.session.events.model.content.WithHeldCode\n import org.matrix.android.sdk.api.session.events.model.toModel\n import org.matrix.android.sdk.api.session.getRoom\n import org.matrix.android.sdk.api.session.room.Room\n@@ -134,7 +133,8 @@ class E2eeSanityTests : InstrumentedTest {\n                     val timeLineEvent = otherSession.getRoom(e2eRoomID)?.getTimelineEvent(sentEventId!!)\n                     timeLineEvent != null &&\n                             timeLineEvent.isEncrypted() &&\n-                            timeLineEvent.root.getClearType() == EventType.MESSAGE\n+                            timeLineEvent.root.getClearType() == EventType.MESSAGE &&\n+                            timeLineEvent.root.mxDecryptionResult?.isSafe == true\n                 }\n             }\n         }\n@@ -331,6 +331,15 @@ class E2eeSanityTests : InstrumentedTest {\n \n         // ensure bob can now decrypt\n         cryptoTestHelper.ensureCanDecrypt(sentEventIds, newBobSession, e2eRoomID, messagesText)\n+\n+        // Check key trust\n+        sentEventIds.forEach { sentEventId ->\n+            val timelineEvent = newBobSession.getRoom(e2eRoomID)?.getTimelineEvent(sentEventId)!!\n+            val result = testHelper.runBlockingTest {\n+                newBobSession.cryptoService().decryptEvent(timelineEvent.root, \"\")\n+            }\n+            assertEquals(\"Keys from history should be deniable\", false, result.isSafe)\n+        }\n     }\n \n     /**\n@@ -379,44 +388,37 @@ class E2eeSanityTests : InstrumentedTest {\n         Log.v(\"#E2E TEST\", \"check that new bob can't currently decrypt\")\n \n         cryptoTestHelper.ensureCannotDecrypt(sentEventIds, newBobSession, e2eRoomID, null)\n-//        newBobSession.cryptoService().getOutgoingRoomKeyRequests()\n-//                .firstOrNull {\n-//                    it.sessionId ==\n-//                }\n \n         // Try to request\n         sentEventIds.forEach { sentEventId ->\n             val event = newBobSession.getRoom(e2eRoomID)!!.getTimelineEvent(sentEventId)!!.root\n             newBobSession.cryptoService().requestRoomKeyForEvent(event)\n         }\n \n-        // wait a bit\n-        // we need to wait a couple of syncs to let sharing occurs\n-//        testHelper.waitFewSyncs(newBobSession, 6)\n-\n         // Ensure that new bob still can't decrypt (keys must have been withheld)\n-        sentEventIds.forEach { sentEventId ->\n-            val megolmSessionId = newBobSession.getRoom(e2eRoomID)!!\n-                    .getTimelineEvent(sentEventId)!!\n-                    .root.content.toModel<EncryptedEventContent>()!!.sessionId\n-            testHelper.waitWithLatch { latch ->\n-                testHelper.retryPeriodicallyWithLatch(latch) {\n-                    val aliceReply = newBobSession.cryptoService().getOutgoingRoomKeyRequests()\n-                            .first {\n-                                it.sessionId == megolmSessionId &&\n-                                        it.roomId == e2eRoomID\n-                            }\n-                            .results.also {\n-                                Log.w(\"##TEST\", \"result list is $it\")\n-                            }\n-                            .firstOrNull { it.userId == aliceSession.myUserId }\n-                            ?.result\n-                    aliceReply != null &&\n-                            aliceReply is RequestResult.Failure &&\n-                            WithHeldCode.UNAUTHORISED == aliceReply.code\n-                }\n-            }\n-        }\n+        // as per new config we won't request to alice, so ignore following test\n+//        sentEventIds.forEach { sentEventId ->\n+//            val megolmSessionId = newBobSession.getRoom(e2eRoomID)!!\n+//                    .getTimelineEvent(sentEventId)!!\n+//                    .root.content.toModel<EncryptedEventContent>()!!.sessionId\n+//            testHelper.waitWithLatch { latch ->\n+//                testHelper.retryPeriodicallyWithLatch(latch) {\n+//                    val aliceReply = newBobSession.cryptoService().getOutgoingRoomKeyRequests()\n+//                            .first {\n+//                                it.sessionId == megolmSessionId &&\n+//                                        it.roomId == e2eRoomID\n+//                            }\n+//                            .results.also {\n+//                                Log.w(\"##TEST\", \"result list is $it\")\n+//                            }\n+//                            .firstOrNull { it.userId == aliceSession.myUserId }\n+//                            ?.result\n+//                    aliceReply != null &&\n+//                            aliceReply is RequestResult.Failure &&\n+//                            WithHeldCode.UNAUTHORISED == aliceReply.code\n+//                }\n+//            }\n+//        }\n \n         cryptoTestHelper.ensureCannotDecrypt(sentEventIds, newBobSession, e2eRoomID, null)\n \n@@ -438,7 +440,10 @@ class E2eeSanityTests : InstrumentedTest {\n      * Test that if a better key is forwarded (lower index, it is then used)\n      */\n     @Test\n-    fun testForwardBetterKey() = runCryptoTest(context()) { cryptoTestHelper, testHelper ->\n+    fun testForwardBetterKey() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, testHelper ->\n \n         val cryptoTestData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom(true)\n         val aliceSession = cryptoTestData.firstSession"
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/internal/crypto/E2eeShareKeysHistoryTest.kt",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -77,6 +77,7 @@ class E2eeShareKeysHistoryTest : InstrumentedTest {\n      */\n     private fun testShareHistoryWithRoomVisibility(roomHistoryVisibility: RoomHistoryVisibility? = null) =\n             runCryptoTest(context()) { cryptoTestHelper, testHelper ->\n+                val aliceMessageText = \"Hello Bob, I am Alice!\"\n                 val cryptoTestData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom(true, roomHistoryVisibility)\n \n                 val e2eRoomID = cryptoTestData.roomId\n@@ -96,7 +97,7 @@ class E2eeShareKeysHistoryTest : InstrumentedTest {\n                 assertEquals(bobRoomPOV.roomSummary()?.joinedMembersCount, 2)\n                 Log.v(\"#E2E TEST\", \"Alice and Bob are in roomId: $e2eRoomID\")\n \n-                val aliceMessageId: String? = sendMessageInRoom(aliceRoomPOV, \"Hello Bob, I am Alice!\", testHelper)\n+                val aliceMessageId: String? = sendMessageInRoom(aliceRoomPOV, aliceMessageText, testHelper)\n                 Assert.assertTrue(\"Message should be sent\", aliceMessageId != null)\n                 Log.v(\"#E2E TEST\", \"Alice sent message to roomId: $e2eRoomID\")\n \n@@ -106,7 +107,8 @@ class E2eeShareKeysHistoryTest : InstrumentedTest {\n                         val timelineEvent = bobSession.roomService().getRoom(e2eRoomID)?.timelineService()?.getTimelineEvent(aliceMessageId!!)\n                         (timelineEvent != null &&\n                                 timelineEvent.isEncrypted() &&\n-                                timelineEvent.root.getClearType() == EventType.MESSAGE).also {\n+                                timelineEvent.root.getClearType() == EventType.MESSAGE &&\n+                                timelineEvent.root.mxDecryptionResult?.isSafe == true).also {\n                             if (it) {\n                                 Log.v(\"#E2E TEST\", \"Bob can decrypt the message: ${timelineEvent?.root?.getDecryptedTextSummary()}\")\n                             }\n@@ -142,7 +144,8 @@ class E2eeShareKeysHistoryTest : InstrumentedTest {\n                                 val timelineEvent = arisSession.roomService().getRoom(e2eRoomID)?.timelineService()?.getTimelineEvent(aliceMessageId!!)\n                                 (timelineEvent != null &&\n                                         timelineEvent.isEncrypted() &&\n-                                        timelineEvent.root.getClearType() == EventType.MESSAGE\n+                                        timelineEvent.root.getClearType() == EventType.MESSAGE &&\n+                                        timelineEvent.root.mxDecryptionResult?.isSafe == false\n                                         ).also {\n                                             if (it) {\n                                                 Log.v(\"#E2E TEST\", \"Aris can decrypt the message: ${timelineEvent?.root?.getDecryptedTextSummary()}\")\n@@ -377,7 +380,10 @@ class E2eeShareKeysHistoryTest : InstrumentedTest {\n     }\n \n     private fun sendMessageInRoom(aliceRoomPOV: Room, text: String, testHelper: CommonTestHelper): String? {\n-        return testHelper.sendTextMessage(aliceRoomPOV, text, 1).firstOrNull()?.eventId\n+        return testHelper.sendTextMessage(aliceRoomPOV, text, 1).firstOrNull()?.let {\n+            Log.v(\"#E2E TEST\", \"Message sent with session ${it.root.content?.get(\"session_id\")}\")\n+            return it.eventId\n+        }\n     }\n \n     private fun ensureMembersHaveJoined(aliceSession: Session, otherAccounts: List<Session>, e2eRoomID: String, testHelper: CommonTestHelper) {"
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/internal/crypto/UnwedgingTest.kt",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -29,6 +29,7 @@ import org.matrix.android.sdk.api.auth.UIABaseAuth\n import org.matrix.android.sdk.api.auth.UserInteractiveAuthInterceptor\n import org.matrix.android.sdk.api.auth.UserPasswordAuth\n import org.matrix.android.sdk.api.auth.registration.RegistrationFlowResponse\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n import org.matrix.android.sdk.api.extensions.tryOrNull\n import org.matrix.android.sdk.api.session.crypto.MXCryptoError\n import org.matrix.android.sdk.api.session.events.model.EventType\n@@ -82,7 +83,10 @@ class UnwedgingTest : InstrumentedTest {\n      * -> This is automatically fixed after SDKs restarted the olm session\n      */\n     @Test\n-    fun testUnwedging() = runCryptoTest(context()) { cryptoTestHelper, testHelper ->\n+    fun testUnwedging() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, testHelper ->\n         val cryptoTestData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom()\n \n         val aliceSession = cryptoTestData.firstSession"
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/internal/crypto/gossiping/KeyShareTests.kt",
          "status": "modified",
          "additions": 57,
          "deletions": 25,
          "patch": "@@ -22,15 +22,16 @@ import androidx.test.filters.LargeTest\n import junit.framework.TestCase.assertNotNull\n import junit.framework.TestCase.assertTrue\n import org.amshove.kluent.internal.assertEquals\n+import org.amshove.kluent.shouldBeEqualTo\n import org.junit.Assert\n import org.junit.Assert.assertNull\n import org.junit.FixMethodOrder\n-import org.junit.Ignore\n-import org.junit.Rule\n import org.junit.Test\n import org.junit.runner.RunWith\n import org.junit.runners.MethodSorters\n import org.matrix.android.sdk.InstrumentedTest\n+import org.matrix.android.sdk.api.crypto.MXCRYPTO_ALGORITHM_OLM\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n import org.matrix.android.sdk.api.session.crypto.OutgoingRoomKeyRequestState\n import org.matrix.android.sdk.api.session.crypto.RequestResult\n import org.matrix.android.sdk.api.session.crypto.crosssigning.DeviceTrustLevel\n@@ -43,24 +44,22 @@ import org.matrix.android.sdk.api.session.room.model.RoomDirectoryVisibility\n import org.matrix.android.sdk.api.session.room.model.create.CreateRoomParams\n import org.matrix.android.sdk.api.session.room.timeline.getLastMessageContent\n import org.matrix.android.sdk.common.CommonTestHelper.Companion.runCryptoTest\n-import org.matrix.android.sdk.common.RetryTestRule\n import org.matrix.android.sdk.common.SessionTestParams\n import org.matrix.android.sdk.common.TestConstants\n import org.matrix.android.sdk.mustFail\n \n @RunWith(AndroidJUnit4::class)\n @FixMethodOrder(MethodSorters.JVM)\n @LargeTest\n-@Ignore\n class KeyShareTests : InstrumentedTest {\n \n-    @get:Rule val rule = RetryTestRule(3)\n+    // @get:Rule val rule = RetryTestRule(3)\n \n     @Test\n     fun test_DoNotSelfShareIfNotTrusted() = runCryptoTest(context()) { cryptoTestHelper, commonTestHelper ->\n \n         val aliceSession = commonTestHelper.createAccount(TestConstants.USER_ALICE, SessionTestParams(true))\n-        Log.v(\"TEST\", \"=======> AliceSession 1 is ${aliceSession.sessionParams.deviceId}\")\n+        Log.v(\"#TEST\", \"=======> AliceSession 1 is ${aliceSession.sessionParams.deviceId}\")\n \n         // Create an encrypted room and add a message\n         val roomId = commonTestHelper.runBlockingTest {\n@@ -86,7 +85,7 @@ class KeyShareTests : InstrumentedTest {\n         aliceSession2.cryptoService().enableKeyGossiping(false)\n         commonTestHelper.syncSession(aliceSession2)\n \n-        Log.v(\"TEST\", \"=======> AliceSession 2 is ${aliceSession2.sessionParams.deviceId}\")\n+        Log.v(\"#TEST\", \"=======> AliceSession 2 is ${aliceSession2.sessionParams.deviceId}\")\n \n         val roomSecondSessionPOV = aliceSession2.getRoom(roomId)\n \n@@ -121,7 +120,7 @@ class KeyShareTests : InstrumentedTest {\n                         }\n             }\n         }\n-        Log.v(\"TEST\", \"=======> Outgoing requet Id is $outGoingRequestId\")\n+        Log.v(\"#TEST\", \"=======> Outgoing requet Id is $outGoingRequestId\")\n \n         val outgoingRequestAfter = aliceSession2.cryptoService().getOutgoingRoomKeyRequests()\n \n@@ -134,14 +133,17 @@ class KeyShareTests : InstrumentedTest {\n         commonTestHelper.waitWithLatch { latch ->\n             commonTestHelper.retryPeriodicallyWithLatch(latch) {\n                 // DEBUG LOGS\n-//                aliceSession.cryptoService().getIncomingRoomKeyRequests().let {\n-//                    Log.v(\"TEST\", \"Incoming request Session 1 (looking for $outGoingRequestId)\")\n-//                    Log.v(\"TEST\", \"=========================\")\n-//                    it.forEach { keyRequest ->\n-//                        Log.v(\"TEST\", \"[ts${keyRequest.localCreationTimestamp}] requestId ${keyRequest.requestId}, for sessionId ${keyRequest.requestBody?.sessionId}\")\n-//                    }\n-//                    Log.v(\"TEST\", \"=========================\")\n-//                }\n+                aliceSession.cryptoService().getIncomingRoomKeyRequests().let {\n+                    Log.v(\"#TEST\", \"Incoming request Session 1 (looking for $outGoingRequestId)\")\n+                    Log.v(\"#TEST\", \"=========================\")\n+                    it.forEach { keyRequest ->\n+                        Log.v(\n+                                \"#TEST\",\n+                                \"[ts${keyRequest.localCreationTimestamp}] requestId ${keyRequest.requestId}, for sessionId ${keyRequest.requestBody?.sessionId}\"\n+                        )\n+                    }\n+                    Log.v(\"#TEST\", \"=========================\")\n+                }\n \n                 val incoming = aliceSession.cryptoService().getIncomingRoomKeyRequests().firstOrNull { it.requestId == outGoingRequestId }\n                 incoming != null\n@@ -152,10 +154,10 @@ class KeyShareTests : InstrumentedTest {\n             commonTestHelper.retryPeriodicallyWithLatch(latch) {\n                 // DEBUG LOGS\n                 aliceSession2.cryptoService().getOutgoingRoomKeyRequests().forEach { keyRequest ->\n-                    Log.v(\"TEST\", \"=========================\")\n-                    Log.v(\"TEST\", \"requestId ${keyRequest.requestId}, for sessionId ${keyRequest.requestBody?.sessionId}\")\n-                    Log.v(\"TEST\", \"replies -> ${keyRequest.results.joinToString { it.toString() }}\")\n-                    Log.v(\"TEST\", \"=========================\")\n+                    Log.v(\"#TEST\", \"=========================\")\n+                    Log.v(\"#TEST\", \"requestId ${keyRequest.requestId}, for sessionId ${keyRequest.requestBody?.sessionId}\")\n+                    Log.v(\"#TEST\", \"replies -> ${keyRequest.results.joinToString { it.toString() }}\")\n+                    Log.v(\"#TEST\", \"=========================\")\n                 }\n \n                 val outgoing = aliceSession2.cryptoService().getOutgoingRoomKeyRequests().firstOrNull { it.requestId == outGoingRequestId }\n@@ -172,11 +174,24 @@ class KeyShareTests : InstrumentedTest {\n         }\n \n         // Mark the device as trusted\n+\n+        Log.v(\"#TEST\", \"=======> Alice device 1 is ${aliceSession.sessionParams.deviceId}|${aliceSession.cryptoService().getMyDevice().identityKey()}\")\n+        val aliceSecondSession = aliceSession2.cryptoService().getMyDevice()\n+        Log.v(\"#TEST\", \"=======> Alice device 2 is ${aliceSession2.sessionParams.deviceId}|${aliceSecondSession.identityKey()}\")\n+\n         aliceSession.cryptoService().setDeviceVerification(\n                 DeviceTrustLevel(crossSigningVerified = false, locallyVerified = true), aliceSession.myUserId,\n                 aliceSession2.sessionParams.deviceId ?: \"\"\n         )\n \n+        // We only accept forwards from trusted session, so we need to trust on other side to\n+        aliceSession2.cryptoService().setDeviceVerification(\n+                DeviceTrustLevel(crossSigningVerified = false, locallyVerified = true), aliceSession.myUserId,\n+                aliceSession.sessionParams.deviceId ?: \"\"\n+        )\n+\n+        aliceSession.cryptoService().deviceWithIdentityKey(aliceSecondSession.identityKey()!!, MXCRYPTO_ALGORITHM_OLM)!!.isVerified shouldBeEqualTo true\n+\n         // Re request\n         aliceSession2.cryptoService().reRequestRoomKeyForEvent(receivedEvent.root)\n \n@@ -193,7 +208,10 @@ class KeyShareTests : InstrumentedTest {\n      * if the key was originally shared with him\n      */\n     @Test\n-    fun test_reShareIfWasIntendedToBeShared() = runCryptoTest(context()) { cryptoTestHelper, commonTestHelper ->\n+    fun test_reShareIfWasIntendedToBeShared() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, commonTestHelper ->\n \n         val testData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom(true)\n         val aliceSession = testData.firstSession\n@@ -224,7 +242,10 @@ class KeyShareTests : InstrumentedTest {\n      * if the key was originally shared with him\n      */\n     @Test\n-    fun test_reShareToUnverifiedIfWasIntendedToBeShared() = runCryptoTest(context()) { cryptoTestHelper, commonTestHelper ->\n+    fun test_reShareToUnverifiedIfWasIntendedToBeShared() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, commonTestHelper ->\n \n         val testData = cryptoTestHelper.doE2ETestWithAliceInARoom(true)\n         val aliceSession = testData.firstSession\n@@ -242,7 +263,6 @@ class KeyShareTests : InstrumentedTest {\n         }\n         val sentEvent = commonTestHelper.sendTextMessage(roomFromAlice, \"Hello\", 1).first()\n         val sentEventMegolmSession = sentEvent.root.content.toModel<EncryptedEventContent>()!!.sessionId!!\n-\n         // Let's try to request any how.\n         // As it was share previously alice should accept to reshare\n         aliceNewSession.cryptoService().reRequestRoomKeyForEvent(sentEvent.root)\n@@ -261,7 +281,10 @@ class KeyShareTests : InstrumentedTest {\n      * Tests that keys reshared with own verified session are done from the earliest known index\n      */\n     @Test\n-    fun test_reShareFromTheEarliestKnownIndexWithOwnVerifiedSession() = runCryptoTest(context()) { cryptoTestHelper, commonTestHelper ->\n+    fun test_reShareFromTheEarliestKnownIndexWithOwnVerifiedSession() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, commonTestHelper ->\n \n         val testData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom(true)\n         val aliceSession = testData.firstSession\n@@ -333,6 +356,9 @@ class KeyShareTests : InstrumentedTest {\n         aliceSession.cryptoService()\n                 .verificationService()\n                 .markedLocallyAsManuallyVerified(aliceNewSession.myUserId, aliceNewSession.sessionParams.deviceId!!)\n+        aliceNewSession.cryptoService()\n+                .verificationService()\n+                .markedLocallyAsManuallyVerified(aliceSession.myUserId, aliceSession.sessionParams.deviceId!!)\n \n         // Let's now try to request\n         aliceNewSession.cryptoService().reRequestRoomKeyForEvent(sentEvents.first().root)\n@@ -381,7 +407,10 @@ class KeyShareTests : InstrumentedTest {\n      * Tests that we don't cancel a request to early on first forward if the index is not good enough\n      */\n     @Test\n-    fun test_dontCancelToEarly() = runCryptoTest(context()) { cryptoTestHelper, commonTestHelper ->\n+    fun test_dontCancelToEarly() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, commonTestHelper ->\n         val testData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom(true)\n         val aliceSession = testData.firstSession\n         val bobSession = testData.secondSession!!\n@@ -421,6 +450,9 @@ class KeyShareTests : InstrumentedTest {\n         aliceSession.cryptoService()\n                 .verificationService()\n                 .markedLocallyAsManuallyVerified(aliceNewSession.myUserId, aliceNewSession.sessionParams.deviceId!!)\n+        aliceNewSession.cryptoService()\n+                .verificationService()\n+                .markedLocallyAsManuallyVerified(aliceSession.myUserId, aliceSession.sessionParams.deviceId!!)\n \n         // /!\\ Stop initial alice session syncing so that it can't reply\n         aliceSession.cryptoService().enableKeyGossiping(false)"
        },
        {
          "filename": "matrix-sdk-android/src/androidTest/java/org/matrix/android/sdk/internal/crypto/gossiping/WithHeldTests.kt",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -27,6 +27,7 @@ import org.junit.runner.RunWith\n import org.junit.runners.MethodSorters\n import org.matrix.android.sdk.InstrumentedTest\n import org.matrix.android.sdk.api.NoOpMatrixCallback\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n import org.matrix.android.sdk.api.extensions.tryOrNull\n import org.matrix.android.sdk.api.session.crypto.MXCryptoError\n import org.matrix.android.sdk.api.session.crypto.RequestResult\n@@ -153,7 +154,10 @@ class WithHeldTests : InstrumentedTest {\n     }\n \n     @Test\n-    fun test_WithHeldNoOlm() = runCryptoTest(context()) { cryptoTestHelper, testHelper ->\n+    fun test_WithHeldNoOlm() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, testHelper ->\n \n         val testData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom()\n         val aliceSession = testData.firstSession\n@@ -233,7 +237,10 @@ class WithHeldTests : InstrumentedTest {\n     }\n \n     @Test\n-    fun test_WithHeldKeyRequest() = runCryptoTest(context()) { cryptoTestHelper, testHelper ->\n+    fun test_WithHeldKeyRequest() = runCryptoTest(\n+            context(),\n+            cryptoConfig = MXCryptoConfig(limitRoomKeyRequestsToMyDevices = false)\n+    ) { cryptoTestHelper, testHelper ->\n \n         val testData = cryptoTestHelper.doE2ETestWithAliceAndBobInARoom()\n         val aliceSession = testData.firstSession"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/crypto/MXCryptoConfig.kt",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -35,8 +35,9 @@ data class MXCryptoConfig constructor(\n \n         /**\n          * Currently megolm keys are requested to the sender device and to all of our devices.\n-         * You can limit request only to your sessions by turning this setting to `true`\n+         * You can limit request only to your sessions by turning this setting to `true`.\n+         * Forwarded keys coming from other users will also be ignored if set to true.\n          */\n-        val limitRoomKeyRequestsToMyDevices: Boolean = false,\n+        val limitRoomKeyRequestsToMyDevices: Boolean = true,\n \n         )"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/query/QueryStringValue.kt",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -68,6 +68,11 @@ sealed interface QueryStringValue {\n      */\n     data class Contains(override val string: String, override val case: Case = Case.SENSITIVE) : ContentQueryStringValue\n \n+    /**\n+     * The tested field must not contain the [string].\n+     */\n+    data class NotContains(override val string: String, override val case: Case = Case.SENSITIVE) : ContentQueryStringValue\n+\n     /**\n      * Case enum for [ContentQueryStringValue].\n      */"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/SessionExtensions.kt",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -32,5 +32,13 @@ fun Session.getRoomSummary(roomIdOrAlias: String): RoomSummary? = roomService().\n \n /**\n  * Get a user using the UserService of a Session.\n+ * @param userId the userId to look for.\n+ * @return a user with userId or null if the User is not known yet by the SDK.\n+ * See [org.matrix.android.sdk.api.session.user.UserService.resolveUser] to ensure that a User is retrieved.\n  */\n fun Session.getUser(userId: String): User? = userService().getUser(userId)\n+\n+/**\n+ * Similar to [getUser], but fallback to a User without details if the User is not known by the SDK, or if Session is null.\n+ */\n+fun Session?.getUserOrDefault(userId: String): User = this?.userService()?.getUser(userId) ?: User(userId)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/crypto/model/MXEventDecryptionResult.kt",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -43,5 +43,7 @@ data class MXEventDecryptionResult(\n          * List of curve25519 keys involved in telling us about the senderCurve25519Key and\n          * claimedEd25519Key. See MXEvent.forwardingCurve25519KeyChain.\n          */\n-        val forwardingCurve25519KeyChain: List<String> = emptyList()\n+        val forwardingCurve25519KeyChain: List<String> = emptyList(),\n+\n+        val isSafe: Boolean = false\n )"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/crypto/model/OlmDecryptionResult.kt",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -44,5 +44,10 @@ data class OlmDecryptionResult(\n         /**\n          * Devices which forwarded this session to us (normally empty).\n          */\n-        @Json(name = \"forwardingCurve25519KeyChain\") val forwardingCurve25519KeyChain: List<String>? = null\n+        @Json(name = \"forwardingCurve25519KeyChain\") val forwardingCurve25519KeyChain: List<String>? = null,\n+\n+        /**\n+         * True if the key used to decrypt is considered safe (trusted).\n+         */\n+        @Json(name = \"key_safety\") val isSafe: Boolean? = null,\n )"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/events/model/Event.kt",
          "status": "modified",
          "additions": 16,
          "deletions": 2,
          "patch": "@@ -174,15 +174,29 @@ data class Event(\n      * @return the event type\n      */\n     fun getClearType(): String {\n-        return mxDecryptionResult?.payload?.get(\"type\")?.toString() ?: type ?: EventType.MISSING_TYPE\n+        return getDecryptedType() ?: type ?: EventType.MISSING_TYPE\n+    }\n+\n+    /**\n+     * @return The decrypted type, or null. Won't fallback to the wired type\n+     */\n+    fun getDecryptedType(): String? {\n+        return mxDecryptionResult?.payload?.get(\"type\")?.toString()\n     }\n \n     /**\n      * @return the event content\n      */\n     fun getClearContent(): Content? {\n+        return getDecryptedContent() ?: content\n+    }\n+\n+    /**\n+     * @return the decrypted event content or null, Won't fallback to the wired content\n+     */\n+    fun getDecryptedContent(): Content? {\n         @Suppress(\"UNCHECKED_CAST\")\n-        return mxDecryptionResult?.payload?.get(\"content\") as? Content ?: content\n+        return mxDecryptionResult?.payload?.get(\"content\") as? Content\n     }\n \n     fun toContentStringWithIndent(): String {"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/Room.kt",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ import org.matrix.android.sdk.api.session.room.call.RoomCallService\n import org.matrix.android.sdk.api.session.room.crypto.RoomCryptoService\n import org.matrix.android.sdk.api.session.room.location.LocationSharingService\n import org.matrix.android.sdk.api.session.room.members.MembershipService\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n import org.matrix.android.sdk.api.session.room.model.relation.RelationService\n import org.matrix.android.sdk.api.session.room.notification.RoomPushRuleService\n@@ -60,11 +61,22 @@ interface Room {\n      */\n     fun getRoomSummaryLive(): LiveData<Optional<RoomSummary>>\n \n+    /**\n+     * A live [LocalRoomSummary] associated with the room.\n+     * You can observe this summary to get dynamic data from this room.\n+     */\n+    fun getLocalRoomSummaryLive(): LiveData<Optional<LocalRoomSummary>>\n+\n     /**\n      * A current snapshot of [RoomSummary] associated with the room.\n      */\n     fun roomSummary(): RoomSummary?\n \n+    /**\n+     * A current snapshot of [LocalRoomSummary] associated with the room.\n+     */\n+    fun localRoomSummary(): LocalRoomSummary?\n+\n     /**\n      * Use this room as a Space, if the type is correct.\n      */"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/RoomService.kt",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ import org.matrix.android.sdk.api.session.events.model.Event\n import org.matrix.android.sdk.api.session.identity.model.SignInvitationResult\n import org.matrix.android.sdk.api.session.room.alias.RoomAliasDescription\n import org.matrix.android.sdk.api.session.room.members.ChangeMembershipState\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n import org.matrix.android.sdk.api.session.room.model.Membership\n import org.matrix.android.sdk.api.session.room.model.RoomMemberSummary\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n@@ -117,6 +118,12 @@ interface RoomService {\n      */\n     fun getRoomSummaryLive(roomId: String): LiveData<Optional<RoomSummary>>\n \n+    /**\n+     * A live [LocalRoomSummary] associated with the room with id [roomId].\n+     * You can observe this summary to get dynamic data from this room, even if the room is not joined yet\n+     */\n+    fun getLocalRoomSummaryLive(roomId: String): LiveData<Optional<LocalRoomSummary>>\n+\n     /**\n      * Get a snapshot list of room summaries.\n      * @return the immutable list of [RoomSummary]"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/RoomSummaryQueryParams.kt",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -20,8 +20,10 @@ import org.matrix.android.sdk.api.query.QueryStringValue\n import org.matrix.android.sdk.api.query.RoomCategoryFilter\n import org.matrix.android.sdk.api.query.RoomTagQueryFilter\n import org.matrix.android.sdk.api.query.SpaceFilter\n+import org.matrix.android.sdk.api.session.room.RoomSummaryQueryParams.Builder\n import org.matrix.android.sdk.api.session.room.model.Membership\n import org.matrix.android.sdk.api.session.room.model.RoomType\n+import org.matrix.android.sdk.api.session.room.model.localecho.RoomLocalEcho\n import org.matrix.android.sdk.api.session.space.SpaceSummaryQueryParams\n \n /**\n@@ -52,6 +54,10 @@ fun spaceSummaryQueryParams(init: (RoomSummaryQueryParams.Builder.() -> Unit) =\n  * [roomSummaryQueryParams] and [spaceSummaryQueryParams] can also be used to build an instance of this class.\n  */\n data class RoomSummaryQueryParams(\n+        /**\n+         * Query for the roomId.\n+         */\n+        val roomId: QueryStringValue,\n         /**\n          * Query for the displayName of the room. The display name can be the value of the state event,\n          * or a value returned by [org.matrix.android.sdk.api.RoomDisplayNameFallbackProvider].\n@@ -94,6 +100,7 @@ data class RoomSummaryQueryParams(\n      * [roomSummaryQueryParams] and [spaceSummaryQueryParams] can also be used to build an instance of [RoomSummaryQueryParams].\n      */\n     class Builder {\n+        var roomId: QueryStringValue = QueryStringValue.NotContains(RoomLocalEcho.PREFIX)\n         var displayName: QueryStringValue = QueryStringValue.NoCondition\n         var canonicalAlias: QueryStringValue = QueryStringValue.NoCondition\n         var memberships: List<Membership> = Membership.all()\n@@ -104,6 +111,7 @@ data class RoomSummaryQueryParams(\n         var spaceFilter: SpaceFilter = SpaceFilter.NoFilter\n \n         fun build() = RoomSummaryQueryParams(\n+                roomId = roomId,\n                 displayName = displayName,\n                 canonicalAlias = canonicalAlias,\n                 memberships = memberships,"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/model/LocalRoomCreationState.kt",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.api.session.room.model\n+\n+enum class LocalRoomCreationState {\n+    NOT_CREATED,\n+    CREATING,\n+    FAILURE,\n+    CREATED\n+}"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/model/LocalRoomSummary.kt",
          "status": "added",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.api.session.room.model\n+\n+import org.matrix.android.sdk.api.session.room.model.create.CreateRoomParams\n+\n+/**\n+ * This class holds some data of a local room.\n+ * It can be retrieved by [org.matrix.android.sdk.api.session.room.Room] and [org.matrix.android.sdk.api.session.room.RoomService]\n+ */\n+data class LocalRoomSummary(\n+        /**\n+         * The roomId of the room.\n+         */\n+        val roomId: String,\n+        /**\n+         * The room summary of the room.\n+         */\n+        val roomSummary: RoomSummary?,\n+        /**\n+         * The creation params attached to the room.\n+         */\n+        val createRoomParams: CreateRoomParams?,\n+        /**\n+         * The roomId of the created room (ie. created on the server), if any.\n+         */\n+        val replacementRoomId: String?,\n+        /**\n+         * The creation state of the room.\n+         */\n+        val creationState: LocalRoomCreationState,\n+)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/model/SpaceChildInfo.kt",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -34,5 +34,4 @@ data class SpaceChildInfo(\n         val canonicalAlias: String?,\n         val aliases: List<String>?,\n         val worldReadable: Boolean\n-\n )"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/room/model/localecho/RoomLocalEcho.kt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -20,7 +20,7 @@ import java.util.UUID\n \n object RoomLocalEcho {\n \n-    private const val PREFIX = \"!local.\"\n+    const val PREFIX = \"!local.\"\n \n     /**\n      * Tell whether the provider room id is a local id."
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/space/SpaceHierarchyData.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -16,13 +16,13 @@\n \n package org.matrix.android.sdk.api.session.space\n \n-import org.matrix.android.sdk.api.session.events.model.Event\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n import org.matrix.android.sdk.api.session.room.model.SpaceChildInfo\n+import org.matrix.android.sdk.api.session.space.model.SpaceChildSummaryEvent\n \n data class SpaceHierarchyData(\n         val rootSummary: RoomSummary,\n         val children: List<SpaceChildInfo>,\n-        val childrenState: List<Event>,\n+        val childrenState: List<SpaceChildSummaryEvent>,\n         val nextToken: String? = null\n )"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/space/SpaceService.kt",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -18,10 +18,10 @@ package org.matrix.android.sdk.api.session.space\n \n import android.net.Uri\n import androidx.lifecycle.LiveData\n-import org.matrix.android.sdk.api.session.events.model.Event\n import org.matrix.android.sdk.api.session.room.RoomSortOrder\n import org.matrix.android.sdk.api.session.room.RoomSummaryQueryParams\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n+import org.matrix.android.sdk.api.session.space.model.SpaceChildSummaryEvent\n import org.matrix.android.sdk.api.session.space.peeking.SpacePeekResult\n \n typealias SpaceSummaryQueryParams = RoomSummaryQueryParams\n@@ -75,12 +75,12 @@ interface SpaceService {\n             suggestedOnly: Boolean? = null,\n             limit: Int? = null,\n             from: String? = null,\n-            knownStateList: List<Event>? = null\n+            knownStateList: List<SpaceChildSummaryEvent>? = null\n     ): SpaceHierarchyData\n \n     /**\n      * Get a live list of space summaries. This list is refreshed as soon as the data changes.\n-     * @return the [LiveData] of List[SpaceSummary]\n+     * @return the [LiveData] of List[RoomSummary]\n      */\n     fun getSpaceSummariesLive(\n             queryParams: SpaceSummaryQueryParams,"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/space/model/SpaceChildSummaryEvent.kt",
          "status": "added",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright (c) 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.api.session.space.model\n+\n+import com.squareup.moshi.Json\n+import com.squareup.moshi.JsonClass\n+import org.matrix.android.sdk.api.session.events.model.Content\n+\n+@JsonClass(generateAdapter = true)\n+data class SpaceChildSummaryEvent(\n+        @Json(name = \"type\") val type: String? = null,\n+        @Json(name = \"state_key\") val stateKey: String? = null,\n+        @Json(name = \"content\") val content: Content? = null,\n+        @Json(name = \"sender\") val senderId: String? = null,\n+        @Json(name = \"origin_server_ts\") val originServerTs: Long? = null,\n+)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/api/session/user/UserService.kt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -29,7 +29,7 @@ interface UserService {\n     /**\n      * Get a user from a userId.\n      * @param userId the userId to look for.\n-     * @return a user with userId or null\n+     * @return a user with userId or null if the User is not known yet by the SDK. See [resolveUser] to ensure that a User is retrieved.\n      */\n     fun getUser(userId: String): User?\n "
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/DefaultCryptoService.kt",
          "status": "modified",
          "additions": 25,
          "deletions": 5,
          "patch": "@@ -79,6 +79,7 @@ import org.matrix.android.sdk.internal.crypto.actions.SetDeviceVerificationActio\n import org.matrix.android.sdk.internal.crypto.algorithms.IMXEncrypting\n import org.matrix.android.sdk.internal.crypto.algorithms.IMXGroupEncryption\n import org.matrix.android.sdk.internal.crypto.algorithms.megolm.MXMegolmEncryptionFactory\n+import org.matrix.android.sdk.internal.crypto.algorithms.megolm.UnRequestedForwardManager\n import org.matrix.android.sdk.internal.crypto.algorithms.olm.MXOlmEncryptionFactory\n import org.matrix.android.sdk.internal.crypto.crosssigning.DefaultCrossSigningService\n import org.matrix.android.sdk.internal.crypto.keysbackup.DefaultKeysBackupService\n@@ -183,7 +184,8 @@ internal class DefaultCryptoService @Inject constructor(\n         private val cryptoCoroutineScope: CoroutineScope,\n         private val eventDecryptor: EventDecryptor,\n         private val verificationMessageProcessor: VerificationMessageProcessor,\n-        private val liveEventManager: Lazy<StreamEventsManager>\n+        private val liveEventManager: Lazy<StreamEventsManager>,\n+        private val unrequestedForwardManager: UnRequestedForwardManager,\n ) : CryptoService {\n \n     private val isStarting = AtomicBoolean(false)\n@@ -399,6 +401,7 @@ internal class DefaultCryptoService @Inject constructor(\n         cryptoCoroutineScope.coroutineContext.cancelChildren(CancellationException(\"Closing crypto module\"))\n         incomingKeyRequestManager.close()\n         outgoingKeyRequestManager.close()\n+        unrequestedForwardManager.close()\n         olmDevice.release()\n         cryptoStore.close()\n     }\n@@ -485,6 +488,14 @@ internal class DefaultCryptoService @Inject constructor(\n                     // just for safety but should not throw\n                     Timber.tag(loggerTag.value).w(\"failed to process incoming room key requests\")\n                 }\n+\n+                unrequestedForwardManager.postSyncProcessParkedKeysIfNeeded(clock.epochMillis()) { events ->\n+                    cryptoCoroutineScope.launch(coroutineDispatchers.crypto) {\n+                        events.forEach {\n+                            onRoomKeyEvent(it, true)\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -845,9 +856,9 @@ internal class DefaultCryptoService @Inject constructor(\n      *\n      * @param event the key event.\n      */\n-    private fun onRoomKeyEvent(event: Event) {\n-        val roomKeyContent = event.getClearContent().toModel<RoomKeyContent>() ?: return\n-        Timber.tag(loggerTag.value).i(\"onRoomKeyEvent() from: ${event.senderId} type<${event.getClearType()}> , sessionId<${roomKeyContent.sessionId}>\")\n+    private fun onRoomKeyEvent(event: Event, acceptUnrequested: Boolean = false) {\n+        val roomKeyContent = event.getDecryptedContent().toModel<RoomKeyContent>() ?: return\n+        Timber.tag(loggerTag.value).i(\"onRoomKeyEvent(forceAccept:$acceptUnrequested) from: ${event.senderId} type<${event.getClearType()}> , sessionId<${roomKeyContent.sessionId}>\")\n         if (roomKeyContent.roomId.isNullOrEmpty() || roomKeyContent.algorithm.isNullOrEmpty()) {\n             Timber.tag(loggerTag.value).e(\"onRoomKeyEvent() : missing fields\")\n             return\n@@ -857,7 +868,7 @@ internal class DefaultCryptoService @Inject constructor(\n             Timber.tag(loggerTag.value).e(\"GOSSIP onRoomKeyEvent() : Unable to handle keys for ${roomKeyContent.algorithm}\")\n             return\n         }\n-        alg.onRoomKeyEvent(event, keysBackupService)\n+        alg.onRoomKeyEvent(event, keysBackupService, acceptUnrequested)\n     }\n \n     private fun onKeyWithHeldReceived(event: Event) {\n@@ -950,6 +961,15 @@ internal class DefaultCryptoService @Inject constructor(\n      * @param event the membership event causing the change\n      */\n     private fun onRoomMembershipEvent(roomId: String, event: Event) {\n+        // because the encryption event can be after the join/invite in the same batch\n+        event.stateKey?.let { _ ->\n+            val roomMember: RoomMemberContent? = event.content.toModel()\n+            val membership = roomMember?.membership\n+            if (membership == Membership.INVITE) {\n+                unrequestedForwardManager.onInviteReceived(roomId, event.senderId.orEmpty(), clock.epochMillis())\n+            }\n+        }\n+\n         roomEncryptorsStore.get(roomId) ?: /* No encrypting in this room */ return\n \n         event.stateKey?.let { userId ->"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/InboundGroupSessionStore.kt",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -91,6 +91,21 @@ internal class InboundGroupSessionStore @Inject constructor(\n         internalStoreGroupSession(new, sessionId, senderKey)\n     }\n \n+    @Synchronized\n+    fun updateToSafe(old: InboundGroupSessionHolder, sessionId: String, senderKey: String) {\n+        Timber.tag(loggerTag.value).v(\"## updateToSafe for session ${old.wrapper.roomId}-${old.wrapper.senderKey}\")\n+\n+        store.storeInboundGroupSessions(\n+                listOf(\n+                        old.wrapper.copy(\n+                                sessionData = old.wrapper.sessionData.copy(trusted = true)\n+                        )\n+                )\n+        )\n+        // will release it :/\n+        sessionCache.remove(CacheKey(sessionId, senderKey))\n+    }\n+\n     @Synchronized\n     fun storeInBoundGroupSession(holder: InboundGroupSessionHolder, sessionId: String, senderKey: String) {\n         internalStoreGroupSession(holder, sessionId, senderKey)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/MXOlmDevice.kt",
          "status": "modified",
          "additions": 50,
          "deletions": 16,
          "patch": "@@ -19,6 +19,7 @@ package org.matrix.android.sdk.internal.crypto\n import androidx.annotation.VisibleForTesting\n import kotlinx.coroutines.sync.Mutex\n import kotlinx.coroutines.sync.withLock\n+import org.matrix.android.sdk.api.extensions.orFalse\n import org.matrix.android.sdk.api.extensions.tryOrNull\n import org.matrix.android.sdk.api.logger.LoggerTag\n import org.matrix.android.sdk.api.session.crypto.MXCryptoError\n@@ -612,14 +613,17 @@ internal class MXOlmDevice @Inject constructor(\n             forwardingCurve25519KeyChain: List<String>,\n             keysClaimed: Map<String, String>,\n             exportFormat: Boolean,\n-            sharedHistory: Boolean\n+            sharedHistory: Boolean,\n+            trusted: Boolean\n     ): AddSessionResult {\n         val candidateSession = tryOrNull(\"Failed to create inbound session in room $roomId\") {\n             if (exportFormat) {\n                 OlmInboundGroupSession.importSession(sessionKey)\n             } else {\n                 OlmInboundGroupSession(sessionKey)\n             }\n+        } ?: return AddSessionResult.NotImported.also {\n+            Timber.tag(loggerTag.value).d(\"## addInboundGroupSession() : failed to import key candidate $senderKey/$sessionId\")\n         }\n \n         val existingSessionHolder = tryOrNull { getInboundGroupSession(sessionId, senderKey, roomId) }\n@@ -631,31 +635,49 @@ internal class MXOlmDevice @Inject constructor(\n                 val existingFirstKnown = tryOrNull { existingSession.session.firstKnownIndex } ?: return AddSessionResult.NotImported.also {\n                     // This is quite unexpected, could throw if native was released?\n                     Timber.tag(loggerTag.value).e(\"## addInboundGroupSession() null firstKnownIndex on existing session\")\n-                    candidateSession?.releaseSession()\n+                    candidateSession.releaseSession()\n                     // Probably should discard it?\n                 }\n-                val newKnownFirstIndex = tryOrNull(\"Failed to get candidate first known index\") { candidateSession?.firstKnownIndex }\n-                // If our existing session is better we keep it\n-                if (newKnownFirstIndex != null && existingFirstKnown <= newKnownFirstIndex) {\n-                    Timber.tag(loggerTag.value).d(\"## addInboundGroupSession() : ignore session our is better $senderKey/$sessionId\")\n-                    candidateSession?.releaseSession()\n-                    return AddSessionResult.NotImportedHigherIndex(newKnownFirstIndex.toInt())\n+                val newKnownFirstIndex = tryOrNull(\"Failed to get candidate first known index\") { candidateSession.firstKnownIndex }\n+                        ?: return AddSessionResult.NotImported.also {\n+                            candidateSession.releaseSession()\n+                            Timber.tag(loggerTag.value).d(\"## addInboundGroupSession() : Failed to get new session index\")\n+                        }\n+\n+                val keyConnects = existingSession.session.connects(candidateSession)\n+                if (!keyConnects) {\n+                    Timber.tag(loggerTag.value)\n+                            .e(\"## addInboundGroupSession() Unconnected key\")\n+                    if (!trusted) {\n+                        // Ignore the not connecting unsafe, keep existing\n+                        Timber.tag(loggerTag.value)\n+                                .e(\"## addInboundGroupSession() Received unsafe unconnected key\")\n+                        return AddSessionResult.NotImported\n+                    }\n+                    // else if the new one is safe and does not connect with existing, import the new one\n+                } else {\n+                    // If our existing session is better we keep it\n+                    if (existingFirstKnown <= newKnownFirstIndex) {\n+                        val shouldUpdateTrust = trusted && (existingSession.sessionData.trusted != true)\n+                        Timber.tag(loggerTag.value).d(\"## addInboundGroupSession() : updateTrust for $sessionId\")\n+                        if (shouldUpdateTrust) {\n+                            // the existing as a better index but the new one is trusted so update trust\n+                            inboundGroupSessionStore.updateToSafe(existingSessionHolder, sessionId, senderKey)\n+                        }\n+                        Timber.tag(loggerTag.value).d(\"## addInboundGroupSession() : ignore session our is better $senderKey/$sessionId\")\n+                        candidateSession.releaseSession()\n+                        return AddSessionResult.NotImportedHigherIndex(newKnownFirstIndex.toInt())\n+                    }\n                 }\n             } catch (failure: Throwable) {\n                 Timber.tag(loggerTag.value).e(\"## addInboundGroupSession() Failed to add inbound: ${failure.localizedMessage}\")\n-                candidateSession?.releaseSession()\n+                candidateSession.releaseSession()\n                 return AddSessionResult.NotImported\n             }\n         }\n \n         Timber.tag(loggerTag.value).d(\"## addInboundGroupSession() : Candidate session should be added $senderKey/$sessionId\")\n \n-        // sanity check on the new session\n-        if (null == candidateSession) {\n-            Timber.tag(loggerTag.value).e(\"## addInboundGroupSession : invalid session <null>\")\n-            return AddSessionResult.NotImported\n-        }\n-\n         try {\n             if (candidateSession.sessionIdentifier() != sessionId) {\n                 Timber.tag(loggerTag.value).e(\"## addInboundGroupSession : ERROR: Mismatched group session ID from senderKey: $senderKey\")\n@@ -674,6 +696,7 @@ internal class MXOlmDevice @Inject constructor(\n                 keysClaimed = keysClaimed,\n                 forwardingCurve25519KeyChain = forwardingCurve25519KeyChain,\n                 sharedHistory = sharedHistory,\n+                trusted = trusted\n         )\n \n         val wrapper = MXInboundMegolmSessionWrapper(\n@@ -689,6 +712,16 @@ internal class MXOlmDevice @Inject constructor(\n         return AddSessionResult.Imported(candidateSession.firstKnownIndex.toInt())\n     }\n \n+    fun OlmInboundGroupSession.connects(other: OlmInboundGroupSession): Boolean {\n+        return try {\n+            val lowestCommonIndex = this.firstKnownIndex.coerceAtLeast(other.firstKnownIndex)\n+            this.export(lowestCommonIndex) == other.export(lowestCommonIndex)\n+        } catch (failure: Throwable) {\n+            // native error? key disposed?\n+            false\n+        }\n+    }\n+\n     /**\n      * Import an inbound group sessions to the session store.\n      *\n@@ -821,7 +854,8 @@ internal class MXOlmDevice @Inject constructor(\n                 payload,\n                 wrapper.sessionData.keysClaimed,\n                 senderKey,\n-                wrapper.sessionData.forwardingCurve25519KeyChain\n+                wrapper.sessionData.forwardingCurve25519KeyChain,\n+                isSafe = sessionHolder.wrapper.sessionData.trusted.orFalse()\n         )\n     }\n "
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/SecretShareManager.kt",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -267,13 +267,24 @@ internal class SecretShareManager @Inject constructor(\n             Timber.tag(loggerTag.value).e(\"onSecretSend() :Received unencrypted secret send event\")\n             return\n         }\n+        // no need to download keys, after a verification we already forced download\n+        val sendingDevice = toDevice.getSenderKey()?.let { cryptoStore.deviceWithIdentityKey(it) }\n+        if (sendingDevice == null) {\n+            Timber.tag(loggerTag.value).e(\"onSecretSend() : Ignore secret from unknown  device ${toDevice.getSenderKey()}\")\n+            return\n+        }\n \n         // Was that sent by us?\n-        if (toDevice.senderId != credentials.userId) {\n+        if (sendingDevice.userId != credentials.userId) {\n             Timber.tag(loggerTag.value).e(\"onSecretSend() : Ignore secret from other user ${toDevice.senderId}\")\n             return\n         }\n \n+        if (!sendingDevice.isVerified) {\n+            Timber.tag(loggerTag.value).e(\"onSecretSend() : Ignore secret from untrusted device ${toDevice.getSenderKey()}\")\n+            return\n+        }\n+\n         val secretContent = toDevice.getClearContent().toModel<SecretSendEventContent>() ?: return\n \n         val existingRequest = verifMutex.withLock {"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/algorithms/IMXDecrypting.kt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -42,5 +42,5 @@ internal interface IMXDecrypting {\n      * @param event the key event.\n      * @param defaultKeysBackupService the keys backup service\n      */\n-    fun onRoomKeyEvent(event: Event, defaultKeysBackupService: DefaultKeysBackupService) {}\n+    fun onRoomKeyEvent(event: Event, defaultKeysBackupService: DefaultKeysBackupService, forceAccept: Boolean = false) {}\n }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/algorithms/megolm/MXMegolmDecryption.kt",
          "status": "modified",
          "additions": 82,
          "deletions": 40,
          "patch": "@@ -17,7 +17,8 @@\n package org.matrix.android.sdk.internal.crypto.algorithms.megolm\n \n import dagger.Lazy\n-import org.matrix.android.sdk.api.MatrixConfiguration\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n+import org.matrix.android.sdk.api.extensions.orFalse\n import org.matrix.android.sdk.api.logger.LoggerTag\n import org.matrix.android.sdk.api.session.crypto.MXCryptoError\n import org.matrix.android.sdk.api.session.crypto.NewSessionListener\n@@ -34,16 +35,20 @@ import org.matrix.android.sdk.internal.crypto.algorithms.IMXDecrypting\n import org.matrix.android.sdk.internal.crypto.keysbackup.DefaultKeysBackupService\n import org.matrix.android.sdk.internal.crypto.store.IMXCryptoStore\n import org.matrix.android.sdk.internal.session.StreamEventsManager\n+import org.matrix.android.sdk.internal.util.time.Clock\n import timber.log.Timber\n \n private val loggerTag = LoggerTag(\"MXMegolmDecryption\", LoggerTag.CRYPTO)\n \n internal class MXMegolmDecryption(\n         private val olmDevice: MXOlmDevice,\n+        private val myUserId: String,\n         private val outgoingKeyRequestManager: OutgoingKeyRequestManager,\n         private val cryptoStore: IMXCryptoStore,\n-        private val matrixConfiguration: MatrixConfiguration,\n-        private val liveEventManager: Lazy<StreamEventsManager>\n+        private val liveEventManager: Lazy<StreamEventsManager>,\n+        private val unrequestedForwardManager: UnRequestedForwardManager,\n+        private val cryptoConfig: MXCryptoConfig,\n+        private val clock: Clock,\n ) : IMXDecrypting {\n \n     var newSessionListener: NewSessionListener? = null\n@@ -94,7 +99,8 @@ internal class MXMegolmDecryption(\n                                         senderCurve25519Key = olmDecryptionResult.senderKey,\n                                         claimedEd25519Key = olmDecryptionResult.keysClaimed?.get(\"ed25519\"),\n                                         forwardingCurve25519KeyChain = olmDecryptionResult.forwardingCurve25519KeyChain\n-                                                .orEmpty()\n+                                                .orEmpty(),\n+                                        isSafe = olmDecryptionResult.isSafe.orFalse()\n                                 ).also {\n                                     liveEventManager.get().dispatchLiveEventDecrypted(event, it)\n                                 }\n@@ -182,45 +188,47 @@ internal class MXMegolmDecryption(\n      * @param event the key event.\n      * @param defaultKeysBackupService the keys backup service\n      */\n-    override fun onRoomKeyEvent(event: Event, defaultKeysBackupService: DefaultKeysBackupService) {\n-        Timber.tag(loggerTag.value).v(\"onRoomKeyEvent()\")\n+    override fun onRoomKeyEvent(event: Event, defaultKeysBackupService: DefaultKeysBackupService, forceAccept: Boolean) {\n+        Timber.tag(loggerTag.value).v(\"onRoomKeyEvent(${event.getSenderKey()})\")\n         var exportFormat = false\n-        val roomKeyContent = event.getClearContent().toModel<RoomKeyContent>() ?: return\n+        val roomKeyContent = event.getDecryptedContent()?.toModel<RoomKeyContent>() ?: return\n+\n+        val eventSenderKey: String = event.getSenderKey() ?: return Unit.also {\n+            Timber.tag(loggerTag.value).e(\"onRoom Key/Forward Event() : event is missing sender_key field\")\n+        }\n+\n+        // this device might not been downloaded now?\n+        val fromDevice = cryptoStore.deviceWithIdentityKey(eventSenderKey)\n+\n+        lateinit var sessionInitiatorSenderKey: String\n+        val trusted: Boolean\n \n-        var senderKey: String? = event.getSenderKey()\n         var keysClaimed: MutableMap<String, String> = HashMap()\n         val forwardingCurve25519KeyChain: MutableList<String> = ArrayList()\n \n         if (roomKeyContent.roomId.isNullOrEmpty() || roomKeyContent.sessionId.isNullOrEmpty() || roomKeyContent.sessionKey.isNullOrEmpty()) {\n             Timber.tag(loggerTag.value).e(\"onRoomKeyEvent() :  Key event is missing fields\")\n             return\n         }\n-        if (event.getClearType() == EventType.FORWARDED_ROOM_KEY) {\n+        if (event.getDecryptedType() == EventType.FORWARDED_ROOM_KEY) {\n             if (!cryptoStore.isKeyGossipingEnabled()) {\n                 Timber.tag(loggerTag.value)\n                         .i(\"onRoomKeyEvent(), ignore forward adding as per crypto config : ${roomKeyContent.roomId}|${roomKeyContent.sessionId}\")\n                 return\n             }\n             Timber.tag(loggerTag.value).i(\"onRoomKeyEvent(), forward adding key : ${roomKeyContent.roomId}|${roomKeyContent.sessionId}\")\n-            val forwardedRoomKeyContent = event.getClearContent().toModel<ForwardedRoomKeyContent>()\n+            val forwardedRoomKeyContent = event.getDecryptedContent()?.toModel<ForwardedRoomKeyContent>()\n                     ?: return\n \n             forwardedRoomKeyContent.forwardingCurve25519KeyChain?.let {\n                 forwardingCurve25519KeyChain.addAll(it)\n             }\n \n-            if (senderKey == null) {\n-                Timber.tag(loggerTag.value).e(\"onRoomKeyEvent() : event is missing sender_key field\")\n-                return\n-            }\n-\n-            forwardingCurve25519KeyChain.add(senderKey)\n+            forwardingCurve25519KeyChain.add(eventSenderKey)\n \n             exportFormat = true\n-            senderKey = forwardedRoomKeyContent.senderKey\n-            if (null == senderKey) {\n+            sessionInitiatorSenderKey = forwardedRoomKeyContent.senderKey ?: return Unit.also {\n                 Timber.tag(loggerTag.value).e(\"onRoomKeyEvent() : forwarded_room_key event is missing sender_key field\")\n-                return\n             }\n \n             if (null == forwardedRoomKeyContent.senderClaimedEd25519Key) {\n@@ -229,13 +237,51 @@ internal class MXMegolmDecryption(\n             }\n \n             keysClaimed[\"ed25519\"] = forwardedRoomKeyContent.senderClaimedEd25519Key\n-        } else {\n-            Timber.tag(loggerTag.value).i(\"onRoomKeyEvent(), Adding key : ${roomKeyContent.roomId}|${roomKeyContent.sessionId}\")\n-            if (null == senderKey) {\n-                Timber.tag(loggerTag.value).e(\"## onRoomKeyEvent() : key event has no sender key (not encrypted?)\")\n+\n+            // checking if was requested once.\n+            // should we check if the request is sort of active?\n+            val wasNotRequested = cryptoStore.getOutgoingRoomKeyRequest(\n+                    roomId = forwardedRoomKeyContent.roomId.orEmpty(),\n+                    sessionId = forwardedRoomKeyContent.sessionId.orEmpty(),\n+                    algorithm = forwardedRoomKeyContent.algorithm.orEmpty(),\n+                    senderKey = forwardedRoomKeyContent.senderKey.orEmpty(),\n+            ).isEmpty()\n+\n+            trusted = false\n+\n+            if (!forceAccept && wasNotRequested) {\n+//                val senderId = cryptoStore.deviceWithIdentityKey(event.getSenderKey().orEmpty())?.userId.orEmpty()\n+                unrequestedForwardManager.onUnRequestedKeyForward(roomKeyContent.roomId, event, clock.epochMillis())\n+                // Ignore unsolicited\n+                Timber.tag(loggerTag.value).w(\"Ignoring forwarded_room_key_event for ${roomKeyContent.sessionId} that was not requested\")\n+                return\n+            }\n+\n+            // Check who sent the request, as we requested we have the device keys (no need to download)\n+            val sessionThatIsSharing = cryptoStore.deviceWithIdentityKey(eventSenderKey)\n+            if (sessionThatIsSharing == null) {\n+                Timber.tag(loggerTag.value).w(\"Ignoring forwarded_room_key from unknown device with identity $eventSenderKey\")\n                 return\n             }\n+            val isOwnDevice = myUserId == sessionThatIsSharing.userId\n+            val isDeviceVerified = sessionThatIsSharing.isVerified\n+            val isFromSessionInitiator = sessionThatIsSharing.identityKey() == sessionInitiatorSenderKey\n+\n+            val isLegitForward = (isOwnDevice && isDeviceVerified) ||\n+                    (!cryptoConfig.limitRoomKeyRequestsToMyDevices && isFromSessionInitiator)\n \n+            val shouldAcceptForward = forceAccept || isLegitForward\n+\n+            if (!shouldAcceptForward) {\n+                Timber.tag(loggerTag.value)\n+                        .w(\"Ignoring forwarded_room_key device:$eventSenderKey, ownVerified:{$isOwnDevice&&$isDeviceVerified}, fromInitiator:$isFromSessionInitiator\")\n+                return\n+            }\n+        } else {\n+            // It's a m.room_key so safe\n+            trusted = true\n+            sessionInitiatorSenderKey = eventSenderKey\n+            Timber.tag(loggerTag.value).i(\"onRoomKeyEvent(), Adding key : ${roomKeyContent.roomId}|${roomKeyContent.sessionId}\")\n             // inherit the claimed ed25519 key from the setup message\n             keysClaimed = event.getKeysClaimed().toMutableMap()\n         }\n@@ -245,48 +291,44 @@ internal class MXMegolmDecryption(\n                 sessionId = roomKeyContent.sessionId,\n                 sessionKey = roomKeyContent.sessionKey,\n                 roomId = roomKeyContent.roomId,\n-                senderKey = senderKey,\n+                senderKey = sessionInitiatorSenderKey,\n                 forwardingCurve25519KeyChain = forwardingCurve25519KeyChain,\n                 keysClaimed = keysClaimed,\n                 exportFormat = exportFormat,\n-                sharedHistory = roomKeyContent.getSharedKey()\n-        )\n+                sharedHistory = roomKeyContent.getSharedKey(),\n+                trusted = trusted\n+        ).also {\n+            Timber.tag(loggerTag.value).v(\".. onRoomKeyEvent addInboundGroupSession ${roomKeyContent.sessionId} result: $it\")\n+        }\n \n         when (addSessionResult) {\n             is MXOlmDevice.AddSessionResult.Imported -> addSessionResult.ratchetIndex\n             is MXOlmDevice.AddSessionResult.NotImportedHigherIndex -> addSessionResult.newIndex\n             else -> null\n         }?.let { index ->\n             if (event.getClearType() == EventType.FORWARDED_ROOM_KEY) {\n-                val fromDevice = (event.content?.get(\"sender_key\") as? String)?.let { senderDeviceIdentityKey ->\n-                    cryptoStore.getUserDeviceList(event.senderId ?: \"\")\n-                            ?.firstOrNull {\n-                                it.identityKey() == senderDeviceIdentityKey\n-                            }\n-                }?.deviceId\n-\n                 outgoingKeyRequestManager.onRoomKeyForwarded(\n                         sessionId = roomKeyContent.sessionId,\n                         algorithm = roomKeyContent.algorithm ?: \"\",\n                         roomId = roomKeyContent.roomId,\n-                        senderKey = senderKey,\n+                        senderKey = sessionInitiatorSenderKey,\n                         fromIndex = index,\n-                        fromDevice = fromDevice,\n+                        fromDevice = fromDevice?.deviceId,\n                         event = event\n                 )\n \n                 cryptoStore.saveIncomingForwardKeyAuditTrail(\n                         roomId = roomKeyContent.roomId,\n                         sessionId = roomKeyContent.sessionId,\n-                        senderKey = senderKey,\n+                        senderKey = sessionInitiatorSenderKey,\n                         algorithm = roomKeyContent.algorithm ?: \"\",\n-                        userId = event.senderId ?: \"\",\n-                        deviceId = fromDevice ?: \"\",\n+                        userId = event.senderId.orEmpty(),\n+                        deviceId = fromDevice?.deviceId.orEmpty(),\n                         chainIndex = index.toLong()\n                 )\n \n                 // The index is used to decide if we cancel sent request or if we wait for a better key\n-                outgoingKeyRequestManager.postCancelRequestForSessionIfNeeded(roomKeyContent.sessionId, roomKeyContent.roomId, senderKey, index)\n+                outgoingKeyRequestManager.postCancelRequestForSessionIfNeeded(roomKeyContent.sessionId, roomKeyContent.roomId, sessionInitiatorSenderKey, index)\n             }\n         }\n \n@@ -295,7 +337,7 @@ internal class MXMegolmDecryption(\n                     .d(\"onRoomKeyEvent(${event.getClearType()}) : Added megolm session ${roomKeyContent.sessionId} in ${roomKeyContent.roomId}\")\n             defaultKeysBackupService.maybeBackupKeys()\n \n-            onNewSession(roomKeyContent.roomId, senderKey, roomKeyContent.sessionId)\n+            onNewSession(roomKeyContent.roomId, sessionInitiatorSenderKey, roomKeyContent.sessionId)\n         }\n     }\n "
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/algorithms/megolm/MXMegolmDecryptionFactory.kt",
          "status": "modified",
          "additions": 16,
          "deletions": 8,
          "patch": "@@ -17,28 +17,36 @@\n package org.matrix.android.sdk.internal.crypto.algorithms.megolm\n \n import dagger.Lazy\n-import org.matrix.android.sdk.api.MatrixConfiguration\n+import org.matrix.android.sdk.api.crypto.MXCryptoConfig\n import org.matrix.android.sdk.internal.crypto.MXOlmDevice\n import org.matrix.android.sdk.internal.crypto.OutgoingKeyRequestManager\n import org.matrix.android.sdk.internal.crypto.store.IMXCryptoStore\n+import org.matrix.android.sdk.internal.di.UserId\n import org.matrix.android.sdk.internal.session.StreamEventsManager\n+import org.matrix.android.sdk.internal.util.time.Clock\n import javax.inject.Inject\n \n internal class MXMegolmDecryptionFactory @Inject constructor(\n         private val olmDevice: MXOlmDevice,\n+        @UserId private val myUserId: String,\n         private val outgoingKeyRequestManager: OutgoingKeyRequestManager,\n         private val cryptoStore: IMXCryptoStore,\n-        private val matrixConfiguration: MatrixConfiguration,\n-        private val eventsManager: Lazy<StreamEventsManager>\n+        private val eventsManager: Lazy<StreamEventsManager>,\n+        private val unrequestedForwardManager: UnRequestedForwardManager,\n+        private val mxCryptoConfig: MXCryptoConfig,\n+        private val clock: Clock,\n ) {\n \n     fun create(): MXMegolmDecryption {\n         return MXMegolmDecryption(\n-                olmDevice,\n-                outgoingKeyRequestManager,\n-                cryptoStore,\n-                matrixConfiguration,\n-                eventsManager\n+                olmDevice = olmDevice,\n+                myUserId = myUserId,\n+                outgoingKeyRequestManager = outgoingKeyRequestManager,\n+                cryptoStore = cryptoStore,\n+                liveEventManager = eventsManager,\n+                unrequestedForwardManager = unrequestedForwardManager,\n+                cryptoConfig = mxCryptoConfig,\n+                clock = clock,\n         )\n     }\n }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/algorithms/megolm/MXMegolmEncryption.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -162,7 +162,8 @@ internal class MXMegolmEncryption(\n                 forwardingCurve25519KeyChain = emptyList(),\n                 keysClaimed = keysClaimedMap,\n                 exportFormat = false,\n-                sharedHistory = sharedHistory\n+                sharedHistory = sharedHistory,\n+                trusted = true\n         )\n \n         defaultKeysBackupService.maybeBackupKeys()"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/algorithms/megolm/UnRequestedForwardManager.kt",
          "status": "added",
          "additions": 150,
          "deletions": 0,
          "patch": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.internal.crypto.algorithms.megolm\n+\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.SupervisorJob\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.launch\n+import org.matrix.android.sdk.api.extensions.tryOrNull\n+import org.matrix.android.sdk.api.session.events.model.Event\n+import org.matrix.android.sdk.internal.crypto.DeviceListManager\n+import org.matrix.android.sdk.internal.session.SessionScope\n+import org.matrix.android.sdk.internal.task.SemaphoreCoroutineSequencer\n+import timber.log.Timber\n+import java.util.concurrent.Executors\n+import javax.inject.Inject\n+import kotlin.math.abs\n+\n+private val INVITE_VALIDITY_TIME_WINDOW_MILLIS = 10 * 60_000\n+\n+@SessionScope\n+internal class UnRequestedForwardManager @Inject constructor(\n+        private val deviceListManager: DeviceListManager,\n+) {\n+\n+    private val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()\n+    private val scope = CoroutineScope(SupervisorJob() + dispatcher)\n+    private val sequencer = SemaphoreCoroutineSequencer()\n+\n+    // For now only in memory storage. Maybe we should persist? in case of gappy sync and long catchups?\n+    private val forwardedKeysPerRoom = mutableMapOf<String, MutableMap<String, MutableList<ForwardInfo>>>()\n+\n+    data class InviteInfo(\n+            val roomId: String,\n+            val fromMxId: String,\n+            val timestamp: Long\n+    )\n+\n+    data class ForwardInfo(\n+            val event: Event,\n+            val timestamp: Long\n+    )\n+\n+    // roomId, local timestamp of invite\n+    private val recentInvites = mutableListOf<InviteInfo>()\n+\n+    fun close() {\n+        try {\n+            scope.cancel(\"User Terminate\")\n+        } catch (failure: Throwable) {\n+            Timber.w(failure, \"Failed to shutDown UnrequestedForwardManager\")\n+        }\n+    }\n+\n+    fun onInviteReceived(roomId: String, fromUserId: String, localTimeStamp: Long) {\n+        Timber.w(\"Invite received in room:$roomId from:$fromUserId at $localTimeStamp\")\n+        scope.launch {\n+            sequencer.post {\n+                if (!recentInvites.any { it.roomId == roomId && it.fromMxId == fromUserId }) {\n+                    recentInvites.add(\n+                            InviteInfo(\n+                                    roomId,\n+                                    fromUserId,\n+                                    localTimeStamp\n+                            )\n+                    )\n+                }\n+            }\n+        }\n+    }\n+\n+    fun onUnRequestedKeyForward(roomId: String, event: Event, localTimeStamp: Long) {\n+        Timber.w(\"Received unrequested forward in room:$roomId from:${event.senderId} at $localTimeStamp\")\n+        scope.launch {\n+            sequencer.post {\n+                val claimSenderId = event.senderId.orEmpty()\n+                val senderKey = event.getSenderKey()\n+                // we might want to download keys, as this user might not be known yet, cache is ok\n+                val ownerMxId =\n+                        tryOrNull {\n+                            deviceListManager.downloadKeys(listOf(claimSenderId), false)\n+                                    .map[claimSenderId]\n+                                    ?.values\n+                                    ?.firstOrNull { it.identityKey() == senderKey }\n+                                    ?.userId\n+                        }\n+                // Not sure what to do if the device has been deleted? I can't proove the mxid\n+                if (ownerMxId == null || claimSenderId != ownerMxId) {\n+                    Timber.w(\"Mismatch senderId between event and olm owner\")\n+                    return@post\n+                }\n+\n+                forwardedKeysPerRoom\n+                        .getOrPut(roomId) { mutableMapOf() }\n+                        .getOrPut(ownerMxId) { mutableListOf() }\n+                        .add(ForwardInfo(event, localTimeStamp))\n+            }\n+        }\n+    }\n+\n+    fun postSyncProcessParkedKeysIfNeeded(currentTimestamp: Long, handleForwards: suspend (List<Event>) -> Unit) {\n+        scope.launch {\n+            sequencer.post {\n+                // Prune outdated invites\n+                recentInvites.removeAll { currentTimestamp - it.timestamp > INVITE_VALIDITY_TIME_WINDOW_MILLIS }\n+                val cleanUpEvents = mutableListOf<Pair<String, String>>()\n+                forwardedKeysPerRoom.forEach { (roomId, senderIdToForwardMap) ->\n+                    senderIdToForwardMap.forEach { (senderId, eventList) ->\n+                        // is there a matching invite in a valid timewindow?\n+                        val matchingInvite = recentInvites.firstOrNull { it.fromMxId == senderId && it.roomId == roomId }\n+                        if (matchingInvite != null) {\n+                            Timber.v(\"match  for room:$roomId from sender:$senderId -> count =${eventList.size}\")\n+\n+                            eventList.filter {\n+                                abs(matchingInvite.timestamp - it.timestamp) <= INVITE_VALIDITY_TIME_WINDOW_MILLIS\n+                            }.map {\n+                                it.event\n+                            }.takeIf { it.isNotEmpty() }?.let {\n+                                Timber.w(\"Re-processing forwarded_room_key_event that was not requested after invite\")\n+                                scope.launch {\n+                                    handleForwards.invoke(it)\n+                                }\n+                            }\n+                            cleanUpEvents.add(roomId to senderId)\n+                        }\n+                    }\n+                }\n+\n+                cleanUpEvents.forEach { roomIdToSenderPair ->\n+                    forwardedKeysPerRoom[roomIdToSenderPair.first]?.get(roomIdToSenderPair.second)?.clear()\n+                }\n+            }\n+        }\n+    }\n+}"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/keysbackup/DefaultKeysBackupService.kt",
          "status": "modified",
          "additions": 0,
          "deletions": 7,
          "patch": "@@ -652,14 +652,7 @@ internal class DefaultKeysBackupService @Inject constructor(\n                         }\n                 val recoveryKey = computeRecoveryKey(secret.fromBase64())\n                 if (isValidRecoveryKeyForKeysBackupVersion(recoveryKey, keysBackupVersion)) {\n-                    awaitCallback<Unit> {\n-                        trustKeysBackupVersion(keysBackupVersion, true, it)\n-                    }\n                     // we don't want to start immediately downloading all as it can take very long\n-\n-//                    val importResult = awaitCallback<ImportRoomKeysResult> {\n-//                        restoreKeysWithRecoveryKey(keysBackupVersion, recoveryKey, null, null, null, it)\n-//                    }\n                     withContext(coroutineDispatchers.crypto) {\n                         cryptoStore.saveBackupRecoveryKey(recoveryKey, keysBackupVersion.version)\n                     }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/model/InboundGroupSessionData.kt",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -38,14 +38,17 @@ data class InboundGroupSessionData(\n         @Json(name = \"forwarding_curve25519_key_chain\")\n         var forwardingCurve25519KeyChain: List<String>? = emptyList(),\n \n-        /** Not yet used, will be in backup v2\n-        val untrusted?: Boolean = false */\n-\n         /**\n          * Flag that indicates whether or not the current inboundSession will be shared to\n          * invited users to decrypt past messages.\n          */\n         @Json(name = \"shared_history\")\n         val sharedHistory: Boolean = false,\n \n+        /**\n+         * Flag indicating that this key is trusted.\n+         */\n+        @Json(name = \"trusted\")\n+        val trusted: Boolean? = null,\n+\n         )"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/model/MXInboundMegolmSessionWrapper.kt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -86,6 +86,7 @@ data class MXInboundMegolmSessionWrapper(\n                     keysClaimed = megolmSessionData.senderClaimedKeys,\n                     forwardingCurve25519KeyChain = megolmSessionData.forwardingCurve25519KeyChain,\n                     sharedHistory = megolmSessionData.sharedHistory,\n+                    trusted = false\n             )\n \n             return MXInboundMegolmSessionWrapper("
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/store/db/RealmCryptoStoreMigration.kt",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -34,6 +34,7 @@ import org.matrix.android.sdk.internal.crypto.store.db.migration.MigrateCryptoTo\n import org.matrix.android.sdk.internal.crypto.store.db.migration.MigrateCryptoTo015\n import org.matrix.android.sdk.internal.crypto.store.db.migration.MigrateCryptoTo016\n import org.matrix.android.sdk.internal.crypto.store.db.migration.MigrateCryptoTo017\n+import org.matrix.android.sdk.internal.crypto.store.db.migration.MigrateCryptoTo018\n import org.matrix.android.sdk.internal.util.database.MatrixRealmMigration\n import org.matrix.android.sdk.internal.util.time.Clock\n import javax.inject.Inject\n@@ -48,7 +49,7 @@ internal class RealmCryptoStoreMigration @Inject constructor(\n         private val clock: Clock,\n ) : MatrixRealmMigration(\n         dbName = \"Crypto\",\n-        schemaVersion = 17L,\n+        schemaVersion = 18L,\n ) {\n     /**\n      * Forces all RealmCryptoStoreMigration instances to be equal.\n@@ -75,5 +76,6 @@ internal class RealmCryptoStoreMigration @Inject constructor(\n         if (oldVersion < 15) MigrateCryptoTo015(realm).perform()\n         if (oldVersion < 16) MigrateCryptoTo016(realm).perform()\n         if (oldVersion < 17) MigrateCryptoTo017(realm).perform()\n+        if (oldVersion < 18) MigrateCryptoTo018(realm).perform()\n     }\n }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/store/db/migration/MigrateCryptoTo018.kt",
          "status": "added",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.internal.crypto.store.db.migration\n+\n+import io.realm.DynamicRealm\n+import org.matrix.android.sdk.internal.crypto.model.InboundGroupSessionData\n+import org.matrix.android.sdk.internal.crypto.store.db.model.OlmInboundGroupSessionEntityFields\n+import org.matrix.android.sdk.internal.di.MoshiProvider\n+import org.matrix.android.sdk.internal.util.database.RealmMigrator\n+import timber.log.Timber\n+\n+/**\n+ * This migration is adding support for trusted flags on megolm sessions.\n+ * We can't really assert the trust of existing keys, so for the sake of simplicity we are going to\n+ * mark existing keys as safe.\n+ * This migration can take long depending on the account\n+ */\n+internal class MigrateCryptoTo018(realm: DynamicRealm) : RealmMigrator(realm, 18) {\n+\n+    private val moshiAdapter = MoshiProvider.providesMoshi().adapter(InboundGroupSessionData::class.java)\n+\n+    override fun doMigrate(realm: DynamicRealm) {\n+        realm.schema.get(\"OlmInboundGroupSessionEntity\")\n+                ?.transform { dynamicObject ->\n+                    try {\n+                        dynamicObject.getString(OlmInboundGroupSessionEntityFields.INBOUND_GROUP_SESSION_DATA_JSON)?.let { oldData ->\n+                            moshiAdapter.fromJson(oldData)?.let { dataToMigrate ->\n+                                dataToMigrate.copy(trusted = true).let {\n+                                    dynamicObject.setString(OlmInboundGroupSessionEntityFields.INBOUND_GROUP_SESSION_DATA_JSON, moshiAdapter.toJson(it))\n+                                }\n+                            }\n+                        }\n+                    } catch (failure: Throwable) {\n+                        Timber.e(failure, \"Failed to migrate megolm session\")\n+                    }\n+                }\n+    }\n+}"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/crypto/tasks/EncryptEventTask.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -82,7 +82,8 @@ internal class DefaultEncryptEventTask @Inject constructor(\n                         ).toContent(),\n                         forwardingCurve25519KeyChain = emptyList(),\n                         senderCurve25519Key = result.eventContent[\"sender_key\"] as? String,\n-                        claimedEd25519Key = cryptoService.get().getMyDevice().fingerprint()\n+                        claimedEd25519Key = cryptoService.get().getMyDevice().fingerprint(),\n+                        isSafe = true\n                 )\n             } else {\n                 null"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/RealmSessionStoreMigration.kt",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -53,6 +53,7 @@ import org.matrix.android.sdk.internal.database.migration.MigrateSessionTo033\n import org.matrix.android.sdk.internal.database.migration.MigrateSessionTo034\n import org.matrix.android.sdk.internal.database.migration.MigrateSessionTo035\n import org.matrix.android.sdk.internal.database.migration.MigrateSessionTo036\n+import org.matrix.android.sdk.internal.database.migration.MigrateSessionTo037\n import org.matrix.android.sdk.internal.util.Normalizer\n import org.matrix.android.sdk.internal.util.database.MatrixRealmMigration\n import javax.inject.Inject\n@@ -61,7 +62,7 @@ internal class RealmSessionStoreMigration @Inject constructor(\n         private val normalizer: Normalizer\n ) : MatrixRealmMigration(\n         dbName = \"Session\",\n-        schemaVersion = 36L,\n+        schemaVersion = 37L,\n ) {\n     /**\n      * Forces all RealmSessionStoreMigration instances to be equal.\n@@ -107,5 +108,6 @@ internal class RealmSessionStoreMigration @Inject constructor(\n         if (oldVersion < 34) MigrateSessionTo034(realm).perform()\n         if (oldVersion < 35) MigrateSessionTo035(realm).perform()\n         if (oldVersion < 36) MigrateSessionTo036(realm).perform()\n+        if (oldVersion < 37) MigrateSessionTo037(realm).perform()\n     }\n }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/helper/ThreadSummaryHelper.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -228,7 +228,8 @@ private fun decryptIfNeeded(cryptoService: CryptoService?, eventEntity: EventEnt\n                     payload = result.clearEvent,\n                     senderKey = result.senderCurve25519Key,\n                     keysClaimed = result.claimedEd25519Key?.let { k -> mapOf(\"ed25519\" to k) },\n-                    forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                    forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                    isSafe = result.isSafe\n             )\n             // Save decryption result, to not decrypt every time we enter the thread list\n             eventEntity.setDecryptionResult(result)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/mapper/LocalRoomSummaryMapper.kt",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.internal.database.mapper\n+\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n+import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntity\n+import javax.inject.Inject\n+\n+internal class LocalRoomSummaryMapper @Inject constructor(\n+        private val roomSummaryMapper: RoomSummaryMapper,\n+) {\n+\n+    fun map(localRoomSummaryEntity: LocalRoomSummaryEntity): LocalRoomSummary {\n+        return LocalRoomSummary(\n+                roomId = localRoomSummaryEntity.roomId,\n+                roomSummary = localRoomSummaryEntity.roomSummaryEntity?.let { roomSummaryMapper.map(it) },\n+                createRoomParams = localRoomSummaryEntity.createRoomParams,\n+                replacementRoomId = localRoomSummaryEntity.replacementRoomId,\n+                creationState = localRoomSummaryEntity.creationState\n+        )\n+    }\n+}"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/migration/MigrateSessionTo037.kt",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.internal.database.migration\n+\n+import io.realm.DynamicRealm\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomCreationState\n+import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntityFields\n+import org.matrix.android.sdk.internal.util.database.RealmMigrator\n+\n+internal class MigrateSessionTo037(realm: DynamicRealm) : RealmMigrator(realm, 37) {\n+\n+    override fun doMigrate(realm: DynamicRealm) {\n+        realm.schema.get(\"LocalRoomSummaryEntity\")\n+                ?.addField(LocalRoomSummaryEntityFields.REPLACEMENT_ROOM_ID, String::class.java)\n+                ?.addField(LocalRoomSummaryEntityFields.STATE_STR, String::class.java)\n+                ?.transform { obj ->\n+                    obj.set(LocalRoomSummaryEntityFields.STATE_STR, LocalRoomCreationState.NOT_CREATED.name)\n+                }\n+    }\n+}"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/model/EventEntity.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -87,7 +87,8 @@ internal open class EventEntity(\n                 payload = result.clearEvent,\n                 senderKey = result.senderCurve25519Key,\n                 keysClaimed = result.claimedEd25519Key?.let { mapOf(\"ed25519\" to it) },\n-                forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                isSafe = result.isSafe\n         )\n         val adapter = MoshiProvider.providesMoshi().adapter(OlmDecryptionResult::class.java)\n         decryptionResultJson = adapter.toJson(decryptionResult)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/model/LocalRoomSummaryEntity.kt",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -18,15 +18,24 @@ package org.matrix.android.sdk.internal.database.model\n \n import io.realm.RealmObject\n import io.realm.annotations.PrimaryKey\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomCreationState\n import org.matrix.android.sdk.api.session.room.model.create.CreateRoomParams\n import org.matrix.android.sdk.api.session.room.model.create.toJSONString\n \n internal open class LocalRoomSummaryEntity(\n         @PrimaryKey var roomId: String = \"\",\n         var roomSummaryEntity: RoomSummaryEntity? = null,\n-        private var createRoomParamsStr: String? = null\n+        var replacementRoomId: String? = null,\n ) : RealmObject() {\n \n+    private var stateStr: String = LocalRoomCreationState.NOT_CREATED.name\n+    var creationState: LocalRoomCreationState\n+        get() = LocalRoomCreationState.valueOf(stateStr)\n+        set(value) {\n+            stateStr = value.name\n+        }\n+\n+    private var createRoomParamsStr: String? = null\n     var createRoomParams: CreateRoomParams?\n         get() {\n             return CreateRoomParams.fromJson(createRoomParamsStr)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/query/LocalRoomSummaryEntityQueries.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 6,
          "patch": "@@ -22,10 +22,6 @@ import io.realm.kotlin.where\n import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntity\n import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntityFields\n \n-internal fun LocalRoomSummaryEntity.Companion.where(realm: Realm, roomId: String? = null): RealmQuery<LocalRoomSummaryEntity> {\n-    val query = realm.where<LocalRoomSummaryEntity>()\n-    if (roomId != null) {\n-        query.equalTo(LocalRoomSummaryEntityFields.ROOM_ID, roomId)\n-    }\n-    return query\n+internal fun LocalRoomSummaryEntity.Companion.where(realm: Realm, roomId: String): RealmQuery<LocalRoomSummaryEntity> {\n+    return realm.where<LocalRoomSummaryEntity>().equalTo(LocalRoomSummaryEntityFields.ROOM_ID, roomId)\n }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/database/query/ReadReceiptEntityQueries.kt",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -33,6 +33,11 @@ internal fun ReadReceiptEntity.Companion.whereUserId(realm: Realm, userId: Strin\n             .equalTo(ReadReceiptEntityFields.USER_ID, userId)\n }\n \n+internal fun ReadReceiptEntity.Companion.whereRoomId(realm: Realm, roomId: String): RealmQuery<ReadReceiptEntity> {\n+    return realm.where<ReadReceiptEntity>()\n+            .equalTo(ReadReceiptEntityFields.ROOM_ID, roomId)\n+}\n+\n internal fun ReadReceiptEntity.Companion.createUnmanaged(roomId: String, eventId: String, userId: String, originServerTs: Double): ReadReceiptEntity {\n     return ReadReceiptEntity().apply {\n         this.primaryKey = \"${roomId}_$userId\""
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/query/QueryStringValueProcessor.kt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -38,6 +38,7 @@ internal class QueryStringValueProcessor @Inject constructor(\n             is ContentQueryStringValue -> when (queryStringValue) {\n                 is QueryStringValue.Equals -> equalTo(field, queryStringValue.toRealmValue(), queryStringValue.case.toRealmCase())\n                 is QueryStringValue.Contains -> contains(field, queryStringValue.toRealmValue(), queryStringValue.case.toRealmCase())\n+                is QueryStringValue.NotContains -> not().process(field, QueryStringValue.Contains(queryStringValue.string, queryStringValue.case))\n             }\n         }\n     }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/DefaultRoom.kt",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ import org.matrix.android.sdk.api.session.room.call.RoomCallService\n import org.matrix.android.sdk.api.session.room.crypto.RoomCryptoService\n import org.matrix.android.sdk.api.session.room.location.LocationSharingService\n import org.matrix.android.sdk.api.session.room.members.MembershipService\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n import org.matrix.android.sdk.api.session.room.model.RoomType\n import org.matrix.android.sdk.api.session.room.model.relation.RelationService\n@@ -82,6 +83,14 @@ internal class DefaultRoom(\n         return roomSummaryDataSource.getRoomSummary(roomId)\n     }\n \n+    override fun getLocalRoomSummaryLive(): LiveData<Optional<LocalRoomSummary>> {\n+        return roomSummaryDataSource.getLocalRoomSummaryLive(roomId)\n+    }\n+\n+    override fun localRoomSummary(): LocalRoomSummary? {\n+        return roomSummaryDataSource.getLocalRoomSummary(roomId)\n+    }\n+\n     override fun asSpace(): Space? {\n         if (roomSummary()?.roomType != RoomType.SPACE) return null\n         return DefaultSpace(this, roomSummaryDataSource, viaParameterFinder)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/DefaultRoomService.kt",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -29,10 +29,12 @@ import org.matrix.android.sdk.api.session.room.RoomSummaryQueryParams\n import org.matrix.android.sdk.api.session.room.UpdatableLivePageResult\n import org.matrix.android.sdk.api.session.room.alias.RoomAliasDescription\n import org.matrix.android.sdk.api.session.room.members.ChangeMembershipState\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n import org.matrix.android.sdk.api.session.room.model.Membership\n import org.matrix.android.sdk.api.session.room.model.RoomMemberSummary\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n import org.matrix.android.sdk.api.session.room.model.create.CreateRoomParams\n+import org.matrix.android.sdk.api.session.room.model.localecho.RoomLocalEcho\n import org.matrix.android.sdk.api.session.room.peeking.PeekResult\n import org.matrix.android.sdk.api.session.room.roomSummaryQueryParams\n import org.matrix.android.sdk.api.session.room.summary.RoomAggregateNotificationCount\n@@ -106,6 +108,10 @@ internal class DefaultRoomService @Inject constructor(\n         return roomSummaryDataSource.getRoomSummaryLive(roomId)\n     }\n \n+    override fun getLocalRoomSummaryLive(roomId: String): LiveData<Optional<LocalRoomSummary>> {\n+        return roomSummaryDataSource.getLocalRoomSummaryLive(roomId)\n+    }\n+\n     override fun getRoomSummaries(\n             queryParams: RoomSummaryQueryParams,\n             sortOrder: RoomSortOrder\n@@ -173,7 +179,10 @@ internal class DefaultRoomService @Inject constructor(\n     }\n \n     override suspend fun onRoomDisplayed(roomId: String) {\n-        updateBreadcrumbsTask.execute(UpdateBreadcrumbsTask.Params(roomId))\n+        // Do not add local rooms to the recent rooms list as they should not be known by the server\n+        if (!RoomLocalEcho.isLocalEchoId(roomId)) {\n+            updateBreadcrumbsTask.execute(UpdateBreadcrumbsTask.Params(roomId))\n+        }\n     }\n \n     override suspend fun joinRoom(roomIdOrAlias: String, reason: String?, viaServers: List<String>) {"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/create/CreateRoomFromLocalRoomTask.kt",
          "status": "modified",
          "additions": 63,
          "deletions": 72,
          "patch": "@@ -17,133 +17,124 @@\n package org.matrix.android.sdk.internal.session.room.create\n \n import com.zhuinden.monarchy.Monarchy\n-import io.realm.kotlin.where\n import kotlinx.coroutines.TimeoutCancellationException\n-import org.matrix.android.sdk.api.extensions.orFalse\n-import org.matrix.android.sdk.api.query.QueryStringValue\n-import org.matrix.android.sdk.api.session.events.model.Event\n import org.matrix.android.sdk.api.session.events.model.EventType\n-import org.matrix.android.sdk.api.session.events.model.toContent\n-import org.matrix.android.sdk.api.session.events.model.toModel\n import org.matrix.android.sdk.api.session.room.failure.CreateRoomFailure\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomCreationState\n+import org.matrix.android.sdk.api.session.room.model.RoomSummary\n import org.matrix.android.sdk.api.session.room.model.create.CreateRoomParams\n-import org.matrix.android.sdk.api.session.room.model.tombstone.RoomTombstoneContent\n-import org.matrix.android.sdk.api.session.room.send.SendState\n import org.matrix.android.sdk.internal.database.awaitNotEmptyResult\n-import org.matrix.android.sdk.internal.database.mapper.toEntity\n-import org.matrix.android.sdk.internal.database.model.CurrentStateEventEntity\n import org.matrix.android.sdk.internal.database.model.EventEntity\n import org.matrix.android.sdk.internal.database.model.EventEntityFields\n-import org.matrix.android.sdk.internal.database.model.EventInsertType\n import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntity\n-import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntityFields\n import org.matrix.android.sdk.internal.database.model.RoomSummaryEntity\n import org.matrix.android.sdk.internal.database.model.RoomSummaryEntityFields\n-import org.matrix.android.sdk.internal.database.query.copyToRealmOrIgnore\n-import org.matrix.android.sdk.internal.database.query.getOrCreate\n+import org.matrix.android.sdk.internal.database.query.where\n import org.matrix.android.sdk.internal.database.query.whereRoomId\n import org.matrix.android.sdk.internal.di.SessionDatabase\n-import org.matrix.android.sdk.internal.di.UserId\n-import org.matrix.android.sdk.internal.session.room.state.StateEventDataSource\n+import org.matrix.android.sdk.internal.session.room.summary.RoomSummaryDataSource\n import org.matrix.android.sdk.internal.task.Task\n-import org.matrix.android.sdk.internal.util.awaitTransaction\n-import org.matrix.android.sdk.internal.util.time.Clock\n-import java.util.UUID\n import java.util.concurrent.TimeUnit\n import javax.inject.Inject\n \n /**\n  * Create a room on the server from a local room.\n  * The configuration of the local room will be use to configure the new room.\n  * The potential local room members will also be invited to this new room.\n- *\n- * A local tombstone event will be created to indicate that the local room has been replacing by the new one.\n  */\n internal interface CreateRoomFromLocalRoomTask : Task<CreateRoomFromLocalRoomTask.Params, String> {\n     data class Params(val localRoomId: String)\n }\n \n internal class DefaultCreateRoomFromLocalRoomTask @Inject constructor(\n-        @UserId private val userId: String,\n         @SessionDatabase private val monarchy: Monarchy,\n         private val createRoomTask: CreateRoomTask,\n-        private val stateEventDataSource: StateEventDataSource,\n-        private val clock: Clock,\n+        private val roomSummaryDataSource: RoomSummaryDataSource,\n ) : CreateRoomFromLocalRoomTask {\n \n     private val realmConfiguration\n         get() = monarchy.realmConfiguration\n \n     override suspend fun execute(params: CreateRoomFromLocalRoomTask.Params): String {\n-        val replacementRoomId = stateEventDataSource.getStateEvent(params.localRoomId, EventType.STATE_ROOM_TOMBSTONE, QueryStringValue.IsEmpty)\n-                ?.content.toModel<RoomTombstoneContent>()\n-                ?.replacementRoomId\n+        val localRoomSummary = roomSummaryDataSource.getLocalRoomSummary(params.localRoomId)\n+                ?: error(\"## CreateRoomFromLocalRoomTask - Cannot retrieve LocalRoomSummary with roomId ${params.localRoomId}\")\n \n-        if (replacementRoomId != null) {\n-            return replacementRoomId\n+        // If a room has already been created for the given local room, return the existing roomId\n+        if (localRoomSummary.replacementRoomId != null) {\n+            return localRoomSummary.replacementRoomId\n         }\n \n-        var createRoomParams: CreateRoomParams? = null\n-        var isEncrypted = false\n-        monarchy.doWithRealm { realm ->\n-            realm.where<LocalRoomSummaryEntity>()\n-                    .equalTo(LocalRoomSummaryEntityFields.ROOM_ID, params.localRoomId)\n-                    .findFirst()\n-                    ?.let {\n-                        createRoomParams = it.createRoomParams\n-                        isEncrypted = it.roomSummaryEntity?.isEncrypted.orFalse()\n-                    }\n+        if (localRoomSummary.createRoomParams != null && localRoomSummary.roomSummary != null) {\n+            return createRoom(params.localRoomId, localRoomSummary.roomSummary, localRoomSummary.createRoomParams)\n+        } else {\n+            error(\"## CreateRoomFromLocalRoomTask - Invalid LocalRoomSummary: $localRoomSummary\")\n         }\n-        val roomId = createRoomTask.execute(createRoomParams!!)\n+    }\n \n+    /**\n+     * Create a room on the server for the given local room.\n+     *\n+     * @param localRoomId the local room identifier.\n+     * @param localRoomSummary the RoomSummary of the local room.\n+     * @param createRoomParams the CreateRoomParams object which was used to configure the local room.\n+     *\n+     * @return the identifier of the created room.\n+     */\n+    private suspend fun createRoom(localRoomId: String, localRoomSummary: RoomSummary, createRoomParams: CreateRoomParams): String {\n+        updateCreationState(localRoomId, LocalRoomCreationState.CREATING)\n+        val replacementRoomId = runCatching {\n+            createRoomTask.execute(createRoomParams)\n+        }.fold(\n+                { it },\n+                {\n+                    updateCreationState(localRoomId, LocalRoomCreationState.FAILURE)\n+                    throw it\n+                }\n+        )\n+        updateReplacementRoomId(localRoomId, replacementRoomId)\n+        waitForRoomEvents(replacementRoomId, localRoomSummary)\n+        updateCreationState(localRoomId, LocalRoomCreationState.CREATED)\n+        return replacementRoomId\n+    }\n+\n+    /**\n+     * Wait for all the room events before triggering the created state.\n+     *\n+     * @param replacementRoomId the identifier of the created room\n+     * @param localRoomSummary the RoomSummary of the local room.\n+     */\n+    private suspend fun waitForRoomEvents(replacementRoomId: String, localRoomSummary: RoomSummary) {\n         try {\n-            // Wait for all the room events before triggering the replacement room\n             awaitNotEmptyResult(realmConfiguration, TimeUnit.MINUTES.toMillis(1L)) { realm ->\n                 realm.where(RoomSummaryEntity::class.java)\n-                        .equalTo(RoomSummaryEntityFields.ROOM_ID, roomId)\n-                        .equalTo(RoomSummaryEntityFields.INVITED_MEMBERS_COUNT, createRoomParams?.invitedUserIds?.size ?: 0)\n+                        .equalTo(RoomSummaryEntityFields.ROOM_ID, replacementRoomId)\n+                        .equalTo(RoomSummaryEntityFields.INVITED_MEMBERS_COUNT, localRoomSummary.invitedMembersCount)\n             }\n             awaitNotEmptyResult(realmConfiguration, TimeUnit.MINUTES.toMillis(1L)) { realm ->\n-                EventEntity.whereRoomId(realm, roomId)\n+                EventEntity.whereRoomId(realm, replacementRoomId)\n                         .equalTo(EventEntityFields.TYPE, EventType.STATE_ROOM_HISTORY_VISIBILITY)\n             }\n-            if (isEncrypted) {\n+            if (localRoomSummary.isEncrypted) {\n                 awaitNotEmptyResult(realmConfiguration, TimeUnit.MINUTES.toMillis(1L)) { realm ->\n-                    EventEntity.whereRoomId(realm, roomId)\n+                    EventEntity.whereRoomId(realm, replacementRoomId)\n                             .equalTo(EventEntityFields.TYPE, EventType.STATE_ROOM_ENCRYPTION)\n                 }\n             }\n         } catch (exception: TimeoutCancellationException) {\n-            throw CreateRoomFailure.CreatedWithTimeout(roomId)\n+            updateCreationState(localRoomSummary.roomId, LocalRoomCreationState.FAILURE)\n+            throw CreateRoomFailure.CreatedWithTimeout(replacementRoomId)\n         }\n+    }\n \n-        createTombstoneEvent(params, roomId)\n-        return roomId\n+    private fun updateCreationState(roomId: String, creationState: LocalRoomCreationState) {\n+        monarchy.runTransactionSync { realm ->\n+            LocalRoomSummaryEntity.where(realm, roomId).findFirst()?.creationState = creationState\n+        }\n     }\n \n-    /**\n-     * Create a Tombstone event to indicate that the local room has been replaced by a new one.\n-     */\n-    private suspend fun createTombstoneEvent(params: CreateRoomFromLocalRoomTask.Params, roomId: String) {\n-        val now = clock.epochMillis()\n-        val event = Event(\n-                type = EventType.STATE_ROOM_TOMBSTONE,\n-                senderId = userId,\n-                originServerTs = now,\n-                stateKey = \"\",\n-                eventId = UUID.randomUUID().toString(),\n-                content = RoomTombstoneContent(\n-                        replacementRoomId = roomId\n-                ).toContent()\n-        )\n-        monarchy.awaitTransaction { realm ->\n-            val eventEntity = event.toEntity(params.localRoomId, SendState.SYNCED, now).copyToRealmOrIgnore(realm, EventInsertType.INCREMENTAL_SYNC)\n-            if (event.stateKey != null && event.type != null && event.eventId != null) {\n-                CurrentStateEventEntity.getOrCreate(realm, params.localRoomId, event.stateKey, event.type).apply {\n-                    eventId = event.eventId\n-                    root = eventEntity\n-                }\n-            }\n+    private fun updateReplacementRoomId(localRoomId: String, replacementRoomId: String) {\n+        monarchy.runTransactionSync { realm ->\n+            LocalRoomSummaryEntity.where(realm, localRoomId).findFirst()?.replacementRoomId = replacementRoomId\n         }\n     }\n }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/delete/DeleteLocalRoomTask.kt",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -22,12 +22,15 @@ import org.matrix.android.sdk.internal.database.model.ChunkEntity\n import org.matrix.android.sdk.internal.database.model.CurrentStateEventEntity\n import org.matrix.android.sdk.internal.database.model.EventEntity\n import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntity\n+import org.matrix.android.sdk.internal.database.model.ReadReceiptEntity\n+import org.matrix.android.sdk.internal.database.model.ReadReceiptsSummaryEntity\n import org.matrix.android.sdk.internal.database.model.RoomEntity\n import org.matrix.android.sdk.internal.database.model.RoomMemberSummaryEntity\n import org.matrix.android.sdk.internal.database.model.RoomSummaryEntity\n import org.matrix.android.sdk.internal.database.model.TimelineEventEntity\n import org.matrix.android.sdk.internal.database.model.deleteOnCascade\n import org.matrix.android.sdk.internal.database.query.where\n+import org.matrix.android.sdk.internal.database.query.whereInRoom\n import org.matrix.android.sdk.internal.database.query.whereRoomId\n import org.matrix.android.sdk.internal.di.SessionDatabase\n import org.matrix.android.sdk.internal.session.room.delete.DeleteLocalRoomTask.Params\n@@ -50,6 +53,12 @@ internal class DefaultDeleteLocalRoomTask @Inject constructor(\n         if (RoomLocalEcho.isLocalEchoId(roomId)) {\n             monarchy.awaitTransaction { realm ->\n                 Timber.i(\"## DeleteLocalRoomTask - delete local room id $roomId\")\n+                ReadReceiptsSummaryEntity.whereInRoom(realm, roomId = roomId).findAll()\n+                        ?.also { Timber.i(\"## DeleteLocalRoomTask - ReadReceiptsSummaryEntity - delete ${it.size} entries\") }\n+                        ?.deleteAllFromRealm()\n+                ReadReceiptEntity.whereRoomId(realm, roomId = roomId).findAll()\n+                        ?.also { Timber.i(\"## DeleteLocalRoomTask - ReadReceiptEntity - delete ${it.size} entries\") }\n+                        ?.deleteAllFromRealm()\n                 RoomMemberSummaryEntity.where(realm, roomId = roomId).findAll()\n                         ?.also { Timber.i(\"## DeleteLocalRoomTask - RoomMemberSummaryEntity - delete ${it.size} entries\") }\n                         ?.deleteAllFromRealm()"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/relation/threads/FetchThreadTimelineTask.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -225,7 +225,8 @@ internal class DefaultFetchThreadTimelineTask @Inject constructor(\n                     payload = result.clearEvent,\n                     senderKey = result.senderCurve25519Key,\n                     keysClaimed = result.claimedEd25519Key?.let { k -> mapOf(\"ed25519\" to k) },\n-                    forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                    forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                    isSafe = result.isSafe\n             )\n         } catch (e: MXCryptoError) {\n             if (e is MXCryptoError.Base) {"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/summary/RoomSummaryDataSource.kt",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -34,6 +34,7 @@ import org.matrix.android.sdk.api.session.room.ResultBoundaries\n import org.matrix.android.sdk.api.session.room.RoomSortOrder\n import org.matrix.android.sdk.api.session.room.RoomSummaryQueryParams\n import org.matrix.android.sdk.api.session.room.UpdatableLivePageResult\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n import org.matrix.android.sdk.api.session.room.model.Membership\n import org.matrix.android.sdk.api.session.room.model.RoomSummary\n import org.matrix.android.sdk.api.session.room.model.RoomType\n@@ -43,7 +44,9 @@ import org.matrix.android.sdk.api.session.room.summary.RoomAggregateNotification\n import org.matrix.android.sdk.api.session.space.SpaceSummaryQueryParams\n import org.matrix.android.sdk.api.util.Optional\n import org.matrix.android.sdk.api.util.toOptional\n+import org.matrix.android.sdk.internal.database.mapper.LocalRoomSummaryMapper\n import org.matrix.android.sdk.internal.database.mapper.RoomSummaryMapper\n+import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntity\n import org.matrix.android.sdk.internal.database.model.RoomSummaryEntity\n import org.matrix.android.sdk.internal.database.model.RoomSummaryEntityFields\n import org.matrix.android.sdk.internal.database.query.findByAlias\n@@ -57,6 +60,7 @@ import javax.inject.Inject\n internal class RoomSummaryDataSource @Inject constructor(\n         @SessionDatabase private val monarchy: Monarchy,\n         private val roomSummaryMapper: RoomSummaryMapper,\n+        private val localRoomSummaryMapper: LocalRoomSummaryMapper,\n         private val queryStringValueProcessor: QueryStringValueProcessor,\n ) {\n \n@@ -95,6 +99,25 @@ internal class RoomSummaryDataSource @Inject constructor(\n         )\n     }\n \n+    fun getLocalRoomSummary(roomId: String): LocalRoomSummary? {\n+        return monarchy\n+                .fetchCopyMap({\n+                    LocalRoomSummaryEntity.where(it, roomId).findFirst()\n+                }, { entity, _ ->\n+                    localRoomSummaryMapper.map(entity)\n+                })\n+    }\n+\n+    fun getLocalRoomSummaryLive(roomId: String): LiveData<Optional<LocalRoomSummary>> {\n+        val liveData = monarchy.findAllMappedWithChanges(\n+                { realm -> LocalRoomSummaryEntity.where(realm, roomId) },\n+                { localRoomSummaryMapper.map(it) }\n+        )\n+        return Transformations.map(liveData) { results ->\n+            results.firstOrNull().toOptional()\n+        }\n+    }\n+\n     fun getRoomSummariesLive(\n             queryParams: RoomSummaryQueryParams,\n             sortOrder: RoomSortOrder = RoomSortOrder.NONE\n@@ -272,6 +295,7 @@ internal class RoomSummaryDataSource @Inject constructor(\n         val query = with(queryStringValueProcessor) {\n             RoomSummaryEntity.where(realm)\n                     .process(RoomSummaryEntityFields.ROOM_ID, QueryStringValue.IsNotEmpty)\n+                    .process(RoomSummaryEntityFields.ROOM_ID, queryParams.roomId)\n                     .process(queryParams.displayName.toDisplayNameField(), queryParams.displayName)\n                     .process(RoomSummaryEntityFields.CANONICAL_ALIAS, queryParams.canonicalAlias)\n                     .process(RoomSummaryEntityFields.MEMBERSHIP_STR, queryParams.memberships)"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/room/timeline/GetEventTask.kt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -56,7 +56,8 @@ internal class DefaultGetEventTask @Inject constructor(\n                                 payload = result.clearEvent,\n                                 senderKey = result.senderCurve25519Key,\n                                 keysClaimed = result.claimedEd25519Key?.let { mapOf(\"ed25519\" to it) },\n-                                forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                                forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                                isSafe = result.isSafe\n                         )\n                     }\n         }"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/space/DefaultSpaceService.kt",
          "status": "modified",
          "additions": 12,
          "deletions": 8,
          "patch": "@@ -21,7 +21,6 @@ import androidx.lifecycle.LiveData\n import kotlinx.coroutines.withContext\n import org.matrix.android.sdk.api.MatrixCoroutineDispatchers\n import org.matrix.android.sdk.api.query.QueryStringValue\n-import org.matrix.android.sdk.api.session.events.model.Event\n import org.matrix.android.sdk.api.session.events.model.EventType\n import org.matrix.android.sdk.api.session.events.model.toContent\n import org.matrix.android.sdk.api.session.events.model.toModel\n@@ -45,6 +44,7 @@ import org.matrix.android.sdk.api.session.space.SpaceHierarchyData\n import org.matrix.android.sdk.api.session.space.SpaceService\n import org.matrix.android.sdk.api.session.space.SpaceSummaryQueryParams\n import org.matrix.android.sdk.api.session.space.model.SpaceChildContent\n+import org.matrix.android.sdk.api.session.space.model.SpaceChildSummaryEvent\n import org.matrix.android.sdk.api.session.space.model.SpaceParentContent\n import org.matrix.android.sdk.api.session.space.peeking.SpacePeekResult\n import org.matrix.android.sdk.internal.di.UserId\n@@ -128,7 +128,7 @@ internal class DefaultSpaceService @Inject constructor(\n             suggestedOnly: Boolean?,\n             limit: Int?,\n             from: String?,\n-            knownStateList: List<Event>?\n+            knownStateList: List<SpaceChildSummaryEvent>?\n     ): SpaceHierarchyData {\n         val spacesResponse = getSpacesResponse(spaceId, suggestedOnly, limit, from)\n         val spaceRootResponse = spacesResponse.getRoot(spaceId)\n@@ -180,7 +180,7 @@ internal class DefaultSpaceService @Inject constructor(\n     private fun List<SpaceChildSummaryResponse>?.mapSpaceChildren(\n             spaceId: String,\n             spaceRootResponse: SpaceChildSummaryResponse?,\n-            knownStateList: List<Event>?,\n+            knownStateList: List<SpaceChildSummaryEvent>?,\n     ) = this?.filterIdIsNot(spaceId)\n             ?.toSpaceChildInfoList(spaceId, spaceRootResponse, knownStateList)\n             .orEmpty()\n@@ -190,18 +190,22 @@ internal class DefaultSpaceService @Inject constructor(\n     private fun List<SpaceChildSummaryResponse>.toSpaceChildInfoList(\n             spaceId: String,\n             rootRoomResponse: SpaceChildSummaryResponse?,\n-            knownStateList: List<Event>?,\n+            knownStateList: List<SpaceChildSummaryEvent>?,\n     ) = flatMap { spaceChildSummary ->\n         (rootRoomResponse?.childrenState ?: knownStateList)\n                 ?.filter { it.isChildOf(spaceChildSummary) }\n                 ?.mapNotNull { childStateEvent -> childStateEvent.toSpaceChildInfo(spaceId, spaceChildSummary) }\n                 .orEmpty()\n     }\n \n-    private fun Event.isChildOf(space: SpaceChildSummaryResponse) = stateKey == space.roomId && type == EventType.STATE_SPACE_CHILD\n+    private fun SpaceChildSummaryEvent.isChildOf(space: SpaceChildSummaryResponse): Boolean {\n+        return stateKey == space.roomId && type == EventType.STATE_SPACE_CHILD\n+    }\n \n-    private fun Event.toSpaceChildInfo(spaceId: String, summary: SpaceChildSummaryResponse) = content.toModel<SpaceChildContent>()?.let { content ->\n-        createSpaceChildInfo(spaceId, summary, content)\n+    private fun SpaceChildSummaryEvent.toSpaceChildInfo(spaceId: String, summary: SpaceChildSummaryResponse): SpaceChildInfo? {\n+        return content.toModel<SpaceChildContent>()?.let { content ->\n+            createSpaceChildInfo(spaceId, summary, content)\n+        }\n     }\n \n     private fun createSpaceChildInfo(\n@@ -255,7 +259,7 @@ internal class DefaultSpaceService @Inject constructor(\n                     stateKey = QueryStringValue.IsEmpty\n             )\n             val powerLevelsContent = powerLevelsEvent?.content?.toModel<PowerLevelsContent>()\n-                    ?: throw UnsupportedOperationException(\"Cannot add canonical child, missing powerlevel\")\n+                    ?: throw UnsupportedOperationException(\"Cannot add canonical child, missing power level\")\n             val powerLevelsHelper = PowerLevelsHelper(powerLevelsContent)\n             if (!powerLevelsHelper.isUserAllowedToSend(userId, true, EventType.STATE_SPACE_CHILD)) {\n                 throw UnsupportedOperationException(\"Cannot add canonical child, not enough power level\")"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/space/SpaceChildSummaryResponse.kt",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -18,7 +18,7 @@ package org.matrix.android.sdk.internal.session.space\n \n import com.squareup.moshi.Json\n import com.squareup.moshi.JsonClass\n-import org.matrix.android.sdk.api.session.events.model.Event\n+import org.matrix.android.sdk.api.session.space.model.SpaceChildSummaryEvent\n \n /**\n  * The fields are the same as those returned by /publicRooms (see spec), with the addition of:\n@@ -36,10 +36,11 @@ internal data class SpaceChildSummaryResponse(\n          */\n         @Json(name = \"room_type\") val roomType: String? = null,\n \n-        /**  The m.space.child events of the room. For each event, only the following fields are included:\n-         *  type, state_key, content, room_id, sender, with the addition of origin_server_ts.\n+        /**\n+         * The m.space.child events of the room. For each event, only the following fields are included:\n+         * type, state_key, content, sender, and of origin_server_ts.\n          */\n-        @Json(name = \"children_state\") val childrenState: List<Event>? = null,\n+        @Json(name = \"children_state\") val childrenState: List<SpaceChildSummaryEvent>? = null,\n \n         /**\n          * Aliases of the room. May be empty."
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/sync/handler/CryptoSyncHandler.kt",
          "status": "modified",
          "additions": 38,
          "deletions": 12,
          "patch": "@@ -16,6 +16,7 @@\n \n package org.matrix.android.sdk.internal.session.sync.handler\n \n+import org.matrix.android.sdk.api.crypto.MXCRYPTO_ALGORITHM_OLM\n import org.matrix.android.sdk.api.logger.LoggerTag\n import org.matrix.android.sdk.api.session.crypto.MXCryptoError\n import org.matrix.android.sdk.api.session.crypto.model.MXEventDecryptionResult\n@@ -42,17 +43,41 @@ internal class CryptoSyncHandler @Inject constructor(\n \n     suspend fun handleToDevice(toDevice: ToDeviceSyncResponse, progressReporter: ProgressReporter? = null) {\n         val total = toDevice.events?.size ?: 0\n-        toDevice.events?.forEachIndexed { index, event ->\n-            progressReporter?.reportProgress(index * 100F / total)\n-            // Decrypt event if necessary\n-            Timber.tag(loggerTag.value).i(\"To device event from ${event.senderId} of type:${event.type}\")\n-            decryptToDeviceEvent(event, null)\n-            if (event.getClearType() == EventType.MESSAGE &&\n-                    event.getClearContent()?.toModel<MessageContent>()?.msgType == \"m.bad.encrypted\") {\n-                Timber.tag(loggerTag.value).e(\"handleToDeviceEvent() : Warning: Unable to decrypt to-device event : ${event.content}\")\n-            } else {\n-                verificationService.onToDeviceEvent(event)\n-                cryptoService.onToDeviceEvent(event)\n+        toDevice.events\n+                ?.filter { isSupportedToDevice(it) }\n+                ?.forEachIndexed { index, event ->\n+                    progressReporter?.reportProgress(index * 100F / total)\n+                    // Decrypt event if necessary\n+                    Timber.tag(loggerTag.value).i(\"To device event from ${event.senderId} of type:${event.type}\")\n+                    decryptToDeviceEvent(event, null)\n+                    if (event.getClearType() == EventType.MESSAGE &&\n+                            event.getClearContent()?.toModel<MessageContent>()?.msgType == \"m.bad.encrypted\") {\n+                        Timber.tag(loggerTag.value).e(\"handleToDeviceEvent() : Warning: Unable to decrypt to-device event : ${event.content}\")\n+                    } else {\n+                        verificationService.onToDeviceEvent(event)\n+                        cryptoService.onToDeviceEvent(event)\n+                    }\n+                }\n+    }\n+\n+    private val unsupportedPlainToDeviceEventTypes = listOf(\n+            EventType.ROOM_KEY,\n+            EventType.FORWARDED_ROOM_KEY,\n+            EventType.SEND_SECRET\n+    )\n+\n+    private fun isSupportedToDevice(event: Event): Boolean {\n+        val algorithm = event.content?.get(\"algorithm\") as? String\n+        val type = event.type.orEmpty()\n+        return if (event.isEncrypted()) {\n+            algorithm == MXCRYPTO_ALGORITHM_OLM\n+        } else {\n+            // some clear events are not allowed\n+            type !in unsupportedPlainToDeviceEventTypes\n+        }.also {\n+            if (!it) {\n+                Timber.tag(loggerTag.value)\n+                        .w(\"Ignoring unsupported to device event ${event.type} alg:${algorithm}\")\n             }\n         }\n     }\n@@ -91,7 +116,8 @@ internal class CryptoSyncHandler @Inject constructor(\n                         payload = result.clearEvent,\n                         senderKey = result.senderCurve25519Key,\n                         keysClaimed = result.claimedEd25519Key?.let { mapOf(\"ed25519\" to it) },\n-                        forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                        forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                        isSafe = result.isSafe\n                 )\n                 return true\n             } else {"
        },
        {
          "filename": "matrix-sdk-android/src/main/java/org/matrix/android/sdk/internal/session/sync/handler/room/RoomSyncHandler.kt",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -40,6 +40,7 @@ import org.matrix.android.sdk.api.session.sync.model.RoomSync\n import org.matrix.android.sdk.api.session.sync.model.RoomsSyncResponse\n import org.matrix.android.sdk.api.settings.LightweightSettingsStorage\n import org.matrix.android.sdk.internal.crypto.DefaultCryptoService\n+import org.matrix.android.sdk.internal.crypto.algorithms.megolm.UnRequestedForwardManager\n import org.matrix.android.sdk.internal.database.helper.addIfNecessary\n import org.matrix.android.sdk.internal.database.helper.addTimelineEvent\n import org.matrix.android.sdk.internal.database.helper.createOrUpdate\n@@ -99,6 +100,7 @@ internal class RoomSyncHandler @Inject constructor(\n         private val timelineInput: TimelineInput,\n         private val liveEventService: Lazy<StreamEventsManager>,\n         private val clock: Clock,\n+        private val unRequestedForwardManager: UnRequestedForwardManager,\n ) {\n \n     sealed class HandlingStrategy {\n@@ -322,6 +324,7 @@ internal class RoomSyncHandler @Inject constructor(\n         }\n         roomChangeMembershipStateDataSource.setMembershipFromSync(roomId, Membership.INVITE)\n         roomSummaryUpdater.update(realm, roomId, Membership.INVITE, updateMembers = true, inviterId = inviterEvent?.senderId, aggregator = aggregator)\n+        unRequestedForwardManager.onInviteReceived(roomId, inviterEvent?.senderId.orEmpty(), clock.epochMillis())\n         return roomEntity\n     }\n \n@@ -551,7 +554,8 @@ internal class RoomSyncHandler @Inject constructor(\n                     payload = result.clearEvent,\n                     senderKey = result.senderCurve25519Key,\n                     keysClaimed = result.claimedEd25519Key?.let { k -> mapOf(\"ed25519\" to k) },\n-                    forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain\n+                    forwardingCurve25519KeyChain = result.forwardingCurve25519KeyChain,\n+                    isSafe = result.isSafe\n             )\n         } catch (e: MXCryptoError) {\n             if (e is MXCryptoError.Base) {"
        },
        {
          "filename": "matrix-sdk-android/src/test/java/org/matrix/android/sdk/internal/crypto/UnRequestedKeysManagerTest.kt",
          "status": "added",
          "additions": 248,
          "deletions": 0,
          "patch": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.internal.crypto\n+\n+import io.mockk.coEvery\n+import io.mockk.mockk\n+import kotlinx.coroutines.runBlocking\n+import org.amshove.kluent.fail\n+import org.amshove.kluent.shouldBe\n+import org.junit.Test\n+import org.matrix.android.sdk.api.crypto.MXCRYPTO_ALGORITHM_MEGOLM\n+import org.matrix.android.sdk.api.session.crypto.crosssigning.DeviceTrustLevel\n+import org.matrix.android.sdk.api.session.crypto.model.CryptoDeviceInfo\n+import org.matrix.android.sdk.api.session.crypto.model.ForwardedRoomKeyContent\n+import org.matrix.android.sdk.api.session.crypto.model.MXUsersDevicesMap\n+import org.matrix.android.sdk.api.session.crypto.model.OlmDecryptionResult\n+import org.matrix.android.sdk.api.session.crypto.model.UnsignedDeviceInfo\n+import org.matrix.android.sdk.api.session.events.model.Event\n+import org.matrix.android.sdk.api.session.events.model.EventType\n+import org.matrix.android.sdk.api.session.events.model.content.OlmEventContent\n+import org.matrix.android.sdk.api.session.events.model.toContent\n+import org.matrix.android.sdk.internal.crypto.algorithms.megolm.UnRequestedForwardManager\n+\n+class UnRequestedKeysManagerTest {\n+\n+    private val aliceMxId = \"alice@example.com\"\n+    private val bobMxId = \"bob@example.com\"\n+    private val bobDeviceId = \"MKRJDSLYGA\"\n+\n+    private val device1Id = \"MGDAADVDMG\"\n+\n+    private val aliceFirstDevice = CryptoDeviceInfo(\n+            deviceId = device1Id,\n+            userId = aliceMxId,\n+            algorithms = MXCryptoAlgorithms.supportedAlgorithms(),\n+            keys = mapOf(\n+                    \"curve25519:$device1Id\" to \"yDa6cWOZ/WGBqm/JMUfTUCdEbAIzKHhuIcdDbnPEhDU\",\n+                    \"ed25519:$device1Id\" to \"XTge+TDwfm+WW10IGnaqEyLTSukPPzg3R1J1YvO1SBI\",\n+            ),\n+            signatures = mapOf(\n+                    aliceMxId to mapOf(\n+                            \"ed25519:$device1Id\" to \"bPOAqM40+QSMgeEzUbYbPSZZccDDMUG00lCNdSXCoaS1gKKBGkSEaHO1OcibISIabjLYzmhp9mgtivz32fbABQ\",\n+                            \"ed25519:Ru4ni66dbQ6FZgUoHyyBtmjKecOHMvMSsSBZ2SABtt0\" to \"owzUsQ4Pvn35uEIc5FdVnXVRPzsVYBV8uJRUSqr4y8r5tp0DvrMArtJukKETgYEAivcZMT1lwNihHIN9xh06DA\"\n+                    )\n+            ),\n+            unsigned = UnsignedDeviceInfo(deviceDisplayName = \"Element Web\"),\n+            trustLevel = DeviceTrustLevel(crossSigningVerified = true, locallyVerified = true)\n+    )\n+\n+    private val aBobDevice = CryptoDeviceInfo(\n+            deviceId = bobDeviceId,\n+            userId = bobMxId,\n+            algorithms = MXCryptoAlgorithms.supportedAlgorithms(),\n+            keys = mapOf(\n+                    \"curve25519:$bobDeviceId\" to \"tWwg63Yfn//61Ylhir6z4QGejvo193E6MVHmURtYVn0\",\n+                    \"ed25519:$bobDeviceId\" to \"pS5NJ1LiVksQFX+p58NlphqMxE705laRVtUtZpYIAfs\",\n+            ),\n+            signatures = mapOf(\n+                    bobMxId to mapOf(\n+                            \"ed25519:$bobDeviceId\" to \"zAJqsmOSzkx8EWXcrynCsWtbgWZifN7A6DLyEBs+ZPPLnNuPN5Jwzc1Rg+oZWZaRPvOPcSL0cgcxRegSBU0NBA\",\n+                    )\n+            ),\n+            unsigned = UnsignedDeviceInfo(deviceDisplayName = \"Element Ios\")\n+    )\n+\n+    @Test\n+    fun `test process key request if invite received`() {\n+        val fakeDeviceListManager = mockk<DeviceListManager> {\n+            coEvery { downloadKeys(any(), any()) } returns MXUsersDevicesMap<CryptoDeviceInfo>().apply {\n+                setObject(bobMxId, bobDeviceId, aBobDevice)\n+            }\n+        }\n+        val unrequestedForwardManager = UnRequestedForwardManager(fakeDeviceListManager)\n+\n+        val roomId = \"someRoomId\"\n+\n+        unrequestedForwardManager.onUnRequestedKeyForward(\n+                roomId,\n+                createFakeSuccessfullyDecryptedForwardToDevice(\n+                        aBobDevice,\n+                        aliceFirstDevice,\n+                        aBobDevice,\n+                        megolmSessionId = \"megolmId1\"\n+                ),\n+                1_000\n+        )\n+\n+        unrequestedForwardManager.onUnRequestedKeyForward(\n+                roomId,\n+                createFakeSuccessfullyDecryptedForwardToDevice(\n+                        aBobDevice,\n+                        aliceFirstDevice,\n+                        aBobDevice,\n+                        megolmSessionId = \"megolmId2\"\n+                ),\n+                1_000\n+        )\n+        // for now no reason to accept\n+        runBlocking {\n+            unrequestedForwardManager.postSyncProcessParkedKeysIfNeeded(1000) {\n+                fail(\"There should be no key to process\")\n+            }\n+        }\n+\n+        // ACT\n+        // suppose an invite is received but from another user\n+        val inviteTime = 1_000L\n+        unrequestedForwardManager.onInviteReceived(roomId, \"@jhon:example.com\", inviteTime)\n+\n+        // we shouldn't process the requests!\n+//        runBlocking {\n+            unrequestedForwardManager.postSyncProcessParkedKeysIfNeeded(inviteTime) {\n+                fail(\"There should be no key to process\")\n+            }\n+//        }\n+\n+        // ACT\n+        // suppose an invite is received from correct user\n+\n+        unrequestedForwardManager.onInviteReceived(roomId, aBobDevice.userId, inviteTime)\n+        runBlocking {\n+            unrequestedForwardManager.postSyncProcessParkedKeysIfNeeded(inviteTime) {\n+                it.size shouldBe 2\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun `test invite before keys`() {\n+        val fakeDeviceListManager = mockk<DeviceListManager> {\n+            coEvery { downloadKeys(any(), any()) } returns MXUsersDevicesMap<CryptoDeviceInfo>().apply {\n+                setObject(bobMxId, bobDeviceId, aBobDevice)\n+            }\n+        }\n+        val unrequestedForwardManager = UnRequestedForwardManager(fakeDeviceListManager)\n+\n+        val roomId = \"someRoomId\"\n+\n+        unrequestedForwardManager.onInviteReceived(roomId, aBobDevice.userId, 1_000)\n+\n+        unrequestedForwardManager.onUnRequestedKeyForward(\n+                roomId,\n+                createFakeSuccessfullyDecryptedForwardToDevice(\n+                        aBobDevice,\n+                        aliceFirstDevice,\n+                        aBobDevice,\n+                        megolmSessionId = \"megolmId1\"\n+                ),\n+                1_000\n+        )\n+\n+        runBlocking {\n+            unrequestedForwardManager.postSyncProcessParkedKeysIfNeeded(1000) {\n+                it.size shouldBe 1\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun `test validity window`() {\n+        val fakeDeviceListManager = mockk<DeviceListManager> {\n+            coEvery { downloadKeys(any(), any()) } returns MXUsersDevicesMap<CryptoDeviceInfo>().apply {\n+                setObject(bobMxId, bobDeviceId, aBobDevice)\n+            }\n+        }\n+        val unrequestedForwardManager = UnRequestedForwardManager(fakeDeviceListManager)\n+\n+        val roomId = \"someRoomId\"\n+\n+        val timeOfKeyReception = 1_000L\n+\n+        unrequestedForwardManager.onUnRequestedKeyForward(\n+                roomId,\n+                createFakeSuccessfullyDecryptedForwardToDevice(\n+                        aBobDevice,\n+                        aliceFirstDevice,\n+                        aBobDevice,\n+                        megolmSessionId = \"megolmId1\"\n+                ),\n+                timeOfKeyReception\n+        )\n+\n+        val currentTimeWindow = 10 * 60_000\n+\n+        // simulate very late invite\n+        val inviteTime = timeOfKeyReception + currentTimeWindow + 1_000\n+        unrequestedForwardManager.onInviteReceived(roomId, aBobDevice.userId, inviteTime)\n+\n+        runBlocking {\n+            unrequestedForwardManager.postSyncProcessParkedKeysIfNeeded(inviteTime) {\n+                fail(\"There should be no key to process\")\n+            }\n+        }\n+    }\n+\n+    private fun createFakeSuccessfullyDecryptedForwardToDevice(\n+            sentBy: CryptoDeviceInfo,\n+            dest: CryptoDeviceInfo,\n+            sessionInitiator: CryptoDeviceInfo,\n+            algorithm: String = MXCRYPTO_ALGORITHM_MEGOLM,\n+            roomId: String = \"!zzgDlIhbWOevcdFBXr:example.com\",\n+            megolmSessionId: String = \"Z/FSE8wDYheouGjGP9pezC4S1i39RtAXM3q9VXrBVZw\"\n+    ): Event {\n+        return Event(\n+                type = EventType.ENCRYPTED,\n+                eventId = \"!fake\",\n+                senderId = sentBy.userId,\n+                content = OlmEventContent(\n+                        ciphertext = mapOf(\n+                                dest.identityKey()!! to mapOf(\n+                                        \"type\" to 0,\n+                                        \"body\" to \"AwogcziNF/tv60X0elsBmnKPN3+LTXr4K3vXw+1ZJ6jpTxESIJCmMMDvOA+\"\n+                                )\n+                        ),\n+                        senderKey = sentBy.identityKey()\n+                ).toContent(),\n+\n+                ).apply {\n+            mxDecryptionResult = OlmDecryptionResult(\n+                    payload = mapOf(\n+                            \"type\" to EventType.FORWARDED_ROOM_KEY,\n+                            \"content\" to ForwardedRoomKeyContent(\n+                                    algorithm = algorithm,\n+                                    roomId = roomId,\n+                                    senderKey = sessionInitiator.identityKey(),\n+                                    sessionId = megolmSessionId,\n+                                    sessionKey = \"AQAAAAAc4dK+lXxXyaFbckSxwjIEoIGDLKYovONJ7viWpwevhfvoBh+Q...\"\n+                            ).toContent()\n+                    ),\n+                    senderKey = sentBy.identityKey()\n+            )\n+        }\n+    }\n+}"
        },
        {
          "filename": "matrix-sdk-android/src/test/java/org/matrix/android/sdk/internal/session/room/create/DefaultCreateRoomFromLocalRoomTaskTest.kt",
          "status": "modified",
          "additions": 88,
          "deletions": 43,
          "patch": "@@ -22,51 +22,47 @@ import io.mockk.coVerify\n import io.mockk.every\n import io.mockk.mockk\n import io.mockk.mockkStatic\n+import io.mockk.spyk\n import io.mockk.unmockkAll\n+import io.mockk.verify\n+import io.mockk.verifyOrder\n import io.realm.kotlin.where\n import kotlinx.coroutines.ExperimentalCoroutinesApi\n import kotlinx.coroutines.test.runTest\n import org.amshove.kluent.shouldBeEqualTo\n+import org.amshove.kluent.shouldBeNull\n import org.junit.After\n import org.junit.Before\n import org.junit.Test\n-import org.matrix.android.sdk.api.query.QueryStringValue\n-import org.matrix.android.sdk.api.session.events.model.Event\n-import org.matrix.android.sdk.api.session.events.model.EventType\n-import org.matrix.android.sdk.api.session.events.model.toContent\n-import org.matrix.android.sdk.api.session.events.model.toModel\n+import org.matrix.android.sdk.api.extensions.tryOrNull\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomCreationState\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n import org.matrix.android.sdk.api.session.room.model.create.CreateRoomParams\n-import org.matrix.android.sdk.api.session.room.model.tombstone.RoomTombstoneContent\n import org.matrix.android.sdk.internal.database.awaitNotEmptyResult\n import org.matrix.android.sdk.internal.database.model.CurrentStateEventEntity\n import org.matrix.android.sdk.internal.database.model.EventEntity\n import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntity\n import org.matrix.android.sdk.internal.database.model.LocalRoomSummaryEntityFields\n import org.matrix.android.sdk.internal.database.query.copyToRealmOrIgnore\n import org.matrix.android.sdk.internal.database.query.getOrCreate\n-import org.matrix.android.sdk.internal.util.time.DefaultClock\n import org.matrix.android.sdk.test.fakes.FakeMonarchy\n-import org.matrix.android.sdk.test.fakes.FakeStateEventDataSource\n+import org.matrix.android.sdk.test.fakes.FakeRoomSummaryDataSource\n \n private const val A_LOCAL_ROOM_ID = \"local.a-local-room-id\"\n private const val AN_EXISTING_ROOM_ID = \"an-existing-room-id\"\n private const val A_ROOM_ID = \"a-room-id\"\n-private const val MY_USER_ID = \"my-user-id\"\n \n @ExperimentalCoroutinesApi\n internal class DefaultCreateRoomFromLocalRoomTaskTest {\n \n     private val fakeMonarchy = FakeMonarchy()\n-    private val clock = DefaultClock()\n     private val createRoomTask = mockk<CreateRoomTask>()\n-    private val fakeStateEventDataSource = FakeStateEventDataSource()\n+    private val fakeRoomSummaryDataSource = FakeRoomSummaryDataSource()\n \n     private val defaultCreateRoomFromLocalRoomTask = DefaultCreateRoomFromLocalRoomTask(\n-            userId = MY_USER_ID,\n             monarchy = fakeMonarchy.instance,\n             createRoomTask = createRoomTask,\n-            stateEventDataSource = fakeStateEventDataSource.instance,\n-            clock = clock\n+            roomSummaryDataSource = fakeRoomSummaryDataSource.instance,\n     )\n \n     @Before\n@@ -91,34 +87,31 @@ internal class DefaultCreateRoomFromLocalRoomTaskTest {\n     @Test\n     fun `given a local room id when execute then the existing room id is kept`() = runTest {\n         // Given\n-        givenATombstoneEvent(\n-                Event(\n-                        roomId = A_LOCAL_ROOM_ID,\n-                        type = EventType.STATE_ROOM_TOMBSTONE,\n-                        stateKey = \"\",\n-                        content = RoomTombstoneContent(replacementRoomId = AN_EXISTING_ROOM_ID).toContent()\n-                )\n+        val aCreateRoomParams = mockk<CreateRoomParams>(relaxed = true)\n+        givenALocalRoomSummary(aCreateRoomParams = aCreateRoomParams, aCreationState = LocalRoomCreationState.CREATED, aReplacementRoomId = AN_EXISTING_ROOM_ID)\n+        val aLocalRoomSummaryEntity = givenALocalRoomSummaryEntity(\n+                aCreateRoomParams = aCreateRoomParams,\n+                aCreationState = LocalRoomCreationState.CREATED,\n+                aReplacementRoomId = AN_EXISTING_ROOM_ID\n         )\n \n         // When\n         val params = CreateRoomFromLocalRoomTask.Params(A_LOCAL_ROOM_ID)\n         val result = defaultCreateRoomFromLocalRoomTask.execute(params)\n \n         // Then\n-        verifyTombstoneEvent(AN_EXISTING_ROOM_ID)\n+        fakeRoomSummaryDataSource.verifyGetLocalRoomSummary(A_LOCAL_ROOM_ID)\n         result shouldBeEqualTo AN_EXISTING_ROOM_ID\n+        aLocalRoomSummaryEntity.replacementRoomId shouldBeEqualTo AN_EXISTING_ROOM_ID\n+        aLocalRoomSummaryEntity.creationState shouldBeEqualTo LocalRoomCreationState.CREATED\n     }\n \n     @Test\n     fun `given a local room id when execute then it is correctly executed`() = runTest {\n         // Given\n-        val aCreateRoomParams = mockk<CreateRoomParams>()\n-        val aLocalRoomSummaryEntity = mockk<LocalRoomSummaryEntity> {\n-            every { roomSummaryEntity } returns mockk(relaxed = true)\n-            every { createRoomParams } returns aCreateRoomParams\n-        }\n-        givenATombstoneEvent(null)\n-        givenALocalRoomSummaryEntity(aLocalRoomSummaryEntity)\n+        val aCreateRoomParams = mockk<CreateRoomParams>(relaxed = true)\n+        givenALocalRoomSummary(aCreateRoomParams = aCreateRoomParams, aReplacementRoomId = null)\n+        val aLocalRoomSummaryEntity = givenALocalRoomSummaryEntity(aCreateRoomParams = aCreateRoomParams, aReplacementRoomId = null)\n \n         coEvery { createRoomTask.execute(any()) } returns A_ROOM_ID\n \n@@ -127,32 +120,84 @@ internal class DefaultCreateRoomFromLocalRoomTaskTest {\n         val result = defaultCreateRoomFromLocalRoomTask.execute(params)\n \n         // Then\n-        verifyTombstoneEvent(null)\n+        fakeRoomSummaryDataSource.verifyGetLocalRoomSummary(A_LOCAL_ROOM_ID)\n         // CreateRoomTask has been called with the initial CreateRoomParams\n         coVerify { createRoomTask.execute(aCreateRoomParams) }\n         // The resulting roomId matches the roomId returned by the createRoomTask\n         result shouldBeEqualTo A_ROOM_ID\n-        // A tombstone state event has been created\n-        coVerify { CurrentStateEventEntity.getOrCreate(realm = any(), roomId = A_LOCAL_ROOM_ID, stateKey = any(), type = EventType.STATE_ROOM_TOMBSTONE) }\n+        // The room creation state has correctly been updated\n+        verifyOrder {\n+            aLocalRoomSummaryEntity.creationState = LocalRoomCreationState.CREATING\n+            aLocalRoomSummaryEntity.creationState = LocalRoomCreationState.CREATED\n+        }\n+        // The local room summary has been updated with the created room id\n+        verify { aLocalRoomSummaryEntity.replacementRoomId = A_ROOM_ID }\n+        aLocalRoomSummaryEntity.replacementRoomId shouldBeEqualTo A_ROOM_ID\n+        aLocalRoomSummaryEntity.creationState shouldBeEqualTo LocalRoomCreationState.CREATED\n+    }\n+\n+    @Test\n+    fun `given a local room id when execute with an exception then the creation state is correctly updated`() = runTest {\n+        // Given\n+        val aCreateRoomParams = mockk<CreateRoomParams>(relaxed = true)\n+        givenALocalRoomSummary(aCreateRoomParams = aCreateRoomParams, aReplacementRoomId = null)\n+        val aLocalRoomSummaryEntity = givenALocalRoomSummaryEntity(aCreateRoomParams = aCreateRoomParams, aReplacementRoomId = null)\n+\n+        coEvery { createRoomTask.execute(any()) }.throws(mockk())\n+\n+        // When\n+        val params = CreateRoomFromLocalRoomTask.Params(A_LOCAL_ROOM_ID)\n+        tryOrNull { defaultCreateRoomFromLocalRoomTask.execute(params) }\n+\n+        // Then\n+        fakeRoomSummaryDataSource.verifyGetLocalRoomSummary(A_LOCAL_ROOM_ID)\n+        // CreateRoomTask has been called with the initial CreateRoomParams\n+        coVerify { createRoomTask.execute(aCreateRoomParams) }\n+        // The room creation state has correctly been updated\n+        verifyOrder {\n+            aLocalRoomSummaryEntity.creationState = LocalRoomCreationState.CREATING\n+            aLocalRoomSummaryEntity.creationState = LocalRoomCreationState.FAILURE\n+        }\n+        // The local room summary has been updated with the created room id\n+        aLocalRoomSummaryEntity.replacementRoomId.shouldBeNull()\n+        aLocalRoomSummaryEntity.creationState shouldBeEqualTo LocalRoomCreationState.FAILURE\n     }\n \n-    private fun givenATombstoneEvent(event: Event?) {\n-        fakeStateEventDataSource.givenGetStateEventReturns(event)\n+    private fun givenALocalRoomSummary(\n+            aCreateRoomParams: CreateRoomParams,\n+            aCreationState: LocalRoomCreationState = LocalRoomCreationState.NOT_CREATED,\n+            aReplacementRoomId: String? = null\n+    ): LocalRoomSummary {\n+        val aLocalRoomSummary = LocalRoomSummary(\n+                roomId = A_LOCAL_ROOM_ID,\n+                roomSummary = mockk(relaxed = true),\n+                createRoomParams = aCreateRoomParams,\n+                creationState = aCreationState,\n+                replacementRoomId = aReplacementRoomId,\n+        )\n+        fakeRoomSummaryDataSource.givenGetLocalRoomSummaryReturns(A_LOCAL_ROOM_ID, aLocalRoomSummary)\n+        return aLocalRoomSummary\n     }\n \n-    private fun givenALocalRoomSummaryEntity(localRoomSummaryEntity: LocalRoomSummaryEntity) {\n+    private fun givenALocalRoomSummaryEntity(\n+            aCreateRoomParams: CreateRoomParams,\n+            aCreationState: LocalRoomCreationState = LocalRoomCreationState.NOT_CREATED,\n+            aReplacementRoomId: String? = null\n+    ): LocalRoomSummaryEntity {\n+        val aLocalRoomSummaryEntity = spyk(LocalRoomSummaryEntity(\n+                roomId = A_LOCAL_ROOM_ID,\n+                roomSummaryEntity = mockk(relaxed = true),\n+                replacementRoomId = aReplacementRoomId,\n+        ).apply {\n+            createRoomParams = aCreateRoomParams\n+            creationState = aCreationState\n+        })\n         every {\n             fakeMonarchy.fakeRealm.instance\n                     .where<LocalRoomSummaryEntity>()\n                     .equalTo(LocalRoomSummaryEntityFields.ROOM_ID, A_LOCAL_ROOM_ID)\n                     .findFirst()\n-        } returns localRoomSummaryEntity\n-    }\n-\n-    private fun verifyTombstoneEvent(expectedRoomId: String?) {\n-        fakeStateEventDataSource.verifyGetStateEvent(A_LOCAL_ROOM_ID, EventType.STATE_ROOM_TOMBSTONE, QueryStringValue.IsEmpty)\n-        fakeStateEventDataSource.instance.getStateEvent(A_LOCAL_ROOM_ID, EventType.STATE_ROOM_TOMBSTONE, QueryStringValue.IsEmpty)\n-                ?.content.toModel<RoomTombstoneContent>()\n-                ?.replacementRoomId shouldBeEqualTo expectedRoomId\n+        } returns aLocalRoomSummaryEntity\n+        return aLocalRoomSummaryEntity\n     }\n }"
        },
        {
          "filename": "matrix-sdk-android/src/test/java/org/matrix/android/sdk/test/fakes/FakeMonarchy.kt",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -47,6 +47,11 @@ internal class FakeMonarchy {\n         } coAnswers {\n             firstArg<Monarchy.RealmBlock>().doWithRealm(fakeRealm.instance)\n         }\n+        coEvery {\n+            instance.runTransactionSync(any())\n+        } coAnswers {\n+            firstArg<Realm.Transaction>().execute(fakeRealm.instance)\n+        }\n         every { instance.realmConfiguration } returns mockk()\n     }\n "
        },
        {
          "filename": "matrix-sdk-android/src/test/java/org/matrix/android/sdk/test/fakes/FakeRoomSummaryDataSource.kt",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2022 The Matrix.org Foundation C.I.C.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.matrix.android.sdk.test.fakes\n+\n+import io.mockk.every\n+import io.mockk.mockk\n+import io.mockk.verify\n+import org.matrix.android.sdk.api.session.room.model.LocalRoomSummary\n+import org.matrix.android.sdk.internal.session.room.summary.RoomSummaryDataSource\n+\n+internal class FakeRoomSummaryDataSource {\n+\n+    val instance: RoomSummaryDataSource = mockk()\n+\n+    fun givenGetLocalRoomSummaryReturns(roomId: String?, localRoomSummary: LocalRoomSummary?) {\n+        every { instance.getLocalRoomSummary(roomId = roomId ?: any()) } returns localRoomSummary\n+    }\n+\n+    fun verifyGetLocalRoomSummary(roomId: String) {\n+        verify { instance.getLocalRoomSummary(roomId) }\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 26,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 11,
        "unique_directories": 42,
        "max_directory_depth": 13
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0c68ee45a20818e591e6b8a0276971477851141f",
            "date": "2024-01-10T15:44:11Z",
            "author_login": "bmarty"
          },
          {
            "sha": "a50ef5f77123c0acf88dc772c86df47028144e7c",
            "date": "2024-01-10T15:43:06Z",
            "author_login": "bmarty"
          },
          {
            "sha": "408e57f7a7d196a34e5d764ba9449a40765594a4",
            "date": "2024-01-10T15:22:21Z",
            "author_login": "bmarty"
          },
          {
            "sha": "d4aa5ed12a2c086aa0f8fd5e2d001d39bf229175",
            "date": "2024-01-10T15:38:32Z",
            "author_login": "bmarty"
          },
          {
            "sha": "12e8ad4bf455998ab956d0438f56a429f04d23f1",
            "date": "2024-01-10T15:37:51Z",
            "author_login": "bmarty"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "matrix-android-sdk2 is the Matrix SDK for Android. Prior to version 1.5.1, an attacker cooperating with a malicious homeserver can construct messages that legitimately appear to have come from another person, without any indication such as a grey shield. Additionally, a sophisticated attacker cooperating with a malicious homeserver could employ this vulnerability to perform a targeted attack in order to send fake to-device messages appearing to originate from another user. This can allow, for example, to inject the key backup secret during a self-verification, to make a targeted device start using a malicious key backup spoofed by the homeserver. matrix-android-sdk2 would then additionally sign such a key backup with its device key, spilling trust over to other devices trusting the matrix-android-sdk2 device. These attacks are possible due to a protocol confusion vulnerability that accepts to-device messages encrypted with Megolm instead of Olm. matrix-android-sdk2 version 1.5.1 has been modified to only accept Olm-encrypted to-device messages and to stop signing backups on a successful decryption. Out of caution, several other checks have been audited or added. This attack requires coordination between a malicious home server and an attacker, so those who trust their home servers do not need a workaround.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-28T20:15:15.667",
    "last_modified": "2024-11-21T07:17:52.300",
    "fix_date": "2022-09-28T16:09:06Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/matrix-android-sdk2/commit/77df720a238d17308deab83ecaa37f7a4740a17e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-android-sdk2/releases/tag/v1.5.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-android-sdk2/security/advisories/GHSA-fpgf-pjjv-2qgm",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://matrix.org/blog/2022/09/28/upgrade-now-to-address-encryption-vulns-in-matrix-sdks-and-clients",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-android-sdk2/commit/77df720a238d17308deab83ecaa37f7a4740a17e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-android-sdk2/releases/tag/v1.5.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-android-sdk2/security/advisories/GHSA-fpgf-pjjv-2qgm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://matrix.org/blog/2022/09/28/upgrade-now-to-address-encryption-vulns-in-matrix-sdks-and-clients",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.296213",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "matrix-android-sdk2",
    "owner": "matrix-org",
    "created_at": "2020-08-14T06:58:49Z",
    "updated_at": "2025-01-06T06:23:39Z",
    "pushed_at": "2024-01-10T15:47:35Z",
    "size": 34741,
    "stars": 191,
    "forks": 51,
    "open_issues": 0,
    "watchers": 191,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Kotlin": 5337619,
      "Java": 12316,
      "Shell": 9955,
      "JavaScript": 1782
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T16:48:29.168870"
  }
}