{
  "cve_id": "CVE-2022-39251",
  "github_data": {
    "repository": "matrix-org/matrix-js-sdk",
    "fix_commit": "a587d7c36026fe1fcf93dfff63588abee359be76",
    "related_commits": [
      "a587d7c36026fe1fcf93dfff63588abee359be76",
      "a587d7c36026fe1fcf93dfff63588abee359be76"
    ],
    "patch_url": "https://github.com/matrix-org/matrix-js-sdk/commit/a587d7c36026fe1fcf93dfff63588abee359be76.patch",
    "fix_commit_details": {
      "sha": "a587d7c36026fe1fcf93dfff63588abee359be76",
      "commit_date": "2022-09-28T12:55:15Z",
      "author": {
        "login": "RiotRobot",
        "type": "User",
        "stats": {
          "total_commits": 923,
          "average_weekly_commits": 1.7887596899224807,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 264
        }
      },
      "commit_message": {
        "title": "Resolve multiple CVEs",
        "length": 82,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1454,
        "additions": 1375,
        "deletions": 79
      },
      "files": [
        {
          "filename": "spec/integ/matrix-client-crypto.spec.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -494,6 +494,7 @@ describe(\"MatrixClient crypto\", () => {\n         aliTestClient.expectKeyQuery({ device_keys: { [aliUserId]: {} }, failures: {} });\n         await aliTestClient.start();\n         await bobTestClient.start();\n+        bobTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         await firstSync(aliTestClient);\n         await aliEnablesEncryption();\n         await aliSendsFirstMessage();\n@@ -504,6 +505,7 @@ describe(\"MatrixClient crypto\", () => {\n         aliTestClient.expectKeyQuery({ device_keys: { [aliUserId]: {} }, failures: {} });\n         await aliTestClient.start();\n         await bobTestClient.start();\n+        bobTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         await firstSync(aliTestClient);\n         await aliEnablesEncryption();\n         await aliSendsFirstMessage();\n@@ -567,6 +569,7 @@ describe(\"MatrixClient crypto\", () => {\n         aliTestClient.expectKeyQuery({ device_keys: { [aliUserId]: {} }, failures: {} });\n         await aliTestClient.start();\n         await bobTestClient.start();\n+        bobTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         await firstSync(aliTestClient);\n         await aliEnablesEncryption();\n         await aliSendsFirstMessage();\n@@ -584,6 +587,9 @@ describe(\"MatrixClient crypto\", () => {\n         await firstSync(bobTestClient);\n         await aliEnablesEncryption();\n         await aliSendsFirstMessage();\n+        bobTestClient.httpBackend.when('POST', '/keys/query').respond(\n+            200, {},\n+        );\n         await bobRecvMessage();\n         await bobEnablesEncryption();\n         const ciphertext = await bobSendsReplyMessage();"
        },
        {
          "filename": "spec/integ/matrix-client-syncing.spec.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -87,6 +87,8 @@ describe(\"MatrixClient syncing\", () => {\n         });\n \n         it(\"should emit RoomEvent.MyMembership for invite->leave->invite cycles\", async () => {\n+            await client.initCrypto();\n+\n             const roomId = \"!cycles:example.org\";\n \n             // First sync: an invite"
        },
        {
          "filename": "spec/integ/megolm-integ.spec.ts",
          "status": "modified",
          "additions": 316,
          "deletions": 1,
          "patch": "@@ -29,8 +29,11 @@ import {\n     IDownloadKeyResult,\n     MatrixEvent,\n     MatrixEventEvent,\n+    IndexedDBCryptoStore,\n+    Room,\n } from \"../../src/matrix\";\n import { IDeviceKeys } from \"../../src/crypto/dehydration\";\n+import { DeviceInfo } from \"../../src/crypto/deviceinfo\";\n \n const ROOM_ID = \"!room:id\";\n \n@@ -280,10 +283,13 @@ describe(\"megolm\", () => {\n \n     it(\"Alice receives a megolm message\", async () => {\n         await aliceTestClient.start();\n+        aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         const p2pSession = await createOlmSession(testOlmAccount, aliceTestClient);\n         const groupSession = new Olm.OutboundGroupSession();\n         groupSession.create();\n \n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n         // make the room_key event\n         const roomKeyEncrypted = encryptGroupSessionKey({\n             senderKey: testSenderKey,\n@@ -326,10 +332,13 @@ describe(\"megolm\", () => {\n     it(\"Alice receives a megolm message before the session keys\", async () => {\n         // https://github.com/vector-im/element-web/issues/2273\n         await aliceTestClient.start();\n+        aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         const p2pSession = await createOlmSession(testOlmAccount, aliceTestClient);\n         const groupSession = new Olm.OutboundGroupSession();\n         groupSession.create();\n \n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n         // make the room_key event, but don't send it yet\n         const roomKeyEncrypted = encryptGroupSessionKey({\n             senderKey: testSenderKey,\n@@ -383,10 +392,13 @@ describe(\"megolm\", () => {\n \n     it(\"Alice gets a second room_key message\", async () => {\n         await aliceTestClient.start();\n+        aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         const p2pSession = await createOlmSession(testOlmAccount, aliceTestClient);\n         const groupSession = new Olm.OutboundGroupSession();\n         groupSession.create();\n \n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n         // make the room_key event\n         const roomKeyEncrypted1 = encryptGroupSessionKey({\n             senderKey: testSenderKey,\n@@ -468,6 +480,9 @@ describe(\"megolm\", () => {\n         aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n             200, getTestKeysQueryResponse('@bob:xyz'),\n         );\n+        aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n+            200, getTestKeysQueryResponse('@bob:xyz'),\n+        );\n \n         await Promise.all([\n             aliceTestClient.client.sendTextMessage(ROOM_ID, 'test').then(() => {\n@@ -541,13 +556,16 @@ describe(\"megolm\", () => {\n \n         logger.log('Forcing alice to download our device keys');\n \n+        aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n+            200, getTestKeysQueryResponse('@bob:xyz'),\n+        );\n         aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n             200, getTestKeysQueryResponse('@bob:xyz'),\n         );\n \n         await Promise.all([\n             aliceTestClient.client.downloadKeys(['@bob:xyz']),\n-            aliceTestClient.httpBackend.flush('/keys/query', 1),\n+            aliceTestClient.httpBackend.flush('/keys/query', 2),\n         ]);\n \n         logger.log('Telling alice to block our device');\n@@ -592,6 +610,9 @@ describe(\"megolm\", () => {\n \n         logger.log(\"Fetching bob's devices and marking known\");\n \n+        aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n+            200, getTestKeysQueryResponse('@bob:xyz'),\n+        );\n         aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n             200, getTestKeysQueryResponse('@bob:xyz'),\n         );\n@@ -786,6 +807,10 @@ describe(\"megolm\", () => {\n         logger.log('Forcing alice to download our device keys');\n         const downloadPromise = aliceTestClient.client.downloadKeys(['@bob:xyz']);\n \n+        aliceTestClient.httpBackend.when('POST', '/keys/query').respond(\n+            200, getTestKeysQueryResponse('@bob:xyz'),\n+        );\n+\n         // so will this.\n         const sendPromise = aliceTestClient.client.sendTextMessage(ROOM_ID, 'test')\n             .then(() => {\n@@ -805,9 +830,12 @@ describe(\"megolm\", () => {\n     it(\"Alice exports megolm keys and imports them to a new device\", async () => {\n         aliceTestClient.expectKeyQuery({ device_keys: { '@alice:localhost': {} }, failures: {} });\n         await aliceTestClient.start();\n+        aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         // establish an olm session with alice\n         const p2pSession = await createOlmSession(testOlmAccount, aliceTestClient);\n \n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n         const groupSession = new Olm.OutboundGroupSession();\n         groupSession.create();\n \n@@ -855,6 +883,8 @@ describe(\"megolm\", () => {\n         await aliceTestClient.client.importRoomKeys(exported);\n         await aliceTestClient.start();\n \n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n         const syncResponse = {\n             next_batch: 1,\n             rooms: {\n@@ -927,10 +957,13 @@ describe(\"megolm\", () => {\n \n     it(\"Alice can decrypt a message with falsey content\", async () => {\n         await aliceTestClient.start();\n+        aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n         const p2pSession = await createOlmSession(testOlmAccount, aliceTestClient);\n         const groupSession = new Olm.OutboundGroupSession();\n         groupSession.create();\n \n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n         // make the room_key event\n         const roomKeyEncrypted = encryptGroupSessionKey({\n             senderKey: testSenderKey,\n@@ -985,10 +1018,13 @@ describe(\"megolm\", () => {\n         \"should successfully decrypt bundled redaction events that don't include a room_id in their /sync data\",\n         async () => {\n             await aliceTestClient.start();\n+            aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n             const p2pSession = await createOlmSession(testOlmAccount, aliceTestClient);\n             const groupSession = new Olm.OutboundGroupSession();\n             groupSession.create();\n \n+            aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => \"@bob:xyz\";\n+\n             // make the room_key event\n             const roomKeyEncrypted = encryptGroupSessionKey({\n                 senderKey: testSenderKey,\n@@ -1045,4 +1081,283 @@ describe(\"megolm\", () => {\n             expect(redactionEvent.content.reason).toEqual(\"redaction test\");\n         },\n     );\n+\n+    it(\"Alice receives shared history before being invited to a room by the sharer\", async () => {\n+        const beccaTestClient = new TestClient(\n+            \"@becca:localhost\", \"foobar\", \"bazquux\",\n+        );\n+        await beccaTestClient.client.initCrypto();\n+\n+        await aliceTestClient.start();\n+        aliceTestClient.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n+        await beccaTestClient.start();\n+\n+        const beccaRoom = new Room(ROOM_ID, beccaTestClient.client, \"@becca:localhost\", {});\n+        beccaTestClient.client.store.storeRoom(beccaRoom);\n+        await beccaTestClient.client.setRoomEncryption(ROOM_ID, { \"algorithm\": \"m.megolm.v1.aes-sha2\" });\n+\n+        const event = new MatrixEvent({\n+            type: \"m.room.message\",\n+            sender: \"@becca:localhost\",\n+            room_id: ROOM_ID,\n+            event_id: \"$1\",\n+            content: {\n+                msgtype: \"m.text\",\n+                body: \"test message\",\n+            },\n+        });\n+\n+        await beccaTestClient.client.crypto.encryptEvent(event, beccaRoom);\n+        // remove keys from the event\n+        // @ts-ignore private properties\n+        event.clearEvent = undefined;\n+        // @ts-ignore private properties\n+        event.senderCurve25519Key = null;\n+        // @ts-ignore private properties\n+        event.claimedEd25519Key = null;\n+\n+        const device = new DeviceInfo(beccaTestClient.client.deviceId);\n+        aliceTestClient.client.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+        aliceTestClient.client.crypto.deviceList.getUserByIdentityKey = () => beccaTestClient.client.getUserId();\n+\n+        // Create an olm session for Becca and Alice's devices\n+        const aliceOtks = await aliceTestClient.awaitOneTimeKeyUpload();\n+        const aliceOtkId = Object.keys(aliceOtks)[0];\n+        const aliceOtk = aliceOtks[aliceOtkId];\n+        const p2pSession = new global.Olm.Session();\n+        await beccaTestClient.client.crypto.cryptoStore.doTxn(\n+            'readonly',\n+            [IndexedDBCryptoStore.STORE_ACCOUNT],\n+            (txn) => {\n+                beccaTestClient.client.crypto.cryptoStore.getAccount(txn, (pickledAccount: string) => {\n+                    const account = new global.Olm.Account();\n+                    try {\n+                        account.unpickle(beccaTestClient.client.crypto.olmDevice.pickleKey, pickledAccount);\n+                        p2pSession.create_outbound(account, aliceTestClient.getDeviceKey(), aliceOtk.key);\n+                    } finally {\n+                        account.free();\n+                    }\n+                });\n+            },\n+        );\n+\n+        const content = event.getWireContent();\n+        const groupSessionKey = await beccaTestClient.client.crypto.olmDevice.getInboundGroupSessionKey(\n+            ROOM_ID,\n+            content.sender_key,\n+            content.session_id,\n+        );\n+        const encryptedForwardedKey = encryptOlmEvent({\n+            sender: \"@becca:localhost\",\n+            senderKey: beccaTestClient.getDeviceKey(),\n+            recipient: aliceTestClient,\n+            p2pSession: p2pSession,\n+            plaincontent: {\n+                \"algorithm\": 'm.megolm.v1.aes-sha2',\n+                \"room_id\": ROOM_ID,\n+                \"sender_key\": content.sender_key,\n+                \"sender_claimed_ed25519_key\": groupSessionKey.sender_claimed_ed25519_key,\n+                \"session_id\": content.session_id,\n+                \"session_key\": groupSessionKey.key,\n+                \"chain_index\": groupSessionKey.chain_index,\n+                \"forwarding_curve25519_key_chain\": groupSessionKey.forwarding_curve25519_key_chain,\n+                \"org.matrix.msc3061.shared_history\": true,\n+            },\n+            plaintype: 'm.forwarded_room_key',\n+        });\n+\n+        // Alice receives shared history\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(200, {\n+            next_batch: 1,\n+            to_device: { events: [encryptedForwardedKey] },\n+        });\n+        await aliceTestClient.flushSync();\n+\n+        // Alice is invited to the room by Becca\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(200, {\n+            next_batch: 2,\n+            rooms: { invite: { [ROOM_ID]: { invite_state: { events: [\n+                {\n+                    sender: '@becca:localhost',\n+                    type: 'm.room.encryption',\n+                    state_key: '',\n+                    content: {\n+                        algorithm: 'm.megolm.v1.aes-sha2',\n+                    },\n+                },\n+                {\n+                    sender: '@becca:localhost',\n+                    type: 'm.room.member',\n+                    state_key: '@alice:localhost',\n+                    content: {\n+                        membership: 'invite',\n+                    },\n+                },\n+            ] } } } },\n+        });\n+        await aliceTestClient.flushSync();\n+\n+        // Alice has joined the room\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(\n+            200, getSyncResponse([\"@alice:localhost\", \"@becca:localhost\"]),\n+        );\n+        await aliceTestClient.flushSync();\n+\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(200, {\n+            next_batch: 4,\n+            rooms: {\n+                join: {\n+                    [ROOM_ID]: { timeline: { events: [event.event] } },\n+                },\n+            },\n+        });\n+        await aliceTestClient.flushSync();\n+\n+        const room = aliceTestClient.client.getRoom(ROOM_ID);\n+        const roomEvent = room.getLiveTimeline().getEvents()[0];\n+        expect(roomEvent.isEncrypted()).toBe(true);\n+        const decryptedEvent = await testUtils.awaitDecryption(roomEvent);\n+        expect(decryptedEvent.getContent().body).toEqual('test message');\n+\n+        await beccaTestClient.stop();\n+    });\n+\n+    it(\"Alice receives shared history before being invited to a room by someone else\", async () => {\n+        const beccaTestClient = new TestClient(\n+            \"@becca:localhost\", \"foobar\", \"bazquux\",\n+        );\n+        await beccaTestClient.client.initCrypto();\n+\n+        await aliceTestClient.start();\n+        await beccaTestClient.start();\n+\n+        const beccaRoom = new Room(ROOM_ID, beccaTestClient.client, \"@becca:localhost\", {});\n+        beccaTestClient.client.store.storeRoom(beccaRoom);\n+        await beccaTestClient.client.setRoomEncryption(ROOM_ID, { \"algorithm\": \"m.megolm.v1.aes-sha2\" });\n+\n+        const event = new MatrixEvent({\n+            type: \"m.room.message\",\n+            sender: \"@becca:localhost\",\n+            room_id: ROOM_ID,\n+            event_id: \"$1\",\n+            content: {\n+                msgtype: \"m.text\",\n+                body: \"test message\",\n+            },\n+        });\n+\n+        await beccaTestClient.client.crypto.encryptEvent(event, beccaRoom);\n+        // remove keys from the event\n+        // @ts-ignore private properties\n+        event.clearEvent = undefined;\n+        // @ts-ignore private properties\n+        event.senderCurve25519Key = null;\n+        // @ts-ignore private properties\n+        event.claimedEd25519Key = null;\n+\n+        const device = new DeviceInfo(beccaTestClient.client.deviceId);\n+        aliceTestClient.client.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+\n+        // Create an olm session for Becca and Alice's devices\n+        const aliceOtks = await aliceTestClient.awaitOneTimeKeyUpload();\n+        const aliceOtkId = Object.keys(aliceOtks)[0];\n+        const aliceOtk = aliceOtks[aliceOtkId];\n+        const p2pSession = new global.Olm.Session();\n+        await beccaTestClient.client.crypto.cryptoStore.doTxn(\n+            'readonly',\n+            [IndexedDBCryptoStore.STORE_ACCOUNT],\n+            (txn) => {\n+                beccaTestClient.client.crypto.cryptoStore.getAccount(txn, (pickledAccount: string) => {\n+                    const account = new global.Olm.Account();\n+                    try {\n+                        account.unpickle(beccaTestClient.client.crypto.olmDevice.pickleKey, pickledAccount);\n+                        p2pSession.create_outbound(account, aliceTestClient.getDeviceKey(), aliceOtk.key);\n+                    } finally {\n+                        account.free();\n+                    }\n+                });\n+            },\n+        );\n+\n+        const content = event.getWireContent();\n+        const groupSessionKey = await beccaTestClient.client.crypto.olmDevice.getInboundGroupSessionKey(\n+            ROOM_ID,\n+            content.sender_key,\n+            content.session_id,\n+        );\n+        const encryptedForwardedKey = encryptOlmEvent({\n+            sender: \"@becca:localhost\",\n+            senderKey: beccaTestClient.getDeviceKey(),\n+            recipient: aliceTestClient,\n+            p2pSession: p2pSession,\n+            plaincontent: {\n+                \"algorithm\": 'm.megolm.v1.aes-sha2',\n+                \"room_id\": ROOM_ID,\n+                \"sender_key\": content.sender_key,\n+                \"sender_claimed_ed25519_key\": groupSessionKey.sender_claimed_ed25519_key,\n+                \"session_id\": content.session_id,\n+                \"session_key\": groupSessionKey.key,\n+                \"chain_index\": groupSessionKey.chain_index,\n+                \"forwarding_curve25519_key_chain\": groupSessionKey.forwarding_curve25519_key_chain,\n+                \"org.matrix.msc3061.shared_history\": true,\n+            },\n+            plaintype: 'm.forwarded_room_key',\n+        });\n+\n+        // Alice receives forwarded history from Becca\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(200, {\n+            next_batch: 1,\n+            to_device: { events: [encryptedForwardedKey] },\n+        });\n+        await aliceTestClient.flushSync();\n+\n+        // Alice is invited to the room by Charlie\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(200, {\n+            next_batch: 2,\n+            rooms: { invite: { [ROOM_ID]: { invite_state: { events: [\n+                {\n+                    sender: '@becca:localhost',\n+                    type: 'm.room.encryption',\n+                    state_key: '',\n+                    content: {\n+                        algorithm: 'm.megolm.v1.aes-sha2',\n+                    },\n+                },\n+                {\n+                    sender: '@charlie:localhost',\n+                    type: 'm.room.member',\n+                    state_key: '@alice:localhost',\n+                    content: {\n+                        membership: 'invite',\n+                    },\n+                },\n+            ] } } } },\n+        });\n+        await aliceTestClient.flushSync();\n+\n+        // Alice has joined the room\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(\n+            200, getSyncResponse([\"@alice:localhost\", \"@becca:localhost\", \"@charlie:localhost\"]),\n+        );\n+        await aliceTestClient.flushSync();\n+\n+        aliceTestClient.httpBackend.when(\"GET\", \"/sync\").respond(200, {\n+            next_batch: 4,\n+            rooms: {\n+                join: {\n+                    [ROOM_ID]: { timeline: { events: [event.event] } },\n+                },\n+            },\n+        });\n+        await aliceTestClient.flushSync();\n+\n+        // Decryption should fail, because Alice hasn't received any keys she can trust\n+        const room = aliceTestClient.client.getRoom(ROOM_ID);\n+        const roomEvent = room.getLiveTimeline().getEvents()[0];\n+        expect(roomEvent.isEncrypted()).toBe(true);\n+        const decryptedEvent = await testUtils.awaitDecryption(roomEvent);\n+        expect(decryptedEvent.isDecryptionFailure()).toBe(true);\n+\n+        await beccaTestClient.stop();\n+    });\n });"
        },
        {
          "filename": "spec/unit/content-helpers.spec.ts",
          "status": "modified",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ import {\n     makeBeaconContent,\n     makeBeaconInfoContent,\n     makeTopicContent,\n+    parseBeaconContent,\n     parseTopicContent,\n } from \"../../src/content-helpers\";\n \n@@ -127,6 +128,66 @@ describe('Beacon content helpers', () => {\n             });\n         });\n     });\n+\n+    describe(\"parseBeaconContent()\", () => {\n+        it(\"should not explode when parsing an invalid beacon\", () => {\n+            // deliberate cast to simulate wire content being invalid\n+            const result = parseBeaconContent({} as any);\n+            expect(result).toEqual({\n+                description: undefined,\n+                uri: undefined,\n+                timestamp: undefined,\n+            });\n+        });\n+\n+        it(\"should parse unstable values\", () => {\n+            const uri = \"urigoeshere\";\n+            const description = \"descriptiongoeshere\";\n+            const timestamp = 1234;\n+            const result = parseBeaconContent({\n+                \"org.matrix.msc3488.location\": {\n+                    uri,\n+                    description,\n+                },\n+                \"org.matrix.msc3488.ts\": timestamp,\n+\n+                // relationship not used - just here to satisfy types\n+                \"m.relates_to\": {\n+                    rel_type: \"m.reference\",\n+                    event_id: \"$unused\",\n+                },\n+            });\n+            expect(result).toEqual({\n+                description,\n+                uri,\n+                timestamp,\n+            });\n+        });\n+\n+        it(\"should parse stable values\", () => {\n+            const uri = \"urigoeshere\";\n+            const description = \"descriptiongoeshere\";\n+            const timestamp = 1234;\n+            const result = parseBeaconContent({\n+                \"m.location\": {\n+                    uri,\n+                    description,\n+                },\n+                \"m.ts\": timestamp,\n+\n+                // relationship not used - just here to satisfy types\n+                \"m.relates_to\": {\n+                    rel_type: \"m.reference\",\n+                    event_id: \"$unused\",\n+                },\n+            });\n+            expect(result).toEqual({\n+                description,\n+                uri,\n+                timestamp,\n+            });\n+        });\n+    });\n });\n \n describe('Topic content helpers', () => {"
        },
        {
          "filename": "spec/unit/crypto.spec.ts",
          "status": "modified",
          "additions": 498,
          "deletions": 12,
          "patch": "@@ -15,6 +15,8 @@ import { CRYPTO_ENABLED } from \"../../src/client\";\n import { DeviceInfo } from \"../../src/crypto/deviceinfo\";\n import { logger } from '../../src/logger';\n import { MemoryStore } from \"../../src\";\n+import { RoomKeyRequestState } from '../../src/crypto/OutgoingRoomKeyRequestManager';\n+import { RoomMember } from '../../src/models/room-member';\n import { IStore } from '../../src/store';\n \n const Olm = global.Olm;\n@@ -40,20 +42,52 @@ async function keyshareEventForEvent(client, event, index): Promise<MatrixEvent>\n         type: \"m.forwarded_room_key\",\n         sender: client.getUserId(),\n         content: {\n-            algorithm: olmlib.MEGOLM_ALGORITHM,\n-            room_id: roomId,\n-            sender_key: eventContent.sender_key,\n-            sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,\n-            session_id: eventContent.session_id,\n-            session_key: key.key,\n-            chain_index: key.chain_index,\n-            forwarding_curve25519_key_chain:\n-            key.forwarding_curve_key_chain,\n+            \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n+            \"room_id\": roomId,\n+            \"sender_key\": eventContent.sender_key,\n+            \"sender_claimed_ed25519_key\": key.sender_claimed_ed25519_key,\n+            \"session_id\": eventContent.session_id,\n+            \"session_key\": key.key,\n+            \"chain_index\": key.chain_index,\n+            \"forwarding_curve25519_key_chain\": key.forwarding_curve_key_chain,\n+            \"org.matrix.msc3061.shared_history\": true,\n         },\n     });\n     // make onRoomKeyEvent think this was an encrypted event\n     // @ts-ignore private property\n     ksEvent.senderCurve25519Key = \"akey\";\n+    ksEvent.getWireType = () => \"m.room.encrypted\";\n+    ksEvent.getWireContent = () => {\n+        return {\n+            algorithm: \"m.olm.v1.curve25519-aes-sha2\",\n+        };\n+    };\n+    return ksEvent;\n+}\n+\n+function roomKeyEventForEvent(client: MatrixClient, event: MatrixEvent): MatrixEvent {\n+    const roomId = event.getRoomId();\n+    const eventContent = event.getWireContent();\n+    const key = client.crypto.olmDevice.getOutboundGroupSessionKey(eventContent.session_id);\n+    const ksEvent = new MatrixEvent({\n+        type: \"m.room_key\",\n+        sender: client.getUserId(),\n+        content: {\n+            \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n+            \"room_id\": roomId,\n+            \"session_id\": eventContent.session_id,\n+            \"session_key\": key.key,\n+        },\n+    });\n+    // make onRoomKeyEvent think this was an encrypted event\n+    // @ts-ignore private property\n+    ksEvent.senderCurve25519Key = event.getSenderKey();\n+    ksEvent.getWireType = () => \"m.room.encrypted\";\n+    ksEvent.getWireContent = () => {\n+        return {\n+            algorithm: \"m.olm.v1.curve25519-aes-sha2\",\n+        };\n+    };\n     return ksEvent;\n }\n \n@@ -95,7 +129,7 @@ describe(\"Crypto\", function() {\n             event.getSenderKey = () => 'YmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmI';\n             event.getWireContent = () => {return { algorithm: olmlib.MEGOLM_ALGORITHM };};\n             event.getForwardingCurve25519KeyChain = () => [\"not empty\"];\n-            event.isKeySourceUntrusted = () => false;\n+            event.isKeySourceUntrusted = () => true;\n             event.getClaimedEd25519Key =\n                 () => 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';\n \n@@ -233,6 +267,7 @@ describe(\"Crypto\", function() {\n     describe('Key requests', function() {\n         let aliceClient: MatrixClient;\n         let bobClient: MatrixClient;\n+        let claraClient: MatrixClient;\n \n         beforeEach(async function() {\n             aliceClient = (new TestClient(\n@@ -241,22 +276,35 @@ describe(\"Crypto\", function() {\n             bobClient = (new TestClient(\n                 \"@bob:example.com\", \"bobdevice\",\n             )).client;\n+            claraClient = (new TestClient(\n+                \"@clara:example.com\", \"claradevice\",\n+            )).client;\n             await aliceClient.initCrypto();\n             await bobClient.initCrypto();\n+            await claraClient.initCrypto();\n         });\n \n         afterEach(async function() {\n             aliceClient.stopClient();\n             bobClient.stopClient();\n+            claraClient.stopClient();\n         });\n \n-        it(\"does not cancel keyshare requests if some messages are not decrypted\", async function() {\n+        it(\"does not cancel keyshare requests until all messages are decrypted with trusted keys\", async function() {\n             const encryptionCfg = {\n                 \"algorithm\": \"m.megolm.v1.aes-sha2\",\n             };\n             const roomId = \"!someroom\";\n             const aliceRoom = new Room(roomId, aliceClient, \"@alice:example.com\", {});\n             const bobRoom = new Room(roomId, bobClient, \"@bob:example.com\", {});\n+            // Make Bob invited by Alice so Bob will accept Alice's forwarded keys\n+            bobRoom.currentState.setStateEvents([new MatrixEvent({\n+                type: \"m.room.member\",\n+                sender: \"@alice:example.com\",\n+                room_id: roomId,\n+                content: { membership: \"invite\" },\n+                state_key: \"@bob:example.com\",\n+            })]);\n             aliceClient.store.storeRoom(aliceRoom);\n             bobClient.store.storeRoom(bobRoom);\n             await aliceClient.setRoomEncryption(roomId, encryptionCfg);\n@@ -302,6 +350,9 @@ describe(\"Crypto\", function() {\n                 }\n             }));\n \n+            const device = new DeviceInfo(aliceClient.deviceId);\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+\n             const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n                 roomId, olmlib.MEGOLM_ALGORITHM,\n             );\n@@ -314,6 +365,8 @@ describe(\"Crypto\", function() {\n             // the first message can't be decrypted yet, but the second one\n             // can\n             let ksEvent = await keyshareEventForEvent(aliceClient, events[1], 1);\n+            bobClient.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n+            bobClient.crypto.deviceList.getUserByIdentityKey = () => \"@alice:example.com\";\n             await bobDecryptor.onRoomKeyEvent(ksEvent);\n             await decryptEventsPromise;\n             expect(events[0].getContent().msgtype).toBe(\"m.bad.encrypted\");\n@@ -340,8 +393,24 @@ describe(\"Crypto\", function() {\n             await bobDecryptor.onRoomKeyEvent(ksEvent);\n             await decryptEventPromise;\n             expect(events[0].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+            expect(events[0].isKeySourceUntrusted()).toBeTruthy();\n+            await sleep(1);\n+            // the room key request should still be there, since we've\n+            // decrypted everything with an untrusted key\n+            expect(await cryptoStore.getOutgoingRoomKeyRequest(roomKeyRequestBody)).toBeDefined();\n+\n+            // Now share a trusted room key event so Bob will re-decrypt the messages.\n+            // Bob will backfill trust when they receive a trusted session with a higher\n+            // index that connects to an untrusted session with a lower index.\n+            const roomKeyEvent = roomKeyEventForEvent(aliceClient, events[1]);\n+            const trustedDecryptEventPromise = awaitEvent(events[0], \"Event.decrypted\");\n+            await bobDecryptor.onRoomKeyEvent(roomKeyEvent);\n+            await trustedDecryptEventPromise;\n+            expect(events[0].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+            expect(events[0].isKeySourceUntrusted()).toBeFalsy();\n             await sleep(1);\n-            // the room key request should be gone since we've now decrypted everything\n+            // now the room key request should be gone, since there's\n+            // no better key to wait for\n             expect(await cryptoStore.getOutgoingRoomKeyRequest(roomKeyRequestBody)).toBeFalsy();\n         });\n \n@@ -383,6 +452,9 @@ describe(\"Crypto\", function() {\n                 // decryption keys yet\n             }\n \n+            const device = new DeviceInfo(aliceClient.deviceId);\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+\n             const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n                 roomId, olmlib.MEGOLM_ALGORITHM,\n             );\n@@ -462,6 +534,420 @@ describe(\"Crypto\", function() {\n             expect(aliceSendToDevice).toBeCalledTimes(3);\n             expect(aliceSendToDevice.mock.calls[2][2]).not.toBe(txnId);\n         });\n+\n+        it(\"should accept forwarded keys which it requested\", async function() {\n+            const encryptionCfg = {\n+                \"algorithm\": \"m.megolm.v1.aes-sha2\",\n+            };\n+            const roomId = \"!someroom\";\n+            const aliceRoom = new Room(roomId, aliceClient, \"@alice:example.com\", {});\n+            const bobRoom = new Room(roomId, bobClient, \"@bob:example.com\", {});\n+            aliceClient.store.storeRoom(aliceRoom);\n+            bobClient.store.storeRoom(bobRoom);\n+            await aliceClient.setRoomEncryption(roomId, encryptionCfg);\n+            await bobClient.setRoomEncryption(roomId, encryptionCfg);\n+            const events = [\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$1\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"1\",\n+                    },\n+                }),\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$2\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"2\",\n+                    },\n+                }),\n+            ];\n+            await Promise.all(events.map(async (event) => {\n+                // alice encrypts each event, and then bob tries to decrypt\n+                // them without any keys, so that they'll be in pending\n+                await aliceClient.crypto.encryptEvent(event, aliceRoom);\n+                // remove keys from the event\n+                // @ts-ignore private properties\n+                event.clearEvent = undefined;\n+                // @ts-ignore private properties\n+                event.senderCurve25519Key = null;\n+                // @ts-ignore private properties\n+                event.claimedEd25519Key = null;\n+                try {\n+                    await bobClient.crypto.decryptEvent(event);\n+                } catch (e) {\n+                    // we expect this to fail because we don't have the\n+                    // decryption keys yet\n+                }\n+            }));\n+\n+            const device = new DeviceInfo(aliceClient.deviceId);\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+            bobClient.crypto.deviceList.getUserByIdentityKey = () => \"@alice:example.com\";\n+\n+            const cryptoStore = bobClient.crypto.cryptoStore;\n+            const eventContent = events[0].getWireContent();\n+            const senderKey = eventContent.sender_key;\n+            const sessionId = eventContent.session_id;\n+            const roomKeyRequestBody = {\n+                algorithm: olmlib.MEGOLM_ALGORITHM,\n+                room_id: roomId,\n+                sender_key: senderKey,\n+                session_id: sessionId,\n+            };\n+            const outgoingReq = await cryptoStore.getOutgoingRoomKeyRequest(roomKeyRequestBody);\n+            expect(outgoingReq).toBeDefined();\n+            await cryptoStore.updateOutgoingRoomKeyRequest(\n+                outgoingReq.requestId, RoomKeyRequestState.Unsent,\n+                { state: RoomKeyRequestState.Sent },\n+            );\n+\n+            const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n+                roomId, olmlib.MEGOLM_ALGORITHM,\n+            );\n+\n+            const decryptEventsPromise = Promise.all(events.map((ev) => {\n+                return awaitEvent(ev, \"Event.decrypted\");\n+            }));\n+            const ksEvent = await keyshareEventForEvent(aliceClient, events[0], 0);\n+            await bobDecryptor.onRoomKeyEvent(ksEvent);\n+            const key = await bobClient.crypto.olmDevice.getInboundGroupSessionKey(\n+                roomId,\n+                events[0].getWireContent().sender_key,\n+                events[0].getWireContent().session_id,\n+            );\n+            expect(key).not.toBeNull();\n+            await decryptEventsPromise;\n+            expect(events[0].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+            expect(events[1].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+        });\n+\n+        it(\"should accept forwarded keys from the user who invited it to the room\", async function() {\n+            const encryptionCfg = {\n+                \"algorithm\": \"m.megolm.v1.aes-sha2\",\n+            };\n+            const roomId = \"!someroom\";\n+            const aliceRoom = new Room(roomId, aliceClient, \"@alice:example.com\", {});\n+            const bobRoom = new Room(roomId, bobClient, \"@bob:example.com\", {});\n+            const claraRoom = new Room(roomId, claraClient, \"@clara:example.com\", {});\n+            // Make Bob invited by Clara\n+            bobRoom.currentState.setStateEvents([new MatrixEvent({\n+                type: \"m.room.member\",\n+                sender: \"@clara:example.com\",\n+                room_id: roomId,\n+                content: { membership: \"invite\" },\n+                state_key: \"@bob:example.com\",\n+            })]);\n+            aliceClient.store.storeRoom(aliceRoom);\n+            bobClient.store.storeRoom(bobRoom);\n+            claraClient.store.storeRoom(claraRoom);\n+            await aliceClient.setRoomEncryption(roomId, encryptionCfg);\n+            await bobClient.setRoomEncryption(roomId, encryptionCfg);\n+            await claraClient.setRoomEncryption(roomId, encryptionCfg);\n+            const events = [\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$1\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"1\",\n+                    },\n+                }),\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$2\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"2\",\n+                    },\n+                }),\n+            ];\n+            await Promise.all(events.map(async (event) => {\n+                // alice encrypts each event, and then bob tries to decrypt\n+                // them without any keys, so that they'll be in pending\n+                await aliceClient.crypto.encryptEvent(event, aliceRoom);\n+                // remove keys from the event\n+                // @ts-ignore private properties\n+                event.clearEvent = undefined;\n+                // @ts-ignore private properties\n+                event.senderCurve25519Key = null;\n+                // @ts-ignore private properties\n+                event.claimedEd25519Key = null;\n+                try {\n+                    await bobClient.crypto.decryptEvent(event);\n+                } catch (e) {\n+                    // we expect this to fail because we don't have the\n+                    // decryption keys yet\n+                }\n+            }));\n+\n+            const device = new DeviceInfo(claraClient.deviceId);\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+            bobClient.crypto.deviceList.getUserByIdentityKey = () => \"@clara:example.com\";\n+\n+            const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n+                roomId, olmlib.MEGOLM_ALGORITHM,\n+            );\n+\n+            const decryptEventsPromise = Promise.all(events.map((ev) => {\n+                return awaitEvent(ev, \"Event.decrypted\");\n+            }));\n+            const ksEvent = await keyshareEventForEvent(aliceClient, events[0], 0);\n+            ksEvent.event.sender = claraClient.getUserId(),\n+            ksEvent.sender = new RoomMember(roomId, claraClient.getUserId());\n+            await bobDecryptor.onRoomKeyEvent(ksEvent);\n+            const key = await bobClient.crypto.olmDevice.getInboundGroupSessionKey(\n+                roomId,\n+                events[0].getWireContent().sender_key,\n+                events[0].getWireContent().session_id,\n+            );\n+            expect(key).not.toBeNull();\n+            await decryptEventsPromise;\n+            expect(events[0].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+            expect(events[1].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+        });\n+\n+        it(\"should accept forwarded keys from one of its own user's other devices\", async function() {\n+            const encryptionCfg = {\n+                \"algorithm\": \"m.megolm.v1.aes-sha2\",\n+            };\n+            const roomId = \"!someroom\";\n+            const aliceRoom = new Room(roomId, aliceClient, \"@alice:example.com\", {});\n+            const bobRoom = new Room(roomId, bobClient, \"@bob:example.com\", {});\n+            aliceClient.store.storeRoom(aliceRoom);\n+            bobClient.store.storeRoom(bobRoom);\n+            await aliceClient.setRoomEncryption(roomId, encryptionCfg);\n+            await bobClient.setRoomEncryption(roomId, encryptionCfg);\n+            const events = [\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$1\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"1\",\n+                    },\n+                }),\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$2\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"2\",\n+                    },\n+                }),\n+            ];\n+            await Promise.all(events.map(async (event) => {\n+                // alice encrypts each event, and then bob tries to decrypt\n+                // them without any keys, so that they'll be in pending\n+                await aliceClient.crypto.encryptEvent(event, aliceRoom);\n+                // remove keys from the event\n+                // @ts-ignore private properties\n+                event.clearEvent = undefined;\n+                // @ts-ignore private properties\n+                event.senderCurve25519Key = null;\n+                // @ts-ignore private properties\n+                event.claimedEd25519Key = null;\n+                try {\n+                    await bobClient.crypto.decryptEvent(event);\n+                } catch (e) {\n+                    // we expect this to fail because we don't have the\n+                    // decryption keys yet\n+                }\n+            }));\n+\n+            const device = new DeviceInfo(claraClient.deviceId);\n+            device.verified = DeviceInfo.DeviceVerification.VERIFIED;\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+            bobClient.crypto.deviceList.getUserByIdentityKey = () => \"@bob:example.com\";\n+\n+            const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n+                roomId, olmlib.MEGOLM_ALGORITHM,\n+            );\n+\n+            const decryptEventsPromise = Promise.all(events.map((ev) => {\n+                return awaitEvent(ev, \"Event.decrypted\");\n+            }));\n+            const ksEvent = await keyshareEventForEvent(aliceClient, events[0], 0);\n+            ksEvent.event.sender = bobClient.getUserId(),\n+            ksEvent.sender = new RoomMember(roomId, bobClient.getUserId());\n+            await bobDecryptor.onRoomKeyEvent(ksEvent);\n+            const key = await bobClient.crypto.olmDevice.getInboundGroupSessionKey(\n+                roomId,\n+                events[0].getWireContent().sender_key,\n+                events[0].getWireContent().session_id,\n+            );\n+            expect(key).not.toBeNull();\n+            await decryptEventsPromise;\n+            expect(events[0].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+            expect(events[1].getContent().msgtype).not.toBe(\"m.bad.encrypted\");\n+        });\n+\n+        it(\"should not accept unexpected forwarded keys for a room it's in\", async function() {\n+            const encryptionCfg = {\n+                \"algorithm\": \"m.megolm.v1.aes-sha2\",\n+            };\n+            const roomId = \"!someroom\";\n+            const aliceRoom = new Room(roomId, aliceClient, \"@alice:example.com\", {});\n+            const bobRoom = new Room(roomId, bobClient, \"@bob:example.com\", {});\n+            const claraRoom = new Room(roomId, claraClient, \"@clara:example.com\", {});\n+            aliceClient.store.storeRoom(aliceRoom);\n+            bobClient.store.storeRoom(bobRoom);\n+            claraClient.store.storeRoom(claraRoom);\n+            await aliceClient.setRoomEncryption(roomId, encryptionCfg);\n+            await bobClient.setRoomEncryption(roomId, encryptionCfg);\n+            await claraClient.setRoomEncryption(roomId, encryptionCfg);\n+            const events = [\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$1\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"1\",\n+                    },\n+                }),\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$2\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"2\",\n+                    },\n+                }),\n+            ];\n+            await Promise.all(events.map(async (event) => {\n+                // alice encrypts each event, and then bob tries to decrypt\n+                // them without any keys, so that they'll be in pending\n+                await aliceClient.crypto.encryptEvent(event, aliceRoom);\n+                // remove keys from the event\n+                // @ts-ignore private properties\n+                event.clearEvent = undefined;\n+                // @ts-ignore private properties\n+                event.senderCurve25519Key = null;\n+                // @ts-ignore private properties\n+                event.claimedEd25519Key = null;\n+                try {\n+                    await bobClient.crypto.decryptEvent(event);\n+                } catch (e) {\n+                    // we expect this to fail because we don't have the\n+                    // decryption keys yet\n+                }\n+            }));\n+\n+            const device = new DeviceInfo(claraClient.deviceId);\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+            bobClient.crypto.deviceList.getUserByIdentityKey = () => \"@alice:example.com\";\n+\n+            const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n+                roomId, olmlib.MEGOLM_ALGORITHM,\n+            );\n+\n+            const ksEvent = await keyshareEventForEvent(aliceClient, events[0], 0);\n+            ksEvent.event.sender = claraClient.getUserId(),\n+            ksEvent.sender = new RoomMember(roomId, claraClient.getUserId());\n+            await bobDecryptor.onRoomKeyEvent(ksEvent);\n+            const key = await bobClient.crypto.olmDevice.getInboundGroupSessionKey(\n+                roomId,\n+                events[0].getWireContent().sender_key,\n+                events[0].getWireContent().session_id,\n+            );\n+            expect(key).toBeNull();\n+        });\n+\n+        it(\"should park forwarded keys for a room it's not in\", async function() {\n+            const encryptionCfg = {\n+                \"algorithm\": \"m.megolm.v1.aes-sha2\",\n+            };\n+            const roomId = \"!someroom\";\n+            const aliceRoom = new Room(roomId, aliceClient, \"@alice:example.com\", {});\n+            aliceClient.store.storeRoom(aliceRoom);\n+            await aliceClient.setRoomEncryption(roomId, encryptionCfg);\n+            const events = [\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$1\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"1\",\n+                    },\n+                }),\n+                new MatrixEvent({\n+                    type: \"m.room.message\",\n+                    sender: \"@alice:example.com\",\n+                    room_id: roomId,\n+                    event_id: \"$2\",\n+                    content: {\n+                        msgtype: \"m.text\",\n+                        body: \"2\",\n+                    },\n+                }),\n+            ];\n+            await Promise.all(events.map(async (event) => {\n+                // alice encrypts each event, and then bob tries to decrypt\n+                // them without any keys, so that they'll be in pending\n+                await aliceClient.crypto.encryptEvent(event, aliceRoom);\n+                // remove keys from the event\n+                // @ts-ignore private properties\n+                event.clearEvent = undefined;\n+                // @ts-ignore private properties\n+                event.senderCurve25519Key = null;\n+                // @ts-ignore private properties\n+                event.claimedEd25519Key = null;\n+            }));\n+\n+            const device = new DeviceInfo(aliceClient.deviceId);\n+            bobClient.crypto.deviceList.getDeviceByIdentityKey = () => device;\n+            bobClient.crypto.deviceList.getUserByIdentityKey = () => \"@alice:example.com\";\n+\n+            const bobDecryptor = bobClient.crypto.getRoomDecryptor(\n+                roomId, olmlib.MEGOLM_ALGORITHM,\n+            );\n+\n+            const content = events[0].getWireContent();\n+\n+            const ksEvent = await keyshareEventForEvent(aliceClient, events[0], 0);\n+            await bobDecryptor.onRoomKeyEvent(ksEvent);\n+            const bobKey = await bobClient.crypto.olmDevice.getInboundGroupSessionKey(\n+                roomId,\n+                content.sender_key,\n+                content.session_id,\n+            );\n+            expect(bobKey).toBeNull();\n+\n+            const aliceKey = await aliceClient.crypto.olmDevice.getInboundGroupSessionKey(\n+                roomId,\n+                content.sender_key,\n+                content.session_id,\n+            );\n+            const parked = await bobClient.crypto.cryptoStore.takeParkedSharedHistory(roomId);\n+            expect(parked).toEqual([{\n+                senderId: aliceClient.getUserId(),\n+                senderKey: content.sender_key,\n+                sessionId: content.session_id,\n+                sessionKey: aliceKey.key,\n+                keysClaimed: { ed25519: aliceKey.sender_claimed_ed25519_key },\n+                forwardingCurve25519KeyChain: [\"akey\"],\n+            }]);\n+        });\n     });\n \n     describe('Secret storage', function() {"
        },
        {
          "filename": "spec/unit/crypto/algorithms/megolm.spec.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -110,6 +110,12 @@ describe(\"MegolmDecryption\", function() {\n                 senderCurve25519Key: \"SENDER_CURVE25519\",\n                 claimedEd25519Key: \"SENDER_ED25519\",\n             };\n+            event.getWireType = () => \"m.room.encrypted\";\n+            event.getWireContent = () => {\n+                return {\n+                    algorithm: \"m.olm.v1.curve25519-aes-sha2\",\n+                };\n+            };\n \n             const mockCrypto = {\n                 decryptEvent: function() {"
        },
        {
          "filename": "spec/unit/crypto/backup.spec.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -214,6 +214,12 @@ describe(\"MegolmBackup\", function() {\n             const event = new MatrixEvent({\n                 type: 'm.room.encrypted',\n             });\n+            event.getWireType = () => \"m.room.encrypted\";\n+            event.getWireContent = () => {\n+                return {\n+                    algorithm: \"m.olm.v1.curve25519-aes-sha2\",\n+                };\n+            };\n             const decryptedData = {\n                 clearEvent: {\n                     type: 'm.room_key',"
        },
        {
          "filename": "spec/unit/crypto/secrets.spec.ts",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -26,6 +26,7 @@ import { logger } from '../../../src/logger';\n import * as utils from \"../../../src/utils\";\n import { ICreateClientOpts } from '../../../src/client';\n import { ISecretStorageKeyInfo } from '../../../src/crypto/api';\n+import { DeviceInfo } from '../../../src/crypto/deviceinfo';\n \n try {\n     // eslint-disable-next-line @typescript-eslint/no-var-requires\n@@ -257,6 +258,7 @@ describe(\"Secrets\", function() {\n                     \"ed25519:VAX\": vaxDevice.deviceEd25519Key,\n                     \"curve25519:VAX\": vaxDevice.deviceCurve25519Key,\n                 },\n+                verified: DeviceInfo.DeviceVerification.VERIFIED,\n             },\n         });\n         vax.client.crypto.deviceList.storeDevicesForUser(\"@alice:example.com\", {\n@@ -280,10 +282,12 @@ describe(\"Secrets\", function() {\n             Object.values(otks)[0],\n         );\n \n+        osborne2.client.crypto.deviceList.downloadKeys = () => Promise.resolve({});\n+        osborne2.client.crypto.deviceList.getUserByIdentityKey = () => \"@alice:example.com\";\n+\n         const request = await secretStorage.request(\"foo\", [\"VAX\"]);\n-        const secret = await request.promise;\n+        await request.promise; // return value not used\n \n-        expect(secret).toBe(\"bar\");\n         osborne2.stop();\n         vax.stop();\n         clearTestClientTimeouts();"
        },
        {
          "filename": "spec/unit/crypto/verification/sas.spec.ts",
          "status": "modified",
          "additions": 20,
          "deletions": 6,
          "patch": "@@ -464,7 +464,7 @@ describe(\"SAS verification\", function() {\n                 },\n             );\n \n-            alice.client.setDeviceVerified = jest.fn();\n+            alice.client.crypto.setDeviceVerification = jest.fn();\n             alice.client.getDeviceEd25519Key = () => {\n                 return \"alice+base64+ed25519+key\";\n             };\n@@ -482,7 +482,7 @@ describe(\"SAS verification\", function() {\n                 return Promise.resolve();\n             };\n \n-            bob.client.setDeviceVerified = jest.fn();\n+            bob.client.crypto.setDeviceVerification = jest.fn();\n             bob.client.getStoredDevice = () => {\n                 return DeviceInfo.fromStorage(\n                     {\n@@ -565,10 +565,24 @@ describe(\"SAS verification\", function() {\n             ]);\n \n             // make sure Alice and Bob verified each other\n-            expect(alice.client.setDeviceVerified)\n-                .toHaveBeenCalledWith(bob.client.getUserId(), bob.client.deviceId);\n-            expect(bob.client.setDeviceVerified)\n-                .toHaveBeenCalledWith(alice.client.getUserId(), alice.client.deviceId);\n+            expect(alice.client.crypto.setDeviceVerification)\n+                .toHaveBeenCalledWith(\n+                    bob.client.getUserId(),\n+                    bob.client.deviceId,\n+                    true,\n+                    null,\n+                    null,\n+                    { \"ed25519:Dynabook\": \"bob+base64+ed25519+key\" },\n+            );\n+            expect(bob.client.crypto.setDeviceVerification)\n+                .toHaveBeenCalledWith(\n+                    alice.client.getUserId(),\n+                    alice.client.deviceId,\n+                    true,\n+                    null,\n+                    null,\n+                    { \"ed25519:Osborne2\": \"alice+base64+ed25519+key\" },\n+            );\n         });\n     });\n });"
        },
        {
          "filename": "spec/unit/models/beacon.spec.ts",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ import {\n     BeaconEvent,\n } from \"../../../src/models/beacon\";\n import { makeBeaconEvent, makeBeaconInfoEvent } from \"../../test-utils/beacon\";\n+import { REFERENCE_RELATION } from \"matrix-events-sdk\";\n \n jest.useFakeTimers();\n \n@@ -431,6 +432,27 @@ describe('Beacon', () => {\n                 expect(emitSpy).not.toHaveBeenCalled();\n             });\n \n+            it(\"should ignore invalid beacon events\", () => {\n+                const beacon = new Beacon(makeBeaconInfoEvent(userId, roomId, { isLive: true, timeout: 60000 }));\n+                const emitSpy = jest.spyOn(beacon, 'emit');\n+\n+                const ev = new MatrixEvent({\n+                    type: M_BEACON_INFO.name,\n+                    sender: userId,\n+                    room_id: roomId,\n+                    content: {\n+                        \"m.relates_to\": {\n+                            rel_type: REFERENCE_RELATION.name,\n+                            event_id: beacon.beaconInfoId,\n+                        },\n+                    },\n+                });\n+                beacon.addLocations([ev]);\n+\n+                expect(beacon.latestLocationEvent).toBeFalsy();\n+                expect(emitSpy).not.toHaveBeenCalled();\n+            });\n+\n             describe('when beacon is live with a start timestamp is in the future', () => {\n                 it('ignores locations before the beacon start timestamp', () => {\n                     const startTimestamp = now + 60000;"
        },
        {
          "filename": "src/@types/crypto.ts",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+/*\n+Copyright 2022 The Matrix.org Foundation C.I.C.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+export type OlmGroupSessionExtraData = {\n+    untrusted?: boolean;\n+    sharedHistory?: boolean;\n+};"
        },
        {
          "filename": "src/NamespacedValue.ts",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -1,5 +1,5 @@\n /*\n-Copyright 2021 The Matrix.org Foundation C.I.C.\n+Copyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n@@ -14,6 +14,8 @@ See the License for the specific language governing permissions and\n limitations under the License.\n */\n \n+import { Optional } from \"matrix-events-sdk/lib/types\";\n+\n /**\n  * Represents a simple Matrix namespaced value. This will assume that if a stable prefix\n  * is provided that the stable prefix should be used when representing the identifier.\n@@ -54,7 +56,7 @@ export class NamespacedValue<S extends string, U extends string> {\n \n     // this desperately wants https://github.com/microsoft/TypeScript/pull/26349 at the top level of the class\n     // so we can instantiate `NamespacedValue<string, _, _>` as a default type for that namespace.\n-    public findIn<T>(obj: any): T {\n+    public findIn<T>(obj: any): Optional<T> {\n         let val: T;\n         if (this.name) {\n             val = obj?.[this.name];"
        },
        {
          "filename": "src/client.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -5287,6 +5287,7 @@ export class MatrixClient extends TypedEventEmitter<EmittedEvents, ClientEventHa\n      * @param {object} [options]\n      * @param {boolean} options.preventReEmit don't re-emit events emitted on an event mapped by this mapper on the client\n      * @param {boolean} options.decrypt decrypt event proactively\n+     * @param {boolean} options.toDevice the event is a to_device event\n      * @return {Function}\n      */\n     public getEventMapper(options?: MapperOpts): EventMapper {"
        },
        {
          "filename": "src/content-helpers.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -292,16 +292,17 @@ export const makeBeaconContent: MakeBeaconContent = (\n });\n \n export type BeaconLocationState = MLocationContent & {\n-    timestamp: number;\n+    uri?: string; // override from MLocationContent to allow optionals\n+    timestamp?: number;\n };\n \n export const parseBeaconContent = (content: MBeaconEventContent): BeaconLocationState => {\n-    const { description, uri } = M_LOCATION.findIn<MLocationContent>(content);\n+    const location = M_LOCATION.findIn<MLocationContent>(content);\n     const timestamp = M_TIMESTAMP.findIn<number>(content);\n \n     return {\n-        description,\n-        uri,\n+        description: location?.description,\n+        uri: location?.uri,\n         timestamp,\n     };\n };"
        },
        {
          "filename": "src/crypto/OlmDevice.ts",
          "status": "modified",
          "additions": 51,
          "deletions": 14,
          "patch": "@@ -23,6 +23,7 @@ import * as algorithms from './algorithms';\n import { CryptoStore, IProblem, ISessionInfo, IWithheld } from \"./store/base\";\n import { IOlmDevice, IOutboundGroupSessionKey } from \"./algorithms/megolm\";\n import { IMegolmSessionData } from \"./index\";\n+import { OlmGroupSessionExtraData } from \"../@types/crypto\";\n \n // The maximum size of an event is 65K, and we base64 the content, so this is a\n // reasonable approximation to the biggest plaintext we can encrypt.\n@@ -122,6 +123,7 @@ interface IInboundGroupSessionKey {\n     forwarding_curve25519_key_chain: string[];\n     sender_claimed_ed25519_key: string;\n     shared_history: boolean;\n+    untrusted: boolean;\n }\n /* eslint-enable camelcase */\n \n@@ -1101,7 +1103,7 @@ export class OlmDevice {\n         sessionKey: string,\n         keysClaimed: Record<string, string>,\n         exportFormat: boolean,\n-        extraSessionData: Record<string, any> = {},\n+        extraSessionData: OlmGroupSessionExtraData = {},\n     ): Promise<void> {\n         await this.cryptoStore.doTxn(\n             'readwrite', [\n@@ -1133,17 +1135,42 @@ export class OlmDevice {\n                                     \"Update for megolm session \"\n                                     + senderKey + \"/\" + sessionId,\n                                 );\n-                                if (existingSession.first_known_index()\n-                                    <= session.first_known_index()\n-                                    && !(existingSession.first_known_index() == session.first_known_index()\n-                                        && !extraSessionData.untrusted\n-                                        && existingSessionData.untrusted)) {\n-                                    // existing session has lower index (i.e. can\n-                                    // decrypt more), or they have the same index and\n-                                    // the new sessions trust does not win over the old\n-                                    // sessions trust, so keep it\n-                                    logger.log(`Keeping existing megolm session ${sessionId}`);\n-                                    return;\n+                                if (existingSession.first_known_index() <= session.first_known_index()) {\n+                                    if (!existingSessionData.untrusted || extraSessionData.untrusted) {\n+                                        // existing session has less-than-or-equal index\n+                                        // (i.e. can decrypt at least as much), and the\n+                                        // new session's trust does not win over the old\n+                                        // session's trust, so keep it\n+                                        logger.log(`Keeping existing megolm session ${sessionId}`);\n+                                        return;\n+                                    }\n+                                    if (existingSession.first_known_index() < session.first_known_index()) {\n+                                        // We want to upgrade the existing session's trust,\n+                                        // but we can't just use the new session because we'll\n+                                        // lose the lower index. Check that the sessions connect\n+                                        // properly, and then manually set the existing session\n+                                        // as trusted.\n+                                        if (\n+                                            existingSession.export_session(session.first_known_index())\n+                                            === session.export_session(session.first_known_index())\n+                                        ) {\n+                                            logger.info(\n+                                                \"Upgrading trust of existing megolm session \" +\n+                                                sessionId + \" based on newly-received trusted session\",\n+                                            );\n+                                            existingSessionData.untrusted = false;\n+                                            this.cryptoStore.storeEndToEndInboundGroupSession(\n+                                                senderKey, sessionId, existingSessionData, txn,\n+                                            );\n+                                        } else {\n+                                            logger.warn(\n+                                                \"Newly-received megolm session \" + sessionId +\n+                                                \" does not match existing session! Keeping existing session\",\n+                                            );\n+                                        }\n+                                        return;\n+                                    }\n+                                    // If the sessions have the same index, go ahead and store the new trusted one.\n                                 }\n                             }\n \n@@ -1427,13 +1454,23 @@ export class OlmDevice {\n                         const claimedKeys = sessionData.keysClaimed || {};\n                         const senderEd25519Key = claimedKeys.ed25519 || null;\n \n+                        const forwardingKeyChain = sessionData.forwardingCurve25519KeyChain || [];\n+                        // older forwarded keys didn't set the \"untrusted\"\n+                        // property, but can be identified by having a\n+                        // non-empty forwarding key chain.  These keys should\n+                        // be marked as untrusted since we don't know that they\n+                        // can be trusted\n+                        const untrusted = \"untrusted\" in sessionData\n+                            ? sessionData.untrusted\n+                            : forwardingKeyChain.length > 0;\n+\n                         result = {\n                             \"chain_index\": chainIndex,\n                             \"key\": exportedSession,\n-                            \"forwarding_curve25519_key_chain\":\n-                                sessionData.forwardingCurve25519KeyChain || [],\n+                            \"forwarding_curve25519_key_chain\": forwardingKeyChain,\n                             \"sender_claimed_ed25519_key\": senderEd25519Key,\n                             \"shared_history\": sessionData.sharedHistory || false,\n+                            \"untrusted\": untrusted,\n                         };\n                     },\n                 );"
        },
        {
          "filename": "src/crypto/SecretStorage.ts",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -539,7 +539,23 @@ export class SecretStorage {\n             // because someone could be trying to send us bogus data\n             return;\n         }\n+\n+        if (!olmlib.isOlmEncrypted(event)) {\n+            logger.error(\"secret event not properly encrypted\");\n+            return;\n+        }\n+\n         const content = event.getContent();\n+\n+        const senderKeyUser = this.baseApis.crypto.deviceList.getUserByIdentityKey(\n+            olmlib.OLM_ALGORITHM,\n+            content.sender_key,\n+        );\n+        if (senderKeyUser !== event.getSender()) {\n+            logger.error(\"sending device does not belong to the user it claims to be from\");\n+            return;\n+        }\n+\n         logger.log(\"got secret share for request\", content.request_id);\n         const requestControl = this.requests.get(content.request_id);\n         if (requestControl) {\n@@ -559,6 +575,14 @@ export class SecretStorage {\n                 logger.log(\"unsolicited secret share from device\", deviceInfo.deviceId);\n                 return;\n             }\n+            // unsure that the sender is trusted.  In theory, this check is\n+            // unnecessary since we only accept secret shares from devices that\n+            // we requested from, but it doesn't hurt.\n+            const deviceTrust = this.baseApis.crypto.checkDeviceInfoTrust(event.getSender(), deviceInfo);\n+            if (!deviceTrust.isVerified()) {\n+                logger.log(\"secret share from unverified device\");\n+                return;\n+            }\n \n             logger.log(\n                 `Successfully received secret ${requestControl.name} ` +"
        },
        {
          "filename": "src/crypto/algorithms/megolm.ts",
          "status": "modified",
          "additions": 108,
          "deletions": 17,
          "patch": "@@ -35,8 +35,10 @@ import { Room } from '../../models/room';\n import { DeviceInfo } from \"../deviceinfo\";\n import { IOlmSessionResult } from \"../olmlib\";\n import { DeviceInfoMap } from \"../DeviceList\";\n-import { MatrixEvent } from \"../..\";\n+import { MatrixEvent } from \"../../models/event\";\n import { IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"../index\";\n+import { RoomKeyRequestState } from '../OutgoingRoomKeyRequestManager';\n+import { OlmGroupSessionExtraData } from \"../../@types/crypto\";\n \n // determine whether the key can be shared with invitees\n export function isRoomSharedHistory(room: Room): boolean {\n@@ -1189,8 +1191,9 @@ class MegolmEncryption extends EncryptionAlgorithm {\n  *     {@link module:crypto/algorithms/DecryptionAlgorithm}\n  */\n class MegolmDecryption extends DecryptionAlgorithm {\n-    // events which we couldn't decrypt due to unknown sessions / indexes: map from\n-    // senderKey|sessionId to Set of MatrixEvents\n+    // events which we couldn't decrypt due to unknown sessions /\n+    // indexes, or which we could only decrypt with untrusted keys:\n+    // map from senderKey|sessionId to Set of MatrixEvents\n     private pendingEvents = new Map<string, Map<string, Set<MatrixEvent>>>();\n \n     // this gets stubbed out by the unit tests.\n@@ -1294,9 +1297,13 @@ class MegolmDecryption extends DecryptionAlgorithm {\n             );\n         }\n \n-        // success. We can remove the event from the pending list, if that hasn't\n-        // already happened.\n-        this.removeEventFromPendingList(event);\n+        // Success. We can remove the event from the pending list, if\n+        // that hasn't already happened. However, if the event was\n+        // decrypted with an untrusted key, leave it on the pending\n+        // list so it will be retried if we find a trusted key later.\n+        if (!res.untrusted) {\n+            this.removeEventFromPendingList(event);\n+        }\n \n         const payload = JSON.parse(res.result);\n \n@@ -1391,6 +1398,8 @@ class MegolmDecryption extends DecryptionAlgorithm {\n         let exportFormat = false;\n         let keysClaimed: ReturnType<MatrixEvent[\"getKeysClaimed\"]>;\n \n+        const extraSessionData: OlmGroupSessionExtraData = {};\n+\n         if (!content.room_id ||\n             !content.session_key ||\n             !content.session_id ||\n@@ -1400,12 +1409,58 @@ class MegolmDecryption extends DecryptionAlgorithm {\n             return;\n         }\n \n-        if (!senderKey) {\n-            logger.error(\"key event has no sender key (not encrypted?)\");\n+        if (!olmlib.isOlmEncrypted(event)) {\n+            logger.error(\"key event not properly encrypted\");\n             return;\n         }\n \n+        if (content[\"org.matrix.msc3061.shared_history\"]) {\n+            extraSessionData.sharedHistory = true;\n+        }\n+\n         if (event.getType() == \"m.forwarded_room_key\") {\n+            const deviceInfo = this.crypto.deviceList.getDeviceByIdentityKey(\n+                olmlib.OLM_ALGORITHM,\n+                senderKey,\n+            );\n+            const senderKeyUser = this.baseApis.crypto.deviceList.getUserByIdentityKey(\n+                olmlib.OLM_ALGORITHM,\n+                senderKey,\n+            );\n+            if (senderKeyUser !== event.getSender()) {\n+                logger.error(\"sending device does not belong to the user it claims to be from\");\n+                return;\n+            }\n+            const outgoingRequests = deviceInfo ? await this.crypto.cryptoStore.getOutgoingRoomKeyRequestsByTarget(\n+                event.getSender(), deviceInfo.deviceId, [RoomKeyRequestState.Sent],\n+            ) : [];\n+            const weRequested = outgoingRequests.some((req) => (\n+                req.requestBody.room_id === content.room_id && req.requestBody.session_id === content.session_id\n+            ));\n+            const room = this.baseApis.getRoom(content.room_id);\n+            const memberEvent = room?.getMember(this.userId)?.events.member;\n+            const fromInviter = memberEvent?.getSender() === event.getSender() ||\n+                (memberEvent?.getUnsigned()?.prev_sender === event.getSender() &&\n+                    memberEvent?.getPrevContent()?.membership === \"invite\");\n+            const fromUs = event.getSender() === this.baseApis.getUserId();\n+\n+            if (!weRequested) {\n+                // If someone sends us an unsolicited key and it's not\n+                // shared history, ignore it\n+                if (!extraSessionData.sharedHistory) {\n+                    logger.log(\"forwarded key not shared history - ignoring\");\n+                    return;\n+                }\n+\n+                // If someone sends us an unsolicited key for a room\n+                // we're already in, and they're not one of our other\n+                // devices or the one who invited us, ignore it\n+                if (room && !fromInviter && !fromUs) {\n+                    logger.log(\"forwarded key not from inviter or from us - ignoring\");\n+                    return;\n+                }\n+            }\n+\n             exportFormat = true;\n             forwardingKeyChain = Array.isArray(content.forwarding_curve25519_key_chain) ?\n                 content.forwarding_curve25519_key_chain : [];\n@@ -1418,7 +1473,6 @@ class MegolmDecryption extends DecryptionAlgorithm {\n                 logger.error(\"forwarded_room_key event is missing sender_key field\");\n                 return;\n             }\n-            senderKey = content.sender_key;\n \n             const ed25519Key = content.sender_claimed_ed25519_key;\n             if (!ed25519Key) {\n@@ -1431,11 +1485,45 @@ class MegolmDecryption extends DecryptionAlgorithm {\n             keysClaimed = {\n                 ed25519: ed25519Key,\n             };\n+\n+            // If this is a key for a room we're not in, don't load it\n+            // yet, just park it in case *this sender* invites us to\n+            // that room later\n+            if (!room) {\n+                const parkedData = {\n+                    senderId: event.getSender(),\n+                    senderKey: content.sender_key,\n+                    sessionId: content.session_id,\n+                    sessionKey: content.session_key,\n+                    keysClaimed,\n+                    forwardingCurve25519KeyChain: forwardingKeyChain,\n+                };\n+                await this.crypto.cryptoStore.doTxn(\n+                    'readwrite',\n+                    ['parked_shared_history'],\n+                    (txn) => this.crypto.cryptoStore.addParkedSharedHistory(content.room_id, parkedData, txn),\n+                    logger.withPrefix(\"[addParkedSharedHistory]\"),\n+                );\n+                return;\n+            }\n+\n+            const sendingDevice = this.crypto.deviceList.getDeviceByIdentityKey(olmlib.OLM_ALGORITHM, senderKey);\n+            const deviceTrust = this.crypto.checkDeviceInfoTrust(event.getSender(), sendingDevice);\n+\n+            if (fromUs && !deviceTrust.isVerified()) {\n+                return;\n+            }\n+\n+            // forwarded keys are always untrusted\n+            extraSessionData.untrusted = true;\n+\n+            // replace the sender key with the sender key of the session\n+            // creator for storage\n+            senderKey = content.sender_key;\n         } else {\n             keysClaimed = event.getKeysClaimed();\n         }\n \n-        const extraSessionData: any = {};\n         if (content[\"org.matrix.msc3061.shared_history\"]) {\n             extraSessionData.sharedHistory = true;\n         }\n@@ -1453,7 +1541,7 @@ class MegolmDecryption extends DecryptionAlgorithm {\n             );\n \n             // have another go at decrypting events sent with this session.\n-            if (await this.retryDecryption(senderKey, content.session_id)) {\n+            if (await this.retryDecryption(senderKey, content.session_id, !extraSessionData.untrusted)) {\n                 // cancel any outstanding room key requests for this session.\n                 // Only do this if we managed to decrypt every message in the\n                 // session, because if we didn't, we leave the other key\n@@ -1668,7 +1756,7 @@ class MegolmDecryption extends DecryptionAlgorithm {\n         session: IMegolmSessionData,\n         opts: { untrusted?: boolean, source?: string } = {},\n     ): Promise<void> {\n-        const extraSessionData: any = {};\n+        const extraSessionData: OlmGroupSessionExtraData = {};\n         if (opts.untrusted || session.untrusted) {\n             extraSessionData.untrusted = true;\n         }\n@@ -1696,7 +1784,7 @@ class MegolmDecryption extends DecryptionAlgorithm {\n                 });\n             }\n             // have another go at decrypting events sent with this session.\n-            this.retryDecryption(session.sender_key, session.session_id);\n+            this.retryDecryption(session.sender_key, session.session_id, !extraSessionData.untrusted);\n         });\n     }\n \n@@ -1707,10 +1795,12 @@ class MegolmDecryption extends DecryptionAlgorithm {\n      * @private\n      * @param {String} senderKey\n      * @param {String} sessionId\n+     * @param {Boolean} keyTrusted\n      *\n-     * @return {Boolean} whether all messages were successfully decrypted\n+     * @return {Boolean} whether all messages were successfully\n+     *     decrypted with trusted keys\n      */\n-    private async retryDecryption(senderKey: string, sessionId: string): Promise<boolean> {\n+    private async retryDecryption(senderKey: string, sessionId: string, keyTrusted?: boolean): Promise<boolean> {\n         const senderPendingEvents = this.pendingEvents.get(senderKey);\n         if (!senderPendingEvents) {\n             return true;\n@@ -1725,13 +1815,14 @@ class MegolmDecryption extends DecryptionAlgorithm {\n \n         await Promise.all([...pending].map(async (ev) => {\n             try {\n-                await ev.attemptDecryption(this.crypto, { isRetry: true });\n+                await ev.attemptDecryption(this.crypto, { isRetry: true, keyTrusted });\n             } catch (e) {\n                 // don't die if something goes wrong\n             }\n         }));\n \n-        // If decrypted successfully, they'll have been removed from pendingEvents\n+        // If decrypted successfully with trusted keys, they'll have\n+        // been removed from pendingEvents\n         return !this.pendingEvents.get(senderKey)?.has(sessionId);\n     }\n "
        },
        {
          "filename": "src/crypto/algorithms/olm.ts",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -222,6 +222,26 @@ class OlmDecryption extends DecryptionAlgorithm {\n             );\n         }\n \n+        // check that the device that encrypted the event belongs to the user\n+        // that the event claims it's from.  We need to make sure that our\n+        // device list is up-to-date.  If the device is unknown, we can only\n+        // assume that the device logged out.  Some event handlers, such as\n+        // secret sharing, may be more strict and reject events that come from\n+        // unknown devices.\n+        await this.crypto.deviceList.downloadKeys([event.getSender()], false);\n+        const senderKeyUser = this.crypto.deviceList.getUserByIdentityKey(\n+            olmlib.OLM_ALGORITHM,\n+            deviceKey,\n+        );\n+        if (senderKeyUser !== event.getSender() && senderKeyUser !== undefined) {\n+            throw new DecryptionError(\n+                \"OLM_BAD_SENDER\",\n+                \"Message claimed to be from \" + event.getSender(), {\n+                    real_sender: senderKeyUser,\n+                },\n+            );\n+        }\n+\n         // check that the original sender matches what the homeserver told us, to\n         // avoid people masquerading as others.\n         // (this check is also provided via the sender's embedded ed25519 key,"
        },
        {
          "filename": "src/crypto/backup.ts",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -431,7 +431,6 @@ export class BackupManager {\n                 )\n             );\n         });\n-        ret.usable = ret.usable || ret.trusted_locally;\n         return ret;\n     }\n "
        },
        {
          "filename": "src/crypto/index.ts",
          "status": "modified",
          "additions": 17,
          "deletions": 9,
          "patch": "@@ -2105,6 +2105,10 @@ export class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap\n      * @param {?boolean} known whether to mark that the user has been made aware of\n      *      the existence of this device. Null to leave unchanged\n      *\n+     * @param {?Record<string, any>} keys The list of keys that was present\n+     * during the device verification. This will be double checked with the list\n+     * of keys the given device has currently.\n+     *\n      * @return {Promise<module:crypto/deviceinfo>} updated DeviceInfo\n      */\n     public async setDeviceVerification(\n@@ -2113,6 +2117,7 @@ export class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap\n         verified?: boolean,\n         blocked?: boolean,\n         known?: boolean,\n+        keys?: Record<string, string>,\n     ): Promise<DeviceInfo | CrossSigningInfo> {\n         // get rid of any `undefined`s here so we can just check\n         // for null rather than null or undefined\n@@ -2131,6 +2136,10 @@ export class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap\n             if (!verified) {\n                 throw new Error(\"Cannot set a cross-signing key as unverified\");\n             }\n+            const gotKeyId = keys ? Object.values(keys)[0] : null;\n+            if (keys && (Object.values(keys).length !== 1 || gotKeyId !== xsk.getId())) {\n+                throw new Error(`Key did not match expected value: expected ${xsk.getId()}, got ${gotKeyId}`);\n+            }\n \n             if (!this.crossSigningInfo.getId() && userId === this.crossSigningInfo.userId) {\n                 this.storeTrustedSelfKeys(xsk.keys);\n@@ -2191,6 +2200,13 @@ export class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap\n         let verificationStatus = dev.verified;\n \n         if (verified) {\n+            if (keys) {\n+                for (const [keyId, key] of Object.entries(keys)) {\n+                    if (dev.keys[keyId] !== key) {\n+                        throw new Error(`Key did not match expected value: expected ${key}, got ${dev.keys[keyId]}`);\n+                    }\n+                }\n+            }\n             verificationStatus = DeviceVerification.VERIFIED;\n         } else if (verified !== null && verificationStatus == DeviceVerification.VERIFIED) {\n             verificationStatus = DeviceVerification.UNVERIFIED;\n@@ -2400,13 +2416,6 @@ export class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap\n             return null;\n         }\n \n-        const forwardingChain = event.getForwardingCurve25519KeyChain();\n-        if (forwardingChain.length > 0) {\n-            // we got the key this event from somewhere else\n-            // TODO: check if we can trust the forwarders.\n-            return null;\n-        }\n-\n         if (event.isKeySourceUntrusted()) {\n             // we got the key for this event from a source that we consider untrusted\n             return null;\n@@ -2478,8 +2487,7 @@ export class Crypto extends TypedEventEmitter<CryptoEvent, CryptoEventHandlerMap\n         }\n         ret.encrypted = true;\n \n-        const forwardingChain = event.getForwardingCurve25519KeyChain();\n-        if (forwardingChain.length > 0 || event.isKeySourceUntrusted()) {\n+        if (event.isKeySourceUntrusted()) {\n             // we got the key this event from somewhere else\n             // TODO: check if we can trust the forwarders.\n             ret.authenticated = false;"
        },
        {
          "filename": "src/crypto/olmlib.ts",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -30,6 +30,8 @@ import { logger } from '../logger';\n import { IOneTimeKey } from \"./dehydration\";\n import { IClaimOTKsResult, MatrixClient } from \"../client\";\n import { ISignatures } from \"../@types/signed\";\n+import { MatrixEvent } from \"../models/event\";\n+import { EventType } from \"../@types/event\";\n \n enum Algorithm {\n     Olm = \"m.olm.v1.curve25519-aes-sha2\",\n@@ -554,6 +556,22 @@ export function pkVerify(obj: IObject, pubKey: string, userId: string) {\n     }\n }\n \n+/**\n+ * Check that an event was encrypted using olm.\n+ */\n+export function isOlmEncrypted(event: MatrixEvent): boolean {\n+    if (!event.getSenderKey()) {\n+        logger.error(\"Event has no sender key (not encrypted?)\");\n+        return false;\n+    }\n+    if (event.getWireType() !== EventType.RoomMessageEncrypted ||\n+        !([\"m.olm.v1.curve25519-aes-sha2\"].includes(event.getWireContent().algorithm))) {\n+        logger.error(\"Event was not encrypted using an appropriate algorithm\");\n+        return false;\n+    }\n+    return true;\n+}\n+\n /**\n  * Encode a typed array of uint8 as base64.\n  * @param {Uint8Array} uint8Array The data to encode."
        },
        {
          "filename": "src/crypto/store/base.ts",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ import { ICrossSigningInfo } from \"../CrossSigning\";\n import { PrefixedLogger } from \"../../logger\";\n import { InboundGroupSessionData } from \"../OlmDevice\";\n import { IEncryptedPayload } from \"../aes\";\n+import { MatrixEvent } from \"../../models/event\";\n \n /**\n  * Internal module. Definitions for storage for the crypto module\n@@ -127,6 +128,8 @@ export interface CryptoStore {\n         roomId: string,\n         txn?: unknown,\n     ): Promise<[senderKey: string, sessionId: string][]>;\n+    addParkedSharedHistory(roomId: string, data: ParkedSharedHistory, txn?: unknown): void;\n+    takeParkedSharedHistory(roomId: string, txn?: unknown): Promise<ParkedSharedHistory[]>;\n \n     // Session key backups\n     doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: unknown) => T, log?: PrefixedLogger): Promise<T>;\n@@ -203,3 +206,12 @@ export interface OutgoingRoomKeyRequest {\n     requestBody: IRoomKeyRequestBody;\n     state: RoomKeyRequestState;\n }\n+\n+export interface ParkedSharedHistory {\n+    senderId: string;\n+    senderKey: string;\n+    sessionId: string;\n+    sessionKey: string;\n+    keysClaimed: ReturnType<MatrixEvent[\"getKeysClaimed\"]>; // XXX: Less type dependence on MatrixEvent\n+    forwardingCurve25519KeyChain: string[];\n+}"
        },
        {
          "filename": "src/crypto/store/indexeddb-crypto-store-backend.ts",
          "status": "modified",
          "additions": 49,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ import {\n     IWithheld,\n     Mode,\n     OutgoingRoomKeyRequest,\n+    ParkedSharedHistory,\n } from \"./base\";\n import { IRoomKeyRequestBody, IRoomKeyRequestRecipient } from \"../index\";\n import { ICrossSigningKey } from \"../../client\";\n@@ -873,6 +874,49 @@ export class Backend implements CryptoStore {\n         });\n     }\n \n+    public addParkedSharedHistory(\n+        roomId: string,\n+        parkedData: ParkedSharedHistory,\n+        txn?: IDBTransaction,\n+    ): void {\n+        if (!txn) {\n+            txn = this.db.transaction(\n+                \"parked_shared_history\", \"readwrite\",\n+            );\n+        }\n+        const objectStore = txn.objectStore(\"parked_shared_history\");\n+        const req = objectStore.get([roomId]);\n+        req.onsuccess = () => {\n+            const { parked } = req.result || { parked: [] };\n+            parked.push(parkedData);\n+            objectStore.put({ roomId, parked });\n+        };\n+    }\n+\n+    public takeParkedSharedHistory(\n+        roomId: string,\n+        txn?: IDBTransaction,\n+    ): Promise<ParkedSharedHistory[]> {\n+        if (!txn) {\n+            txn = this.db.transaction(\n+                \"parked_shared_history\", \"readwrite\",\n+            );\n+        }\n+        const cursorReq = txn.objectStore(\"parked_shared_history\").openCursor(roomId);\n+        return new Promise((resolve, reject) => {\n+            cursorReq.onsuccess = () => {\n+                const cursor = cursorReq.result;\n+                if (!cursor) {\n+                    resolve([]);\n+                }\n+                const data = cursor.value;\n+                cursor.delete();\n+                resolve(data);\n+            };\n+            cursorReq.onerror = reject;\n+        });\n+    }\n+\n     public doTxn<T>(\n         mode: Mode,\n         stores: string | string[],\n@@ -958,6 +1002,11 @@ export function upgradeDatabase(db: IDBDatabase, oldVersion: number): void {\n             keyPath: [\"roomId\"],\n         });\n     }\n+    if (oldVersion < 11) {\n+        db.createObjectStore(\"parked_shared_history\", {\n+            keyPath: [\"roomId\"],\n+        });\n+    }\n     // Expand as needed.\n }\n "
        },
        {
          "filename": "src/crypto/store/indexeddb-crypto-store.ts",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -29,6 +29,7 @@ import {\n     IWithheld,\n     Mode,\n     OutgoingRoomKeyRequest,\n+    ParkedSharedHistory,\n } from \"./base\";\n import { IRoomKeyRequestBody } from \"../index\";\n import { ICrossSigningKey } from \"../../client\";\n@@ -55,6 +56,7 @@ export class IndexedDBCryptoStore implements CryptoStore {\n     public static STORE_INBOUND_GROUP_SESSIONS = 'inbound_group_sessions';\n     public static STORE_INBOUND_GROUP_SESSIONS_WITHHELD = 'inbound_group_sessions_withheld';\n     public static STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS = 'shared_history_inbound_group_sessions';\n+    public static STORE_PARKED_SHARED_HISTORY = 'parked_shared_history';\n     public static STORE_DEVICE_DATA = 'device_data';\n     public static STORE_ROOMS = 'rooms';\n     public static STORE_BACKUP = 'sessions_needing_backup';\n@@ -669,6 +671,27 @@ export class IndexedDBCryptoStore implements CryptoStore {\n         return this.backend.getSharedHistoryInboundGroupSessions(roomId, txn);\n     }\n \n+    /**\n+     * Park a shared-history group session for a room we may be invited to later.\n+     */\n+    public addParkedSharedHistory(\n+        roomId: string,\n+        parkedData: ParkedSharedHistory,\n+        txn?: IDBTransaction,\n+    ): void {\n+        this.backend.addParkedSharedHistory(roomId, parkedData, txn);\n+    }\n+\n+    /**\n+     * Pop out all shared-history group sessions for a room.\n+     */\n+    public takeParkedSharedHistory(\n+        roomId: string,\n+        txn?: IDBTransaction,\n+    ): Promise<ParkedSharedHistory[]> {\n+        return this.backend.takeParkedSharedHistory(roomId, txn);\n+    }\n+\n     /**\n      * Perform a transaction on the crypto store. Any store methods\n      * that require a transaction (txn) object to be passed in may"
        },
        {
          "filename": "src/crypto/store/memory-crypto-store.ts",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ import {\n     IWithheld,\n     Mode,\n     OutgoingRoomKeyRequest,\n+    ParkedSharedHistory,\n } from \"./base\";\n import { IRoomKeyRequestBody } from \"../index\";\n import { ICrossSigningKey } from \"../../client\";\n@@ -58,6 +59,7 @@ export class MemoryCryptoStore implements CryptoStore {\n     private rooms: { [roomId: string]: IRoomEncryption } = {};\n     private sessionsNeedingBackup: { [sessionKey: string]: boolean } = {};\n     private sharedHistoryInboundGroupSessions: { [roomId: string]: [senderKey: string, sessionId: string][] } = {};\n+    private parkedSharedHistory = new Map<string, ParkedSharedHistory[]>(); // keyed by room ID\n \n     /**\n      * Ensure the database exists and is up-to-date.\n@@ -526,6 +528,18 @@ export class MemoryCryptoStore implements CryptoStore {\n         return Promise.resolve(this.sharedHistoryInboundGroupSessions[roomId] || []);\n     }\n \n+    public addParkedSharedHistory(roomId: string, parkedData: ParkedSharedHistory): void {\n+        const parked = this.parkedSharedHistory.get(roomId) ?? [];\n+        parked.push(parkedData);\n+        this.parkedSharedHistory.set(roomId, parked);\n+    }\n+\n+    public takeParkedSharedHistory(roomId: string): Promise<ParkedSharedHistory[]> {\n+        const parked = this.parkedSharedHistory.get(roomId) ?? [];\n+        this.parkedSharedHistory.delete(roomId);\n+        return Promise.resolve(parked);\n+    }\n+\n     // Session key backups\n \n     public doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn?: unknown) => T): Promise<T> {"
        },
        {
          "filename": "src/crypto/verification/Base.ts",
          "status": "modified",
          "additions": 19,
          "deletions": 6,
          "patch": "@@ -299,7 +299,13 @@ export class VerificationBase<\n         if (this.doVerification && !this.started) {\n             this.started = true;\n             this.resetTimer(); // restart the timeout\n-            Promise.resolve(this.doVerification()).then(this.done.bind(this), this.cancel.bind(this));\n+            new Promise<void>((resolve, reject) => {\n+                const crossSignId = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(this.userId)?.getId();\n+                if (crossSignId === this.deviceId) {\n+                    reject(new Error(\"Device ID is the same as the cross-signing ID\"));\n+                }\n+                resolve();\n+            }).then(() => this.doVerification()).then(this.done.bind(this), this.cancel.bind(this));\n         }\n         return this.promise;\n     }\n@@ -310,14 +316,14 @@ export class VerificationBase<\n         // we try to verify all the keys that we're told about, but we might\n         // not know about all of them, so keep track of the keys that we know\n         // about, and ignore the rest\n-        const verifiedDevices = [];\n+        const verifiedDevices: [string, string, string][] = [];\n \n         for (const [keyId, keyInfo] of Object.entries(keys)) {\n             const deviceId = keyId.split(':', 2)[1];\n             const device = this.baseApis.getStoredDevice(userId, deviceId);\n             if (device) {\n                 verifier(keyId, device, keyInfo);\n-                verifiedDevices.push(deviceId);\n+                verifiedDevices.push([deviceId, keyId, device.keys[keyId]]);\n             } else {\n                 const crossSigningInfo = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(userId);\n                 if (crossSigningInfo && crossSigningInfo.getId() === deviceId) {\n@@ -326,7 +332,7 @@ export class VerificationBase<\n                             [keyId]: deviceId,\n                         },\n                     }, deviceId), keyInfo);\n-                    verifiedDevices.push(deviceId);\n+                    verifiedDevices.push([deviceId, keyId, deviceId]);\n                 } else {\n                     logger.warn(\n                         `verification: Could not find device ${deviceId} to verify`,\n@@ -348,8 +354,15 @@ export class VerificationBase<\n         // TODO: There should probably be a batch version of this, otherwise it's going\n         // to upload each signature in a separate API call which is silly because the\n         // API supports as many signatures as you like.\n-        for (const deviceId of verifiedDevices) {\n-            await this.baseApis.setDeviceVerified(userId, deviceId);\n+        for (const [deviceId, keyId, key] of verifiedDevices) {\n+            await this.baseApis.crypto.setDeviceVerification(userId, deviceId, true, null, null, { [keyId]: key });\n+        }\n+\n+        // if one of the user's own devices is being marked as verified / unverified,\n+        // check the key backup status, since whether or not we use this depends on\n+        // whether it has a signature from a verified device\n+        if (userId == this.baseApis.credentials.userId) {\n+            await this.baseApis.checkKeyBackup();\n         }\n     }\n "
        },
        {
          "filename": "src/event-mapper.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -22,13 +22,18 @@ export type EventMapper = (obj: Partial<IEvent>) => MatrixEvent;\n export interface MapperOpts {\n     preventReEmit?: boolean;\n     decrypt?: boolean;\n+    toDevice?: boolean;\n }\n \n export function eventMapperFor(client: MatrixClient, options: MapperOpts): EventMapper {\n     let preventReEmit = Boolean(options.preventReEmit);\n     const decrypt = options.decrypt !== false;\n \n     function mapper(plainOldJsObject: Partial<IEvent>) {\n+        if (options.toDevice) {\n+            delete plainOldJsObject.room_id;\n+        }\n+\n         const room = client.getRoom(plainOldJsObject.room_id);\n \n         let event: MatrixEvent;"
        },
        {
          "filename": "src/models/beacon.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -15,7 +15,6 @@ limitations under the License.\n */\n \n import { MBeaconEventContent } from \"../@types/beacon\";\n-import { M_TIMESTAMP } from \"../@types/location\";\n import { BeaconInfoState, BeaconLocationState, parseBeaconContent, parseBeaconInfoContent } from \"../content-helpers\";\n import { MatrixEvent } from \"../matrix\";\n import { sortEventsByLatestContentTimestamp } from \"../utils\";\n@@ -161,7 +160,9 @@ export class Beacon extends TypedEventEmitter<Exclude<BeaconEvent, BeaconEvent.N\n \n         const validLocationEvents = beaconLocationEvents.filter(event => {\n             const content = event.getContent<MBeaconEventContent>();\n-            const timestamp = M_TIMESTAMP.findIn<number>(content);\n+            const parsed = parseBeaconContent(content);\n+            if (!parsed.uri || !parsed.timestamp) return false; // we won't be able to process these\n+            const { timestamp } = parsed;\n             return (\n                 // only include positions that were taken inside the beacon's live period\n                 isTimestampInDuration(this._beaconInfo.timestamp, this._beaconInfo.timeout, timestamp) &&"
        },
        {
          "filename": "src/models/event.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -151,6 +151,7 @@ interface IKeyRequestRecipient {\n export interface IDecryptOptions {\n     emit?: boolean;\n     isRetry?: boolean;\n+    keyTrusted?: boolean;\n }\n \n /**\n@@ -695,7 +696,7 @@ export class MatrixEvent extends TypedEventEmitter<EmittedEvents, MatrixEventHan\n             throw new Error(\"Attempt to decrypt event which isn't encrypted\");\n         }\n \n-        if (this.clearEvent && !this.isDecryptionFailure()) {\n+        if (this.clearEvent && !this.isDecryptionFailure() && !(this.isKeySourceUntrusted() && options.keyTrusted)) {\n             // we may want to just ignore this? let's start with rejecting it.\n             throw new Error(\n                 \"Attempt to decrypt event which has already been decrypted\","
        },
        {
          "filename": "src/sync.ts",
          "status": "modified",
          "additions": 37,
          "deletions": 2,
          "patch": "@@ -1109,7 +1109,20 @@ export class SyncApi {\n         if (Array.isArray(data.to_device?.events) && data.to_device.events.length > 0) {\n             const cancelledKeyVerificationTxns = [];\n             data.to_device.events\n-                .map(client.getEventMapper())\n+                .filter((eventJSON) => {\n+                    if (\n+                        eventJSON.type === EventType.RoomMessageEncrypted &&\n+                        !([\"m.olm.v1.curve25519-aes-sha2\"].includes(eventJSON.content?.algorithm))\n+                    ) {\n+                        logger.log(\n+                            'Ignoring invalid encrypted to-device event from ' + eventJSON.sender,\n+                        );\n+                        return false;\n+                    }\n+\n+                    return true;\n+                })\n+                .map(client.getEventMapper({ toDevice: true }))\n                 .map((toDeviceEvent) => { // map is a cheap inline forEach\n                     // We want to flag m.key.verification.start events as cancelled\n                     // if there's an accompanying m.key.verification.cancel event, so\n@@ -1185,6 +1198,24 @@ export class SyncApi {\n             const stateEvents = this.mapSyncEventsFormat(inviteObj.invite_state, room);\n \n             await this.processRoomEvents(room, stateEvents);\n+\n+            const inviter = room.currentState.getStateEvents(EventType.RoomMember, client.getUserId())?.getSender();\n+            const parkedHistory = await client.crypto.cryptoStore.takeParkedSharedHistory(room.roomId);\n+            for (const parked of parkedHistory) {\n+                if (parked.senderId === inviter) {\n+                    await this.client.crypto.olmDevice.addInboundGroupSession(\n+                        room.roomId,\n+                        parked.senderKey,\n+                        parked.forwardingCurve25519KeyChain,\n+                        parked.sessionId,\n+                        parked.sessionKey,\n+                        parked.keysClaimed,\n+                        true,\n+                        { sharedHistory: true, untrusted: true },\n+                    );\n+                }\n+            }\n+\n             if (inviteObj.isBrandNewRoom) {\n                 room.recalculate();\n                 client.store.storeRoom(room);\n@@ -1288,7 +1319,11 @@ export class SyncApi {\n                 }\n             }\n \n-            await this.processRoomEvents(room, stateEvents, events, syncEventData.fromCache);\n+            try {\n+                await this.processRoomEvents(room, stateEvents, events, syncEventData.fromCache);\n+            } catch (e) {\n+                logger.error(`Failed to process events on room ${room.roomId}:`, e);\n+            }\n \n             // set summary after processing events,\n             // because it will trigger a name calculation"
        }
      ],
      "file_patterns": {
        "security_files": 19,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 13,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "07f97d724f755a131571511af6662d4e3b345728",
            "date": "2025-01-14T14:09:25Z",
            "author_login": "RiotRobot"
          },
          {
            "sha": "72ee5504d5ab39dc40c4ba1a5601a90b7a6b3426",
            "date": "2025-01-14T14:08:54Z",
            "author_login": "RiotRobot"
          },
          {
            "sha": "9134471dc72a14b29eb207f1c5ef207521f40bd3",
            "date": "2025-01-14T10:20:51Z",
            "author_login": "toger5"
          },
          {
            "sha": "f22d5e9d478a90618bcc008a18ffe2f1e9e7f6a7",
            "date": "2025-01-13T18:29:50Z",
            "author_login": "toger5"
          },
          {
            "sha": "ffb228bf5a404c26e03fcea51a207c51f104a716",
            "date": "2025-01-13T13:20:54Z",
            "author_login": "toger5"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "Matrix Javascript SDK is the Matrix Client-Server SDK for JavaScript. Prior to version 19.7.0, an attacker cooperating with a malicious homeserver can construct messages that legitimately appear to have come from another person, without any indication such as a grey shield. Additionally, a sophisticated attacker cooperating with a malicious homeserver could employ this vulnerability to perform a targeted attack in order to send fake to-device messages appearing to originate from another user. This can allow, for example, to inject the key backup secret during a self-verification, to make a targeted device start using a malicious key backup spoofed by the homeserver. These attacks are possible due to a protocol confusion vulnerability that accepts to-device messages encrypted with Megolm instead of Olm. Starting with version 19.7.0, matrix-js-sdk has been modified to only accept Olm-encrypted to-device messages. Out of caution, several other checks have been audited or added. This attack requires coordination between a malicious home server and an attacker, so those who trust their home servers do not need a workaround.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-28T20:15:16.533",
    "last_modified": "2024-11-21T07:17:52.733",
    "fix_date": "2022-09-28T12:55:15Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/matrix-js-sdk/commit/a587d7c36026fe1fcf93dfff63588abee359be76",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-js-sdk/releases/tag/v19.7.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-js-sdk/security/advisories/GHSA-r48r-j8fx-mq2c",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://matrix.org/blog/2022/09/28/upgrade-now-to-address-encryption-vulns-in-matrix-sdks-and-clients",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202210-35",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-js-sdk/commit/a587d7c36026fe1fcf93dfff63588abee359be76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-js-sdk/releases/tag/v19.7.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-js-sdk/security/advisories/GHSA-r48r-j8fx-mq2c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://matrix.org/blog/2022/09/28/upgrade-now-to-address-encryption-vulns-in-matrix-sdks-and-clients",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202210-35",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.296575",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "matrix-js-sdk",
    "owner": "matrix-org",
    "created_at": "2015-03-04T17:28:51Z",
    "updated_at": "2025-01-14T10:34:14Z",
    "pushed_at": "2025-01-14T10:34:12Z",
    "size": 52427,
    "stars": 1665,
    "forks": 605,
    "open_issues": 254,
    "watchers": 1665,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "TypeScript": 6540475,
      "Python": 25161,
      "JavaScript": 16869,
      "Shell": 521
    },
    "commit_activity": {
      "total_commits_last_year": 730,
      "avg_commits_per_week": 14.038461538461538,
      "days_active_last_year": 186
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:43:41.167882"
  }
}