{
  "cve_id": "CVE-2022-39257",
  "github_data": {
    "repository": "matrix-org/matrix-ios-sdk",
    "fix_commit": "5ca86c328a5faaab429c240551cb9ca8f0f6262c",
    "related_commits": [
      "5ca86c328a5faaab429c240551cb9ca8f0f6262c",
      "5ca86c328a5faaab429c240551cb9ca8f0f6262c"
    ],
    "patch_url": "https://github.com/matrix-org/matrix-ios-sdk/commit/5ca86c328a5faaab429c240551cb9ca8f0f6262c.patch",
    "fix_commit_details": {
      "sha": "5ca86c328a5faaab429c240551cb9ca8f0f6262c",
      "commit_date": "2022-09-28T14:25:36Z",
      "author": {
        "login": "Anderas",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Resolve multiple CVEs",
        "length": 52,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 2595,
        "additions": 2396,
        "deletions": 199
      },
      "files": [
        {
          "filename": "CHANGES.md",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -1,3 +1,10 @@\n+## Changes in 0.23.19 (2022-09-28)\n+\n+\ud83d\udc1b Bugfixes\n+\n+- CVE-2022-39255: Olm/Megolm protocol confusion ([Security advisory](https://github.com/matrix-org/matrix-ios-sdk/security/advisories/GHSA-hw6g-j8v6-9hcm))\n+- CVE-2022-39257: Impersonation via forwarded Megolm sessions ([Security advisory](https://github.com/matrix-org/matrix-ios-sdk/security/advisories/GHSA-qxr3-5jmq-xcf4))\n+\n ## Changes in 0.23.18 (2022-09-07)\n \n \u2728 Features"
        },
        {
          "filename": "MatrixSDK.xcodeproj/project.pbxproj",
          "status": "modified",
          "additions": 122,
          "deletions": 0,
          "patch": "@@ -1801,6 +1801,14 @@\n \t\tECF29BDF264195320053E6D6 /* MXAssertedIdentityModel.h in Headers */ = {isa = PBXBuildFile; fileRef = ECF29BDD264195320053E6D6 /* MXAssertedIdentityModel.h */; settings = {ATTRIBUTES = (Public, ); }; };\n \t\tECF29BE52641953C0053E6D6 /* MXAssertedIdentityModel.m in Sources */ = {isa = PBXBuildFile; fileRef = ECF29BE42641953C0053E6D6 /* MXAssertedIdentityModel.m */; };\n \t\tECF29BE62641953C0053E6D6 /* MXAssertedIdentityModel.m in Sources */ = {isa = PBXBuildFile; fileRef = ECF29BE42641953C0053E6D6 /* MXAssertedIdentityModel.m */; };\n+\t\tED01915228C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m in Sources */ = {isa = PBXBuildFile; fileRef = ED01914E28C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m */; };\n+\t\tED01915328C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m in Sources */ = {isa = PBXBuildFile; fileRef = ED01914E28C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m */; };\n+\t\tED01915428C64E0400ED3A69 /* MXRoomKeyEventContent.h in Headers */ = {isa = PBXBuildFile; fileRef = ED01914F28C64E0400ED3A69 /* MXRoomKeyEventContent.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\tED01915528C64E0400ED3A69 /* MXRoomKeyEventContent.h in Headers */ = {isa = PBXBuildFile; fileRef = ED01914F28C64E0400ED3A69 /* MXRoomKeyEventContent.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\tED01915628C64E0400ED3A69 /* MXRoomKeyEventContent.m in Sources */ = {isa = PBXBuildFile; fileRef = ED01915028C64E0400ED3A69 /* MXRoomKeyEventContent.m */; };\n+\t\tED01915728C64E0400ED3A69 /* MXRoomKeyEventContent.m in Sources */ = {isa = PBXBuildFile; fileRef = ED01915028C64E0400ED3A69 /* MXRoomKeyEventContent.m */; };\n+\t\tED01915828C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h in Headers */ = {isa = PBXBuildFile; fileRef = ED01915128C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\tED01915928C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h in Headers */ = {isa = PBXBuildFile; fileRef = ED01915128C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h */; settings = {ATTRIBUTES = (Public, ); }; };\n \t\tED1AE92A2881AC7500D3432A /* MXWarnings.h in Headers */ = {isa = PBXBuildFile; fileRef = ED1AE9292881AC7100D3432A /* MXWarnings.h */; settings = {ATTRIBUTES = (Public, ); }; };\n \t\tED1AE92B2881AC7500D3432A /* MXWarnings.h in Headers */ = {isa = PBXBuildFile; fileRef = ED1AE9292881AC7100D3432A /* MXWarnings.h */; settings = {ATTRIBUTES = (Public, ); }; };\n \t\tED21F68528104DA2002FF83D /* MXMegolmEncryptionTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED21F68428104DA2002FF83D /* MXMegolmEncryptionTests.swift */; };\n@@ -1846,6 +1854,28 @@\n \t\tED5C754928B3E80300D24E85 /* MXLogObjcWrapper.h in Headers */ = {isa = PBXBuildFile; fileRef = ED5C753B28B3E80300D24E85 /* MXLogObjcWrapper.h */; settings = {ATTRIBUTES = (Public, ); }; };\n \t\tED5C95CE2833E85600843D82 /* MXOlmDeviceUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED5C95CD2833E85600843D82 /* MXOlmDeviceUnitTests.swift */; };\n \t\tED5C95CF2833E85600843D82 /* MXOlmDeviceUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED5C95CD2833E85600843D82 /* MXOlmDeviceUnitTests.swift */; };\n+\t\tED6DABFC28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DABFB28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift */; };\n+\t\tED6DABFD28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DABFB28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift */; };\n+\t\tED6DAC0228C76F0A00ECDCB6 /* MXRoomKeyInfo.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0128C76F0A00ECDCB6 /* MXRoomKeyInfo.swift */; };\n+\t\tED6DAC0328C76F0A00ECDCB6 /* MXRoomKeyInfo.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0128C76F0A00ECDCB6 /* MXRoomKeyInfo.swift */; };\n+\t\tED6DAC0728C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0628C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift */; };\n+\t\tED6DAC0828C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0628C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift */; };\n+\t\tED6DAC0A28C784AE00ECDCB6 /* Dictionary.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0928C784AE00ECDCB6 /* Dictionary.swift */; };\n+\t\tED6DAC0B28C784AE00ECDCB6 /* Dictionary.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0928C784AE00ECDCB6 /* Dictionary.swift */; };\n+\t\tED6DAC0D28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0C28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift */; };\n+\t\tED6DAC0E28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC0C28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift */; };\n+\t\tED6DAC1128C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1028C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift */; };\n+\t\tED6DAC1228C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1028C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift */; };\n+\t\tED6DAC1528C78D4000ECDCB6 /* MXMemoryCryptoStore.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1428C78D4000ECDCB6 /* MXMemoryCryptoStore.swift */; };\n+\t\tED6DAC1628C78D4000ECDCB6 /* MXMemoryCryptoStore.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1428C78D4000ECDCB6 /* MXMemoryCryptoStore.swift */; };\n+\t\tED6DAC1828C799E300ECDCB6 /* MXRoomKeyResult.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1728C799E300ECDCB6 /* MXRoomKeyResult.swift */; };\n+\t\tED6DAC1928C799E300ECDCB6 /* MXRoomKeyResult.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1728C799E300ECDCB6 /* MXRoomKeyResult.swift */; };\n+\t\tED6DAC1B28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1A28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift */; };\n+\t\tED6DAC1C28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1A28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift */; };\n+\t\tED6DAC1E28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1D28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift */; };\n+\t\tED6DAC1F28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC1D28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift */; };\n+\t\tED6DAC2128C7A51400ECDCB6 /* MXDateProvider.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC2028C7A4F000ECDCB6 /* MXDateProvider.swift */; };\n+\t\tED6DAC2228C7A51400ECDCB6 /* MXDateProvider.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED6DAC2028C7A4F000ECDCB6 /* MXDateProvider.swift */; };\n \t\tED7019DD2886C24100FC31B9 /* MXCrossSigningInfoSourceUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED8F1D242885A39800F897E7 /* MXCrossSigningInfoSourceUnitTests.swift */; };\n \t\tED7019DE2886C24A00FC31B9 /* MXTrustLevelSourceUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED8F1D2F2885AB0300F897E7 /* MXTrustLevelSourceUnitTests.swift */; };\n \t\tED7019DF2886C25600FC31B9 /* MXDeviceInfoUnitTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = ED8F1D1B2885909E00F897E7 /* MXDeviceInfoUnitTests.swift */; };\n@@ -2910,6 +2940,10 @@\n \t\tECF29BD2264194BB0053E6D6 /* MXCallAssertedIdentityEventContent.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MXCallAssertedIdentityEventContent.m; sourceTree = \"<group>\"; };\n \t\tECF29BDD264195320053E6D6 /* MXAssertedIdentityModel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MXAssertedIdentityModel.h; sourceTree = \"<group>\"; };\n \t\tECF29BE42641953C0053E6D6 /* MXAssertedIdentityModel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MXAssertedIdentityModel.m; sourceTree = \"<group>\"; };\n+\t\tED01914E28C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MXForwardedRoomKeyEventContent.m; sourceTree = \"<group>\"; };\n+\t\tED01914F28C64E0400ED3A69 /* MXRoomKeyEventContent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MXRoomKeyEventContent.h; sourceTree = \"<group>\"; };\n+\t\tED01915028C64E0400ED3A69 /* MXRoomKeyEventContent.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MXRoomKeyEventContent.m; sourceTree = \"<group>\"; };\n+\t\tED01915128C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MXForwardedRoomKeyEventContent.h; sourceTree = \"<group>\"; };\n \t\tED1AE9292881AC7100D3432A /* MXWarnings.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = MXWarnings.h; sourceTree = \"<group>\"; };\n \t\tED21F68428104DA2002FF83D /* MXMegolmEncryptionTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXMegolmEncryptionTests.swift; sourceTree = \"<group>\"; };\n \t\tED2DD111286C450600F06731 /* MXCryptoMachine.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MXCryptoMachine.swift; sourceTree = \"<group>\"; };\n@@ -2935,6 +2969,17 @@\n \t\tED5C753A28B3E80300D24E85 /* MXLogger.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MXLogger.m; sourceTree = \"<group>\"; };\n \t\tED5C753B28B3E80300D24E85 /* MXLogObjcWrapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MXLogObjcWrapper.h; sourceTree = \"<group>\"; };\n \t\tED5C95CD2833E85600843D82 /* MXOlmDeviceUnitTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXOlmDeviceUnitTests.swift; sourceTree = \"<group>\"; };\n+\t\tED6DABFB28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MXRoomKeyInfoFactory.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC0128C76F0A00ECDCB6 /* MXRoomKeyInfo.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXRoomKeyInfo.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC0628C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXForwardedRoomKeyEventContentUnitTests.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC0928C784AE00ECDCB6 /* Dictionary.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Dictionary.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC0C28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXRoomKeyEventContentUnitTests.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC1028C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXRoomKeyInfoFactoryUnitTests.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC1428C78D4000ECDCB6 /* MXMemoryCryptoStore.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXMemoryCryptoStore.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC1728C799E300ECDCB6 /* MXRoomKeyResult.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXRoomKeyResult.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC1A28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MXUnrequestedForwardedRoomKeyManager.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC1D28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXUnrequestedForwardedRoomKeyManagerUnitTests.swift; sourceTree = \"<group>\"; };\n+\t\tED6DAC2028C7A4F000ECDCB6 /* MXDateProvider.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MXDateProvider.swift; sourceTree = \"<group>\"; };\n \t\tED7019E42886C32900FC31B9 /* MXSASTransactionV2.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MXSASTransactionV2.swift; sourceTree = \"<group>\"; };\n \t\tED7019E72886C33100FC31B9 /* MXKeyVerificationRequestV2.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MXKeyVerificationRequestV2.swift; sourceTree = \"<group>\"; };\n \t\tED7019EA2886C33A00FC31B9 /* MXKeyVerificationManagerV2.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MXKeyVerificationManagerV2.swift; sourceTree = \"<group>\"; };\n@@ -3229,6 +3274,7 @@\n \t\t\t\tB17B2BDB2369FC81009D6650 /* MXUIKitBackgroundTask.m */,\n \t\t\t\tEDF1B68F2876CD2C00BBBCEE /* MXTaskQueue.swift */,\n \t\t\t\tED1AE9292881AC7100D3432A /* MXWarnings.h */,\n+\t\t\t\tED6DAC2028C7A4F000ECDCB6 /* MXDateProvider.swift */,\n \t\t\t);\n \t\t\tpath = Utils;\n \t\t\tsourceTree = \"<group>\";\n@@ -3288,6 +3334,7 @@\n \t\t\t\t32261B8723C749FB0018F1E2 /* Trust */,\n \t\t\t\t32A1513B1DAF768D00400192 /* Data */,\n \t\t\t\t3AC1379326432ED500EE1E74 /* Dehydration */,\n+\t\t\t\tED6DAC0428C771D500ECDCB6 /* RoomKeys */,\n \t\t\t\t32BBAE642178E99100D85F46 /* KeyBackup */,\n \t\t\t\t32FA10B21FA1C28100E54233 /* KeySharing */,\n \t\t\t\t3A108A382580E979005EEBE9 /* KeyProvider */,\n@@ -4318,6 +4365,7 @@\n \t\t\t\t32FA10BF1FA1C9EE00E54233 /* MXOutgoingRoomKeyRequestManager.h */,\n \t\t\t\t32FA10C01FA1C9EE00E54233 /* MXOutgoingRoomKeyRequestManager.m */,\n \t\t\t\t32A30B161FB4813400C8309E /* MXIncomingRoomKeyRequestManager.h */,\n+\t\t\t\tED6DAC1A28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift */,\n \t\t\t\t32A30B171FB4813400C8309E /* MXIncomingRoomKeyRequestManager.m */,\n \t\t\t\tED44F01328180EAB00452A5D /* MXSharedHistoryKeyManager.swift */,\n \t\t\t\tEDBCF335281A8AB900ED5044 /* MXSharedHistoryKeyService.h */,\n@@ -4329,6 +4377,10 @@\n \t\t32FA10C31FA1C9F700E54233 /* Data */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n+\t\t\t\tED01915128C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h */,\n+\t\t\t\tED01914E28C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m */,\n+\t\t\t\tED01914F28C64E0400ED3A69 /* MXRoomKeyEventContent.h */,\n+\t\t\t\tED01915028C64E0400ED3A69 /* MXRoomKeyEventContent.m */,\n \t\t\t\t32F945F21FAB83D900622468 /* MXIncomingRoomKeyRequest.h */,\n \t\t\t\t32F945F31FAB83D900622468 /* MXIncomingRoomKeyRequest.m */,\n \t\t\t\t32F945F41FAB83D900622468 /* MXIncomingRoomKeyRequestCancellation.h */,\n@@ -5127,6 +5179,7 @@\n \t\t\t\tED8F1D1428857FD300F897E7 /* CrossSigning */,\n \t\t\t\tED8F1D2E2885AAEB00F897E7 /* Trust */,\n \t\t\t\tED8F1D292885A7DF00F897E7 /* Devices */,\n+\t\t\t\tED6DAC0F28C7889A00ECDCB6 /* RoomKeys */,\n \t\t\t\tED44F01628180F1300452A5D /* KeySharing */,\n \t\t\t\tED35652A281150230002BF6A /* Data */,\n \t\t\t\tED21F67B28104BA1002FF83D /* Algorithms */,\n@@ -5178,6 +5231,7 @@\n \t\tED35652A281150230002BF6A /* Data */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n+\t\t\t\tED6DAC1328C78D3700ECDCB6 /* Store */,\n \t\t\t\tED35652B281150310002BF6A /* MXOlmInboundGroupSessionUnitTests.swift */,\n \t\t\t\tED35652E281153480002BF6A /* MXMegolmSessionDataUnitTests.swift */,\n \t\t\t);\n@@ -5187,7 +5241,9 @@\n \t\tED44F01628180F1300452A5D /* KeySharing */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n+\t\t\t\tED6DAC0528C77E0600ECDCB6 /* Data */,\n \t\t\t\tED44F01728180F1C00452A5D /* MXSharedHistoryKeyManagerUnitTests.swift */,\n+\t\t\t\tED6DAC1D28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift */,\n \t\t\t);\n \t\t\tpath = KeySharing;\n \t\t\tsourceTree = \"<group>\";\n@@ -5206,6 +5262,41 @@\n \t\t\tpath = Logs;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n+\t\tED6DAC0428C771D500ECDCB6 /* RoomKeys */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tED6DAC0128C76F0A00ECDCB6 /* MXRoomKeyInfo.swift */,\n+\t\t\t\tED6DAC1728C799E300ECDCB6 /* MXRoomKeyResult.swift */,\n+\t\t\t\tED6DABFB28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift */,\n+\t\t\t);\n+\t\t\tpath = RoomKeys;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tED6DAC0528C77E0600ECDCB6 /* Data */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tED6DAC0628C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift */,\n+\t\t\t\tED6DAC0C28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift */,\n+\t\t\t);\n+\t\t\tpath = Data;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tED6DAC0F28C7889A00ECDCB6 /* RoomKeys */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tED6DAC1028C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift */,\n+\t\t\t);\n+\t\t\tpath = RoomKeys;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tED6DAC1328C78D3700ECDCB6 /* Store */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tED6DAC1428C78D4000ECDCB6 /* MXMemoryCryptoStore.swift */,\n+\t\t\t);\n+\t\t\tpath = Store;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n \t\tED7019ED2886CA6C00FC31B9 /* Verification */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n@@ -5365,6 +5456,7 @@\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n \t\t\t\t3259D0072603705300C365DB /* Array.swift */,\n+\t\t\t\tED6DAC0928C784AE00ECDCB6 /* Dictionary.swift */,\n \t\t\t\tF08B8D5A1E014711006171A8 /* NSData+MatrixSDK.h */,\n \t\t\t\tF08B8D5B1E014711006171A8 /* NSData+MatrixSDK.m */,\n \t\t\t\t3259D02226037A7200C365DB /* NSDictionary.swift */,\n@@ -5704,6 +5796,7 @@\n \t\t\t\t326056851C76FDF2009D44AD /* MXRoomEventTimeline.h in Headers */,\n \t\t\t\t3A59A49D25A7A16F00DDA1FC /* MXOlmOutboundGroupSession.h in Headers */,\n \t\t\t\t32AF927F240EA0190008A0FD /* MXSecretShareManager.h in Headers */,\n+\t\t\t\tED01915828C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h in Headers */,\n \t\t\t\t321CFDEE225264C4004D31DF /* NSArray+MatrixSDK.h in Headers */,\n \t\t\t\t1838928827031D1D003F0C4F /* MXSendReplyEventStringLocalizerProtocol.h in Headers */,\n \t\t\t\tB11BD44822CB56790064D8B0 /* MXReplyEventParser.h in Headers */,\n@@ -5731,6 +5824,7 @@\n \t\t\t\t32DC15D01A8CF7AE006F9AD3 /* MXNotificationCenter.h in Headers */,\n \t\t\t\t3275FD9C21A6B60B00B9C13D /* MXLoginPolicy.h in Headers */,\n \t\t\t\tEC05473425FF8A3C0047ECD7 /* MXVirtualRoomInfo.h in Headers */,\n+\t\t\t\tED01915428C64E0400ED3A69 /* MXRoomKeyEventContent.h in Headers */,\n \t\t\t\tF0173EAC1FCF0E8900B5F6A3 /* MXGroup.h in Headers */,\n \t\t\t\t32D2CC0523422462002BD8CA /* MX3PidAddSession.h in Headers */,\n \t\t\t\t329FB17F1A0B665800A5E88E /* MXUser.h in Headers */,\n@@ -6008,6 +6102,7 @@\n \t\t\t\tB14EF3202397E90400758AF0 /* MXKeyBackupPassword.h in Headers */,\n \t\t\t\tB14EF3212397E90400758AF0 /* MXRestClient.h in Headers */,\n \t\t\t\t324DD2B2246BDC6800377005 /* MXSecretStorage_Private.h in Headers */,\n+\t\t\t\tED01915928C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.h in Headers */,\n \t\t\t\t32B0E33A23A2989A0054FF1A /* MXEventReferenceChunk.h in Headers */,\n \t\t\t\tB1EE98C72804697400AB63F0 /* MXBeacon.h in Headers */,\n \t\t\t\tB14EF3222397E90400758AF0 /* MXKeyVerificationManager.h in Headers */,\n@@ -6053,6 +6148,7 @@\n \t\t\t\tEC60EE07265CFFF400B39A4E /* MXGroupSyncProfile.h in Headers */,\n \t\t\t\tEC11658E270F3ABF0089FA56 /* RLMRealm+MatrixSDK.h in Headers */,\n \t\t\t\t324AAC7E2399143400380A66 /* MXKeyVerificationCancel.h in Headers */,\n+\t\t\t\tED01915528C64E0400ED3A69 /* MXRoomKeyEventContent.h in Headers */,\n \t\t\t\tB14EF3372397E90400758AF0 /* MXRoomTombStoneContent.h in Headers */,\n \t\t\t\t3274538B23FD918800438328 /* MXKeyVerificationByToDeviceRequest.h in Headers */,\n \t\t\t\tB14EF3382397E90400758AF0 /* MXFilterObject.h in Headers */,\n@@ -6470,6 +6566,7 @@\n \t\t\t\t3275FD9D21A6B60B00B9C13D /* MXLoginPolicy.m in Sources */,\n \t\t\t\t327F8DB31C6112BA00581CA3 /* MXRoomThirdPartyInvite.m in Sources */,\n \t\t\t\tB17982FC2119E4A2001FD722 /* MXRoomPowerLevels.m in Sources */,\n+\t\t\t\tED6DAC0228C76F0A00ECDCB6 /* MXRoomKeyInfo.swift in Sources */,\n \t\t\t\tB146D4E421A5AEF200D8C2C6 /* MXRealmMediaScanMapper.m in Sources */,\n \t\t\t\tB146D4E321A5AEF200D8C2C6 /* MXRealmMediaScan.m in Sources */,\n \t\t\t\tED5C754628B3E80300D24E85 /* MXLogger.m in Sources */,\n@@ -6487,6 +6584,7 @@\n \t\t\t\tB1136965230AC9D900E2B2FA /* MXIdentityService.m in Sources */,\n \t\t\t\t66836AB727CFA17200515780 /* MXEventStreamService.swift in Sources */,\n \t\t\t\tB11BD44922CB56790064D8B0 /* MXReplyEventParser.m in Sources */,\n+\t\t\t\tED01915228C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m in Sources */,\n \t\t\t\tED8F1D3B2885BB2D00F897E7 /* MXCryptoProtocols.swift in Sources */,\n \t\t\t\tEC0B941127184E8A00B4D440 /* MXRoomSummaryMO.swift in Sources */,\n \t\t\t\tEDBCF339281A8D3D00ED5044 /* MXSharedHistoryKeyService.m in Sources */,\n@@ -6598,6 +6696,7 @@\n \t\t\t\tB1F04B1A2812A4E000103EBE /* MXBeaconInfoSummaryProtocol.swift in Sources */,\n \t\t\t\t021AFBA52179E91900742B2C /* MXEncryptedContentKey.m in Sources */,\n \t\t\t\t32F634AC1FC5E3480054EF49 /* MXEventDecryptionResult.m in Sources */,\n+\t\t\t\tED01915628C64E0400ED3A69 /* MXRoomKeyEventContent.m in Sources */,\n \t\t\t\t327137281A24D50A00DB6757 /* MXMyUser.m in Sources */,\n \t\t\t\tECDA763B27B6B74C000C48CF /* MXCapabilities.m in Sources */,\n \t\t\t\tEC0B94242718E3EE00B4D440 /* MXCoreDataRoomListDataFetcher.swift in Sources */,\n@@ -6640,6 +6739,7 @@\n \t\t\t\tA780625027B2CE74005780C0 /* FileManager+AppGroupContainer.swift in Sources */,\n \t\t\t\t9274AFE91EE580240009BEB6 /* MXCallKitAdapter.m in Sources */,\n \t\t\t\t3274538C23FD918800438328 /* MXKeyVerificationByToDeviceRequest.m in Sources */,\n+\t\t\t\tED6DAC1828C799E300ECDCB6 /* MXRoomKeyResult.swift in Sources */,\n \t\t\t\tECB6FA952683811800A941E4 /* MXiOSAudioOutputRouter.swift in Sources */,\n \t\t\t\tEC131B0A2758D56600712964 /* MXThreadNotificationsCount.swift in Sources */,\n \t\t\t\tEC1848C52685F64D00865E16 /* MXiOSAudioOutputRoute.swift in Sources */,\n@@ -6653,6 +6753,7 @@\n \t\t\t\tEC383BA5253DE6C9002FBBE6 /* MXSyncResponseStore.swift in Sources */,\n \t\t\t\t32CEEF4523AD2A6C0039BA98 /* MXCrossSigningKey.m in Sources */,\n \t\t\t\t327E9AF02289C61100A98BC1 /* MXAggregations.m in Sources */,\n+\t\t\t\tED6DAC1B28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift in Sources */,\n \t\t\t\tB18B0E4A25FB783B00E32151 /* MXSpaceCreationParameters.swift in Sources */,\n \t\t\t\tEDD578E52881C37C006739DD /* MXCrossSigningInfoSource.swift in Sources */,\n \t\t\t\tEC2EACFF266625170038B61F /* MXRoomLastMessage.m in Sources */,\n@@ -6679,6 +6780,7 @@\n \t\t\t\t32A31BC920D401FC005916C7 /* MXRoomFilter.m in Sources */,\n \t\t\t\tB190AC812833FA8900D6F0C4 /* MXBeaconInfoSummaryRealmStore.swift in Sources */,\n \t\t\t\tEC11658F270F3ABF0089FA56 /* RLMRealm+MatrixSDK.m in Sources */,\n+\t\t\t\tED6DAC0A28C784AE00ECDCB6 /* Dictionary.swift in Sources */,\n \t\t\t\t32A151471DAF7C0C00400192 /* MXDeviceInfo.m in Sources */,\n \t\t\t\tECDA764E27BA963D000C48CF /* MXBooleanCapability.m in Sources */,\n \t\t\t\t321CFDEB22525DEE004D31DF /* MXIncomingSASTransaction.m in Sources */,\n@@ -6754,6 +6856,7 @@\n \t\t\t\tB146D47B21A5958400D8C2C6 /* MXAntivirusScanStatusFormatter.m in Sources */,\n \t\t\t\tEC8A53DE25B1BCC6004E0802 /* MXThirdpartyProtocolsResponse.m in Sources */,\n \t\t\t\t32133022228BF7BC0070BA9B /* MXReactionCountChange.m in Sources */,\n+\t\t\t\tED6DAC2228C7A51400ECDCB6 /* MXDateProvider.swift in Sources */,\n \t\t\t\t32A151491DAF7C0C00400192 /* MXKey.m in Sources */,\n \t\t\t\t324DD2AE246AEB7B00377005 /* MXSecretStoragePassphrase.m in Sources */,\n \t\t\t\tECB5D98C2552C9B4000AD89C /* MXStopwatch.swift in Sources */,\n@@ -6777,6 +6880,7 @@\n \t\t\t\t3291D4D51A68FFEB00C3BA41 /* MXFileRoomStore.m in Sources */,\n \t\t\t\t329FB1801A0B665800A5E88E /* MXUser.m in Sources */,\n \t\t\t\t324AAC73239913AD00380A66 /* MXKeyVerificationDone.m in Sources */,\n+\t\t\t\tED6DABFC28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift in Sources */,\n \t\t\t\tB11556EE230C45C600B2A2CF /* MXIdentityServerRestClient.swift in Sources */,\n \t\t\t\t321CFDE722525A49004D31DF /* MXSASTransaction.m in Sources */,\n \t\t\t\t32720D9D222EAA6F0086FFF5 /* MXDiscoveredClientConfig.m in Sources */,\n@@ -6891,6 +6995,7 @@\n \t\t\t\tEC51019D26C41981007D6D88 /* MXSyncResponseUnitTests.swift in Sources */,\n \t\t\t\tEDB4209527DF822B0036AF39 /* MXEventsByTypesEnumeratorOnArrayTests.swift in Sources */,\n \t\t\t\tEC40385D28A16EDA0067D5B8 /* MXAes256KeyBackupTests.m in Sources */,\n+\t\t\t\tED6DAC0728C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift in Sources */,\n \t\t\t\t3265CB3B1A151C3800E24B2F /* MXRoomStateTests.m in Sources */,\n \t\t\t\tED8F1D302885AB0300F897E7 /* MXTrustLevelSourceUnitTests.swift in Sources */,\n \t\t\t\tB135066927EA100000BD3276 /* MXBeaconInfoUnitTests.swift in Sources */,\n@@ -6901,6 +7006,7 @@\n \t\t\t\t324BE45B1E3FA7A8008D99D4 /* MXMegolmExportEncryptionUnitTests.m in Sources */,\n \t\t\t\t327E9ACF2284783E00A98BC1 /* MXEventAnnotationUnitTests.swift in Sources */,\n \t\t\t\tEC40386128A1A3830067D5B8 /* MXBaseKeyBackupTests.m in Sources */,\n+\t\t\t\tED6DAC0D28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift in Sources */,\n \t\t\t\t32EEA84A2603FDD60041425B /* MXResponseUnitTests.swift in Sources */,\n \t\t\t\t32322A481E57264E005DD155 /* MXSelfSignedHomeserverTests.m in Sources */,\n \t\t\t\t325653831A2E14ED00CC0423 /* MXStoreTests.m in Sources */,\n@@ -6911,6 +7017,7 @@\n \t\t\t\t32B477852638133C00EA5800 /* MXAggregatedEditsUnitTests.m in Sources */,\n \t\t\t\tECB6FA8E267CFF4300A941E4 /* MXCredentialsUnitTests.swift in Sources */,\n \t\t\t\tED7019F52886CA6C00FC31B9 /* MXKeyVerificationRequestV2UnitTests.swift in Sources */,\n+\t\t\t\tED6DAC1128C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift in Sources */,\n \t\t\t\t3A108E6725826F52005EEBE9 /* MXKeyProviderUnitTests.m in Sources */,\n \t\t\t\t3A858DE8275511A4006322C1 /* MXRoomAliasAvailabilityCheckerResultTests.swift in Sources */,\n \t\t\t\tEC116593270FB6970089FA56 /* MXBackgroundTaskUnitTests.swift in Sources */,\n@@ -6925,6 +7032,7 @@\n \t\t\t\tEDF4678727E3331D00435913 /* EventsEnumeratorDataSourceStub.swift in Sources */,\n \t\t\t\tEC746C59274E61EF002AD24C /* MXThreadingServiceTests.swift in Sources */,\n \t\t\t\t32A31BC120D3F4C4005916C7 /* MXFilterTests.m in Sources */,\n+\t\t\t\tED6DAC1528C78D4000ECDCB6 /* MXMemoryCryptoStore.swift in Sources */,\n \t\t\t\t32B477842638133C00EA5800 /* MXAggregatedReferenceUnitTests.m in Sources */,\n \t\t\t\t32B0E3E423A384D40054FF1A /* MXAggregatedReferenceTests.m in Sources */,\n \t\t\t\t32D5D16323E400A600E3E37C /* MXRoomSummaryTrustTests.m in Sources */,\n@@ -6952,6 +7060,7 @@\n \t\t\t\tEDE1B13B28B7BEAB000DEEE8 /* MXCrossSigningV2UnitTests.swift in Sources */,\n \t\t\t\tEC746C56274E5197002AD24C /* MXThreadingServiceUnitTests.swift in Sources */,\n \t\t\t\tED8F1D252885A39800F897E7 /* MXCrossSigningInfoSourceUnitTests.swift in Sources */,\n+\t\t\t\tED6DAC1E28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift in Sources */,\n \t\t\t\t32A27D1F19EC335300BAFADE /* MXRoomTests.m in Sources */,\n \t\t\t\t32D8CAC219DEE6ED002AF8A0 /* MXRestClientNoAuthAPITests.m in Sources */,\n \t\t\t\t32FCAB4D19E578860049C555 /* MXRestClientTests.m in Sources */,\n@@ -7069,6 +7178,7 @@\n \t\t\t\tB14EF1EF2397E90400758AF0 /* MXIdentityService.m in Sources */,\n \t\t\t\tECF29BE62641953C0053E6D6 /* MXAssertedIdentityModel.m in Sources */,\n \t\t\t\tEC8A53C625B1BC77004E0802 /* MXTurnServerResponse.m in Sources */,\n+\t\t\t\tED6DAC0328C76F0A00ECDCB6 /* MXRoomKeyInfo.swift in Sources */,\n \t\t\t\tB14EF1F02397E90400758AF0 /* MXReplyEventParser.m in Sources */,\n \t\t\t\tB14EF1F12397E90400758AF0 /* MXFileStore.m in Sources */,\n \t\t\t\tED5C754728B3E80300D24E85 /* MXLogger.m in Sources */,\n@@ -7086,6 +7196,7 @@\n \t\t\t\t3A108A8125810C96005EEBE9 /* MXKeyData.m in Sources */,\n \t\t\t\t66836AB827CFA17200515780 /* MXEventStreamService.swift in Sources */,\n \t\t\t\t3A59A4A025A7A16F00DDA1FC /* MXOlmOutboundGroupSession.m in Sources */,\n+\t\t\t\tED01915328C64E0400ED3A69 /* MXForwardedRoomKeyEventContent.m in Sources */,\n \t\t\t\tED8F1D3C2885BB2D00F897E7 /* MXCryptoProtocols.swift in Sources */,\n \t\t\t\tEC0B941227184E8A00B4D440 /* MXRoomSummaryMO.swift in Sources */,\n \t\t\t\tEDBCF33A281A8D3D00ED5044 /* MXSharedHistoryKeyService.m in Sources */,\n@@ -7197,6 +7308,7 @@\n \t\t\t\tB1F04B1B2812A4E000103EBE /* MXBeaconInfoSummaryProtocol.swift in Sources */,\n \t\t\t\tEC60EDDD265CFF0600B39A4E /* MXInvitedRoomSync.m in Sources */,\n \t\t\t\tB14EF2292397E90400758AF0 /* MXRealmEventScanMapper.m in Sources */,\n+\t\t\t\tED01915728C64E0400ED3A69 /* MXRoomKeyEventContent.m in Sources */,\n \t\t\t\tECDA763C27B6B74C000C48CF /* MXCapabilities.m in Sources */,\n \t\t\t\tEC0B94252718E3EF00B4D440 /* MXCoreDataRoomListDataFetcher.swift in Sources */,\n \t\t\t\tB14EF22A2397E90400758AF0 /* MXReplyEventFormattedBodyParts.m in Sources */,\n@@ -7239,6 +7351,7 @@\n \t\t\t\tB14EF23B2397E90400758AF0 /* MXKeyBackupData.m in Sources */,\n \t\t\t\tB14EF23C2397E90400758AF0 /* MXJSONModels.m in Sources */,\n \t\t\t\tEC8A538E25B1BC77004E0802 /* MXCallSessionDescription.m in Sources */,\n+\t\t\t\tED6DAC1928C799E300ECDCB6 /* MXRoomKeyResult.swift in Sources */,\n \t\t\t\tEC131B0B2758D56600712964 /* MXThreadNotificationsCount.swift in Sources */,\n \t\t\t\tB14EF23D2397E90400758AF0 /* MXCallManager.m in Sources */,\n \t\t\t\tB14EF23E2397E90400758AF0 /* MXPeekingRoom.m in Sources */,\n@@ -7252,6 +7365,7 @@\n \t\t\t\tEC8A53A625B1BC77004E0802 /* MXCallInviteEventContent.m in Sources */,\n \t\t\t\tECD2899226EB3B3400F268CF /* MXRoomListDataFetcher.swift in Sources */,\n \t\t\t\tB18B0E5025FB783F00E32151 /* MXSpaceService.swift in Sources */,\n+\t\t\t\tED6DAC1C28C79AA300ECDCB6 /* MXUnrequestedForwardedRoomKeyManager.swift in Sources */,\n \t\t\t\tB14EF2412397E90400758AF0 /* MXRoomFilter.m in Sources */,\n \t\t\t\tEDD578E62881C37C006739DD /* MXCrossSigningInfoSource.swift in Sources */,\n \t\t\t\tEC8A53D925B1BCC6004E0802 /* MXThirdPartyProtocolInstance.m in Sources */,\n@@ -7278,6 +7392,7 @@\n \t\t\t\tB135066F27EA44C800BD3276 /* MXLocationServiceError.swift in Sources */,\n \t\t\t\tB190AC822833FA8900D6F0C4 /* MXBeaconInfoSummaryRealmStore.swift in Sources */,\n \t\t\t\tB14EF24B2397E90400758AF0 /* MXServiceTermsRestClient.m in Sources */,\n+\t\t\t\tED6DAC0B28C784AE00ECDCB6 /* Dictionary.swift in Sources */,\n \t\t\t\tEC1165C527107E330089FA56 /* MXRoomListDataFilterOptions.swift in Sources */,\n \t\t\t\t3A858DE227528EEB006322C1 /* MXHomeserverCapabilitiesService.swift in Sources */,\n \t\t\t\tECDA764F27BA963D000C48CF /* MXBooleanCapability.m in Sources */,\n@@ -7353,6 +7468,7 @@\n \t\t\t\tB14EF26B2397E90400758AF0 /* MXMegolmBackupCreationInfo.m in Sources */,\n \t\t\t\tB14EF26C2397E90400758AF0 /* MXRoom.m in Sources */,\n \t\t\t\tB14EF26D2397E90400758AF0 /* NSData+MatrixSDK.m in Sources */,\n+\t\t\t\tED6DAC2128C7A51400ECDCB6 /* MXDateProvider.swift in Sources */,\n \t\t\t\tEC383BB22540688E002FBBE6 /* MXBackgroundStore.swift in Sources */,\n \t\t\t\tB14EF26E2397E90400758AF0 /* MXFileRoomStore.m in Sources */,\n \t\t\t\tEC60ED9D265CFE1700B39A4E /* MXRoomSyncState.m in Sources */,\n@@ -7376,6 +7492,7 @@\n \t\t\t\tB18B0E4B25FB783B00E32151 /* MXSpaceCreationParameters.swift in Sources */,\n \t\t\t\tB14EF2752397E90400758AF0 /* MXResponse.swift in Sources */,\n \t\t\t\tB14EF2772397E90400758AF0 /* MXDecryptionResult.m in Sources */,\n+\t\t\t\tED6DABFD28C7542800ECDCB6 /* MXRoomKeyInfoFactory.swift in Sources */,\n \t\t\t\tB14EF2782397E90400758AF0 /* MXTransactionCancelCode.m in Sources */,\n \t\t\t\tB14EF2792397E90400758AF0 /* MXEventListener.m in Sources */,\n \t\t\t\tB1710B202613D01400A9B429 /* MXSpaceChildrenRequestParameters.swift in Sources */,\n@@ -7490,6 +7607,7 @@\n \t\t\t\tEC51019E26C41981007D6D88 /* MXSyncResponseUnitTests.swift in Sources */,\n \t\t\t\tEDB4209627DF822B0036AF39 /* MXEventsByTypesEnumeratorOnArrayTests.swift in Sources */,\n \t\t\t\tEC40385E28A16EDA0067D5B8 /* MXAes256KeyBackupTests.m in Sources */,\n+\t\t\t\tED6DAC0828C77E1100ECDCB6 /* MXForwardedRoomKeyEventContentUnitTests.swift in Sources */,\n \t\t\t\t32B477AA2638186000EA5800 /* MXHTTPAdditionalHeadersUnitTests.m in Sources */,\n \t\t\t\tB135066A27EA100100BD3276 /* MXBeaconInfoUnitTests.swift in Sources */,\n \t\t\t\tEC0B944727206D0B00B4D440 /* MXCoreDataRoomListDataManagerUnitTests.swift in Sources */,\n@@ -7500,6 +7618,7 @@\n \t\t\t\tB1E09A3E2397FD820057C069 /* MXToolsUnitTests.m in Sources */,\n \t\t\t\t32B477912638133D00EA5800 /* MXAggregatedEditsUnitTests.m in Sources */,\n \t\t\t\tEC40386228A1A3830067D5B8 /* MXBaseKeyBackupTests.m in Sources */,\n+\t\t\t\tED6DAC0E28C784E200ECDCB6 /* MXRoomKeyEventContentUnitTests.swift in Sources */,\n \t\t\t\tB1E09A1E2397FCE90057C069 /* MXCryptoShareTests.m in Sources */,\n \t\t\t\tB1E09A422397FD820057C069 /* MXCryptoTests.m in Sources */,\n \t\t\t\tB1E09A382397FD7D0057C069 /* MXUserTests.m in Sources */,\n@@ -7510,6 +7629,7 @@\n \t\t\t\t32AF9293241112850008A0FD /* MXCryptoSecretShareTests.m in Sources */,\n \t\t\t\tB1E09A462397FD990057C069 /* MXMediaScanStoreUnitTests.m in Sources */,\n \t\t\t\tED7019F62886CA6C00FC31B9 /* MXKeyVerificationRequestV2UnitTests.swift in Sources */,\n+\t\t\t\tED6DAC1228C788A700ECDCB6 /* MXRoomKeyInfoFactoryUnitTests.swift in Sources */,\n \t\t\t\tECB6FA8F267CFF4300A941E4 /* MXCredentialsUnitTests.swift in Sources */,\n \t\t\t\t3A858DE9275511A4006322C1 /* MXRoomAliasAvailabilityCheckerResultTests.swift in Sources */,\n \t\t\t\tED7019DF2886C25600FC31B9 /* MXDeviceInfoUnitTests.swift in Sources */,\n@@ -7524,6 +7644,7 @@\n \t\t\t\tB1B4431A283D00CA00BB26F4 /* MXMegolmDecryptionUnitTests.swift in Sources */,\n \t\t\t\tEDF4678827E3331D00435913 /* EventsEnumeratorDataSourceStub.swift in Sources */,\n \t\t\t\tEC746C5A274E61EF002AD24C /* MXThreadingServiceTests.swift in Sources */,\n+\t\t\t\tED6DAC1628C78D4000ECDCB6 /* MXMemoryCryptoStore.swift in Sources */,\n \t\t\t\tB1E09A222397FCE90057C069 /* MXRoomSummaryTests.m in Sources */,\n \t\t\t\tB1E09A3A2397FD820057C069 /* MXStoreTests.m in Sources */,\n \t\t\t\tB1E09A342397FD750057C069 /* MXRoomStateDynamicTests.m in Sources */,\n@@ -7551,6 +7672,7 @@\n \t\t\t\tEDE1B13C28B7BEAB000DEEE8 /* MXCrossSigningV2UnitTests.swift in Sources */,\n \t\t\t\tA816248525F60D0300A46F05 /* MXDeviceListOperationsPoolUnitTests.swift in Sources */,\n \t\t\t\tEC746C57274E5197002AD24C /* MXThreadingServiceUnitTests.swift in Sources */,\n+\t\t\t\tED6DAC1F28C79D2000ECDCB6 /* MXUnrequestedForwardedRoomKeyManagerUnitTests.swift in Sources */,\n \t\t\t\tB1E09A312397FD750057C069 /* MXSessionTests.m in Sources */,\n \t\t\t\t32B477902638133D00EA5800 /* MXAggregatedReferenceUnitTests.m in Sources */,\n \t\t\t\tEC116598270FCA8B0089FA56 /* MXBackgroundTaskUnitTests.swift in Sources */,"
        },
        {
          "filename": "MatrixSDK/Background/MXBackgroundSyncService.swift",
          "status": "modified",
          "additions": 28,
          "deletions": 48,
          "patch": "@@ -564,6 +564,12 @@ public enum MXBackgroundSyncServiceError: Error {\n     }\n     \n     private func handleToDeviceEvent(_ event: MXEvent) {\n+        //   only handle supported events\n+        guard MXTools.isSupportedToDeviceEvent(event) else {\n+            MXLog.debug(\"[MXBackgroundSyncService] handleToDeviceEvent: ignore unsupported event\")\n+            return\n+        }\n+        \n         if event.isEncrypted {\n             do {\n                 try decryptEvent(event)\n@@ -573,61 +579,35 @@ public enum MXBackgroundSyncServiceError: Error {\n             }\n         }\n         \n-        guard let content = event.content else {\n-            MXLog.debug(\"[MXBackgroundSyncService] handleToDeviceEvent: ERROR: incomplete event content: \\(String(describing: event.jsonDictionary()))\")\n+        guard let userId = credentials.userId else {\n+            MXLog.error(\"[MXBackgroundSyncService] handleToDeviceEvent: Cannot get userId\")\n             return\n         }\n         \n-        guard let roomId = content[\"room_id\"] as? String,\n-            let sessionId = content[\"session_id\"] as? String,\n-            let sessionKey = content[\"session_key\"] as? String,\n-            var senderKey = event.senderKey else {\n-            MXLog.debug(\"[MXBackgroundSyncService] handleToDeviceEvent: ERROR: incomplete event: \\(String(describing: event.jsonDictionary()))\")\n+        let factory = MXRoomKeyInfoFactory(myUserId: userId, store: cryptoStore)\n+        guard let key = factory.roomKey(for: event) else {\n+            MXLog.error(\"[MXBackgroundSyncService] handleToDeviceEvent: Cannot create megolm key from event\")\n             return\n         }\n         \n-        var forwardingKeyChain: [String] = []\n-        var exportFormat: Bool = false\n-        var keysClaimed: [String: String] = [:]\n-        \n-        switch event.eventType {\n-        case .roomKey:\n-            keysClaimed = event.keysClaimed as! [String: String]\n-        case .roomForwardedKey:\n-            exportFormat = true\n-            \n-            if let array = content[\"forwarding_curve25519_key_chain\"] as? [String] {\n-                forwardingKeyChain = array\n-            }\n-            forwardingKeyChain.append(senderKey)\n-            \n-            if let senderKeyInContent = content[\"sender_key\"] as? String {\n-                senderKey = senderKeyInContent\n-            } else {\n-                return\n-            }\n-            \n-            guard let ed25519Key = event.content[\"sender_claimed_ed25519_key\"] as? String else {\n-                return\n-            }\n-            \n-            keysClaimed = [\n-                \"ed25519\": ed25519Key\n-            ]\n-        default:\n-            MXLog.debug(\"[MXBackgroundSyncService] handleToDeviceEvent: ERROR: Not supported type: \\(event.eventType)\")\n-            return\n+        switch key.type {\n+        case .safe:\n+            olmDevice.addInboundGroupSession(\n+                key.info.sessionId,\n+                sessionKey: key.info.sessionKey,\n+                roomId: key.info.roomId,\n+                senderKey: key.info.senderKey,\n+                forwardingCurve25519KeyChain: key.info.forwardingKeyChain,\n+                keysClaimed: key.info.keysClaimed,\n+                exportFormat: key.info.exportFormat,\n+                sharedHistory: key.info.sharedHistory,\n+                untrusted: key.type != .safe\n+            )\n+        case .unsafe:\n+            MXLog.warning(\"[MXBackgroundSyncService] handleToDeviceEvent: Ignoring unsafe keys\")\n+        case .unrequested:\n+            MXLog.warning(\"[MXBackgroundSyncService] handleToDeviceEvent: Ignoring unrequested keys\")\n         }\n-        \n-        let sharedHistory = (content[kMXSharedHistoryKeyName] as? Bool) ?? false\n-        olmDevice.addInboundGroupSession(sessionId,\n-                                         sessionKey: sessionKey,\n-                                         roomId: roomId,\n-                                         senderKey: senderKey,\n-                                         forwardingCurve25519KeyChain: forwardingKeyChain,\n-                                         keysClaimed: keysClaimed,\n-                                         exportFormat: exportFormat,\n-                                         sharedHistory: sharedHistory)\n     }\n     \n     private func updateBackgroundServiceStoresIfNeeded() {"
        },
        {
          "filename": "MatrixSDK/Contrib/Swift/JSONModels/MXEvent.swift",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -73,6 +73,9 @@ public enum MXEventType: Equatable, Hashable {\n     case keyVerificationMac\n     case keyVerificationCancel\n     case keyVerificationDone\n+    case secretRequest\n+    case secretSend\n+    case secretStorageDefaultKey\n     case taggedEvents\n     case spaceChild\n     case spaceOrder\n@@ -132,6 +135,9 @@ public enum MXEventType: Equatable, Hashable {\n         case .keyVerificationMac: return kMXEventTypeStringKeyVerificationMac\n         case .keyVerificationCancel: return kMXEventTypeStringKeyVerificationCancel\n         case .keyVerificationDone: return kMXEventTypeStringKeyVerificationDone\n+        case .secretRequest: return kMXEventTypeStringSecretRequest\n+        case .secretSend: return kMXEventTypeStringSecretSend\n+        case .secretStorageDefaultKey: return kMXEventTypeStringSecretStorageDefaultKey\n         case .taggedEvents: return kMXEventTypeStringTaggedEvents\n         case .spaceChild: return kMXEventTypeStringSpaceChild\n         case .spaceOrder: return kMXEventTypeStringSpaceOrderMSC3230\n@@ -151,7 +157,7 @@ public enum MXEventType: Equatable, Hashable {\n     }\n     \n     public init(identifier: String) {\n-        let events: [MXEventType] = [.roomName, .roomTopic, .roomAvatar, .roomMember, .roomCreate, .roomJoinRules, .roomPowerLevels, .roomAliases, .roomCanonicalAlias, .roomEncrypted, .roomEncryption, .roomGuestAccess, .roomHistoryVisibility, .roomKey, .roomForwardedKey, .roomKeyRequest, .roomMessage, .roomMessageFeedback, .roomRedaction, .roomThirdPartyInvite, .roomTag, .presence, .typing, .callInvite, .callCandidates, .callAnswer, .callSelectAnswer, .callHangup, .callReject, .callNegotiate, .callReplaces, .callRejectReplacement, .callAssertedIdentity, .callAssertedIdentityUnstable, .reaction, .receipt, .roomTombStone, .keyVerificationStart, .keyVerificationAccept, .keyVerificationKey, .keyVerificationMac, .keyVerificationCancel, .keyVerificationDone, .taggedEvents, .spaceChild, .spaceOrder, .pollStart, .pollResponse, .pollEnd, .beaconInfo, .beacon]\n+        let events: [MXEventType] = [.roomName, .roomTopic, .roomAvatar, .roomMember, .roomCreate, .roomJoinRules, .roomPowerLevels, .roomAliases, .roomCanonicalAlias, .roomEncrypted, .roomEncryption, .roomGuestAccess, .roomHistoryVisibility, .roomKey, .roomForwardedKey, .roomKeyRequest, .roomMessage, .roomMessageFeedback, .roomRedaction, .roomThirdPartyInvite, .roomTag, .presence, .typing, .callInvite, .callCandidates, .callAnswer, .callSelectAnswer, .callHangup, .callReject, .callNegotiate, .callReplaces, .callRejectReplacement, .callAssertedIdentity, .callAssertedIdentityUnstable, .reaction, .receipt, .roomTombStone, .keyVerificationStart, .keyVerificationAccept, .keyVerificationKey, .keyVerificationMac, .keyVerificationCancel, .keyVerificationDone, .secretRequest, .secretSend, .secretStorageDefaultKey, .taggedEvents, .spaceChild, .spaceOrder, .pollStart, .pollResponse, .pollEnd, .beaconInfo, .beacon]\n         \n         if let type = events.first(where: { $0.identifier == identifier }) {\n             self = type"
        },
        {
          "filename": "MatrixSDK/Crypto/Algorithms/MXDecrypting.h",
          "status": "modified",
          "additions": 11,
          "deletions": 4,
          "patch": "@@ -23,7 +23,7 @@\n #import \"MXEventDecryptionResult.h\"\n #import \"MXIncomingRoomKeyRequest.h\"\n \n-@class MXCrypto, MXOlmInboundGroupSession;\n+@class MXCrypto, MXOlmInboundGroupSession, MXRoomKeyResult;\n \n \n @protocol MXDecrypting <NSObject>\n@@ -56,12 +56,19 @@\n - (MXEventDecryptionResult *)decryptEvent:(MXEvent*)event inTimeline:(NSString*)timeline;\n \n /**\n- * Handle a key event.\n- *\n- * @param event the key event.\n+ Handle a key event.\n+ \n+ @param event the key event.\n  */\n - (void)onRoomKeyEvent:(MXEvent*)event;\n \n+/**\n+ Handle new room key\n+ \n+ @param key the domain object with key details and safety\n+ */\n+- (void)onRoomKey:(MXRoomKeyResult*)key;\n+\n /**\n  Notification that a room key has been imported.\n "
        },
        {
          "filename": "MatrixSDK/Crypto/Algorithms/Megolm/MXMegolmDecryption.m",
          "status": "modified",
          "additions": 44,
          "deletions": 77,
          "patch": "@@ -26,6 +26,7 @@\n #import \"MXTools.h\"\n #import \"MatrixSDKSwiftHeader.h\"\n #import \"MXSharedHistoryKeyService.h\"\n+#import \"MXForwardedRoomKeyEventContent.h\"\n \n @interface MXMegolmDecryption ()\n {\n@@ -41,6 +42,10 @@ @interface MXMegolmDecryption ()\n         NSMutableDictionary<NSString* /* timelineId */,\n             NSMutableDictionary<NSString* /* eventId */, MXEvent*>*>*> *pendingEvents;\n }\n+\n+// Factory to create room key info\n+@property (nonatomic, strong) MXRoomKeyInfoFactory *roomKeyInfoFactory;\n+\n @end\n \n @implementation MXMegolmDecryption\n@@ -59,6 +64,7 @@ - (instancetype)initWithCrypto:(MXCrypto *)theCrypto\n     {\n         crypto = theCrypto;\n         olmDevice = theCrypto.olmDevice;\n+        _roomKeyInfoFactory = [[MXRoomKeyInfoFactory alloc] initWithMyUserId:crypto.mxSession.credentials.userId store:crypto.store];\n         pendingEvents = [NSMutableDictionary dictionary];\n     }\n     return self;\n@@ -191,98 +197,59 @@ - (void)addEventToPendingList:(MXEvent*)event inTimeline:(NSString*)timelineId\n \n - (void)onRoomKeyEvent:(MXEvent *)event\n {\n-    NSDictionary *content = event.content;\n-    NSString *roomId, *sessionId, *sessionKey;\n-\n-    MXJSONModelSetString(roomId, content[@\"room_id\"]);\n-    MXJSONModelSetString(sessionId, content[@\"session_id\"]);\n-    MXJSONModelSetString(sessionKey, content[@\"session_key\"]);\n-\n-    if (!roomId || !sessionId || !sessionKey)\n+    MXRoomKeyResult *key = [self.roomKeyInfoFactory roomKeyFor:event];\n+    if (!key)\n     {\n-        MXLogDebug(@\"[MXMegolmDecryption] onRoomKeyEvent: ERROR: Key event is missing fields\");\n+        MXLogError(@\"[MXMegolmDecryption] onRoomKeyEvent: Cannot create megolm key from event\");\n         return;\n     }\n-\n-    NSString *senderKey = event.senderKey;\n-    if (!senderKey)\n-    {\n-        MXLogDebug(@\"[MXMegolmDecryption] onRoomKeyEvent: ERROR: Key event has no sender key (not encrypted?)\");\n-        return;\n-    }\n-\n-    NSArray<NSString*> *forwardingKeyChain;\n-    BOOL exportFormat = NO;\n-    NSDictionary *keysClaimed;\n-    BOOL sharedHistory = NO;\n-    if (content[kMXSharedHistoryKeyName] != nil)\n-    {\n-        MXJSONModelSetBoolean(sharedHistory, content[kMXSharedHistoryKeyName]);\n-    }\n-\n-    if (event.eventType == MXEventTypeRoomForwardedKey)\n-    {\n-        exportFormat = YES;\n-        MXJSONModelSetArray(forwardingKeyChain, content[@\"forwarding_curve25519_key_chain\"]);\n-        if (!forwardingKeyChain)\n-        {\n-            forwardingKeyChain = @[];\n-        }\n-\n-        // copy content before we modify it\n-        NSMutableArray *forwardingKeyChain2 = [NSMutableArray arrayWithArray:forwardingKeyChain];\n-        [forwardingKeyChain2 addObject:senderKey];\n-        forwardingKeyChain = forwardingKeyChain2;\n-\n-        MXJSONModelSetString(senderKey, content[@\"sender_key\"]);\n-        if (!senderKey)\n-        {\n-            MXLogDebug(@\"[MXMegolmDecryption] onRoomKeyEvent: ERROR: forwarded_room_key event is missing sender_key field\");\n-            return;\n-        }\n-\n-        NSString *ed25519Key;\n-        MXJSONModelSetString(ed25519Key, content[@\"sender_claimed_ed25519_key\"]);\n-        if (!ed25519Key)\n-        {\n-            MXLogDebug(@\"[MXMegolmDecryption] onRoomKeyEvent: ERROR: forwarded_room_key_event is missing sender_claimed_ed25519_key field\");\n-            return;\n-        }\n-\n-        keysClaimed = @{\n-                        @\"ed25519\": ed25519Key\n-                        };\n-    }\n-    else\n-    {\n-        keysClaimed = event.keysClaimed;\n+    \n+    switch (key.type) {\n+        case MXRoomKeyTypeSafe:\n+            MXLogDebug(@\"[MXMegolmDecryption] onRoomKeyEvent: Adding key for megolm session %@|%@ from %@ event\", key.info.senderKey, key.info.sessionId, event.type);\n+            [self onRoomKey:key];\n+            break;\n+        case MXRoomKeyTypeUnsafe:\n+            MXLogWarning(@\"[MXMegolmDecryption] onRoomKeyEvent: Ignoring unsafe key\");\n+            break;\n+        case MXRoomKeyTypeUnrequested:\n+            [crypto handleUnrequestedRoomKeyInfo:key.info senderId:event.sender senderKey:event.senderKey];\n+            break;\n+        default:\n+            MXLogFailureDetails(@\"[MXMegolmDecryption] onRoomKeyEvent: Unknown key type\", @{\n+                @\"key_type\": @(key.type)\n+            });\n+            break;\n     }\n+}\n \n-    MXLogDebug(@\"[MXMegolmDecryption] onRoomKeyEvent: Adding key for megolm session %@|%@ from %@ event\", senderKey, sessionId, event.type);\n-\n-    [olmDevice addInboundGroupSession:sessionId\n-                           sessionKey:sessionKey\n-                               roomId:roomId\n-                            senderKey:senderKey\n-         forwardingCurve25519KeyChain:forwardingKeyChain\n-                          keysClaimed:keysClaimed\n-                         exportFormat:exportFormat\n-                        sharedHistory:sharedHistory];\n+- (void)onRoomKey:(MXRoomKeyResult *)key\n+{\n+    MXRoomKeyInfo *keyInfo = key.info;\n+    [olmDevice addInboundGroupSession:keyInfo.sessionId\n+                           sessionKey:keyInfo.sessionKey\n+                               roomId:keyInfo.roomId\n+                            senderKey:keyInfo.senderKey\n+         forwardingCurve25519KeyChain:keyInfo.forwardingKeyChain\n+                          keysClaimed:keyInfo.keysClaimed\n+                         exportFormat:keyInfo.exportFormat\n+                        sharedHistory:keyInfo.sharedHistory\n+                            untrusted:key.type != MXRoomKeyTypeSafe];\n \n     [crypto.backup maybeSendKeyBackup];\n \n     MXWeakify(self);\n-    [self retryDecryption:senderKey sessionId:content[@\"session_id\"] complete:^(BOOL allDecrypted) {\n+    [self retryDecryption:keyInfo.senderKey sessionId:keyInfo.sessionId complete:^(BOOL allDecrypted) {\n         MXStrongifyAndReturnIfNil(self);\n \n         if (allDecrypted)\n         {\n             // cancel any outstanding room key requests for this session\n             [self->crypto cancelRoomKeyRequest:@{\n-                                                 @\"algorithm\": content[@\"algorithm\"],\n-                                                 @\"room_id\": content[@\"room_id\"],\n-                                                 @\"session_id\": content[@\"session_id\"],\n-                                                 @\"sender_key\": senderKey\n+                                                 @\"algorithm\": keyInfo.algorithm,\n+                                                 @\"room_id\": keyInfo.roomId,\n+                                                 @\"session_id\": keyInfo.sessionId,\n+                                                 @\"sender_key\": keyInfo.senderKey\n                                                  }];\n         }\n     }];"
        },
        {
          "filename": "MatrixSDK/Crypto/Algorithms/Megolm/MXMegolmEncryption.m",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -340,6 +340,7 @@ - (MXOutboundSessionInfo*)prepareNewSession\n                                                }\n                                 exportFormat:NO\n                                sharedHistory:sharedHistory\n+                                   untrusted:NO\n      ];\n \n     [crypto.backup maybeSendKeyBackup];"
        },
        {
          "filename": "MatrixSDK/Crypto/Algorithms/Olm/MXOlmDecryption.m",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -223,6 +223,11 @@ - (void)onRoomKeyEvent:(MXEvent *)event\n     // No impact for olm\n }\n \n+- (void)onRoomKeyInfo:(MXRoomKeyInfo *)keyInfo\n+{\n+    // No impact for olm\n+}\n+\n - (void)didImportRoomKey:(MXOlmInboundGroupSession *)session\n {\n     // No impact for olm"
        },
        {
          "filename": "MatrixSDK/Crypto/KeyBackup/Data/MXKeyBackupVersionTrust.h",
          "status": "modified",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -39,11 +39,6 @@ NS_ASSUME_NONNULL_BEGIN\n  */\n @property (nonatomic) NSArray<MXKeyBackupVersionTrustSignature*> *signatures;\n \n-/**\n- Flag indicating the backup trusted locally.\n- */\n-@property (nonatomic, getter=isTrustedLocally) BOOL trustedLocally;\n-\n @end\n \n "
        },
        {
          "filename": "MatrixSDK/Crypto/KeyBackup/Data/MXKeyBackupVersionTrust.m",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -25,7 +25,6 @@ - (instancetype)init\n     {\n         _usable = NO;\n         _signatures = [NSArray new];\n-        _trustedLocally = NO;\n     }\n     return self;\n }"
        },
        {
          "filename": "MatrixSDK/Crypto/KeyBackup/MXKeyBackup.m",
          "status": "modified",
          "additions": 0,
          "deletions": 12,
          "patch": "@@ -1123,17 +1123,6 @@ - (MXKeyBackupVersionTrust *)trustForKeyBackupVersionFromCryptoQueue:(MXKeyBacku\n         return keyBackupVersionTrust;\n     }\n \n-    NSData *privateKey = self.privateKeyFromCryptoStore;\n-    if (privateKey)\n-    {\n-        id<MXKeyBackupAlgorithm> algorithm = [self getOrCreateKeyBackupAlgorithmFor:keyBackupVersion privateKey:privateKey];\n-        if ([algorithm keyMatches:privateKey error:nil])\n-        {\n-            MXLogDebug(@\"[MXKeyBackup] trustForKeyBackupVersionFromCryptoQueue: Backup is trusted locally\");\n-            keyBackupVersionTrust.trustedLocally = YES;\n-        }\n-    }\n-\n     NSDictionary *mySigs = authData.signatures[myUserId];\n     NSMutableArray<MXKeyBackupVersionTrustSignature*> *signatures = [NSMutableArray array];\n     for (NSString *keyId in mySigs)\n@@ -1196,7 +1185,6 @@ - (MXKeyBackupVersionTrust *)trustForKeyBackupVersionFromCryptoQueue:(MXKeyBacku\n             keyBackupVersionTrust.usable = YES;\n         }\n     }\n-    keyBackupVersionTrust.usable = keyBackupVersionTrust.usable || keyBackupVersionTrust.isTrustedLocally;\n \n     return keyBackupVersionTrust;\n }"
        },
        {
          "filename": "MatrixSDK/Crypto/KeySharing/Data/MXForwardedRoomKeyEventContent.h",
          "status": "added",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -0,0 +1,74 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+#import <MatrixSDK/MatrixSDK.h>\n+\n+NS_ASSUME_NONNULL_BEGIN\n+\n+@interface MXForwardedRoomKeyEventContent : MXJSONModel\n+\n+/**\n+ The encryption algorithm the key in this event is to be used with\n+ */\n+@property (nonatomic) NSString *algorithm;\n+\n+/**\n+ The room where the key is used\n+ */\n+@property (nonatomic) NSString *roomId;\n+\n+/**\n+ The Curve25519 key of the device which initiated the session originally\n+ */\n+@property (nonatomic) NSString *senderKey;\n+\n+/**\n+ The ID of the session that the key is for\n+ */\n+@property (nonatomic) NSString *sessionId;\n+\n+/**\n+ The key to be exchanged\n+ */\n+@property (nonatomic) NSString *sessionKey;\n+\n+/**\n+ Chain of Curve25519 keys\n+ \n+ It starts out empty, but each time the key is forwarded to another device, the previous sender\n+ in the chain is added to the end of the list.\n+ \n+ For example, if the key is forwarded from A to B to C, this field is empty between A and B,\n+ and contains A's Curve25519 key between B and C\n+ */\n+@property (nonatomic) NSArray<NSString*> *forwardingCurve25519KeyChain;\n+\n+/**\n+ The Ed25519 key of the device which initiated the session originally\n+ \n+ It is 'claimed' because the receiving device has no way to tell that the original room_key actually\n+ came from a device which owns the private part of this key unless they have done device verification.\n+ */\n+@property (nonatomic) NSString *senderClaimedEd25519Key;\n+\n+/**\n+ MSC3061 Identifies keys that were sent when the room's visibility setting was set to `world_readable` or `shared`\n+ */\n+@property (nonatomic) BOOL sharedHistory;\n+\n+@end\n+\n+NS_ASSUME_NONNULL_END"
        },
        {
          "filename": "MatrixSDK/Crypto/KeySharing/Data/MXForwardedRoomKeyEventContent.m",
          "status": "added",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -0,0 +1,66 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+#import \"MXForwardedRoomKeyEventContent.h\"\n+\n+static NSString* const kJSONKeyAlgorithm = @\"algorithm\";\n+static NSString* const kJSONKeyRoomId = @\"room_id\";\n+static NSString* const kJSONKeySenderKey = @\"sender_key\";\n+static NSString* const kJSONKeySessionId = @\"session_id\";\n+static NSString* const kJSONKeySessionKey = @\"session_key\";\n+static NSString* const kJSONKeyForwardingCurve25519KeyChain = @\"forwarding_curve25519_key_chain\";\n+static NSString* const kJSONKeySenderClaimedEd25519Key = @\"sender_claimed_ed25519_key\";\n+\n+@implementation MXForwardedRoomKeyEventContent\n+\n+#pragma mark - MXJSONModel\n+\n++ (id)modelFromJSON:(NSDictionary *)JSONDictionary\n+{\n+    MXForwardedRoomKeyEventContent *result = [[MXForwardedRoomKeyEventContent alloc] init];\n+    MXJSONModelSetString(result.algorithm, JSONDictionary[kJSONKeyAlgorithm]);\n+    MXJSONModelSetString(result.roomId, JSONDictionary[kJSONKeyRoomId]);\n+    MXJSONModelSetString(result.sessionId, JSONDictionary[kJSONKeySessionId]);\n+    MXJSONModelSetString(result.sessionKey, JSONDictionary[kJSONKeySessionKey]);\n+    MXJSONModelSetString(result.senderKey, JSONDictionary[kJSONKeySenderKey]);\n+    MXJSONModelSetString(result.senderClaimedEd25519Key, JSONDictionary[kJSONKeySenderClaimedEd25519Key]);\n+    if (!result.algorithm || !result.roomId || !result.sessionId || !result.sessionKey || !result.senderKey || !result.senderClaimedEd25519Key)\n+    {\n+        MXLogError(@\"[MXRoomKeyEventContent] modelFromJSON: Key event is missing fields\");\n+        return nil;\n+    }\n+    \n+    MXJSONModelSetArray(result.forwardingCurve25519KeyChain, JSONDictionary[kJSONKeyForwardingCurve25519KeyChain] ?: @[]);\n+    MXJSONModelSetBoolean(result.sharedHistory, JSONDictionary[kMXSharedHistoryKeyName]);\n+\n+    return result;\n+}\n+\n+- (NSDictionary *)JSONDictionary\n+{\n+    NSMutableDictionary *JSONDictionary = [NSMutableDictionary dictionary];\n+    JSONDictionary[kJSONKeyAlgorithm] = _algorithm;\n+    JSONDictionary[kJSONKeyRoomId] = _roomId;\n+    JSONDictionary[kJSONKeySenderKey] = _senderKey;\n+    JSONDictionary[kJSONKeySessionId] = _sessionId;\n+    JSONDictionary[kJSONKeySessionKey] = _sessionKey;\n+    JSONDictionary[kJSONKeyForwardingCurve25519KeyChain] = _forwardingCurve25519KeyChain;\n+    JSONDictionary[kJSONKeySenderClaimedEd25519Key] = _senderClaimedEd25519Key;\n+    JSONDictionary[kMXSharedHistoryKeyName] = @(_sharedHistory);\n+    return JSONDictionary;\n+}\n+\n+@end"
        },
        {
          "filename": "MatrixSDK/Crypto/KeySharing/Data/MXRoomKeyEventContent.h",
          "status": "added",
          "additions": 50,
          "deletions": 0,
          "patch": "@@ -0,0 +1,50 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+#import <MatrixSDK/MatrixSDK.h>\n+\n+NS_ASSUME_NONNULL_BEGIN\n+\n+@interface MXRoomKeyEventContent : MXJSONModel\n+\n+/**\n+ The encryption algorithm the key in this event is to be used with\n+ */\n+@property (nonatomic) NSString *algorithm;\n+\n+/**\n+ The room where the key is used\n+ */\n+@property (nonatomic) NSString *roomId;\n+\n+/**\n+ The ID of the session that the key is for\n+ */\n+@property (nonatomic) NSString *sessionId;\n+\n+/**\n+ The key to be exchanged\n+ */\n+@property (nonatomic) NSString *sessionKey;\n+\n+/**\n+ MSC3061 Identifies keys that were sent when the room's visibility setting was set to `world_readable` or `shared`\n+ */\n+@property (nonatomic) BOOL sharedHistory;\n+\n+@end\n+\n+NS_ASSUME_NONNULL_END"
        },
        {
          "filename": "MatrixSDK/Crypto/KeySharing/Data/MXRoomKeyEventContent.m",
          "status": "added",
          "additions": 58,
          "deletions": 0,
          "patch": "@@ -0,0 +1,58 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+#import \"MXRoomKeyEventContent.h\"\n+\n+static NSString* const kJSONKeyAlgorithm = @\"algorithm\";\n+static NSString* const kJSONKeyRoomId = @\"room_id\";\n+static NSString* const kJSONKeySessionId = @\"session_id\";\n+static NSString* const kJSONKeySessionKey = @\"session_key\";\n+\n+@implementation MXRoomKeyEventContent\n+\n+#pragma mark - MXJSONModel\n+\n++ (id)modelFromJSON:(NSDictionary *)JSONDictionary\n+{\n+    MXRoomKeyEventContent *result = [MXRoomKeyEventContent new];\n+    MXJSONModelSetString(result.algorithm, JSONDictionary[kJSONKeyAlgorithm]);\n+    MXJSONModelSetString(result.roomId, JSONDictionary[kJSONKeyRoomId]);\n+    MXJSONModelSetString(result.sessionId, JSONDictionary[kJSONKeySessionId]);\n+    MXJSONModelSetString(result.sessionKey, JSONDictionary[kJSONKeySessionKey]);\n+    if (!result.algorithm || !result.roomId || !result.sessionId || !result.sessionKey)\n+    {\n+        MXLogError(@\"[MXRoomKeyEventContent] modelFromJSON: Key event is missing fields\");\n+        return nil;\n+    }\n+\n+    MXJSONModelSetBoolean(result.sharedHistory, JSONDictionary[kMXSharedHistoryKeyName]);\n+    \n+\n+    return result;\n+}\n+\n+- (NSDictionary *)JSONDictionary\n+{\n+    NSMutableDictionary *JSONDictionary = [NSMutableDictionary dictionary];\n+    JSONDictionary[kJSONKeyAlgorithm] = _algorithm;\n+    JSONDictionary[kJSONKeyRoomId] = _roomId;\n+    JSONDictionary[kJSONKeySessionId] = _sessionId;\n+    JSONDictionary[kJSONKeySessionKey] = _sessionKey;\n+    JSONDictionary[kMXSharedHistoryKeyName] = @(_sharedHistory);\n+    return JSONDictionary;\n+}\n+\n+@end"
        },
        {
          "filename": "MatrixSDK/Crypto/KeySharing/MXUnrequestedForwardedRoomKeyManager.swift",
          "status": "added",
          "additions": 153,
          "deletions": 0,
          "patch": "@@ -0,0 +1,153 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+\n+@objc public protocol MXUnrequestedForwardedRoomKeyManagerDelegate: AnyObject {\n+    func downloadDeviceKeys(userId: String, completion: @escaping (MXUsersDevicesMap<MXDeviceInfo>) -> Void)\n+    func acceptRoomKey(keyInfo: MXRoomKeyInfo)\n+}\n+\n+@objcMembers\n+public class MXUnrequestedForwardedRoomKeyManager: NSObject {\n+    private typealias RoomId = String\n+    private typealias UserId = String\n+    \n+    static let MaximumTimeInterval: TimeInterval = 10 * 60\n+    \n+    struct PendingKey {\n+        let info: MXRoomKeyInfo\n+        let date: Date\n+    }\n+    \n+    struct RoomInvite {\n+        let roomId: String\n+        let senderId: String\n+        let date: Date\n+    }\n+    \n+    public weak var delegate: MXUnrequestedForwardedRoomKeyManagerDelegate?\n+    \n+    private let dateProvider: MXDateProviding\n+    private var pendingKeys = [RoomId: [UserId: [PendingKey]]]()\n+    private var roomInvites = [RoomInvite]()\n+    \n+    override public init() {\n+        self.dateProvider = MXDateProvider()\n+    }\n+    \n+    init(dateProvider: MXDateProviding) {\n+        self.dateProvider = dateProvider\n+    }\n+    \n+    public func close() {\n+        pendingKeys = [:]\n+        roomInvites = []\n+    }\n+    \n+    public func addPendingKey(keyInfo: MXRoomKeyInfo, senderId: String, senderKey: String) {\n+        guard let delegate = delegate else {\n+            MXLog.error(\"[MXUnrequestedForwardedRoomKeyManager] addPendingKey: Delegate is not set\")\n+            return\n+        }\n+        \n+        // If just invited by the user we may not yet have their keys locally\n+        delegate.downloadDeviceKeys(userId: senderId) { [weak self] keys in\n+            guard let self = self else { return }\n+            \n+            guard let userId = self.matchingUserId(in: keys, userId: senderId, identityKey: senderKey) else {\n+                MXLog.error(\"[MXUnrequestedForwardedRoomKeyManager] addPendingKey: senderId does not match the claimed senderKey\")\n+                return\n+            }\n+            self.addPendingKey(keyInfo: keyInfo, confirmedSenderId: userId)\n+            self.processUnrequestedKeys()\n+        }\n+    }\n+    \n+    public func onRoomInvite(roomId: String, senderId: String) {\n+        roomInvites.append(\n+            .init(\n+                roomId: roomId,\n+                senderId: senderId,\n+                date: dateProvider.currentDate()\n+            )\n+        )\n+    }\n+    \n+    public func processUnrequestedKeys() {\n+        guard let delegate = delegate else {\n+            MXLog.error(\"[MXUnrequestedForwardedRoomKeyManager] processUnrequestedKeys: Delegate is not set\")\n+            return\n+        }\n+        \n+        let now = dateProvider.currentDate()\n+        \n+        roomInvites.removeAll {\n+            !$0.date.isWithin(timeInterval: Self.MaximumTimeInterval, of: now)\n+        }\n+        \n+        for invite in roomInvites {\n+            guard let roomKeys = pendingKeys[invite.roomId] else {\n+                continue\n+            }\n+            \n+            for (senderId, keys) in roomKeys {\n+                if invite.senderId == senderId {\n+                    for key in keys {\n+                        guard key.date.isWithin(timeInterval: Self.MaximumTimeInterval, of: invite.date) else {\n+                            continue\n+                        }\n+                        delegate.acceptRoomKey(keyInfo: key.info)\n+                    }\n+                }\n+            }\n+            \n+            pendingKeys[invite.roomId] = nil\n+        }\n+    }\n+    \n+    // MARK: - Private\n+    \n+    private func matchingUserId(in deviceKeys: MXUsersDevicesMap<MXDeviceInfo>, userId: String, identityKey: String) -> String? {\n+        return deviceKeys\n+            .objects(forUser: userId)?\n+            .first { $0.identityKey == identityKey }\n+            .flatMap { $0.userId }\n+    }\n+    \n+    private func addPendingKey(keyInfo: MXRoomKeyInfo, confirmedSenderId: String) {\n+        if pendingKeys[keyInfo.roomId] == nil {\n+            pendingKeys[keyInfo.roomId] = [:]\n+        }\n+        \n+        if pendingKeys[keyInfo.roomId]![confirmedSenderId] == nil {\n+            pendingKeys[keyInfo.roomId]![confirmedSenderId] = []\n+        }\n+        \n+        pendingKeys[keyInfo.roomId]![confirmedSenderId]!.append(\n+            .init(\n+                info: keyInfo,\n+                date: dateProvider.currentDate()\n+            )\n+        )\n+    }\n+}\n+\n+private extension Date {\n+    func isWithin(timeInterval: TimeInterval, of date: Date) -> Bool {\n+        return abs(self.timeIntervalSince(date)) < timeInterval\n+    }\n+}"
        },
        {
          "filename": "MatrixSDK/Crypto/KeySharing/Secret/MXSecretShareManager.m",
          "status": "modified",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -402,6 +402,12 @@ - (void)shareSecret:(NSString*)secret toRequest:(MXSecretShareRequest*)request\n \n - (void)handleSecretSendEvent:(MXEvent*)event\n {\n+    if (![self canAcceptSecretSendEvent:event])\n+    {\n+        MXLogDebug(@\"[MXSecretShareManager] handleSecretSendEvent: Rejecting unacceptable secret\");\n+        return;\n+    }\n+    \n     MXSecretShareSend *shareSend;\n     MXJSONModelSetMXJSONModel(shareSend, MXSecretShareSend, event.content);\n     if (!shareSend)\n@@ -428,4 +434,29 @@ - (void)handleSecretSendEvent:(MXEvent*)event\n     }\n }\n \n+- (BOOL)canAcceptSecretSendEvent:(MXEvent*)event\n+{\n+    // No need to download keys, after a verification we already forced download\n+    MXDeviceInfo *sendingDevice = [self.crypto.store deviceWithIdentityKey:event.senderKey];\n+    if (!sendingDevice)\n+    {\n+        MXLogError(@\"[MXSecretShareManager] canAcceptSecretSendEvent: Unknown sending device\");\n+        return NO;\n+    }\n+    \n+    if (![sendingDevice.userId isEqualToString:self.crypto.mxSession.myUserId])\n+    {\n+        MXLogDebug(@\"[MXSecretShareManager] canAcceptSecretSendEvent: Ignoring secret from another user\");\n+        return NO;\n+    }\n+    \n+    if (!sendingDevice.trustLevel.isVerified)\n+    {\n+        MXLogDebug(@\"[MXSecretShareManager] canAcceptSecretSendEvent: Ignoring secret from untrusted device\");\n+        return NO;\n+    }\n+    return YES;\n+}\n+\n+\n @end"
        },
        {
          "filename": "MatrixSDK/Crypto/MXCrypto.m",
          "status": "modified",
          "additions": 42,
          "deletions": 8,
          "patch": "@@ -76,7 +76,7 @@\n NSTimeInterval kMXCryptoUploadOneTimeKeysPeriod = 60.0; // one minute\n NSTimeInterval kMXCryptoMinForceSessionPeriod = 3600.0; // one hour\n \n-@interface MXCrypto ()\n+@interface MXCrypto () <MXUnrequestedForwardedRoomKeyManagerDelegate>\n {\n     // MXEncrypting instance for each room.\n     NSMutableDictionary<NSString*, id<MXEncrypting>> *roomEncryptors;\n@@ -107,6 +107,9 @@ @interface MXCrypto ()\n     // The manager for incoming room key requests\n     MXIncomingRoomKeyRequestManager *incomingRoomKeyRequestManager;\n     \n+    // The manager for unrequested m.forwarded_room_keys\n+    MXUnrequestedForwardedRoomKeyManager *unrequestedForwardedRoomKeyManager;\n+    \n     // The date of the last time we forced establishment\n     // of a new session for each user:device.\n     MXUsersDevicesMap<NSDate*> *lastNewSessionForcedDates;\n@@ -434,6 +437,9 @@ - (void)close:(BOOL)deleteStore\n \n         [self->outgoingRoomKeyRequestManager close];\n         self->outgoingRoomKeyRequestManager = nil;\n+        \n+        [self->unrequestedForwardedRoomKeyManager close];\n+        self->outgoingRoomKeyRequestManager = nil;\n \n         if (deleteStore)\n         {\n@@ -983,6 +989,7 @@ - (void)onSyncCompleted:(NSString *)oldSyncToken nextSyncToken:(NSString *)nextS\n         {\n             [self maybeUploadOneTimeKeys:nil failure:nil];\n             [self->incomingRoomKeyRequestManager processReceivedRoomKeyRequests];\n+            [self->unrequestedForwardedRoomKeyManager processUnrequestedKeys];\n         }\n     });\n \n@@ -2044,6 +2051,9 @@ - (instancetype)initWithMatrixSession:(MXSession*)matrixSession cryptoQueue:(dis\n                                          cryptoStore:_store];\n \n         incomingRoomKeyRequestManager = [[MXIncomingRoomKeyRequestManager alloc] initWithCrypto:self];\n+        \n+        unrequestedForwardedRoomKeyManager = [[MXUnrequestedForwardedRoomKeyManager alloc] init];\n+        unrequestedForwardedRoomKeyManager.delegate = self;\n \n         _keyVerificationManager = [[MXKeyVerificationManager alloc] initWithCrypto:self];\n         \n@@ -2583,6 +2593,11 @@ - (void)cancelRoomKeyRequest:(NSDictionary*)requestBody\n     [outgoingRoomKeyRequestManager cancelRoomKeyRequest:requestBody];\n }\n \n+- (void)handleUnrequestedRoomKeyInfo:(MXRoomKeyInfo *)keyInfo senderId:(NSString *)senderId senderKey:(NSString *)senderKey\n+{\n+    [unrequestedForwardedRoomKeyManager addPendingKeyWithKeyInfo:keyInfo senderId:senderId senderKey:senderKey];\n+}\n+\n - (NSDictionary*)buildMegolmKeyForwardingMessage:(NSString*)roomId senderKey:(NSString*)senderKey sessionId:(NSString*)sessionId  chainIndex:(NSNumber*)chainIndex\n {\n     NSDictionary *key = [self.olmDevice getInboundGroupSessionKey:roomId senderKey:senderKey sessionId:sessionId chainIndex:chainIndex];\n@@ -2802,16 +2817,16 @@ - (void)onCryptoEvent:(MXEvent*)event\n  */\n - (void)onRoomMembership:(MXEvent*)event roomState:(MXRoomState*)roomState\n {\n-    id<MXEncrypting> alg = roomEncryptors[event.roomId];\n-    if (!alg)\n-    {\n-        // No encrypting in this room\n-        return;\n-    }\n-\n     // Check whether we have to track the devices for this user.\n     BOOL shouldTrack = NO;\n     NSString *userId = event.stateKey;\n+    \n+    MXRoomMemberEventContent *content = [MXRoomMemberEventContent modelFromJSON:event.content];\n+    if ([userId isEqualToString:self.mxSession.credentials.userId] && [content.membership isEqualToString:kMXMembershipStringInvite])\n+    {\n+        [unrequestedForwardedRoomKeyManager onRoomInviteWithRoomId:event.roomId senderId:event.sender];\n+    }\n+    \n     MXRoomMember *member = [roomState.members memberWithUserId:userId];\n     if (member)\n     {\n@@ -3264,6 +3279,25 @@ - (void)markOlmSessionForUnwedgingInEvent:(MXEvent*)event\n     }];\n }\n \n+#pragma mark - MXUnrequestedForwardedRoomKeyManagerDelegate\n+\n+- (void)downloadDeviceKeysWithUserId:(NSString *)userId completion:(void (^)(MXUsersDevicesMap<MXDeviceInfo *> *))completion\n+{\n+    [self downloadKeys:@[userId] forceDownload:YES success:^(MXUsersDevicesMap<MXDeviceInfo *> *usersDevicesInfoMap, NSDictionary<NSString *,MXCrossSigningInfo *> *crossSigningKeysMap) {\n+        completion(usersDevicesInfoMap);\n+    } failure:^(NSError *error) {\n+        MXLogError(@\"[MXCrypto]: Failed downloading keys for key forward manager\");\n+        completion([[MXUsersDevicesMap alloc] init]);\n+    }];\n+}\n+\n+- (void)acceptRoomKeyWithKeyInfo:(MXRoomKeyInfo *)keyInfo\n+{\n+    id<MXDecrypting> decryptor = [self getRoomDecryptor:keyInfo.roomId algorithm:keyInfo.algorithm];\n+    MXRoomKeyResult *key = [[MXRoomKeyResult alloc] initWithType:MXRoomKeyTypeUnsafe info:keyInfo];\n+    [decryptor onRoomKey:key];\n+}\n+\n #endif\n \n @end"
        },
        {
          "filename": "MatrixSDK/Crypto/MXCrypto_Private.h",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -33,6 +33,8 @@\n \n #import \"MXCrypto.h\"\n \n+@class MXRoomKeyInfo;\n+\n /**\n  The `MXCrypto_Private` extension exposes internal operations.\n  \n@@ -224,6 +226,15 @@\n // Create a message to forward a megolm session\n - (NSDictionary*)buildMegolmKeyForwardingMessage:(NSString*)roomId senderKey:(NSString*)senderKey sessionId:(NSString*)sessionId chainIndex:(NSNumber*)chainIndex;\n \n+/**\n+ Handle forwarded room key that was not requested by this device\n+ \n+ @param keyInfo details about the key\n+ @param senderId userId of the person who sent us the key\n+ @param senderKey identity of the person who sent us the room key\n+ */\n+- (void)handleUnrequestedRoomKeyInfo:(MXRoomKeyInfo *)keyInfo senderId:(NSString *)senderId senderKey:(NSString *)senderKey;\n+\n @end\n \n #endif"
        },
        {
          "filename": "MatrixSDK/Crypto/MXOlmDevice.h",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -241,7 +241,8 @@ Determine if an incoming messages is a prekey message matching an existing sessi\n   forwardingCurve25519KeyChain:(NSArray<NSString *> *)forwardingCurve25519KeyChain\n                    keysClaimed:(NSDictionary<NSString*, NSString*>*)keysClaimed\n                   exportFormat:(BOOL)exportFormat\n-                 sharedHistory:(BOOL)sharedHistory;\n+                 sharedHistory:(BOOL)sharedHistory\n+                     untrusted:(BOOL)untrusted;\n \n /**\n  Add previously-exported inbound group sessions to the session store."
        },
        {
          "filename": "MatrixSDK/Crypto/MXOlmDevice.m",
          "status": "modified",
          "additions": 48,
          "deletions": 6,
          "patch": "@@ -351,7 +351,8 @@ - (BOOL)addInboundGroupSession:(NSString*)sessionId\n   forwardingCurve25519KeyChain:(NSArray<NSString *> *)forwardingCurve25519KeyChain\n                    keysClaimed:(NSDictionary<NSString*, NSString*>*)keysClaimed\n                   exportFormat:(BOOL)exportFormat\n-                 sharedHistory:(BOOL)sharedHistory;\n+                 sharedHistory:(BOOL)sharedHistory\n+                     untrusted:(BOOL)untrusted\n {\n     MXOlmInboundGroupSession *session;\n     if (exportFormat)\n@@ -372,13 +373,29 @@ - (BOOL)addInboundGroupSession:(NSString*)sessionId\n     if (existingSession)\n     {\n         // If we already have this session, consider updating it\n-        MXLogDebug(@\"[MXOlmDevice] addInboundGroupSession: Update for megolm session %@|%@\", senderKey, sessionId);\n+        MXLogDebug(@\"[MXOlmDevice] addInboundGroupSession: Considering updates for megolm session %@|%@\", senderKey, sessionId);\n \n-        // If our existing session is better, we keep it\n-        if (existingSession.session.firstKnownIndex <= session.session.firstKnownIndex)\n+        BOOL isExistingSessionBetter = existingSession.session.firstKnownIndex <= session.session.firstKnownIndex;\n+        if (isExistingSessionBetter)\n         {\n-            MXLogDebug(@\"[MXOlmDevice] addInboundGroupSession: Skip it. The index of the incoming session is higher (%@ vs %@)\", @(session.session.firstKnownIndex), @(existingSession.session.firstKnownIndex));\n-            return NO;\n+            BOOL isNewSessionSafer = existingSession.isUntrusted && !session.isUntrusted;\n+            if (!isNewSessionSafer)\n+            {\n+                MXLogDebug(@\"[MXOlmDevice] addInboundGroupSession: Skip it. The index of the incoming session is higher (%@ vs %@)\", @(session.session.firstKnownIndex), @(existingSession.session.firstKnownIndex));\n+                return NO;\n+            }\n+            \n+            if ([self connectsSession1:existingSession session2:session])\n+            {\n+                MXLogDebug(@\"[MXOlmDevice] addInboundGroupSession: Skipping new session, and upgrading the safety of existing session\");\n+                [self upgradeSafetyForSession:existingSession];\n+                return NO;\n+            }\n+            else\n+            {\n+                MXLogWarning(@\"[MXOlmDevice] addInboundGroupSession: Recieved a safer but disconnected key, which will override the existing unsafe key\");\n+                existingSession = nil;\n+            }\n         }\n     }\n \n@@ -394,6 +411,7 @@ - (BOOL)addInboundGroupSession:(NSString*)sessionId\n     session.roomId = roomId;\n     session.keysClaimed = keysClaimed;\n     session.forwardingCurve25519KeyChain = forwardingCurve25519KeyChain;\n+    session.untrusted = untrusted;\n     \n     // If we already have a session stored, the sharedHistory flag will not be overwritten\n     if (!existingSession && MXSDKOptions.sharedInstance.enableRoomSharedHistoryOnInvite)\n@@ -406,6 +424,30 @@ - (BOOL)addInboundGroupSession:(NSString*)sessionId\n     return YES;\n }\n \n+- (void)upgradeSafetyForSession:(MXOlmInboundGroupSession *)session\n+{\n+    [self.store performSessionOperationWithGroupSessionWithId:session.session.sessionIdentifier senderKey:session.senderKey block:^(MXOlmInboundGroupSession *inboundGroupSession) {\n+        inboundGroupSession.untrusted = NO;\n+    }];\n+    if (MXSDKOptions.sharedInstance.enableGroupSessionCache)\n+    {\n+        @synchronized (self.inboundGroupSessionCache)\n+        {\n+            session.untrusted = NO;\n+            [self.inboundGroupSessionCache put:session.session.sessionIdentifier object:session];\n+        }\n+    }\n+}\n+\n+- (BOOL)connectsSession1:(MXOlmInboundGroupSession *)session1 session2:(MXOlmInboundGroupSession *)session2\n+{\n+    // `connects` function will be moved to libolm in the future to avoid having to export the session\n+    NSUInteger lowestCommonIndex = MAX(session1.session.firstKnownIndex, session2.session.firstKnownIndex);\n+    MXMegolmSessionData *export1 = [session1 exportSessionDataAtMessageIndex:lowestCommonIndex];\n+    MXMegolmSessionData *export2 = [session2 exportSessionDataAtMessageIndex:lowestCommonIndex];\n+    return [export1.sessionKey isEqualToString:export2.sessionKey];\n+}\n+\n - (NSArray<MXOlmInboundGroupSession *>*)importInboundGroupSessions:(NSArray<MXMegolmSessionData *>*)inboundGroupSessionsData;\n {\n     NSMutableArray<MXOlmInboundGroupSession *> *sessions = [NSMutableArray arrayWithCapacity:inboundGroupSessionsData.count];"
        },
        {
          "filename": "MatrixSDK/Crypto/RoomKeys/MXRoomKeyInfo.swift",
          "status": "added",
          "additions": 90,
          "deletions": 0,
          "patch": "@@ -0,0 +1,90 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+\n+/// Domain object representing a room key and its parameters\n+@objcMembers\n+public class MXRoomKeyInfo: NSObject {\n+    public let algorithm: String\n+    public let sessionId: String\n+    public let sessionKey: String\n+    public let roomId: String\n+    public let senderKey: String\n+    public let forwardingKeyChain: [String]?\n+    public let keysClaimed: [String: String]\n+    public let exportFormat: Bool\n+    public let sharedHistory: Bool\n+    \n+    public init(\n+        algorithm: String,\n+        sessionId: String,\n+        sessionKey: String,\n+        roomId: String,\n+        senderKey: String,\n+        forwardingKeyChain: [String]?,\n+        keysClaimed: [String: String],\n+        exportFormat: Bool,\n+        sharedHistory: Bool\n+    ) {\n+        self.algorithm = algorithm\n+        self.sessionId = sessionId\n+        self.sessionKey = sessionKey\n+        self.roomId = roomId\n+        self.senderKey = senderKey\n+        self.forwardingKeyChain = forwardingKeyChain\n+        self.keysClaimed = keysClaimed\n+        self.exportFormat = exportFormat\n+        self.sharedHistory = sharedHistory\n+        super.init()\n+    }\n+}\n+\n+extension MXRoomKeyInfo {\n+    convenience init?(roomKey: MXRoomKeyEventContent, event: MXEvent) {\n+        guard let senderKey = event.senderKey, let keysClaimed = event.keysClaimed as? [String: String] else {\n+            return nil\n+        }\n+        \n+        self.init(\n+            algorithm: roomKey.algorithm,\n+            sessionId: roomKey.sessionId,\n+            sessionKey: roomKey.sessionKey,\n+            roomId: roomKey.roomId,\n+            senderKey: senderKey,\n+            forwardingKeyChain: nil,\n+            keysClaimed: keysClaimed,\n+            exportFormat: false,\n+            sharedHistory: roomKey.sharedHistory\n+        )\n+    }\n+}\n+\n+extension MXRoomKeyInfo {\n+    convenience init(forwardedRoomKey: MXForwardedRoomKeyEventContent) {\n+        self.init(\n+            algorithm: forwardedRoomKey.algorithm,\n+            sessionId: forwardedRoomKey.sessionId,\n+            sessionKey: forwardedRoomKey.sessionKey,\n+            roomId: forwardedRoomKey.roomId,\n+            senderKey: forwardedRoomKey.senderKey,\n+            forwardingKeyChain: forwardedRoomKey.forwardingCurve25519KeyChain,\n+            keysClaimed: [\"ed25519\": forwardedRoomKey.senderClaimedEd25519Key],\n+            exportFormat: true,\n+            sharedHistory: forwardedRoomKey.sharedHistory\n+        )\n+    }\n+}"
        },
        {
          "filename": "MatrixSDK/Crypto/RoomKeys/MXRoomKeyInfoFactory.swift",
          "status": "added",
          "additions": 100,
          "deletions": 0,
          "patch": "@@ -0,0 +1,100 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+\n+@objcMembers\n+public class MXRoomKeyInfoFactory: NSObject {\n+    private let myUserId: String\n+    private let store: MXCryptoStore\n+    private let log = MXNamedLog(name: \"MXRoomKeyFactory\")\n+    \n+    public init(myUserId: String, store: MXCryptoStore) {\n+        self.myUserId = myUserId\n+        self.store = store\n+    }\n+    \n+    public func roomKey(for event: MXEvent) -> MXRoomKeyResult? {\n+        if event.eventType == .roomKey {\n+            return roomKeyEventInfo(for: event)\n+        } else if event.eventType == .roomForwardedKey {\n+            return forwardedRoomKeyEventInfo(for: event)\n+        } else {\n+            log.error(\"Unknown event type\", context: event.eventType)\n+            return nil\n+        }\n+    }\n+    \n+    private func roomKeyEventInfo(for event: MXEvent) -> MXRoomKeyResult? {\n+        guard\n+            let content = MXRoomKeyEventContent(fromJSON: event.content),\n+            let info = MXRoomKeyInfo(roomKey: content, event: event)\n+        else {\n+            log.error(\"Invalid room key\")\n+            return nil\n+        }\n+        \n+        return .init(type: .safe, info: info)\n+    }\n+    \n+    private func forwardedRoomKeyEventInfo(for event: MXEvent) -> MXRoomKeyResult? {\n+        guard let eventSenderKey = event.senderKey else {\n+            log.error(\"Unknown event sender\")\n+            return nil\n+        }\n+        \n+        guard let content = MXForwardedRoomKeyEventContent(fromJSON: event.content) else {\n+            log.error(\"Invalid forwarded key\")\n+            return nil\n+        }\n+        \n+        content.forwardingCurve25519KeyChain += [eventSenderKey]\n+\n+        return .init(\n+            type: keyType(for: content, senderKey: eventSenderKey),\n+            info: .init(forwardedRoomKey: content)\n+        )\n+    }\n+    \n+    private func keyType(for content: MXForwardedRoomKeyEventContent, senderKey: String) -> MXRoomKeyType {\n+        if !hasPendingRequest(for: content) {\n+            log.debug(\"Key was not requested\")\n+            return .unrequested\n+        } else if isMyVerifiedDevice(identityKey: senderKey) {\n+            return .safe\n+        } else {\n+            log.debug(\"Key forward is not from my verified device\")\n+            return .unsafe\n+        }\n+    }\n+    \n+    private func isMyVerifiedDevice(identityKey: String) -> Bool {\n+        guard let device = store.device(withIdentityKey: identityKey) else {\n+            return false\n+        }\n+        return device.userId == myUserId && device.trustLevel.isVerified\n+    }\n+    \n+    private func hasPendingRequest(for content: MXForwardedRoomKeyEventContent) -> Bool {\n+        let request = store.outgoingRoomKeyRequest(withRequestBody: [\n+            \"room_id\": content.roomId,\n+            \"algorithm\": content.algorithm,\n+            \"sender_key\": content.senderKey,\n+            \"session_id\": content.sessionId\n+        ])\n+        return request != nil\n+    }\n+}"
        },
        {
          "filename": "MatrixSDK/Crypto/RoomKeys/MXRoomKeyResult.swift",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+\n+@objc public enum MXRoomKeyType: Int {\n+    case safe\n+    case unsafe\n+    case unrequested\n+}\n+\n+@objcMembers\n+public class MXRoomKeyResult: NSObject {\n+    public let type: MXRoomKeyType\n+    public let info: MXRoomKeyInfo\n+    \n+    public init(type: MXRoomKeyType, info: MXRoomKeyInfo) {\n+        self.type = type\n+        self.info = info\n+    }\n+}"
        },
        {
          "filename": "MatrixSDK/Crypto/Verification/Transactions/SAS/MXSASTransaction.m",
          "status": "modified",
          "additions": 9,
          "deletions": 1,
          "patch": "@@ -363,6 +363,8 @@ - (void)verifyMacs\n \n         __block MXTransactionCancelCode *cancelCode;\n         dispatch_group_t group = dispatch_group_create();\n+        \n+        MXCrossSigningKey *otherUserMasterKeys= [self.manager.crypto crossSigningKeysForUser:self.otherDevice.userId].masterKeys;\n \n         for (NSString *keyFullId in self.theirMac.mac)\n         {\n@@ -372,6 +374,13 @@ - (void)verifyMacs\n             MXDeviceInfo *device = [self.manager.crypto deviceWithDeviceId:key.keyId ofUser:self.otherDevice.userId];\n             if (device)\n             {\n+                if ([device.deviceId isEqualToString:otherUserMasterKeys.keys])\n+                {\n+                    MXLogWarning(@\"[MXKeyVerification][MXSASTransaction] verifyMacs: Device id should not be the same as master key\");\n+                    cancelCode = MXTransactionCancelCode.invalidMessage;\n+                    break;\n+                }\n+                \n                 if ([key.value isEqualToString:[self macUsingAgreedMethod:device.keys[keyFullId]\n                                                                      info:[NSString stringWithFormat:@\"%@%@\", baseInfo, keyFullId]]])\n                 {\n@@ -398,7 +407,6 @@ - (void)verifyMacs\n             else\n             {\n                 // This key is maybe a cross-signing master key\n-                MXCrossSigningKey *otherUserMasterKeys= [self.manager.crypto crossSigningKeysForUser:self.otherDevice.userId].masterKeys;\n                 if (otherUserMasterKeys)\n                 {\n                     // Check MAC with user's MSK keys"
        },
        {
          "filename": "MatrixSDK/MXSession.m",
          "status": "modified",
          "additions": 12,
          "deletions": 3,
          "patch": "@@ -1964,16 +1964,25 @@ - (void)updateSummaryDirectUserIdForRooms:(NSSet<NSString*> *)roomIds\n \n - (void)handleToDeviceEvents:(NSArray<MXEvent *> *)events  onComplete:(void (^)(void))onComplete\n {\n-    if (events.count == 0)\n+    NSMutableArray *supportedEvents = [NSMutableArray arrayWithCapacity:events.count];\n+    for (MXEvent *event in events)\n+    {\n+        if ([MXTools isSupportedToDeviceEvent:event])\n+        {\n+            [supportedEvents addObject:event];\n+        }\n+    }\n+\n+    if (supportedEvents.count == 0)\n     {\n         onComplete();\n         return;\n     }\n     \n-    [self decryptEvents:events inTimeline:nil onComplete:^(NSArray<MXEvent *> *failedEvents) {\n+    [self decryptEvents:supportedEvents inTimeline:nil onComplete:^(NSArray<MXEvent *> *failedEvents) {\n         dispatch_group_t dispatchGroup = dispatch_group_create();\n         \n-        for (MXEvent *event in events)\n+        for (MXEvent *event in supportedEvents)\n         {\n             if (!event.decryptionError)\n             {"
        },
        {
          "filename": "MatrixSDK/MatrixSDK.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -171,6 +171,8 @@ FOUNDATION_EXPORT NSString *MatrixSDKVersion;\n #import \"MXCachedSyncResponse.h\"\n #import \"MXBackgroundCryptoStore.h\"\n #import \"MXSharedHistoryKeyService.h\"\n+#import \"MXRoomKeyEventContent.h\"\n+#import \"MXForwardedRoomKeyEventContent.h\"\n \n //  Sync response models\n #import \"MXSyncResponse.h\""
        },
        {
          "filename": "MatrixSDK/Utils/Categories/Dictionary.swift",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+\n+internal extension Dictionary {\n+    func adding(key: Key, value: Value) -> [Key: Value] {\n+        var dict = self\n+        dict[key] = value\n+        return dict\n+    }\n+    \n+    func removing(key: Key) -> [Key: Value] {\n+        var dict = self\n+        dict[key] = nil\n+        return dict\n+    }\n+}"
        },
        {
          "filename": "MatrixSDK/Utils/MXDateProvider.swift",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+\n+protocol MXDateProviding {\n+    func currentDate() -> Date\n+}\n+\n+struct MXDateProvider: MXDateProviding {\n+    func currentDate() -> Date {\n+        Date()\n+    }\n+}"
        },
        {
          "filename": "MatrixSDK/Utils/MXLRUCache.m",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -149,6 +149,11 @@ - (void)put:(NSString*)key object:(NSObject*)object\n                 [cachedObjects addObject:item];\n                 [cachedKeys addObject:key];\n             }\n+            else\n+            {\n+                MXLRUCacheItem* item = [cachedObjects objectAtIndex:pos];\n+                item.object = object;\n+            }\n         }\n     }\n }"
        },
        {
          "filename": "MatrixSDK/Utils/MXTools.swift",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -44,4 +44,33 @@ public extension MXTools {\n         }\n         return urlString\n     }\n+\n+    @objc\n+    /// Checks whether a given to-device event is supported or not.\n+    /// - Parameter event: Event to be checked\n+    /// - Returns: `true` if the event is supported, otherwise `false`\n+    static func isSupportedToDeviceEvent(_ event: MXEvent) -> Bool {\n+        if event.isEncrypted {\n+            // only support OLM encrypted events\n+            let algorithm = event.wireContent[\"algorithm\"] as? String\n+            guard algorithm == kMXCryptoOlmAlgorithm else {\n+                MXLog.debug(\"[MXTools] isSupportedToDeviceEvent: not supported event encrypted with other than OLM algorithm: \\(String(describing: algorithm))\")\n+                return false\n+            }\n+        } else {\n+            // define unsupported plain event types\n+            let unsupportedPlainEvents = Set([\n+                MXEventType.roomKey.identifier,\n+                MXEventType.roomForwardedKey.identifier,\n+                MXEventType.secretSend.identifier\n+            ])\n+            // make sure that the event type is supported\n+            if unsupportedPlainEvents.contains(event.type) {\n+                MXLog.debug(\"[MXTools] isSupportedToDeviceEvent: not supported plain event with type: \\(String(describing: event.type))\")\n+                return false\n+            }\n+        }\n+\n+        return true\n+    }\n }"
        },
        {
          "filename": "MatrixSDKTests/Crypto/Algorithms/Megolm/MXMegolmDecryptionUnitTests.swift",
          "status": "modified",
          "additions": 5,
          "deletions": 27,
          "patch": "@@ -35,7 +35,8 @@ class MXMegolmDecryptionUnitTests: XCTestCase {\n             forwardingCurve25519KeyChain: [String]!,\n             keysClaimed: [String : String]!,\n             exportFormat: Bool,\n-            sharedHistory: Bool\n+            sharedHistory: Bool,\n+            untrusted: Bool\n         ) -> Bool {\n             sessions.append(\n                 .init(sharedHistory: sharedHistory)\n@@ -137,7 +138,9 @@ class MXMegolmDecryptionUnitTests: XCTestCase {\n         session.historyVisibility = kMXRoomHistoryVisibilityWorldReadable\n         \n         for (eventValue, expectedValue) in eventToExpectation {\n-            let event = makeRoomKeyEvent(sharedHistory: eventValue)\n+            let event = MXEvent.roomKeyFixture(\n+                sharedHistory: eventValue\n+            )\n             device.sessions = []\n             \n             decryption.onRoomKeyEvent(event)\n@@ -213,29 +216,4 @@ class MXMegolmDecryptionUnitTests: XCTestCase {\n             XCTAssertEqual(hasSharedHistory, expectedValue)\n         }\n     }\n-    \n-    // MARK: - Helpers\n-    \n-    /// Create a room key event with some random but valid data that can be used to create a new inbound session.\n-    private func makeRoomKeyEvent(sharedHistory: Bool? = nil) -> MXEvent? {\n-        let event = MXEvent(fromJSON: [\n-            \"sender_key\": senderKey,\n-        ])\n-        \n-        var content: [String: Any] = [\n-            \"room_id\": roomId1,\n-            \"session_id\": sessionId1,\n-            \"session_key\": \"123\",\n-            \"algorithm\": \"456\",\n-        ]\n-        if let sharedHistory = sharedHistory {\n-            content[\"org.matrix.msc3061.shared_history\"] = sharedHistory\n-        }\n-        \n-        let result = MXEventDecryptionResult()\n-        result.senderCurve25519Key = \"XYZ\"\n-        result.clearEvent = [\"content\": content]\n-        event?.setClearData(result)\n-        return event\n-    }\n }"
        },
        {
          "filename": "MatrixSDKTests/Crypto/Data/Store/MXMemoryCryptoStore.swift",
          "status": "added",
          "additions": 511,
          "deletions": 0,
          "patch": "@@ -0,0 +1,511 @@\n+//\n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+import OLMKit\n+\n+public class MXMemoryCryptoStore: NSObject, MXCryptoStore {\n+\n+    private static var stores: [MXCredentials: MXMemoryCryptoStore] = [:]\n+\n+    private let credentials: MXCredentials\n+    private var storeAccount: Account?\n+    private var devices: [String: [MXDeviceInfo]] = [:]\n+    private var algorithms: [String: RoomAlgorithm] = [:]\n+    private var inboundSessions: [InboundSession] = []\n+    private var outboundSessions: [String: MXOlmOutboundGroupSession] = [:]\n+    private var secrets: [String: String] = [:]\n+    private var incomingRoomKeyRequestsMap: [String: MXIncomingRoomKeyRequest] = [:]\n+    private var outgoingRoomKeyRequests: [String: MXOutgoingRoomKeyRequest] = [:]\n+    private var olmSessions: [OlmSessionMapKey: MXOlmSession] = [:]\n+    private var crossSigningKeysMap: [String: MXCrossSigningInfo] = [:]\n+    private var sharedOutboundSessions: [SharedOutboundSession] = []\n+\n+    // MARK: - MXCryptoStore\n+\n+    public required init!(credentials: MXCredentials!) {\n+        self.credentials = credentials\n+        storeAccount = Account()\n+        storeAccount?.userId = credentials.userId\n+        storeAccount?.deviceId = credentials.deviceId\n+        storeAccount?.cryptoVersion = MXCryptoVersion(rawValue: MXCryptoVersion.versionCount.rawValue - 1) ?? .versionUndefined\n+        super.init()\n+    }\n+\n+    public static func hasData(for credentials: MXCredentials!) -> Bool {\n+        stores[credentials] != nil\n+    }\n+\n+    public static func createStore(with credentials: MXCredentials!) -> Self! {\n+        if let existingStore = stores[credentials] as? Self {\n+            return existingStore\n+        }\n+        if let newStore = Self(credentials: credentials) {\n+            stores[credentials] = newStore\n+            return newStore\n+        }\n+        return nil\n+    }\n+\n+    public static func delete(with credentials: MXCredentials!) {\n+        stores.removeValue(forKey: credentials)\n+    }\n+\n+    public static func deleteAllStores() {\n+        stores.removeAll()\n+    }\n+\n+    public static func deleteReadonlyStore(with credentials: MXCredentials!) {\n+        // no-op\n+    }\n+\n+    public func open(_ onComplete: (() -> Void)!, failure: ((Error?) -> Void)!) {\n+        onComplete?()\n+    }\n+\n+    // MARK: - Device ID\n+\n+    public func storeDeviceId(_ deviceId: String!) {\n+        storeAccount?.deviceId = deviceId\n+    }\n+\n+    public func deviceId() -> String! {\n+        storeAccount?.deviceId\n+    }\n+\n+    // MARK: - Account\n+\n+    public func setAccount(_ account: OLMAccount!) {\n+        storeAccount?.olmAccount = account\n+    }\n+\n+    public func account() -> OLMAccount! {\n+        storeAccount?.olmAccount\n+    }\n+\n+    public func performAccountOperation(_ block: ((OLMAccount?) -> Void)!) {\n+        block?(storeAccount?.olmAccount)\n+    }\n+\n+    // MARK: - Device Sync Token\n+\n+    public func storeDeviceSyncToken(_ deviceSyncToken: String!) {\n+        storeAccount?.deviceSyncToken = deviceSyncToken\n+    }\n+\n+    public func deviceSyncToken() -> String! {\n+        storeAccount?.deviceSyncToken\n+    }\n+\n+    // MARK: - Devices\n+\n+    public func storeDevice(forUser userId: String!, device: MXDeviceInfo!) {\n+        if devices[userId] == nil {\n+            devices[userId] = []\n+        }\n+        devices[userId]?.append(device)\n+    }\n+\n+    public func device(withDeviceId deviceId: String!, forUser userId: String!) -> MXDeviceInfo! {\n+        devices[userId]?.first { $0.deviceId == deviceId }\n+    }\n+\n+    public func device(withIdentityKey identityKey: String!) -> MXDeviceInfo! {\n+        Array(devices.values).flatMap { $0 }.first { $0.identityKey == identityKey }\n+    }\n+\n+    public func storeDevices(forUser userId: String!, devices: [String : MXDeviceInfo]!) {\n+        if self.devices[userId] != nil {\n+            // Reset all previously stored devices for this user\n+            self.devices.removeValue(forKey: userId)\n+        }\n+\n+        self.devices[userId] = Array(devices.values)\n+    }\n+\n+    public func devices(forUser userId: String!) -> [String : MXDeviceInfo]! {\n+        let devices = devices[userId] ?? []\n+\n+        var result: [String: MXDeviceInfo] = [:]\n+\n+        for device in devices {\n+            result[device.deviceId] = device\n+        }\n+\n+        return result\n+    }\n+\n+    // MARK: - Device Tracking Status\n+\n+    public func deviceTrackingStatus() -> [String : NSNumber]! {\n+        storeAccount?.deviceTrackingStatus\n+    }\n+\n+    public func storeDeviceTrackingStatus(_ statusMap: [String : NSNumber]!) {\n+        storeAccount?.deviceTrackingStatus = statusMap\n+    }\n+\n+    // MARK: - Cross Signing Keys\n+\n+    public func storeCrossSigningKeys(_ crossSigningInfo: MXCrossSigningInfo!) {\n+        crossSigningKeysMap[crossSigningInfo.userId] = crossSigningInfo\n+    }\n+\n+    public func crossSigningKeys(forUser userId: String!) -> MXCrossSigningInfo! {\n+        crossSigningKeysMap[userId]\n+    }\n+\n+    public func crossSigningKeys() -> [MXCrossSigningInfo]! {\n+        Array(crossSigningKeysMap.values)\n+    }\n+\n+    // MARK: - Room Algorithm\n+\n+    public func storeAlgorithm(forRoom roomId: String!, algorithm: String!) {\n+        algorithms[roomId] = RoomAlgorithm(algorithm: algorithm)\n+    }\n+\n+    public func algorithm(forRoom roomId: String!) -> String! {\n+        algorithms[roomId]?.algorithm\n+    }\n+\n+    // MARK: - OLM Session\n+\n+    public func store(_ session: MXOlmSession!, forDevice deviceKey: String!) {\n+        let key = OlmSessionMapKey(sessionId: session.session.sessionIdentifier(), deviceKey: deviceKey)\n+        olmSessions[key] = session\n+    }\n+\n+    public func session(withDevice deviceKey: String!, andSessionId sessionId: String!) -> MXOlmSession! {\n+        let key = OlmSessionMapKey(sessionId: sessionId, deviceKey: deviceKey)\n+        return olmSessions[key]\n+    }\n+\n+    public func performSessionOperation(withDevice deviceKey: String!, andSessionId sessionId: String!, block: ((MXOlmSession?) -> Void)!) {\n+        let session = session(withDevice: deviceKey, andSessionId: sessionId)\n+        block?(session)\n+    }\n+\n+    public func sessions(withDevice deviceKey: String!) -> [MXOlmSession]! {\n+        Array(olmSessions.filter { $0.key.deviceKey == deviceKey }.values)\n+    }\n+\n+    // MARK: - Inbound Group Sessions\n+\n+    public func store(_ sessions: [MXOlmInboundGroupSession]!) {\n+        inboundSessions.append(contentsOf: sessions.map { InboundSession(session: $0) } )\n+    }\n+\n+    public func inboundGroupSession(withId sessionId: String!, andSenderKey senderKey: String!) -> MXOlmInboundGroupSession! {\n+        inboundSessions.first { $0.sessionId == sessionId && $0.session.senderKey == senderKey }?.session\n+    }\n+\n+    public func performSessionOperationWithGroupSession(withId sessionId: String!, senderKey: String!, block: ((MXOlmInboundGroupSession?) -> Void)!) {\n+        let session = inboundGroupSession(withId: sessionId, andSenderKey: senderKey)\n+        block?(session)\n+    }\n+\n+    public func inboundGroupSessions() -> [MXOlmInboundGroupSession]! {\n+        inboundSessions.map { $0.session }\n+    }\n+\n+    public func inboundGroupSessions(withSessionId sessionId: String!) -> [MXOlmInboundGroupSession]! {\n+        inboundSessions.filter { $0.sessionId == sessionId }.map { $0.session }\n+    }\n+\n+    public func removeInboundGroupSession(withId sessionId: String!, andSenderKey senderKey: String!) {\n+        inboundSessions.removeAll { $0.sessionId == sessionId && $0.session.senderKey == senderKey }\n+    }\n+\n+    // MARK: - Outbound Group Sessions\n+\n+    public func store(_ session: OLMOutboundGroupSession!, withRoomId roomId: String!) -> MXOlmOutboundGroupSession! {\n+        let creationTime: TimeInterval\n+\n+        if let existingSession = outboundSessions[roomId],\n+           existingSession.sessionId == session.sessionIdentifier() {\n+            // Update the existing one\n+            creationTime = existingSession.creationTime\n+        } else {\n+            creationTime = Date().timeIntervalSince1970\n+        }\n+\n+        if let newSession = MXOlmOutboundGroupSession(session: session, roomId: roomId, creationTime: creationTime) {\n+            outboundSessions[roomId] = newSession\n+            return newSession\n+        }\n+\n+        return nil\n+    }\n+\n+    public func outboundGroupSession(withRoomId roomId: String!) -> MXOlmOutboundGroupSession! {\n+        outboundSessions[roomId]\n+    }\n+\n+    public func outboundGroupSessions() -> [MXOlmOutboundGroupSession]! {\n+        Array(outboundSessions.values)\n+    }\n+\n+    public func removeOutboundGroupSession(withRoomId roomId: String!) {\n+        outboundSessions.removeValue(forKey: roomId)\n+    }\n+\n+    // MARK: - Shared Devices\n+\n+    public func storeSharedDevices(_ devices: MXUsersDevicesMap<NSNumber>!, messageIndex: UInt, forOutboundGroupSessionInRoomWithId roomId: String!, sessionId: String!) {\n+        for userId in devices.userIds() {\n+            for deviceId in devices.deviceIds(forUser: userId) {\n+                guard let device = device(withDeviceId: deviceId, forUser: userId) else {\n+                    continue\n+                }\n+\n+                let session = SharedOutboundSession(roomId: roomId, sessionId: sessionId, device: device, messageIndex: messageIndex)\n+                sharedOutboundSessions.append(session)\n+            }\n+        }\n+    }\n+\n+    public func sharedDevicesForOutboundGroupSessionInRoom(withId roomId: String!, sessionId: String!) -> MXUsersDevicesMap<NSNumber>! {\n+        let result = MXUsersDevicesMap<NSNumber>()\n+\n+        let sessions = sharedOutboundSessions.filter { $0.roomId == roomId && $0.sessionId == sessionId }\n+\n+        for session in sessions {\n+            result.setObject(NSNumber(value: session.messageIndex),\n+                             forUser: session.device.userId,\n+                             andDevice: session.device.deviceId)\n+        }\n+\n+        return result\n+    }\n+\n+    public func messageIndexForSharedDeviceInRoom(withId roomId: String!, sessionId: String!, userId: String!, deviceId: String!) -> NSNumber! {\n+        guard let index = sharedOutboundSessions.first(where: { $0.roomId == roomId\n+            && $0.sessionId == sessionId\n+            && $0.device.deviceId == deviceId })?.messageIndex else {\n+            return nil\n+        }\n+        return NSNumber(value: index)\n+    }\n+\n+    // MARK: - Backup Markers\n+\n+    public var backupVersion: String! {\n+        get {\n+            storeAccount?.backupVersion\n+        } set {\n+            storeAccount?.backupVersion = newValue\n+        }\n+    }\n+\n+    public func resetBackupMarkers() {\n+        inboundSessions.forEach { $0.backedUp = false }\n+    }\n+\n+    public func markBackupDone(for sessions: [MXOlmInboundGroupSession]!) {\n+        for session in sessions {\n+            inboundSessions.filter({ $0.sessionId == session.session.sessionIdentifier() }).forEach { $0.backedUp = true }\n+        }\n+    }\n+\n+    public func inboundGroupSessions(toBackup limit: UInt) -> [MXOlmInboundGroupSession]! {\n+        let toBackup = inboundSessions.filter { !$0.backedUp }\n+        if toBackup.isEmpty {\n+            return []\n+        }\n+        let toDrop = toBackup.count > limit ? toBackup.count - Int(limit) : 0\n+        return toBackup.dropLast(toDrop).map { $0.session }\n+    }\n+\n+    public func inboundGroupSessionsCount(_ onlyBackedUp: Bool) -> UInt {\n+        UInt(onlyBackedUp ? inboundSessions.filter { $0.backedUp }.count : inboundSessions.count)\n+    }\n+\n+    // MARK: - Outgoing Room Key Requests\n+\n+    public func outgoingRoomKeyRequest(withRequestBody requestBody: [AnyHashable : Any]!) -> MXOutgoingRoomKeyRequest! {\n+        outgoingRoomKeyRequests.first(where: { NSDictionary(dictionary: $1.requestBody).isEqual(to: requestBody) })?.value\n+    }\n+\n+    public func outgoingRoomKeyRequest(with state: MXRoomKeyRequestState) -> MXOutgoingRoomKeyRequest! {\n+        outgoingRoomKeyRequests.first(where: { $0.value.state == state })?.value\n+    }\n+\n+    public func allOutgoingRoomKeyRequests(with state: MXRoomKeyRequestState) -> [MXOutgoingRoomKeyRequest]! {\n+        Array(outgoingRoomKeyRequests.filter { $1.state == state }.values)\n+    }\n+\n+    public func allOutgoingRoomKeyRequests(withRoomId roomId: String!, sessionId: String!, algorithm: String!, senderKey: String!) -> [MXOutgoingRoomKeyRequest]! {\n+        Array(outgoingRoomKeyRequests.filter {\n+            $1.roomId == roomId\n+            && $1.sessionId == sessionId\n+            && $1.algorithm == algorithm\n+            && $1.senderKey == senderKey\n+        }.values)\n+    }\n+\n+    public func store(_ request: MXOutgoingRoomKeyRequest!) {\n+        outgoingRoomKeyRequests[request.requestId] = request\n+    }\n+\n+    public func update(_ request: MXOutgoingRoomKeyRequest!) {\n+        outgoingRoomKeyRequests[request.requestId] = request\n+    }\n+\n+    public func deleteOutgoingRoomKeyRequest(withRequestId requestId: String!) {\n+        outgoingRoomKeyRequests.removeValue(forKey: requestId)\n+    }\n+\n+    // MARK: - Incoming Room Key Requests\n+\n+    public func store(_ request: MXIncomingRoomKeyRequest!) {\n+        incomingRoomKeyRequestsMap[request.requestId] = request\n+    }\n+\n+    public func deleteIncomingRoomKeyRequest(_ requestId: String!, fromUser userId: String!, andDevice deviceId: String!) {\n+        let toBeRemoved = incomingRoomKeyRequestsMap.filter { $1.requestId == requestId && $1.userId == userId && $1.deviceId == deviceId }\n+        for identifier in toBeRemoved {\n+            incomingRoomKeyRequestsMap.removeValue(forKey: identifier.key)\n+        }\n+    }\n+\n+    public func incomingRoomKeyRequest(withRequestId requestId: String!, fromUser userId: String!, andDevice deviceId: String!) -> MXIncomingRoomKeyRequest! {\n+        incomingRoomKeyRequestsMap.first(where: { $1.requestId == requestId && $1.userId == userId && $1.deviceId == deviceId })?.value\n+    }\n+\n+    public func incomingRoomKeyRequests() -> MXUsersDevicesMap<NSArray>! {\n+        let result = MXUsersDevicesMap<NSMutableArray>()\n+\n+        for request in incomingRoomKeyRequestsMap {\n+            if let requests = result.object(forDevice: request.value.deviceId, forUser: request.value.userId) {\n+                requests.add(request.value)\n+            } else {\n+                let requests = NSMutableArray(object: request.value)\n+                result.setObject(requests, forUser: request.value.userId, andDevice: request.value.deviceId)\n+            }\n+        }\n+\n+        return result as? MXUsersDevicesMap<NSArray>\n+    }\n+\n+    // MARK: - Secrets\n+\n+    public func storeSecret(_ secret: String!, withSecretId secretId: String!) {\n+        secrets[secretId] = secret\n+    }\n+\n+    public func secret(withSecretId secretId: String!) -> String! {\n+        secrets[secretId]\n+    }\n+\n+    public func deleteSecret(withSecretId secretId: String!) {\n+        secrets.removeValue(forKey: secretId)\n+    }\n+\n+    // MARK: - Blacklist Unverified Devices\n+\n+    public var globalBlacklistUnverifiedDevices: Bool {\n+        get {\n+            storeAccount?.globalBlacklistUnverifiedDevices ?? false\n+        } set {\n+            storeAccount?.globalBlacklistUnverifiedDevices = newValue\n+        }\n+    }\n+\n+    public func blacklistUnverifiedDevices(inRoom roomId: String!) -> Bool {\n+        algorithms[roomId]?.blacklistUnverifiedDevices ?? false\n+    }\n+\n+    public func storeBlacklistUnverifiedDevices(inRoom roomId: String!, blacklist: Bool) {\n+        if let algorithm = algorithms[roomId] {\n+            algorithm.blacklistUnverifiedDevices = blacklist\n+        } else {\n+            algorithms[roomId] = RoomAlgorithm(algorithm: nil, blacklistUnverifiedDevices: blacklist)\n+        }\n+    }\n+\n+    // MARK: - Crypto Version\n+\n+    public var cryptoVersion: MXCryptoVersion {\n+        get {\n+            storeAccount?.cryptoVersion ?? .versionUndefined\n+        } set {\n+            storeAccount?.cryptoVersion = newValue\n+        }\n+    }\n+\n+}\n+\n+// MARK: - Models\n+\n+// MARK: InboundSession\n+\n+private class InboundSession {\n+    let session: MXOlmInboundGroupSession\n+    var backedUp: Bool\n+\n+    var sessionId: String {\n+        session.session.sessionIdentifier()\n+    }\n+\n+    init(session: MXOlmInboundGroupSession,\n+         backedUp: Bool = false) {\n+        self.session = session\n+        self.backedUp = backedUp\n+    }\n+}\n+\n+// MARK: OlmSessionMapKey\n+\n+private struct OlmSessionMapKey: Hashable {\n+    let sessionId: String\n+    let deviceKey: String\n+}\n+\n+// MARK: Account\n+\n+private struct Account {\n+    var userId: String?\n+    var deviceId: String?\n+    var cryptoVersion: MXCryptoVersion = .versionUndefined\n+    var deviceSyncToken: String?\n+    var olmAccount: OLMAccount?\n+    var backupVersion: String?\n+    var globalBlacklistUnverifiedDevices: Bool = false\n+    var deviceTrackingStatus: [String : NSNumber]?\n+}\n+\n+// MARK: SharedOutboundSession\n+\n+private struct SharedOutboundSession {\n+    let roomId: String\n+    let sessionId: String\n+    let device: MXDeviceInfo\n+    let messageIndex: UInt\n+}\n+\n+// MARK: RoomAlgorithm\n+\n+private class RoomAlgorithm {\n+    let algorithm: String?\n+    var blacklistUnverifiedDevices: Bool\n+\n+    init(algorithm: String?,\n+         blacklistUnverifiedDevices: Bool = false) {\n+        self.algorithm = algorithm\n+        self.blacklistUnverifiedDevices = blacklistUnverifiedDevices\n+    }\n+}"
        },
        {
          "filename": "MatrixSDKTests/Crypto/KeySharing/Data/MXForwardedRoomKeyEventContentUnitTests.swift",
          "status": "added",
          "additions": 121,
          "deletions": 0,
          "patch": "@@ -0,0 +1,121 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+import XCTest\n+@testable import MatrixSDK\n+\n+class MXForwardedRoomKeyEventContentUnitTests: XCTestCase {\n+    \n+    // MARK: - modelFromJSON\n+    \n+    func makeValidJSON() -> [String: Any] {\n+        return [\n+            \"algorithm\": \"A\",\n+            \"room_id\": \"B\",\n+            \"sender_key\": \"C\",\n+            \"session_id\": \"D\",\n+            \"session_key\": \"E\",\n+            \"sender_claimed_ed25519_key\": \"F\",\n+            \"forwarding_curve25519_key_chain\": [\"G\", \"H\"],\n+            kMXSharedHistoryKeyName: false\n+        ]\n+    }\n+    \n+    func test_modelFromJSON_doesNotCreateWithMissingFields() {\n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: [:])\n+        )\n+        \n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"algorithm\"))\n+        )\n+        \n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"room_id\"))\n+        )\n+        \n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"sender_key\"))\n+        )\n+        \n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"session_id\"))\n+        )\n+        \n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"session_key\"))\n+        )\n+        \n+        XCTAssertNil(MXForwardedRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"sender_claimed_ed25519_key\"))\n+        )\n+    }\n+    \n+    func test_modelFromJSON_canCreateFromJSON() {\n+        let content = MXForwardedRoomKeyEventContent(fromJSON: makeValidJSON())\n+        \n+        XCTAssertNotNil(content)\n+        XCTAssertEqual(content?.algorithm, \"A\")\n+        XCTAssertEqual(content?.roomId, \"B\")\n+        XCTAssertEqual(content?.senderKey, \"C\")\n+        XCTAssertEqual(content?.sessionId, \"D\")\n+        XCTAssertEqual(content?.sessionKey, \"E\")\n+        XCTAssertEqual(content?.senderClaimedEd25519Key, \"F\")\n+        XCTAssertEqual(content?.forwardingCurve25519KeyChain, [\"G\", \"H\"])\n+        XCTAssertEqual(content?.sharedHistory, false)\n+    }\n+    \n+    func test_modelFromJSON_forwardingCurveChainDefaultsToEmpty() {\n+        let json = makeValidJSON().removing(key: \"forwarding_curve25519_key_chain\")\n+        let content = MXForwardedRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content?.forwardingCurve25519KeyChain, [])\n+    }\n+    \n+    func test_modelFromJSON_sharedHistory() {\n+        var json = makeValidJSON()\n+        \n+        json[kMXSharedHistoryKeyName] = true\n+        let content1 = MXForwardedRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content1?.sharedHistory, true)\n+        \n+        json[kMXSharedHistoryKeyName] = false\n+        let content2 = MXForwardedRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content2?.sharedHistory, false)\n+        \n+        json[kMXSharedHistoryKeyName] = nil\n+        let content3 = MXForwardedRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content3?.sharedHistory, false)\n+    }\n+    \n+    // MARK: - JSONDictionary\n+    \n+    func test_JSONDictionary_canExportJSON() {\n+        let content = MXForwardedRoomKeyEventContent()\n+        content.algorithm = \"A\"\n+        content.roomId = \"B\"\n+        content.senderKey = \"C\"\n+        content.sessionId = \"D\"\n+        content.sessionKey = \"E\"\n+        content.senderClaimedEd25519Key = \"F\"\n+        content.forwardingCurve25519KeyChain = [\"G\", \"H\"]\n+        content.sharedHistory = false\n+        \n+        let json = content.jsonDictionary()\n+        \n+        XCTAssertEqual(json as? NSDictionary, makeValidJSON() as NSDictionary)\n+    }\n+}"
        },
        {
          "filename": "MatrixSDKTests/Crypto/KeySharing/Data/MXRoomKeyEventContentUnitTests.swift",
          "status": "added",
          "additions": 98,
          "deletions": 0,
          "patch": "@@ -0,0 +1,98 @@\n+//\n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+import XCTest\n+@testable import MatrixSDK\n+\n+class MXRoomKeyEventContentUnitTests: XCTestCase {\n+    \n+    // MARK: - modelFromJSON\n+    \n+    func makeValidJSON() -> [String: Any] {\n+        return [\n+            \"algorithm\": \"A\",\n+            \"room_id\": \"B\",\n+            \"session_id\": \"C\",\n+            \"session_key\": \"D\",\n+            kMXSharedHistoryKeyName: false\n+        ]\n+    }\n+    \n+    func test_modelFromJSON_doesNotCreateWithMissingFields() {\n+        XCTAssertNil(MXRoomKeyEventContent(\n+            fromJSON: [:])\n+        )\n+        \n+        XCTAssertNil(MXRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"algorithm\"))\n+        )\n+        \n+        XCTAssertNil(MXRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"room_id\"))\n+        )\n+        \n+        XCTAssertNil(MXRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"session_id\"))\n+        )\n+        \n+        XCTAssertNil(MXRoomKeyEventContent(\n+            fromJSON: makeValidJSON().removing(key: \"session_key\"))\n+        )\n+    }\n+    \n+    func test_modelFromJSON_canCreateFromJSON() {\n+        let content = MXRoomKeyEventContent(fromJSON: makeValidJSON())\n+\n+        XCTAssertNotNil(content)\n+        XCTAssertEqual(content?.algorithm, \"A\")\n+        XCTAssertEqual(content?.roomId, \"B\")\n+        XCTAssertEqual(content?.sessionId, \"C\")\n+        XCTAssertEqual(content?.sessionKey, \"D\")\n+        XCTAssertEqual(content?.sharedHistory, false)\n+    }\n+\n+    func test_modelFromJSON_sharedHistory() {\n+        var json = makeValidJSON()\n+\n+        json[kMXSharedHistoryKeyName] = true\n+        let content1 = MXRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content1?.sharedHistory, true)\n+\n+        json[kMXSharedHistoryKeyName] = false\n+        let content2 = MXRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content2?.sharedHistory, false)\n+\n+        json[kMXSharedHistoryKeyName] = nil\n+        let content3 = MXRoomKeyEventContent(fromJSON: json)\n+        XCTAssertEqual(content3?.sharedHistory, false)\n+    }\n+\n+    // MARK: - JSONDictionary\n+\n+    func test_JSONDictionary_canExportJSON() {\n+        let content = MXRoomKeyEventContent()\n+        content.algorithm = \"A\"\n+        content.roomId = \"B\"\n+        content.sessionId = \"C\"\n+        content.sessionKey = \"D\"\n+        content.sharedHistory = false\n+\n+        let json = content.jsonDictionary()\n+\n+        XCTAssertEqual(json as? NSDictionary, makeValidJSON() as NSDictionary)\n+    }\n+}"
        },
        {
          "filename": "MatrixSDKTests/Crypto/KeySharing/MXUnrequestedForwardedRoomKeyManagerUnitTests.swift",
          "status": "added",
          "additions": 237,
          "deletions": 0,
          "patch": "@@ -0,0 +1,237 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+import XCTest\n+@testable import MatrixSDK\n+\n+private let BobSenderKey = \"BobDeviceCurveKey\"\n+\n+class MXUnrequestedForwardedRoomKeyManagerUnitTests: XCTestCase {\n+    class Delegate: MXUnrequestedForwardedRoomKeyManagerDelegate {\n+        var stubbedUserKeys = [String: [MXDeviceInfo]]()\n+        var spyKeys = [MXRoomKeyInfo]()\n+        \n+        func downloadDeviceKeys(userId: String, completion: @escaping (MXUsersDevicesMap<MXDeviceInfo>) -> Void) {\n+            let map = MXUsersDevicesMap<MXDeviceInfo>()\n+            for (userId, devices) in stubbedUserKeys {\n+                for device in devices {\n+                    map.setObject(device, forUser: userId, andDevice: device.deviceId)\n+                }\n+            }\n+            completion(map)\n+        }\n+        \n+        func acceptRoomKey(keyInfo: MXRoomKeyInfo) {\n+            spyKeys.append(keyInfo)\n+        }\n+    }\n+    \n+    class StubDateProvider: MXDateProviding {\n+        var stubbedDate: Date?\n+        func currentDate() -> Date {\n+            return stubbedDate ?? Date()\n+        }\n+    }\n+    \n+    var dateProvider: StubDateProvider!\n+    var manager: MXUnrequestedForwardedRoomKeyManager!\n+    var delegate: Delegate!\n+    \n+    override func setUp() {\n+        dateProvider = StubDateProvider()\n+        manager = MXUnrequestedForwardedRoomKeyManager(dateProvider: dateProvider)\n+        delegate = Delegate()\n+        manager.delegate = delegate\n+        \n+        delegate.stubbedUserKeys = [\n+            \"Bob\": [\n+                MXDeviceInfo(fromJSON: [\n+                    \"user_id\": \"Bob\",\n+                    \"device_id\": \"BobDevice\",\n+                    \"keys\": [\n+                        \"ed25519:BobDevice\": \"BobDeviceEdKey\",\n+                        \"curve25519:BobDevice\": BobSenderKey,\n+                    ]\n+                ])\n+            ]\n+        ]\n+    }\n+    \n+    func test_processUnrequestedKeys_doesNothingIfNoKeys() {\n+        manager.processUnrequestedKeys()\n+        XCTAssertEqual(delegate.spyKeys, [])\n+    }\n+    \n+    func test_processUnrequestedKeys_addsAllKeysForInvitedRooms() {\n+        let keys = [\n+            MXRoomKeyInfo.fixture(sessionId: \"1\", roomId: \"A\"),\n+            MXRoomKeyInfo.fixture(sessionId: \"2\", roomId: \"A\"),\n+            MXRoomKeyInfo.fixture(sessionId: \"3\", roomId: \"B\"),\n+            MXRoomKeyInfo.fixture(sessionId: \"4\", roomId: \"C\"),\n+        ]\n+        for info in keys {\n+            manager.addPendingKey(keyInfo: info, senderId: \"Bob\", senderKey: BobSenderKey)\n+        }\n+        manager.onRoomInvite(roomId: \"A\", senderId: \"Bob\")\n+        manager.onRoomInvite(roomId: \"C\", senderId: \"Bob\")\n+        \n+        manager.processUnrequestedKeys()\n+        \n+        let sessionIds = delegate.spyKeys.map { $0.sessionId }\n+        XCTAssertEqual(Set(sessionIds), [\"1\", \"2\", \"4\"])\n+    }\n+    \n+    func test_processUnrequestedKeys_addsOnlyKeysFromRoomInviter() {\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"1\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: \"AliceKey\"\n+        )\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"2\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: BobSenderKey\n+        )\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"3\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: \"CharlieKey\"\n+        )\n+        manager.onRoomInvite(roomId: \"A\", senderId: \"Bob\")\n+\n+        manager.processUnrequestedKeys()\n+\n+        let sessionIds = delegate.spyKeys.map { $0.sessionId }\n+        XCTAssertEqual(Set(sessionIds), [\"2\"])\n+    }\n+    \n+    func test_processUnrequestedKeys_doesNotAddKeysIfSenderNotValid() {\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"2\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: \"BobInvalidKey\"\n+        )\n+        manager.onRoomInvite(roomId: \"A\", senderId: \"Bob\")\n+\n+        manager.processUnrequestedKeys()\n+\n+        XCTAssertEqual(delegate.spyKeys, [])\n+    }\n+    \n+    func test_processUnrequestedKeys_removesProcessedKeys() {\n+        delegate.spyKeys = []\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"1\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: BobSenderKey\n+        )\n+        manager.processUnrequestedKeys()\n+        XCTAssertEqual(delegate.spyKeys.count, 0)\n+        \n+        delegate.spyKeys = []\n+        manager.onRoomInvite(roomId: \"A\", senderId: \"Bob\")\n+        manager.processUnrequestedKeys()\n+        XCTAssertEqual(delegate.spyKeys.count, 1)\n+        \n+        delegate.spyKeys = []\n+        manager.processUnrequestedKeys()\n+        XCTAssertEqual(delegate.spyKeys.count, 0)\n+    }\n+    \n+    func test_processUnrequestedKeys_removesInvitesMoreThan10MinutesFromPresent() {\n+        let minutesToRoom: [TimeInterval: String] = [\n+            -10: \"A\",\n+             -9: \"B\",\n+             0: \"C\",\n+             9: \"D\",\n+             10: \"E\"\n+        ]\n+        \n+        // First add all the keys\n+        for (minutes, roomId) in minutesToRoom {\n+            stubDate(timeInterval: minutes * 60)\n+            manager.addPendingKey(\n+                keyInfo: MXRoomKeyInfo.fixture(sessionId: roomId, roomId: roomId),\n+                senderId: \"Bob\",\n+                senderKey: BobSenderKey\n+            )\n+        }\n+        \n+        // Now add invites\n+        for (minutes, roomId) in minutesToRoom {\n+            stubDate(timeInterval: minutes * 60)\n+            manager.onRoomInvite(roomId: roomId, senderId: \"Bob\")\n+        }\n+        \n+        // Set the date to present\n+        stubDate(timeInterval: 0)\n+        \n+        // Process invites\n+        manager.processUnrequestedKeys()\n+        \n+        let sessionIds = delegate.spyKeys.map { $0.sessionId }\n+        XCTAssertEqual(Set(sessionIds), [\"B\", \"C\", \"D\"])\n+    }\n+    \n+    func test_processUnrequestedKeys_removesKeysOlderThan10MinutesOfInvite() {\n+        stubDate(timeInterval: 0)\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"1\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: BobSenderKey\n+        )\n+        stubDate(timeInterval: 1 * 60)\n+        manager.addPendingKey(\n+            keyInfo: MXRoomKeyInfo.fixture(sessionId: \"2\", roomId: \"A\"),\n+            senderId: \"Bob\",\n+            senderKey: BobSenderKey\n+        )\n+        stubDate(timeInterval: 10 * 60)\n+        manager.onRoomInvite(roomId: \"A\", senderId: \"Bob\")\n+        stubDate(timeInterval: 19 * 60)\n+        \n+        manager.processUnrequestedKeys()\n+        \n+        XCTAssertEqual(delegate.spyKeys.count, 1)\n+        XCTAssertEqual(delegate.spyKeys.first?.sessionId, \"2\")\n+    }\n+    \n+    // MARK: - Helpers\n+    \n+    func stubDate(timeInterval: TimeInterval) {\n+        dateProvider.stubbedDate = Date(timeIntervalSince1970: timeInterval)\n+    }\n+}\n+\n+private extension MXRoomKeyInfo {\n+    static func fixture(\n+        sessionId: String,\n+        roomId: String\n+    ) -> MXRoomKeyInfo {\n+        return MXRoomKeyInfo(\n+            algorithm: \"\",\n+            sessionId: sessionId,\n+            sessionKey: \"\",\n+            roomId: roomId,\n+            senderKey: \"\",\n+            forwardingKeyChain: nil,\n+            keysClaimed: [:],\n+            exportFormat: false,\n+            sharedHistory: false\n+        )\n+    }\n+}"
        },
        {
          "filename": "MatrixSDKTests/Crypto/MXOlmDeviceUnitTests.swift",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -71,7 +71,8 @@ class MXOlmDeviceUnitTests: XCTestCase {\n             forwardingCurve25519KeyChain: [],\n             keysClaimed: [:],\n             exportFormat: false,\n-            sharedHistory: sharedHistory\n+            sharedHistory: sharedHistory,\n+            untrusted: false\n         )\n     }\n     "
        },
        {
          "filename": "MatrixSDKTests/Crypto/RoomKeys/MXRoomKeyInfoFactoryUnitTests.swift",
          "status": "added",
          "additions": 184,
          "deletions": 0,
          "patch": "@@ -0,0 +1,184 @@\n+// \n+// Copyright 2022 The Matrix.org Foundation C.I.C\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+//\n+\n+import Foundation\n+import XCTest\n+@testable import MatrixSDK\n+\n+class MXRoomKeyInfoFactoryUnitTests: XCTestCase {\n+    \n+    var store: MXMemoryCryptoStore!\n+    var factory: MXRoomKeyInfoFactory!\n+    override func setUp() {\n+        store = MXMemoryCryptoStore(credentials: MXCredentials(homeServer: \"\", userId: \"Alice\", accessToken: nil))\n+        factory = MXRoomKeyInfoFactory(myUserId: \"Alice\", store: store)\n+        storeOutgoingKeyRequest(requestId: \"1\")\n+    }\n+    \n+    // MARK: - Any event\n+    \n+    func test_roomKeyInfo_isNilForInvalidEvent() {\n+        let info = factory.roomKey(for: MXEvent(fromJSON: [:]))\n+        XCTAssertNil(info)\n+    }\n+    \n+    // MARK: - Room key event\n+    \n+    func test_roomKeyInfo_createFromRoomKeyEvent() {\n+        let event = MXEvent.roomKeyFixture()\n+        \n+        let key = factory.roomKey(for: event)\n+        \n+        let info = key?.info\n+        XCTAssertNotNil(key)\n+        XCTAssertEqual(key?.type, .safe)\n+        XCTAssertEqual(info?.algorithm, \"megolm\")\n+        XCTAssertEqual(info?.sessionId, \"session1\")\n+        XCTAssertEqual(info?.sessionKey, \"<key>\")\n+        XCTAssertEqual(info?.roomId, \"!123:matrix.org\")\n+        XCTAssertEqual(info?.senderKey, \"<sender_key>\")\n+        XCTAssertNil(info?.forwardingKeyChain)\n+        XCTAssertEqual(info?.keysClaimed as? NSDictionary, [\"ed25519\": \"<claimed_key>\"])\n+        XCTAssertEqual(info?.exportFormat, false)\n+        XCTAssertEqual(info?.sharedHistory, false)\n+    }\n+    \n+    // MARK: - Forwarded room key event\n+    \n+    func test_roomKeyInfo_isUnrequestedIfKeyNotRequested() {\n+        store.deleteOutgoingRoomKeyRequest(withRequestId: \"1\")\n+        storeDevice(userId: \"Alice\", trusted: true, identityKey: \"AliceSender\")\n+        let event = MXEvent.forwardedRoomKeyFixture(\n+            senderKey: \"AliceSender\"\n+        )\n+        \n+        let key = factory.roomKey(for: event)\n+        \n+        let info = key?.info\n+        XCTAssertNotNil(key)\n+        XCTAssertEqual(key?.type, .unrequested)\n+        XCTAssertEqual(info?.algorithm, \"megolm\")\n+        XCTAssertEqual(info?.sessionId, \"session1\")\n+        XCTAssertEqual(info?.sessionKey, \"<key>\")\n+        XCTAssertEqual(info?.roomId, \"!123:matrix.org\")\n+        XCTAssertEqual(info?.senderKey, \"<initial_sender_key>\")\n+        XCTAssertEqual(info?.forwardingKeyChain, [\"AliceSender\"])\n+        XCTAssertEqual(info?.keysClaimed as? NSDictionary, [\"ed25519\": \"<claimed_key>\"])\n+        XCTAssertEqual(info?.exportFormat, true)\n+        XCTAssertEqual(info?.sharedHistory, false)\n+    }\n+    \n+    func test_roomKeyInfo_isUnsafeIfNotFromMyself() {\n+        storeDevice(userId: \"Bob\", trusted: true, identityKey: \"AliceSender\")\n+        let event = MXEvent.forwardedRoomKeyFixture(\n+            senderKey: \"AliceSender\"\n+        )\n+        \n+        let key = factory.roomKey(for: event)\n+        \n+        let info = key?.info\n+        XCTAssertNotNil(key)\n+        XCTAssertEqual(key?.type, .unsafe)\n+        XCTAssertEqual(info?.algorithm, \"megolm\")\n+        XCTAssertEqual(info?.sessionId, \"session1\")\n+        XCTAssertEqual(info?.sessionKey, \"<key>\")\n+        XCTAssertEqual(info?.roomId, \"!123:matrix.org\")\n+        XCTAssertEqual(info?.senderKey, \"<initial_sender_key>\")\n+        XCTAssertEqual(info?.forwardingKeyChain, [\"AliceSender\"])\n+        XCTAssertEqual(info?.keysClaimed as? NSDictionary, [\"ed25519\": \"<claimed_key>\"])\n+        XCTAssertEqual(info?.exportFormat, true)\n+        XCTAssertEqual(info?.sharedHistory, false)\n+    }\n+    \n+    func test_roomKeyInfo_isUnsafeIfFromUnverifiedDevice() {\n+        storeDevice(userId: \"Alice\", trusted: false, identityKey: \"AliceSender\")\n+        let event = MXEvent.forwardedRoomKeyFixture(\n+            senderKey: \"AliceSender\"\n+        )\n+        \n+        let key = factory.roomKey(for: event)\n+        \n+        let info = key?.info\n+        XCTAssertNotNil(key)\n+        XCTAssertEqual(key?.type, .unsafe)\n+        XCTAssertEqual(info?.algorithm, \"megolm\")\n+        XCTAssertEqual(info?.sessionId, \"session1\")\n+        XCTAssertEqual(info?.sessionKey, \"<key>\")\n+        XCTAssertEqual(info?.roomId, \"!123:matrix.org\")\n+        XCTAssertEqual(info?.senderKey, \"<initial_sender_key>\")\n+        XCTAssertEqual(info?.forwardingKeyChain, [\"AliceSender\"])\n+        XCTAssertEqual(info?.keysClaimed as? NSDictionary, [\"ed25519\": \"<claimed_key>\"])\n+        XCTAssertEqual(info?.exportFormat, true)\n+        XCTAssertEqual(info?.sharedHistory, false)\n+    }\n+    \n+    func test_roomKeyInfo_createFromForwardedRoomKeyEvent() {\n+        storeDevice(userId: \"Alice\", trusted: true, identityKey: \"AliceSender\")\n+        let event = MXEvent.forwardedRoomKeyFixture(\n+            senderKey: \"AliceSender\"\n+        )\n+        \n+        let key = factory.roomKey(for: event)\n+        \n+        let info = key?.info\n+        XCTAssertNotNil(key)\n+        XCTAssertEqual(key?.type, .safe)\n+        XCTAssertEqual(info?.algorithm, \"megolm\")\n+        XCTAssertEqual(info?.sessionId, \"session1\")\n+        XCTAssertEqual(info?.sessionKey, \"<key>\")\n+        XCTAssertEqual(info?.roomId, \"!123:matrix.org\")\n+        XCTAssertEqual(info?.senderKey, \"<initial_sender_key>\")\n+        XCTAssertEqual(info?.forwardingKeyChain, [\"AliceSender\"])\n+        XCTAssertEqual(info?.keysClaimed as? NSDictionary, [\"ed25519\": \"<claimed_key>\"])\n+        XCTAssertEqual(info?.exportFormat, true)\n+        XCTAssertEqual(info?.sharedHistory, false)\n+    }\n+    \n+    // MARK: - Helpers\n+    \n+    func storeOutgoingKeyRequest(\n+        requestId: String = \"1\",\n+        algorithm: String = \"megolm\",\n+        roomId: String = \"!123:matrix.org\",\n+        sessionId: String = \"session1\",\n+        senderKey: String = \"<initial_sender_key>\"\n+    ) {\n+        let request = MXOutgoingRoomKeyRequest()\n+        request.requestId = requestId\n+        \n+        request.requestBody = [\n+            \"room_id\": roomId,\n+            \"algorithm\": algorithm,\n+            \"sender_key\": senderKey,\n+            \"session_id\": sessionId\n+        ]\n+        store.store(request)\n+    }\n+    \n+    func storeDevice(userId: String, trusted: Bool, identityKey: String) {\n+        let trust = MXDeviceTrustLevel(\n+            localVerificationStatus: trusted ? .verified : .unverified,\n+            crossSigningVerified: false\n+        )\n+        let device = MXDeviceInfo(fromJSON: [\n+            \"user_id\": userId,\n+            \"device_id\": \"ABC\",\n+            \"keys\": [\"curve25519:ABC\": identityKey]\n+        ])!\n+        device.setValue(trust, forKey: \"trustLevel\")\n+        store.storeDevice(forUser: userId, device: device)\n+    }\n+}"
        },
        {
          "filename": "MatrixSDKTests/JSONModels/MXEventFixtures.swift",
          "status": "modified",
          "additions": 68,
          "deletions": 0,
          "patch": "@@ -34,4 +34,72 @@ extension MXEvent {\n             ]\n         ])!\n     }\n+    \n+    static func roomKeyFixture(\n+        algorithm: String = \"megolm\",\n+        roomId: String = \"!123:matrix.org\",\n+        sessionId: String = \"session1\",\n+        sessionKey: String = \"<key>\",\n+        senderKey: String = \"<sender_key>\",\n+        claimedKey: String = \"<claimed_key>\",\n+        sharedHistory: Bool? = nil\n+    ) -> MXEvent {\n+        var content: [String: Any] = [\n+            \"type\": kMXEventTypeStringRoomKey,\n+            \"room_id\": roomId,\n+            \"session_id\": sessionId,\n+            \"session_key\": sessionKey,\n+            \"algorithm\": algorithm\n+        ]\n+        \n+        if let sharedHistory = sharedHistory {\n+            content[\"org.matrix.msc3061.shared_history\"] = sharedHistory\n+        }\n+        \n+        let result = MXEventDecryptionResult()\n+        result.senderCurve25519Key = senderKey\n+        result.claimedEd25519Key = claimedKey\n+        result.clearEvent = [\n+            \"type\": kMXEventTypeStringRoomKey,\n+            \"content\": content\n+        ]\n+        \n+        let event = MXEvent(fromJSON: [:])!\n+        event.setClearData(result)\n+        return event\n+    }\n+    \n+    static func forwardedRoomKeyFixture(\n+        algorithm: String = \"megolm\",\n+        roomId: String = \"!123:matrix.org\",\n+        sessionId: String = \"session1\",\n+        sessionKey: String = \"<key>\",\n+        senderKey: String = \"<sender_key>\",\n+        initialSenderKey: String = \"<initial_sender_key>\",\n+        claimedKey: String = \"<claimed_key>\",\n+        sharedHistory: Bool = false\n+    ) -> MXEvent {\n+        let content: [String: Any] = [\n+            \"type\": kMXEventTypeStringRoomKey,\n+            \"room_id\": roomId,\n+            \"session_id\": sessionId,\n+            \"session_key\": sessionKey,\n+            \"algorithm\": algorithm,\n+            \"sender_key\": initialSenderKey,\n+            \"sender_claimed_ed25519_key\": claimedKey,\n+            kMXSharedHistoryKeyName: sharedHistory\n+        ]\n+        \n+        let result = MXEventDecryptionResult()\n+        result.senderCurve25519Key = senderKey\n+        result.claimedEd25519Key = claimedKey\n+        result.clearEvent = [\n+            \"type\": kMXEventTypeStringRoomForwardedKey,\n+            \"content\": content\n+        ]\n+        \n+        let event = MXEvent(fromJSON: [:])!\n+        event.setClearData(result)\n+        return event\n+    }\n }"
        },
        {
          "filename": "MatrixSDKTests/MXCryptoSecretShareTests.m",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -82,7 +82,7 @@ - (void)testLocalSecretStorage\n  \n  - Alice has a secret on her 1st device\n  - Alice logs in on a new device\n- - Alice trusts the new device\n+ - Alice trusts the new device and vice versa\n  - Alice requests the secret from the new device\n  -> She gets the secret\n  */\n@@ -101,8 +101,9 @@ - (void)testSecretShare\n             \n             MXCredentials *newAlice = newAliceSession.matrixRestClient.credentials;\n             \n-            // - Alice trusts the new device\n+            // - Alice trusts the new device and vice versa\n             [aliceSession.crypto setDeviceVerification:MXDeviceVerified forDevice:newAlice.deviceId ofUser:newAlice.userId success:nil failure:nil];\n+            [newAliceSession.crypto setDeviceVerification:MXDeviceVerified forDevice:aliceSession.myDeviceId ofUser:aliceSession.myUserId success:nil failure:nil];\n             \n             // - Alice requests the secret from the new device\n             [newAliceSession.crypto.secretShareManager requestSecret:secretId toDeviceIds:nil success:^(NSString * _Nonnull requestId) {"
        },
        {
          "filename": "MatrixSDKTests/MXCryptoTests.m",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -31,6 +31,7 @@\n #import \"MXSendReplyEventDefaultStringLocalizer.h\"\n #import \"MXOutboundSessionInfo.h\"\n #import <OLMKit/OLMKit.h>\n+#import \"MXLRUCache.h\"\n \n #import \"MXKey.h\"\n \n@@ -2081,6 +2082,8 @@ - (void)testLateRoomKey\n \n                 id<MXCryptoStore> bobCryptoStore = (id<MXCryptoStore>)[bobSession.crypto.olmDevice valueForKey:@\"store\"];\n                 [bobCryptoStore removeInboundGroupSessionWithId:sessionId andSenderKey:toDeviceEvent.senderKey];\n+                MXLRUCache *cache = [bobSession.crypto.olmDevice valueForKey:@\"inboundGroupSessionCache\"];\n+                [cache clear];\n \n                 // So that we cannot decrypt it anymore right now\n                 [event setClearData:nil];"
        },
        {
          "filename": "MatrixSDKTests/MXToolsUnitTests.m",
          "status": "modified",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -18,6 +18,7 @@\n \n #import \"MXTools.h\"\n #import \"MatrixSDKTestsSwiftHeader.h\"\n+#import \"MatrixSDKSwiftHeader.h\"\n \n @interface MXToolsUnitTests : XCTestCase\n \n@@ -129,4 +130,54 @@ - (void)testUrlGeneration\n     XCTAssertNotEqualObjects(url, [MXTools urlStringWithBase:currentResult queryParameters:@[parameter]]);\n }\n \n+#pragma mark - Supported To-Device events\n+\n+- (void)testSupportedToDeviceEvents\n+{\n+    MXEvent *event1 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"m.room.encrypted\",\n+        @\"content\": @{\n+            @\"algorithm\": kMXCryptoOlmAlgorithm\n+        }\n+    }];\n+    XCTAssertTrue([MXTools isSupportedToDeviceEvent:event1]);\n+    \n+    MXEvent *event2 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"m.room.message\",\n+    }];\n+    XCTAssertTrue([MXTools isSupportedToDeviceEvent:event2]);\n+    \n+    MXEvent *event3 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"random\",\n+    }];\n+    XCTAssertTrue([MXTools isSupportedToDeviceEvent:event3]);\n+}\n+\n+- (void)testUnsupportedToDeviceEvents\n+{\n+    MXEvent *event1 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"m.room.encrypted\",\n+        @\"content\": @{\n+            @\"algorithm\": kMXCryptoMegolmAlgorithm\n+        }\n+    }];\n+    XCTAssertFalse([MXTools isSupportedToDeviceEvent:event1]);\n+    \n+    MXEvent *event2 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"m.room_key\",\n+    }];\n+    XCTAssertFalse([MXTools isSupportedToDeviceEvent:event2]);\n+    \n+    MXEvent *event3 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"m.forwarded_room_key\",\n+    }];\n+    XCTAssertFalse([MXTools isSupportedToDeviceEvent:event3]);\n+    \n+    MXEvent *event4 = [MXEvent modelFromJSON:@{\n+        @\"type\": @\"m.secret.send\",\n+    }];\n+    XCTAssertFalse([MXTools isSupportedToDeviceEvent:event4]);\n+}\n+\n+\n @end"
        },
        {
          "filename": "MatrixSDKTests/TestPlans/UnitTests.xctestplan",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -52,10 +52,12 @@\n         \"MXEventsByTypesEnumeratorOnArrayTests\",\n         \"MXEventsEnumeratorOnArrayTests\",\n         \"MXFilterUnitTests\",\n+        \"MXForwardedRoomKeyEventContentUnitTests\",\n         \"MXHTTPAdditionalHeadersUnitTests\",\n         \"MXJSONModelUnitTests\",\n         \"MXKeyBackupUnitTests\",\n         \"MXKeyProviderUnitTests\",\n+        \"MXKeyVerificationRequestV2UnitTests\",\n         \"MXMediaScanStoreUnitTests\",\n         \"MXMegolmDecryptionUnitTests\",\n         \"MXMegolmExportEncryptionUnitTests\",\n@@ -67,15 +69,19 @@\n         \"MXQRCodeDataUnitTests\",\n         \"MXReplyEventParserUnitTests\",\n         \"MXResponseUnitTests\",\n+        \"MXRoomKeyEventContentUnitTests\",\n+        \"MXRoomKeyInfoFactoryUnitTests\",\n         \"MXRoomStateUnitTests\",\n+        \"MXSASTransactionV2UnitTests\",\n         \"MXSharedHistoryKeyManagerUnitTests\",\n         \"MXStoreRoomListDataManagerUnitTests\",\n         \"MXSyncResponseUnitTests\",\n         \"MXTaskQueueUnitTests\",\n         \"MXThreadEventTimelineUnitTests\",\n         \"MXThreadingServiceUnitTests\",\n         \"MXToolsUnitTests\",\n-        \"MXTrustLevelSourceUnitTests\"\n+        \"MXTrustLevelSourceUnitTests\",\n+        \"MXUnrequestedForwardedRoomKeyManagerUnitTests\",\n       ],\n       \"target\" : {\n         \"containerPath\" : \"container:MatrixSDK.xcodeproj\","
        },
        {
          "filename": "MatrixSDKTests/TestPlans/UnitTestsWithSanitizers.xctestplan",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -60,10 +60,12 @@\n         \"MXEventReferenceUnitTests\",\n         \"MXEventScanStoreUnitTests\",\n         \"MXFilterUnitTests\",\n+        \"MXForwardedRoomKeyEventContentUnitTests\",\n         \"MXHTTPAdditionalHeadersUnitTests\",\n         \"MXJSONModelUnitTests\",\n         \"MXKeyBackupUnitTests\",\n         \"MXKeyProviderUnitTests\",\n+        \"MXKeyVerificationRequestV2UnitTests\",\n         \"MXMediaScanStoreUnitTests\",\n         \"MXMegolmDecryptionUnitTests\",\n         \"MXMegolmExportEncryptionUnitTests\",\n@@ -75,15 +77,19 @@\n         \"MXQRCodeDataUnitTests\",\n         \"MXReplyEventParserUnitTests\",\n         \"MXResponseUnitTests\",\n+        \"MXRoomKeyEventContentUnitTests\",\n+        \"MXRoomKeyInfoFactoryUnitTests\",\n         \"MXRoomStateUnitTests\",\n+        \"MXSASTransactionV2UnitTests\",\n         \"MXSharedHistoryKeyManagerUnitTests\",\n         \"MXStoreRoomListDataManagerUnitTests\",\n         \"MXSyncResponseUnitTests\",\n         \"MXTaskQueueUnitTests\",\n         \"MXThreadEventTimelineUnitTests\",\n         \"MXThreadingServiceUnitTests\",\n         \"MXToolsUnitTests\",\n-        \"MXTrustLevelSourceUnitTests\"\n+        \"MXTrustLevelSourceUnitTests\",\n+        \"MXUnrequestedForwardedRoomKeyManagerUnitTests\",\n       ],\n       \"target\" : {\n         \"containerPath\" : \"container:MatrixSDK.xcodeproj\","
        }
      ],
      "file_patterns": {
        "security_files": 30,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 13,
        "unique_directories": 27,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2529e7feb9ef4b76c5b7cfdc0a3aa617197762b0",
            "date": "2024-12-10T10:06:24Z",
            "author_login": "pixlwave"
          },
          {
            "sha": "16473376fe031ebe6908d2df8d3ae3f35f1039d0",
            "date": "2024-12-10T10:06:23Z",
            "author_login": "pixlwave"
          },
          {
            "sha": "75fe517811ebfd6ce90d3287997a6c09e89eabee",
            "date": "2024-12-10T10:06:19Z",
            "author_login": "pixlwave"
          },
          {
            "sha": "de3f7a8be0dae6a5ed06588c6bbad8d5ba25ce7e",
            "date": "2024-12-10T10:06:18Z",
            "author_login": "pixlwave"
          },
          {
            "sha": "0d73a961480fd4b91af8e80c7844fefe5494f40d",
            "date": "2024-12-10T10:04:43Z",
            "author_login": "pixlwave"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "Matrix iOS SDK allows developers to build iOS apps compatible with Matrix. Prior to version 0.23.19, an attacker cooperating with a malicious homeserver can construct messages appearing to have come from another person. Such messages will be marked with a grey shield on some platforms, but this may be missing in others. This attack is possible due to the matrix-ios-sdk implementing a too permissive key forwarding strategy. The default policy for accepting key forwards has been made more strict in the matrix-ios-sdk version 0.23.19. matrix-ios-sdk will now only accept forwarded keys in response to previously issued requests and only from own, verified devices. The SDK now sets a `trusted` flag on the decrypted message upon decryption, based on whether the key used to decrypt the message was received from a trusted source. Clients need to ensure that messages decrypted with a key with `trusted = false` are decorated appropriately (for example, by showing a warning for such messages). This attack requires coordination between a malicious home server and an attacker, so those who trust their home servers do not need a workaround.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-09-28T21:15:14.397",
    "last_modified": "2024-11-21T07:17:53.680",
    "fix_date": "2022-09-28T14:25:36Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/matrix-ios-sdk/commit/5ca86c328a5faaab429c240551cb9ca8f0f6262c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-ios-sdk/releases/tag/v0.23.19",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-ios-sdk/security/advisories/GHSA-qxr3-5jmq-xcf4",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://matrix.org/blog/2022/09/28/upgrade-now-to-address-encryption-vulns-in-matrix-sdks-and-clients",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-ios-sdk/commit/5ca86c328a5faaab429c240551cb9ca8f0f6262c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-ios-sdk/releases/tag/v0.23.19",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-ios-sdk/security/advisories/GHSA-qxr3-5jmq-xcf4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://matrix.org/blog/2022/09/28/upgrade-now-to-address-encryption-vulns-in-matrix-sdks-and-clients",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.297148",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "matrix-ios-sdk",
    "owner": "matrix-org",
    "created_at": "2014-09-30T10:06:39Z",
    "updated_at": "2025-01-14T08:08:46Z",
    "pushed_at": "2024-12-10T10:06:26Z",
    "size": 23396,
    "stars": 453,
    "forks": 216,
    "open_issues": 168,
    "watchers": 453,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "Objective-C": 4660528,
      "Swift": 1648756,
      "C": 13782,
      "Ruby": 7523,
      "Python": 7499,
      "Shell": 3767,
      "Jinja": 2085
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:48:03.651308"
  }
}