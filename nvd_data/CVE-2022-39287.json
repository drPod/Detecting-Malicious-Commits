{
  "cve_id": "CVE-2022-39287",
  "github_data": {
    "repository": "valexandersaulys/tiny-csrf",
    "fix_commit": "8eead6da3b56e290512bbe8d20c2c5df3be317ba",
    "related_commits": [
      "8eead6da3b56e290512bbe8d20c2c5df3be317ba",
      "8eead6da3b56e290512bbe8d20c2c5df3be317ba"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "8eead6da3b56e290512bbe8d20c2c5df3be317ba",
      "commit_date": "2022-10-06T16:10:13Z",
      "author": {
        "login": "valexandersaulys",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Updated to include encrypting cookies, better protection client side",
        "length": 68,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 265,
        "additions": 182,
        "deletions": 83
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 27,
          "deletions": 6,
          "patch": "@@ -4,6 +4,14 @@ This is a tiny csrf library meant to replace what `csurf` used to do\n [before it was deleted](https://github.com/expressjs/csurf). It is\n _almost_ a drop-in replacement.  \n \n+Note that if you require very specific security needs you may want to\n+look elsewhere. This library supports encrypting cookies on the client\n+side to prevent malicious attackers from looking in. It does not\n+protect against things such as [double submit\n+cookies](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie). Those\n+setups require greater setup and more know-how. This library aims to\n+be simple to setup. \n+\n \n \n ## Installation\n@@ -17,11 +25,16 @@ To Use in your app:\n ```javascript\n const csurf = require(\"tiny-csrf\");\n const express = require(\"express\");\n+const session = require(\"express-session\");\n \n let app = express();\n \n+app.use(\n+  session({})\n+);\n app.use(\n   csurf(\n+    \"123456789iamasecret987654321look\",  // secret -- must be 32 bits or chars in length\n     [\"POST\"],    // the request methods we want CSRF protection for\n     [\"/detail\", /\\/detail\\.*/i]  // any URLs we want to exclude, either as strings or regexp\n   )\n@@ -30,13 +43,16 @@ app.use(\n // declare all your other routes and middleware\n ```\n \n-Defaults to only requiring CSRF protection on `POST` requests and\n-excludes no URLs. \n+The secret must be 32 bits (e.g. characters) in length and uses \n+[the built-in `crypto.createCipheriv` library built into Node\n+](https://nodejs.org/api/crypto.html#cryptocreatecipherivalgorithm-key-iv-options). The\n+secret length is enforced by the\n+[`AES-256-CBC`](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n+algorithm. \n \n-This uses the built-in [`crypto`\n-library](https://nodejs.org/api/crypto.html#cryptorandomuuidoptions)\n-for generating CSRF tokens. This may or may not be sufficient for your\n-needs. \n+Defaults to only requiring CSRF protection on `POST`, `PUT`, and `PATCH` requests and\n+excludes no URLs. The csrf will be checked for in the body of a\n+request via `_csrf`. \n \n \n ## Examples\n@@ -68,3 +84,8 @@ app.post(\"/\", (req, res) => {\n   return res.status(200).send(\"Got it!\");\n });\n ```\n+\n+\n+## License\n+\n+[MIT](#)"
        },
        {
          "filename": "encryption.js",
          "status": "added",
          "additions": 57,
          "deletions": 0,
          "patch": "@@ -0,0 +1,57 @@\n+const { randomBytes, createCipheriv, createDecipheriv } = require(\"crypto\");\n+\n+const ALGORITHM = \"aes-256-cbc\";\n+\n+const encryptCookie = (cookie, _secret) => {\n+  /**\n+   * Encrypt a cookie using AES 256 bits\n+   * @param {cookie} string the cookie we want to encrypt. Will be visible as plain string to client.\n+   * @param {_secret} string the secret that will be stored server-side. Client will never see this.\n+   */\n+  const iv = randomBytes(16);\n+  const _cipher = createCipheriv(ALGORITHM, Buffer.from(_secret), iv);\n+  const encrypted = [\n+    iv.toString(\"hex\"),\n+    \":\",\n+    _cipher.update(cookie, \"utf8\", \"hex\"),\n+    _cipher.final(\"hex\")\n+  ];\n+  return encrypted.join(\"\");\n+};\n+\n+const decryptCookie = (cookie, _secret) => {\n+  /**\n+   * Decrypt a cookie using AES 256 bits\n+   * @param {cookie} string the cookie we want to encrypt. Will be visible as plain string to client.\n+   * @param {_secret} string the secret that will be stored server-side. Client will never see this.\n+   */\n+  const _encryptedArray = cookie.split(\":\");\n+  if (_encryptedArray.length != 2) throw new Error(\"bad decrypt\");\n+  const iv = new Buffer(_encryptedArray[0], \"hex\");\n+  const encrypted = new Buffer(_encryptedArray[1], \"hex\");\n+  const decipher = createDecipheriv(ALGORITHM, _secret, iv);\n+  const decrypted =\n+    decipher.update(encrypted, \"hex\", \"utf8\") + decipher.final(\"utf8\");\n+  return decrypted;\n+};\n+\n+const verifyCsrf = (requestCsrf, cookieCsrf, _secret) => {\n+  /**\n+   * Verify a CSRF token\n+   * @param {requestCsrf} string the CSRF coming from client side\n+   * @param {cookieCsrf} string the CSRF as stored in the user's cookies\n+   * @param {_secret} string the string used to encrypt the CSRF in the first place.\n+   */\n+  try {\n+    const decryptedCookie = decryptCookie(cookieCsrf, _secret);\n+    return decryptedCookie === requestCsrf;\n+  } catch (err) {\n+    return false;\n+  }\n+};\n+\n+module.exports = {\n+  encryptCookie,\n+  decryptCookie,\n+  verifyCsrf\n+};"
        },
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 23,
          "deletions": 22,
          "patch": "@@ -1,9 +1,19 @@\n const { randomUUID } = require(\"crypto\");\n+const { encryptCookie, verifyCsrf } = require(\"./encryption\");\n \n-const csurf = (forbiddenMethods, excludedUrls) => {\n-  if (!forbiddenMethods) forbiddenMethods = [\"POST\"];\n+const cookieParams = {\n+  httpOnly: true,\n+  sameSite: \"strict\",\n+  signed: true,\n+  maxAge: 300000\n+};\n+\n+const csurf = (secret, forbiddenMethods, excludedUrls) => {\n+  if (!forbiddenMethods) forbiddenMethods = [\"POST\", \"PUT\", \"PATCH\"];\n+  if (secret.length != 32)\n+    throw new Error(\"Your secret is not the required 32 characters long\");\n   return (req, res, next) => {\n-    if (!req.cookies || !res.cookie)\n+    if (!req.cookies || !res.cookie || !req.signedCookies)\n       throw new Error(\"No Cookie middleware is installed\");\n     if (\n       // if any excludedUrl matches as either string or regexp\n@@ -12,42 +22,33 @@ const csurf = (forbiddenMethods, excludedUrls) => {\n       ).length > 0\n     ) {\n       req.csrfToken = () => {\n-        if (!req.cookies.csrfToken) {\n-          const csrfToken = randomUUID();\n-          res.cookie(\"csrfToken\", csrfToken);\n-          return csrfToken;\n-        }\n-        return req.cookies.csrfToken;\n+        const csrfToken = randomUUID();\n+        res.cookie(\"csrfToken\", encryptCookie(csrfToken, secret), cookieParams);\n+        return csrfToken;\n       };\n       return next();\n     } else if (forbiddenMethods.includes(req.method)) {\n-      const { csrfToken } = req.cookies;\n+      const { csrfToken } = req.signedCookies;\n       if (\n         csrfToken != undefined &&\n-        (req.query._csrf === csrfToken ||\n-          req.params._csrf === csrfToken ||\n-          req.body._csrf === csrfToken)\n+        verifyCsrf(req.body?._csrf, csrfToken, secret)\n       ) {\n-        res.cookie(\"csrfToken\", \"\");\n+        res.cookie(\"csrfToken\", null, cookieParams);\n         return next();\n       } else {\n         throw new Error(\n-          `Did not get a CSRF token for ${req.method} ${req.originalUrl}: ${req.body._csrf} v. ${csrfToken}`\n+          `Did not get a valid CSRF token for '${req.method} ${req.originalUrl}': ${req.body?._csrf} v. ${csrfToken}`\n         );\n       }\n     } else {\n       req.csrfToken = () => {\n-        if (!req.cookies.csrfToken) {\n-          const csrfToken = randomUUID();\n-          res.cookie(\"csrfToken\", csrfToken);\n-          return csrfToken;\n-        }\n-        return req.cookies.csrfToken;\n+        const csrfToken = randomUUID();\n+        res.cookie(\"csrfToken\", encryptCookie(csrfToken, secret), cookieParams);\n+        return csrfToken;\n       };\n       return next();\n     }\n   };\n };\n \n-// module.exports = csurf(forbiddenMethods, excludedUrls);\n module.exports = csurf;"
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"tiny-csrf\",\n-  \"version\": \"1.0.3\",\n+  \"version\": \"1.1.0\",\n   \"description\": \"Tiny CSRF library for use with ExpressJS\",\n   \"main\": \"index.js\",\n   \"scripts\": {"
        },
        {
          "filename": "test.js",
          "status": "modified",
          "additions": 74,
          "deletions": 54,
          "patch": "@@ -3,13 +3,57 @@ const { describe, before, beforeEach, after, afterEach, it } = require(\"mocha\");\n const sinon = require(\"sinon\");\n const { mockRequest, mockResponse } = require(\"mock-req-res\");\n \n+const { randomUUID, randomBytes } = require(\"crypto\");\n const csurf = require(\"./index\");\n+const { encryptCookie, decryptCookie, verifyCsrf } = require(\"./encryption\");\n+\n+describe(\"Cookie Encryption Tests\", () => {\n+  before(() => {});\n+  after(() => {});\n+\n+  it(\"will encrypt and decrypt a cookie\", () => {\n+    // req.cookies.csrfToken =>  will be scrambled\n+    const secret = \"123456789iamasecret987654321look\";\n+    const csrfToken = randomUUID();\n+    const encryptedCsrfToken = encryptCookie(csrfToken, secret);\n+    assert.notEqual(\n+      csrfToken,\n+      encryptedCsrfToken,\n+      \"Both are equal as plain string and shouldn't be\"\n+    );\n+    assert.isTrue(verifyCsrf(csrfToken, encryptedCsrfToken, secret));\n+    assert.isFalse(\n+      verifyCsrf(\n+        csrfToken,\n+        encryptedCsrfToken,\n+        randomBytes(16).toString(\"hex\")\n+      ),\n+      \"Should not be able to verify without the secret\"\n+    );\n+    assert.isFalse(\n+      verifyCsrf(randomUUID(), encryptedCsrfToken, secret),\n+      \"Should not verify random UUID tokens\"\n+    );\n+    assert.isFalse(\n+      verifyCsrf(\"\", encryptedCsrfToken, secret),\n+      \"Should not verify random blank tokens\"\n+    );\n+    assert.isFalse(\n+      verifyCsrf(null, encryptedCsrfToken, secret),\n+      \"Should not verify random null tokens\"\n+    );\n+  });\n+});\n \n describe(\"Default Options Tests\", () => {\n   before(() => {\n-    this.csrf = csurf(null, []);\n+    this.secret = \"123456789iamasecret987654321look\";\n+    this.csrf = csurf(this.secret);\n   });\n \n+  it(\"throw internal error if our secret is not long enough\", () => {\n+    assert.throws(() => csurf(\"imnotlongenough\"));\n+  });\n   it(\"throws internal error if we have no cookies\", () => {\n     const req = mockRequest({\n       cookies: null\n@@ -28,7 +72,7 @@ describe(\"Default Options Tests\", () => {\n   it(\"generates token for non-POST request\", () => {\n     const req = mockRequest({\n       method: \"GET\",\n-      cookies: {},\n+      signedCookies: {},\n       body: {}\n     });\n     const res = mockResponse({\n@@ -46,8 +90,8 @@ describe(\"Default Options Tests\", () => {\n   it(\"allows if the CSRF token is correct\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {\n-        csrfToken: \"aaaa\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaa\", this.secret)\n       },\n       body: {\n         _csrf: \"aaaa\"\n@@ -64,8 +108,8 @@ describe(\"Default Options Tests\", () => {\n   it(\"does not allow if the CSRF token is incorrect\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {\n-        csrfToken: \"aaaabbb\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaabbb\", this.secret)\n       },\n       body: {\n         _csrf: \"aaaa\"\n@@ -80,15 +124,15 @@ describe(\"Default Options Tests\", () => {\n       this.csrf(req, res, next);\n     } catch (err) {\n       assert.equal(err.name, \"Error\");\n-      assert.include(err.message, \"Did not get a CSRF token\");\n+      assert.include(err.message, \"Did not get a valid CSRF token\");\n     }\n     assert.isFalse(next.calledOnce);\n   });\n   it(\"does not allow if the CSRF token is missing in body\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {\n-        csrfToken: \"aaaabbb\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaabbb\", this.secret)\n       },\n       body: {}\n     });\n@@ -101,14 +145,14 @@ describe(\"Default Options Tests\", () => {\n       this.csrf(req, res, next);\n     } catch (err) {\n       assert.equal(err.name, \"Error\");\n-      assert.include(err.message, \"Did not get a CSRF token\");\n+      assert.include(err.message, \"Did not get a valid CSRF token\");\n     }\n     assert.isFalse(next.calledOnce);\n   });\n   it(\"does not allow if the CSRF token was never generated\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {},\n+      signedCookies: {},\n       body: {}\n     });\n     const res = mockResponse({\n@@ -120,44 +164,23 @@ describe(\"Default Options Tests\", () => {\n       this.csrf(req, res, next);\n     } catch (err) {\n       assert.equal(err.name, \"Error\");\n-      assert.include(err.message, \"Did not get a CSRF token\");\n+      assert.include(err.message, \"Did not get a valid CSRF token\");\n     }\n     assert.isFalse(next.calledOnce);\n   });\n-  it(\"will reuse if the CSRF token already exists in a non-POST\", () => {\n-    const req = mockRequest({\n-      method: \"GET\",\n-      cookies: {\n-        csrfToken: \"aaaabc\"\n-      },\n-      body: {}\n-    });\n-    const res = mockResponse({\n-      cookie: sinon.stub()\n-    });\n-    const next = sinon.stub();\n-    assert.isNotFunction(req.csrfToken);\n-    this.csrf(req, res, next);\n-    assert.isTrue(next.calledOnce);\n-    assert.isFunction(\n-      req.csrfToken,\n-      \"Did not attach a csrfToken function to req\"\n-    );\n-    const sampleToken = req.csrfToken();\n-    assert.equal(sampleToken, \"aaaabc\");\n-  });\n });\n \n describe(\"Tests w/Specified Included Request Methods\", () => {\n   before(() => {\n-    this.csrf = csurf([\"POST\", \"PUT\"], []);\n+    this.secret = \"123456789iamasecret987654321look\";\n+    this.csrf = csurf(this.secret, [\"POST\", \"PUT\"], []);\n   });\n \n   it(\"allows if the CSRF token is correct\", () => {\n     const req = mockRequest({\n       method: \"PUT\",\n-      cookies: {\n-        csrfToken: \"aaaa\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaa\", this.secret)\n       },\n       body: {\n         _csrf: \"aaaa\"\n@@ -174,8 +197,8 @@ describe(\"Tests w/Specified Included Request Methods\", () => {\n   it(\"does not allow if the CSRF token is incorrect\", () => {\n     const req = mockRequest({\n       method: \"PUT\",\n-      cookies: {\n-        csrfToken: \"aaaabbb\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaabbb\", this.secret)\n       },\n       body: {\n         _csrf: \"aaaa\"\n@@ -190,15 +213,15 @@ describe(\"Tests w/Specified Included Request Methods\", () => {\n       this.csrf(req, res, next);\n     } catch (err) {\n       assert.equal(err.name, \"Error\");\n-      assert.include(err.message, \"Did not get a CSRF token\");\n+      assert.include(err.message, \"Did not get a valid CSRF token\");\n     }\n     assert.isFalse(next.calledOnce);\n   });\n   it(\"allows if the method is specified as not included\", () => {\n     const req = mockRequest({\n       method: \"GET\",\n-      cookies: {\n-        csrfToken: \"aaaa\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaa\", this.secret)\n       },\n       body: {\n         _csrf: \"\"\n@@ -216,14 +239,15 @@ describe(\"Tests w/Specified Included Request Methods\", () => {\n \n describe(\"Tests w/Specified Excluded URLs\", () => {\n   before(() => {\n-    this.csrf = csurf(null, [\"/detail\", /\\/detail\\.*/i]);\n+    this.secret = \"123456789iamasecret987654321look\";\n+    this.csrf = csurf(this.secret, null, [\"/detail\", /\\/detail\\.*/i]);\n   });\n \n   it(\"allows if the URL is marked as excluded\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {\n-        csrfToken: \"aaaaa\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaaa\", this.secret)\n       },\n       body: {\n         _csrf: \"\"\n@@ -241,14 +265,12 @@ describe(\"Tests w/Specified Excluded URLs\", () => {\n       req.csrfToken,\n       \"Did not add the csrfToken to this request\"\n     );\n-    const sampleToken = req.csrfToken();\n-    assert.equal(sampleToken, \"aaaaa\", \"Not reusing csrf tokens\");\n   });\n   it(\"allows if the URL is marked as excluded as a regexp\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {\n-        csrfToken: \"aaaaa\"\n+      signedCookies: {\n+        csrfToken: encryptCookie(\"aaaaa\", this.secret)\n       },\n       body: {\n         _csrf: \"\"\n@@ -266,13 +288,11 @@ describe(\"Tests w/Specified Excluded URLs\", () => {\n       req.csrfToken,\n       \"Did not add the csrfToken to this request\"\n     );\n-    const sampleToken = req.csrfToken();\n-    assert.equal(sampleToken, \"aaaaa\", \"Not reusing csrf tokens\");\n   });\n   it(\"generates a new token if no token is supplied\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {},\n+      signedCookies: {},\n       body: {\n         _csrf: \"\"\n       },\n@@ -295,7 +315,7 @@ describe(\"Tests w/Specified Excluded URLs\", () => {\n   it(\"does not allow if the CSRF token is incorrect and the URL is not marked as excluded\", () => {\n     const req = mockRequest({\n       method: \"POST\",\n-      cookies: {\n+      signedCookies: {\n         csrfToken: \"aaaabbb\"\n       },\n       body: {\n@@ -312,7 +332,7 @@ describe(\"Tests w/Specified Excluded URLs\", () => {\n       this.csrf(req, res, next);\n     } catch (err) {\n       assert.equal(err.name, \"Error\");\n-      assert.include(err.message, \"Did not get a CSRF token\");\n+      assert.include(err.message, \"Did not get a valid CSRF token\");\n     }\n     assert.isFalse(next.calledOnce);\n   });"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d543a2731a81fb8b3a0849b0be59ecfa6bfb184f",
            "date": "2024-01-19T22:18:39Z",
            "author_login": "valexandersaulys"
          },
          {
            "sha": "3c423decb8250c5c0ae39de152ecbb5af0294cad",
            "date": "2024-01-19T22:12:39Z",
            "author_login": "valexandersaulys"
          },
          {
            "sha": "39e867c93da2802673cac49d902696cfe181ee63",
            "date": "2024-01-19T22:09:16Z",
            "author_login": "valexandersaulys"
          },
          {
            "sha": "b51ef0af5005d9e3d85af96ccca1787e24740667",
            "date": "2024-01-03T07:03:07Z",
            "author_login": "fishbar"
          },
          {
            "sha": "6a463fc0608fe11f1e6e0784a4cdf3c2f692990c",
            "date": "2022-10-15T20:10:21Z",
            "author_login": "valexandersaulys"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-319",
    "description": "tiny-csrf is a Node.js cross site request forgery (CSRF) protection middleware. In versions prior to 1.1.0 cookies were not encrypted and thus CSRF tokens were transmitted in the clear. This issue has been addressed in commit `8eead6d` and the patch with be included in version 1.1.0. Users are advised to upgrade. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-10-07T20:15:15.060",
    "last_modified": "2024-11-21T07:17:57.760",
    "fix_date": "2022-10-06T16:10:13Z"
  },
  "references": [
    {
      "url": "https://github.com/valexandersaulys/tiny-csrf/commit/8eead6da3b56e290512bbe8d20c2c5df3be317ba",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/valexandersaulys/tiny-csrf/security/advisories/GHSA-pj2c-h76w-vv6f",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/valexandersaulys/tiny-csrf/commit/8eead6da3b56e290512bbe8d20c2c5df3be317ba",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/valexandersaulys/tiny-csrf/security/advisories/GHSA-pj2c-h76w-vv6f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.319232",
    "processing_status": "enhanced"
  }
}