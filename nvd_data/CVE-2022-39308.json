{
  "cve_id": "CVE-2022-39308",
  "github_data": {
    "repository": "gocd/gocd",
    "fix_commit": "236d4baf92e6607f2841c151c855adcc477238b8",
    "related_commits": [
      "236d4baf92e6607f2841c151c855adcc477238b8",
      "236d4baf92e6607f2841c151c855adcc477238b8"
    ],
    "patch_url": "https://github.com/gocd/gocd/commit/236d4baf92e6607f2841c151c855adcc477238b8.patch",
    "fix_commit_details": {
      "sha": "236d4baf92e6607f2841c151c855adcc477238b8",
      "commit_date": "2019-02-01T06:08:30Z",
      "author": {
        "login": "GaneshSPatil",
        "type": "User",
        "stats": {
          "total_commits": 1248,
          "average_weekly_commits": 2.1517241379310343,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 184
        }
      },
      "commit_message": {
        "title": "Access Token APIs  (#5797)",
        "length": 1065,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1969,
        "additions": 1969,
        "deletions": 0
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -93,6 +93,9 @@ api/api-admins-config-v2/logs/\n api/api-admins-config-v2/out/\n api/api-admins-config-v2/target/\n api/api-artifact-store-config-v1/config/\n+api/api-access-token-v1/logs/\n+api/api-access-token-v1/out/\n+api/api-access-token-v1/target/\n api/api-artifact-store-config-v1/logs/\n api/api-artifact-store-config-v1/out/\n api/api-artifact-store-config-v1/target/"
        },
        {
          "filename": "api/api-access-token-v1/build.gradle",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+apply plugin: 'jacoco'\n+apply plugin: 'groovy'\n+\n+dependencies {\n+  compile project(':api:api-base')\n+\n+  testCompile project(path: ':api:api-base', configuration: 'testOutput')\n+\n+  testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: project.versions.junit5\n+  testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: project.versions.junit5\n+}"
        },
        {
          "filename": "api/api-access-token-v1/src/main/java/com/thoughtworks/go/apiv1/accessToken/AccessTokenControllerV1.java",
          "status": "added",
          "additions": 135,
          "deletions": 0,
          "patch": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.apiv1.accessToken;\n+\n+import com.thoughtworks.go.api.ApiController;\n+import com.thoughtworks.go.api.ApiVersion;\n+import com.thoughtworks.go.api.representers.JsonReader;\n+import com.thoughtworks.go.api.spring.ApiAuthenticationHelper;\n+import com.thoughtworks.go.api.util.GsonTransformer;\n+import com.thoughtworks.go.apiv1.accessToken.representers.AccessTokenRepresenter;\n+import com.thoughtworks.go.apiv1.accessToken.representers.AccessTokensRepresenter;\n+import com.thoughtworks.go.config.exceptions.RecordNotFoundException;\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.server.newsecurity.models.AuthenticationToken;\n+import com.thoughtworks.go.server.newsecurity.utils.SessionUtils;\n+import com.thoughtworks.go.server.service.AccessTokenService;\n+import com.thoughtworks.go.server.service.result.HttpLocalizedOperationResult;\n+import com.thoughtworks.go.spark.Routes;\n+import com.thoughtworks.go.spark.spring.SparkSpringController;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+import spark.Request;\n+import spark.Response;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static spark.Spark.*;\n+\n+@Component\n+public class AccessTokenControllerV1 extends ApiController implements SparkSpringController {\n+\n+    private final ApiAuthenticationHelper apiAuthenticationHelper;\n+    private AccessTokenService accessTokenService;\n+\n+    @Autowired\n+    public AccessTokenControllerV1(ApiAuthenticationHelper apiAuthenticationHelper, AccessTokenService AccessTokenService) {\n+        super(ApiVersion.v1);\n+        this.apiAuthenticationHelper = apiAuthenticationHelper;\n+        this.accessTokenService = AccessTokenService;\n+    }\n+\n+    @Override\n+    public String controllerBasePath() {\n+        return Routes.AccessToken.BASE;\n+    }\n+\n+    @Override\n+    public void setupRoutes() {\n+        path(controllerBasePath(), () -> {\n+            before(\"\", mimeType, this::setContentType);\n+            before(\"/*\", mimeType, this::setContentType);\n+\n+            before(\"\", mimeType, this.apiAuthenticationHelper::checkUserAnd403);\n+            before(\"/*\", mimeType, this.apiAuthenticationHelper::checkUserAnd403);\n+\n+            get(\"\", mimeType, this::getAllAccessTokens);\n+            post(\"\", mimeType, this::createAccessToken);\n+            patch(String.format(\"%s%s/revoke\", Routes.AccessToken.USERNAME, Routes.AccessToken.TOKEN_NAME), mimeType, this::revokeAccessToken);\n+            get(Routes.AccessToken.TOKEN_NAME, mimeType, this::getAccessToken);\n+\n+            exception(RecordNotFoundException.class, this::notFound);\n+        });\n+    }\n+\n+    public String createAccessToken(Request request, Response response) throws Exception {\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        final JsonReader reader = GsonTransformer.getInstance().jsonReaderFrom(request.body());\n+\n+        String tokenName = reader.getString(\"name\");\n+        String tokenDescription = reader.optString(\"description\").orElse(null);\n+\n+        AccessToken created = accessTokenService.create(tokenName, tokenDescription, currentUsername(), currentUserAuthConfigId(request), result);\n+\n+        if (result.isSuccessful()) {\n+            return renderAccessToken(request, response, created, true);\n+        }\n+\n+        return renderHTTPOperationResult(result, request, response);\n+    }\n+\n+    public String getAccessToken(Request request, Response response) throws Exception {\n+        final AccessToken token = accessTokenService.find(request.params(\"token_name\"), currentUsername().getUsername().toString());\n+\n+        if (token == null) {\n+            throw new RecordNotFoundException();\n+        }\n+\n+        return renderAccessToken(request, response, token, false);\n+    }\n+\n+    public String getAllAccessTokens(Request request, Response response) throws Exception {\n+        List<AccessToken> allTokens = accessTokenService.findAllTokensForUser(currentUsername());\n+        return writerForTopLevelObject(request, response, outputWriter -> AccessTokensRepresenter.toJSON(outputWriter, allTokens));\n+    }\n+\n+    public String revokeAccessToken(Request request, Response response) throws Exception {\n+        String tokenName = request.params(\"token_name\");\n+        String username = request.params(\"username\");\n+\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+        accessTokenService.revokeAccessToken(tokenName, username, result);\n+\n+        if (result.isSuccessful()) {\n+            return renderAccessToken(request, response, accessTokenService.find(tokenName, username), true);\n+        }\n+\n+        return renderHTTPOperationResult(result, request, response);\n+    }\n+\n+    private String renderAccessToken(Request request, Response response, AccessToken token, boolean includeTokenValue) throws IOException {\n+        return writerForTopLevelObject(request, response, outputWriter -> AccessTokenRepresenter.toJSON(outputWriter, token, includeTokenValue));\n+    }\n+\n+    private String currentUserAuthConfigId(Request request) {\n+        AuthenticationToken<?> authenticationToken = SessionUtils.getAuthenticationToken(request.raw());\n+        return authenticationToken.getAuthConfigId();\n+    }\n+\n+}"
        },
        {
          "filename": "api/api-access-token-v1/src/main/java/com/thoughtworks/go/apiv1/accessToken/representers/AccessTokenRepresenter.java",
          "status": "added",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.apiv1.accessToken.representers;\n+\n+import com.thoughtworks.go.api.base.OutputWriter;\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.spark.Routes;\n+\n+public class AccessTokenRepresenter {\n+    public static void toJSON(OutputWriter outputWriter, AccessToken token, boolean includeTokenValue) {\n+        outputWriter.addLinks(linksWriter -> linksWriter\n+                .addLink(\"self\", Routes.AccessToken.name(token.getName()))\n+                .addAbsoluteLink(\"doc\", Routes.AccessToken.DOC)\n+                .addLink(\"find\", Routes.AccessToken.find()));\n+\n+        outputWriter.add(\"name\", token.getName())\n+                .add(\"description\", token.getDescription())\n+                .add(\"auth_config_id\", token.getAuthConfigId())\n+                .addChild(\"_meta\", metaWriter -> {\n+                    metaWriter.add(\"is_revoked\", token.isRevoked())\n+                            .add(\"revoked_at\", token.getRevokedAt())\n+                            .add(\"created_at\", token.getCreatedAt())\n+                            .add(\"last_used_at\", token.getLastUsed());\n+                });\n+\n+        if (includeTokenValue) {\n+            outputWriter.add(\"token\", token.getOriginalValue());\n+        }\n+    }\n+}"
        },
        {
          "filename": "api/api-access-token-v1/src/main/java/com/thoughtworks/go/apiv1/accessToken/representers/AccessTokensRepresenter.java",
          "status": "added",
          "additions": 37,
          "deletions": 0,
          "patch": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.apiv1.accessToken.representers;\n+\n+import com.thoughtworks.go.api.base.OutputWriter;\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.spark.Routes;\n+\n+import java.util.List;\n+\n+public class AccessTokensRepresenter {\n+    public static void toJSON(OutputWriter outputWriter, List<AccessToken> allTokens) {\n+        outputWriter.addLinks(outputLinkWriter -> outputLinkWriter\n+                .addLink(\"self\", Routes.AccessToken.BASE)\n+                .addAbsoluteLink(\"doc\", Routes.AccessToken.DOC))\n+                .addChild(\"_embedded\", embeddedWriter ->\n+                        embeddedWriter.addChildList(\"access_tokens\", AccessTokenWriter -> {\n+                            allTokens.forEach(token -> AccessTokenWriter.addChild(artifactStoreWriter -> AccessTokenRepresenter.toJSON(artifactStoreWriter, token, false)));\n+                        })\n+                );\n+    }\n+}"
        },
        {
          "filename": "api/api-access-token-v1/src/test/groovy/com/thoughtworks/go/apiv1/accessToken/AccessTokenControllerV1Test.groovy",
          "status": "added",
          "additions": 305,
          "deletions": 0,
          "patch": "@@ -0,0 +1,305 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.apiv1.accessToken\n+\n+import com.thoughtworks.go.api.SecurityTestTrait\n+import com.thoughtworks.go.api.spring.ApiAuthenticationHelper\n+import com.thoughtworks.go.api.util.HaltApiMessages\n+import com.thoughtworks.go.apiv1.accessToken.representers.AccessTokenRepresenter\n+import com.thoughtworks.go.apiv1.accessToken.representers.AccessTokensRepresenter\n+import com.thoughtworks.go.server.domain.Username\n+import com.thoughtworks.go.server.service.AccessTokenService\n+import com.thoughtworks.go.server.service.result.HttpLocalizedOperationResult\n+import com.thoughtworks.go.spark.ControllerTrait\n+import com.thoughtworks.go.spark.NormalUserSecurity\n+import com.thoughtworks.go.spark.SecurityServiceTrait\n+import org.junit.jupiter.api.BeforeEach\n+import org.junit.jupiter.api.Nested\n+import org.junit.jupiter.api.Test\n+import org.mockito.Mock\n+import org.mockito.invocation.InvocationOnMock\n+\n+import static com.thoughtworks.go.api.base.JsonUtils.toObjectString\n+import static com.thoughtworks.go.helper.AccessTokenMother.accessTokenWithName\n+import static org.mockito.ArgumentMatchers.any\n+import static org.mockito.ArgumentMatchers.eq\n+import static org.mockito.Mockito.when\n+import static org.mockito.MockitoAnnotations.initMocks\n+\n+class AccessTokenControllerV1Test implements ControllerTrait<AccessTokenControllerV1>, SecurityServiceTrait {\n+  @Mock\n+  AccessTokenService accessTokenService\n+\n+  @BeforeEach\n+  void setUp() {\n+    initMocks(this)\n+  }\n+\n+  @Override\n+  AccessTokenControllerV1 createControllerInstance() {\n+    return new AccessTokenControllerV1(new ApiAuthenticationHelper(securityService, goConfigService), accessTokenService)\n+  }\n+\n+  @Nested\n+  class Show {\n+    def tokenName = \"token1\"\n+    def token = accessTokenWithName(tokenName)\n+\n+    @Nested\n+    class Security implements SecurityTestTrait, NormalUserSecurity {\n+      @BeforeEach\n+      void setUp() {\n+        when(accessTokenService.find(eq(tokenName), any(Username.class))).thenReturn(token)\n+      }\n+\n+      @Override\n+      String getControllerMethodUnderTest() {\n+        return \"getAccessToken\"\n+      }\n+\n+      @Override\n+      void makeHttpCall() {\n+        getWithApiHeader(controller.controllerPath(tokenName))\n+      }\n+    }\n+\n+    @Nested\n+    class AsAdmin {\n+      @BeforeEach\n+      void setUp() {\n+        enableSecurity()\n+        loginAsAdmin()\n+\n+        when(accessTokenService.find(eq(tokenName), any(String.class))).thenReturn(token)\n+      }\n+\n+      @Test\n+      void 'should render the access token'() {\n+        getWithApiHeader(controller.controllerPath(tokenName))\n+\n+        assertThatResponse()\n+          .isOk()\n+          .hasContentType(controller.mimeType)\n+          .hasBody(toObjectString({ AccessTokenRepresenter.toJSON(it, token, false) }))\n+      }\n+\n+      @Test\n+      void 'should render not found when the specified access token does not exists'() {\n+        when(accessTokenService.find(eq(tokenName), any(String.class))).thenReturn(null)\n+\n+        getWithApiHeader(controller.controllerPath(tokenName))\n+\n+        assertThatResponse()\n+          .isNotFound()\n+          .hasJsonMessage(HaltApiMessages.notFoundMessage())\n+          .hasContentType(controller.mimeType)\n+      }\n+    }\n+  }\n+\n+  @Nested\n+  class Create {\n+    def authConfigId = 'authConfigId'\n+    def tokenName = \"token1\"\n+    def token = accessTokenWithName(tokenName)\n+\n+    @Nested\n+    class Security implements SecurityTestTrait, NormalUserSecurity {\n+      @Override\n+      String getControllerMethodUnderTest() {\n+        return \"createAccessToken\"\n+      }\n+\n+      @Override\n+      void makeHttpCall() {\n+        postWithApiHeader(controller.controllerPath(), [:])\n+      }\n+    }\n+\n+    @Nested\n+    class AsAdmin {\n+      @BeforeEach\n+      void setUp() {\n+        enableSecurity()\n+        loginAsAdmin()\n+\n+        when(accessTokenService.create(eq(tokenName), eq(token.description), any(Username.class), eq(authConfigId), any(HttpLocalizedOperationResult.class))).thenReturn(token)\n+      }\n+\n+      @Test\n+      void 'should create a new access token'() {\n+        def requestBody = [\n+          name       : token.name,\n+          description: token.description\n+        ]\n+\n+        postWithApiHeader(controller.controllerPath(), requestBody)\n+\n+        assertThatResponse()\n+          .isOk()\n+          .hasContentType(controller.mimeType)\n+          .hasBody(toObjectString({ AccessTokenRepresenter.toJSON(it, token, true) }))\n+      }\n+\n+      @Test\n+      void 'should create a new access token without providing token description'() {\n+        token.setDescription(null)\n+        when(accessTokenService.create(eq(tokenName), eq(token.description), any(Username.class), eq(authConfigId), any(HttpLocalizedOperationResult.class))).thenReturn(token)\n+\n+        def requestBody = [\n+          name: token.name\n+        ]\n+\n+        postWithApiHeader(controller.controllerPath(), requestBody)\n+\n+        assertThatResponse()\n+          .isOk()\n+          .hasContentType(controller.mimeType)\n+          .hasBody(toObjectString({ AccessTokenRepresenter.toJSON(it, token, true) }))\n+      }\n+\n+      @Test\n+      void 'should fail to create a new access token when no token name is specified'() {\n+        def requestBody = [\n+          no_name: token.name\n+        ]\n+\n+        postWithApiHeader(controller.controllerPath(), requestBody)\n+\n+        assertThatResponse()\n+          .isUnprocessableEntity()\n+      }\n+\n+      @Test\n+      void 'should show errors occurred while creating a new access token'() {\n+        when(accessTokenService.create(eq(tokenName), eq(token.description), any(Username.class), eq(authConfigId), any(HttpLocalizedOperationResult.class))).then({ InvocationOnMock invocation ->\n+          HttpLocalizedOperationResult result = invocation.getArguments().last() as HttpLocalizedOperationResult\n+          result.unprocessableEntity(\"Boom!\")\n+        })\n+\n+        def requestBody = [\n+          name       : token.name,\n+          description: token.description\n+        ]\n+\n+        postWithApiHeader(controller.controllerPath(), requestBody)\n+\n+        assertThatResponse()\n+          .isUnprocessableEntity()\n+          .hasJsonMessage(\"Boom!\")\n+      }\n+    }\n+  }\n+\n+  @Nested\n+  class Index {\n+    def token = accessTokenWithName(\"token1\")\n+\n+    @Nested\n+    class Security implements SecurityTestTrait, NormalUserSecurity {\n+      @BeforeEach\n+      void setUp() {\n+        when(accessTokenService.findAllTokensForUser(any(Username.class))).thenReturn([token])\n+      }\n+\n+      @Override\n+      String getControllerMethodUnderTest() {\n+        return \"getAllAccessTokens\"\n+      }\n+\n+      @Override\n+      void makeHttpCall() {\n+        getWithApiHeader(controller.controllerPath())\n+      }\n+    }\n+\n+    @Nested\n+    class AsAdmin {\n+      @BeforeEach\n+      void setUp() {\n+        enableSecurity()\n+        loginAsAdmin()\n+\n+        when(accessTokenService.findAllTokensForUser(any(Username.class))).thenReturn([token])\n+      }\n+\n+      @Test\n+      void 'should render all the access tokens'() {\n+        getWithApiHeader(controller.controllerPath())\n+\n+        assertThatResponse()\n+          .isOk()\n+          .hasContentType(controller.mimeType)\n+          .hasBody(toObjectString({ AccessTokensRepresenter.toJSON(it, [token]) }))\n+      }\n+    }\n+  }\n+\n+  @Nested\n+  class Revoke {\n+    def tokenName = \"token1\"\n+    def userName = \"bob\"\n+    def token = accessTokenWithName(tokenName)\n+\n+    @Nested\n+    class Security implements SecurityTestTrait, NormalUserSecurity {\n+      @Override\n+      String getControllerMethodUnderTest() {\n+        return \"revokeAccessToken\"\n+      }\n+\n+      @Override\n+      void makeHttpCall() {\n+        patchWithApiHeader(controller.controllerPath(userName, tokenName, 'revoke'), [:])\n+      }\n+    }\n+\n+    @Nested\n+    class AsAdmin {\n+      @BeforeEach\n+      void setUp() {\n+        enableSecurity()\n+        loginAsAdmin()\n+      }\n+\n+      @Test\n+      void 'should revoke the access token'() {\n+        when(accessTokenService.find(tokenName, userName)).thenReturn(token)\n+        patchWithApiHeader(controller.controllerPath(userName, tokenName, 'revoke'), [:])\n+\n+        assertThatResponse()\n+          .isOk()\n+          .hasContentType(controller.mimeType)\n+          .hasBody(toObjectString({ AccessTokenRepresenter.toJSON(it, token, true) }))\n+      }\n+\n+      @Test\n+      void 'should show errors occurred while revoking a new access token'() {\n+        when(accessTokenService.revokeAccessToken(eq(tokenName) as String, eq(userName) as String, any() as HttpLocalizedOperationResult)).then({ InvocationOnMock invocation ->\n+          HttpLocalizedOperationResult result = invocation.getArguments().last() as HttpLocalizedOperationResult\n+          result.unprocessableEntity(\"Boom!\")\n+        })\n+\n+        patchWithApiHeader(controller.controllerPath(userName, tokenName, 'revoke'), [:])\n+\n+        assertThatResponse()\n+          .isUnprocessableEntity()\n+          .hasJsonMessage(\"Boom!\")\n+      }\n+    }\n+  }\n+}"
        },
        {
          "filename": "api/api-access-token-v1/src/test/groovy/com/thoughtworks/go/apiv1/accessToken/representers/AccessTokenRepresenterTest.groovy",
          "status": "added",
          "additions": 97,
          "deletions": 0,
          "patch": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.apiv1.accessToken.representers\n+\n+\n+import org.junit.jupiter.api.Test\n+\n+import static com.thoughtworks.go.CurrentGoCDVersion.apiDocsUrl\n+import static com.thoughtworks.go.api.base.JsonOutputWriter.jsonDate\n+import static com.thoughtworks.go.api.base.JsonUtils.toObjectString\n+import static com.thoughtworks.go.helper.AccessTokenMother.accessTokenWithName\n+import static net.javacrumbs.jsonunit.fluent.JsonFluentAssert.assertThatJson\n+\n+class AccessTokenRepresenterTest {\n+  @Test\n+  void 'renders the access token hal representation with token value'() {\n+    def token = accessTokenWithName(\"token1\")\n+\n+    def json = toObjectString({\n+      AccessTokenRepresenter.toJSON(it, token, true)\n+    })\n+\n+    def expectedJSON = [\n+      \"_links\"        : [\n+        \"self\": [\n+          \"href\": \"http://test.host/go/api/access_token/token1\"\n+        ],\n+        \"doc\" : [\n+          \"href\": apiDocsUrl('#access_token')\n+        ],\n+        \"find\": [\n+          \"href\": \"http://test.host/go/api/access_token/:token_name\"\n+        ]\n+      ],\n+      \"name\"          : token.getName(),\n+      \"description\"   : token.getDescription(),\n+      \"auth_config_id\": token.authConfigId,\n+      \"_meta\"         : [\n+        \"is_revoked\"  : token.isRevoked(),\n+        \"revoked_at\"  : null,\n+        \"created_at\"  : jsonDate(token.getCreatedAt()),\n+        \"last_used_at\": null\n+      ],\n+      \"token\"         : token.getOriginalValue()\n+    ]\n+\n+    assertThatJson(json).isEqualTo(expectedJSON)\n+  }\n+\n+  @Test\n+  void 'renders the access token metadata hal representation without token value'() {\n+    def token = accessTokenWithName(\"token1\")\n+\n+    def json = toObjectString({\n+      AccessTokenRepresenter.toJSON(it, token, false)\n+    })\n+\n+    def expectedJSON = [\n+      \"_links\"        : [\n+        \"self\": [\n+          \"href\": \"http://test.host/go/api/access_token/token1\"\n+        ],\n+        \"doc\" : [\n+          \"href\": apiDocsUrl('#access_token')\n+        ],\n+        \"find\": [\n+          \"href\": \"http://test.host/go/api/access_token/:token_name\"\n+        ]\n+      ],\n+      \"name\"          : token.getName(),\n+      \"description\"   : token.getDescription(),\n+      \"auth_config_id\": token.authConfigId,\n+      \"_meta\"         : [\n+        \"is_revoked\"  : token.isRevoked(),\n+        \"revoked_at\"  : null,\n+        \"created_at\"  : jsonDate(token.getCreatedAt()),\n+        \"last_used_at\": null\n+      ]\n+    ]\n+\n+    assertThatJson(json).isEqualTo(expectedJSON)\n+  }\n+}"
        },
        {
          "filename": "api/api-access-token-v1/src/test/groovy/com/thoughtworks/go/apiv1/accessToken/representers/AccessTokensRepresenterTest.groovy",
          "status": "added",
          "additions": 99,
          "deletions": 0,
          "patch": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.apiv1.accessToken.representers\n+\n+\n+import org.junit.jupiter.api.Test\n+\n+import static com.thoughtworks.go.CurrentGoCDVersion.apiDocsUrl\n+import static com.thoughtworks.go.api.base.JsonOutputWriter.jsonDate\n+import static com.thoughtworks.go.api.base.JsonUtils.toObjectString\n+import static com.thoughtworks.go.helper.AccessTokenMother.accessTokenWithName\n+import static net.javacrumbs.jsonunit.fluent.JsonFluentAssert.assertThatJson\n+\n+class AccessTokensRepresenterTest {\n+  @Test\n+  void 'renders the access tokens hal representation without token value'() {\n+    def token1 = accessTokenWithName(\"token1\")\n+    def token2 = accessTokenWithName(\"token2\")\n+\n+    def json = toObjectString({\n+      AccessTokensRepresenter.toJSON(it, [token1, token2])\n+    })\n+\n+    def expectedJSON = [\n+      \"_links\"   : [\n+        \"self\": [\n+          \"href\": \"http://test.host/go/api/access_token\"\n+        ],\n+        \"doc\" : [\n+          \"href\": apiDocsUrl('#access_token')\n+        ],\n+      ],\n+      \"_embedded\": [\n+        \"access_tokens\": [\n+          [\n+            \"_links\"        : [\n+              \"self\": [\n+                \"href\": \"http://test.host/go/api/access_token/token1\"\n+              ],\n+              \"doc\" : [\n+                \"href\": apiDocsUrl('#access_token')\n+              ],\n+              \"find\": [\n+                \"href\": \"http://test.host/go/api/access_token/:token_name\"\n+              ]\n+            ],\n+            \"name\"          : token1.getName(),\n+            \"description\"   : token1.getDescription(),\n+            \"auth_config_id\": token1.authConfigId,\n+            \"_meta\"         : [\n+              \"is_revoked\"  : token1.isRevoked(),\n+              \"revoked_at\"  : null,\n+              \"created_at\"  : jsonDate(token1.getCreatedAt()),\n+              \"last_used_at\": null\n+            ]\n+          ],\n+          [\n+            \"_links\"        : [\n+              \"self\": [\n+                \"href\": \"http://test.host/go/api/access_token/token2\"\n+              ],\n+              \"doc\" : [\n+                \"href\": apiDocsUrl('#access_token')\n+              ],\n+              \"find\": [\n+                \"href\": \"http://test.host/go/api/access_token/:token_name\"\n+              ]\n+            ],\n+            \"name\"          : token2.getName(),\n+            \"description\"   : token2.getDescription(),\n+            \"auth_config_id\": token2.authConfigId,\n+            \"_meta\"         : [\n+              \"is_revoked\"  : token2.isRevoked(),\n+              \"revoked_at\"  : null,\n+              \"created_at\"  : jsonDate(token2.getCreatedAt()),\n+              \"last_used_at\": null\n+            ]\n+          ]\n+        ]\n+      ]\n+    ]\n+\n+    assertThatJson(json).isEqualTo(expectedJSON)\n+  }\n+}"
        },
        {
          "filename": "common/src/main/java/com/thoughtworks/go/domain/AccessToken.java",
          "status": "added",
          "additions": 200,
          "deletions": 0,
          "patch": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.domain;\n+\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.Objects;\n+\n+public class AccessToken extends PersistentObject {\n+    private String name;\n+    //this is the hashed token value\n+    private String value;\n+    private String originalValue;\n+    private String description;\n+    private Boolean isRevoked = false;\n+    private Timestamp revokedAt;\n+    private Timestamp createdAt;\n+    private Timestamp lastUsed;\n+    private String username;\n+    private String saltId;\n+    private String saltValue;\n+    private String authConfigId;\n+\n+    public AccessToken() {\n+    }\n+\n+    public AccessToken(String name, String value) {\n+        this.name = name;\n+        this.value = value;\n+    }\n+\n+    public AccessToken(String name, String value, String description) {\n+        this(name, value);\n+        this.description = description;\n+    }\n+\n+    public AccessToken(String name, String value, String description, Boolean isRevoked) {\n+        this(name, value, description);\n+        this.isRevoked = isRevoked;\n+    }\n+\n+    public AccessToken(String name, String value, String description, Boolean isRevoked, Date createdAt, Date lastUsed) {\n+        this(name, value, description, isRevoked);\n+        this.createdAt = new Timestamp(createdAt.getTime());\n+        setLastUsed(lastUsed);\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public void setValue(String value) {\n+        this.value = value;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.description = description;\n+    }\n+\n+    public Boolean isRevoked() {\n+        return isRevoked;\n+    }\n+\n+    public void setRevoked(Boolean revoked) {\n+        isRevoked = revoked;\n+    }\n+\n+    public Date getLastUsed() {\n+        return lastUsed;\n+    }\n+\n+    public void setLastUsed(Date lastUsed) {\n+        this.lastUsed = lastUsed != null ? new Timestamp(lastUsed.getTime()) : null;\n+    }\n+\n+    public Date getCreatedAt() {\n+        return createdAt;\n+    }\n+\n+    public void setCreatedAt(Date createdAt) {\n+        this.createdAt = new Timestamp(createdAt.getTime());\n+    }\n+\n+    public String getOriginalValue() {\n+        return originalValue;\n+    }\n+\n+    public void setOriginalValue(String originalValue) {\n+        this.originalValue = originalValue;\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public void setUsername(String username) {\n+        this.username = username;\n+    }\n+\n+    public Timestamp getRevokedAt() {\n+        return revokedAt;\n+    }\n+\n+    public void setRevokedAt(Timestamp revokedAt) {\n+        this.revokedAt = revokedAt;\n+    }\n+\n+    public String getSaltId() {\n+        return saltId;\n+    }\n+\n+    public void setSaltId(String saltId) {\n+        this.saltId = saltId;\n+    }\n+\n+    public String getSaltValue() {\n+        return saltValue;\n+    }\n+\n+    public void setSaltValue(String saltValue) {\n+        this.saltValue = saltValue;\n+    }\n+\n+    public String getAuthConfigId() {\n+        return authConfigId;\n+    }\n+\n+    public void setAuthConfigId(String authConfigId) {\n+        this.authConfigId = authConfigId;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+        AccessToken accessToken = (AccessToken) o;\n+        return Objects.equals(name, accessToken.name) &&\n+                Objects.equals(value, accessToken.value) &&\n+                Objects.equals(originalValue, accessToken.originalValue) &&\n+                Objects.equals(description, accessToken.description) &&\n+                Objects.equals(isRevoked, accessToken.isRevoked) &&\n+                Objects.equals(revokedAt, accessToken.revokedAt) &&\n+                Objects.equals(createdAt, accessToken.createdAt) &&\n+                Objects.equals(lastUsed, accessToken.lastUsed) &&\n+                Objects.equals(username, accessToken.username) &&\n+                Objects.equals(saltId, accessToken.saltId) &&\n+                Objects.equals(saltValue, accessToken.saltValue) &&\n+                Objects.equals(authConfigId, accessToken.authConfigId);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), name, value, originalValue, description, isRevoked, revokedAt, createdAt, lastUsed, username, saltId, saltValue, authConfigId);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"AccessToken{\" +\n+                \"name='\" + name + '\\'' +\n+                \", value='\" + value + '\\'' +\n+                \", originalValue='\" + originalValue + '\\'' +\n+                \", description='\" + description + '\\'' +\n+                \", isRevoked=\" + isRevoked +\n+                \", revokedAt=\" + revokedAt +\n+                \", createdAt=\" + createdAt +\n+                \", lastUsed=\" + lastUsed +\n+                \", username='\" + username + '\\'' +\n+                \", saltId='\" + saltId + '\\'' +\n+                \", saltValue='\" + saltValue + '\\'' +\n+                \", authConfigId='\" + authConfigId + '\\'' +\n+                '}';\n+    }\n+}"
        },
        {
          "filename": "common/src/test/java/com/thoughtworks/go/helper/AccessTokenMother.java",
          "status": "added",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.helper;\n+\n+import com.thoughtworks.go.domain.AccessToken;\n+import org.apache.commons.lang3.RandomStringUtils;\n+\n+import java.util.Date;\n+\n+public class AccessTokenMother {\n+    public static AccessToken accessTokenWithName(String tokenName) {\n+        String tokenValue = RandomStringUtils.randomAlphanumeric(32).toUpperCase();\n+        String tokenDescription = RandomStringUtils.randomAlphanumeric(512).toUpperCase();\n+        String saltId = RandomStringUtils.randomAlphanumeric(8).toUpperCase();\n+        String saltValue = RandomStringUtils.randomAlphanumeric(255).toUpperCase();\n+        String authConfigId = RandomStringUtils.randomAlphanumeric(255).toUpperCase();\n+\n+        AccessToken accessToken = new AccessToken(tokenName, tokenValue, tokenDescription, false, new Date(), null);\n+        accessToken.setSaltId(saltId);\n+        accessToken.setSaltValue(saltValue);\n+        accessToken.setAuthConfigId(authConfigId);\n+        accessToken.setUsername(\"Bob\");\n+\n+        return accessToken;\n+    }\n+\n+    public static AccessToken accessTokenWithNameForUser(String tokenName, String username) {\n+        AccessToken accessToken = accessTokenWithName(tokenName);\n+        accessToken.setUsername(username);\n+\n+        return accessToken;\n+    }\n+}"
        },
        {
          "filename": "server/config/cruise-config.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -14,6 +14,7 @@\n         <role name=\"xyz\" />\n       </roles>\n       <admins>\n+        <user>jez</user>\n         <user>admin</user>\n       </admins>\n     </security>"
        },
        {
          "filename": "server/db/migrate/h2deltas/1902002_add_access_token.sql",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+--*************************GO-LICENSE-START*********************************\n+-- Copyright 2014 ThoughtWorks, Inc.\n+--\n+-- Licensed under the Apache License, Version 2.0 (the \"License\");\n+-- you may not use this file except in compliance with the License.\n+-- You may obtain a copy of the License at\n+--\n+--    http://www.apache.org/licenses/LICENSE-2.0\n+--\n+-- Unless required by applicable law or agreed to in writing, software\n+-- distributed under the License is distributed on an \"AS IS\" BASIS,\n+-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+-- See the License for the specific language governing permissions and\n+-- limitations under the License.\n+--*************************GO-LICENSE-END***********************************\n+\n+CREATE TABLE AccessToken (\n+id             BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY,\n+name           VARCHAR_IGNORECASE(255) NOT NULL,\n+value          VARCHAR(255) UNIQUE NOT NULL,\n+saltId         VARCHAR(8) UNIQUE NOT NULL,\n+saltValue      VARCHAR(255) UNIQUE NOT NULL,\n+description    VARCHAR(1024),\n+isRevoked      BOOLEAN,\n+revokedAt      TIMESTAMP,\n+createdAt      TIMESTAMP,\n+lastUsed       TIMESTAMP,\n+username       VARCHAR_IGNORECASE(255) NOT NULL,\n+authConfigId   VARCHAR_IGNORECASE(255) NOT NULL\n+);\n+\n+--//@UNDO\n+DROP TABLE IF EXISTS AccessToken;"
        },
        {
          "filename": "server/src/main/java/com/thoughtworks/go/server/dao/AccessTokenDao.java",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.dao;\n+\n+import com.thoughtworks.go.domain.AccessToken;\n+\n+import java.util.List;\n+\n+public interface AccessTokenDao {\n+    void saveOrUpdate(AccessToken accessToken);\n+\n+    AccessToken findAccessToken(String name, String username);\n+\n+    AccessToken load(long id);\n+\n+    void deleteAll();\n+\n+    List<AccessToken> findAllTokensForUser(String toString);\n+\n+    AccessToken findAccessTokenBySaltId(String saltId);\n+}"
        },
        {
          "filename": "server/src/main/java/com/thoughtworks/go/server/dao/AccessTokenSqlMapDao.java",
          "status": "added",
          "additions": 96,
          "deletions": 0,
          "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.dao;\n+\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.server.transaction.TransactionTemplate;\n+import org.hibernate.Query;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.criterion.Restrictions;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.orm.hibernate3.support.HibernateDaoSupport;\n+import org.springframework.stereotype.Component;\n+import org.springframework.transaction.TransactionStatus;\n+import org.springframework.transaction.support.TransactionCallback;\n+import org.springframework.transaction.support.TransactionCallbackWithoutResult;\n+\n+import java.util.List;\n+\n+@Component\n+public class AccessTokenSqlMapDao extends HibernateDaoSupport implements AccessTokenDao {\n+    private SessionFactory sessionFactory;\n+    private TransactionTemplate transactionTemplate;\n+\n+    @Autowired\n+    public AccessTokenSqlMapDao(SessionFactory sessionFactory,\n+                                TransactionTemplate transactionTemplate) {\n+        this.sessionFactory = sessionFactory;\n+        this.transactionTemplate = transactionTemplate;\n+        setSessionFactory(sessionFactory);\n+    }\n+\n+    public void saveOrUpdate(final AccessToken accessToken) {\n+        transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n+            @Override\n+            protected void doInTransactionWithoutResult(TransactionStatus status) {\n+                sessionFactory.getCurrentSession().saveOrUpdate(accessToken);\n+            }\n+        });\n+    }\n+\n+    public AccessToken findAccessToken(final String tokenName, String username) {\n+        return (AccessToken) transactionTemplate.execute((TransactionCallback) transactionStatus ->\n+                sessionFactory.getCurrentSession()\n+                        .createCriteria(AccessToken.class)\n+                        .add(Restrictions.eq(\"name\", tokenName))\n+                        .add(Restrictions.eq(\"username\", username))\n+                        .setCacheable(true).uniqueResult());\n+    }\n+\n+    @Override\n+    public List<AccessToken> findAllTokensForUser(String username) {\n+        return (List<AccessToken>) transactionTemplate.execute((TransactionCallback) transactionStatus -> {\n+            Query query = sessionFactory.getCurrentSession().createQuery(\"FROM AccessToken where username = :username\");\n+            query.setString(\"username\", username);\n+            query.setCacheable(true);\n+            return query.list();\n+        });\n+    }\n+\n+    @Override\n+    public AccessToken findAccessTokenBySaltId(String saltId) {\n+        return (AccessToken) transactionTemplate.execute((TransactionCallback) transactionStatus ->\n+                sessionFactory.getCurrentSession()\n+                        .createCriteria(AccessToken.class)\n+                        .add(Restrictions.eq(\"saltId\", saltId))\n+                        .setCacheable(true).uniqueResult());\n+    }\n+\n+    public AccessToken load(final long id) {\n+        return (AccessToken) transactionTemplate.execute((TransactionCallback) transactionStatus -> sessionFactory.getCurrentSession().get(AccessToken.class, id));\n+    }\n+\n+    // Used only by tests\n+    public void deleteAll() {\n+        transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n+            @Override\n+            protected void doInTransactionWithoutResult(TransactionStatus status) {\n+                sessionFactory.getCurrentSession().createQuery(\"DELETE FROM AccessToken\").executeUpdate();\n+            }\n+        });\n+    }\n+}"
        },
        {
          "filename": "server/src/main/java/com/thoughtworks/go/server/exceptions/InvalidAccessTokenException.java",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.exceptions;\n+\n+public class InvalidAccessTokenException extends RuntimeException {\n+    public InvalidAccessTokenException() {\n+        super(\"Invalid Personal Access Token.\");\n+    }\n+}"
        },
        {
          "filename": "server/src/main/java/com/thoughtworks/go/server/exceptions/RevokedAccessTokenException.java",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.exceptions;\n+\n+import java.sql.Timestamp;\n+\n+public class RevokedAccessTokenException extends RuntimeException {\n+    public RevokedAccessTokenException(Timestamp revokedAt) {\n+        super(String.format(\"Invalid Personal Access Token. Access token was revoked at: %s\", revokedAt));\n+    }\n+}"
        },
        {
          "filename": "server/src/main/java/com/thoughtworks/go/server/service/AccessTokenService.java",
          "status": "added",
          "additions": 172,
          "deletions": 0,
          "patch": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.service;\n+\n+import com.thoughtworks.go.config.validation.NameTypeValidator;\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.server.dao.AccessTokenDao;\n+import com.thoughtworks.go.server.domain.Username;\n+import com.thoughtworks.go.server.exceptions.InvalidAccessTokenException;\n+import com.thoughtworks.go.server.exceptions.RevokedAccessTokenException;\n+import com.thoughtworks.go.server.service.result.HttpLocalizedOperationResult;\n+import org.apache.commons.codec.binary.Base64;\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.security.SecureRandom;\n+import java.sql.Timestamp;\n+import java.util.Date;\n+import java.util.List;\n+\n+@Service\n+public class AccessTokenService {\n+    private static final int DEFAULT_ITERATIONS = 4096;\n+    private static final int DESIRED_KEY_LENGTH = 256;\n+\n+    private static final int SALT_LENGTH = 32;\n+\n+    private AccessTokenDao accessTokenDao;\n+\n+    @Autowired\n+    public AccessTokenService(AccessTokenDao accessTokenDao) {\n+        this.accessTokenDao = accessTokenDao;\n+    }\n+\n+    public AccessToken create(String tokenName, String description, Username username, String authConfigId, HttpLocalizedOperationResult result) throws Exception {\n+        if (!new NameTypeValidator().isNameValid(tokenName)) {\n+            result.unprocessableEntity(NameTypeValidator.errorMessage(\"access token\", tokenName));\n+            return null;\n+        }\n+\n+        if (description != null && description.length() > 1024) {\n+            result.unprocessableEntity(\"Validation Failed. Access token description can not be longer than 1024 characters.\");\n+            return null;\n+        }\n+\n+        if (hasTokenWithNameForTheUser(tokenName, username)) {\n+            result.conflict(String.format(\"Validation Failed. Another access token with name '%s' already exists.\", tokenName));\n+            return null;\n+        }\n+\n+        AccessToken tokenToCreate = generateAccessTokenFor(tokenName, description, username, authConfigId);\n+        accessTokenDao.saveOrUpdate(tokenToCreate);\n+        return tokenToCreate;\n+    }\n+\n+    private boolean hasTokenWithNameForTheUser(String tokenName, Username username) {\n+        return accessTokenDao.findAccessToken(tokenName, username.getUsername().toString()) != null;\n+    }\n+\n+    private AccessToken generateAccessTokenFor(String tokenName, String description, Username username, String authConfigId) throws Exception {\n+        AccessToken accessToken = new AccessToken();\n+\n+        accessToken.setName(tokenName);\n+        accessToken.setDescription(description);\n+        accessToken.setAuthConfigId(authConfigId);\n+        accessToken.setCreatedAt(new Date());\n+\n+        String originalToken = generateSecureRandomString(16);\n+        String saltId = generateSecureRandomString(4);\n+        String saltValue = generateSalt();\n+        String hashedToken = digestToken(originalToken, saltValue);\n+        String finalTokenValue = String.format(\"%s%s\", saltId, originalToken);\n+\n+        accessToken.setOriginalValue(finalTokenValue);\n+        accessToken.setSaltId(saltId);\n+        accessToken.setSaltValue(saltValue);\n+        accessToken.setValue(hashedToken);\n+\n+        accessToken.setUsername(username.getUsername().toString());\n+\n+        return accessToken;\n+    }\n+\n+    String digestToken(String originalToken, String salt) throws Exception {\n+        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n+        SecretKey key = factory.generateSecret(new PBEKeySpec(originalToken.toCharArray(), salt.getBytes(), DEFAULT_ITERATIONS, DESIRED_KEY_LENGTH));\n+        return Hex.encodeHexString(key.getEncoded());\n+    }\n+\n+    private String generateSecureRandomString(int byteLength) {\n+        byte[] randomBytes = new byte[byteLength];\n+        new SecureRandom().nextBytes(randomBytes);\n+        return Hex.encodeHexString(randomBytes);\n+    }\n+\n+    private static String generateSalt() throws Exception {\n+        return Base64.encodeBase64String(SecureRandom.getInstance(\"SHA1PRNG\").generateSeed(SALT_LENGTH));\n+    }\n+\n+    public AccessToken find(String tokenName, String username) {\n+        return accessTokenDao.findAccessToken(tokenName, username);\n+    }\n+\n+    public AccessToken findByAccessToken(String actualToken) throws Exception {\n+        if (actualToken.length() != 40) {\n+            throw new InvalidAccessTokenException();\n+        }\n+\n+        String saltId = StringUtils.substring(actualToken, 0, 8);\n+        String originalToken = StringUtils.substring(actualToken, 8);\n+\n+        AccessToken token = accessTokenDao.findAccessTokenBySaltId(saltId);\n+        if (token == null) {\n+            throw new InvalidAccessTokenException();\n+        }\n+\n+        String saltValue = token.getSaltValue();\n+        String digestOfUserProvidedToken = digestToken(originalToken, saltValue);\n+\n+        if (!token.getValue().equals(digestOfUserProvidedToken)) {\n+            throw new InvalidAccessTokenException();\n+        }\n+\n+        if (token.isRevoked()) {\n+            throw new RevokedAccessTokenException(token.getRevokedAt());\n+        }\n+\n+        return token;\n+    }\n+\n+    public void revokeAccessToken(String name, String username, HttpLocalizedOperationResult result) {\n+        AccessToken fetchedAccessToken = accessTokenDao.findAccessToken(name, username);\n+\n+        if (fetchedAccessToken == null) {\n+            result.unprocessableEntity(String.format(\"Validation Failed. Access Token with name '%s' for user '%s' does not exists.\", name, username));\n+            return;\n+        }\n+\n+        if (fetchedAccessToken.isRevoked()) {\n+            result.unprocessableEntity(String.format(\"Validation Failed. Access Token with name '%s' for user '%s' has already been revoked.\", name, username));\n+            return;\n+        }\n+\n+        fetchedAccessToken.setRevoked(true);\n+        fetchedAccessToken.setRevokedAt(new Timestamp(System.currentTimeMillis()));\n+\n+        accessTokenDao.saveOrUpdate(fetchedAccessToken);\n+    }\n+\n+    public List<AccessToken> findAllTokensForUser(Username username) {\n+        return accessTokenDao.findAllTokensForUser(username.getUsername().toString());\n+    }\n+}"
        },
        {
          "filename": "server/src/main/resources/hibernate-mappings/AccessToken.hbm.xml",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+<?xml version=\"1.0\"?>\n+<!--\n+  ~ Copyright 2019 ThoughtWorks, Inc.\n+  ~\n+  ~ Licensed under the Apache License, Version 2.0 (the \"License\");\n+  ~ you may not use this file except in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~     http://www.apache.org/licenses/LICENSE-2.0\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS,\n+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  ~ See the License for the specific language governing permissions and\n+  ~ limitations under the License.\n+  -->\n+\n+<!DOCTYPE hibernate-mapping PUBLIC\n+    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n+    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n+\n+<hibernate-mapping package=\"com.thoughtworks.go.domain\" default-access=\"field\" default-lazy=\"false\">\n+    <class name=\"AccessToken\" table=\"AccessToken\">\n+        <cache usage=\"read-write\"/>\n+        <id name=\"id\" column=\"id\">\n+            <generator class=\"identity\"/>\n+        </id>\n+        <property name=\"name\"/>\n+        <property name=\"value\"/>\n+        <property name=\"description\"/>\n+        <property name=\"isRevoked\"/>\n+        <property name=\"revokedAt\"/>\n+        <property name=\"createdAt\"/>\n+        <property name=\"lastUsed\"/>\n+        <property name=\"username\"/>\n+        <property name=\"saltId\"/>\n+        <property name=\"saltValue\"/>\n+        <property name=\"authConfigId\"/>\n+    </class>\n+</hibernate-mapping>"
        },
        {
          "filename": "server/src/test-fast/java/com/thoughtworks/go/server/service/AccessTokenServiceTest.java",
          "status": "added",
          "additions": 147,
          "deletions": 0,
          "patch": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.service;\n+\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.server.dao.AccessTokenDao;\n+import com.thoughtworks.go.server.domain.Username;\n+import com.thoughtworks.go.server.service.result.HttpLocalizedOperationResult;\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+\n+class AccessTokenServiceTest {\n+    @Mock\n+    private AccessTokenDao accessTokenDao;\n+    private AccessTokenService accessTokenService;\n+    private HttpLocalizedOperationResult result;\n+    private Username username;\n+    private String authConfigId;\n+\n+    @BeforeEach\n+    void setUp() {\n+        initMocks(this);\n+        accessTokenService = new AccessTokenService(accessTokenDao);\n+        result = new HttpLocalizedOperationResult();\n+\n+        username = new Username(\"Bob\");\n+        authConfigId = \"auth-config-1\";\n+    }\n+\n+    @Test\n+    void shouldValidateAccessTokenName() throws Exception {\n+        String invalidTokenName = \"@#my_%_fancy_%_token#@\";\n+        accessTokenService.create(invalidTokenName, null, username, authConfigId, result);\n+\n+        assertThat(result.isSuccessful()).isFalse();\n+        assertThat(result.httpCode()).isEqualTo(422);\n+        assertThat(result.message()).isEqualTo(String.format(\"Invalid access token name '%s'. This must be alphanumeric and can contain underscores and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\", invalidTokenName));\n+\n+        verifyNoMoreInteractions(accessTokenDao);\n+    }\n+\n+    @Test\n+    void shouldValidateAccessTokenDescription() throws Exception {\n+        String tokenName = \"token1\";\n+        String longerDescription = RandomStringUtils.randomAlphanumeric(1025).toUpperCase();\n+        accessTokenService.create(tokenName, longerDescription, username, authConfigId, result);\n+\n+        assertThat(result.isSuccessful()).isFalse();\n+        assertThat(result.httpCode()).isEqualTo(422);\n+        assertThat(result.message()).isEqualTo(\"Validation Failed. Access token description can not be longer than 1024 characters.\");\n+\n+        verifyNoMoreInteractions(accessTokenDao);\n+    }\n+\n+    @Test\n+    void shouldMakeACallToSQLDaoForAccessTokenCreation() throws Exception {\n+        String tokenName = \"token1\";\n+        String longerDescription = RandomStringUtils.randomAlphanumeric(1024).toUpperCase();\n+        accessTokenService.create(tokenName, longerDescription, username, authConfigId, result);\n+\n+        assertThat(result.isSuccessful()).isTrue();\n+\n+        verify(accessTokenDao, times(1)).saveOrUpdate(any(AccessToken.class));\n+    }\n+\n+    @Test\n+    void shouldMakeACallToSQLDaoForFetchingAccessToken() {\n+        String tokenName = \"token1\";\n+        accessTokenService.find(tokenName, username.getUsername().toString());\n+\n+        verify(accessTokenDao, times(1)).findAccessToken(tokenName, username.getUsername().toString());\n+        verifyNoMoreInteractions(accessTokenDao);\n+    }\n+\n+    @Test\n+    void shouldMakeACallToSQLDaoForFetchingAllAccessTokensBelongingToAUser() {\n+        accessTokenService.findAllTokensForUser(username);\n+\n+        verify(accessTokenDao, times(1)).findAllTokensForUser(username.getUsername().toString());\n+        verifyNoMoreInteractions(accessTokenDao);\n+    }\n+\n+    @Test\n+    void shouldValidateExistenceOfAnotherAccessTokenWithTheSameName() throws Exception {\n+        String tokenName = \"token1\";\n+        String longerDescription = RandomStringUtils.randomAlphanumeric(1024).toUpperCase();\n+\n+        when(accessTokenDao.findAccessToken(tokenName, username.getUsername().toString())).thenReturn(new AccessToken(tokenName, \"value\"));\n+\n+        accessTokenService.create(tokenName, longerDescription, username, authConfigId, result);\n+\n+        assertThat(result.isSuccessful()).isFalse();\n+        assertThat(result.httpCode()).isEqualTo(409);\n+        assertThat(result.message()).isEqualTo(\"Validation Failed. Another access token with name 'token1' already exists.\");\n+\n+        verify(accessTokenDao, times(1)).findAccessToken(tokenName, username.getUsername().toString());\n+        verifyNoMoreInteractions(accessTokenDao);\n+    }\n+\n+    @Test\n+    void hashToken_shouldHashTheProvidedString() throws Exception {\n+        String tokenValue = \"token1\";\n+        String saltValue = \"salt1\";\n+        String hashed = accessTokenService.digestToken(tokenValue, saltValue);\n+\n+        SecretKey key = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\")\n+                .generateSecret(new PBEKeySpec(tokenValue.toCharArray(), saltValue.getBytes(), 4096, 256));\n+\n+        assertThat(hashed).isEqualTo(Hex.encodeHexString(key.getEncoded()));\n+    }\n+\n+    @Test\n+    void hashToken_shouldGenerateTheSameHashValueForTheSameInputString() throws Exception {\n+        String tokenValue = \"new-token\";\n+        String saltValue = \"new-salt\";\n+        String hashed1 = accessTokenService.digestToken(tokenValue, saltValue);\n+        String hashed2 = accessTokenService.digestToken(tokenValue, saltValue);\n+\n+        assertThat(hashed1).isEqualTo(hashed2);\n+    }\n+}"
        },
        {
          "filename": "server/src/test-integration/java/com/thoughtworks/go/server/dao/AccessTokenSqlMapDaoIntegrationTest.java",
          "status": "added",
          "additions": 122,
          "deletions": 0,
          "patch": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.dao;\n+\n+import com.thoughtworks.go.domain.AccessToken;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import java.util.List;\n+\n+import static com.thoughtworks.go.helper.AccessTokenMother.accessTokenWithName;\n+import static com.thoughtworks.go.helper.AccessTokenMother.accessTokenWithNameForUser;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(locations = {\n+        \"classpath:WEB-INF/applicationContext-global.xml\",\n+        \"classpath:WEB-INF/applicationContext-dataLocalAccess.xml\",\n+        \"classpath:testPropertyConfigurer.xml\"\n+})\n+public class AccessTokenSqlMapDaoIntegrationTest {\n+    @Autowired\n+    private AccessTokenSqlMapDao accessTokenSqlMapDao;\n+\n+    @Autowired\n+    private DatabaseAccessHelper dbHelper;\n+\n+    private String username;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        dbHelper.onSetUp();\n+        username = \"Bob\";\n+    }\n+\n+    @After\n+    public void teardown() throws Exception {\n+        accessTokenSqlMapDao.deleteAll();\n+        dbHelper.onTearDown();\n+    }\n+\n+    @Test\n+    public void shouldSaveUsersIntoDatabase() {\n+        String tokenName = \"access-token-for-apis\";\n+        AccessToken accessToken = accessTokenWithName(tokenName);\n+\n+        accessTokenSqlMapDao.saveOrUpdate(accessToken);\n+\n+        AccessToken savedAccessToken = accessTokenSqlMapDao.findAccessToken(tokenName, username);\n+        assertThat(savedAccessToken).isEqualTo(accessToken);\n+        assertThat(accessTokenSqlMapDao.load(savedAccessToken.getId())).isEqualTo(accessToken);\n+    }\n+\n+    @Test\n+    public void shouldReturnNullWhenNoAccessTokenFoundForTheSpecifiedName() {\n+        String tokenName = \"access-token-for-apis\";\n+        AccessToken savedAccessToken = accessTokenSqlMapDao.findAccessToken(tokenName, username);\n+        assertThat(savedAccessToken).isNull();\n+    }\n+\n+    @Test\n+    public void shouldReturnAllTheAccessTokensBelongingToAUser() {\n+        String user1 = \"Bob\";\n+        String user2 = \"John\";\n+\n+        String tokenName1 = \"token1-created-by-Bob\";\n+        String tokenName2 = \"token2-created-by-Bob\";\n+        String tokenName3 = \"token2-created-by-John\";\n+\n+        accessTokenSqlMapDao.saveOrUpdate(accessTokenWithNameForUser(tokenName1, user1));\n+        accessTokenSqlMapDao.saveOrUpdate(accessTokenWithNameForUser(tokenName2, user1));\n+        accessTokenSqlMapDao.saveOrUpdate(accessTokenWithNameForUser(tokenName3, user2));\n+\n+        List<AccessToken> user1AccessTokens = accessTokenSqlMapDao.findAllTokensForUser(user1);\n+        List<AccessToken> user2AccessTokens = accessTokenSqlMapDao.findAllTokensForUser(user2);\n+\n+        assertThat(user1AccessTokens).hasSize(2);\n+        assertThat(user2AccessTokens).hasSize(1);\n+\n+        assertThat(user1AccessTokens.get(0).getName()).isEqualTo(tokenName1);\n+        assertThat(user1AccessTokens.get(1).getName()).isEqualTo(tokenName2);\n+\n+        assertThat(user2AccessTokens.get(0).getName()).isEqualTo(tokenName3);\n+    }\n+\n+    @Test\n+    public void shouldLoadAccessTokenBasedOnSaltId() {\n+        String tokenName = \"access-token-for-apis\";\n+        AccessToken accessToken = accessTokenWithName(tokenName);\n+\n+        accessTokenSqlMapDao.saveOrUpdate(accessToken);\n+\n+        AccessToken savedAccessToken = accessTokenSqlMapDao.findAccessTokenBySaltId(accessToken.getSaltId());\n+        assertThat(savedAccessToken).isEqualTo(accessToken);\n+    }\n+\n+    @Test\n+    public void shouldReturnNullWhenNoAccessTokenFoundForTheSpecifiedSaltId() {\n+        String saltId = \"access-token-for-apis\";\n+        AccessToken savedAccessToken = accessTokenSqlMapDao.findAccessTokenBySaltId(saltId);\n+        assertThat(savedAccessToken).isNull();\n+    }\n+}"
        },
        {
          "filename": "server/src/test-integration/java/com/thoughtworks/go/server/service/AccessTokenServiceIntegrationTest.java",
          "status": "added",
          "additions": 238,
          "deletions": 0,
          "patch": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2019 ThoughtWorks, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.thoughtworks.go.server.service;\n+\n+import com.thoughtworks.go.domain.AccessToken;\n+import com.thoughtworks.go.server.dao.AccessTokenSqlMapDao;\n+import com.thoughtworks.go.server.dao.DatabaseAccessHelper;\n+import com.thoughtworks.go.server.domain.Username;\n+import com.thoughtworks.go.server.exceptions.InvalidAccessTokenException;\n+import com.thoughtworks.go.server.exceptions.RevokedAccessTokenException;\n+import com.thoughtworks.go.server.service.result.HttpLocalizedOperationResult;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import static com.thoughtworks.go.server.newsecurity.utils.SessionUtils.currentUsername;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(locations = {\n+        \"classpath:WEB-INF/applicationContext-global.xml\",\n+        \"classpath:WEB-INF/applicationContext-dataLocalAccess.xml\",\n+        \"classpath:testPropertyConfigurer.xml\"\n+})\n+public class AccessTokenServiceIntegrationTest {\n+    @Autowired\n+    DatabaseAccessHelper dbHelper;\n+\n+    @Autowired\n+    AccessTokenService accessTokenService;\n+\n+    @Autowired\n+    AccessTokenSqlMapDao accessTokenSqlMapDao;\n+    private Username username;\n+    private String authConfigId;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        dbHelper.onSetUp();\n+        username = currentUsername();\n+        authConfigId = \"auth-config-1\";\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        accessTokenSqlMapDao.deleteAll();\n+        dbHelper.onTearDown();\n+    }\n+\n+    @Test\n+    public void shouldCreateAnAccessToken() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        AccessToken createdToken = accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+\n+        AccessToken fetchedToken = accessTokenService.find(tokenName, username.getUsername().toString());\n+\n+        assertThat(result.isSuccessful()).isTrue();\n+        assertThat(createdToken.getName()).isEqualTo(tokenName);\n+        assertThat(createdToken.getDescription()).isEqualTo(tokenDescription);\n+        assertThat(createdToken.getValue()).isNotNull();\n+        assertThat(createdToken.getOriginalValue()).isNotNull();\n+        assertThat(createdToken.getCreatedAt()).isNotNull();\n+        assertThat(createdToken.getLastUsed()).isNull();\n+        assertThat(createdToken.isRevoked()).isFalse();\n+\n+        assertThat(fetchedToken.getValue()).isEqualTo(createdToken.getValue());\n+        assertThat(fetchedToken.getName()).isEqualTo(createdToken.getName());\n+        assertThat(fetchedToken.getDescription()).isEqualTo(createdToken.getDescription());\n+        assertThat(fetchedToken.getCreatedAt()).isEqualTo(createdToken.getCreatedAt());\n+        assertThat(fetchedToken.getLastUsed()).isEqualTo(createdToken.getLastUsed());\n+        assertThat(fetchedToken.isRevoked()).isEqualTo(createdToken.isRevoked());\n+\n+        assertThat(fetchedToken.getOriginalValue()).isNull();\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateAccessTokenWhenOneWithTheSameNameAlreadyExists() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+        assertThat(result.isSuccessful()).isTrue();\n+\n+        AccessToken savedToken = accessTokenService.find(tokenName, username.getUsername().toString());\n+        assertThat(savedToken.getName()).isEqualTo(tokenName);\n+\n+        accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+        assertThat(result.isSuccessful()).isFalse();\n+        assertThat(result.httpCode()).isEqualTo(409);\n+        assertThat(result.message()).isEqualTo(\"Validation Failed. Another access token with name 'token1' already exists.\");\n+    }\n+\n+    @Test\n+    public void shouldAllowDifferentUsersToCreateAccessTokenWhenWithSameName() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+        assertThat(result.isSuccessful()).isTrue();\n+\n+        AccessToken savedToken = accessTokenService.find(tokenName, username.getUsername().toString());\n+        assertThat(savedToken.getName()).isEqualTo(tokenName);\n+\n+        accessTokenService.create(tokenName, tokenDescription, new Username(\"Another User\"), authConfigId, result);\n+\n+        assertThat(result.isSuccessful()).isTrue();\n+    }\n+\n+    @Test\n+    public void shouldGetAccessTokenProvidedTokenValue() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first Token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        AccessToken createdToken = accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+        String accessTokenInString = createdToken.getOriginalValue();\n+        createdToken.setOriginalValue(null);\n+        AccessToken fetchedToken = accessTokenService.findByAccessToken(accessTokenInString);\n+\n+        assertThat(createdToken).isEqualTo(fetchedToken);\n+    }\n+\n+    @Test\n+    public void shouldFailToGetAccessTokenWhenProvidedTokenLengthIsNotEqualTo40() {\n+        InvalidAccessTokenException exception = assertThrows(InvalidAccessTokenException.class, () -> accessTokenService.findByAccessToken(\"my-access-token\"));\n+        assertThat(\"Invalid Personal Access Token.\").isEqualTo(exception.getMessage());\n+    }\n+\n+    @Test\n+    public void shouldFailToGetAccessTokenWhenProvidedTokenContainsInvalidSaltId() {\n+        String accessToken = RandomStringUtils.randomAlphanumeric(40);\n+        InvalidAccessTokenException exception = assertThrows(InvalidAccessTokenException.class, () -> accessTokenService.findByAccessToken(accessToken));\n+        assertThat(\"Invalid Personal Access Token.\").isEqualTo(exception.getMessage());\n+    }\n+\n+    @Test\n+    public void shouldFailToGetAccessTokenWhenProvidedTokenHashEqualityFails() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first Token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        AccessToken createdToken = accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+        String accessTokenInString = createdToken.getOriginalValue();\n+        //replace last 5 characters to make the current token invalid\n+        String invalidAccessToken = StringUtils.replace(accessTokenInString, accessTokenInString.substring(35), \"abcde\");\n+\n+        InvalidAccessTokenException exception = assertThrows(InvalidAccessTokenException.class, () -> accessTokenService.findByAccessToken(invalidAccessToken));\n+        assertThat(\"Invalid Personal Access Token.\").isEqualTo(exception.getMessage());\n+    }\n+\n+    @Test\n+    public void shouldNotGetAccessTokenProvidedTokenValueWhenTokenIsRevoked() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first Token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        AccessToken createdToken = accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, result);\n+        accessTokenService.revokeAccessToken(createdToken.getName(), currentUsername().getUsername().toString(), result);\n+        String accessTokenInString = createdToken.getOriginalValue();\n+\n+        RevokedAccessTokenException exception = assertThrows(RevokedAccessTokenException.class, () -> accessTokenService.findByAccessToken(accessTokenInString));\n+        assertThat(exception.getMessage()).startsWith(\"Invalid Personal Access Token. Access token was revoked at: \");\n+    }\n+\n+    @Test\n+    public void shouldRevokeAnAccessToken() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first Token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+        AccessToken createdToken = accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, new HttpLocalizedOperationResult());\n+\n+        assertThat(createdToken.isRevoked()).isFalse();\n+\n+        accessTokenService.revokeAccessToken(tokenName, currentUsername().getUsername().toString(), result);\n+        assertThat(result.isSuccessful()).isTrue();\n+\n+        AccessToken tokenAfterRevoking = accessTokenService.find(tokenName, currentUsername().getUsername().toString());\n+        assertThat(tokenAfterRevoking.isRevoked()).isTrue();\n+    }\n+\n+    @Test\n+    public void shouldFailToRevokeAnAlreadyRevokedAccessToken() throws Exception {\n+        String tokenName = \"token1\";\n+        String tokenDescription = \"This is my first Token\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+        AccessToken createdToken = accessTokenService.create(tokenName, tokenDescription, currentUsername(), authConfigId, new HttpLocalizedOperationResult());\n+\n+        assertThat(createdToken.isRevoked()).isFalse();\n+\n+        accessTokenService.revokeAccessToken(tokenName, currentUsername().getUsername().toString(), result);\n+        assertThat(result.isSuccessful()).isTrue();\n+\n+        AccessToken tokenAfterRevoking = accessTokenService.find(tokenName, currentUsername().getUsername().toString());\n+        assertThat(tokenAfterRevoking.isRevoked()).isTrue();\n+\n+        accessTokenService.revokeAccessToken(tokenName, currentUsername().getUsername().toString(), result);\n+        assertThat(result.isSuccessful()).isFalse();\n+\n+        assertThat(result.message()).isEqualTo(String.format(\"Validation Failed. Access Token with name '%s' for user '%s' has already been revoked.\", tokenName, currentUsername().getUsername().toString()));\n+    }\n+\n+    @Test\n+    public void shouldFailToRevokeNonExistingAccessToken() {\n+        String tokenName = \"token1\";\n+        HttpLocalizedOperationResult result = new HttpLocalizedOperationResult();\n+\n+        accessTokenService.revokeAccessToken(tokenName, currentUsername().getUsername().toString(), result);\n+        assertThat(result.isSuccessful()).isFalse();\n+        assertThat(result.message()).isEqualTo(String.format(\"Validation Failed. Access Token with name '%s' for user '%s' does not exists.\", tokenName, currentUsername().getUsername().toString()));\n+    }\n+}"
        },
        {
          "filename": "server/src/test-shared/java/com/thoughtworks/go/server/dao/DatabaseAccessHelper.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -189,6 +189,7 @@ private void initialize(DataSource dataSource) throws AmbiguousTableNameExceptio\n         dataSet.addTable(new DefaultTable(\"jobAgentMetadata\"));\n         dataSet.addTable(new DefaultTable(\"DataSharingSettings\"));\n         dataSet.addTable(new DefaultTable(\"UsageDataReporting\"));\n+        dataSet.addTable(new DefaultTable(\"AccessToken\"));\n \n         databaseTester.setDataSet(dataSet);\n     }"
        },
        {
          "filename": "server/webapp/WEB-INF/applicationContext-global.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -27,6 +27,7 @@\n \n   <context:annotation-config/>\n \n+  <context:component-scan base-package=\"com.thoughtworks.go.apiv1.accessToken\"/>\n   <context:component-scan base-package=\"com.thoughtworks.go.apiv2.environments\"/>\n   <context:component-scan base-package=\"com.thoughtworks.go.apiv2.adminsconfig\"/>\n   <context:component-scan base-package=\"com.thoughtworks.go.apiv2.rolesconfig\"/>"
        },
        {
          "filename": "server/webapp/WEB-INF/urlrewrite.xml",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -46,6 +46,24 @@\n     <to last=\"true\">/spark/api/users/${escape:$1}</to>\n   </rule>\n \n+  <rule>\n+    <name>Access Token Index and Create API</name>\n+    <from>^/api/access_token(/?)$</from>\n+    <to last=\"true\">/spark/api/access_token</to>\n+  </rule>\n+\n+  <rule>\n+    <name>Spark Access Token Show API</name>\n+    <from>^/api/access_token/(.*)$</from>\n+    <to last=\"true\">/spark/api/access_token/${escape:$1}</to>\n+  </rule>\n+\n+  <rule>\n+    <name>Spark Access Token Revoke API</name>\n+    <from>^/api/access_token/([^/]+)/([^/]+)/revoke</from>\n+    <to last=\"true\">/spark/api/access_token/${escape:$1}/${escape:$2}/revoke</to>\n+  </rule>\n+\n   <rule>\n     <name>users UI</name>\n     <from>^/admin/users(/?)$</from>"
        },
        {
          "filename": "settings.gradle",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -27,6 +27,7 @@ include ':api:api-admins-config-v2'\n include ':api:api-agents-v4'\n include ':api:api-api-shared-v1'\n include ':api:api-artifact-store-config-v1'\n+include ':api:api-access-token-v1'\n include ':api:api-backups-v1'\n include ':api:api-base'\n include ':api:api-build_cause-v1'"
        },
        {
          "filename": "spark/spark-base/src/main/java/com/thoughtworks/go/spark/Routes.java",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -433,4 +433,19 @@ public static class Users {\n     public class ArtifactStores {\n         public static final String SPA_BASE = \"/admin/artifact_stores\";\n     }\n+\n+    public static class AccessToken {\n+        public static final String BASE = \"/api/access_token\";\n+        public static final String TOKEN_NAME = \"/:token_name\";\n+        public static final String USERNAME = \"/:username\";\n+        public static final String DOC = apiDocsUrl(\"#access_token\");\n+\n+        public static String find() {\n+            return BASE + TOKEN_NAME;\n+        }\n+\n+        public static String name(String tokenName) {\n+            return find().replaceAll(\":token_name\", tokenName);\n+        }\n+    }\n }"
        },
        {
          "filename": "spark/spark-base/src/main/java/com/thoughtworks/go/spark/SparkController.java",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -18,12 +18,14 @@\n \n import com.thoughtworks.go.config.CaseInsensitiveString;\n import com.thoughtworks.go.server.domain.Username;\n+import com.thoughtworks.go.server.newsecurity.models.AuthenticationToken;\n import com.thoughtworks.go.server.newsecurity.utils.SessionUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.http.client.utils.URLEncodedUtils;\n import org.apache.http.message.BasicNameValuePair;\n import spark.Request;\n \n+import javax.servlet.http.HttpServletRequest;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;"
        },
        {
          "filename": "spark/spark-base/src/test/groovy/com/thoughtworks/go/spark/ControllerTrait.groovy",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -22,6 +22,8 @@ import com.thoughtworks.go.http.mocks.HttpRequestBuilder\n import com.thoughtworks.go.http.mocks.MockHttpServletRequest\n import com.thoughtworks.go.http.mocks.MockHttpServletResponse\n import com.thoughtworks.go.server.domain.Username\n+import com.thoughtworks.go.server.newsecurity.models.AuthenticationToken\n+import com.thoughtworks.go.server.newsecurity.models.UsernamePassword\n import com.thoughtworks.go.server.newsecurity.utils.SessionUtils\n import com.thoughtworks.go.spark.mocks.StubTemplateEngine\n import com.thoughtworks.go.spark.mocks.TestApplication\n@@ -129,7 +131,10 @@ trait ControllerTrait<T extends SparkController> {\n     }\n \n     if (!currentUsername().isAnonymous()) {\n+      final AuthenticationToken<?> newToken = new AuthenticationToken<>(SessionUtils.getCurrentUser(), new UsernamePassword(currentUserLoginName().toString(), \"password\"), \"plugin1\", System.currentTimeMillis(), \"authConfigId\")\n+\n       httpRequestBuilder.withSessionAttr(SessionUtils.CURRENT_USER_ID, currentUserLoginId())\n+      httpRequestBuilder.withSessionAttr(SessionUtils.AUTHENTICATION_TOKEN, newToken)\n     }\n \n     request = httpRequestBuilder.build()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 9,
        "unique_directories": 21,
        "max_directory_depth": 11
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "745b8846335e2d352bd17223122b3585ba63bc18",
            "date": "2025-01-14T11:10:03Z",
            "author_login": "chadlwilson"
          },
          {
            "sha": "7e0e0c87401d8ce8d76c651194e9165523416037",
            "date": "2025-01-14T11:09:46Z",
            "author_login": "chadlwilson"
          },
          {
            "sha": "99aa6ecc886d9c30f79601e30c06224112da3045",
            "date": "2025-01-14T11:09:29Z",
            "author_login": "chadlwilson"
          },
          {
            "sha": "6e87477e6527985cddd634b48bd3505be1079d4d",
            "date": "2025-01-14T11:09:11Z",
            "author_login": "chadlwilson"
          },
          {
            "sha": "90fccf4ddc5b1641b3fcaadd6eaeff34501aefb6",
            "date": "2025-01-14T10:44:32Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-208",
    "description": "GoCD is a continuous delivery server. GoCD helps you automate and streamline the build-test-release cycle for continuous delivery of your product. GoCD versions from 19.2.0 to 19.10.0 (inclusive) are subject to a timing attack in validation of access tokens due to use of regular string comparison for validation of the token rather than a constant time algorithm. This could allow a brute force attack on GoCD server API calls to observe timing differences in validations in order to guess an access token generated by a user for API access. This issue is fixed in GoCD version 19.11.0. As a workaround, users can apply rate limiting or insert random delays to API calls made to GoCD Server via a reverse proxy or other fronting web server. Another workaround, users may disallow use of access tokens by users by having an administrator revoke all access tokens through the \"Access Token Management\" admin function.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-10-14T19:15:18.310",
    "last_modified": "2024-11-21T07:18:00.193",
    "fix_date": "2019-02-01T06:08:30Z"
  },
  "references": [
    {
      "url": "https://github.com/gocd/gocd/commit/236d4baf92e6607f2841c151c855adcc477238b8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gocd/gocd/releases/tag/19.11.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gocd/gocd/security/advisories/GHSA-999p-fp84-jcpq",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.gocd.org/releases/#19-11-0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/gocd/gocd/commit/236d4baf92e6607f2841c151c855adcc477238b8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gocd/gocd/releases/tag/19.11.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gocd/gocd/security/advisories/GHSA-999p-fp84-jcpq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.gocd.org/releases/#19-11-0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.343517",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gocd",
    "owner": "gocd",
    "created_at": "2013-12-13T05:26:16Z",
    "updated_at": "2025-01-14T12:47:48Z",
    "pushed_at": "2025-01-14T11:10:10Z",
    "size": 393992,
    "stars": 7159,
    "forks": 972,
    "open_issues": 82,
    "watchers": 7159,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Java": 20251061,
      "TypeScript": 4424594,
      "Groovy": 2080119,
      "JavaScript": 753678,
      "SCSS": 564746,
      "Ruby": 364252,
      "HTML": 253777,
      "XSLT": 202698,
      "NSIS": 24216,
      "Shell": 15469,
      "FreeMarker": 13061,
      "EJS": 1626,
      "CSS": 1575,
      "Batchfile": 474
    },
    "commit_activity": {
      "total_commits_last_year": 1743,
      "avg_commits_per_week": 33.51923076923077,
      "days_active_last_year": 299
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:11:02.445502"
  }
}