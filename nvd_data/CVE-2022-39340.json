{
  "cve_id": "CVE-2022-39340",
  "github_data": {
    "repository": "openfga/openfga",
    "fix_commit": "779d73d4b6d067ee042ec9b59fec707eed71e42f",
    "related_commits": [
      "779d73d4b6d067ee042ec9b59fec707eed71e42f",
      "779d73d4b6d067ee042ec9b59fec707eed71e42f"
    ],
    "patch_url": "https://github.com/openfga/openfga/commit/779d73d4b6d067ee042ec9b59fec707eed71e42f.patch",
    "fix_commit_details": {
      "sha": "779d73d4b6d067ee042ec9b59fec707eed71e42f",
      "commit_date": "2022-10-21T16:19:48Z",
      "author": {
        "login": "miparnisari",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-95x7-mh78-7w2r",
        "length": 132,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 224,
        "additions": 154,
        "deletions": 70
      },
      "files": [
        {
          "filename": "pkg/cmd/service/service.go",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -359,11 +359,16 @@ func BuildService(config *Config, logger logger.Logger) (*service, error) {\n \t\treturn nil, errors.Errorf(\"failed to initialize authenticator: %v\", err)\n \t}\n \n-\tinterceptors := []grpc.UnaryServerInterceptor{\n+\tunaryServerInterceptors := []grpc.UnaryServerInterceptor{\n \t\tgrpc_auth.UnaryServerInterceptor(middleware.AuthFunc(authenticator)),\n \t\tmiddleware.NewErrorLoggingInterceptor(logger),\n \t}\n \n+\tstreamingServerInterceptors := []grpc.StreamServerInterceptor{\n+\t\tgrpc_auth.StreamServerInterceptor(middleware.AuthFunc(authenticator)),\n+\t\tmiddleware.NewStreamingErrorLoggingInterceptor(logger),\n+\t}\n+\n \tgrpcHostAddr, grpcHostPort, err := net.SplitHostPort(config.GRPC.Addr)\n \tif err != nil {\n \t\treturn nil, errors.Errorf(\"`grpc.addr` config must be in the form [host]:port\")\n@@ -415,7 +420,8 @@ func BuildService(config *Config, logger logger.Logger) (*service, error) {\n \t\tChangelogHorizonOffset: config.ChangelogHorizonOffset,\n \t\tListObjectsDeadline:    config.ListObjectsDeadline,\n \t\tListObjectsMaxResults:  config.ListObjectsMaxResults,\n-\t\tUnaryInterceptors:      interceptors,\n+\t\tUnaryInterceptors:      unaryServerInterceptors,\n+\t\tStreamingInterceptors:  streamingServerInterceptors,\n \t\tMuxOptions:             nil,\n \t})\n \tif err != nil {"
        },
        {
          "filename": "pkg/cmd/service/service_test.go",
          "status": "modified",
          "additions": 121,
          "deletions": 65,
          "patch": "@@ -7,6 +7,7 @@ import (\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n \t\"crypto/x509/pkix\"\n+\t\"encoding/json\"\n \t\"encoding/pem\"\n \t\"fmt\"\n \t\"io\"\n@@ -24,6 +25,7 @@ import (\n \t\"github.com/hashicorp/go-retryablehttp\"\n \t\"github.com/openfga/openfga/pkg/logger\"\n \t\"github.com/openfga/openfga/server/authn/mocks\"\n+\tserverErrors \"github.com/openfga/openfga/server/errors\"\n \t\"github.com/stretchr/testify/require\"\n \t\"github.com/tidwall/gjson\"\n \topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n@@ -33,6 +35,7 @@ import (\n \t\"google.golang.org/grpc/credentials\"\n \t\"google.golang.org/grpc/credentials/insecure\"\n \thealthv1pb \"google.golang.org/grpc/health/grpc_health_v1\"\n+\t\"google.golang.org/protobuf/encoding/protojson\"\n )\n \n func TestMain(m *testing.M) {\n@@ -205,9 +208,10 @@ func createCertsAndKeys(t *testing.T) certHandle {\n }\n \n type authTest struct {\n-\t_name         string\n-\tauthHeader    string\n-\texpectedError string\n+\t_name                 string\n+\tauthHeader            string\n+\texpectedErrorResponse *serverErrors.ErrorResponse\n+\texpectedStatusCode    int\n }\n \n func TestBuildServiceWithNoAuth(t *testing.T) {\n@@ -251,48 +255,39 @@ func TestBuildServiceWithPresharedKeyAuthentication(t *testing.T) {\n \tensureServiceUp(t, service, nil, true)\n \n \ttests := []authTest{{\n-\t\t_name:         \"Header with incorrect key fails\",\n-\t\tauthHeader:    \"Bearer incorrectkey\",\n-\t\texpectedError: \"unauthenticated\",\n+\t\t_name:      \"Header with incorrect key fails\",\n+\t\tauthHeader: \"Bearer incorrectkey\",\n+\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n+\t\t\tCode:    \"unauthenticated\",\n+\t\t\tMessage: \"unauthenticated\",\n+\t\t},\n+\t\texpectedStatusCode: 401,\n \t}, {\n-\t\t_name:         \"Missing header fails\",\n-\t\tauthHeader:    \"\",\n-\t\texpectedError: \"missing bearer token\",\n+\t\t_name:      \"Missing header fails\",\n+\t\tauthHeader: \"\",\n+\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n+\t\t\tCode:    \"bearer_token_missing\",\n+\t\t\tMessage: \"missing bearer token\",\n+\t\t},\n+\t\texpectedStatusCode: 401,\n \t}, {\n-\t\t_name:         \"Correct key one succeeds\",\n-\t\tauthHeader:    \"Bearer KEYONE\",\n-\t\texpectedError: \"\",\n+\t\t_name:              \"Correct key one succeeds\",\n+\t\tauthHeader:         fmt.Sprintf(\"Bearer %s\", config.Authn.AuthnPresharedKeyConfig.Keys[0]),\n+\t\texpectedStatusCode: 200,\n \t}, {\n-\t\t_name:         \"Correct key two succeeds\",\n-\t\tauthHeader:    \"Bearer KEYTWO\",\n-\t\texpectedError: \"\",\n+\t\t_name:              \"Correct key two succeeds\",\n+\t\tauthHeader:         fmt.Sprintf(\"Bearer %s\", config.Authn.AuthnPresharedKeyConfig.Keys[1]),\n+\t\texpectedStatusCode: 200,\n \t}}\n \n \tretryClient := retryablehttp.NewClient()\n \tfor _, test := range tests {\n \t\tt.Run(test._name, func(t *testing.T) {\n-\t\t\tpayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n-\t\t\treq, err := retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), payload)\n-\t\t\trequire.NoError(t, err, \"Failed to construct request\")\n-\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n-\t\t\treq.Header.Set(\"authorization\", test.authHeader)\n-\n-\t\t\tres, err := retryClient.Do(req)\n-\t\t\trequire.NoError(t, err, \"Failed to execute request\")\n-\n-\t\t\tdefer res.Body.Close()\n-\t\t\tbody, err := io.ReadAll(res.Body)\n-\t\t\trequire.NoError(t, err, \"Failed to read response\")\n-\n-\t\t\tstringBody := string(body)\n-\n-\t\t\tif test.expectedError == \"\" && strings.Contains(stringBody, \"code\") {\n-\t\t\t\tt.Fatalf(\"Expected no error but got '%v'\", stringBody)\n-\t\t\t}\n+\t\t\ttryGetStores(t, test, service, retryClient)\n+\t\t})\n \n-\t\t\tif !strings.Contains(stringBody, test.expectedError) && test.expectedError != \"\" {\n-\t\t\t\tt.Fatalf(\"Expected '%v' to contain '%v'\", stringBody, test.expectedError)\n-\t\t\t}\n+\t\tt.Run(test._name+\"/streaming\", func(t *testing.T) {\n+\t\t\ttryStreamingListObjects(t, test, service, retryClient, config.Authn.AuthnPresharedKeyConfig.Keys[0])\n \t\t})\n \t}\n \n@@ -301,6 +296,75 @@ func TestBuildServiceWithPresharedKeyAuthentication(t *testing.T) {\n \trequire.NoError(t, g.Wait())\n }\n \n+func tryStreamingListObjects(t *testing.T, test authTest, service *service, retryClient *retryablehttp.Client, validToken string) {\n+\t// create a store\n+\tcreateStorePayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n+\treq, err := retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), createStorePayload)\n+\trequire.NoError(t, err, \"Failed to construct create store request\")\n+\treq.Header.Set(\"content-type\", \"application/json\")\n+\treq.Header.Set(\"authorization\", fmt.Sprintf(\"Bearer %s\", validToken))\n+\tres, err := retryClient.Do(req)\n+\trequire.NoError(t, err, \"Failed to execute create store request\")\n+\tdefer res.Body.Close()\n+\tbody, err := io.ReadAll(res.Body)\n+\trequire.NoError(t, err, \"Failed to read create store response\")\n+\tvar createStoreResponse openfgapb.CreateStoreResponse\n+\terr = protojson.Unmarshal(body, &createStoreResponse)\n+\trequire.NoError(t, err, \"Failed to unmarshal create store response\")\n+\n+\t// create an authorization model\n+\tauthModelPayload := strings.NewReader(`{\"type_definitions\":[{\"type\":\"document\",\"relations\":{\"owner\":{\"this\":{}}}}]}`)\n+\treq, err = retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores/%s/authorization-models\", service.GetHTTPAddrPort().Port(), createStoreResponse.Id), authModelPayload)\n+\trequire.NoError(t, err, \"Failed to construct create authorization model request\")\n+\treq.Header.Set(\"content-type\", \"application/json\")\n+\treq.Header.Set(\"authorization\", fmt.Sprintf(\"Bearer %s\", validToken))\n+\t_, err = retryClient.Do(req)\n+\trequire.NoError(t, err, \"Failed to execute create authorization model request\")\n+\n+\t// call one streaming endpoint\n+\tlistObjectsPayload := strings.NewReader(`{\"type\": \"document\", \"user\": \"anne\", \"relation\": \"owner\"}`)\n+\treq, err = retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores/%s/streamed-list-objects\", service.GetHTTPAddrPort().Port(), createStoreResponse.Id), listObjectsPayload)\n+\trequire.NoError(t, err, \"Failed to construct request\")\n+\treq.Header.Set(\"content-type\", \"application/json\")\n+\treq.Header.Set(\"authorization\", test.authHeader)\n+\n+\tres, err = retryClient.Do(req)\n+\trequire.Equal(t, test.expectedStatusCode, res.StatusCode)\n+\trequire.NoError(t, err, \"Failed to execute streaming request\")\n+\n+\tdefer res.Body.Close()\n+\tbody, err = io.ReadAll(res.Body)\n+\trequire.NoError(t, err, \"Failed to read response\")\n+\n+\tif test.expectedErrorResponse != nil {\n+\t\trequire.Contains(t, string(body), fmt.Sprintf(\",\\\"message\\\":\\\"%s\\\"\", test.expectedErrorResponse.Message))\n+\t}\n+}\n+\n+func tryGetStores(t *testing.T, test authTest, service *service, retryClient *retryablehttp.Client) {\n+\treq, err := retryablehttp.NewRequest(\"GET\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), nil)\n+\trequire.NoError(t, err, \"Failed to construct request\")\n+\treq.Header.Set(\"content-type\", \"application/json\")\n+\treq.Header.Set(\"authorization\", test.authHeader)\n+\n+\tres, err := retryClient.Do(req)\n+\trequire.NoError(t, err, \"Failed to execute request\")\n+\trequire.Equal(t, test.expectedStatusCode, res.StatusCode)\n+\n+\tdefer res.Body.Close()\n+\tbody, err := io.ReadAll(res.Body)\n+\trequire.NoError(t, err, \"Failed to read response\")\n+\n+\tif test.expectedErrorResponse != nil {\n+\t\tvar actualErrorResponse serverErrors.ErrorResponse\n+\t\terr = json.Unmarshal(body, &actualErrorResponse)\n+\n+\t\trequire.NoError(t, err, \"Failed to unmarshal response\")\n+\n+\t\trequire.Equal(t, test.expectedErrorResponse, &actualErrorResponse)\n+\t}\n+}\n+\n func TestHTTPServerWithCORS(t *testing.T) {\n \tconfig, err := DefaultConfigWithRandomPorts()\n \trequire.NoError(t, err)\n@@ -436,43 +500,35 @@ func TestBuildServerWithOIDCAuthentication(t *testing.T) {\n \trequire.NoError(t, err)\n \n \ttests := []authTest{{\n-\t\t_name:         \"Header with invalid token fails\",\n-\t\tauthHeader:    \"Bearer incorrecttoken\",\n-\t\texpectedError: \"invalid bearer token\",\n+\t\t_name:      \"Header with invalid token fails\",\n+\t\tauthHeader: \"Bearer incorrecttoken\",\n+\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n+\t\t\tCode:    \"auth_failed_invalid_bearer_token\",\n+\t\t\tMessage: \"invalid bearer token\",\n+\t\t},\n+\t\texpectedStatusCode: 401,\n \t}, {\n-\t\t_name:         \"Missing header fails\",\n-\t\tauthHeader:    \"\",\n-\t\texpectedError: \"missing bearer token\",\n+\t\t_name:      \"Missing header fails\",\n+\t\tauthHeader: \"\",\n+\t\texpectedErrorResponse: &serverErrors.ErrorResponse{\n+\t\t\tCode:    \"bearer_token_missing\",\n+\t\t\tMessage: \"missing bearer token\",\n+\t\t},\n+\t\texpectedStatusCode: 401,\n \t}, {\n-\t\t_name:         \"Correct token succeeds\",\n-\t\tauthHeader:    \"Bearer \" + trustedToken,\n-\t\texpectedError: \"\",\n+\t\t_name:              \"Correct token succeeds\",\n+\t\tauthHeader:         \"Bearer \" + trustedToken,\n+\t\texpectedStatusCode: 200,\n \t}}\n \n \tretryClient := retryablehttp.NewClient()\n \tfor _, test := range tests {\n \t\tt.Run(test._name, func(t *testing.T) {\n-\t\t\tpayload := strings.NewReader(`{\"name\": \"some-store-name\"}`)\n-\t\t\treq, err := retryablehttp.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/stores\", service.GetHTTPAddrPort().Port()), payload)\n-\t\t\trequire.NoError(t, err, \"Failed to construct request\")\n-\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n-\t\t\treq.Header.Set(\"authorization\", test.authHeader)\n-\n-\t\t\tres, err := retryClient.Do(req)\n-\t\t\trequire.NoError(t, err, \"Failed to execute request\")\n-\n-\t\t\tdefer res.Body.Close()\n-\t\t\tbody, err := io.ReadAll(res.Body)\n-\t\t\trequire.NoError(t, err, \"Failed to read response\")\n-\n-\t\t\tstringBody := string(body)\n-\t\t\tif test.expectedError == \"\" && strings.Contains(stringBody, \"code\") {\n-\t\t\t\tt.Fatalf(\"Expected no error but got %v\", stringBody)\n-\t\t\t}\n+\t\t\ttryGetStores(t, test, service, retryClient)\n+\t\t})\n \n-\t\t\tif !strings.Contains(stringBody, test.expectedError) && test.expectedError != \"\" {\n-\t\t\t\tt.Fatalf(\"Expected %v to contain %v\", stringBody, test.expectedError)\n-\t\t\t}\n+\t\tt.Run(test._name+\"/streaming\", func(t *testing.T) {\n+\t\t\ttryStreamingListObjects(t, test, service, retryClient, trustedToken)\n \t\t})\n \t}\n "
        },
        {
          "filename": "server/middleware/logging.go",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -25,3 +25,18 @@ func NewErrorLoggingInterceptor(logger logger.Logger) grpc.UnaryServerIntercepto\n \t\treturn resp, nil\n \t}\n }\n+\n+func NewStreamingErrorLoggingInterceptor(logger logger.Logger) grpc.StreamServerInterceptor {\n+\treturn func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n+\t\terr := handler(srv, stream)\n+\t\tif err != nil {\n+\t\t\tvar e error\n+\t\t\tif internalError, ok := err.(serverErrors.InternalError); ok {\n+\t\t\t\te = internalError.Internal()\n+\t\t\t}\n+\t\t\tlogger.Error(\"grpc_error\", zap.Error(e), zap.String(\"public_error\", err.Error()))\n+\t\t}\n+\n+\t\treturn err\n+\t}\n+}"
        },
        {
          "filename": "server/server.go",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -81,6 +81,7 @@ type Config struct {\n \tListObjectsDeadline    time.Duration\n \tListObjectsMaxResults  uint32\n \tUnaryInterceptors      []grpc.UnaryServerInterceptor\n+\tStreamingInterceptors  []grpc.StreamServerInterceptor\n \tMuxOptions             []runtime.ServeMuxOption\n }\n \n@@ -486,13 +487,19 @@ func (s *Server) IsReady(ctx context.Context) (bool, error) {\n // server cancel the provided ctx.\n func (s *Server) Run(ctx context.Context) error {\n \n-\tinterceptors := []grpc.UnaryServerInterceptor{\n+\tunaryServerInterceptors := []grpc.UnaryServerInterceptor{\n \t\tgrpc_validator.UnaryServerInterceptor(),\n \t}\n-\tinterceptors = append(interceptors, s.config.UnaryInterceptors...)\n+\tunaryServerInterceptors = append(unaryServerInterceptors, s.config.UnaryInterceptors...)\n+\n+\tstreamingInterceptors := []grpc.StreamServerInterceptor{\n+\t\tgrpc_validator.StreamServerInterceptor(),\n+\t}\n+\tstreamingInterceptors = append(streamingInterceptors, s.config.StreamingInterceptors...)\n \n \topts := []grpc.ServerOption{\n-\t\tgrpc.ChainUnaryInterceptor(interceptors...),\n+\t\tgrpc.ChainUnaryInterceptor(unaryServerInterceptors...),\n+\t\tgrpc.ChainStreamInterceptor(streamingInterceptors...),\n \t}\n \n \tif s.config.GRPCServer.TLSConfig != nil {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "40cf00389f9498edd7edacfd2b0602888f55d1a5",
            "date": "2025-01-14T00:17:26Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0199bd6f08ddb3825587938e55b640366a39e9ed",
            "date": "2025-01-13T21:25:16Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "cfd75567075ef916f6e871e8c8cf787e9170bbc7",
            "date": "2025-01-13T21:10:20Z",
            "author_login": "adriantam"
          },
          {
            "sha": "dc1a4803b1ae2f539a67cfa78a929923642c631b",
            "date": "2025-01-13T20:38:41Z",
            "author_login": "justincoh"
          },
          {
            "sha": "a4491e49f446d5aa121b384675ced9010a35f761",
            "date": "2025-01-13T15:22:20Z",
            "author_login": "adriantam"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-285",
    "description": "OpenFGA is an authorization/permission engine. Prior to version 0.2.4, the `streamed-list-objects` endpoint was not validating the authorization header, resulting in disclosure of objects in the store. Users `openfga/openfga` versions 0.2.3 and prior who are exposing the OpenFGA service to the internet are vulnerable. Version 0.2.4 contains a patch for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-10-25T17:15:56.213",
    "last_modified": "2024-11-21T07:18:04.393",
    "fix_date": "2022-10-21T16:19:48Z"
  },
  "references": [
    {
      "url": "https://github.com/openfga/openfga/commit/779d73d4b6d067ee042ec9b59fec707eed71e42f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/releases/tag/v0.2.4",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/security/advisories/GHSA-95x7-mh78-7w2r",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/commit/779d73d4b6d067ee042ec9b59fec707eed71e42f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/releases/tag/v0.2.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/security/advisories/GHSA-95x7-mh78-7w2r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:00.953742",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "openfga",
    "owner": "openfga",
    "created_at": "2022-06-08T18:47:15Z",
    "updated_at": "2025-01-14T13:09:15Z",
    "pushed_at": "2025-01-14T01:10:04Z",
    "size": 31758,
    "stars": 3129,
    "forks": 220,
    "open_issues": 127,
    "watchers": 3129,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 2873841,
      "Makefile": 7516,
      "Dockerfile": 1275,
      "HTML": 379
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:56:19.885603"
  }
}