{
  "cve_id": "CVE-2022-39341",
  "github_data": {
    "repository": "openfga/openfga",
    "fix_commit": "b466769cc100b2065047786578718d313f52695b",
    "related_commits": [
      "b466769cc100b2065047786578718d313f52695b",
      "b466769cc100b2065047786578718d313f52695b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b466769cc100b2065047786578718d313f52695b",
      "commit_date": "2022-10-20T22:29:12Z",
      "author": {
        "login": "jon-whit",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-vj4m-83m8-xpw5",
        "length": 278,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 215,
        "additions": 196,
        "deletions": 19
      },
      "files": [
        {
          "filename": "server/commands/check.go",
          "status": "modified",
          "additions": 22,
          "deletions": 2,
          "patch": "@@ -2,6 +2,7 @@ package commands\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \t\"sync\"\n \n \t\"github.com/go-errors/errors\"\n@@ -21,7 +22,7 @@ import (\n \t\"golang.org/x/sync/errgroup\"\n )\n \n-const AllUsers = \"*\"\n+const Wildcard = \"*\"\n \n // A CheckQuery can be used to Check if a User has a Relation to an Object\n // CheckQuery instances may be safely shared by multiple go-routines\n@@ -401,7 +402,9 @@ func (query *CheckQuery) resolveTupleToUserset(ctx context.Context, rc *resoluti\n \tif relation == \"\" {\n \t\trelation = rc.tk.GetRelation()\n \t}\n-\tfindTK := &openfgapb.TupleKey{Object: rc.tk.GetObject(), Relation: relation}\n+\n+\tfindTK := tupleUtils.NewTupleKey(rc.tk.GetObject(), relation, \"\")\n+\n \ttracer := rc.tracer.AppendTupleToUserset().AppendString(tupleUtils.ToObjectRelationString(findTK.GetObject(), relation))\n \titer, err := rc.read(ctx, query.datastore, findTK)\n \tif err != nil {\n@@ -429,6 +432,23 @@ func (query *CheckQuery) resolveTupleToUserset(ctx context.Context, rc *resoluti\n \n \t\tuserObj, userRel := tupleUtils.SplitObjectRelation(tuple.GetUser())\n \n+\t\tif userObj == Wildcard {\n+\t\t\tobjectType, _ := tupleUtils.SplitObject(rc.tk.GetObject())\n+\n+\t\t\tquery.logger.WarnWithContext(\n+\t\t\t\tctx,\n+\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on tupleset relation '%s'\", relation),\n+\t\t\t\tzap.String(\"store_id\", rc.store),\n+\t\t\t\tzap.String(\"authorization_model_id\", rc.modelID),\n+\t\t\t\tzap.String(\"object_type\", objectType),\n+\t\t\t)\n+\n+\t\t\treturn serverErrors.InvalidTuple(\n+\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on relation '%s#%s'\", objectType, relation),\n+\t\t\t\ttupleUtils.NewTupleKey(rc.tk.GetObject(), relation, Wildcard),\n+\t\t\t)\n+\t\t}\n+\n \t\tif !tupleUtils.IsValidObject(userObj) {\n \t\t\tcontinue // TupleToUserset tuplesets should be of the form 'objectType:id' or 'objectType:id#relation' but are not guaranteed to be because it is neither a user or userset\n \t\t}"
        },
        {
          "filename": "server/commands/check_utils.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -195,7 +195,7 @@ func (u *userSet) Get(value string) (resolutionTracer, bool) {\n \tvar found bool\n \tvar rt resolutionTracer\n \tif rt, found = u.u[value]; !found {\n-\t\tif rt, found = u.u[AllUsers]; !found {\n+\t\tif rt, found = u.u[Wildcard]; !found {\n \t\t\treturn nil, false\n \t\t}\n \t}"
        },
        {
          "filename": "server/commands/expand.go",
          "status": "modified",
          "additions": 47,
          "deletions": 5,
          "patch": "@@ -2,6 +2,7 @@ package commands\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \n \t\"github.com/openfga/openfga/pkg/logger\"\n \ttupleUtils \"github.com/openfga/openfga/pkg/tuple\"\n@@ -11,6 +12,7 @@ import (\n \t\"github.com/openfga/openfga/storage\"\n \topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n \t\"go.opentelemetry.io/otel/trace\"\n+\t\"go.uber.org/zap\"\n \t\"golang.org/x/sync/errgroup\"\n )\n \n@@ -58,7 +60,13 @@ func (query *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequ\n \t}, nil\n }\n \n-func (query *ExpandQuery) resolveUserset(ctx context.Context, store, modelID string, userset *openfgapb.Userset, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n+func (query *ExpandQuery) resolveUserset(\n+\tctx context.Context,\n+\tstore, modelID string,\n+\tuserset *openfgapb.Userset,\n+\ttk *openfgapb.TupleKey,\n+\tmetadata *utils.ResolutionMetadata,\n+) (*openfgapb.UsersetTree_Node, error) {\n \tctx, span := query.tracer.Start(ctx, \"resolveUserset\")\n \tdefer span.End()\n \n@@ -68,7 +76,7 @@ func (query *ExpandQuery) resolveUserset(ctx context.Context, store, modelID str\n \tcase *openfgapb.Userset_ComputedUserset:\n \t\treturn query.resolveComputedUserset(ctx, us.ComputedUserset, tk, metadata)\n \tcase *openfgapb.Userset_TupleToUserset:\n-\t\treturn query.resolveTupleToUserset(ctx, store, us.TupleToUserset, tk, metadata)\n+\t\treturn query.resolveTupleToUserset(ctx, store, modelID, us.TupleToUserset, tk, metadata)\n \tcase *openfgapb.Userset_Union:\n \t\treturn query.resolveUnionUserset(ctx, store, modelID, us.Union, tk, metadata)\n \tcase *openfgapb.Userset_Difference:\n@@ -152,14 +160,24 @@ func (query *ExpandQuery) resolveComputedUserset(ctx context.Context, userset *o\n }\n \n // resolveTupleToUserset creates a new leaf node containing the result of expanding a TupleToUserset rewrite.\n-func (query *ExpandQuery) resolveTupleToUserset(ctx context.Context, store string, userset *openfgapb.TupleToUserset, tk *openfgapb.TupleKey, metadata *utils.ResolutionMetadata) (*openfgapb.UsersetTree_Node, error) {\n+func (query *ExpandQuery) resolveTupleToUserset(\n+\tctx context.Context,\n+\tstore, modelID string,\n+\tuserset *openfgapb.TupleToUserset,\n+\ttk *openfgapb.TupleKey,\n+\tmetadata *utils.ResolutionMetadata,\n+) (*openfgapb.UsersetTree_Node, error) {\n \tctx, span := query.tracer.Start(ctx, \"resolveTupleToUserset\")\n \tdefer span.End()\n \n+\ttargetObject := tk.GetObject()\n+\n+\ttupleset := userset.GetTupleset().GetRelation()\n \ttsKey := &openfgapb.TupleKey{\n-\t\tObject:   tk.GetObject(),\n-\t\tRelation: userset.GetTupleset().GetRelation(),\n+\t\tObject:   targetObject,\n+\t\tRelation: tupleset,\n \t}\n+\n \tif tsKey.GetRelation() == \"\" {\n \t\ttsKey.Relation = tk.GetRelation()\n \t}\n@@ -170,6 +188,7 @@ func (query *ExpandQuery) resolveTupleToUserset(ctx context.Context, store strin\n \t\treturn nil, serverErrors.HandleError(\"\", err)\n \t}\n \tdefer iter.Stop()\n+\n \tvar computed []*openfgapb.UsersetTree_Computed\n \tseen := make(map[string]bool)\n \tfor {\n@@ -181,29 +200,52 @@ func (query *ExpandQuery) resolveTupleToUserset(ctx context.Context, store strin\n \t\t\treturn nil, serverErrors.HandleError(\"\", err)\n \t\t}\n \t\tuser := tuple.GetKey().GetUser()\n+\n+\t\tif user == Wildcard {\n+\t\t\tobjectType, _ := tupleUtils.SplitObject(targetObject)\n+\n+\t\t\tquery.logger.WarnWithContext(\n+\t\t\t\tctx,\n+\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on tupleset relation '%s'\", tupleset),\n+\t\t\t\tzap.String(\"store_id\", store),\n+\t\t\t\tzap.String(\"authorization_model_id\", modelID),\n+\t\t\t\tzap.String(\"object_type\", objectType),\n+\t\t\t)\n+\n+\t\t\treturn nil, serverErrors.InvalidTuple(\n+\t\t\t\tfmt.Sprintf(\"unexpected wildcard evaluated on relation '%s#%s'\", objectType, tupleset),\n+\t\t\t\ttupleUtils.NewTupleKey(targetObject, tupleset, Wildcard),\n+\t\t\t)\n+\t\t}\n+\n \t\t// user must contain a type (i.e., be an object or userset)\n \t\tif tupleUtils.GetType(user) == \"\" {\n \t\t\tcontinue\n \t\t}\n+\n \t\ttObject, tRelation := tupleUtils.SplitObjectRelation(user)\n \t\t// We only proceed in the case that tRelation == userset.GetComputedUserset().GetRelation().\n \t\t// tRelation may be empty, and in this case, we set it to userset.GetComputedUserset().GetRelation().\n \t\tif tRelation == \"\" {\n \t\t\ttRelation = userset.GetComputedUserset().GetRelation()\n \t\t}\n+\n \t\tif tRelation != userset.GetComputedUserset().GetRelation() {\n \t\t\tcontinue\n \t\t}\n+\n \t\tcs := &openfgapb.TupleKey{\n \t\t\tObject:   tObject,\n \t\t\tRelation: tRelation,\n \t\t}\n+\n \t\tcomputedRelation := toObjectRelation(cs)\n \t\tif !seen[computedRelation] {\n \t\t\tcomputed = append(computed, &openfgapb.UsersetTree_Computed{Userset: computedRelation})\n \t\t\tseen[computedRelation] = true\n \t\t}\n \t}\n+\n \treturn &openfgapb.UsersetTree_Node{\n \t\tName: toObjectRelation(tk),\n \t\tValue: &openfgapb.UsersetTree_Node_Leaf{"
        },
        {
          "filename": "server/test/check.go",
          "status": "modified",
          "additions": 99,
          "deletions": 7,
          "patch": "@@ -1167,6 +1167,104 @@ func TestCheckQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n \t\t\t\tAllowed: true,\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname:             \"Error if * encountered in TupleToUserset evaluation\",\n+\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n+\t\t\trequest: &openfgapb.CheckRequest{\n+\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:anne\"),\n+\t\t\t},\n+\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n+\t\t\t\t{\n+\t\t\t\t\tType: \"document\",\n+\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n+\t\t\t\t\t\t\"parent\": typesystem.This(),\n+\t\t\t\t\t\t\"viewer\": typesystem.TupleToUserset(\"parent\", \"viewer\"),\n+\t\t\t\t\t},\n+\t\t\t\t\tMetadata: &openfgapb.Metadata{\n+\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n+\t\t\t\t\t\t\t\"parent\": {\n+\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n+\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"folder\", \"\"),\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tType: \"folder\",\n+\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n+\t\t\t\t\t\t\"viewer\": typesystem.This(),\n+\t\t\t\t\t},\n+\t\t\t\t\tMetadata: &openfgapb.Metadata{\n+\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n+\t\t\t\t\t\t\t\"viewer\": {\n+\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n+\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"user\", \"\"),\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttuples: []*openfgapb.TupleKey{\n+\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"*\"), // wildcard not allowed on tupleset relations\n+\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:anne\"),\n+\t\t\t},\n+\t\t\terr: serverErrors.InvalidTuple(\n+\t\t\t\t\"unexpected wildcard evaluated on relation 'document#parent'\",\n+\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", commands.Wildcard),\n+\t\t\t),\n+\t\t},\n+\t\t{\n+\t\t\tname:             \"Error if * encountered in TTU evaluation including ContextualTuples\",\n+\t\t\tresolveNodeLimit: defaultResolveNodeLimit,\n+\t\t\trequest: &openfgapb.CheckRequest{\n+\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:anne\"),\n+\t\t\t\tContextualTuples: &openfgapb.ContextualTupleKeys{\n+\t\t\t\t\tTupleKeys: []*openfgapb.TupleKey{\n+\t\t\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"*\"), // wildcard not allowed on tupleset relations\n+\t\t\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:anne\"),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n+\t\t\t\t{\n+\t\t\t\t\tType: \"document\",\n+\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n+\t\t\t\t\t\t\"parent\": typesystem.This(),\n+\t\t\t\t\t\t\"viewer\": typesystem.TupleToUserset(\"parent\", \"viewer\"),\n+\t\t\t\t\t},\n+\t\t\t\t\tMetadata: &openfgapb.Metadata{\n+\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n+\t\t\t\t\t\t\t\"parent\": {\n+\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n+\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"folder\", \"\"),\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tType: \"folder\",\n+\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n+\t\t\t\t\t\t\"viewer\": typesystem.This(),\n+\t\t\t\t\t},\n+\t\t\t\t\tMetadata: &openfgapb.Metadata{\n+\t\t\t\t\t\tRelations: map[string]*openfgapb.RelationMetadata{\n+\t\t\t\t\t\t\t\"viewer\": {\n+\t\t\t\t\t\t\t\tDirectlyRelatedUserTypes: []*openfgapb.RelationReference{\n+\t\t\t\t\t\t\t\t\ttypesystem.RelationReference(\"user\", \"\"),\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\terr: serverErrors.InvalidTuple(\n+\t\t\t\t\"unexpected wildcard evaluated on relation 'document#parent'\",\n+\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", commands.Wildcard),\n+\t\t\t),\n+\t\t},\n \t}\n \n \tctx := context.Background()\n@@ -1196,13 +1294,7 @@ func TestCheckQuery(t *testing.T, datastore storage.OpenFGADatastore) {\n \t\t\ttest.request.AuthorizationModelId = model.Id\n \t\t\tresp, gotErr := cmd.Execute(ctx, test.request)\n \n-\t\t\tif test.err == nil {\n-\t\t\t\trequire.NoError(t, gotErr)\n-\t\t\t}\n-\n-\t\t\tif test.err != nil {\n-\t\t\t\trequire.EqualError(t, test.err, gotErr.Error())\n-\t\t\t}\n+\t\t\trequire.ErrorIs(t, gotErr, test.err)\n \n \t\t\tif test.response != nil {\n \t\t\t\trequire.NoError(t, gotErr)"
        },
        {
          "filename": "server/test/expand.go",
          "status": "modified",
          "additions": 27,
          "deletions": 4,
          "patch": "@@ -4,12 +4,12 @@ import (\n \t\"context\"\n \t\"testing\"\n \n-\t\"github.com/go-errors/errors\"\n \t\"github.com/google/go-cmp/cmp\"\n \t\"github.com/openfga/openfga/pkg/id\"\n \t\"github.com/openfga/openfga/pkg/logger\"\n \t\"github.com/openfga/openfga/pkg/telemetry\"\n \t\"github.com/openfga/openfga/pkg/testutils\"\n+\t\"github.com/openfga/openfga/pkg/tuple\"\n \t\"github.com/openfga/openfga/pkg/typesystem\"\n \t\"github.com/openfga/openfga/server/commands\"\n \tserverErrors \"github.com/openfga/openfga/server/errors\"\n@@ -811,6 +811,31 @@ func TestExpandQueryErrors(t *testing.T, datastore storage.OpenFGADatastore) {\n \t\t\t\tRelation: \"baz\",\n \t\t\t}),\n \t\t},\n+\t\t{\n+\t\t\tname: \"TupleToUserset involving wildcard returns error\",\n+\t\t\ttypeDefinitions: []*openfgapb.TypeDefinition{\n+\t\t\t\t{\n+\t\t\t\t\tType: \"document\",\n+\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n+\t\t\t\t\t\t\"parent\": typesystem.This(),\n+\t\t\t\t\t\t\"viewer\": typesystem.Union(\n+\t\t\t\t\t\t\ttypesystem.This(), typesystem.TupleToUserset(\"parent\", \"viewer\"),\n+\t\t\t\t\t\t),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttuples: []*openfgapb.TupleKey{\n+\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"*\"),\n+\t\t\t\ttuple.NewTupleKey(\"document:X\", \"viewer\", \"jon\"),\n+\t\t\t},\n+\t\t\trequest: &openfgapb.ExpandRequest{\n+\t\t\t\tTupleKey: tuple.NewTupleKey(\"document:1\", \"viewer\", \"\"),\n+\t\t\t},\n+\t\t\texpected: serverErrors.InvalidTuple(\n+\t\t\t\t\"unexpected wildcard evaluated on relation 'document#parent'\",\n+\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"*\"),\n+\t\t\t),\n+\t\t},\n \t}\n \n \trequire := require.New(t)\n@@ -830,9 +855,7 @@ func TestExpandQueryErrors(t *testing.T, datastore storage.OpenFGADatastore) {\n \t\t\ttest.request.AuthorizationModelId = modelID\n \n \t\t\t_, err = query.Execute(ctx, test.request)\n-\t\t\tif !errors.Is(err, test.expected) {\n-\t\t\t\tt.Fatalf(\"'%s': Execute(), err = %v, want %v\", test.name, err, test.expected)\n-\t\t\t}\n+\t\t\trequire.ErrorIs(err, test.expected)\n \t\t})\n \t}\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a76e26b459502416dcb2bef66b0e61b5cd4c1d3b",
            "date": "2025-01-24T21:47:11Z",
            "author_login": "miparnisari"
          },
          {
            "sha": "0613a3a05d91dc8a312fc6cdde5c6f61bf5ac615",
            "date": "2025-01-23T18:46:22Z",
            "author_login": "justincoh"
          },
          {
            "sha": "e556a14d903efb78dbf76324ded412e1fc8fcdc8",
            "date": "2025-01-23T01:44:21Z",
            "author_login": "justincoh"
          },
          {
            "sha": "e7d707aed3c9cc268c1f508756f870639c21d13d",
            "date": "2025-01-22T20:55:47Z",
            "author_login": "miparnisari"
          },
          {
            "sha": "04b8f54da6aa628cacb7e77bda7182f09166fecf",
            "date": "2025-01-22T20:32:27Z",
            "author_login": "justincoh"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-285",
    "description": "OpenFGA is an authorization/permission engine. Versions prior to version 0.2.4 are vulnerable to authorization bypass under certain conditions. Users who have wildcard (`*`) defined on tupleset relations in their authorization model are vulnerable. Version 0.2.4 contains a patch for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-10-25T17:15:56.273",
    "last_modified": "2024-11-21T07:18:04.517",
    "fix_date": "2022-10-20T22:29:12Z"
  },
  "references": [
    {
      "url": "https://github.com/openfga/openfga/commit/b466769cc100b2065047786578718d313f52695b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/releases/tag/v0.2.4",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/security/advisories/GHSA-vj4m-83m8-xpw5",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/commit/b466769cc100b2065047786578718d313f52695b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/releases/tag/v0.2.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/openfga/openfga/security/advisories/GHSA-vj4m-83m8-xpw5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:00.953886",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "openfga",
    "owner": "openfga",
    "created_at": "2022-06-08T18:47:15Z",
    "updated_at": "2025-01-25T14:36:21Z",
    "pushed_at": "2025-01-24T23:38:01Z",
    "size": 31334,
    "stars": 3185,
    "forks": 225,
    "open_issues": 121,
    "watchers": 3185,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 2914858,
      "Makefile": 7516,
      "Dockerfile": 1275,
      "HTML": 379
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:44:27.084121"
  }
}