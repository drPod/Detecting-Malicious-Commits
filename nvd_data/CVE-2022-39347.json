{
  "cve_id": "CVE-2022-39347",
  "github_data": {
    "repository": "FreeRDP/FreeRDP",
    "fix_commit": "027424c2c6c0991cb9c22f9511478229c9b17e5d",
    "related_commits": [
      "027424c2c6c0991cb9c22f9511478229c9b17e5d",
      "027424c2c6c0991cb9c22f9511478229c9b17e5d"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "027424c2c6c0991cb9c22f9511478229c9b17e5d",
      "commit_date": "2022-10-24T08:41:55Z",
      "author": {
        "login": "akallabeth",
        "type": "User",
        "stats": {
          "total_commits": 7864,
          "average_weekly_commits": 11.076056338028168,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 487
        }
      },
      "commit_message": {
        "title": "Fixed path validation in drive channel",
        "length": 172,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 122,
        "additions": 73,
        "deletions": 49
      },
      "files": [
        {
          "filename": "channels/drive/client/drive_file.c",
          "status": "modified",
          "additions": 65,
          "deletions": 41,
          "patch": "@@ -61,10 +61,14 @@\n \t} while (0)\n #endif\n \n-static void drive_file_fix_path(WCHAR* path)\n+static BOOL drive_file_fix_path(WCHAR* path, size_t length)\n {\n \tsize_t i;\n-\tsize_t length = _wcslen(path);\n+\n+\tif ((length == 0) || (length > UINT32_MAX))\n+\t\treturn FALSE;\n+\n+\tWINPR_ASSERT(path);\n \n \tfor (i = 0; i < length; i++)\n \t{\n@@ -75,71 +79,94 @@ static void drive_file_fix_path(WCHAR* path)\n #ifdef WIN32\n \n \tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n-\t\treturn;\n+\t\treturn FALSE;\n \n #else\n \n \tif ((length == 1) && (path[0] == L'/'))\n-\t\treturn;\n+\t\treturn FALSE;\n \n #endif\n \n \tif ((length > 0) && (path[length - 1] == L'/'))\n \t\tpath[length - 1] = L'\\0';\n+\n+\treturn TRUE;\n }\n \n static WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n-                                          size_t PathLength)\n+                                          size_t PathWCharLength)\n {\n-\tWCHAR* fullpath;\n-\tsize_t base_path_length;\n+\tBOOL ok = FALSE;\n+\tWCHAR* fullpath = NULL;\n+\tsize_t length;\n \n-\tif (!base_path || (!path && (PathLength > 0)))\n-\t\treturn NULL;\n+\tif (!base_path || (!path && (PathWCharLength > 0)))\n+\t\tgoto fail;\n \n-\tbase_path_length = _wcslen(base_path) * 2;\n-\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n+\tconst size_t base_path_length = _wcsnlen(base_path, MAX_PATH);\n+\tlength = base_path_length + PathWCharLength + 1;\n+\tfullpath = (WCHAR*)calloc(length, sizeof(WCHAR));\n \n \tif (!fullpath)\n+\t\tgoto fail;\n+\n+\tCopyMemory(fullpath, base_path, base_path_length * sizeof(WCHAR));\n+\tif (path)\n+\t\tCopyMemory(&fullpath[base_path_length], path, PathWCharLength * sizeof(WCHAR));\n+\n+\tif (!drive_file_fix_path(fullpath, length))\n+\t\tgoto fail;\n+\n+\t/* Ensure the path does not contain sequences like '..' */\n+\tconst WCHAR dotdot[] = { '.', '.', '\\0' };\n+\tif (_wcsstr(&fullpath[base_path_length], dotdot))\n \t{\n-\t\tWLog_ERR(TAG, \"malloc failed!\");\n-\t\treturn NULL;\n+\t\tchar abuffer[MAX_PATH] = { 0 };\n+\t\tConvertFromUnicode(CP_UTF8, 0, &fullpath[base_path_length], -1, (char**)&abuffer,\n+\t\t                   ARRAYSIZE(abuffer) - 1, NULL, NULL);\n+\n+\t\tWLog_WARN(TAG, \"[rdpdr] received invalid file path '%s' from server, aborting!\",\n+\t\t          &abuffer[base_path_length]);\n+\t\tgoto fail;\n \t}\n \n-\tCopyMemory(fullpath, base_path, base_path_length);\n-\tif (path)\n-\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n-\tdrive_file_fix_path(fullpath);\n+\tok = TRUE;\n+fail:\n+\tif (!ok)\n+\t{\n+\t\tfree(fullpath);\n+\t\tfullpath = NULL;\n+\t}\n \treturn fullpath;\n }\n \n static BOOL drive_file_remove_dir(const WCHAR* path)\n {\n-\tWIN32_FIND_DATAW findFileData;\n+\tWIN32_FIND_DATAW findFileData = { 0 };\n \tBOOL ret = TRUE;\n-\tHANDLE dir;\n-\tWCHAR* fullpath;\n-\tWCHAR* path_slash;\n-\tsize_t base_path_length;\n+\tHANDLE dir = INVALID_HANDLE_VALUE;\n+\tWCHAR* fullpath = NULL;\n+\tWCHAR* path_slash = NULL;\n+\tsize_t base_path_length = 0;\n \n \tif (!path)\n \t\treturn FALSE;\n \n-\tbase_path_length = _wcslen(path) * 2;\n-\tpath_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);\n+\tbase_path_length = _wcslen(path);\n+\tpath_slash = (WCHAR*)calloc(base_path_length + 3, sizeof(WCHAR));\n \n \tif (!path_slash)\n \t{\n \t\tWLog_ERR(TAG, \"malloc failed!\");\n \t\treturn FALSE;\n \t}\n \n-\tCopyMemory(path_slash, path, base_path_length);\n-\tpath_slash[base_path_length / 2] = L'/';\n-\tpath_slash[base_path_length / 2 + 1] = L'*';\n+\tCopyMemory(path_slash, path, base_path_length * sizeof(WCHAR));\n+\tpath_slash[base_path_length] = L'/';\n+\tpath_slash[base_path_length + 1] = L'*';\n \tDEBUG_WSTR(\"Search in %s\", path_slash);\n \tdir = FindFirstFileW(path_slash, &findFileData);\n-\tpath_slash[base_path_length / 2 + 1] = 0;\n \n \tif (dir == INVALID_HANDLE_VALUE)\n \t{\n@@ -149,15 +176,15 @@ static BOOL drive_file_remove_dir(const WCHAR* path)\n \n \tdo\n \t{\n-\t\tsize_t len = _wcslen(findFileData.cFileName);\n+\t\tconst size_t len = _wcsnlen(findFileData.cFileName, ARRAYSIZE(findFileData.cFileName));\n \n \t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n \t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n \t\t{\n \t\t\tcontinue;\n \t\t}\n \n-\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);\n+\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len);\n \t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n \n \t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n@@ -333,13 +360,13 @@ static BOOL drive_file_init(DRIVE_FILE* file)\n \treturn file->file_handle != INVALID_HANDLE_VALUE;\n }\n \n-DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n-                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n-                           UINT32 FileAttributes, UINT32 SharedAccess)\n+DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,\n+                           UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,\n+                           UINT32 CreateOptions, UINT32 FileAttributes, UINT32 SharedAccess)\n {\n \tDRIVE_FILE* file;\n \n-\tif (!base_path || (!path && (PathLength > 0)))\n+\tif (!base_path || (!path && (PathWCharLength > 0)))\n \t\treturn NULL;\n \n \tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n@@ -359,7 +386,7 @@ DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 Pat\n \tfile->CreateDisposition = CreateDisposition;\n \tfile->CreateOptions = CreateOptions;\n \tfile->SharedAccess = SharedAccess;\n-\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n+\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathWCharLength));\n \n \tif (!drive_file_init(file))\n \t{\n@@ -714,13 +741,10 @@ BOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UIN\n \t\t\t\treturn FALSE;\n \n \t\t\tfullpath = drive_file_combine_fullpath(file->basepath, (WCHAR*)Stream_Pointer(input),\n-\t\t\t                                       FileNameLength);\n+\t\t\t                                       FileNameLength / sizeof(WCHAR));\n \n \t\t\tif (!fullpath)\n-\t\t\t{\n-\t\t\t\tWLog_ERR(TAG, \"drive_file_combine_fullpath failed!\");\n \t\t\t\treturn FALSE;\n-\t\t\t}\n \n #ifdef _WIN32\n \n@@ -759,7 +783,7 @@ BOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UIN\n }\n \n BOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,\n-                                const WCHAR* path, UINT32 PathLength, wStream* output)\n+                                const WCHAR* path, UINT32 PathWCharLength, wStream* output)\n {\n \tsize_t length;\n \tWCHAR* ent_path;\n@@ -773,7 +797,7 @@ BOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYT\n \t\tif (file->find_handle != INVALID_HANDLE_VALUE)\n \t\t\tFindClose(file->find_handle);\n \n-\t\tent_path = drive_file_combine_fullpath(file->basepath, path, PathLength);\n+\t\tent_path = drive_file_combine_fullpath(file->basepath, path, PathWCharLength);\n \t\t/* open new search handle and retrieve the first entry */\n \t\tfile->find_handle = FindFirstFileW(ent_path, &file->find_data);\n \t\tfree(ent_path);"
        },
        {
          "filename": "channels/drive/client/drive_file.h",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -51,9 +51,9 @@ struct _DRIVE_FILE\n \tUINT32 CreateOptions;\n };\n \n-DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n-                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n-                           UINT32 FileAttributes, UINT32 SharedAccess);\n+DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,\n+                           UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,\n+                           UINT32 CreateOptions, UINT32 FileAttributes, UINT32 SharedAccess);\n BOOL drive_file_free(DRIVE_FILE* file);\n \n BOOL drive_file_open(DRIVE_FILE* file);\n@@ -64,6 +64,6 @@ BOOL drive_file_query_information(DRIVE_FILE* file, UINT32 FsInformationClass, w\n BOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,\n                                 wStream* input);\n BOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass, BYTE InitialQuery,\n-                                const WCHAR* path, UINT32 PathLength, wStream* output);\n+                                const WCHAR* path, UINT32 PathWCharLength, wStream* output);\n \n #endif /* FREERDP_CHANNEL_DRIVE_FILE_H */"
        },
        {
          "filename": "channels/drive/client/drive_main.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -184,8 +184,8 @@ static UINT drive_process_irp_create(DRIVE_DEVICE* drive, IRP* irp)\n \n \tpath = (const WCHAR*)Stream_Pointer(irp->input);\n \tFileId = irp->devman->id_sequence++;\n-\tfile = drive_file_new(drive->path, path, PathLength, FileId, DesiredAccess, CreateDisposition,\n-\t                      CreateOptions, FileAttributes, SharedAccess);\n+\tfile = drive_file_new(drive->path, path, PathLength / sizeof(WCHAR), FileId, DesiredAccess,\n+\t                      CreateDisposition, CreateOptions, FileAttributes, SharedAccess);\n \n \tif (!file)\n \t{\n@@ -639,8 +639,8 @@ static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n \t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n \t\tStream_Write_UINT32(irp->output, 0); /* Length */\n \t}\n-\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n-\t                                     irp->output))\n+\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,\n+\t                                     PathLength / sizeof(WCHAR), irp->output))\n \t{\n \t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n \t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6c812548b2a885b33157e8e5f14af26eec463a22",
            "date": "2025-01-25T08:38:10Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "912d9b83889ec6e53fdd4f98edbd4ab36c15f595",
            "date": "2025-01-24T13:07:17Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "600768a637b761ffeca7708c28b0e1286378d334",
            "date": "2025-01-23T19:50:45Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "e28302eaab5d6ee8ce7ebeacd652a5e11bef249d",
            "date": "2025-01-23T20:39:45Z",
            "author_login": "akallabeth"
          },
          {
            "sha": "b1eaf5e53070bf452413b1128311f1e634219311",
            "date": "2025-01-23T19:32:29Z",
            "author_login": "akallabeth"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 2.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing path canonicalization and base path check for `drive` channel. A malicious server can trick a FreeRDP based client to read files outside the shared directory. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the `/drive`, `/drives` or `+home-drive` redirection switch.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-11-16T20:15:10.367",
    "last_modified": "2024-11-21T07:18:05.243",
    "fix_date": "2022-10-24T08:41:55Z"
  },
  "references": [
    {
      "url": "https://github.com/FreeRDP/FreeRDP/commit/027424c2c6c0991cb9c22f9511478229c9b17e5d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-c5xq-8v35-pffg",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202401-16",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/FreeRDP/FreeRDP/commit/027424c2c6c0991cb9c22f9511478229c9b17e5d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-c5xq-8v35-pffg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202401-16",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:01.024136",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "FreeRDP",
    "owner": "FreeRDP",
    "created_at": "2011-06-30T19:14:15Z",
    "updated_at": "2025-01-26T00:00:51Z",
    "pushed_at": "2025-01-25T08:38:10Z",
    "size": 68437,
    "stars": 11266,
    "forks": 14955,
    "open_issues": 249,
    "watchers": 11266,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "stable-1.0",
      "stable-1.1",
      "stable-2.0"
    ],
    "languages": {
      "C": 17375733,
      "C++": 685294,
      "CMake": 628057,
      "Objective-C": 540407,
      "Java": 373545,
      "HTML": 99135,
      "Shell": 51751,
      "Python": 46892,
      "Lua": 27393,
      "Roff": 26338,
      "Perl": 8044,
      "C#": 5756,
      "CSS": 5696,
      "Makefile": 2420,
      "Rich Text Format": 937
    },
    "commit_activity": {
      "total_commits_last_year": 2306,
      "avg_commits_per_week": 44.34615384615385,
      "days_active_last_year": 266
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:40:53.763016"
  }
}