{
  "cve_id": "CVE-2022-39385",
  "github_data": {
    "repository": "discourse/discourse",
    "fix_commit": "a414520742da8dc9dc976d4fb7b72dbd445813bb",
    "related_commits": [
      "a414520742da8dc9dc976d4fb7b72dbd445813bb",
      "a414520742da8dc9dc976d4fb7b72dbd445813bb"
    ],
    "patch_url": "https://github.com/discourse/discourse/commit/a414520742da8dc9dc976d4fb7b72dbd445813bb.patch",
    "fix_commit_details": {
      "sha": "a414520742da8dc9dc976d4fb7b72dbd445813bb",
      "commit_date": "2022-11-14T02:02:06Z",
      "author": {
        "login": "martin-brennan",
        "type": "User",
        "stats": {
          "total_commits": 1378,
          "average_weekly_commits": 1.9884559884559885,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 245
        }
      },
      "commit_message": {
        "title": "SECURITY: Prevent email from being nil in InviteRedeemer (#19004)",
        "length": 927,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 719,
        "additions": 506,
        "deletions": 213
      },
      "files": [
        {
          "filename": "app/controllers/session_controller.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -760,7 +760,7 @@ def validate_invitiation!(sso)\n     end\n \n     if invite.redeemable?\n-      if !invite.is_invite_link? && sso.email != invite.email\n+      if invite.is_email_invite? && sso.email != invite.email\n         raise Invite::ValidationFailed.new(I18n.t(\"invite.not_matching_email\"))\n       end\n     elsif invite.expired?"
        },
        {
          "filename": "app/models/invite.rb",
          "status": "modified",
          "additions": 9,
          "deletions": 3,
          "patch": "@@ -74,8 +74,16 @@ def email_xor_domain\n     end\n   end\n \n+  # Even if a domain is specified on the invite, it still counts as\n+  # an invite link.\n   def is_invite_link?\n-    email.blank?\n+    self.email.blank?\n+  end\n+\n+  # Email invites have specific behaviour and it's easier to visually\n+  # parse is_email_invite? than !is_invite_link?\n+  def is_email_invite?\n+    self.email.present?\n   end\n \n   def redeemable?\n@@ -201,8 +209,6 @@ def redeem(\n   )\n     return if !redeemable?\n \n-    email = self.email if email.blank? && !is_invite_link?\n-\n     InviteRedeemer.new(\n       invite: self,\n       email: email,"
        },
        {
          "filename": "app/models/invite_redeemer.rb",
          "status": "modified",
          "additions": 80,
          "deletions": 25,
          "patch": "@@ -1,5 +1,18 @@\n # frozen_string_literal: true\n \n+# NOTE: There are a _lot_ of complicated rules and conditions for our\n+# invite system, and the code is spread out through a lot of places.\n+# Tread lightly and read carefully when modifying this code. You may\n+# also want to look at:\n+#\n+# * InvitesController\n+# * SessionController\n+# * Invite model\n+# * User model\n+#\n+# Invites that are scoped to a specific email (email IS NOT NULL on the Invite\n+# model) have different rules to invites that are considered an \"invite link\",\n+# (email IS NULL) on the Invite model.\n class InviteRedeemer\n   attr_reader :invite,\n     :email,\n@@ -13,7 +26,7 @@ class InviteRedeemer\n     :redeeming_user\n \n   def initialize(\n-    invite: nil,\n+    invite:,\n     email: nil,\n     username: nil,\n     name: nil,\n@@ -23,9 +36,7 @@ def initialize(\n     session: nil,\n     email_token: nil,\n     redeeming_user: nil)\n-\n     @invite = invite\n-    @email = email\n     @username = username\n     @name = name\n     @password = password\n@@ -34,6 +45,8 @@ def initialize(\n     @session = session\n     @email_token = email_token\n     @redeeming_user = redeeming_user\n+\n+    ensure_email_is_present!(email)\n   end\n \n   def redeem\n@@ -45,7 +58,29 @@ def redeem\n     end\n   end\n \n-  # extracted from User cause it is very specific to invites\n+  # The email must be present in some form since many of the methods\n+  # for processing + redemption rely on it. If it's still nil after\n+  # these checks then we have hit an edge case and should not proceed!\n+  def ensure_email_is_present!(email)\n+    if email.blank?\n+      Rails.logger.warn(\n+        \"email param was blank in InviteRedeemer for invite ID #{@invite.id}. The `redeeming_user` was #{@redeeming_user.present? ? \"(ID: #{@redeeming_user.id})\" : \"not\"} present.\",\n+      )\n+    end\n+\n+    if email.blank? && @invite.is_email_invite?\n+      @email = @invite.email\n+    elsif @redeeming_user.present?\n+      @email = @redeeming_user.email\n+    else\n+      @email = email\n+    end\n+\n+    raise Discourse::InvalidParameters if @email.blank?\n+  end\n+\n+  # This will _never_ be called if there is a redeeming_user being passed\n+  # in to InviteRedeemer -- see invited_user below.\n   def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil)\n     if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email)\n       available_username = username\n@@ -107,7 +142,10 @@ def self.create_user_from_invite(email:, invite:, username: nil, name: nil, pass\n     user.save!\n     authenticator.finish\n \n-    if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token\n+    if invite.emailed_status != Invite.emailed_status_types[:not_required] &&\n+        email == invite.email &&\n+        invite.email_token.present? &&\n+        email_token == invite.email_token\n       user.activate\n     end\n \n@@ -118,24 +156,26 @@ def self.create_user_from_invite(email:, invite:, username: nil, name: nil, pass\n \n   def can_redeem_invite?\n     return false if !invite.redeemable?\n+    return false if email.blank?\n \n-    # Invite has already been redeemed by anyone.\n-    if !invite.is_invite_link? && InvitedUser.exists?(invite_id: invite.id)\n+    # Invite scoped to email has already been redeemed by anyone.\n+    if invite.is_email_invite? && InvitedUser.exists?(invite_id: invite.id)\n       return false\n     end\n \n-    # Email will not be present if we are claiming an invite link, which\n-    # does not have an email or domain scope on the invitation.\n-    if email.present? || redeeming_user.present?\n-      email_to_check = redeeming_user&.email || email\n+    # The email will be present for either an invite link (where the user provides\n+    # us the email manually) or for an invite scoped to an email, where we\n+    # prefill the email and do not let the user modify it.\n+    #\n+    # Note that an invite link can also have a domain scope which must be checked.\n+    email_to_check = redeeming_user&.email || email\n \n-      if invite.email.present? && !invite.email_matches?(email_to_check)\n-        raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.not_matching_email'))\n-      end\n+    if invite.email.present? && !invite.email_matches?(email_to_check)\n+      raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.not_matching_email'))\n+    end\n \n-      if invite.domain.present? && !invite.domain_matches?(email_to_check)\n-        raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed'))\n-      end\n+    if invite.domain.present? && !invite.domain_matches?(email_to_check)\n+      raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed'))\n     end\n \n     # Anon user is trying to redeem an invitation, if an existing user already\n@@ -148,6 +188,10 @@ def can_redeem_invite?\n     true\n   end\n \n+  # Note that the invited_user is returned by #redeemed, so other places\n+  # (e.g. the InvitesController) can perform further actions on it, this\n+  # is why things like send_welcome_message are set without being saved\n+  # on the model.\n   def invited_user\n     return @invited_user if defined?(@invited_user)\n \n@@ -196,9 +240,18 @@ def mark_invite_redeemed\n   end\n \n   def add_to_private_topics_if_invited\n-    topic_ids = Topic.where(archetype: Archetype::private_message).includes(:invites).where(invites: { email: email }).pluck(:id)\n+    # Should not happen because of ensure_email_is_present!, but better to cover bases.\n+    return if email.blank?\n+\n+    topic_ids = TopicInvite.joins(:invite)\n+      .joins(:topic)\n+      .where(\"topics.archetype = ?\", Archetype::private_message)\n+      .where(\"invites.email = ?\", email)\n+      .pluck(:topic_id)\n     topic_ids.each do |id|\n-      TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id) unless TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id)\n+      if !TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id)\n+        TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id)\n+      end\n     end\n   end\n \n@@ -221,15 +274,17 @@ def send_welcome_message\n   end\n \n   def notify_invitee\n-    if inviter = invite.invited_by\n-      inviter.notifications.create!(\n-        notification_type: Notification.types[:invitee_accepted],\n-        data: { display_username: invited_user.username }.to_json\n-      )\n-    end\n+    return if invite.invited_by.blank?\n+    invite.invited_by.notifications.create!(\n+      notification_type: Notification.types[:invitee_accepted],\n+      data: { display_username: invited_user.username }.to_json\n+    )\n   end\n \n   def delete_duplicate_invites\n+    # Should not happen because of ensure_email_is_present!, but better to cover bases.\n+    return if email.blank?\n+\n     Invite\n       .where('invites.max_redemptions_allowed = 1')\n       .joins(\"LEFT JOIN invited_users ON invites.id = invited_users.invite_id\")"
        },
        {
          "filename": "db/migrate/20221103051248_remove_invalid_topic_allowed_users_from_invites.rb",
          "status": "added",
          "additions": 60,
          "deletions": 0,
          "patch": "@@ -0,0 +1,60 @@\n+# frozen_string_literal: true\n+\n+class RemoveInvalidTopicAllowedUsersFromInvites < ActiveRecord::Migration[7.0]\n+  def up\n+    # We are getting all the topic_allowed_users records that\n+    # match an invited user, which is created as part of the invite\n+    # redemption flow. The original invite would _not_ have had a topic_invite\n+    # record, and the user should have been added to the topic in the brief\n+    # period between creation of the invited_users record and the update of\n+    # that record.\n+    #\n+    # Having > 2 topic allowed users disqualifies messages sent only\n+    # by the system or an admin to the user.\n+    subquery_sql = <<~SQL\n+      SELECT DISTINCT id\n+      FROM (\n+               SELECT tau.id, tau.user_id, COUNT(*) OVER (PARTITION BY tau.user_id)\n+               FROM topic_allowed_users tau\n+                    JOIN invited_users iu ON iu.user_id = tau.user_id\n+                    LEFT JOIN topic_invites ti ON ti.invite_id = iu.invite_id AND tau.topic_id = ti.topic_id\n+               WHERE ti.id IS NULL\n+                 AND tau.created_at BETWEEN iu.created_at AND iu.updated_at\n+                 AND iu.redeemed_at > '2022-10-27'\n+           ) AS matching_topic_allowed_users\n+      WHERE matching_topic_allowed_users.count > 2\n+    SQL\n+\n+    # Back up the records we are going to change in case we are too\n+    # brutal, and for further inspection.\n+    #\n+    # TODO DROP this table (topic_allowed_users_backup_nov_2022) in a later migration.\n+    DB.exec(<<~SQL)\n+      CREATE TABLE topic_allowed_users_backup_nov_2022\n+      (\n+          id       INT NOT NULL,\n+          user_id  INT NOT NULL,\n+          topic_id INT NOT NULL\n+      );\n+      INSERT INTO topic_allowed_users_backup_nov_2022(id, user_id, topic_id)\n+      SELECT id, user_id, topic_id\n+      FROM topic_allowed_users\n+      WHERE id IN (\n+                      #{subquery_sql}\n+                  )\n+    SQL\n+\n+    # Delete the invalid topic allowed users that should not be there.\n+    DB.query(<<~SQL)\n+      DELETE\n+      FROM topic_allowed_users\n+      WHERE id IN (\n+                      #{subquery_sql}\n+                  )\n+    SQL\n+  end\n+\n+  def down\n+    raise ActiveRecord::IrreversibleMigration\n+  end\n+end"
        },
        {
          "filename": "spec/models/invite_redeemer_spec.rb",
          "status": "modified",
          "additions": 229,
          "deletions": 125,
          "patch": "@@ -3,6 +3,83 @@\n RSpec.describe InviteRedeemer do\n   fab!(:admin) { Fabricate(:admin) }\n \n+  describe \"#initialize\" do\n+    fab!(:redeeming_user) { Fabricate(:user, email: \"redeemer@test.com\") }\n+\n+    context \"for invite link\" do\n+      fab!(:invite) { Fabricate(:invite, email: nil) }\n+\n+      context \"when an email is passed in without a redeeming user\" do\n+        it \"uses that email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: \"blah@test.com\")\n+          expect(redeemer.email).to eq(\"blah@test.com\")\n+          expect { redeemer.redeem }.to change { User.count }\n+          expect(User.find_by_email(redeemer.email)).to be_present\n+        end\n+      end\n+\n+      context \"when an email is passed in with a redeeming user\" do\n+        it \"uses the redeeming user's email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: \"blah@test.com\", redeeming_user: redeeming_user)\n+          expect(redeemer.email).to eq(redeeming_user.email)\n+          expect { redeemer.redeem }.not_to change { User.count }\n+        end\n+      end\n+\n+      context \"when an email is not passed in with a redeeming user\" do\n+        it \"uses the redeeming user's email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: nil, redeeming_user: redeeming_user)\n+          expect(redeemer.email).to eq(redeeming_user.email)\n+          expect { redeemer.redeem }.not_to change { User.count }\n+        end\n+      end\n+\n+      context \"when no email and no redeeming user is passed in\" do\n+        it \"raises an error\" do\n+          expect { described_class.new(invite: invite, email: nil, redeeming_user: nil) }.to raise_error(Discourse::InvalidParameters)\n+        end\n+      end\n+    end\n+\n+    context \"for invite with email\" do\n+      fab!(:invite) { Fabricate(:invite, email: \"foobar@example.com\") }\n+\n+      context \"when an email is passed in without a redeeming user\" do\n+        it \"uses that email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: \"foobar@example.com\")\n+          expect(redeemer.email).to eq(\"foobar@example.com\")\n+          expect { redeemer.redeem }.to change { User.count }\n+          expect(User.find_by_email(redeemer.email)).to be_present\n+        end\n+      end\n+\n+      context \"when an email is passed in with a redeeming user\" do\n+        it \"uses the redeeming user's email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: \"blah@test.com\", redeeming_user: redeeming_user)\n+          expect(redeemer.email).to eq(redeeming_user.email)\n+          expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(\"invite.not_matching_email\"))\n+        end\n+      end\n+\n+      context \"when an email is not passed in with a redeeming user\" do\n+        it \"uses the invite email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: nil, redeeming_user: redeeming_user)\n+          expect(redeemer.email).to eq(\"foobar@example.com\")\n+          expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(\"invite.not_matching_email\"))\n+        end\n+      end\n+\n+      context \"when no email and no redeeming user is passed in\" do\n+        it \"uses the invite email for invite redemption\" do\n+          redeemer = described_class.new(invite: invite, email: nil, redeeming_user: nil)\n+          expect(redeemer.email).to eq(\"foobar@example.com\")\n+          expect { redeemer.redeem }.to change { User.count }\n+          expect(User.find_by_email(redeemer.email)).to be_present\n+        end\n+      end\n+    end\n+  end\n+\n   describe '.create_user_from_invite' do\n     it \"should be created correctly\" do\n       invite = Fabricate(:invite, email: 'walter.white@email.com')\n@@ -113,171 +190,198 @@\n   end\n \n   describe \"#redeem\" do\n-    fab!(:invite) { Fabricate(:invite, email: \"foobar@example.com\") }\n     let(:name) { 'john snow' }\n     let(:username) { 'kingofthenorth' }\n     let(:password) { 'know5nOthiNG' }\n     let(:invite_redeemer) { InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name) }\n \n-    context \"when must_approve_users setting is enabled\" do\n-      before do\n-        SiteSetting.must_approve_users = true\n-      end\n+    context \"with email\" do\n+      fab!(:invite) { Fabricate(:invite, email: \"foobar@example.com\") }\n+      context \"when must_approve_users setting is enabled\" do\n+        before do\n+          SiteSetting.must_approve_users = true\n+        end\n \n-      it \"should redeem an invite but not approve the user when invite is created by a staff user\" do\n-        inviter = invite.invited_by\n-        inviter.update!(admin: true)\n-        user = invite_redeemer.redeem\n+        it \"should redeem an invite but not approve the user when invite is created by a staff user\" do\n+          inviter = invite.invited_by\n+          inviter.update!(admin: true)\n+          user = invite_redeemer.redeem\n \n-        expect(user.name).to eq(name)\n-        expect(user.username).to eq(username)\n-        expect(user.invited_by).to eq(inviter)\n-        expect(user.approved).to eq(false)\n+          expect(user.name).to eq(name)\n+          expect(user.username).to eq(username)\n+          expect(user.invited_by).to eq(inviter)\n+          expect(user.approved).to eq(false)\n \n-        expect(inviter.notifications.count).to eq(1)\n+          expect(inviter.notifications.count).to eq(1)\n+        end\n+\n+        it \"should redeem the invite but not approve the user when invite is created by a regular user\" do\n+          inviter = invite.invited_by\n+          user = invite_redeemer.redeem\n+\n+          expect(user.name).to eq(name)\n+          expect(user.username).to eq(username)\n+          expect(user.invited_by).to eq(inviter)\n+          expect(user.approved).to eq(false)\n+\n+          expect(inviter.notifications.count).to eq(1)\n+        end\n+\n+        it \"should redeem the invite and approve the user when user email is in auto_approve_email_domains setting\" do\n+          SiteSetting.auto_approve_email_domains = \"example.com\"\n+          user = invite_redeemer.redeem\n+\n+          expect(user.name).to eq(name)\n+          expect(user.username).to eq(username)\n+          expect(user.approved).to eq(true)\n+          expect(user.approved_by).to eq(Discourse.system_user)\n+        end\n       end\n \n-      it \"should redeem the invite but not approve the user when invite is created by a regular user\" do\n+      it \"should redeem the invite if invited by non staff and approve if staff not required to approve\" do\n         inviter = invite.invited_by\n         user = invite_redeemer.redeem\n \n         expect(user.name).to eq(name)\n         expect(user.username).to eq(username)\n         expect(user.invited_by).to eq(inviter)\n-        expect(user.approved).to eq(false)\n-\n         expect(inviter.notifications.count).to eq(1)\n+        expect(user.approved).to eq(false)\n       end\n \n-      it \"should redeem the invite and approve the user when user email is in auto_approve_email_domains setting\" do\n-        SiteSetting.auto_approve_email_domains = \"example.com\"\n-        user = invite_redeemer.redeem\n-\n-        expect(user.name).to eq(name)\n-        expect(user.username).to eq(username)\n-        expect(user.approved).to eq(true)\n-        expect(user.approved_by).to eq(Discourse.system_user)\n+      it \"should delete invite if invited_by user has been removed\" do\n+        invite.invited_by.destroy!\n+        expect { invite.reload }.to raise_error(ActiveRecord::RecordNotFound)\n       end\n-    end\n \n-    it \"should redeem the invite if invited by non staff and approve if staff not required to approve\" do\n-      inviter = invite.invited_by\n-      user = invite_redeemer.redeem\n-\n-      expect(user.name).to eq(name)\n-      expect(user.username).to eq(username)\n-      expect(user.invited_by).to eq(inviter)\n-      expect(inviter.notifications.count).to eq(1)\n-      expect(user.approved).to eq(false)\n-    end\n-\n-    it \"should delete invite if invited_by user has been removed\" do\n-      invite.invited_by.destroy!\n-      expect { invite.reload }.to raise_error(ActiveRecord::RecordNotFound)\n-    end\n+      it \"can set password\" do\n+        user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n+        expect(user).to have_password\n+        expect(user.confirm_password?(password)).to eq(true)\n+        expect(user.approved).to eq(false)\n+      end\n \n-    it \"can set password\" do\n-      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n-      expect(user).to have_password\n-      expect(user.confirm_password?(password)).to eq(true)\n-      expect(user.approved).to eq(false)\n-    end\n+      it \"can set custom fields\" do\n+        required_field = Fabricate(:user_field)\n+        optional_field = Fabricate(:user_field, required: false)\n+        user_fields = {\n+          required_field.id.to_s => 'value1',\n+          optional_field.id.to_s => 'value2'\n+        }\n+        user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password, user_custom_fields: user_fields).redeem\n+\n+        expect(user).to be_present\n+        expect(user.custom_fields[\"user_field_#{required_field.id}\"]).to eq('value1')\n+        expect(user.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value2')\n+      end\n \n-    it \"can set custom fields\" do\n-      required_field = Fabricate(:user_field)\n-      optional_field = Fabricate(:user_field, required: false)\n-      user_fields = {\n-        required_field.id.to_s => 'value1',\n-        optional_field.id.to_s => 'value2'\n-      }\n-      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password, user_custom_fields: user_fields).redeem\n-\n-      expect(user).to be_present\n-      expect(user.custom_fields[\"user_field_#{required_field.id}\"]).to eq('value1')\n-      expect(user.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value2')\n-    end\n+      it \"does not add user to group if inviter does not have permissions\" do\n+        group = Fabricate(:group, grant_trust_level: 2)\n+        InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n+        user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n \n-    it \"does not add user to group if inviter does not have permissions\" do\n-      group = Fabricate(:group, grant_trust_level: 2)\n-      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n-      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n+        expect(user.group_users.count).to eq(0)\n+      end\n \n-      expect(user.group_users.count).to eq(0)\n-    end\n+      it \"adds user to group\" do\n+        group = Fabricate(:group, grant_trust_level: 2)\n+        InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n+        group.add_owner(invite.invited_by)\n \n-    it \"adds user to group\" do\n-      group = Fabricate(:group, grant_trust_level: 2)\n-      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n-      group.add_owner(invite.invited_by)\n+        user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n \n-      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n+        expect(user.group_users.count).to eq(4)\n+        expect(user.trust_level).to eq(2)\n+      end\n \n-      expect(user.group_users.count).to eq(4)\n-      expect(user.trust_level).to eq(2)\n-    end\n+      it \"adds an entry to the group logs when the invited user is added to a group\" do\n+        group = Fabricate(:group)\n+        InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n+        group.add_owner(invite.invited_by)\n+\n+        GroupHistory.destroy_all\n+\n+        user = InviteRedeemer.new(\n+          invite: invite,\n+          email: invite.email,\n+          username: username,\n+          name: name,\n+          password: password\n+        ).redeem\n+\n+        expect(group.reload.usernames.split(\",\")).to include(user.username)\n+        expect(GroupHistory.exists?(\n+          target_user_id: user.id,\n+          acting_user: invite.invited_by.id,\n+          group_id: group.id,\n+          action: GroupHistory.actions[:add_user_to_group]\n+        )).to eq(true)\n+      end\n \n-    it \"adds an entry to the group logs when the invited user is added to a group\" do\n-      group = Fabricate(:group)\n-      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n-      group.add_owner(invite.invited_by)\n+      it \"only allows one user to be created per invite\" do\n+        user = invite_redeemer.redeem\n+        invite.reload\n \n-      GroupHistory.destroy_all\n+        user.email = \"john@example.com\"\n+        user.save!\n \n-      user = InviteRedeemer.new(\n-        invite: invite,\n-        email: invite.email,\n-        username: username,\n-        name: name,\n-        password: password\n-      ).redeem\n-\n-      expect(group.reload.usernames.split(\",\")).to include(user.username)\n-      expect(GroupHistory.exists?(\n-        target_user_id: user.id,\n-        acting_user: invite.invited_by.id,\n-        group_id: group.id,\n-        action: GroupHistory.actions[:add_user_to_group]\n-      )).to eq(true)\n-    end\n+        another_invite_redeemer = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name)\n+        another_user = another_invite_redeemer.redeem\n+        expect(another_user).to eq(nil)\n+      end\n \n-    it \"only allows one user to be created per invite\" do\n-      user = invite_redeemer.redeem\n-      invite.reload\n+      it \"should correctly update the invite redeemed_at date\" do\n+        SiteSetting.invite_expiry_days = 2\n+        invite.update!(created_at: 10.days.ago)\n \n-      user.email = \"john@example.com\"\n-      user.save!\n+        inviter = invite.invited_by\n+        inviter.admin = true\n+        user = invite_redeemer.redeem\n+        invite.reload\n \n-      another_invite_redeemer = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name)\n-      another_user = another_invite_redeemer.redeem\n-      expect(another_user).to eq(nil)\n-    end\n+        expect(user.invited_by).to eq(inviter)\n+        expect(inviter.notifications.count).to eq(1)\n+        expect(invite.invited_users.first).to be_present\n+      end\n \n-    it \"should correctly update the invite redeemed_at date\" do\n-      SiteSetting.invite_expiry_days = 2\n-      invite.update!(created_at: 10.days.ago)\n+      it \"raises an error if the email does not match the invite email\" do\n+        redeemer = InviteRedeemer.new(invite: invite, email: \"blah@test.com\", username: username, name: name)\n+        expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(\"invite.not_matching_email\"))\n+      end\n \n-      inviter = invite.invited_by\n-      inviter.admin = true\n-      user = invite_redeemer.redeem\n-      invite.reload\n+      it \"adds the user to the appropriate private topic and no others\" do\n+        topic1 = Fabricate(:private_message_topic)\n+        topic2 = Fabricate(:private_message_topic)\n+        TopicInvite.create(invite: invite, topic: topic1)\n+        user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n+        expect(TopicAllowedUser.exists?(topic: topic1, user: user)).to eq(true)\n+        expect(TopicAllowedUser.exists?(topic: topic2, user: user)).to eq(false)\n+      end\n \n-      expect(user.invited_by).to eq(inviter)\n-      expect(inviter.notifications.count).to eq(1)\n-      expect(invite.invited_users.first).to be_present\n-    end\n+      context \"when a redeeming user is passed in\" do\n+        fab!(:redeeming_user) { Fabricate(:user, email: \"foobar@example.com\") }\n \n-    it \"raises an error if the email does not match the invite email\" do\n-      redeemer = InviteRedeemer.new(invite: invite, email: \"blah@test.com\", username: username, name: name)\n-      expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(\"invite.not_matching_email\"))\n-    end\n+        it \"raises an error if the email does not match the invite email\" do\n+          redeeming_user.update!(email: \"foo@bar.com\")\n+          redeemer = InviteRedeemer.new(invite: invite, redeeming_user: redeeming_user)\n+          expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(\"invite.not_matching_email\"))\n+        end\n \n-    context \"when a redeeming user is passed in\" do\n-      fab!(:redeeming_user) { Fabricate(:user, email: \"foobar@example.com\") }\n+        it \"adds the user to the appropriate private topic and no others\" do\n+          topic1 = Fabricate(:private_message_topic)\n+          topic2 = Fabricate(:private_message_topic)\n+          TopicInvite.create(invite: invite, topic: topic1)\n+          InviteRedeemer.new(invite: invite, redeeming_user: redeeming_user).redeem\n+          expect(TopicAllowedUser.exists?(topic: topic1, user: redeeming_user)).to eq(true)\n+          expect(TopicAllowedUser.exists?(topic: topic2, user: redeeming_user)).to eq(false)\n+        end\n \n-      it \"raises an error if the email does not match the invite email\" do\n-        redeeming_user.update!(email: \"foo@bar.com\")\n-        redeemer = InviteRedeemer.new(invite: invite, redeeming_user: redeeming_user)\n-        expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(\"invite.not_matching_email\"))\n+        it \"does not create a topic allowed user record if the invited user is already in the topic\" do\n+          topic1 = Fabricate(:private_message_topic)\n+          TopicInvite.create(invite: invite, topic: topic1)\n+          TopicAllowedUser.create(topic: topic1, user: redeeming_user)\n+          expect { InviteRedeemer.new(invite: invite, redeeming_user: redeeming_user).redeem }.not_to change { TopicAllowedUser.count }\n+        end\n       end\n     end\n "
        },
        {
          "filename": "spec/requests/invites_controller_spec.rb",
          "status": "modified",
          "additions": 127,
          "deletions": 59,
          "patch": "@@ -912,76 +912,144 @@\n     end\n \n     context 'when user is already logged in' do\n-      fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }\n-      fab!(:user) { Fabricate(:user, email: 'test@example.com') }\n-      fab!(:group) { Fabricate(:group) }\n-\n       before { sign_in(user) }\n \n-      it 'redeems the invitation and creates the invite accepted notification' do\n-        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n-        expect(response.status).to eq(200)\n-        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n-        invite.reload\n-        expect(invite.invited_users.first.user).to eq(user)\n-        expect(invite.redeemed?).to be_truthy\n-        expect(\n-          Notification.exists?(\n-            user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]\n-          )\n-        ).to eq(true)\n-      end\n+      context \"for an email invite\" do\n+        fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }\n+        fab!(:user) { Fabricate(:user, email: 'test@example.com') }\n+        fab!(:group) { Fabricate(:group) }\n \n-      it 'redirects to the first topic the user was invited to and creates the topic notification' do\n-        topic = Fabricate(:topic)\n-        TopicInvite.create!(invite: invite, topic: topic)\n-        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n-        expect(response.status).to eq(200)\n-        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n-        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n-      end\n+        it 'redeems the invitation and creates the invite accepted notification' do\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n+          invite.reload\n+          expect(invite.invited_users.first.user).to eq(user)\n+          expect(invite.redeemed?).to be_truthy\n+          expect(\n+            Notification.exists?(\n+              user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]\n+            )\n+          ).to eq(true)\n+        end\n \n-      it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n-        group.add_owner(invite.invited_by)\n-        secured_category = Fabricate(:category)\n-        secured_category.permissions = { group.name => :full }\n-        secured_category.save!\n+        it 'redirects to the first topic the user was invited to and creates the topic notification' do\n+          topic = Fabricate(:topic)\n+          TopicInvite.create!(invite: invite, topic: topic)\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n+          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n+        end\n \n-        topic = Fabricate(:topic, category: secured_category)\n-        TopicInvite.create!(invite: invite, topic: topic)\n-        InvitedGroup.create!(invite: invite, group: group)\n+        it \"adds the user to the private topic\" do\n+          topic = Fabricate(:private_message_topic)\n+          TopicInvite.create!(invite: invite, topic: topic)\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n+          expect(TopicAllowedUser.exists?(user: user, topic: topic)).to eq(true)\n+        end\n \n-        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n-        expect(response.status).to eq(200)\n-        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n-        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n-        invite.reload\n-        expect(invite.redeemed?).to be_truthy\n-        expect(user.reload.groups).to include(group)\n-        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n-      end\n+        it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n+          group.add_owner(invite.invited_by)\n+          secured_category = Fabricate(:category)\n+          secured_category.permissions = { group.name => :full }\n+          secured_category.save!\n+\n+          topic = Fabricate(:topic, category: secured_category)\n+          TopicInvite.create!(invite: invite, topic: topic)\n+          InvitedGroup.create!(invite: invite, group: group)\n \n-      it \"does not try to log in the user automatically\" do\n-        expect do\n           put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n-        end.not_to change { UserAuthToken.count }\n-        expect(response.status).to eq(200)\n-        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n-      end\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n+          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n+          invite.reload\n+          expect(invite.redeemed?).to be_truthy\n+          expect(user.reload.groups).to include(group)\n+          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n+        end\n \n-      it \"errors if the user's email doesn't match the invite email\" do\n-        user.update!(email: \"blah@test.com\")\n-        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n-        expect(response.status).to eq(412)\n-        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_matching_email\"))\n+        it \"does not try to log in the user automatically\" do\n+          expect do\n+            put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          end.not_to change { UserAuthToken.count }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n+        end\n+\n+        it \"errors if the user's email doesn't match the invite email\" do\n+          user.update!(email: \"blah@test.com\")\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(412)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_matching_email\"))\n+        end\n+\n+        it \"errors if the user's email domain doesn't match the invite domain\" do\n+          user.update!(email: \"blah@test.com\")\n+          invite.update!(email: nil, domain: \"example.com\")\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(412)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))\n+        end\n       end\n \n-      it \"errors if the user's email domain doesn't match the invite domain\" do\n-        user.update!(email: \"blah@test.com\")\n-        invite.update!(email: nil, domain: \"example.com\")\n-        put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n-        expect(response.status).to eq(412)\n-        expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))\n+      context \"for an invite link\" do\n+        fab!(:invite) { Fabricate(:invite, email: nil) }\n+        fab!(:user) { Fabricate(:user, email: 'test@example.com') }\n+        fab!(:group) { Fabricate(:group) }\n+\n+        it 'redeems the invitation and creates the invite accepted notification' do\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n+          invite.reload\n+          expect(invite.invited_users.first.user).to eq(user)\n+          expect(invite.redeemed?).to be_truthy\n+          expect(\n+            Notification.exists?(\n+              user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]\n+            )\n+          ).to eq(true)\n+        end\n+\n+        it 'redirects to the first topic the user was invited to and creates the topic notification' do\n+          topic = Fabricate(:topic)\n+          TopicInvite.create!(invite: invite, topic: topic)\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n+          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n+        end\n+\n+        it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do\n+          group.add_owner(invite.invited_by)\n+          secured_category = Fabricate(:category)\n+          secured_category.permissions = { group.name => :full }\n+          secured_category.save!\n+\n+          topic = Fabricate(:topic, category: secured_category)\n+          TopicInvite.create!(invite: invite, topic: topic)\n+          InvitedGroup.create!(invite: invite, group: group)\n+\n+          put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n+          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)\n+          invite.reload\n+          expect(invite.redeemed?).to be_truthy\n+          expect(user.reload.groups).to include(group)\n+          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)\n+        end\n+\n+        it \"does not try to log in the user automatically\" do\n+          expect do\n+            put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }\n+          end.not_to change { UserAuthToken.count }\n+          expect(response.status).to eq(200)\n+          expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))\n+        end\n       end\n     end\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "496a739788d58a7f1c6bd59643d062ae37e982a0",
            "date": "2025-01-14T15:19:49Z",
            "author_login": "discourse-translator-bot"
          },
          {
            "sha": "a89086f7996f95024827df61fb0d86a516b269f6",
            "date": "2025-01-14T15:19:19Z",
            "author_login": "markvanlan"
          },
          {
            "sha": "473e37e7b3dcb254548a04695fb5e5f56a6de33b",
            "date": "2025-01-14T14:32:50Z",
            "author_login": "CvX"
          },
          {
            "sha": "eb64db828e116edbacdf10266f8102ed7028a2f2",
            "date": "2025-01-14T13:28:46Z",
            "author_login": "renato"
          },
          {
            "sha": "7330cfa76a6e6ab7bf90702fb1db5e1a37a2eca1",
            "date": "2025-01-14T13:28:16Z",
            "author_login": "awesomerobot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "Discourse is the an open source discussion platform. In some rare cases users redeeming an invitation can be added as a participant to several private message topics that they should not be added to. They are not notified of this, it happens transparently in the background. This issue has been resolved in commit `a414520742` and will be included in future releases. Users are advised to upgrade. Users are also advised to set `SiteSetting.max_invites_per_day` to 0 until the patch is installed.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-11-14T21:15:15.007",
    "last_modified": "2024-11-21T07:18:11.163",
    "fix_date": "2022-11-14T02:02:06Z"
  },
  "references": [
    {
      "url": "https://github.com/discourse/discourse/commit/a414520742da8dc9dc976d4fb7b72dbd445813bb",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-gh5r-j595-qx48",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/commit/a414520742da8dc9dc976d4fb7b72dbd445813bb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-gh5r-j595-qx48",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:01.016751",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "discourse",
    "owner": "discourse",
    "created_at": "2013-01-12T00:25:55Z",
    "updated_at": "2025-01-14T12:47:11Z",
    "pushed_at": "2025-01-14T12:47:07Z",
    "size": 692535,
    "stars": 42892,
    "forks": 8390,
    "open_issues": 67,
    "watchers": 42892,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 20275963,
      "JavaScript": 9399743,
      "HTML": 1461704,
      "Handlebars": 1070089,
      "SCSS": 988476,
      "Mustache": 32177,
      "Shell": 12314,
      "CSS": 2558
    },
    "commit_activity": {
      "total_commits_last_year": 5032,
      "avg_commits_per_week": 96.76923076923077,
      "days_active_last_year": 300
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:00:05.486140"
  }
}