{
  "cve_id": "CVE-2022-39388",
  "github_data": {
    "repository": "istio/istio",
    "fix_commit": "346260e5115e9fbc65ba8a559bc686e6ca046a32",
    "related_commits": [
      "346260e5115e9fbc65ba8a559bc686e6ca046a32",
      "9a643e270421560afb2630e00f76d46a55499df9",
      "346260e5115e9fbc65ba8a559bc686e6ca046a32",
      "9a643e270421560afb2630e00f76d46a55499df9"
    ],
    "patch_url": "https://github.com/istio/istio/commit/346260e5115e9fbc65ba8a559bc686e6ca046a32.patch",
    "fix_commit_details": {
      "sha": "346260e5115e9fbc65ba8a559bc686e6ca046a32",
      "commit_date": "2022-07-14T16:30:33Z",
      "author": {
        "login": "ramaraochavali",
        "type": "User",
        "stats": {
          "total_commits": 765,
          "average_weekly_commits": 1.7915690866510539,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 245
        }
      },
      "commit_message": {
        "title": "add xfcc authenticator (#39405)",
        "length": 1922,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 446,
        "additions": 393,
        "deletions": 53
      },
      "files": [
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -120,6 +120,8 @@ require (\n \tgithub.com/PuerkitoBio/purell v1.1.1 // indirect\n \tgithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect\n \tgithub.com/VividCortex/ewma v1.1.1 // indirect\n+\tgithub.com/alecholmes/xfccparser v0.1.0\n+\tgithub.com/alecthomas/participle v0.4.1 // indirect\n \tgithub.com/antlr/antlr4/runtime/Go/antlr v0.0.0-20220418222510-f25a4f6275ed // indirect\n \tgithub.com/asaskevich/govalidator v0.0.0-20210307081110-f21760c49a8d // indirect\n \tgithub.com/beorn7/perks v1.0.1 // indirect"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -257,7 +257,14 @@ github.com/afex/hystrix-go v0.0.0-20180502004556-fa1af6a1f4f5/go.mod h1:SkGFH1ia\n github.com/agext/levenshtein v1.2.3/go.mod h1:JEDfjyjHDjOF/1e4FlBE/PkbqA9OfWu2ki2W0IB5558=\n github.com/agnivade/levenshtein v1.0.1/go.mod h1:CURSv5d9Uaml+FovSIICkLbAUZ9S4RqaHDIsdSBg7lM=\n github.com/ahmetb/gen-crd-api-reference-docs v0.3.0/go.mod h1:TdjdkYhlOifCQWPs1UdTma97kQQMozf5h26hTuG70u8=\n+github.com/alecholmes/xfccparser v0.1.0 h1:/PBnzDBxfHJ66AinLNglzZH4oWLrc1/QTKlSoNNnei8=\n+github.com/alecholmes/xfccparser v0.1.0/go.mod h1:c1S35dudNR5aZ4Vf9zKCrEwC8iqwF4TcDAbU+RXQ5yY=\n+github.com/alecthomas/go-thrift v0.0.0-20170109061633-7914173639b2/go.mod h1:CxCgO+NdpMdi9SsTlGbc0W+/UNxO3I0AabOEJZ3w61w=\n github.com/alecthomas/kingpin v2.2.6+incompatible/go.mod h1:59OFYbFVLKQKq+mqrL6Rw5bR0c3ACQaawgXx0QYndlE=\n+github.com/alecthomas/kong v0.2.1/go.mod h1:+inYUSluD+p4L8KdviBSgzcqEjUQOfC5fQDRFuc36lI=\n+github.com/alecthomas/participle v0.4.1 h1:P2PJWzwrSpuCWXKnzqvw0b0phSfH1kJo4p2HvLynVsI=\n+github.com/alecthomas/participle v0.4.1/go.mod h1:T8u4bQOSMwrkTWOSyt8/jSFPEnRtd0FKFMjVfYBlqPs=\n+github.com/alecthomas/repr v0.0.0-20181024024818-d37bc2a10ba1/go.mod h1:xTS7Pm1pD1mvyM075QCDSRqH6qRLXylzS24ZTpRiSzQ=\n github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\n github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\n github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0="
        },
        {
          "filename": "licenses/github.com/alecholmes/xfccparser/LICENSE",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+MIT License\n+\n+Copyright (c) 2020 Alec Holmes\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
        },
        {
          "filename": "licenses/github.com/alecthomas/participle/COPYING",
          "status": "added",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -0,0 +1,19 @@\n+Copyright (C) 2017 Alec Thomas\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of\n+this software and associated documentation files (the \"Software\"), to deal in\n+the Software without restriction, including without limitation the rights to\n+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n+of the Software, and to permit persons to whom the Software is furnished to do\n+so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
        },
        {
          "filename": "pilot/pkg/bootstrap/server.go",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -322,6 +322,9 @@ func NewServer(args *PilotArgs, initFuncs ...func(*Server)) (*Server, error) {\n \t// so we build it later.\n \tauthenticators = append(authenticators,\n \t\tkubeauth.NewKubeJWTAuthenticator(s.environment.Watcher, s.kubeClient.Kube(), s.clusterID, s.multiclusterController.GetRemoteKubeClient, features.JwtPolicy))\n+\tif len(features.TrustedGatewayCIDR) > 0 {\n+\t\tauthenticators = append(authenticators, &authenticate.XfccAuthenticator{})\n+\t}\n \tif features.XDSAuth {\n \t\ts.XDSServer.Authenticators = authenticators\n \t}"
        },
        {
          "filename": "pilot/pkg/features/pilot.go",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -405,6 +405,18 @@ var (\n \t\t\"If enabled, pilot will authorize XDS clients, to ensure they are acting only as namespaces they have permissions for.\",\n \t).Get()\n \n+\t// TODO: Move this to proper API.\n+\ttrustedGatewayCIDR = env.RegisterStringVar(\n+\t\t\"TRUSTED_GATEWAY_CIDR\",\n+\t\t\"\",\n+\t\t\"If set, any connections from gateway to Istiod with this CIDR range are treated as trusted for using authenication mechanisms like XFCC.\"+\n+\t\t\t\" This can only be used when the network where Istiod and the authenticating gateways are running in a trusted/secure network\",\n+\t)\n+\n+\tTrustedGatewayCIDR = func() []string {\n+\t\treturn strings.Split(trustedGatewayCIDR.Get(), \",\")\n+\t}()\n+\n \tEnableServiceEntrySelectPods = env.RegisterBoolVar(\"PILOT_ENABLE_SERVICEENTRY_SELECT_PODS\", true,\n \t\t\"If enabled, service entries with selectors will select pods from the cluster. \"+\n \t\t\t\"It is safe to disable it if you are quite sure you don't need this feature\").Get()"
        },
        {
          "filename": "pilot/pkg/xds/auth.go",
          "status": "modified",
          "additions": 9,
          "deletions": 12,
          "patch": "@@ -18,7 +18,6 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"strings\"\n \n \t\"google.golang.org/grpc/codes\"\n \t\"google.golang.org/grpc/credentials\"\n@@ -27,12 +26,13 @@ import (\n \n \t\"istio.io/istio/pilot/pkg/features\"\n \t\"istio.io/istio/pilot/pkg/model\"\n+\t\"istio.io/istio/pkg/security\"\n \t\"istio.io/istio/pkg/spiffe\"\n \t\"istio.io/pkg/env\"\n )\n \n var AuthPlaintext = env.RegisterBoolVar(\"XDS_AUTH_PLAINTEXT\", false,\n-\t\"Authenticate plain text requests - used if Istiod is behind a gateway handling TLS\").Get()\n+\t\"Authenticate plain text requests - used if Istiod is running on a secure/trusted network\").Get()\n \n // authenticate authenticates the ADS request using the configured authenticators.\n // Returns the validated principals or an error.\n@@ -56,17 +56,14 @@ func (s *DiscoveryServer) authenticate(ctx context.Context) ([]string, error) {\n \tif _, ok := peerInfo.AuthInfo.(credentials.TLSInfo); !ok && !AuthPlaintext {\n \t\treturn nil, nil\n \t}\n-\tauthFailMsgs := []string{}\n-\tfor _, authn := range s.Authenticators {\n-\t\tu, err := authn.Authenticate(ctx)\n-\t\t// If one authenticator passes, return\n-\t\tif u != nil && u.Identities != nil && err == nil {\n-\t\t\treturn u.Identities, nil\n-\t\t}\n-\t\tauthFailMsgs = append(authFailMsgs, fmt.Sprintf(\"Authenticator %s: %v\", authn.AuthenticatorType(), err))\n-\t}\n \n-\tlog.Errorf(\"Failed to authenticate client from %s: %s\", peerInfo.Addr.String(), strings.Join(authFailMsgs, \"; \"))\n+\tam := security.AuthenticationManager{\n+\t\tAuthenticators: s.Authenticators,\n+\t}\n+\tif u := am.Authenticate(ctx); u != nil {\n+\t\treturn u.Identities, nil\n+\t}\n+\tlog.Errorf(\"Failed to authenticate client from %s: %s\", peerInfo.Addr.String(), am.FailedMessages())\n \treturn nil, errors.New(\"authentication failure\")\n }\n "
        },
        {
          "filename": "pkg/security/security.go",
          "status": "modified",
          "additions": 37,
          "deletions": 0,
          "patch": "@@ -23,11 +23,14 @@ import (\n \t\"time\"\n \n \t\"google.golang.org/grpc/metadata\"\n+\t\"google.golang.org/grpc/peer\"\n \n \t\"istio.io/pkg/env\"\n \tistiolog \"istio.io/pkg/log\"\n )\n \n+var securityLog = istiolog.RegisterScope(\"security\", \"security debugging\", 0)\n+\n const (\n \t// etc/certs files are used with external CA managing the certs,\n \t// i.e. mounted Secret or external plugin.\n@@ -351,12 +354,46 @@ type Caller struct {\n \tIdentities []string\n }\n \n+// Authenticator determines the caller identity based on request context.\n type Authenticator interface {\n \tAuthenticate(ctx context.Context) (*Caller, error)\n \tAuthenticatorType() string\n \tAuthenticateRequest(req *http.Request) (*Caller, error)\n }\n \n+// AuthenticationManager orchestrates all authenticators to perform authentication.\n+type AuthenticationManager struct {\n+\tAuthenticators []Authenticator\n+\t// authFailMsgs contains list of messages that authenticator wants to record - mainly used for logging.\n+\tauthFailMsgs []string\n+}\n+\n+// Authenticate loops through all the configured Authenticators and returns if one of the authenticator succeeds.\n+func (am *AuthenticationManager) Authenticate(ctx context.Context) *Caller {\n+\tfor _, authn := range am.Authenticators {\n+\t\tu, err := authn.Authenticate(ctx)\n+\t\tif u != nil && len(u.Identities) > 0 && err == nil {\n+\t\t\tsecurityLog.Debugf(\"Authentication successful through auth source %v\", u.AuthSource)\n+\t\t\treturn u\n+\t\t}\n+\t\tam.authFailMsgs = append(am.authFailMsgs, fmt.Sprintf(\"Authenticator %s: %v\", authn.AuthenticatorType(), err))\n+\t}\n+\treturn nil\n+}\n+\n+func GetConnectionAddress(ctx context.Context) string {\n+\tpeerInfo, ok := peer.FromContext(ctx)\n+\tpeerAddr := \"unknown\"\n+\tif ok {\n+\t\tpeerAddr = peerInfo.Addr.String()\n+\t}\n+\treturn peerAddr\n+}\n+\n+func (am *AuthenticationManager) FailedMessages() string {\n+\treturn strings.Join(am.authFailMsgs, \"; \")\n+}\n+\n func ExtractBearerToken(ctx context.Context) (string, error) {\n \tmd, ok := metadata.FromIncomingContext(ctx)\n \tif !ok {"
        },
        {
          "filename": "security/pkg/nodeagent/caclient/providers/citadel/client_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -44,7 +44,6 @@ import (\n \t\"istio.io/istio/security/pkg/credentialfetcher/plugin\"\n \t\"istio.io/istio/security/pkg/monitoring\"\n \t\"istio.io/istio/security/pkg/nodeagent/util\"\n-\tca2 \"istio.io/istio/security/pkg/server/ca\"\n )\n \n const (\n@@ -67,7 +66,8 @@ type mockCAServer struct {\n \n func (ca *mockCAServer) CreateCertificate(ctx context.Context, in *pb.IstioCertificateRequest) (*pb.IstioCertificateResponse, error) {\n \tif ca.Authenticator != nil {\n-\t\tcaller := ca2.Authenticate(ctx, []security.Authenticator{ca.Authenticator})\n+\t\tam := security.AuthenticationManager{Authenticators: []security.Authenticator{ca.Authenticator}}\n+\t\tcaller := am.Authenticate(ctx)\n \t\tif caller == nil {\n \t\t\treturn nil, status.Error(codes.Unauthenticated, \"request authenticate failure\")\n \t\t}"
        },
        {
          "filename": "security/pkg/nodeagent/test/mock/caserver.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -32,7 +32,6 @@ import (\n \t\"istio.io/istio/pkg/spiffe\"\n \tcaerror \"istio.io/istio/security/pkg/pki/error\"\n \t\"istio.io/istio/security/pkg/pki/util\"\n-\t\"istio.io/istio/security/pkg/server/ca\"\n \t\"istio.io/pkg/log\"\n )\n \n@@ -166,8 +165,10 @@ func (s *CAServer) CreateCertificate(ctx context.Context, request *pb.IstioCerti\n \t}\n \tid := []string{\"client-identity\"}\n \tif len(s.Authenticators) > 0 {\n-\t\tcaller := ca.Authenticate(ctx, s.Authenticators)\n+\t\tam := security.AuthenticationManager{Authenticators: s.Authenticators}\n+\t\tcaller := am.Authenticate(ctx)\n \t\tif caller == nil {\n+\t\t\tcaServerLog.Errorf(\"Failed to authenticate client from %s: %s\", security.GetConnectionAddress(ctx), am.FailedMessages())\n \t\t\treturn nil, status.Error(codes.Unauthenticated, \"request authenticate failure\")\n \t\t}\n \t\tid = caller.Identities"
        },
        {
          "filename": "security/pkg/server/ca/authenticate/cert_authenticator.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -15,10 +15,10 @@\n package authenticate\n \n import (\n+\t\"context\"\n \t\"fmt\"\n \t\"net/http\"\n \n-\t\"golang.org/x/net/context\"\n \t\"google.golang.org/grpc/credentials\"\n \t\"google.golang.org/grpc/peer\"\n "
        },
        {
          "filename": "security/pkg/server/ca/authenticate/xfcc_authenticator.go",
          "status": "added",
          "additions": 117,
          "deletions": 0,
          "patch": "@@ -0,0 +1,117 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package authenticate\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"strings\"\n+\n+\t\"github.com/alecholmes/xfccparser\"\n+\t\"google.golang.org/grpc/metadata\"\n+\t\"google.golang.org/grpc/peer\"\n+\n+\t\"istio.io/istio/pilot/pkg/features\"\n+\t\"istio.io/istio/pkg/security\"\n+)\n+\n+const (\n+\tXfccAuthenticatorType = \"XfccAuthenticator\"\n+)\n+\n+// XfccAuthenticator extracts identities from Xfcc header.\n+type XfccAuthenticator struct{}\n+\n+var _ security.Authenticator = &XfccAuthenticator{}\n+\n+func (xff XfccAuthenticator) AuthenticatorType() string {\n+\treturn XfccAuthenticatorType\n+}\n+\n+// Authenticate extracts identities from Xfcc Header.\n+func (xff XfccAuthenticator) Authenticate(ctx context.Context) (*security.Caller, error) {\n+\tpeerInfo, _ := peer.FromContext(ctx)\n+\t// First check if client is trusted client so that we can \"trust\" the Xfcc Header.\n+\tif !isTrustedAddress(peerInfo.Addr.String(), features.TrustedGatewayCIDR) {\n+\t\treturn nil, fmt.Errorf(\"caller from %s is not in the trusted network. XfccAuthenticator can not be used\", peerInfo.Addr.String())\n+\t}\n+\tmeta, ok := metadata.FromIncomingContext(ctx)\n+\n+\tif !ok || len(meta.Get(xfccparser.ForwardedClientCertHeader)) == 0 {\n+\t\treturn nil, nil\n+\t}\n+\txfccHeader := meta.Get(xfccparser.ForwardedClientCertHeader)[0]\n+\treturn buildSecurityCaller(xfccHeader)\n+}\n+\n+// AuthenticateRequest validates Xfcc Header.\n+func (xff XfccAuthenticator) AuthenticateRequest(req *http.Request) (*security.Caller, error) {\n+\txfccHeader := req.Header.Get(xfccparser.ForwardedClientCertHeader)\n+\tif len(xfccHeader) == 0 {\n+\t\treturn nil, nil\n+\t}\n+\treturn buildSecurityCaller(xfccHeader)\n+}\n+\n+func buildSecurityCaller(xfccHeader string) (*security.Caller, error) {\n+\tclientCerts, err := xfccparser.ParseXFCCHeader(xfccHeader)\n+\tif err != nil {\n+\t\tmessage := fmt.Sprintf(\"error in parsing xfcc header: %v\", err)\n+\t\treturn nil, fmt.Errorf(message)\n+\t}\n+\tif len(clientCerts) == 0 {\n+\t\tmessage := \"xfcc header does not have atleast one client certs\"\n+\t\treturn nil, fmt.Errorf(message)\n+\t}\n+\tids := []string{}\n+\tfor _, cc := range clientCerts {\n+\t\tids = append(ids, cc.URI)\n+\t\tids = append(ids, cc.DNS...)\n+\t\tif cc.Subject != nil {\n+\t\t\tids = append(ids, cc.Subject.CommonName)\n+\t\t}\n+\t}\n+\n+\treturn &security.Caller{\n+\t\tAuthSource: security.AuthSourceClientCertificate,\n+\t\tIdentities: ids,\n+\t}, nil\n+}\n+\n+func isTrustedAddress(addr string, trustedCidrs []string) bool {\n+\tfor _, cidr := range trustedCidrs {\n+\t\tif isInRange(addr, cidr) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\t// Always trust local host addresses.\n+\treturn net.ParseIP(addr).IsLoopback()\n+}\n+\n+func isInRange(addr, cidr string) bool {\n+\tif strings.Contains(cidr, \"/\") {\n+\t\tip, ipnet, err := net.ParseCIDR(cidr)\n+\t\tif err != nil {\n+\t\t\treturn false\n+\t\t}\n+\t\tif ip.To4() == nil && ip.To16() == nil {\n+\t\t\treturn false\n+\t\t}\n+\t\treturn ipnet.Contains(net.ParseIP(addr))\n+\t}\n+\treturn false\n+}"
        },
        {
          "filename": "security/pkg/server/ca/authenticate/xfcc_authenticator_test.go",
          "status": "added",
          "additions": 153,
          "deletions": 0,
          "patch": "@@ -0,0 +1,153 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package authenticate\n+\n+import (\n+\t\"net\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/alecholmes/xfccparser\"\n+\t\"golang.org/x/net/context\"\n+\t\"google.golang.org/grpc/metadata\"\n+\t\"google.golang.org/grpc/peer\"\n+\n+\t\"istio.io/istio/pkg/security\"\n+)\n+\n+func TestIsTrustedAddress(t *testing.T) {\n+\tcases := []struct {\n+\t\tname    string\n+\t\tcidr    string\n+\t\tpeer    string\n+\t\ttrusted bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"localhost client\",\n+\t\t\tcidr:    \"\",\n+\t\t\tpeer:    \"127.0.0.1\",\n+\t\t\ttrusted: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"external client without trusted cidr\",\n+\t\t\tcidr:    \"\",\n+\t\t\tpeer:    \"172.0.0.1\",\n+\t\t\ttrusted: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"cidr in range\",\n+\t\t\tcidr:    \"172.17.0.0/16,192.17.0.0/16\",\n+\t\t\tpeer:    \"172.17.0.2\",\n+\t\t\ttrusted: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"cidr in range with both ipv6 and ipv4\",\n+\t\t\tcidr:    \"172.17.0.0/16,2001:db8:1234:1a00::/56\",\n+\t\t\tpeer:    \"2001:0db8:1234:1aff:ffff:ffff:ffff:ffff\",\n+\t\t\ttrusted: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"cidr outside range\",\n+\t\t\tcidr:    \"172.17.0.0/16,172.17.0.0/16\",\n+\t\t\tpeer:    \"110.17.0.2\",\n+\t\t\ttrusted: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range cases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tif result := isTrustedAddress(tt.peer, strings.Split(tt.cidr, \",\")); result != tt.trusted {\n+\t\t\t\tt.Errorf(\"Unexpected authentication result: want %v but got %v\",\n+\t\t\t\t\ttt.trusted, result)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestXfccAuthenticator(t *testing.T) {\n+\tcases := []struct {\n+\t\tname               string\n+\t\txfccHeader         string\n+\t\tcaller             *security.Caller\n+\t\tauthenticateErrMsg string\n+\t}{\n+\t\t{\n+\t\t\tname:       \"No xfcc header\",\n+\t\t\txfccHeader: \"\",\n+\t\t\tcaller:     nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:               \"junk xfcc header\",\n+\t\t\txfccHeader:         `junk xfcc header`,\n+\t\t\tauthenticateErrMsg: `error in parsing xfcc header: invalid header format: unexpected token \"junk xfcc header\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Xfcc Header single hop\",\n+\t\t\t// nolint lll\n+\t\t\txfccHeader: `Hash=meshclient;Subject=\"\";URI=spiffe://mesh.example.com/ns/otherns/sa/othersa`,\n+\t\t\tcaller: &security.Caller{\n+\t\t\t\tAuthSource: security.AuthSourceClientCertificate,\n+\t\t\t\tIdentities: []string{\n+\t\t\t\t\t\"spiffe://mesh.example.com/ns/otherns/sa/othersa\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Xfcc Header multiple hops\",\n+\t\t\t// nolint lll\n+\t\t\txfccHeader: `Hash=hash;Cert=\"-----BEGIN%20CERTIFICATE-----%0cert%0A-----END%20CERTIFICATE-----%0A\";Subject=\"CN=hello,OU=hello,O=Acme\\, Inc.\";URI=spiffe://mesh.example.com/ns/firstns/sa/firstsa;DNS=hello.west.example.com;DNS=hello.east.example.com,By=spiffe://mesh.example.com/ns/hellons/sa/hellosa;Hash=again;Subject=\"\";URI=spiffe://mesh.example.com/ns/otherns/sa/othersa`,\n+\t\t\tcaller: &security.Caller{\n+\t\t\t\tAuthSource: security.AuthSourceClientCertificate,\n+\t\t\t\tIdentities: []string{\n+\t\t\t\t\t\"spiffe://mesh.example.com/ns/firstns/sa/firstsa\",\n+\t\t\t\t\t\"hello.west.example.com\",\n+\t\t\t\t\t\"hello.east.example.com\",\n+\t\t\t\t\t\"hello\",\n+\t\t\t\t\t\"spiffe://mesh.example.com/ns/otherns/sa/othersa\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tauth := &XfccAuthenticator{}\n+\n+\tfor _, tt := range cases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tmd := metadata.MD{}\n+\t\t\tif len(tt.xfccHeader) > 0 {\n+\t\t\t\tmd.Append(xfccparser.ForwardedClientCertHeader, tt.xfccHeader)\n+\t\t\t}\n+\t\t\tctx := peer.NewContext(context.Background(), &peer.Peer{Addr: &net.IPAddr{IP: net.ParseIP(\"127.0.0.1\").To4()}})\n+\t\t\tctx = metadata.NewIncomingContext(ctx, md)\n+\t\t\tresult, err := auth.Authenticate(ctx)\n+\t\t\tif len(tt.authenticateErrMsg) > 0 {\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Errorf(\"Succeeded. Error expected: %v\", err)\n+\t\t\t\t} else if err.Error() != tt.authenticateErrMsg {\n+\t\t\t\t\tt.Errorf(\"Incorrect error message: want %s but got %s\",\n+\t\t\t\t\t\ttt.authenticateErrMsg, err.Error())\n+\t\t\t\t}\n+\t\t\t} else if err != nil {\n+\t\t\t\tt.Fatalf(\"Unexpected Error: %v\", err)\n+\t\t\t}\n+\n+\t\t\tif !reflect.DeepEqual(tt.caller, result) {\n+\t\t\t\tt.Errorf(\"Unexpected authentication result: want %v but got %v\",\n+\t\t\t\t\ttt.caller, result)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "security/pkg/server/ca/server.go",
          "status": "modified",
          "additions": 2,
          "deletions": 31,
          "patch": "@@ -15,13 +15,11 @@\n package ca\n \n import (\n-\t\"fmt\"\n \t\"time\"\n \n \t\"golang.org/x/net/context\"\n \t\"google.golang.org/grpc\"\n \t\"google.golang.org/grpc/codes\"\n-\t\"google.golang.org/grpc/peer\"\n \t\"google.golang.org/grpc/status\"\n \n \tpb \"istio.io/api/security/v1alpha1\"\n@@ -54,15 +52,6 @@ type Server struct {\n \tserverCertTTL  time.Duration\n }\n \n-func getConnectionAddress(ctx context.Context) string {\n-\tpeerInfo, ok := peer.FromContext(ctx)\n-\tpeerAddr := \"unknown\"\n-\tif ok {\n-\t\tpeerAddr = peerInfo.Addr.String()\n-\t}\n-\treturn peerAddr\n-}\n-\n // CreateCertificate handles an incoming certificate signing request (CSR). It does\n // authentication and authorization. Upon validated, signs a certificate that:\n // the SAN is the identity of the caller in authentication result.\n@@ -73,7 +62,8 @@ func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertifi\n \t*pb.IstioCertificateResponse, error,\n ) {\n \ts.monitoring.CSR.Increment()\n-\tcaller := Authenticate(ctx, s.Authenticators)\n+\tam := security.AuthenticationManager{Authenticators: s.Authenticators}\n+\tcaller := am.Authenticate(ctx)\n \tif caller == nil {\n \t\ts.monitoring.AuthnError.Increment()\n \t\treturn nil, status.Error(codes.Unauthenticated, \"request authenticate failure\")\n@@ -158,22 +148,3 @@ func New(ca CertificateAuthority, ttl time.Duration,\n \t}\n \treturn server, nil\n }\n-\n-// authenticate goes through a list of authenticators (provided client cert, k8s jwt, and ID token)\n-// and authenticates if one of them is valid.\n-func Authenticate(ctx context.Context, auth []security.Authenticator) *security.Caller {\n-\t// TODO: apply different authenticators in specific order / according to configuration.\n-\tvar errMsg string\n-\tfor id, authn := range auth {\n-\t\tu, err := authn.Authenticate(ctx)\n-\t\tif err != nil {\n-\t\t\terrMsg += fmt.Sprintf(\"Authenticator %s at index %d got error: %v. \", authn.AuthenticatorType(), id, err)\n-\t\t}\n-\t\tif u != nil && err == nil {\n-\t\t\tserverCaLog.Debugf(\"Authentication successful through auth source %v\", u.AuthSource)\n-\t\t\treturn u\n-\t\t}\n-\t}\n-\tserverCaLog.Warnf(\"Authentication failed for %v: %s\", getConnectionAddress(ctx), errMsg)\n-\treturn nil\n-}"
        },
        {
          "filename": "security/pkg/server/ca/server_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -205,27 +205,27 @@ func TestCreateCertificate(t *testing.T) {\n \t\t\tca:   &mockca.FakeCA{},\n \t\t},\n \t\t\"CA not ready\": {\n-\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{}},\n+\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{identities: []string{\"test-identity\"}}},\n \t\t\tca:             &mockca.FakeCA{SignErr: caerror.NewError(caerror.CANotReady, fmt.Errorf(\"cannot sign\"))},\n \t\t\tcode:           codes.Internal,\n \t\t},\n \t\t\"Invalid CSR\": {\n-\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{}},\n+\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{identities: []string{\"test-identity\"}}},\n \t\t\tca:             &mockca.FakeCA{SignErr: caerror.NewError(caerror.CSRError, fmt.Errorf(\"cannot sign\"))},\n \t\t\tcode:           codes.InvalidArgument,\n \t\t},\n \t\t\"Invalid TTL\": {\n-\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{}},\n+\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{identities: []string{\"test-identity\"}}},\n \t\t\tca:             &mockca.FakeCA{SignErr: caerror.NewError(caerror.TTLError, fmt.Errorf(\"cannot sign\"))},\n \t\t\tcode:           codes.InvalidArgument,\n \t\t},\n \t\t\"Failed to sign\": {\n-\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{}},\n+\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{identities: []string{\"test-identity\"}}},\n \t\t\tca:             &mockca.FakeCA{SignErr: caerror.NewError(caerror.CertGenError, fmt.Errorf(\"cannot sign\"))},\n \t\t\tcode:           codes.Internal,\n \t\t},\n \t\t\"Successful signing\": {\n-\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{}},\n+\t\t\tauthenticators: []security.Authenticator{&mockAuthenticator{identities: []string{\"test-identity\"}}},\n \t\t\tca: &mockca.FakeCA{\n \t\t\t\tSignedCert:    []byte(\"cert\"),\n \t\t\t\tKeyCertBundle: util.NewKeyCertBundleFromPem(nil, nil, []byte(\"cert_chain\"), []byte(\"root_cert\")),"
        }
      ],
      "file_patterns": {
        "security_files": 9,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 11,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "282e0b96dba4b987884607ab3ce68fddbf9eb5f4",
            "date": "2025-01-14T17:08:52Z",
            "author_login": "keithmattix"
          },
          {
            "sha": "9cbc0328c88c02dc2b85ef79a42dc78e4083194a",
            "date": "2025-01-14T16:18:51Z",
            "author_login": "istio-testing"
          },
          {
            "sha": "e33c2b9aa5d3fc9131d58af3d42b33b49d6dd9dc",
            "date": "2025-01-13T20:01:51Z",
            "author_login": "whitneygriffith"
          },
          {
            "sha": "0a41d8a13e093ec771a3420e043c8688aa8f354b",
            "date": "2025-01-13T17:27:57Z",
            "author_login": "sridhargaddam"
          },
          {
            "sha": "a1946248a9fe05bc3cefd172ef773e0647cd7a89",
            "date": "2025-01-13T17:27:50Z",
            "author_login": "ilrudie"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.6,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N",
    "cwe_id": "CWE-863",
    "description": "Istio is an open platform to connect, manage, and secure microservices. In versions on the 1.15.x branch prior to 1.15.3, a user can impersonate any workload identity within the service mesh if they have localhost access to the Istiod control plane. Version 1.15.3 contains a patch for this issue. There are no known workarounds.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-11-10T20:15:10.587",
    "last_modified": "2024-11-21T07:18:11.550",
    "fix_date": "2022-07-14T16:30:33Z"
  },
  "references": [
    {
      "url": "https://github.com/istio/istio/commit/346260e5115e9fbc65ba8a559bc686e6ca046a32",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/istio/istio/commit/9a643e270421560afb2630e00f76d46a55499df9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/istio/istio/security/advisories/GHSA-6c6p-h79f-g6p4",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://istio.io/latest/news/releases/1.15.x/announcing-1.15.3/",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/istio/istio/commit/346260e5115e9fbc65ba8a559bc686e6ca046a32",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/istio/istio/commit/9a643e270421560afb2630e00f76d46a55499df9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/istio/istio/security/advisories/GHSA-6c6p-h79f-g6p4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://istio.io/latest/news/releases/1.15.x/announcing-1.15.3/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:01.007098",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "istio",
    "owner": "istio",
    "created_at": "2016-11-18T23:57:21Z",
    "updated_at": "2025-01-14T14:31:19Z",
    "pushed_at": "2025-01-13T20:01:51Z",
    "size": 275791,
    "stars": 36347,
    "forks": 7819,
    "open_issues": 499,
    "watchers": 36347,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "1.21.2-build-deps",
      "1.21.3-deps",
      "1.22-update-deps",
      "bookinfo-tidy",
      "craigbox-patch-1",
      "dependabot/go_modules/github.com/docker/docker-26.0.2incompatible",
      "dependabot/go_modules/google.golang.org/grpc-1.64.1",
      "dependabot/pip/samples/bookinfo/src/productpage/certifi-2024.7.4",
      "dependabot/pip/samples/bookinfo/src/productpage/requests-2.32.0",
      "dependabot/pip/samples/bookinfo/src/productpage/requests-2.32.2",
      "dependabot/pip/samples/bookinfo/src/productpage/urllib3-2.2.2",
      "dependabot/pip/samples/helloworld/src/certifi-2024.7.4",
      "dependabot/pip/samples/helloworld/src/urllib3-2.2.2",
      "experimental-ambient",
      "experimental-dual-stack",
      "howardjohn/exp-debug-test",
      "howardjohn-patch-1",
      "hzxuzhonghu-patch-1",
      "latest-golangci-lint",
      "master",
      "master-master-commonfiles-1b3e9286",
      "newBaseVersion1.19-2024-04-16T19-02-45",
      "newBaseVersion1.19-2024-04-26T19-02-46",
      "newBaseVersion1.19-2024-04-27T19-03-13",
      "newBaseVersion1.20-2024-04-19T19-02-18",
      "newBaseVersion1.21-2024-06-01T19-03-56",
      "newBaseVersion1.21-2024-09-04T19-00-43",
      "newBaseVersion1.23-2024-08-08T19-01-38",
      "newBaseVersionmaster-2024-05-08T22-56-43",
      "newBaseVersionmaster-2024-12-17T19-00-43"
    ],
    "languages": {
      "Go": 14412921,
      "Shell": 121344,
      "Makefile": 51223,
      "CSS": 47647,
      "Jsonnet": 32268,
      "HTML": 28430,
      "Python": 12110,
      "Smarty": 8813,
      "Dockerfile": 1273,
      "Java": 1080,
      "JavaScript": 13
    },
    "commit_activity": {
      "total_commits_last_year": 2316,
      "avg_commits_per_week": 44.53846153846154,
      "days_active_last_year": 331
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:40:10.524278"
  }
}