{
  "cve_id": "CVE-2022-40138",
  "github_data": {
    "repository": "facebook/hermes",
    "fix_commit": "6aa825e480d48127b480b08d13adf70033237097",
    "related_commits": [
      "6aa825e480d48127b480b08d13adf70033237097",
      "6aa825e480d48127b480b08d13adf70033237097"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "6aa825e480d48127b480b08d13adf70033237097",
      "commit_date": "2022-09-27T15:14:30Z",
      "author": {
        "login": "facebook-github-bot",
        "type": "User",
        "stats": {
          "total_commits": 11,
          "average_weekly_commits": 0.037800687285223365,
          "total_additions": 608,
          "total_deletions": 17685,
          "weeks_active": 11
        }
      },
      "commit_message": {
        "title": "Re-sync with internal repository (#822)",
        "length": 134,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 187,
        "additions": 165,
        "deletions": 22
      },
      "files": [
        {
          "filename": "include/hermes/BCGen/HBC/BytecodeInstructionGenerator.h",
          "status": "modified",
          "additions": 14,
          "deletions": 7,
          "patch": "@@ -45,7 +45,16 @@ class BytecodeInstructionGenerator {\n   /// A list of opcodes.\n   std::vector<opcode_atom_t> opcodes_{};\n \n+  /// A flag indicating that an encoding error happened, in which case the\n+  /// bytecode is wrong and shouldn't be executed.\n+  bool encodingError_{};\n+\n  public:\n+  /// Returns whether an encoding error happened during bytecode emission.\n+  bool hasEncodingError() const {\n+    return encodingError_;\n+  }\n+\n   /// Returns the current location of the bytecode stream.\n   offset_t getCurrentLocation() {\n     return opcodes_.size();\n@@ -76,13 +85,11 @@ class BytecodeInstructionGenerator {\n // We also assert that the value can fit into ctype.\n // For integer values, ((param_t)(ctype)value) == value will do the job;\n // We also want doubles to pass the check unconditionally.\n-#define DEFINE_OPERAND_TYPE(name, ctype)          \\\n-  void emit##name(param_t value) {                \\\n-    assert(                                       \\\n-        (((param_t)(ctype)value) == value ||      \\\n-         std::is_floating_point<ctype>::value) && \\\n-        \"Value does not fit in \" #ctype);         \\\n-    emitOperand(value, sizeof(ctype));            \\\n+#define DEFINE_OPERAND_TYPE(name, ctype)                  \\\n+  void emit##name(param_t value) {                        \\\n+    encodingError_ |= ((param_t)(ctype)value) != value && \\\n+        !std::is_floating_point<ctype>::value;            \\\n+    emitOperand(value, sizeof(ctype));                    \\\n   }\n #include \"hermes/BCGen/HBC/BytecodeList.def\"\n "
        },
        {
          "filename": "include/hermes/CompilerDriver/CompilerDriver.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -32,6 +32,8 @@ enum CompileStatus {\n   OutputFileError,\n   /// An error occured during optimization.\n   OptimizationFailed,\n+  /// An error occured in the backend during/after IR lowering.\n+  BackendError,\n };\n \n /// Information about a bytecode file that is loaded into a buffer."
        },
        {
          "filename": "include/hermes/VM/CodeBlock.h",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -63,7 +63,7 @@ class CodeBlock final\n \n #ifndef HERMESVM_LEAN\n   /// Compiles a lazy CodeBlock. Intended to be called from lazyCompile.\n-  void lazyCompileImpl(Runtime &runtime);\n+  ExecutionStatus lazyCompileImpl(Runtime &runtime);\n #endif\n \n   /// Helper function for getting start and end locations.\n@@ -237,17 +237,20 @@ class CodeBlock final\n   }\n \n   /// Compiles this CodeBlock, if it's lazy and not already compiled.\n-  void lazyCompile(Runtime &runtime) {\n+  ExecutionStatus lazyCompile(Runtime &runtime) {\n     if (LLVM_UNLIKELY(isLazy())) {\n-      lazyCompileImpl(runtime);\n+      return lazyCompileImpl(runtime);\n     }\n+    return ExecutionStatus::RETURNED;\n   }\n #else\n   /// Checks whether this function is lazily compiled.\n   bool isLazy() const {\n     return false;\n   }\n-  void lazyCompile(Runtime &) {}\n+  ExecutionStatus lazyCompile(Runtime &) {\n+    return ExecutionStatus::RETURNED;\n+  }\n #endif\n \n   /// Get the start location of this function, if it's lazy."
        },
        {
          "filename": "lib/BCGen/HBC/BytecodeGenerator.cpp",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -217,6 +217,8 @@ void BytecodeModuleGenerator::setFunctionGenerator(\n   assert(\n       functionGenerators_.find(F) == functionGenerators_.end() &&\n       \"Adding same function twice.\");\n+  assert(\n+      !BFG->hasEncodingError() && \"Error should have been reported already.\");\n   functionGenerators_[F] = std::move(BFG);\n }\n "
        },
        {
          "filename": "lib/BCGen/HBC/BytecodeProviderFromSrc.cpp",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -236,8 +236,11 @@ BCProviderFromSrc::createBCProviderFromSrcImpl(\n   opts.staticBuiltinsEnabled =\n       context->getOptimizationSettings().staticBuiltins;\n   opts.verifyIR = compileFlags.verifyIR;\n-  auto bytecode = createBCProviderFromSrc(\n-      hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts));\n+  auto BM = hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts);\n+  if (context->getSourceErrorManager().getErrorCount() > 0) {\n+    return {nullptr, getErrorString()};\n+  }\n+  auto bytecode = createBCProviderFromSrc(std::move(BM));\n   bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());\n   return {std::move(bytecode), std::string{}};\n }"
        },
        {
          "filename": "lib/BCGen/HBC/HBC.cpp",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -313,6 +313,11 @@ std::unique_ptr<BytecodeModule> hbc::generateBytecodeModule(\n       debugCache = hbciSel.getDebugCache();\n     }\n \n+    if (funcGen->hasEncodingError()) {\n+      M->getContext().getSourceErrorManager().error(\n+          F.getSourceRange().Start, \"Error encoding bytecode\");\n+      return nullptr;\n+    }\n     BMGen.setFunctionGenerator(&F, std::move(funcGen));\n   }\n \n@@ -335,6 +340,10 @@ std::unique_ptr<BytecodeModule> hbc::generateBytecode(\n       sourceMapGen,\n       std::move(baseBCProvider));\n \n+  if (!BM) {\n+    return {};\n+  }\n+\n   if (options.format == OutputFormatKind::EmitBundle) {\n     assert(BM != nullptr);\n     BytecodeSerializer BS{OS, options};"
        },
        {
          "filename": "lib/BCGen/HBC/ISel.cpp",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -1337,6 +1337,10 @@ void HBCISel::generateHBCResolveEnvironment(\n       \"Cannot access variables in inner scopes\");\n   int32_t delta = curScopeDepth.getValue() - instScopeDepth.getValue();\n   assert(delta > 0 && \"HBCResolveEnvironment for current scope\");\n+  if (std::numeric_limits<uint8_t>::max() < delta) {\n+    F_->getContext().getSourceErrorManager().error(\n+        Inst->getLocation(), \"Variable environment is out-of-reach\");\n+  }\n   BCFGen_->emitGetEnvironment(encodeValue(Inst), delta - 1);\n }\n void HBCISel::generateHBCStoreToEnvironmentInst("
        },
        {
          "filename": "lib/CompilerDriver/CompilerDriver.cpp",
          "status": "modified",
          "additions": 13,
          "deletions": 2,
          "patch": "@@ -1694,9 +1694,15 @@ CompileResult generateBytecodeForExecution(\n   std::shared_ptr<Context> context = M.shareContext();\n   CompileResult result{Success};\n   if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n-    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n-        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n+    auto BM =\n+        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions);\n+    if (auto N = context->getSourceErrorManager().getErrorCount()) {\n+      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n+      return BackendError;\n+    }\n \n+    result.bytecodeProvider =\n+        hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(BM));\n   } else {\n     llvm_unreachable(\"Invalid bytecode kind for execution\");\n     result = InvalidFlags;\n@@ -1735,6 +1741,11 @@ CompileResult generateBytecodeForSerialization(\n         sourceMapGenOrNull,\n         std::move(baseBCProvider));\n \n+    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n+      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n+      return BackendError;\n+    }\n+\n     if (cl::DumpTarget == DumpBytecode) {\n       disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n           std::move(bytecodeModule)));"
        },
        {
          "filename": "lib/VM/Callable.cpp",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -1395,7 +1395,11 @@ CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n   // Note that this will do nothing after the very first time a lazy function\n   // is called, so we only resize before we save any registers at all.\n   if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n-    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n+    if (LLVM_UNLIKELY(\n+            selfHandle->getCodeBlock(runtime)->lazyCompile(runtime) ==\n+            ExecutionStatus::EXCEPTION)) {\n+      return ExecutionStatus::EXCEPTION;\n+    }\n     if (LLVM_UNLIKELY(\n             ArrayStorage::resize(\n                 ctx,"
        },
        {
          "filename": "lib/VM/CodeBlock.cpp",
          "status": "modified",
          "additions": 14,
          "deletions": 1,
          "patch": "@@ -14,6 +14,7 @@\n #include \"hermes/IRGen/IRGen.h\"\n #include \"hermes/Support/Conversions.h\"\n #include \"hermes/Support/PerfSection.h\"\n+#include \"hermes/Support/SimpleDiagHandler.h\"\n #include \"hermes/VM/GCPointer-inline.h\"\n #include \"hermes/VM/Runtime.h\"\n #include \"hermes/VM/RuntimeModule.h\"\n@@ -330,14 +331,24 @@ std::unique_ptr<hbc::BytecodeModule> compileLazyFunction(\n }\n } // namespace\n \n-void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n+ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &runtime) {\n   assert(isLazy() && \"Laziness has not been checked\");\n   PerfSection perf(\"Lazy function compilation\");\n   auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n   auto *func = provider->getBytecodeFunction();\n   auto *lazyData = func->getLazyCompilationData();\n+  SourceErrorManager &manager = lazyData->context->getSourceErrorManager();\n+  SimpleDiagHandlerRAII outputManager{manager};\n   auto bcModule = compileLazyFunction(lazyData);\n \n+  if (manager.getErrorCount()) {\n+    // Raise a SyntaxError to be consistent with eval().\n+    return runtime.raiseSyntaxError(\n+        llvh::StringRef{outputManager.getErrorString()});\n+  }\n+\n+  assert(bcModule && \"No errors, yet no bcModule\");\n+\n   runtimeModule_->initializeLazyMayAllocate(\n       hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n   // Reset all meta lazyData of the CodeBlock to point to the newly\n@@ -346,6 +357,8 @@ void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n   functionHeader_ =\n       runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n   bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n+\n+  return ExecutionStatus::RETURNED;\n }\n #endif // HERMESVM_LEAN\n "
        },
        {
          "filename": "lib/VM/Debugger/Debugger.cpp",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -1147,7 +1147,12 @@ bool Debugger::resolveBreakpointLocation(Breakpoint &breakpoint) const {\n            (start.col <= request.column && request.column <= end.col))) {\n         // The code block probably contains the breakpoint we want to set.\n         // First, we compile it.\n-        codeBlock->lazyCompile(runtime_);\n+        if (LLVM_UNLIKELY(\n+                codeBlock->lazyCompile(runtime_) ==\n+                ExecutionStatus::EXCEPTION)) {\n+          // TODO: how to better handle this?\n+          runtime_.clearThrownValue();\n+        }\n \n         // We've found the codeBlock at this level and expanded it,\n         // so there's no point continuing the search."
        },
        {
          "filename": "lib/VM/Interpreter.cpp",
          "status": "modified",
          "additions": 12,
          "deletions": 3,
          "patch": "@@ -785,7 +785,10 @@ static inline const Inst *nextInstCall(const Inst *ip) {\n \n CallResult<HermesValue> Runtime::interpretFunctionImpl(\n     CodeBlock *newCodeBlock) {\n-  newCodeBlock->lazyCompile(*this);\n+  if (LLVM_UNLIKELY(\n+          newCodeBlock->lazyCompile(*this) == ExecutionStatus::EXCEPTION)) {\n+    return ExecutionStatus::EXCEPTION;\n+  }\n \n #if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n   // We always call getCurrentIP() in a debug build as this has the effect\n@@ -1584,7 +1587,10 @@ CallResult<HermesValue> Interpreter::interpretFunction(\n #endif\n \n         CodeBlock *calleeBlock = func->getCodeBlock(runtime);\n-        CAPTURE_IP(calleeBlock->lazyCompile(runtime));\n+        CAPTURE_IP_ASSIGN(auto res, calleeBlock->lazyCompile(runtime));\n+        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n+          goto exception;\n+        }\n         curCodeBlock = calleeBlock;\n         CAPTURE_IP_SET();\n         goto tailCall;\n@@ -1637,7 +1643,10 @@ CallResult<HermesValue> Interpreter::interpretFunction(\n \n         assert(!SingleStep && \"can't single-step a call\");\n \n-        CAPTURE_IP(calleeBlock->lazyCompile(runtime));\n+        CAPTURE_IP_ASSIGN(auto res, calleeBlock->lazyCompile(runtime));\n+        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n+          goto exception;\n+        }\n         curCodeBlock = calleeBlock;\n         CAPTURE_IP_SET();\n         goto tailCall;"
        },
        {
          "filename": "lib/VM/Operations.cpp",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1679,7 +1679,9 @@ CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n     auto *cb = func->getCodeBlock(runtime);\n     // Even though it doesn't make sense logically, we need to compile the\n     // function in order to access it flags.\n-    cb->lazyCompile(runtime);\n+    if (LLVM_UNLIKELY(cb->lazyCompile(runtime) == ExecutionStatus::EXCEPTION)) {\n+      return ExecutionStatus::EXCEPTION;\n+    }\n     return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n         true);\n   }"
        },
        {
          "filename": "test/hermes/far-environment-access-eval.js",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+/**\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+// RUN: %hermes -O -target=HBC %s 2>&1 | %FileCheck --match-full-lines %s\n+// RUN: %hermes -O -target=HBC %s -lazy 2>&1 | %FileCheck --match-full-lines %s\n+// XFAIL: windows\n+// UNSUPPORTED: ubsan\n+\n+// Hermes has a 256 limit on the number of scopes nesting. This test ensures\n+// that the compiler will handle applications that require more scopes\n+// gracefully -- i.e., it won't crash, nor emit bad bytecode.\n+\n+try {\n+    eval('\"use strict\";\\n' +\n+         '\\n' +\n+         'function sink(x) { return x; }\\n' +\n+         'function foo(){\\n' +\n+         '  var var0 = sink(\"1\");\\n' +\n+         '  var var1 = sink(\"2\");\\n' +\n+         '  var var2 = sink(\"3\");\\n' +\n+         '  return ()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=> [var0, var1, var2];\\n' +\n+         '}\\n' +\n+         '\\n' +\n+         'print(foo()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()());\\n')\n+} catch (e) {\n+  print(e);\n+}\n+\n+// CHECK: SyntaxError: {{[0-9]+}}:{{[0-9]+}}:Variable environment is out-of-reach"
        },
        {
          "filename": "test/hermes/far-environment-access.js",
          "status": "added",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+// RUN: (%hermesc -O -target=HBC %s --dump-bytecode 2>&1 || true) | %FileCheck --match-full-lines %s\n+// RUN: (%hermes -O -target=HBC %s 2>&1 || true) | %FileCheck --match-full-lines %s\n+// RUN: %hermes -O -target=HBC %s -lazy 2>&1 | %FileCheck --match-full-lines %s --check-prefix=LAZY\n+// XFAIL: windows\n+// UNSUPPORTED: ubsan\n+\n+// Hermes has a 256 limit on the number of scopes nesting. This test ensures\n+// that the compiler will handle applications that require more scopes\n+// gracefully -- i.e., it won't crash, nor emit bad bytecode.\n+\n+\"use strict\";\n+\n+function sink(x) { return x; }\n+function foo(){\n+  var var0 = sink(\"1\");\n+  var var1 = sink(\"2\");\n+  var var2 = sink(\"3\");\n+  return ()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=>()=> [var0, var1, var2];\n+}\n+\n+try {\n+  print(foo()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()());\n+} catch (e) {\n+  print(e);\n+}\n+\n+\n+// CHECK: {{.*}}far-environment-access.js:{{[0-9]+}}:{{[0-9]+}}: error: Variable environment is out-of-reach\n+// LAZY: SyntaxError: {{[0-9]+}}:{{[0-9]+}}:Variable environment is out-of-reach"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 8,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7af61dbdde40ff8beefdebd778c116b10b43977b",
            "date": "2025-01-25T02:21:37Z",
            "author_login": "panagosg7"
          },
          {
            "sha": "ee1ac30851fb6f17250bdf756f917c2c7817ec15",
            "date": "2025-01-24T23:46:27Z",
            "author_login": "neildhar"
          },
          {
            "sha": "608c5ba92c43bcac98c268075be8c15fc891dcd5",
            "date": "2025-01-24T22:56:03Z",
            "author_login": "lavenzg"
          },
          {
            "sha": "576fbeac375e30747f539e595e81ac62f0001cca",
            "date": "2025-01-24T22:03:46Z",
            "author_login": "tsaichien"
          },
          {
            "sha": "a08b71bb6f93966e9f58ea91105b648c5573e191",
            "date": "2025-01-24T22:03:46Z",
            "author_login": "tsaichien"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-681",
    "description": "An integer conversion error in Hermes bytecode generation, prior to commit 6aa825e480d48127b480b08d13adf70033237097, could have been used to perform Out-Of-Bounds operations and subsequently execute arbitrary code. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-10-11T02:15:08.857",
    "last_modified": "2024-11-21T07:20:57.487",
    "fix_date": "2022-09-27T15:14:30Z"
  },
  "references": [
    {
      "url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
      "source": "cve-assign@fb.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.facebook.com/security/advisories/CVE-2022-40138",
      "source": "cve-assign@fb.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.facebook.com/security/advisories/CVE-2022-40138",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:03:41.322140",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "hermes",
    "owner": "facebook",
    "created_at": "2018-10-22T19:13:00Z",
    "updated_at": "2025-01-25T02:24:07Z",
    "pushed_at": "2025-01-25T02:24:02Z",
    "size": 97415,
    "stars": 10060,
    "forks": 651,
    "open_issues": 165,
    "watchers": 10060,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "gh-pages",
      "main"
    ],
    "languages": {
      "C++": 10951483,
      "JavaScript": 7957683,
      "Rust": 1201532,
      "Python": 337456,
      "Java": 319660,
      "TypeScript": 184977,
      "Objective-C++": 113458,
      "CMake": 113065,
      "C": 41344,
      "Shell": 38189,
      "Swift": 22129,
      "NASL": 4993,
      "Ruby": 3189,
      "DTrace": 574,
      "Objective-C": 303,
      "D": 225
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:38:59.629104"
  }
}