{
  "cve_id": "CVE-2022-41903",
  "github_data": {
    "repository": "git/git",
    "fix_commit": "508386c6c5857b4faa2c3e491f422c98cc69ae76",
    "related_commits": [
      "508386c6c5857b4faa2c3e491f422c98cc69ae76",
      "508386c6c5857b4faa2c3e491f422c98cc69ae76"
    ],
    "patch_url": "https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76.patch",
    "fix_commit_details": {
      "sha": "508386c6c5857b4faa2c3e491f422c98cc69ae76",
      "commit_date": "2023-01-16T20:11:58Z",
      "author": {
        "login": "gitster",
        "type": "User",
        "stats": {
          "total_commits": 22453,
          "average_weekly_commits": 21.77788554801164,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 884
        }
      },
      "commit_message": {
        "title": "Sync with 2.39.1",
        "length": 16,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 697,
        "additions": 572,
        "deletions": 125
      },
      "files": [
        {
          "filename": "Documentation/RelNotes/2.30.7.txt",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+Git v2.30.7 Release Notes\n+=========================\n+\n+This release addresses the security issues CVE-2022-41903 and\n+CVE-2022-23521.\n+\n+\n+Fixes since v2.30.6\n+-------------------\n+\n+ * CVE-2022-41903:\n+\n+   git log has the ability to display commits using an arbitrary\n+   format with its --format specifiers. This functionality is also\n+   exposed to git archive via the export-subst gitattribute.\n+\n+   When processing the padding operators (e.g., %<(, %<|(, %>(,\n+   %>>(, or %><( ), an integer overflow can occur in\n+   pretty.c::format_and_pad_commit() where a size_t is improperly\n+   stored as an int, and then added as an offset to a subsequent\n+   memcpy() call.\n+\n+   This overflow can be triggered directly by a user running a\n+   command which invokes the commit formatting machinery (e.g., git\n+   log --format=...). It may also be triggered indirectly through\n+   git archive via the export-subst mechanism, which expands format\n+   specifiers inside of files within the repository during a git\n+   archive.\n+\n+   This integer overflow can result in arbitrary heap writes, which\n+   may result in remote code execution.\n+\n+* CVE-2022-23521:\n+\n+    gitattributes are a mechanism to allow defining attributes for\n+    paths. These attributes can be defined by adding a `.gitattributes`\n+    file to the repository, which contains a set of file patterns and\n+    the attributes that should be set for paths matching this pattern.\n+\n+    When parsing gitattributes, multiple integer overflows can occur\n+    when there is a huge number of path patterns, a huge number of\n+    attributes for a single pattern, or when the declared attribute\n+    names are huge.\n+\n+    These overflows can be triggered via a crafted `.gitattributes` file\n+    that may be part of the commit history. Git silently splits lines\n+    longer than 2KB when parsing gitattributes from a file, but not when\n+    parsing them from the index. Consequentially, the failure mode\n+    depends on whether the file exists in the working tree, the index or\n+    both.\n+\n+    This integer overflow can result in arbitrary heap reads and writes,\n+    which may result in remote code execution.\n+\n+Credit for finding CVE-2022-41903 goes to Joern Schneeweisz of GitLab.\n+An initial fix was authored by Markus Vervier of X41 D-Sec. Credit for\n+finding CVE-2022-23521 goes to Markus Vervier and Eric Sesterhenn of X41\n+D-Sec. This work was sponsored by OSTIF.\n+\n+The proposed fixes have been polished and extended to cover additional\n+findings by Patrick Steinhardt of GitLab, with help from others on the\n+Git security mailing list.\n+\n+Patrick Steinhardt (21):\n+      attr: fix overflow when upserting attribute with overly long name\n+      attr: fix out-of-bounds read with huge attribute names\n+      attr: fix integer overflow when parsing huge attribute names\n+      attr: fix out-of-bounds write when parsing huge number of attributes\n+      attr: fix out-of-bounds read with unreasonable amount of patterns\n+      attr: fix integer overflow with more than INT_MAX macros\n+      attr: harden allocation against integer overflows\n+      attr: fix silently splitting up lines longer than 2048 bytes\n+      attr: ignore attribute lines exceeding 2048 bytes\n+      attr: ignore overly large gitattributes files\n+      pretty: fix out-of-bounds write caused by integer overflow\n+      pretty: fix out-of-bounds read when left-flushing with stealing\n+      pretty: fix out-of-bounds read when parsing invalid padding format\n+      pretty: fix adding linefeed when placeholder is not expanded\n+      pretty: fix integer overflow in wrapping format\n+      utf8: fix truncated string lengths in `utf8_strnwidth()`\n+      utf8: fix returning negative string width\n+      utf8: fix overflow when returning string width\n+      utf8: fix checking for glyph width in `strbuf_utf8_replace()`\n+      utf8: refactor `strbuf_utf8_replace` to not rely on preallocated buffer\n+      pretty: restrict input lengths for padding and wrapping formats\n+"
        },
        {
          "filename": "Documentation/RelNotes/2.31.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.31.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.32.5.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+Git v2.32.5 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details.\n+\n+In addition, included are additional code for \"git fsck\" to check\n+for questionable .gitattributes files."
        },
        {
          "filename": "Documentation/RelNotes/2.33.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.33.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.34.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.34.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.35.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.35.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.36.4.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.36.4 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.37.5.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.37.5 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.38.3.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.38.3 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.39.1.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.39.1 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "attr.c",
          "status": "modified",
          "additions": 56,
          "deletions": 35,
          "patch": "@@ -24,7 +24,7 @@ static const char git_attr__unknown[] = \"(builtin)unknown\";\n #define ATTR__UNKNOWN git_attr__unknown\n \n struct git_attr {\n-\tint attr_nr; /* unique attribute number */\n+\tunsigned int attr_nr; /* unique attribute number */\n \tchar name[FLEX_ARRAY]; /* attribute name */\n };\n \n@@ -206,7 +206,7 @@ static void report_invalid_attr(const char *name, size_t len,\n  * dictionary.  If no entry is found, create a new attribute and store it in\n  * the dictionary.\n  */\n-static const struct git_attr *git_attr_internal(const char *name, int namelen)\n+static const struct git_attr *git_attr_internal(const char *name, size_t namelen)\n {\n \tstruct git_attr *a;\n \n@@ -222,8 +222,8 @@ static const struct git_attr *git_attr_internal(const char *name, int namelen)\n \t\ta->attr_nr = hashmap_get_size(&g_attr_hashmap.map);\n \n \t\tattr_hashmap_add(&g_attr_hashmap, a->name, namelen, a);\n-\t\tassert(a->attr_nr ==\n-\t\t       (hashmap_get_size(&g_attr_hashmap.map) - 1));\n+\t\tif (a->attr_nr != hashmap_get_size(&g_attr_hashmap.map) - 1)\n+\t\t\tdie(_(\"unable to add additional attribute\"));\n \t}\n \n \thashmap_unlock(&g_attr_hashmap);\n@@ -268,7 +268,7 @@ struct match_attr {\n \t\tconst struct git_attr *attr;\n \t} u;\n \tchar is_macro;\n-\tunsigned num_attr;\n+\tsize_t num_attr;\n \tstruct attr_state state[FLEX_ARRAY];\n };\n \n@@ -289,7 +289,7 @@ static const char *parse_attr(const char *src, int lineno, const char *cp,\n \t\t\t      struct attr_state *e)\n {\n \tconst char *ep, *equals;\n-\tint len;\n+\tsize_t len;\n \n \tep = cp + strcspn(cp, blank);\n \tequals = strchr(cp, '=');\n@@ -333,8 +333,7 @@ static const char *parse_attr(const char *src, int lineno, const char *cp,\n static struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\t\t\t  int lineno, unsigned flags)\n {\n-\tint namelen;\n-\tint num_attr, i;\n+\tsize_t namelen, num_attr, i;\n \tconst char *cp, *name, *states;\n \tstruct match_attr *res = NULL;\n \tint is_macro;\n@@ -345,6 +344,11 @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\treturn NULL;\n \tname = cp;\n \n+\tif (strlen(line) >= ATTR_MAX_LINE_LENGTH) {\n+\t\twarning(_(\"ignoring overly long attributes line %d\"), lineno);\n+\t\treturn NULL;\n+\t}\n+\n \tif (*cp == '\"' && !unquote_c_style(&pattern, name, &states)) {\n \t\tname = pattern.buf;\n \t\tnamelen = pattern.len;\n@@ -381,10 +385,9 @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\tgoto fail_return;\n \t}\n \n-\tres = xcalloc(1,\n-\t\t      sizeof(*res) +\n-\t\t      sizeof(struct attr_state) * num_attr +\n-\t\t      (is_macro ? 0 : namelen + 1));\n+\tres = xcalloc(1, st_add3(sizeof(*res),\n+\t\t\t\t st_mult(sizeof(struct attr_state), num_attr),\n+\t\t\t\t is_macro ? 0 : namelen + 1));\n \tif (is_macro) {\n \t\tres->u.attr = git_attr_internal(name, namelen);\n \t} else {\n@@ -447,11 +450,12 @@ struct attr_stack {\n \n static void attr_stack_free(struct attr_stack *e)\n {\n-\tint i;\n+\tunsigned i;\n \tfree(e->origin);\n \tfor (i = 0; i < e->num_matches; i++) {\n \t\tstruct match_attr *a = e->attrs[i];\n-\t\tint j;\n+\t\tsize_t j;\n+\n \t\tfor (j = 0; j < a->num_attr; j++) {\n \t\t\tconst char *setto = a->state[j].setto;\n \t\t\tif (setto == ATTR__TRUE ||\n@@ -660,8 +664,8 @@ static void handle_attr_line(struct attr_stack *res,\n \ta = parse_attr_line(line, src, lineno, flags);\n \tif (!a)\n \t\treturn;\n-\tALLOC_GROW(res->attrs, res->num_matches + 1, res->alloc);\n-\tres->attrs[res->num_matches++] = a;\n+\tALLOC_GROW_BY(res->attrs, res->num_matches, 1, res->alloc);\n+\tres->attrs[res->num_matches - 1] = a;\n }\n \n static struct attr_stack *read_attr_from_array(const char **list)\n@@ -701,11 +705,12 @@ void git_attr_set_direction(enum git_attr_direction new_direction)\n \n static struct attr_stack *read_attr_from_file(const char *path, unsigned flags)\n {\n+\tstruct strbuf buf = STRBUF_INIT;\n \tint fd;\n \tFILE *fp;\n \tstruct attr_stack *res;\n-\tchar buf[2048];\n \tint lineno = 0;\n+\tstruct stat st;\n \n \tif (flags & READ_ATTR_NOFOLLOW)\n \t\tfd = open_nofollow(path, O_RDONLY);\n@@ -717,15 +722,26 @@ static struct attr_stack *read_attr_from_file(const char *path, unsigned flags)\n \t\treturn NULL;\n \t}\n \tfp = xfdopen(fd, \"r\");\n+\tif (fstat(fd, &st)) {\n+\t\twarning_errno(_(\"cannot fstat gitattributes file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n+\tif (st.st_size >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res, 1);\n-\twhile (fgets(buf, sizeof(buf), fp)) {\n-\t\tchar *bufp = buf;\n-\t\tif (!lineno)\n-\t\t\tskip_utf8_bom(&bufp, strlen(bufp));\n-\t\thandle_attr_line(res, bufp, path, ++lineno, flags);\n+\twhile (strbuf_getline(&buf, fp) != EOF) {\n+\t\tif (!lineno && starts_with(buf.buf, utf8_bom))\n+\t\t\tstrbuf_remove(&buf, 0, strlen(utf8_bom));\n+\t\thandle_attr_line(res, buf.buf, path, ++lineno, flags);\n \t}\n+\n \tfclose(fp);\n+\tstrbuf_release(&buf);\n \treturn res;\n }\n \n@@ -736,6 +752,7 @@ static struct attr_stack *read_attr_from_index(struct index_state *istate,\n \tstruct attr_stack *res;\n \tchar *buf, *sp;\n \tint lineno = 0;\n+\tsize_t size;\n \n \tif (!istate)\n \t\treturn NULL;\n@@ -754,9 +771,13 @@ static struct attr_stack *read_attr_from_index(struct index_state *istate,\n \tif (!path_in_cone_mode_sparse_checkout(path, istate))\n \t\treturn NULL;\n \n-\tbuf = read_blob_data_from_index(istate, path, NULL);\n+\tbuf = read_blob_data_from_index(istate, path, &size);\n \tif (!buf)\n \t\treturn NULL;\n+\tif (size >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes blob '%s'\"), path);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res, 1);\n \tfor (sp = buf; *sp; ) {\n@@ -999,12 +1020,12 @@ static int macroexpand_one(struct all_attrs_item *all_attrs, int nr, int rem);\n static int fill_one(struct all_attrs_item *all_attrs,\n \t\t    const struct match_attr *a, int rem)\n {\n-\tint i;\n+\tsize_t i;\n \n-\tfor (i = a->num_attr - 1; rem > 0 && i >= 0; i--) {\n-\t\tconst struct git_attr *attr = a->state[i].attr;\n+\tfor (i = a->num_attr; rem > 0 && i > 0; i--) {\n+\t\tconst struct git_attr *attr = a->state[i - 1].attr;\n \t\tconst char **n = &(all_attrs[attr->attr_nr].value);\n-\t\tconst char *v = a->state[i].setto;\n+\t\tconst char *v = a->state[i - 1].setto;\n \n \t\tif (*n == ATTR__UNKNOWN) {\n \t\t\t*n = v;\n@@ -1020,11 +1041,11 @@ static int fill(const char *path, int pathlen, int basename_offset,\n \t\tstruct all_attrs_item *all_attrs, int rem)\n {\n \tfor (; rem > 0 && stack; stack = stack->prev) {\n-\t\tint i;\n+\t\tunsigned i;\n \t\tconst char *base = stack->origin ? stack->origin : \"\";\n \n-\t\tfor (i = stack->num_matches - 1; 0 < rem && 0 <= i; i--) {\n-\t\t\tconst struct match_attr *a = stack->attrs[i];\n+\t\tfor (i = stack->num_matches; 0 < rem && 0 < i; i--) {\n+\t\t\tconst struct match_attr *a = stack->attrs[i - 1];\n \t\t\tif (a->is_macro)\n \t\t\t\tcontinue;\n \t\t\tif (path_matches(path, pathlen, basename_offset,\n@@ -1055,11 +1076,11 @@ static void determine_macros(struct all_attrs_item *all_attrs,\n \t\t\t     const struct attr_stack *stack)\n {\n \tfor (; stack; stack = stack->prev) {\n-\t\tint i;\n-\t\tfor (i = stack->num_matches - 1; i >= 0; i--) {\n-\t\t\tconst struct match_attr *ma = stack->attrs[i];\n+\t\tunsigned i;\n+\t\tfor (i = stack->num_matches; i > 0; i--) {\n+\t\t\tconst struct match_attr *ma = stack->attrs[i - 1];\n \t\t\tif (ma->is_macro) {\n-\t\t\t\tint n = ma->u.attr->attr_nr;\n+\t\t\t\tunsigned int n = ma->u.attr->attr_nr;\n \t\t\t\tif (!all_attrs[n].macro) {\n \t\t\t\t\tall_attrs[n].macro = ma;\n \t\t\t\t}\n@@ -1111,7 +1132,7 @@ void git_check_attr(struct index_state *istate,\n \tcollect_some_attrs(istate, path, check);\n \n \tfor (i = 0; i < check->nr; i++) {\n-\t\tsize_t n = check->items[i].attr->attr_nr;\n+\t\tunsigned int n = check->items[i].attr->attr_nr;\n \t\tconst char *value = check->all_attrs[n].value;\n \t\tif (value == ATTR__UNKNOWN)\n \t\t\tvalue = ATTR__UNSET;"
        },
        {
          "filename": "attr.h",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -107,6 +107,18 @@\n  * - Free the `attr_check` struct by calling `attr_check_free()`.\n  */\n \n+/**\n+ * The maximum line length for a gitattributes file. If the line exceeds this\n+ * length we will ignore it.\n+ */\n+#define ATTR_MAX_LINE_LENGTH 2048\n+\n+ /**\n+  * The maximum size of the giattributes file. If the file exceeds this size we\n+  * will ignore it.\n+  */\n+#define ATTR_MAX_FILE_SIZE (100 * 1024 * 1024)\n+\n struct index_state;\n \n /**"
        },
        {
          "filename": "column.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -23,7 +23,7 @@ struct column_data {\n /* return length of 's' in letters, ANSI escapes stripped */\n static int item_length(const char *s)\n {\n-\treturn utf8_strnwidth(s, -1, 1);\n+\treturn utf8_strnwidth(s, strlen(s), 1);\n }\n \n /*"
        },
        {
          "filename": "fsck.c",
          "status": "modified",
          "additions": 94,
          "deletions": 43,
          "patch": "@@ -2,6 +2,7 @@\n #include \"object-store.h\"\n #include \"repository.h\"\n #include \"object.h\"\n+#include \"attr.h\"\n #include \"blob.h\"\n #include \"tree.h\"\n #include \"tree-walk.h\"\n@@ -614,17 +615,22 @@ static int fsck_tree(const struct object_id *tree_oid,\n \t\t\t\t\t\t \".gitmodules is a symbolic link\");\n \t\t}\n \n+\t\tif (is_hfs_dotgitattributes(name) || is_ntfs_dotgitattributes(name)) {\n+\t\t\tif (!S_ISLNK(mode))\n+\t\t\t\toidset_insert(&options->gitattributes_found,\n+\t\t\t\t\t      entry_oid);\n+\t\t\telse\n+\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n+\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n+\t\t\t\t\t\t \".gitattributes is a symlink\");\n+\t\t}\n+\n \t\tif (S_ISLNK(mode)) {\n \t\t\tif (is_hfs_dotgitignore(name) ||\n \t\t\t    is_ntfs_dotgitignore(name))\n \t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n \t\t\t\t\t\t FSCK_MSG_GITIGNORE_SYMLINK,\n \t\t\t\t\t\t \".gitignore is a symlink\");\n-\t\t\tif (is_hfs_dotgitattributes(name) ||\n-\t\t\t    is_ntfs_dotgitattributes(name))\n-\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n-\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n-\t\t\t\t\t\t \".gitattributes is a symlink\");\n \t\t\tif (is_hfs_dotmailmap(name) ||\n \t\t\t    is_ntfs_dotmailmap(name))\n \t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n@@ -1159,38 +1165,70 @@ static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n static int fsck_blob(const struct object_id *oid, const char *buf,\n \t\t     unsigned long size, struct fsck_options *options)\n {\n-\tstruct fsck_gitmodules_data data;\n-\tstruct config_options config_opts = { 0 };\n-\n-\tif (!oidset_contains(&options->gitmodules_found, oid))\n-\t\treturn 0;\n-\toidset_insert(&options->gitmodules_done, oid);\n+\tint ret = 0;\n \n \tif (object_on_skiplist(options, oid))\n \t\treturn 0;\n \n-\tif (!buf) {\n-\t\t/*\n-\t\t * A missing buffer here is a sign that the caller found the\n-\t\t * blob too gigantic to load into memory. Let's just consider\n-\t\t * that an error.\n-\t\t */\n-\t\treturn report(options, oid, OBJ_BLOB,\n-\t\t\t      FSCK_MSG_GITMODULES_LARGE,\n-\t\t\t      \".gitmodules too large to parse\");\n+\tif (oidset_contains(&options->gitmodules_found, oid)) {\n+\t\tstruct config_options config_opts = { 0 };\n+\t\tstruct fsck_gitmodules_data data;\n+\n+\t\toidset_insert(&options->gitmodules_done, oid);\n+\n+\t\tif (!buf) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_LARGE,\n+\t\t\t\t\t\".gitmodules too large to parse\");\n+\t\t}\n+\n+\t\tdata.oid = oid;\n+\t\tdata.options = options;\n+\t\tdata.ret = 0;\n+\t\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n+\t\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n+\t\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n+\t\t\tdata.ret |= report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_PARSE,\n+\t\t\t\t\t\"could not parse gitmodules blob\");\n+\t\tret |= data.ret;\n \t}\n \n-\tdata.oid = oid;\n-\tdata.options = options;\n-\tdata.ret = 0;\n-\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n-\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n-\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n-\t\tdata.ret |= report(options, oid, OBJ_BLOB,\n-\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n-\t\t\t\t   \"could not parse gitmodules blob\");\n-\n-\treturn data.ret;\n+\tif (oidset_contains(&options->gitattributes_found, oid)) {\n+\t\tconst char *ptr;\n+\n+\t\toidset_insert(&options->gitattributes_done, oid);\n+\n+\t\tif (!buf || size > ATTR_MAX_FILE_SIZE) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITATTRIBUTES_LARGE,\n+\t\t\t\t\t\".gitattributes too large to parse\");\n+\t\t}\n+\n+\t\tfor (ptr = buf; *ptr; ) {\n+\t\t\tconst char *eol = strchrnul(ptr, '\\n');\n+\t\t\tif (eol - ptr >= ATTR_MAX_LINE_LENGTH) {\n+\t\t\t\tret |= report(options, oid, OBJ_BLOB,\n+\t\t\t\t\t      FSCK_MSG_GITATTRIBUTES_LINE_LENGTH,\n+\t\t\t\t\t      \".gitattributes has too long lines to parse\");\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tptr = *eol ? eol + 1 : eol;\n+\t\t}\n+\t}\n+\n+\treturn ret;\n }\n \n int fsck_object(struct object *obj, void *data, unsigned long size,\n@@ -1229,45 +1267,58 @@ int fsck_error_function(struct fsck_options *o,\n \treturn 1;\n }\n \n-int fsck_finish(struct fsck_options *options)\n+static int fsck_blobs(struct oidset *blobs_found, struct oidset *blobs_done,\n+\t\t      enum fsck_msg_id msg_missing, enum fsck_msg_id msg_type,\n+\t\t      struct fsck_options *options, const char *blob_type)\n {\n \tint ret = 0;\n \tstruct oidset_iter iter;\n \tconst struct object_id *oid;\n \n-\toidset_iter_init(&options->gitmodules_found, &iter);\n+\toidset_iter_init(blobs_found, &iter);\n \twhile ((oid = oidset_iter_next(&iter))) {\n \t\tenum object_type type;\n \t\tunsigned long size;\n \t\tchar *buf;\n \n-\t\tif (oidset_contains(&options->gitmodules_done, oid))\n+\t\tif (oidset_contains(blobs_done, oid))\n \t\t\tcontinue;\n \n \t\tbuf = read_object_file(oid, &type, &size);\n \t\tif (!buf) {\n \t\t\tif (is_promisor_object(oid))\n \t\t\t\tcontinue;\n \t\t\tret |= report(options,\n-\t\t\t\t      oid, OBJ_BLOB,\n-\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n-\t\t\t\t      \"unable to read .gitmodules blob\");\n+\t\t\t\t      oid, OBJ_BLOB, msg_missing,\n+\t\t\t\t      \"unable to read %s blob\", blob_type);\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (type == OBJ_BLOB)\n \t\t\tret |= fsck_blob(oid, buf, size, options);\n \t\telse\n-\t\t\tret |= report(options,\n-\t\t\t\t      oid, type,\n-\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n-\t\t\t\t      \"non-blob found at .gitmodules\");\n+\t\t\tret |= report(options, oid, type, msg_type,\n+\t\t\t\t      \"non-blob found at %s\", blob_type);\n \t\tfree(buf);\n \t}\n \n+\toidset_clear(blobs_found);\n+\toidset_clear(blobs_done);\n+\n+\treturn ret;\n+}\n+\n+int fsck_finish(struct fsck_options *options)\n+{\n+\tint ret = 0;\n+\n+\tret |= fsck_blobs(&options->gitmodules_found, &options->gitmodules_done,\n+\t\t\t  FSCK_MSG_GITMODULES_MISSING, FSCK_MSG_GITMODULES_BLOB,\n+\t\t\t  options, \".gitmodules\");\n+\tret |= fsck_blobs(&options->gitattributes_found, &options->gitattributes_done,\n+\t\t\t  FSCK_MSG_GITATTRIBUTES_MISSING, FSCK_MSG_GITATTRIBUTES_BLOB,\n+\t\t\t  options, \".gitattributes\");\n \n-\toidset_clear(&options->gitmodules_found);\n-\toidset_clear(&options->gitmodules_done);\n \treturn ret;\n }\n "
        },
        {
          "filename": "fsck.h",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -59,6 +59,10 @@ enum fsck_msg_type {\n \tFUNC(GITMODULES_URL, ERROR) \\\n \tFUNC(GITMODULES_PATH, ERROR) \\\n \tFUNC(GITMODULES_UPDATE, ERROR) \\\n+\tFUNC(GITATTRIBUTES_MISSING, ERROR) \\\n+\tFUNC(GITATTRIBUTES_LARGE, ERROR) \\\n+\tFUNC(GITATTRIBUTES_LINE_LENGTH, ERROR) \\\n+\tFUNC(GITATTRIBUTES_BLOB, ERROR) \\\n \t/* warnings */ \\\n \tFUNC(EMPTY_NAME, WARN) \\\n \tFUNC(FULL_PATHNAME, WARN) \\\n@@ -133,25 +137,33 @@ struct fsck_options {\n \tstruct oidset skiplist;\n \tstruct oidset gitmodules_found;\n \tstruct oidset gitmodules_done;\n+\tstruct oidset gitattributes_found;\n+\tstruct oidset gitattributes_done;\n \tkh_oid_map_t *object_names;\n };\n \n #define FSCK_OPTIONS_DEFAULT { \\\n \t.skiplist = OIDSET_INIT, \\\n \t.gitmodules_found = OIDSET_INIT, \\\n \t.gitmodules_done = OIDSET_INIT, \\\n+\t.gitattributes_found = OIDSET_INIT, \\\n+\t.gitattributes_done = OIDSET_INIT, \\\n \t.error_func = fsck_error_function \\\n }\n #define FSCK_OPTIONS_STRICT { \\\n \t.strict = 1, \\\n \t.gitmodules_found = OIDSET_INIT, \\\n \t.gitmodules_done = OIDSET_INIT, \\\n+\t.gitattributes_found = OIDSET_INIT, \\\n+\t.gitattributes_done = OIDSET_INIT, \\\n \t.error_func = fsck_error_function, \\\n }\n #define FSCK_OPTIONS_MISSING_GITMODULES { \\\n \t.strict = 1, \\\n \t.gitmodules_found = OIDSET_INIT, \\\n \t.gitmodules_done = OIDSET_INIT, \\\n+\t.gitattributes_found = OIDSET_INIT, \\\n+\t.gitattributes_done = OIDSET_INIT, \\\n \t.error_func = fsck_error_cb_print_missing_gitmodules, \\\n }\n "
        },
        {
          "filename": "git-compat-util.h",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -1022,6 +1022,14 @@ static inline unsigned long cast_size_t_to_ulong(size_t a)\n \treturn (unsigned long)a;\n }\n \n+static inline int cast_size_t_to_int(size_t a)\n+{\n+\tif (a > INT_MAX)\n+\t\tdie(\"number too large to represent as int on this platform: %\"PRIuMAX,\n+\t\t    (uintmax_t)a);\n+\treturn (int)a;\n+}\n+\n /*\n  * Limit size of IO chunks, because huge chunks only cause pain.  OS X\n  * 64-bit is buggy, returning EINVAL if len >= INT_MAX; and even in"
        },
        {
          "filename": "pretty.c",
          "status": "modified",
          "additions": 52,
          "deletions": 11,
          "patch": "@@ -14,6 +14,13 @@\n #include \"trailer.h\"\n #include \"run-command.h\"\n \n+/*\n+ * The limit for formatting directives, which enable the caller to append\n+ * arbitrarily many bytes to the formatted buffer. This includes padding\n+ * and wrapping formatters.\n+ */\n+#define FORMATTING_LIMIT (16 * 1024)\n+\n static char *user_format;\n static struct cmt_fmt_map {\n \tconst char *name;\n@@ -994,7 +1001,9 @@ static void strbuf_wrap(struct strbuf *sb, size_t pos,\n \tif (pos)\n \t\tstrbuf_add(&tmp, sb->buf, pos);\n \tstrbuf_add_wrapped_text(&tmp, sb->buf + pos,\n-\t\t\t\t(int) indent1, (int) indent2, (int) width);\n+\t\t\t\tcast_size_t_to_int(indent1),\n+\t\t\t\tcast_size_t_to_int(indent2),\n+\t\t\t\tcast_size_t_to_int(width));\n \tstrbuf_swap(&tmp, sb);\n \tstrbuf_release(&tmp);\n }\n@@ -1120,9 +1129,18 @@ static size_t parse_padding_placeholder(const char *placeholder,\n \t\tconst char *end = start + strcspn(start, \",)\");\n \t\tchar *next;\n \t\tint width;\n-\t\tif (!end || end == start)\n+\t\tif (!*end || end == start)\n \t\t\treturn 0;\n \t\twidth = strtol(start, &next, 10);\n+\n+\t\t/*\n+\t\t * We need to limit the amount of padding, or otherwise this\n+\t\t * would allow the user to pad the buffer by arbitrarily many\n+\t\t * bytes and thus cause resource exhaustion.\n+\t\t */\n+\t\tif (width < -FORMATTING_LIMIT || width > FORMATTING_LIMIT)\n+\t\t\treturn 0;\n+\n \t\tif (next == start || width == 0)\n \t\t\treturn 0;\n \t\tif (width < 0) {\n@@ -1405,6 +1423,16 @@ static size_t format_commit_one(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\tif (*next != ')')\n \t\t\t\t\treturn 0;\n \t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * We need to limit the format here as it allows the\n+\t\t\t * user to prepend arbitrarily many bytes to the buffer\n+\t\t\t * when rewrapping.\n+\t\t\t */\n+\t\t\tif (width > FORMATTING_LIMIT ||\n+\t\t\t    indent1 > FORMATTING_LIMIT ||\n+\t\t\t    indent2 > FORMATTING_LIMIT)\n+\t\t\t\treturn 0;\n \t\t\trewrap_message_tail(sb, c, width, indent1, indent2);\n \t\t\treturn end - placeholder + 1;\n \t\t} else\n@@ -1670,19 +1698,21 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t    struct format_commit_context *c)\n {\n \tstruct strbuf local_sb = STRBUF_INIT;\n-\tint total_consumed = 0, len, padding = c->padding;\n+\tsize_t total_consumed = 0;\n+\tint len, padding = c->padding;\n+\n \tif (padding < 0) {\n \t\tconst char *start = strrchr(sb->buf, '\\n');\n \t\tint occupied;\n \t\tif (!start)\n \t\t\tstart = sb->buf;\n-\t\toccupied = utf8_strnwidth(start, -1, 1);\n+\t\toccupied = utf8_strnwidth(start, strlen(start), 1);\n \t\toccupied += c->pretty_ctx->graph_width;\n \t\tpadding = (-padding) - occupied;\n \t}\n \twhile (1) {\n \t\tint modifier = *placeholder == 'C';\n-\t\tint consumed = format_commit_one(&local_sb, placeholder, c);\n+\t\tsize_t consumed = format_commit_one(&local_sb, placeholder, c);\n \t\ttotal_consumed += consumed;\n \n \t\tif (!modifier)\n@@ -1694,7 +1724,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\tplaceholder++;\n \t\ttotal_consumed++;\n \t}\n-\tlen = utf8_strnwidth(local_sb.buf, -1, 1);\n+\tlen = utf8_strnwidth(local_sb.buf, local_sb.len, 1);\n \n \tif (c->flush_type == flush_left_and_steal) {\n \t\tconst char *ch = sb->buf + sb->len - 1;\n@@ -1709,7 +1739,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t\tif (*ch != 'm')\n \t\t\t\tbreak;\n \t\t\tp = ch - 1;\n-\t\t\twhile (ch - p < 10 && *p != '\\033')\n+\t\t\twhile (p > sb->buf && ch - p < 10 && *p != '\\033')\n \t\t\t\tp--;\n \t\t\tif (*p != '\\033' ||\n \t\t\t    ch + 1 - p != display_mode_esc_sequence_len(p))\n@@ -1748,7 +1778,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t}\n \t\tstrbuf_addbuf(sb, &local_sb);\n \t} else {\n-\t\tint sb_len = sb->len, offset = 0;\n+\t\tsize_t sb_len = sb->len, offset = 0;\n \t\tif (c->flush_type == flush_left)\n \t\t\toffset = padding - len;\n \t\telse if (c->flush_type == flush_both)\n@@ -1771,8 +1801,7 @@ static size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t const char *placeholder,\n \t\t\t\t void *context)\n {\n-\tint consumed;\n-\tsize_t orig_len;\n+\tsize_t consumed, orig_len;\n \tenum {\n \t\tNO_MAGIC,\n \t\tADD_LF_BEFORE_NON_EMPTY,\n@@ -1793,9 +1822,21 @@ static size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \tdefault:\n \t\tbreak;\n \t}\n-\tif (magic != NO_MAGIC)\n+\tif (magic != NO_MAGIC) {\n \t\tplaceholder++;\n \n+\t\tswitch (placeholder[0]) {\n+\t\tcase 'w':\n+\t\t\t/*\n+\t\t\t * `%+w()` cannot ever expand to a non-empty string,\n+\t\t\t * and it potentially changes the layout of preceding\n+\t\t\t * contents. We're thus not able to handle the magic in\n+\t\t\t * this combination and refuse the pattern.\n+\t\t\t */\n+\t\t\treturn 0;\n+\t\t};\n+\t}\n+\n \torig_len = sb->len;\n \tif (((struct format_commit_context *)context)->flush_type != no_flush)\n \t\tconsumed = format_and_pad_commit(sb, placeholder, context);"
        },
        {
          "filename": "t/t0003-attributes.sh",
          "status": "modified",
          "additions": 59,
          "deletions": 0,
          "patch": "@@ -376,4 +376,63 @@ test_expect_success SYMLINKS 'symlinks not respected in-tree' '\n \ttest_i18ngrep \"unable to access.*gitattributes\" err\n '\n \n+test_expect_success 'large attributes line ignored in tree' '\n+\ttest_when_finished \"rm .gitattributes\" &&\n+\tprintf \"path %02043d\" 1 >.gitattributes &&\n+\tgit check-attr --all path >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success 'large attributes line ignores trailing content in tree' '\n+\ttest_when_finished \"rm .gitattributes\" &&\n+\t# older versions of Git broke lines at 2048 bytes; the 2045 bytes\n+\t# of 0-padding here is accounting for the three bytes of \"a 1\", which\n+\t# would knock \"trailing\" to the \"next\" line, where it would be\n+\t# erroneously parsed.\n+\tprintf \"a %02045dtrailing attribute\\n\" 1 >.gitattributes &&\n+\tgit check-attr --all trailing >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success EXPENSIVE 'large attributes file ignored in tree' '\n+\ttest_when_finished \"rm .gitattributes\" &&\n+\tdd if=/dev/zero of=.gitattributes bs=101M count=1 2>/dev/null &&\n+\tgit check-attr --all path >/dev/null 2>err &&\n+\techo \"warning: ignoring overly large gitattributes file ${SQ}.gitattributes${SQ}\" >expect &&\n+\ttest_cmp expect err\n+'\n+\n+test_expect_success 'large attributes line ignored in index' '\n+\ttest_when_finished \"git update-index --remove .gitattributes\" &&\n+\tblob=$(printf \"path %02043d\" 1 | git hash-object -w --stdin) &&\n+\tgit update-index --add --cacheinfo 100644,$blob,.gitattributes &&\n+\tgit check-attr --cached --all path >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success 'large attributes line ignores trailing content in index' '\n+\ttest_when_finished \"git update-index --remove .gitattributes\" &&\n+\tblob=$(printf \"a %02045dtrailing attribute\\n\" 1 | git hash-object -w --stdin) &&\n+\tgit update-index --add --cacheinfo 100644,$blob,.gitattributes &&\n+\tgit check-attr --cached --all trailing >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success EXPENSIVE 'large attributes file ignored in index' '\n+\ttest_when_finished \"git update-index --remove .gitattributes\" &&\n+\tblob=$(dd if=/dev/zero bs=101M count=1 2>/dev/null | git hash-object -w --stdin) &&\n+\tgit update-index --add --cacheinfo 100644,$blob,.gitattributes &&\n+\tgit check-attr --cached --all path >/dev/null 2>err &&\n+\techo \"warning: ignoring overly large gitattributes blob ${SQ}.gitattributes${SQ}\" >expect &&\n+\ttest_cmp expect err\n+'\n+\n test_done"
        },
        {
          "filename": "t/t1450-fsck.sh",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -999,4 +999,28 @@ test_expect_success 'fsck error and recovery on invalid object type' '\n \t)\n '\n \n+test_expect_success 'fsck error on gitattributes with excessive line lengths' '\n+\tblob=$(printf \"pattern %02048d\" 1 | git hash-object -w --stdin) &&\n+\ttest_when_finished \"remove_object $blob\" &&\n+\ttree=$(printf \"100644 blob %s\\t%s\\n\" $blob .gitattributes | git mktree) &&\n+\ttest_when_finished \"remove_object $tree\" &&\n+\tcat >expected <<-EOF &&\n+\terror in blob $blob: gitattributesLineLength: .gitattributes has too long lines to parse\n+\tEOF\n+\ttest_must_fail git fsck --no-dangling >actual 2>&1 &&\n+\ttest_cmp expected actual\n+'\n+\n+test_expect_success 'fsck error on gitattributes with excessive size' '\n+\tblob=$(test-tool genzeros $((100 * 1024 * 1024 + 1)) | git hash-object -w --stdin) &&\n+\ttest_when_finished \"remove_object $blob\" &&\n+\ttree=$(printf \"100644 blob %s\\t%s\\n\" $blob .gitattributes | git mktree) &&\n+\ttest_when_finished \"remove_object $tree\" &&\n+\tcat >expected <<-EOF &&\n+\terror in blob $blob: gitattributesLarge: .gitattributes too large to parse\n+\tEOF\n+\ttest_must_fail git fsck --no-dangling >actual 2>&1 &&\n+\ttest_cmp expected actual\n+'\n+\n test_done"
        },
        {
          "filename": "t/t4205-log-pretty-formats.sh",
          "status": "modified",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -1018,4 +1018,80 @@ test_expect_success '%(describe:abbrev=...) vs git describe --abbrev=...' '\n \ttest_cmp expect actual\n '\n \n+test_expect_success 'log --pretty with space stealing' '\n+\tprintf mm0 >expect &&\n+\tgit log -1 --pretty=\"format:mm%>>|(1)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty with invalid padding format' '\n+\tprintf \"%s%%<(20\" \"$(git rev-parse HEAD)\" >expect &&\n+\tgit log -1 --pretty=\"format:%H%<(20\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty with magical wrapping directives' '\n+\tcommit_id=$(git commit-tree HEAD^{tree} -m \"describe me\") &&\n+\tgit tag describe-me $commit_id &&\n+\tprintf \"\\n(tag:\\ndescribe-me)%%+w(2)\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(1)%+d%+w(2)\" $commit_id >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success SIZE_T_IS_64BIT 'log --pretty with overflowing wrapping directive' '\n+\tprintf \"%%w(2147483649,1,1)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(2147483649,1,1)%x30\" >actual &&\n+\ttest_cmp expect actual &&\n+\tprintf \"%%w(1,2147483649,1)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(1,2147483649,1)%x30\" >actual &&\n+\ttest_cmp expect actual &&\n+\tprintf \"%%w(1,1,2147483649)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(1,1,2147483649)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success SIZE_T_IS_64BIT 'log --pretty with overflowing padding directive' '\n+\tprintf \"%%<(2147483649)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%<(2147483649)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty with padding and preceding control chars' '\n+\tprintf \"\\20\\20   0\" >expect &&\n+\tgit log -1 --pretty=\"format:%x10%x10%>|(4)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty truncation with control chars' '\n+\ttest_commit \"$(printf \"\\20\\20\\20\\20xxxx\")\" file contents commit-with-control-chars &&\n+\tprintf \"\\20\\20\\20\\20x..\" >expect &&\n+\tgit log -1 --pretty=\"format:%<(3,trunc)%s\" commit-with-control-chars >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'log --pretty with huge commit message' '\n+\t# We only assert that this command does not crash. This needs to be\n+\t# executed with the address sanitizer to demonstrate failure.\n+\tgit log -1 --pretty=\"format:%>(2147483646)%x41%41%>(2147483646)%x41\" >/dev/null\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'set up huge commit' '\n+\ttest-tool genzeros 2147483649 | tr \"\\000\" \"1\" >expect &&\n+\thuge_commit=$(git commit-tree -F expect HEAD^{tree})\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'log --pretty with huge commit message' '\n+\tgit log -1 --format=\"%B%<(1)%x30\" $huge_commit >actual &&\n+\techo 0 >>expect &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'log --pretty with huge commit message does not cause allocation failure' '\n+\ttest_must_fail git log -1 --format=\"%<(1)%B\" $huge_commit 2>error &&\n+\tcat >expect <<-EOF &&\n+\tfatal: number too large to represent as int on this platform: 2147483649\n+\tEOF\n+\ttest_cmp expect error\n+'\n+\n test_done"
        },
        {
          "filename": "utf8.c",
          "status": "modified",
          "additions": 43,
          "deletions": 34,
          "patch": "@@ -206,26 +206,34 @@ int utf8_width(const char **start, size_t *remainder_p)\n  * string, assuming that the string is utf8.  Returns strlen() instead\n  * if the string does not look like a valid utf8 string.\n  */\n-int utf8_strnwidth(const char *string, int len, int skip_ansi)\n+int utf8_strnwidth(const char *string, size_t len, int skip_ansi)\n {\n-\tint width = 0;\n \tconst char *orig = string;\n+\tsize_t width = 0;\n \n-\tif (len == -1)\n-\t\tlen = strlen(string);\n \twhile (string && string < orig + len) {\n-\t\tint skip;\n+\t\tint glyph_width;\n+\t\tsize_t skip;\n+\n \t\twhile (skip_ansi &&\n \t\t       (skip = display_mode_esc_sequence_len(string)) != 0)\n \t\t\tstring += skip;\n-\t\twidth += utf8_width(&string, NULL);\n+\n+\t\tglyph_width = utf8_width(&string, NULL);\n+\t\tif (glyph_width > 0)\n+\t\t\twidth += glyph_width;\n \t}\n-\treturn string ? width : len;\n+\n+\t/*\n+\t * TODO: fix the interface of this function and `utf8_strwidth()` to\n+\t * return `size_t` instead of `int`.\n+\t */\n+\treturn cast_size_t_to_int(string ? width : len);\n }\n \n int utf8_strwidth(const char *string)\n {\n-\treturn utf8_strnwidth(string, -1, 0);\n+\treturn utf8_strnwidth(string, strlen(string), 0);\n }\n \n int is_utf8(const char *text)\n@@ -357,51 +365,52 @@ void strbuf_add_wrapped_bytes(struct strbuf *buf, const char *data, int len,\n void strbuf_utf8_replace(struct strbuf *sb_src, int pos, int width,\n \t\t\t const char *subst)\n {\n-\tstruct strbuf sb_dst = STRBUF_INIT;\n-\tchar *src = sb_src->buf;\n-\tchar *end = src + sb_src->len;\n-\tchar *dst;\n-\tint w = 0, subst_len = 0;\n+\tconst char *src = sb_src->buf, *end = sb_src->buf + sb_src->len;\n+\tstruct strbuf dst;\n+\tint w = 0;\n \n-\tif (subst)\n-\t\tsubst_len = strlen(subst);\n-\tstrbuf_grow(&sb_dst, sb_src->len + subst_len);\n-\tdst = sb_dst.buf;\n+\tstrbuf_init(&dst, sb_src->len);\n \n \twhile (src < end) {\n-\t\tchar *old;\n+\t\tconst char *old;\n+\t\tint glyph_width;\n \t\tsize_t n;\n \n \t\twhile ((n = display_mode_esc_sequence_len(src))) {\n-\t\t\tmemcpy(dst, src, n);\n+\t\t\tstrbuf_add(&dst, src, n);\n \t\t\tsrc += n;\n-\t\t\tdst += n;\n \t\t}\n \n \t\tif (src >= end)\n \t\t\tbreak;\n \n \t\told = src;\n-\t\tn = utf8_width((const char**)&src, NULL);\n-\t\tif (!src) \t/* broken utf-8, do nothing */\n+\t\tglyph_width = utf8_width((const char**)&src, NULL);\n+\t\tif (!src) /* broken utf-8, do nothing */\n \t\t\tgoto out;\n-\t\tif (n && w >= pos && w < pos + width) {\n+\n+\t\t/*\n+\t\t * In case we see a control character we copy it into the\n+\t\t * buffer, but don't add it to the width.\n+\t\t */\n+\t\tif (glyph_width < 0)\n+\t\t\tglyph_width = 0;\n+\n+\t\tif (glyph_width && w >= pos && w < pos + width) {\n \t\t\tif (subst) {\n-\t\t\t\tmemcpy(dst, subst, subst_len);\n-\t\t\t\tdst += subst_len;\n+\t\t\t\tstrbuf_addstr(&dst, subst);\n \t\t\t\tsubst = NULL;\n \t\t\t}\n-\t\t\tw += n;\n-\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tstrbuf_add(&dst, old, src - old);\n \t\t}\n-\t\tmemcpy(dst, old, src - old);\n-\t\tdst += src - old;\n-\t\tw += n;\n+\n+\t\tw += glyph_width;\n \t}\n-\tstrbuf_setlen(&sb_dst, dst - sb_dst.buf);\n-\tstrbuf_swap(sb_src, &sb_dst);\n+\n+\tstrbuf_swap(sb_src, &dst);\n out:\n-\tstrbuf_release(&sb_dst);\n+\tstrbuf_release(&dst);\n }\n \n /*\n@@ -796,7 +805,7 @@ int skip_utf8_bom(char **text, size_t len)\n void strbuf_utf8_align(struct strbuf *buf, align_type position, unsigned int width,\n \t\t       const char *s)\n {\n-\tint slen = strlen(s);\n+\tsize_t slen = strlen(s);\n \tint display_len = utf8_strnwidth(s, slen, 0);\n \tint utf8_compensation = slen - display_len;\n "
        },
        {
          "filename": "utf8.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -7,7 +7,7 @@ typedef unsigned int ucs_char_t;  /* assuming 32bit int */\n \n size_t display_mode_esc_sequence_len(const char *s);\n int utf8_width(const char **start, size_t *remainder_p);\n-int utf8_strnwidth(const char *string, int len, int skip_ansi);\n+int utf8_strnwidth(const char *string, size_t len, int skip_ansi);\n int utf8_strwidth(const char *string);\n int is_utf8(const char *text);\n int is_encoding_utf8(const char *name);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "757161efcca150a9a96b312d9e780a071e601a03",
            "date": "2025-01-13T21:02:01Z",
            "author_login": "gitster"
          },
          {
            "sha": "46afc2ba91a3c7fa8f1591c0a6a1b7c4ad0d2a07",
            "date": "2025-01-13T21:00:48Z",
            "author_login": "gitster"
          },
          {
            "sha": "f93ff170b93a1782659637824b25923245ac9dd1",
            "date": "2025-01-13T20:57:19Z",
            "author_login": "gitster"
          },
          {
            "sha": "65faad6d841c29d4545e9cf3676d75f4e6e4872c",
            "date": "2025-01-13T20:55:26Z",
            "author_login": "gitster"
          },
          {
            "sha": "fbe8d3079d4a96aeb4e4529cc93cc0043b759a05",
            "date": "2025-01-10T17:20:20Z",
            "author_login": "gitster"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-190",
    "description": "Git is distributed revision control system. `git log` can display commits in an arbitrary format using its `--format` specifiers. This functionality is also exposed to `git archive` via the `export-subst` gitattribute. When processing the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()` where a `size_t` is stored improperly as an `int`, and then added as an offset to a `memcpy()`. This overflow can be triggered directly by a user running a command which invokes the commit formatting machinery (e.g., `git log --format=...`). It may also be triggered indirectly through git archive via the export-subst mechanism, which expands format specifiers inside of files within the repository during a git archive. This integer overflow can result in arbitrary heap writes, which may result in arbitrary code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. Users who are unable to upgrade should disable `git archive` in untrusted repositories. If you expose git archive via `git daemon`, disable it by running `git config --global daemon.uploadArch false`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-17T23:15:15.690",
    "last_modified": "2024-11-21T07:24:01.993",
    "fix_date": "2023-01-16T20:11:58Z"
  },
  "references": [
    {
      "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#_export_subst",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://git-scm.com/docs/pretty-formats#Documentation/pretty-formats.txt-emltltNgttruncltruncmtruncem",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git/git/security/advisories/GHSA-475x-2q3q-hvwq",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202312-15",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#_export_subst",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://git-scm.com/docs/pretty-formats#Documentation/pretty-formats.txt-emltltNgttruncltruncmtruncem",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git/git/security/advisories/GHSA-475x-2q3q-hvwq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.gentoo.org/glsa/202312-15",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.569991",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "git",
    "owner": "git",
    "created_at": "2008-07-23T14:21:26Z",
    "updated_at": "2025-01-14T14:01:56Z",
    "pushed_at": "2025-01-13T19:45:30Z",
    "size": 271691,
    "stars": 53164,
    "forks": 25796,
    "open_issues": 201,
    "watchers": 53164,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 11381600,
      "Shell": 8590199,
      "Perl": 1166701,
      "Tcl": 852369,
      "Python": 183463,
      "Makefile": 168746,
      "Meson": 106388,
      "JavaScript": 49713,
      "CMake": 46584,
      "M4": 38265,
      "Roff": 26859,
      "C++": 26403,
      "SmPL": 15676,
      "Go": 15064,
      "CSS": 10664,
      "Batchfile": 9822,
      "Emacs Lisp": 660,
      "PowerShell": 478,
      "ReScript": 92
    },
    "commit_activity": {
      "total_commits_last_year": 3693,
      "avg_commits_per_week": 71.01923076923077,
      "days_active_last_year": 312
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:39:36.932072"
  }
}