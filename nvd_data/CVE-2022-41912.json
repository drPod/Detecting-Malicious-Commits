{
  "cve_id": "CVE-2022-41912",
  "github_data": {
    "repository": "crewjam/saml",
    "fix_commit": "aee3fb1edeeaf1088fcb458727e0fd863d277f8b",
    "related_commits": [
      "aee3fb1edeeaf1088fcb458727e0fd863d277f8b",
      "aee3fb1edeeaf1088fcb458727e0fd863d277f8b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "aee3fb1edeeaf1088fcb458727e0fd863d277f8b",
      "commit_date": "2022-11-28T13:48:29Z",
      "author": {
        "login": "crewjam",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-j2jp-wvqg-wc2g",
        "length": 90,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 862,
        "additions": 495,
        "deletions": 367
      },
      "files": [
        {
          "filename": "service_provider.go",
          "status": "modified",
          "additions": 425,
          "deletions": 346,
          "patch": "@@ -3,6 +3,7 @@ package saml\n import (\n \t\"bytes\"\n \t\"compress/flate\"\n+\t\"context\"\n \t\"crypto/rsa\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n@@ -17,9 +18,8 @@ import (\n \t\"regexp\"\n \t\"time\"\n \n-\txrv \"github.com/mattermost/xml-roundtrip-validator\"\n-\n \t\"github.com/beevik/etree\"\n+\txrv \"github.com/mattermost/xml-roundtrip-validator\"\n \tdsig \"github.com/russellhaering/goxmldsig\"\n \t\"github.com/russellhaering/goxmldsig/etreeutils\"\n \n@@ -592,97 +592,79 @@ func (e ErrBadStatus) Error() string {\n \treturn e.Status\n }\n \n-func responseIsSigned(response *etree.Element) (bool, error) {\n-\tsignatureElement, err := findChild(response, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\")\n-\tif err != nil {\n-\t\treturn false, err\n+// ParseResponse extracts the SAML IDP response received in req, resolves\n+// artifacts when necessary, validates it, and returns the verified assertion.\n+func (sp *ServiceProvider) ParseResponse(req *http.Request, possibleRequestIDs []string) (*Assertion, error) {\n+\tif artifactID := req.Form.Get(\"SAMLart\"); artifactID != \"\" {\n+\t\treturn sp.handleArtifactRequest(req.Context(), artifactID, possibleRequestIDs)\n \t}\n-\treturn signatureElement != nil, nil\n+\treturn sp.parseResponseHTTP(req, possibleRequestIDs)\n }\n \n-// validateDestination validates the Destination attribute.\n-// If the response is signed, the Destination is required to be present.\n-func (sp *ServiceProvider) validateDestination(response *etree.Element, responseDom *Response) error {\n-\tsigned, err := responseIsSigned(response)\n+func (sp *ServiceProvider) handleArtifactRequest(ctx context.Context, artifactID string, possibleRequestIDs []string) (*Assertion, error) {\n+\tretErr := &InvalidResponseError{Now: TimeNow()}\n+\n+\tartifactResolveRequest, err := sp.MakeArtifactResolveRequest(artifactID)\n \tif err != nil {\n-\t\treturn err\n+\t\tretErr.PrivateErr = fmt.Errorf(\"Cannot generate artifact resolution request: %s\", err)\n+\t\treturn nil, retErr\n \t}\n \n-\t// Compare if the response is signed OR the Destination is provided.\n-\t// (Even if the response is not signed, if the Destination is set it must match.)\n-\tif signed || responseDom.Destination != \"\" {\n-\t\tif responseDom.Destination != sp.AcsURL.String() {\n-\t\t\treturn fmt.Errorf(\"`Destination` does not match AcsURL (expected %q, actual %q)\", sp.AcsURL.String(), responseDom.Destination)\n-\t\t}\n+\trequestBody, err := elementToBytes(artifactResolveRequest.SoapRequest())\n+\tif err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn nil, retErr\n \t}\n \n-\treturn nil\n-}\n-\n-// ParseResponse extracts the SAML IDP response received in req, resolves\n-// artifacts when necessary, validates it, and returns the verified assertion.\n-func (sp *ServiceProvider) ParseResponse(req *http.Request, possibleRequestIDs []string) (*Assertion, error) {\n-\tnow := TimeNow()\n+\treq, err := http.NewRequestWithContext(ctx, \"POST\", sp.GetArtifactBindingLocation(SOAPBinding),\n+\t\tbytes.NewReader(requestBody))\n+\tif err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn nil, retErr\n+\t}\n \n-\tvar assertion *Assertion\n+\thttpClient := sp.HTTPClient\n+\tif httpClient == nil {\n+\t\thttpClient = http.DefaultClient\n+\t}\n+\tresponse, err := httpClient.Do(req)\n+\tif err != nil {\n+\t\tretErr.PrivateErr = fmt.Errorf(\"cannot resolve artifact: %s\", err)\n+\t\treturn nil, retErr\n+\t}\n+\tdefer response.Body.Close()\n+\tif response.StatusCode != 200 {\n+\t\tretErr.PrivateErr = fmt.Errorf(\"Error during artifact resolution: HTTP status %d (%s)\", response.StatusCode, response.Status)\n+\t\treturn nil, retErr\n+\t}\n+\tresponseBody, err := ioutil.ReadAll(response.Body)\n+\tif err != nil {\n+\t\tretErr.PrivateErr = fmt.Errorf(\"Error during artifact resolution: %s\", err)\n+\t\treturn nil, retErr\n+\t}\n+\tassertion, err := sp.ParseXMLArtifactResponse(responseBody, possibleRequestIDs, artifactResolveRequest.ID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn assertion, nil\n+}\n \n+func (sp *ServiceProvider) parseResponseHTTP(req *http.Request, possibleRequestIDs []string) (*Assertion, error) {\n \tretErr := &InvalidResponseError{\n-\t\tNow:      now,\n-\t\tResponse: req.PostForm.Get(\"SAMLResponse\"),\n+\t\tNow: TimeNow(),\n \t}\n \n-\tif req.Form.Get(\"SAMLart\") != \"\" {\n-\t\tretErr.Response = req.Form.Get(\"SAMLart\")\n-\n-\t\treq, err := sp.MakeArtifactResolveRequest(req.Form.Get(\"SAMLart\"))\n-\t\tif err != nil {\n-\t\t\tretErr.PrivateErr = fmt.Errorf(\"Cannot generate artifact resolution request: %s\", err)\n-\t\t\treturn nil, retErr\n-\t\t}\n-\n-\t\tdoc := etree.NewDocument()\n-\t\tdoc.SetRoot(req.SoapRequest())\n-\n-\t\tvar requestBuffer bytes.Buffer\n-\t\tdoc.WriteTo(&requestBuffer)\n-\t\tclient := sp.HTTPClient\n-\t\tif client == nil {\n-\t\t\tclient = http.DefaultClient\n-\t\t}\n-\t\tresponse, err := client.Post(sp.GetArtifactBindingLocation(SOAPBinding), \"text/xml\", &requestBuffer)\n-\t\tif err != nil {\n-\t\t\tretErr.PrivateErr = fmt.Errorf(\"Error during artifact resolution: %s\", err)\n-\t\t\treturn nil, retErr\n-\t\t}\n-\t\tdefer response.Body.Close()\n-\t\tif response.StatusCode != 200 {\n-\t\t\tretErr.PrivateErr = fmt.Errorf(\"Error during artifact resolution: HTTP status %d (%s)\", response.StatusCode, response.Status)\n-\t\t\treturn nil, retErr\n-\t\t}\n-\t\trawResponseBuf, err := ioutil.ReadAll(response.Body)\n-\t\tif err != nil {\n-\t\t\tretErr.PrivateErr = fmt.Errorf(\"Error during artifact resolution: %s\", err)\n-\t\t\treturn nil, retErr\n-\t\t}\n-\t\tassertion, err = sp.ParseXMLArtifactResponse(rawResponseBuf, possibleRequestIDs, req.ID)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t} else {\n-\t\trawResponseBuf, err := base64.StdEncoding.DecodeString(req.PostForm.Get(\"SAMLResponse\"))\n-\t\tif err != nil {\n-\t\t\tretErr.PrivateErr = fmt.Errorf(\"cannot parse base64: %s\", err)\n-\t\t\treturn nil, retErr\n-\t\t}\n-\t\tretErr.Response = string(rawResponseBuf)\n-\t\tassertion, err = sp.ParseXMLResponse(rawResponseBuf, possibleRequestIDs)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n+\trawResponseBuf, err := base64.StdEncoding.DecodeString(req.PostForm.Get(\"SAMLResponse\"))\n+\tif err != nil {\n+\t\tretErr.PrivateErr = fmt.Errorf(\"cannot parse base64: %s\", err)\n+\t\treturn nil, retErr\n \t}\n \n+\tassertion, err := sp.ParseXMLResponse(rawResponseBuf, possibleRequestIDs)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \treturn assertion, nil\n-\n }\n \n // ParseXMLArtifactResponse validates the SAML Artifact resolver response\n@@ -695,83 +677,95 @@ func (sp *ServiceProvider) ParseResponse(req *http.Request, possibleRequestIDs [\n // properties are useful in describing which part of the parsing process\n // failed. However, to discourage inadvertent disclosure the diagnostic\n // information, the Error() method returns a static string.\n-func (sp *ServiceProvider) ParseXMLArtifactResponse(decodedResponseXML []byte, possibleRequestIDs []string, artifactRequestID string) (*Assertion, error) {\n+func (sp *ServiceProvider) ParseXMLArtifactResponse(soapResponseXML []byte, possibleRequestIDs []string, artifactRequestID string) (*Assertion, error) {\n \tnow := TimeNow()\n-\t//var err error\n \tretErr := &InvalidResponseError{\n+\t\tResponse: string(soapResponseXML),\n \t\tNow:      now,\n-\t\tResponse: string(decodedResponseXML),\n \t}\n \n-\t// ensure that the response XML is well formed before we parse it\n-\tif err := xrv.Validate(bytes.NewReader(decodedResponseXML)); err != nil {\n+\t// ensure that the response XML is well-formed before we parse it\n+\tif err := xrv.Validate(bytes.NewReader(soapResponseXML)); err != nil {\n \t\tretErr.PrivateErr = fmt.Errorf(\"invalid xml: %s\", err)\n \t\treturn nil, retErr\n \t}\n \n-\tenvelope := &struct {\n-\t\tXMLName xml.Name `xml:\"http://schemas.xmlsoap.org/soap/envelope/ Envelope\"`\n-\t\tBody    struct {\n-\t\t\tArtifactResponse ArtifactResponse\n-\t\t} `xml:\"http://schemas.xmlsoap.org/soap/envelope/ Body\"`\n-\t}{}\n-\tif err := xml.Unmarshal(decodedResponseXML, &envelope); err != nil {\n+\tdoc := etree.NewDocument()\n+\tif err := doc.ReadFromBytes(soapResponseXML); err != nil {\n \t\tretErr.PrivateErr = fmt.Errorf(\"cannot unmarshal response: %s\", err)\n \t\treturn nil, retErr\n \t}\n-\n-\tresp := envelope.Body.ArtifactResponse\n-\n-\t// Validate ArtifactResponse\n-\tif resp.InResponseTo != artifactRequestID {\n-\t\tretErr.PrivateErr = fmt.Errorf(\"`InResponseTo` does not match the artifact request ID (expected %v)\", artifactRequestID)\n+\tif doc.Root().NamespaceURI() != \"http://schemas.xmlsoap.org/soap/envelope/\" ||\n+\t\tdoc.Root().Tag != \"Envelope\" {\n+\t\tretErr.PrivateErr = fmt.Errorf(\"expected a SOAP Envelope\")\n \t\treturn nil, retErr\n \t}\n-\tif resp.IssueInstant.Add(MaxIssueDelay).Before(now) {\n-\t\tretErr.PrivateErr = fmt.Errorf(\"response IssueInstant expired at %s\", resp.IssueInstant.Add(MaxIssueDelay))\n-\t\treturn nil, retErr\n-\t}\n-\tif resp.Issuer != nil && resp.Issuer.Value != sp.IDPMetadata.EntityID {\n-\t\tretErr.PrivateErr = fmt.Errorf(\"response Issuer does not match the IDP metadata (expected %q)\", sp.IDPMetadata.EntityID)\n-\t\treturn nil, retErr\n-\t}\n-\tif resp.Status.StatusCode.Value != StatusSuccess {\n-\t\tretErr.PrivateErr = ErrBadStatus{Status: resp.Status.StatusCode.Value}\n+\n+\tsoapBodyEl, err := findOneChild(doc.Root(), \"http://schemas.xmlsoap.org/soap/envelope/\", \"Body\")\n+\tif err != nil {\n+\t\tretErr.PrivateErr = err\n \t\treturn nil, retErr\n \t}\n \n-\tdoc := etree.NewDocument()\n-\tif err := doc.ReadFromBytes(decodedResponseXML); err != nil {\n+\tartifactResponseEl, err := findOneChild(soapBodyEl, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"ArtifactResponse\")\n+\tif err != nil {\n \t\tretErr.PrivateErr = err\n \t\treturn nil, retErr\n \t}\n \n-\tartifactEl := doc.FindElement(\"Envelope/Body/ArtifactResponse\")\n-\tif artifactEl == nil {\n-\t\tretErr.PrivateErr = fmt.Errorf(\"missing ArtifactResponse\")\n-\t\treturn nil, retErr\n+\treturn sp.parseArtifactResponse(artifactResponseEl, possibleRequestIDs, artifactRequestID, now)\n+}\n+\n+func (sp *ServiceProvider) parseArtifactResponse(artifactResponseEl *etree.Element, possibleRequestIDs []string, artifactRequestID string, now time.Time) (*Assertion, error) {\n+\tretErr := &InvalidResponseError{\n+\t\tNow:      now,\n+\t\tResponse: elementToString(artifactResponseEl),\n+\t}\n+\n+\t{\n+\t\tvar artifactResponse ArtifactResponse\n+\t\tif err := unmarshalElement(artifactResponseEl, &artifactResponse); err != nil {\n+\t\t\tretErr.PrivateErr = err\n+\t\t\treturn nil, retErr\n+\t\t}\n+\t\tif artifactResponse.InResponseTo != artifactRequestID {\n+\t\t\tretErr.PrivateErr = fmt.Errorf(\"`InResponseTo` does not match the artifact request ID (expected %s)\", artifactRequestID)\n+\t\t\treturn nil, retErr\n+\t\t}\n+\t\tif artifactResponse.IssueInstant.Add(MaxIssueDelay).Before(now) {\n+\t\t\tretErr.PrivateErr = fmt.Errorf(\"response IssueInstant expired at %s\", artifactResponse.IssueInstant.Add(MaxIssueDelay))\n+\t\t\treturn nil, retErr\n+\t\t}\n+\t\tif artifactResponse.Issuer != nil && artifactResponse.Issuer.Value != sp.IDPMetadata.EntityID {\n+\t\t\tretErr.PrivateErr = fmt.Errorf(\"response Issuer does not match the IDP metadata (expected %q)\", sp.IDPMetadata.EntityID)\n+\t\t\treturn nil, retErr\n+\t\t}\n+\t\tif artifactResponse.Status.StatusCode.Value != StatusSuccess {\n+\t\t\tretErr.PrivateErr = ErrBadStatus{Status: artifactResponse.Status.StatusCode.Value}\n+\t\t\treturn nil, retErr\n+\t\t}\n \t}\n-\tresponseEl := doc.FindElement(\"Envelope/Body/ArtifactResponse/Response\")\n-\tif responseEl == nil {\n-\t\tretErr.PrivateErr = fmt.Errorf(\"missing inner Response\")\n+\n+\tvar signatureRequirement signatureRequirement\n+\tsigErr := sp.validateSignature(artifactResponseEl)\n+\tif sigErr == nil {\n+\t\tsignatureRequirement = signatureNotRequired\n+\t} else if sigErr == errSignatureElementNotPresent {\n+\t\tsignatureRequirement = signatureRequired\n+\t} else {\n+\t\tretErr.PrivateErr = sigErr\n \t\treturn nil, retErr\n \t}\n \n-\thaveSignature := false\n-\tvar err error\n-\tif err = sp.validateArtifactSigned(artifactEl); err != nil && err.Error() != \"either the Response or Assertion must be signed\" {\n+\tresponseEl, err := findOneChild(artifactResponseEl, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"Response\")\n+\tif err != nil {\n \t\tretErr.PrivateErr = err\n \t\treturn nil, retErr\n \t}\n-\tif err == nil {\n-\t\thaveSignature = true\n-\t}\n-\tassertion, updatedResponse, err := sp.validateXMLResponse(&resp.Response, responseEl, possibleRequestIDs, now, !haveSignature)\n+\n+\tassertion, err := sp.parseResponse(responseEl, possibleRequestIDs, now, signatureRequirement)\n \tif err != nil {\n \t\tretErr.PrivateErr = err\n-\t\tif updatedResponse != nil {\n-\t\t\tretErr.Response = *updatedResponse\n-\t\t}\n \t\treturn nil, retErr\n \t}\n \n@@ -797,150 +791,213 @@ func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR\n \t\tResponse: string(decodedResponseXML),\n \t}\n \n-\t// ensure that the response XML is well formed before we parse it\n+\t// ensure that the response XML is well-formed before we parse it\n \tif err := xrv.Validate(bytes.NewReader(decodedResponseXML)); err != nil {\n \t\tretErr.PrivateErr = fmt.Errorf(\"invalid xml: %s\", err)\n \t\treturn nil, retErr\n \t}\n \n-\t// do some validation first before we decrypt\n-\tresp := Response{}\n-\tif err := xml.Unmarshal(decodedResponseXML, &resp); err != nil {\n-\t\tretErr.PrivateErr = fmt.Errorf(\"cannot unmarshal response: %s\", err)\n-\t\treturn nil, retErr\n-\t}\n-\n \tdoc := etree.NewDocument()\n \tif err := doc.ReadFromBytes(decodedResponseXML); err != nil {\n \t\tretErr.PrivateErr = err\n \t\treturn nil, retErr\n \t}\n \n-\tassertion, updatedResponse, err := sp.validateXMLResponse(&resp, doc.Root(), possibleRequestIDs, now, true)\n+\tassertion, err := sp.parseResponse(doc.Root(), possibleRequestIDs, now, signatureRequired)\n \tif err != nil {\n \t\tretErr.PrivateErr = err\n-\t\tif updatedResponse != nil {\n-\t\t\tretErr.Response = *updatedResponse\n-\t\t}\n \t\treturn nil, retErr\n \t}\n \n \treturn assertion, nil\n }\n \n+type signatureRequirement int\n+\n+const (\n+\tsignatureRequired signatureRequirement = iota\n+\tsignatureNotRequired\n+)\n+\n // validateXMLResponse validates the SAML IDP response and returns\n // the verified assertion.\n //\n // This function handles decrypting the message, verifying the digital\n // signature on the assertion, and verifying that the specified conditions\n // and properties are met.\n-func (sp *ServiceProvider) validateXMLResponse(resp *Response, responseEl *etree.Element, possibleRequestIDs []string, now time.Time, needSig bool) (*Assertion, *string, error) {\n-\tvar err error\n-\tvar updatedResponse *string\n-\tif err := sp.validateDestination(responseEl, resp); err != nil {\n-\t\treturn nil, updatedResponse, err\n+func (sp *ServiceProvider) parseResponse(responseEl *etree.Element, possibleRequestIDs []string, now time.Time, signatureRequirement signatureRequirement) (*Assertion, error) {\n+\tvar responseSignatureErr error\n+\tvar responseHasSignature bool\n+\tif signatureRequirement == signatureRequired {\n+\t\tresponseSignatureErr = sp.validateSignature(responseEl)\n+\t\tif responseSignatureErr != errSignatureElementNotPresent {\n+\t\t\tresponseHasSignature = true\n+\t\t}\n+\n+\t\t// Note: we're deferring taking action on the signature validation until after we've\n+\t\t// processed the request attributes, because certain test cases seem to require this mis-feature.\n+\t\t// TODO(ross): adjust the test cases so that we can abort here if the Response signature is invalid.\n \t}\n \n-\trequestIDvalid := false\n+\t// validate request attributes\n+\t{\n+\t\tvar response Response\n+\t\tif err := unmarshalElement(responseEl, &response); err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"cannot unmarshal response: %v\", err)\n+\t\t}\n \n-\tif sp.AllowIDPInitiated {\n-\t\trequestIDvalid = true\n-\t} else {\n-\t\tfor _, possibleRequestID := range possibleRequestIDs {\n-\t\t\tif resp.InResponseTo == possibleRequestID {\n-\t\t\t\trequestIDvalid = true\n+\t\t// If the response is *not* signed, the Destination may be omitted.\n+\t\tif responseHasSignature || response.Destination != \"\" {\n+\t\t\tif response.Destination != sp.AcsURL.String() {\n+\t\t\t\treturn nil, fmt.Errorf(\"`Destination` does not match AcsURL (expected %q, actual %q)\", sp.AcsURL.String(), response.Destination)\n \t\t\t}\n \t\t}\n-\t}\n-\n-\tif !requestIDvalid {\n-\t\treturn nil, updatedResponse, fmt.Errorf(\"`InResponseTo` does not match any of the possible request IDs (expected %v)\", possibleRequestIDs)\n-\t}\n \n-\tif resp.IssueInstant.Add(MaxIssueDelay).Before(now) {\n-\t\treturn nil, updatedResponse, fmt.Errorf(\"response IssueInstant expired at %s\", resp.IssueInstant.Add(MaxIssueDelay))\n-\t}\n-\tif resp.Issuer != nil && resp.Issuer.Value != sp.IDPMetadata.EntityID {\n-\t\treturn nil, updatedResponse, fmt.Errorf(\"response Issuer does not match the IDP metadata (expected %q)\", sp.IDPMetadata.EntityID)\n-\t}\n-\tif resp.Status.StatusCode.Value != StatusSuccess {\n-\t\treturn nil, updatedResponse, ErrBadStatus{Status: resp.Status.StatusCode.Value}\n-\t}\n-\n-\tvar assertion *Assertion\n-\tif resp.EncryptedAssertion == nil {\n-\t\t// TODO(ross): verify that the namespace is urn:oasis:names:tc:SAML:2.0:protocol\n-\t\tif responseEl.Tag != \"Response\" {\n-\t\t\treturn nil, updatedResponse, fmt.Errorf(\"expected to find a response object, not %s\", responseEl.Tag)\n+\t\trequestIDvalid := false\n+\t\tif sp.AllowIDPInitiated {\n+\t\t\trequestIDvalid = true\n+\t\t} else {\n+\t\t\tfor _, possibleRequestID := range possibleRequestIDs {\n+\t\t\t\tif response.InResponseTo == possibleRequestID {\n+\t\t\t\t\trequestIDvalid = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif !requestIDvalid {\n+\t\t\treturn nil, fmt.Errorf(\"`InResponseTo` does not match any of the possible request IDs (expected %v)\", possibleRequestIDs)\n \t\t}\n \n-\t\tif err = sp.validateSigned(responseEl); err != nil && !(!needSig && err.Error() == \"either the Response or Assertion must be signed\") {\n-\t\t\treturn nil, updatedResponse, err\n+\t\tif response.IssueInstant.Add(MaxIssueDelay).Before(now) {\n+\t\t\treturn nil, fmt.Errorf(\"response IssueInstant expired at %s\", response.IssueInstant.Add(MaxIssueDelay))\n+\t\t}\n+\t\tif response.Issuer != nil && response.Issuer.Value != sp.IDPMetadata.EntityID {\n+\t\t\treturn nil, fmt.Errorf(\"response Issuer does not match the IDP metadata (expected %q)\", sp.IDPMetadata.EntityID)\n \t\t}\n+\t\tif response.Status.StatusCode.Value != StatusSuccess {\n+\t\t\treturn nil, ErrBadStatus{Status: response.Status.StatusCode.Value}\n+\t\t}\n+\t}\n \n-\t\tassertion = resp.Assertion\n+\tif signatureRequirement == signatureRequired {\n+\t\tif responseSignatureErr == nil {\n+\t\t\t// since the request has a signature, none of the Assertions need one\n+\t\t\tsignatureRequirement = signatureNotRequired\n+\t\t} else if responseSignatureErr == errSignatureElementNotPresent {\n+\t\t\t// the request has no signature, so assertions must be signed\n+\t\t\tsignatureRequirement = signatureRequired // nop\n+\t\t} else {\n+\t\t\treturn nil, responseSignatureErr\n+\t\t}\n \t}\n \n-\t// decrypt the response\n-\tif resp.EncryptedAssertion != nil {\n-\t\t// encrypted assertions are part of the signature\n-\t\t// before decrypting the response verify that\n-\t\tresponseSigned, err := responseIsSigned(responseEl)\n+\tvar errs []error\n+\tvar assertions []Assertion\n+\n+\t// look for encrypted assertions\n+\t{\n+\t\tencryptedAssertionEls, err := findChildren(responseEl, \"urn:oasis:names:tc:SAML:2.0:assertion\", \"EncryptedAssertion\")\n \t\tif err != nil {\n-\t\t\treturn nil, updatedResponse, err\n+\t\t\treturn nil, err\n \t\t}\n-\t\tif responseSigned {\n-\t\t\tif err := sp.validateSigned(responseEl); err != nil {\n-\t\t\t\treturn nil, updatedResponse, err\n+\t\tfor _, encryptedAssertionEl := range encryptedAssertionEls {\n+\t\t\tassertion, err := sp.parseEncryptedAssertion(encryptedAssertionEl, possibleRequestIDs, now, signatureRequirement)\n+\t\t\tif err != nil {\n+\t\t\t\terrs = append(errs, err)\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\tassertions = append(assertions, *assertion)\n \t\t}\n+\t}\n \n-\t\tvar key interface{} = sp.Key\n-\t\tkeyEl := responseEl.FindElement(\"//EncryptedAssertion/EncryptedKey\")\n-\t\tif keyEl != nil {\n-\t\t\tkey, err = xmlenc.Decrypt(sp.Key, keyEl)\n+\t// look for plaintext assertions\n+\t{\n+\t\tassertionEls, err := findChildren(responseEl, \"urn:oasis:names:tc:SAML:2.0:assertion\", \"Assertion\")\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfor _, assertionEl := range assertionEls {\n+\t\t\tassertion, err := sp.parseAssertion(assertionEl, possibleRequestIDs, now, signatureRequirement)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, updatedResponse, fmt.Errorf(\"failed to decrypt key from response: %s\", err)\n+\t\t\t\terrs = append(errs, err)\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\tassertions = append(assertions, *assertion)\n \t\t}\n+\t}\n \n-\t\tel := responseEl.FindElement(\"//EncryptedAssertion/EncryptedData\")\n-\t\tplaintextAssertion, err := xmlenc.Decrypt(key, el)\n-\t\tif err != nil {\n-\t\t\treturn nil, updatedResponse, fmt.Errorf(\"failed to decrypt response: %s\", err)\n+\tif len(assertions) == 0 {\n+\t\tif len(errs) > 0 {\n+\t\t\treturn nil, errs[0]\n \t\t}\n-\t\tupdatedResponse = new(string)\n-\t\t*updatedResponse = string(plaintextAssertion)\n+\t\treturn nil, fmt.Errorf(\"expected at least one valid Assertion, none found\")\n+\t}\n \n-\t\t// TODO(ross): add test case for this\n-\t\tif err := xrv.Validate(bytes.NewReader(plaintextAssertion)); err != nil {\n-\t\t\treturn nil, updatedResponse, fmt.Errorf(\"plaintext response contains invalid XML: %s\", err)\n-\t\t}\n+\t// if we have at least one assertion, return the first one. It is almost universally true that valid responses\n+\t// contain only one assertion. This is less that fully correct, but we didn't realize that there could be more\n+\t// than one assertion at the time of establishing the public interface of ParseXMLResponse(), so for compatability\n+\t// we return the first one.\n+\treturn &assertions[0], nil\n+}\n \n-\t\tdoc := etree.NewDocument()\n-\t\tif err := doc.ReadFromBytes(plaintextAssertion); err != nil {\n-\t\t\treturn nil, updatedResponse, fmt.Errorf(\"cannot parse plaintext response %v\", err)\n-\t\t}\n+func (sp *ServiceProvider) parseEncryptedAssertion(encryptedAssertionEl *etree.Element, possibleRequestIDs []string, now time.Time, signatureRequirement signatureRequirement) (*Assertion, error) {\n+\tassertionEl, err := sp.decryptElement(encryptedAssertionEl)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to decrypt EncryptedAssertion: %v\", err)\n+\t}\n+\treturn sp.parseAssertion(assertionEl, possibleRequestIDs, now, signatureRequirement)\n+}\n \n-\t\t// the decrypted assertion may be signed too\n-\t\t// otherwise, a signed response is sufficient\n-\t\tif err := sp.validateSigned(doc.Root()); err != nil && !((responseSigned || !needSig) && err.Error() == \"either the Response or Assertion must be signed\") {\n-\t\t\treturn nil, updatedResponse, err\n+func (sp *ServiceProvider) decryptElement(encryptedEl *etree.Element) (*etree.Element, error) {\n+\tencryptedDataEl, err := findOneChild(encryptedEl, \"http://www.w3.org/2001/04/xmlenc#\", \"EncryptedData\")\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar key interface{} = sp.Key\n+\tkeyEl := encryptedEl.FindElement(\"./EncryptedKey\")\n+\tif keyEl != nil {\n+\t\tvar err error\n+\t\tkey, err = xmlenc.Decrypt(sp.Key, keyEl)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to decrypt key from response: %s\", err)\n \t\t}\n+\t}\n+\n+\tplaintextEl, err := xmlenc.Decrypt(key, encryptedDataEl)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \n-\t\tassertion = &Assertion{}\n-\t\t// Note: plaintextAssertion is known to be safe to parse because\n-\t\t// plaintextAssertion is unmodified from when xrv.Validate() was called above.\n-\t\tif err := xml.Unmarshal(plaintextAssertion, assertion); err != nil {\n-\t\t\treturn nil, updatedResponse, err\n+\tif err := xrv.Validate(bytes.NewReader(plaintextEl)); err != nil {\n+\t\treturn nil, fmt.Errorf(\"plaintext response contains invalid XML: %s\", err)\n+\t}\n+\n+\tdoc := etree.NewDocument()\n+\tif err := doc.ReadFromBytes(plaintextEl); err != nil {\n+\t\treturn nil, fmt.Errorf(\"cannot parse plaintext response %v\", err)\n+\t}\n+\treturn doc.Root(), nil\n+}\n+\n+func (sp *ServiceProvider) parseAssertion(assertionEl *etree.Element, possibleRequestIDs []string, now time.Time, signatureRequirement signatureRequirement) (*Assertion, error) {\n+\tif signatureRequirement == signatureRequired {\n+\t\tsigErr := sp.validateSignature(assertionEl)\n+\t\tif sigErr != nil {\n+\t\t\treturn nil, sigErr\n \t\t}\n \t}\n \n-\tif err := sp.validateAssertion(assertion, possibleRequestIDs, now); err != nil {\n-\t\treturn nil, updatedResponse, fmt.Errorf(\"assertion invalid: %s\", err)\n+\t// parse the assertion we just validated\n+\tvar assertion Assertion\n+\tif err := unmarshalElement(assertionEl, &assertion); err != nil {\n+\t\treturn nil, err\n \t}\n \n-\treturn assertion, updatedResponse, nil\n+\tif err := sp.validateAssertion(&assertion, possibleRequestIDs, now); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &assertion, nil\n }\n \n // validateAssertion checks that the conditions specified in assertion match\n@@ -1012,117 +1069,21 @@ func (sp *ServiceProvider) validateAssertion(assertion *Assertion, possibleReque\n \treturn nil\n }\n \n-func findChild(parentEl *etree.Element, childNS string, childTag string) (*etree.Element, error) {\n-\tfor _, childEl := range parentEl.ChildElements() {\n-\t\tif childEl.Tag != childTag {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tctx, err := etreeutils.NSBuildParentContext(childEl)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tctx, err = ctx.SubContext(childEl)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tns, err := ctx.LookupPrefix(childEl.Space)\n-\t\tif err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"[%s]:%s cannot find prefix %s: %v\", childNS, childTag, childEl.Space, err)\n-\t\t}\n-\t\tif ns != childNS {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\treturn childEl, nil\n-\t}\n-\treturn nil, nil\n-}\n-\n-// validateArtifactSigned returns a nil error iff each of the signatures on the ArtifactResponse, Response\n-// and Assertion elements are valid and there is at least one signature.\n-func (sp *ServiceProvider) validateArtifactSigned(artifactEl *etree.Element) error {\n-\thaveSignature := false\n+var errSignatureElementNotPresent = errors.New(\"Signature element not present\")\n \n-\tsigEl, err := findChild(artifactEl, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\")\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif sigEl != nil {\n-\t\tif err = sp.validateSignature(artifactEl); err != nil {\n-\t\t\treturn fmt.Errorf(\"cannot validate signature on Response: %v\", err)\n-\t\t}\n-\t\thaveSignature = true\n-\t}\n-\n-\tresponseEl, err := findChild(artifactEl, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"Response\")\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif responseEl != nil {\n-\t\terr = sp.validateSigned(responseEl)\n-\t\tif err != nil && err.Error() != \"either the Response or Assertion must be signed\" {\n-\t\t\treturn err\n-\t\t}\n-\t\tif err == nil {\n-\t\t\thaveSignature = true // guaranteed by validateSigned\n-\t\t}\n-\t}\n-\n-\tif !haveSignature {\n-\t\treturn errors.New(\"either the ArtifactResponse, Response or Assertion must be signed\")\n-\t}\n-\treturn nil\n-}\n-\n-// validateSigned returns a nil error iff each of the signatures on the Response and Assertion elements\n-// are valid and there is at least one signature.\n-func (sp *ServiceProvider) validateSigned(responseEl *etree.Element) error {\n-\thaveSignature := false\n-\n-\t// Some SAML responses have the signature on the Response object, and some on the Assertion\n-\t// object, and some on both. We will require that at least one signature be present and that\n-\t// all signatures be valid\n-\tsigEl, err := findChild(responseEl, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\")\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif sigEl != nil {\n-\t\tif err = sp.validateSignature(responseEl); err != nil {\n-\t\t\treturn fmt.Errorf(\"cannot validate signature on Response: %v\", err)\n-\t\t}\n-\t\thaveSignature = true\n-\t}\n-\n-\tassertionEl, err := findChild(responseEl, \"urn:oasis:names:tc:SAML:2.0:assertion\", \"Assertion\")\n+// validateSignature returns nil iff the Signature embedded in the element is valid\n+func (sp *ServiceProvider) validateSignature(el *etree.Element) error {\n+\tsigEl, err := findChild(el, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\")\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif assertionEl != nil {\n-\t\tsigEl, err := findChild(assertionEl, \"http://www.w3.org/2000/09/xmldsig#\", \"Signature\")\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif sigEl != nil {\n-\t\t\tif err = sp.validateSignature(assertionEl); err != nil {\n-\t\t\t\treturn fmt.Errorf(\"cannot validate signature on Response: %v\", err)\n-\t\t\t}\n-\t\t\thaveSignature = true\n-\t\t}\n-\t}\n-\n-\tif !haveSignature {\n-\t\treturn errors.New(\"either the Response or Assertion must be signed\")\n+\tif sigEl == nil {\n+\t\treturn errSignatureElementNotPresent\n \t}\n-\treturn nil\n-}\n \n-// validateSignature returns nill iff the Signature embedded in the element is valid\n-func (sp *ServiceProvider) validateSignature(el *etree.Element) error {\n \tcerts, err := sp.getIDPSigningCerts()\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"cannot validate signature on %s: %v\", el.Tag, err)\n \t}\n \n \tcertificateStore := dsig.MemoryX509CertificateStore{\n@@ -1154,23 +1115,26 @@ func (sp *ServiceProvider) validateSignature(el *etree.Element) error {\n \n \tctx, err := etreeutils.NSBuildParentContext(el)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"cannot validate signature on %s: %v\", el.Tag, err)\n \t}\n \tctx, err = ctx.SubContext(el)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"cannot validate signature on %s: %v\", el.Tag, err)\n \t}\n \tel, err = etreeutils.NSDetatch(ctx, el)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"cannot validate signature on %s: %v\", el.Tag, err)\n \t}\n \n \tif sp.SignatureVerifier != nil {\n \t\treturn sp.SignatureVerifier.VerifySignature(validationContext, el)\n \t}\n \n-\t_, err = validationContext.Validate(el)\n-\treturn err\n+\tif _, err := validationContext.Validate(el); err != nil {\n+\t\treturn fmt.Errorf(\"cannot validate signature on %s: %v\", el.Tag, err)\n+\t}\n+\n+\treturn nil\n }\n \n // SignLogoutRequest adds the `Signature` element to the `LogoutRequest`.\n@@ -1497,73 +1461,90 @@ func (sp *ServiceProvider) ValidateLogoutResponseRequest(req *http.Request) erro\n \n // ValidateLogoutResponseForm returns a nil error if the logout response is valid.\n func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error {\n+\tretErr := &InvalidResponseError{\n+\t\tNow: TimeNow(),\n+\t}\n+\n \trawResponseBuf, err := base64.StdEncoding.DecodeString(postFormData)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"unable to parse base64: %s\", err)\n+\t\tretErr.PrivateErr = fmt.Errorf(\"unable to parse base64: %s\", err)\n+\t\treturn retErr\n \t}\n+\tretErr.Response = string(rawResponseBuf)\n \n \t// TODO(ross): add test case for this (SLO does not have tests right now)\n \tif err := xrv.Validate(bytes.NewReader(rawResponseBuf)); err != nil {\n \t\treturn fmt.Errorf(\"response contains invalid XML: %s\", err)\n \t}\n \n-\tvar resp LogoutResponse\n-\tif err := xml.Unmarshal(rawResponseBuf, &resp); err != nil {\n-\t\treturn fmt.Errorf(\"cannot unmarshal response: %s\", err)\n+\tdoc := etree.NewDocument()\n+\tif err := doc.ReadFromBytes(rawResponseBuf); err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n \t}\n \n-\tif err := sp.validateLogoutResponse(&resp); err != nil {\n-\t\treturn err\n+\tif err := sp.validateSignature(doc.Root()); err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n \t}\n \n-\tdoc := etree.NewDocument()\n-\tif err := doc.ReadFromBytes(rawResponseBuf); err != nil {\n+\tvar resp LogoutResponse\n+\tif err := unmarshalElement(doc.Root(), &resp); err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n+\t}\n+\tif err := sp.validateLogoutResponse(&resp); err != nil {\n \t\treturn err\n \t}\n-\n-\tresponseEl := doc.Root()\n-\treturn sp.validateSigned(responseEl)\n+\treturn nil\n }\n \n // ValidateLogoutResponseRedirect returns a nil error if the logout response is valid.\n //\n // URL Binding appears to be gzip / flate encoded\n // See https://www.oasis-open.org/committees/download.php/20645/sstc-saml-tech-overview-2%200-draft-10.pdf  6.6\n func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData string) error {\n+\tretErr := &InvalidResponseError{\n+\t\tNow: TimeNow(),\n+\t}\n+\n \trawResponseBuf, err := base64.StdEncoding.DecodeString(queryParameterData)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"unable to parse base64: %s\", err)\n+\t\tretErr.PrivateErr = fmt.Errorf(\"unable to parse base64: %s\", err)\n+\t\treturn retErr\n \t}\n+\tretErr.Response = string(rawResponseBuf)\n \n \tgr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))\n \tif err != nil {\n-\t\treturn err\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n \t}\n \n \tif err := xrv.Validate(bytes.NewReader(gr)); err != nil {\n \t\treturn err\n \t}\n \n-\tdecoder := xml.NewDecoder(bytes.NewReader(gr))\n-\n-\tvar resp LogoutResponse\n-\n-\terr = decoder.Decode(&resp)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"unable to flate decode: %s\", err)\n+\tdoc := etree.NewDocument()\n+\tif err := doc.ReadFromBytes(rawResponseBuf); err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n \t}\n \n-\tif err := sp.validateLogoutResponse(&resp); err != nil {\n-\t\treturn err\n+\tif err := sp.validateSignature(doc.Root()); err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n \t}\n \n-\tdoc := etree.NewDocument()\n-\tif _, err := doc.ReadFrom(bytes.NewReader(gr)); err != nil {\n+\tvar resp LogoutResponse\n+\tif err := unmarshalElement(doc.Root(), &resp); err != nil {\n+\t\tretErr.PrivateErr = err\n+\t\treturn retErr\n+\t}\n+\tif err := sp.validateLogoutResponse(&resp); err != nil {\n \t\treturn err\n \t}\n-\n-\tresponseEl := doc.Root()\n-\treturn sp.validateSigned(responseEl)\n+\treturn nil\n }\n \n // validateLogoutResponse validates the LogoutResponse fields. Returns a nil error if the LogoutResponse is valid.\n@@ -1592,3 +1573,101 @@ func firstSet(a, b string) string {\n \t}\n \treturn a\n }\n+\n+// findChildren returns all the elements matching childNS/childTag that are direct children of parentEl.\n+func findChildren(parentEl *etree.Element, childNS string, childTag string) ([]*etree.Element, error) {\n+\tvar rv []*etree.Element\n+\tfor _, childEl := range parentEl.ChildElements() {\n+\t\tif childEl.Tag != childTag {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tctx, err := etreeutils.NSBuildParentContext(childEl)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tctx, err = ctx.SubContext(childEl)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tns, err := ctx.LookupPrefix(childEl.Space)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"[%s]:%s cannot find prefix %s: %v\", childNS, childTag, childEl.Space, err)\n+\t\t}\n+\t\tif ns != childNS {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\trv = append(rv, childEl)\n+\t}\n+\n+\treturn rv, nil\n+}\n+\n+// findOneChild finds the specified child element. Returns an error if the element doesn't exist.\n+func findOneChild(parentEl *etree.Element, childNS string, childTag string) (*etree.Element, error) {\n+\tchildren, err := findChildren(parentEl, childNS, childTag)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch len(children) {\n+\tcase 0:\n+\t\treturn nil, fmt.Errorf(\"cannot find %s:%s element\", childNS, childTag)\n+\tcase 1:\n+\t\treturn children[0], nil\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"expected exactly one %s:%s element\", childNS, childTag)\n+\t}\n+}\n+\n+// findChild finds the specified child element. Returns (nil, nil) of the element doesn't exist.\n+func findChild(parentEl *etree.Element, childNS string, childTag string) (*etree.Element, error) {\n+\tchildren, err := findChildren(parentEl, childNS, childTag)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch len(children) {\n+\tcase 0:\n+\t\treturn nil, nil\n+\tcase 1:\n+\t\treturn children[0], nil\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"expected at most one %s:%s element\", childNS, childTag)\n+\t}\n+}\n+\n+func elementToBytes(el *etree.Element) ([]byte, error) {\n+\tnamespaces := map[string]string{}\n+\tfor _, childEl := range el.FindElements(\"//*\") {\n+\t\tns := childEl.NamespaceURI()\n+\t\tif ns != \"\" {\n+\t\t\tnamespaces[childEl.Space] = ns\n+\t\t}\n+\t}\n+\n+\tdoc := etree.NewDocument()\n+\tdoc.SetRoot(el.Copy())\n+\tfor space, uri := range namespaces {\n+\t\tdoc.Root().CreateAttr(\"xmlns:\"+space, uri)\n+\t}\n+\n+\treturn doc.WriteToBytes()\n+}\n+\n+// unmarshalElement serializes el into v by serializing el and then parsing it with xml.Unmarshal.\n+func unmarshalElement(el *etree.Element, v interface{}) error {\n+\tbuf, err := elementToBytes(el)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn xml.Unmarshal(buf, v)\n+}\n+\n+func elementToString(el *etree.Element) string {\n+\tbuf, err := elementToBytes(el)\n+\tif err != nil {\n+\t\treturn \"\"\n+\t}\n+\treturn string(buf)\n+}"
        },
        {
          "filename": "service_provider_go117_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -125,12 +125,12 @@ func TestSPInvalidResponses(t *testing.T) {\n \treq.PostForm.Set(\"SAMLResponse\", base64.StdEncoding.EncodeToString(test.SamlResponse))\n \t_, err = s.ParseResponse(&req, []string{\"id-9e61753d64e928af5a7a341a97f420c9\"})\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: cannot parse certificate: illegal base64 data at input byte 4\"))\n+\t\t\"cannot validate signature on Assertion: cannot parse certificate: illegal base64 data at input byte 4\"))\n \n \ts.IDPMetadata.IDPSSODescriptors[0].KeyDescriptors[0].KeyInfo.X509Data.X509Certificates[0].Data = \"aW52YWxpZA==\"\n \treq.PostForm.Set(\"SAMLResponse\", base64.StdEncoding.EncodeToString(test.SamlResponse))\n \t_, err = s.ParseResponse(&req, []string{\"id-9e61753d64e928af5a7a341a97f420c9\"})\n \n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: x509: malformed certificate\"))\n+\t\t\"cannot validate signature on Assertion: x509: malformed certificate\"))\n }"
        },
        {
          "filename": "service_provider_test.go",
          "status": "modified",
          "additions": 60,
          "deletions": 19,
          "patch": "@@ -985,7 +985,7 @@ func TestServiceProviderMismatchedDestinationsWithSignaturePresent(t *testing.T)\n \n \treq := http.Request{PostForm: url.Values{}}\n \ts.AcsURL = mustParseURL(\"https://wrong/saml2/acs\")\n-\tbytes, _ := addSignatureToDocument(test.responseDom()).WriteToBytes()\n+\tbytes, _ := test.responseDom().WriteToBytes()\n \treq.PostForm.Set(\"SAMLResponse\", base64.StdEncoding.EncodeToString(bytes))\n \t_, err = s.ParseResponse(&req, []string{\"id-9e61753d64e928af5a7a341a97f420c9\"})\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n@@ -1087,11 +1087,20 @@ func TestSPInvalidAssertions(t *testing.T) {\n \terr := xml.Unmarshal(test.IDPMetadata, &s.IDPMetadata)\n \tassert.Check(t, err)\n \n-\treq := http.Request{PostForm: url.Values{}}\n-\treq.PostForm.Set(\"SAMLResponse\", base64.StdEncoding.EncodeToString(test.SamlResponse))\n-\ts.IDPMetadata.IDPSSODescriptors[0].KeyDescriptors[0].KeyInfo.X509Data.X509Certificates[0].Data = \"invalid\"\n-\t_, err = s.ParseResponse(&req, []string{\"id-9e61753d64e928af5a7a341a97f420c9\"})\n-\tassertionBuf := []byte(err.(*InvalidResponseError).Response)\n+\t// HACK: decrypt response without verifying assertions\n+\tvar assertionBuf []byte\n+\t{\n+\t\tdoc := etree.NewDocument()\n+\t\tassert.Check(t, doc.ReadFromBytes(test.SamlResponse))\n+\t\tencryptedEL := doc.Root().FindElement(\"//EncryptedAssertion\")\n+\t\tassertionEl, err := s.decryptElement(encryptedEL)\n+\t\tassert.Check(t, err)\n+\n+\t\tdoc = etree.NewDocument()\n+\t\tdoc.SetRoot(assertionEl)\n+\t\tassertionBuf, err = doc.WriteToBytes()\n+\t\tassert.Check(t, err)\n+\t}\n \n \tassertion := Assertion{}\n \terr = xml.Unmarshal(assertionBuf, &assertion)\n@@ -1234,9 +1243,13 @@ func TestXswPermutationThreeIsRejected(t *testing.T) {\n \treq := http.Request{PostForm: url.Values{}}\n \treq.PostForm.Set(\"SAMLResponse\", string(respStr))\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n-\t// Because this permutation contains an unsigned assertion as child of the response\n-\tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"either the Response or Assertion must be signed\"))\n+\n+\t// This response contains two assertions. The first is missing a Signature element. The second is\n+\t// signed by a certificate that is not yet valid at the time of issue.\n+\t//\n+\t// When no assertions are valid, we return the first error encountered, which in this case is that\n+\t// there is no Signature on the element.\n+\tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr, \"Signature element not present\"))\n }\n \n func TestXswPermutationFourIsRejected(t *testing.T) {\n@@ -1262,9 +1275,11 @@ func TestXswPermutationFourIsRejected(t *testing.T) {\n \treq := http.Request{PostForm: url.Values{}}\n \treq.PostForm.Set(\"SAMLResponse\", string(respStr))\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n-\t// Because this permutation contains an unsigned assertion as child of the response\n-\tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"either the Response or Assertion must be signed\"))\n+\n+\t// This permutation contains a signed assertion embedded within an unsigned assertion.\n+\t// I'm pretty sure this is just not allowed, so we properly decide that there are no\n+\t// signed assertions at all.\n+\tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr, \"Signature element not present\"))\n }\n \n func TestXswPermutationFiveIsRejected(t *testing.T) {\n@@ -1291,7 +1306,7 @@ func TestXswPermutationFiveIsRejected(t *testing.T) {\n \treq.PostForm.Set(\"SAMLResponse\", string(respStr))\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: Missing signature referencing the top-level element\"))\n+\t\t\"cannot validate signature on Assertion: Missing signature referencing the top-level element\"))\n }\n \n func TestXswPermutationSixIsRejected(t *testing.T) {\n@@ -1318,7 +1333,7 @@ func TestXswPermutationSixIsRejected(t *testing.T) {\n \treq.PostForm.Set(\"SAMLResponse\", string(respStr))\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: Missing signature referencing the top-level element\"))\n+\t\t\"cannot validate signature on Assertion: Missing signature referencing the top-level element\"))\n }\n \n func TestXswPermutationSevenIsRejected(t *testing.T) {\n@@ -1349,7 +1364,7 @@ func TestXswPermutationSevenIsRejected(t *testing.T) {\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n \t//It's the assertion signature that can't be verified. The error message is generic and always mentions Response\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: Signature could not be verified\"))\n+\t\t\"cannot validate signature on Assertion: Signature could not be verified\"))\n }\n \n func TestXswPermutationEightIsRejected(t *testing.T) {\n@@ -1380,7 +1395,7 @@ func TestXswPermutationEightIsRejected(t *testing.T) {\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n \t//It's the assertion signature that can't be verified. The error message is generic and always mentions Response\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: Signature could not be verified\"))\n+\t\t\"cannot validate signature on Assertion: Signature could not be verified\"))\n }\n \n func TestXswPermutationNineIsRejected(t *testing.T) {\n@@ -1411,7 +1426,7 @@ func TestXswPermutationNineIsRejected(t *testing.T) {\n \t_, err = s.ParseResponse(&req, []string{\"ONELOGIN_4fee3b046395c4e751011e97f8900b5273d56685\"})\n \t//It's the assertion signature that can't be verified. The error message is generic and always mentions Response\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: Missing signature referencing the top-level element\"))\n+\t\t\"cannot validate signature on Assertion: Missing signature referencing the top-level element\"))\n }\n \n func TestSPRealWorldKeyInfoHasRSAPublicKeyNotX509Cert(t *testing.T) {\n@@ -1749,7 +1764,7 @@ func TestParseBadXMLArtifactResponse(t *testing.T) {\n \n \tassertion, err = sp.ParseXMLArtifactResponse(samlResponse, possibleReqIDs, reqID)\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"cannot validate signature on Response: Cert is not valid at this time\"))\n+\t\t\"cannot validate signature on ArtifactResponse: Cert is not valid at this time\"))\n \tassert.Check(t, is.Nil(assertion))\n \tClock = dsig.NewFakeClockAt(TimeNow())\n \n@@ -1769,6 +1784,32 @@ func TestParseBadXMLArtifactResponse(t *testing.T) {\n \tsp.Key = mustParsePrivateKey(golden.Get(t, \"key_2017.pem\")).(*rsa.PrivateKey)\n \tassertion, err = sp.ParseXMLArtifactResponse(samlResponse, possibleReqIDs, reqID)\n \tassert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,\n-\t\t\"failed to decrypt response: certificate does not match provided key\"))\n+\t\t\"failed to decrypt EncryptedAssertion: certificate does not match provided key\"))\n \tassert.Check(t, is.Nil(assertion))\n }\n+\n+func TestMultipleAssertions(t *testing.T) {\n+\tidpMetadata := golden.Get(t, \"TestSPRealWorldKeyInfoHasRSAPublicKeyNotX509Cert_idp_metadata\")\n+\trespStr := golden.Get(t, \"TestSPMultipleAssertions\")\n+\tTimeNow = func() time.Time {\n+\t\trv, _ := time.Parse(\"Mon Jan 2 15:04:05 MST 2006\", \"Fri Apr 21 13:12:51 UTC 2017\")\n+\t\treturn rv\n+\t}\n+\tClock = dsig.NewFakeClockAt(TimeNow())\n+\ts := ServiceProvider{\n+\t\tKey:         mustParsePrivateKey(golden.Get(t, \"key_2017.pem\")).(*rsa.PrivateKey),\n+\t\tCertificate: mustParseCertificate(golden.Get(t, \"cert_2017.pem\")),\n+\t\tMetadataURL: mustParseURL(\"https://preview.docrocket-ross.test.octolabs.io/saml/metadata\"),\n+\t\tAcsURL:      mustParseURL(\"https://preview.docrocket-ross.test.octolabs.io/saml/acs\"),\n+\t\tIDPMetadata: &EntityDescriptor{},\n+\t}\n+\terr := xml.Unmarshal(idpMetadata, &s.IDPMetadata)\n+\tassert.Check(t, err)\n+\n+\treq := http.Request{PostForm: url.Values{}}\n+\treq.PostForm.Set(\"SAMLResponse\", base64.StdEncoding.EncodeToString(respStr))\n+\tprofile, err := s.ParseResponse(&req, []string{\"id-3992f74e652d89c3cf1efd6c7e472abaac9bc917\"})\n+\n+\tassert.Check(t, err)\n+\tassert.Check(t, profile.Subject.NameID.Value != \"admin@evil.com\")\n+}"
        },
        {
          "filename": "testdata/TestSPMultipleAssertions",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?><saml2p:Response xmlns:saml2p=\"urn:oasis:names:tc:SAML:2.0:protocol\" Destination=\"https://preview.docrocket-ross.test.octolabs.io/saml/acs\" ID=\"28338c8c-39ab-4b94-bcdc-46f68f99d962\" InResponseTo=\"id-3992f74e652d89c3cf1efd6c7e472abaac9bc917\" IssueInstant=\"2017-04-21T13:12:50.830Z\" Version=\"2.0\"><saml2:Issuer xmlns:saml2=\"urn:oasis:names:tc:SAML:2.0:assertion\">https://idp.secureworks.com/SAML2</saml2:Issuer>\n+<saml2p:Status><saml2p:StatusCode Value=\"urn:oasis:names:tc:SAML:2.0:status:Success\"/><saml2p:StatusMessage>Authentication success.</saml2p:StatusMessage></saml2p:Status><saml2:Assertion xmlns:saml2=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"e5afbcaa-be69-4b41-ac48-2f23538accdb\" IssueInstant=\"2017-04-21T13:12:50.830Z\" Version=\"2.0\"><saml2:Issuer>https://idp.secureworks.com/SAML2</saml2:Issuer><ds:Signature xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"><ds:SignedInfo><ds:CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/><ds:SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/><ds:Reference URI=\"#e5afbcaa-be69-4b41-ac48-2f23538accdb\"><ds:Transforms><ds:Transform Algorithm=\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"/><ds:Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"/></ds:Transforms><ds:DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/><ds:DigestValue>BMN0lUblP0gYGcw2PCyhwFZzkxY=</ds:DigestValue></ds:Reference></ds:SignedInfo><ds:SignatureValue>F/2aaOQ3J/S6ULUd+gAuIclVueHEC2UfmtO2eR2oYb/YXub9E22yZe7eQgj2wdhYOvacVXN28QJJJG+K3Njwvi6b7mqf+T8N1YwaJW1fYAm28ayg4dEOTjHnjbRMZ6L+3cZPmPcFyE+edhCHEMnTLSqSvBnSyc1cwGdO9PmfWmt6PzUwf2nr2P5577Yc1FEQ9OtTx7ugWN3iPmjtLeTcpZfIDQX9+gSsh0KT+t61uWaYz+PJhtKnZQFeyr3uIxBTxv4wQ90FnmE4PiDvMksin5CDMfiMwd7pn7rNbk4EVHiDgSMkY6P4h8eWQwiqglOrQSZZr4BJgCoUbcNfZCq/7A==</ds:SignatureValue><ds:KeyInfo><ds:KeyValue><ds:RSAKeyValue><ds:Modulus>zZlTNJ+QcTp2yGH1ECXO3ry4GHhcs1CW3I6GPiPvtO+P6lyWxYdQd2RK/Hk9Kap6qpm/qom0rTwb\n+FU2I67Y2JdQ3T5QBJjGHbGHU1uMxVWkhJluoa0Lpm381zNCJTZp8PetoB8dnIGua9y1aL75v04CG\n+TzJ14I9/sW+apTkWj7xVQXutvVKETdn4kAy+L33HpriZjQNlcuAbqQj6OWsN4tGkLvNFZT40jQzp\n+/8/tOQE6n2+zn3I8hUePwjPQROUmCeK86CkF0yVCPQ/vOTsC00Uaeu/SPOUu5ot+/75NPyE8w5Ry\n+DgefdDXhYNmeuQtwGtcu/FI66atQMNTDoChXJQ==</ds:Modulus><ds:Exponent>AQAB</ds:Exponent></ds:RSAKeyValue></ds:KeyValue></ds:KeyInfo></ds:Signature><saml2:Subject><saml2:NameID>rkinder@secureworks.com</saml2:NameID><saml2:SubjectConfirmation Method=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><saml2:SubjectConfirmationData InResponseTo=\"id-3992f74e652d89c3cf1efd6c7e472abaac9bc917\" NotBefore=\"2017-04-21T13:12:50.830Z\" NotOnOrAfter=\"2017-04-21T13:17:50.830Z\" Recipient=\"https://preview.docrocket-ross.test.octolabs.io/saml/acs\"/></saml2:SubjectConfirmation></saml2:Subject><saml2:Conditions NotBefore=\"2017-04-21T13:12:50.830Z\" NotOnOrAfter=\"2017-04-21T13:17:50.830Z\"><saml2:AudienceRestriction><saml2:Audience>https://preview.docrocket-ross.test.octolabs.io/saml/metadata</saml2:Audience></saml2:AudienceRestriction></saml2:Conditions><saml2:AuthnStatement AuthnInstant=\"2017-04-21T13:12:50.830Z\" SessionIndex=\"undefined\"><saml2:AuthnContext><saml2:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified</saml2:AuthnContextClassRef></saml2:AuthnContext></saml2:AuthnStatement></saml2:Assertion>\n+<saml2:Assertion xmlns:saml2=\"urn:oasis:names:tc:SAML:2.0:assertion\" ID=\"e5afbcaa-be69-4b41-ac48-2f23538accdb\" IssueInstant=\"2017-04-21T13:12:50.830Z\" Version=\"2.0\"><saml2:Issuer>https://idp.secureworks.com/SAML2</saml2:Issuer>\n+<saml2:Subject><saml2:NameID>admin@evil.com</saml2:NameID><saml2:SubjectConfirmation Method=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><saml2:SubjectConfirmationData InResponseTo=\"id-3992f74e652d89c3cf1efd6c7e472abaac9bc917\" NotBefore=\"2017-04-21T13:12:50.830Z\" NotOnOrAfter=\"2017-04-21T13:17:50.830Z\" Recipient=\"https://preview.docrocket-ross.test.octolabs.io/saml/acs\"/></saml2:SubjectConfirmation></saml2:Subject><saml2:Conditions NotBefore=\"2017-04-21T13:12:50.830Z\" NotOnOrAfter=\"2017-04-21T13:17:50.830Z\"><saml2:AudienceRestriction><saml2:Audience>https://preview.docrocket-ross.test.octolabs.io/saml/metadata</saml2:Audience></saml2:AudienceRestriction></saml2:Conditions><saml2:AuthnStatement AuthnInstant=\"2017-04-21T13:12:50.830Z\" SessionIndex=\"undefined\"><saml2:AuthnContext><saml2:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified</saml2:AuthnContextClassRef></saml2:AuthnContext></saml2:AuthnStatement></saml2:Assertion></saml2p:Response>"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bbccb7933d5f60512ebc6caec7120c604581983d",
            "date": "2024-07-20T11:07:57Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a32b643a25a46182499b1278293e265150056d89",
            "date": "2023-10-16T11:18:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "b2c7702ef01c1ff83ac08159afcd3c5a678c6d52",
            "date": "2023-10-14T14:42:23Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "adb3ff5ed70dc743bcef17ac52b993eef1dc7992",
            "date": "2023-10-14T14:26:29Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "5e8dc1f05e26c4cd518fd80643cdd7fdde04bb19",
            "date": "2023-10-14T14:25:58Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "The crewjam/saml go library prior to version 0.4.9 is vulnerable to an authentication bypass when processing SAML responses containing multiple Assertion elements. This issue has been corrected in version 0.4.9. There are no workarounds other than upgrading to a fixed version.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-11-28T15:15:10.460",
    "last_modified": "2024-11-21T07:24:03.190",
    "fix_date": "2022-11-28T13:48:29Z"
  },
  "references": [
    {
      "url": "http://packetstormsecurity.com/files/170356/crewjam-saml-Signature-Bypass.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/crewjam/saml/commit/aee3fb1edeeaf1088fcb458727e0fd863d277f8b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/crewjam/saml/security/advisories/GHSA-j2jp-wvqg-wc2g",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://packetstormsecurity.com/files/170356/crewjam-saml-Signature-Bypass.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/crewjam/saml/commit/aee3fb1edeeaf1088fcb458727e0fd863d277f8b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/crewjam/saml/security/advisories/GHSA-j2jp-wvqg-wc2g",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.171161",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "saml",
    "owner": "crewjam",
    "created_at": "2015-11-30T04:42:00Z",
    "updated_at": "2025-01-24T05:45:16Z",
    "pushed_at": "2024-08-16T15:28:18Z",
    "size": 1062,
    "stars": 983,
    "forks": 442,
    "open_issues": 96,
    "watchers": 983,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 448628
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-2-clause"
    },
    "collected_at": "2025-01-26T08:32:08.967431"
  }
}