{
  "cve_id": "CVE-2022-41933",
  "github_data": {
    "repository": "xwiki/xwiki-platform",
    "fix_commit": "443e8398b75a1295067d74afb5898370782d863a",
    "related_commits": [
      "443e8398b75a1295067d74afb5898370782d863a",
      "443e8398b75a1295067d74afb5898370782d863a"
    ],
    "patch_url": "https://github.com/xwiki/xwiki-platform/commit/443e8398b75a1295067d74afb5898370782d863a.patch",
    "fix_commit_details": {
      "sha": "443e8398b75a1295067d74afb5898370782d863a",
      "commit_date": "2022-07-01T13:47:31Z",
      "author": {
        "login": "surli",
        "type": "User",
        "stats": {
          "total_commits": 1932,
          "average_weekly_commits": 2.0251572327044025,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 283
        }
      },
      "commit_message": {
        "title": "XWIKI-19869: Improve user property storage",
        "length": 162,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 1056,
        "additions": 1044,
        "deletions": 12
      },
      "files": [
        {
          "filename": "xwiki-platform-core/xwiki-platform-mail/xwiki-platform-mail-send/xwiki-platform-mail-send-default/src/main/java/org/xwiki/mail/internal/factory/text/TextMimeMessageFactory.java",
          "status": "added",
          "additions": 109,
          "deletions": 0,
          "patch": "@@ -0,0 +1,109 @@\n+/*\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.xwiki.mail.internal.factory.text;\n+\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+import javax.inject.Singleton;\n+import javax.mail.Address;\n+import javax.mail.Message;\n+import javax.mail.MessagingException;\n+import javax.mail.Multipart;\n+import javax.mail.internet.MimeMessage;\n+import javax.mail.internet.MimeMultipart;\n+\n+import org.xwiki.component.annotation.Component;\n+import org.xwiki.mail.ExtendedMimeMessage;\n+import org.xwiki.mail.MimeBodyPartFactory;\n+import org.xwiki.mail.MimeMessageFactory;\n+import org.xwiki.mail.internal.factory.AbstractMimeMessageFactory;\n+import org.xwiki.properties.ConverterManager;\n+\n+/**\n+ * A basic {@link MimeMessageFactory} which is taken a {@link String} as source which represents the content of the\n+ * message.\n+ *\n+ * @version $Id$\n+ * @since 14.6RC1\n+ * @since 14.4.3\n+ * @since 13.10.8\n+ */\n+@Component\n+@Singleton\n+@Named(\"text\")\n+public class TextMimeMessageFactory extends AbstractMimeMessageFactory<MimeMessage>\n+{\n+    @Inject\n+    private ConverterManager converterManager;\n+\n+    @Inject\n+    private MimeBodyPartFactory<String> mimeBodyPartFactory;\n+\n+    @Override\n+    public MimeMessage createMessage(Object source, Map<String, Object> parameters) throws MessagingException\n+    {\n+        // This whole code has been inspired by the implementation of\n+        // org.xwiki.mail.internal.factory.template.AbstractTemplateMimeMessageFactory\n+\n+        // Note: We don't create a Session here ATM since it's not required. The returned MimeMessage will be\n+        // given a valid Session when it's deserialized from the mail content store for sending.\n+        ExtendedMimeMessage message = new ExtendedMimeMessage();\n+\n+        // Handle optional \"from\" address.\n+        Address from = this.converterManager.convert(Address.class, parameters.get(\"from\"));\n+        if (from != null) {\n+            message.setFrom(from);\n+        }\n+\n+        // Handle optional \"to\", \"cc\" and \"bcc\" addresses.\n+        setRecipient(message, Message.RecipientType.TO, parameters.get(\"to\"));\n+        setRecipient(message, Message.RecipientType.CC, parameters.get(\"cc\"));\n+        setRecipient(message, Message.RecipientType.BCC, parameters.get(\"bcc\"));\n+\n+        // Handle optional \"type\" parameter to set the mail type\n+        // Set the Message type if passed in parameters\n+        String type = (String) parameters.get(\"type\");\n+        if (type != null) {\n+            message.setType(type);\n+        }\n+\n+        // Handle the subject. Get it from the parameters.\n+        String subject = (String) parameters.get(\"subject\");\n+        message.setSubject(subject);\n+\n+        // Add a default body part taken from the template.\n+        Multipart multipart = new MimeMultipart(\"mixed\");\n+        multipart.addBodyPart(this.mimeBodyPartFactory.create((String) source, parameters));\n+        message.setContent(multipart);\n+\n+        return message;\n+    }\n+\n+    private void setRecipient(MimeMessage message, Message.RecipientType type, Object value)\n+        throws MessagingException\n+    {\n+        Address[] addresses = this.converterManager.convert(Address[].class, value);\n+        if (addresses != null) {\n+            message.setRecipients(type, addresses);\n+        }\n+    }\n+}"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-mail/xwiki-platform-mail-send/xwiki-platform-mail-send-default/src/main/resources/META-INF/components.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -33,3 +33,4 @@ org.xwiki.mail.internal.factory.template.DefaultAttachmentConverter\n org.xwiki.mail.internal.factory.files.SerializedFilesMimeMessageFactory\n org.xwiki.mail.internal.factory.group.GroupMimeMessageFactory\n org.xwiki.mail.internal.factory.usersandgroups.UsersAndGroupsMimeMessageFactory\n+org.xwiki.mail.internal.factory.text.TextMimeMessageFactory"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-mail/xwiki-platform-mail-send/xwiki-platform-mail-send-default/src/test/java/org/xwiki/mail/internal/factory/text/TextMimeMessageFactoryTest.java",
          "status": "added",
          "additions": 98,
          "deletions": 0,
          "patch": "@@ -0,0 +1,98 @@\n+/*\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.xwiki.mail.internal.factory.text;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.mail.Address;\n+import javax.mail.Message;\n+import javax.mail.MessagingException;\n+import javax.mail.Multipart;\n+import javax.mail.internet.InternetAddress;\n+import javax.mail.internet.MimeBodyPart;\n+import javax.mail.internet.MimeMessage;\n+import javax.mail.internet.MimeMultipart;\n+\n+import org.junit.jupiter.api.Test;\n+import org.xwiki.mail.ExtendedMimeMessage;\n+import org.xwiki.mail.MimeBodyPartFactory;\n+import org.xwiki.properties.ConverterManager;\n+import org.xwiki.test.junit5.mockito.ComponentTest;\n+import org.xwiki.test.junit5.mockito.InjectMockComponents;\n+import org.xwiki.test.junit5.mockito.MockComponent;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests for {@link TextMimeMessageFactory}.\n+ *\n+ * @version $Id$\n+ */\n+@ComponentTest\n+class TextMimeMessageFactoryTest\n+{\n+    @InjectMockComponents\n+    private TextMimeMessageFactory textMimeMessageFactory;\n+\n+    @MockComponent\n+    private ConverterManager converterManager;\n+\n+    @MockComponent\n+    private MimeBodyPartFactory<String> mimeBodyPartFactory;\n+\n+    @Test\n+    void createMessage() throws MessagingException, IOException\n+    {\n+        String source = \"Some mail content\";\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(\"to\", \"toto@xwiki.com\");\n+        parameters.put(\"from\", \"admin@xwiki.com\");\n+        parameters.put(\"type\", \"text\");\n+        parameters.put(\"subject\", \"important email\");\n+\n+        Address from = new InternetAddress(\"admin@xwiki.com\");\n+        Address to = new InternetAddress(\"toto@xwiki.com\");\n+\n+        when(this.converterManager.convert(Address[].class, \"toto@xwiki.com\")).thenReturn(new Address[] {to});\n+        when(this.converterManager.convert(Address.class, \"admin@xwiki.com\")).thenReturn(from);\n+\n+        MimeBodyPart bodyPart = mock(MimeBodyPart.class);\n+        when(this.mimeBodyPartFactory.create(source, parameters)).thenReturn(bodyPart);\n+\n+        ExtendedMimeMessage expectedMessage = new ExtendedMimeMessage();\n+        expectedMessage.setFrom(from);\n+        expectedMessage.setRecipient(Message.RecipientType.TO, to);\n+        expectedMessage.setSubject(\"important email\");\n+        expectedMessage.setType(\"text\");\n+        Multipart multipart = new MimeMultipart(\"mixed\");\n+        multipart.addBodyPart(bodyPart);\n+        expectedMessage.setContent(multipart);\n+\n+        MimeMessage message = this.textMimeMessageFactory.createMessage(source, parameters);\n+        assertEquals(to, message.getRecipients(Message.RecipientType.TO)[0]);\n+        assertEquals(from, message.getFrom()[0]);\n+        assertEquals(\"important email\", message.getSubject());\n+        assertEquals(bodyPart, ((Multipart) message.getContent()).getBodyPart(0));\n+    }\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/store/migration/hibernate/R140600000XWIKI19869DataMigration.java",
          "status": "added",
          "additions": 319,
          "deletions": 0,
          "patch": "@@ -0,0 +1,319 @@\n+/*\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package com.xpn.xwiki.store.migration.hibernate;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+import javax.inject.Provider;\n+import javax.inject.Singleton;\n+\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n+import org.slf4j.Logger;\n+import org.xwiki.component.annotation.Component;\n+import org.xwiki.configuration.ConfigurationSource;\n+import org.xwiki.environment.Environment;\n+import org.xwiki.model.reference.DocumentReference;\n+import org.xwiki.model.reference.DocumentReferenceResolver;\n+import org.xwiki.model.reference.EntityReferenceSerializer;\n+import org.xwiki.query.Query;\n+import org.xwiki.query.QueryException;\n+import org.xwiki.query.QueryFilter;\n+import org.xwiki.query.QueryManager;\n+import org.xwiki.user.UserReferenceSerializer;\n+\n+import com.xpn.xwiki.XWikiContext;\n+import com.xpn.xwiki.XWikiException;\n+import com.xpn.xwiki.doc.DocumentRevisionProvider;\n+import com.xpn.xwiki.doc.XWikiDocument;\n+import com.xpn.xwiki.doc.XWikiDocumentArchive;\n+import com.xpn.xwiki.doc.rcs.XWikiRCSNodeInfo;\n+import com.xpn.xwiki.internal.mandatory.XWikiUsersDocumentInitializer;\n+import com.xpn.xwiki.objects.BaseObject;\n+import com.xpn.xwiki.store.migration.DataMigrationException;\n+import com.xpn.xwiki.store.migration.XWikiDBVersion;\n+\n+/**\n+ * Migration responsible of ensuring the password fields are properly hashed.\n+ *\n+ * @version $Id$\n+ * @since 14.6RC1\n+ * @since 14.4.3\n+ * @since 13.10.8\n+ */\n+@Component\n+@Singleton\n+@Named(R140600000XWIKI19869DataMigration.HINT)\n+public class R140600000XWIKI19869DataMigration extends AbstractHibernateDataMigration\n+{\n+    /**\n+     * The hint for this component.\n+     */\n+    public static final String HINT = \"140600000XWIKI19869\";\n+\n+    private static final String FILENAME = HINT + \"DataMigration.txt\";\n+\n+    private static final String XWQL_QUERY = \"select distinct doc.fullName from Document doc, \"\n+        + \"doc.object(XWiki.XWikiUsers) objUser where objUser.password not like 'hash:%' and objUser.password <> '' \"\n+        + \"order by doc.fullName\";\n+\n+    private static final String PASSWORD_FIELD = \"password\";\n+\n+    private static final int BATCH_SIZE = 100;\n+\n+    @Inject\n+    private QueryManager queryManager;\n+\n+    @Inject\n+    private DocumentReferenceResolver<String> documentReferenceResolver;\n+\n+    @Inject\n+    private DocumentRevisionProvider documentRevisionProvider;\n+\n+    @Inject\n+    private Provider<UserReferenceSerializer<String>> userReferenceSerializerProvider;\n+\n+    @Inject\n+    @Named(\"count\")\n+    private Provider<QueryFilter> countFilterProvider;\n+\n+    @Inject\n+    private EntityReferenceSerializer<String> entityReferenceSerializer;\n+\n+    @Inject\n+    private Environment environment;\n+\n+    @Inject\n+    @Named(\"xwikiproperties\")\n+    private Provider<ConfigurationSource> propertiesConfigurationProvider;\n+\n+    @Inject\n+    private Logger logger;\n+\n+    @Override\n+    public String getDescription()\n+    {\n+        return \"Migrate wrongly stored passwords information.\";\n+    }\n+\n+    @Override\n+    public XWikiDBVersion getVersion()\n+    {\n+        return new XWikiDBVersion(140600000);\n+    }\n+\n+    @Override\n+    public boolean shouldExecute(XWikiDBVersion startupVersion)\n+    {\n+        // The bug we discovered only impact the main wiki users thanks to another bug (XWIKI-19591),\n+        // so we can safely ignore subwikis\n+        return getXWikiContext().isMainWiki();\n+    }\n+\n+    @Override\n+    protected void hibernateMigrate() throws DataMigrationException, XWikiException\n+    {\n+        // 1. Find users with a plain text password and then for each user:\n+        // 2. Set an empty password OR recompute a hash of the password and store it (this choice is made through\n+        //    the xwiki.properties security.migration.R140600000XWIKI19869.resetPassword)\n+        // 3. If the reset password feature is enabled force a reset, else log a warning in the console\n+        // 4. Rewrite the history of the user page to replace plain text passwords info with new password hash from it\n+        //    (we don't wipe out to avoid problem with rollback)\n+        boolean resetPassword = this.propertiesConfigurationProvider.get()\n+            .getProperty(\"security.migration.R140600000XWIKI19869.resetPassword\", true);\n+        boolean requireMigrationFile = this.propertiesConfigurationProvider.get()\n+            .getProperty(\"security.migration.R140600000XWIKI19869.requireMigrationFile\", true);\n+        long numberOfUsersToMigrate = this.getNumberOfUsersToMigrate();\n+        this.logger.info(\"The migration will need to process [{}] user documents\", numberOfUsersToMigrate);\n+        File migrationFile = new File(this.environment.getPermanentDirectory(), FILENAME);\n+        Optional<BufferedWriter> bufferedWriterOptional = Optional.empty();\n+        try {\n+            bufferedWriterOptional = Optional.of(Files.newBufferedWriter(migrationFile.toPath(),\n+                StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.APPEND));\n+        } catch (IOException e) {\n+            if (requireMigrationFile) {\n+                throw new DataMigrationException(\"Error while trying to create the migration file for sending users \"\n+                    + \"instructions to reset their password. If you cannot resolve the problem, you can skip this check\"\n+                    + \" by setting the property 'security.migration.R140600000XWIKI19869.requireMigrationFile' \"\n+                    + \"in xwiki.properties.\", e);\n+            } else {\n+                logger.warn(\"Error while trying to create the migration file to force user to reset their password. \"\n+                        + \"The migration will then output in the logs the list of users so that the admin can reach \"\n+                        + \"them directly. The cause of the error for creating the file was [{}]\",\n+                    ExceptionUtils.getRootCauseMessage(e));\n+            }\n+        }\n+        try {\n+            List<DocumentReference> users;\n+            do {\n+                users = this.getUsers();\n+\n+                if (!users.isEmpty()) {\n+                    this.logger.info(\"Start processing [{}] users over [{}]\", users.size(), numberOfUsersToMigrate);\n+\n+                    for (DocumentReference userReference : users) {\n+                        this.handleUser(userReference, resetPassword, bufferedWriterOptional);\n+                    }\n+                    bufferedWriterOptional.ifPresent(bufferedWriter -> {\n+                        try {\n+                            bufferedWriter.flush();\n+                        } catch (IOException e) {\n+                            logger.warn(\"Error while flushing the buffer to write data migration file: [{}]\",\n+                                ExceptionUtils.getRootCauseMessage(e));\n+                        }\n+                    });\n+                }\n+            } while (!users.isEmpty());\n+        } finally {\n+            bufferedWriterOptional.ifPresent(bufferedWriter -> {\n+                try {\n+                    bufferedWriter.flush();\n+                    bufferedWriter.close();\n+                } catch (IOException e) {\n+                    logger.warn(\"Error while flushing and closing the buffer to write data migration file: [{}]\",\n+                        ExceptionUtils.getRootCauseMessage(e));\n+                }\n+            });\n+        }\n+    }\n+\n+    private long getNumberOfUsersToMigrate()\n+    {\n+        long result = -1;\n+        try {\n+            Query query = this.queryManager.createQuery(XWQL_QUERY, Query.XWQL)\n+                .addFilter(this.countFilterProvider.get());\n+            List<Long> countValue = query.execute();\n+            result = countValue.get(0);\n+        } catch (QueryException e) {\n+            // We don't throw an exception because it might be only a problem with the count\n+            // and this is only used for log purpose.\n+            // In case of real issue on the query, it will throw an exception when actually getting the users\n+            this.logger.warn(\"Error while trying to count the number of users\", e);\n+        }\n+        return result;\n+    }\n+\n+    private List<DocumentReference> getUsers() throws DataMigrationException\n+    {\n+        try {\n+            // Note: we don't need to set an offset, since we call back the query after having processed the users\n+            // so we shouldn't retrieve back the users already processed.\n+            Query query = this.queryManager\n+                .createQuery(XWQL_QUERY, Query.XWQL)\n+                .setLimit(BATCH_SIZE);\n+            List<String> usersList = query.execute();\n+\n+            return usersList.stream().map(this.documentReferenceResolver::resolve).collect(Collectors.toList());\n+        } catch (QueryException e) {\n+            throw new DataMigrationException(\"Error while querying the list of users\", e);\n+        }\n+    }\n+\n+    private void handleUser(DocumentReference userDocReference, boolean resetPassword,\n+        Optional<BufferedWriter> bufferedWriterOptional) throws XWikiException\n+    {\n+        XWikiContext context = getXWikiContext();\n+        XWikiDocument userDoc = context.getWiki().getDocument(userDocReference, context);\n+\n+        if (fixPasswordHash(userDoc, true, resetPassword)) {\n+            String serializedUserRef = this.entityReferenceSerializer.serialize(userDocReference);\n+            this.handleHistory(userDoc);\n+            context.getWiki().saveDocument(userDoc, context);\n+            if (bufferedWriterOptional.isPresent()) {\n+                try {\n+                    bufferedWriterOptional.get()\n+                        .write(serializedUserRef + \"\\n\");\n+                } catch (IOException e) {\n+                    logger.warn(\"Error when writing in migration file (root cause was [{}]. Please reach \"\n+                            + \"individually [{}] for resetting their password.\",\n+                        ExceptionUtils.getRootCauseMessage(e), serializedUserRef);\n+                }\n+            } else {\n+                logger.warn(\"Please reach individually [{}] for resetting their password.\", serializedUserRef);\n+            }\n+        }\n+    }\n+\n+    private void handleHistory(XWikiDocument userDoc) throws XWikiException\n+    {\n+        XWikiContext context = getXWikiContext();\n+        XWikiDocumentArchive documentArchive = userDoc.getDocumentArchive(context);\n+        Collection<XWikiRCSNodeInfo> archiveNodes = documentArchive.getNodes();\n+\n+        for (XWikiRCSNodeInfo node : new ArrayList<>(archiveNodes)) {\n+            XWikiDocument revision = this.documentRevisionProvider.getRevision(userDoc, node.getVersion().toString());\n+            if (fixPasswordHash(revision, false, false)) {\n+                String author = userReferenceSerializerProvider.get()\n+                    .serialize(revision.getAuthors().getOriginalMetadataAuthor());\n+                documentArchive.updateArchive(revision, author, revision.getDate(), revision.getComment(),\n+                    revision.getRCSVersion(), context);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the password value using the appropriate API.\n+     * The first boolean flag is used to know if the reset is called for the last version of the doc or for one of the\n+     * history version. The second flag is used to define if the password should be just reset, or if the hash of the\n+     * defined password should be computed.\n+     *\n+     * @param userDoc the document to update\n+     * @param isMain is {@code true} if the reset is called for the last version of the doc or for one of the\n+     *               history version.\n+     * @param resetPassword {@code true} if the password should be just reset, or {@code false} if the hash of the\n+     *                      defined password should be computed.\n+     */\n+    private boolean fixPasswordHash(XWikiDocument userDoc, boolean isMain, boolean resetPassword)\n+    {\n+        boolean result = false;\n+        XWikiContext context = getXWikiContext();\n+        BaseObject userObj = userDoc.getXObject(XWikiUsersDocumentInitializer.XWIKI_USERS_DOCUMENT_REFERENCE);\n+        if (userObj != null) {\n+            String password = userObj.getStringValue(PASSWORD_FIELD);\n+            if (!password.startsWith(\"hash:\")) {\n+                if (isMain && resetPassword) {\n+                    userObj.set(PASSWORD_FIELD, \"\", context);\n+                } else {\n+                    // The set method should automatically compute the hash\n+                    userObj.set(PASSWORD_FIELD, password, context);\n+                }\n+                result = true;\n+            } else if (isMain) {\n+                this.logger.warn(\"User document was wrongly retrieved [{}] it won't be modified.\",\n+                    userDoc.getDocumentReference());\n+            }\n+        } else if (isMain) {\n+            this.logger.warn(\"Null user object for document [{}] this should never happen.\",\n+                userDoc.getDocumentReference());\n+        }\n+        return result;\n+    }\n+}"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-oldcore/src/main/resources/META-INF/components.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -215,6 +215,7 @@ com.xpn.xwiki.store.migration.hibernate.R130200000XWIKI17200DataMigration\n com.xpn.xwiki.store.migration.hibernate.R140000000XWIKI19125DataMigration\n com.xpn.xwiki.store.migration.hibernate.R140200010XWIKI19207DataMigration\n com.xpn.xwiki.store.migration.hibernate.R140200000XWIKI19352DataMigration\n+com.xpn.xwiki.store.migration.hibernate.R140600000XWIKI19869DataMigration\n com.xpn.xwiki.store.VoidAttachmentVersioningStore\n com.xpn.xwiki.store.XWikiHibernateStore\n com.xpn.xwiki.store.XWikiHibernateVersioningStore"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/main/java/org/xwiki/security/authentication/internal/DefaultResetPasswordManager.java",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -319,7 +319,9 @@ public void resetPassword(UserReference userReference, String newPassword)\n                 XWikiDocument userDocument = context.getWiki().getDocument(reference, context);\n                 userDocument.removeXObjects(RESET_PASSWORD_REQUEST_CLASS_REFERENCE);\n                 BaseObject userXObject = userDocument.getXObject(USER_CLASS_REFERENCE);\n-                userXObject.setStringValue(\"password\", newPassword);\n+\n+                // /!\\ We cannot use BaseCollection#setStringValue as it's storing value in plain text.\n+                userXObject.set(\"password\", newPassword, context);\n \n                 String saveComment = this.localizationManager.getTranslationPlain(\n                     \"xe.admin.passwordReset.step2.versionComment.passwordReset\");"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/main/java/org/xwiki/security/authentication/internal/R140600000XWIKI19869DataMigrationListener.java",
          "status": "added",
          "additions": 205,
          "deletions": 0,
          "patch": "@@ -0,0 +1,205 @@\n+/*\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.xwiki.security.authentication.internal;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+import javax.inject.Provider;\n+import javax.inject.Singleton;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.xwiki.bridge.event.ApplicationReadyEvent;\n+import org.xwiki.component.annotation.Component;\n+import org.xwiki.environment.Environment;\n+import org.xwiki.localization.ContextualLocalizationManager;\n+import org.xwiki.observation.AbstractEventListener;\n+import org.xwiki.observation.event.Event;\n+import org.xwiki.security.authentication.ResetPasswordException;\n+import org.xwiki.security.authentication.ResetPasswordManager;\n+import org.xwiki.security.authentication.ResetPasswordRequestResponse;\n+import org.xwiki.user.UserProperties;\n+import org.xwiki.user.UserPropertiesResolver;\n+import org.xwiki.user.UserReference;\n+import org.xwiki.user.UserReferenceResolver;\n+\n+/**\n+ * Listener in charge of checking if a data migration file is there and ask users to reset their passwords.\n+ *\n+ * @version $Id$\n+ * @since 14.6RC1\n+ * @since 14.4.3\n+ * @since 13.10.8\n+ */\n+@Component\n+@Singleton\n+@Named(R140600000XWIKI19869DataMigrationListener.NAME)\n+public class R140600000XWIKI19869DataMigrationListener extends AbstractEventListener\n+{\n+    static final String NAME = \"R140600000XWIKI19869DataMigrationListener\";\n+    private static final List<Event> EVENT_LIST = Collections.singletonList(new ApplicationReadyEvent());\n+\n+    private static final String FILENAME = \"140600000XWIKI19869DataMigration.txt\";\n+    private static final String MAIL_TEMPLATE = \"140600000XWIKI19869-mail.txt\";\n+    private static final String SUBJECT_MARKER = \"subject:\";\n+\n+    @Inject\n+    private Provider<ResetPasswordManager> resetPasswordManagerProvider;\n+\n+    @Inject\n+    private Provider<ResetPasswordMailSender> resetPasswordMailSenderProvider;\n+\n+    @Inject\n+    private Provider<UserReferenceResolver<String>> userReferenceResolverProvider;\n+\n+    @Inject\n+    private Provider<ContextualLocalizationManager> contextualLocalizationManagerProvider;\n+\n+    @Inject\n+    private Provider<UserPropertiesResolver> userPropertiesResolver;\n+\n+    @Inject\n+    private Environment environment;\n+\n+    @Inject\n+    private Logger logger;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public R140600000XWIKI19869DataMigrationListener()\n+    {\n+        super(NAME, EVENT_LIST);\n+    }\n+\n+    @Override\n+    public void onEvent(Event event, Object source, Object data)\n+    {\n+        File migrationFile = new File(this.environment.getPermanentDirectory(), FILENAME);\n+        if (Files.exists(migrationFile.toPath())) {\n+            handleMigrationFile(migrationFile);\n+        }\n+    }\n+\n+    private void handleMigrationFile(File migrationFile)\n+    {\n+        try {\n+            List<String> serializedReferences = Files.readAllLines(migrationFile.toPath());\n+\n+            // We use a set in case there was same reference multiple times in the file (could happen if the migration\n+            // was restarted)\n+            Set<String> exploredReference = new HashSet<>();\n+\n+            Pair<String, String> mailData = this.getMailData();\n+            for (String serializedReference : serializedReferences) {\n+                if (!exploredReference.contains(serializedReference)) {\n+                    UserReference userReference = this.userReferenceResolverProvider.get().resolve(serializedReference);\n+                    UserProperties userProperties = this.userPropertiesResolver.get().resolve(userReference);\n+                    if (userProperties.getEmail() != null) {\n+                        this.handleResetPassword(userReference, mailData);\n+                    } else {\n+                        this.logger.warn(\"Reset email cannot be sent for user [{}] as no email address is provided.\",\n+                            userReference);\n+                    }\n+\n+                    exploredReference.add(serializedReference);\n+                }\n+            }\n+\n+            Files.delete(migrationFile.toPath());\n+        } catch (IOException e) {\n+            this.logger.warn(\"Error while trying to read the data migration file to ask user to reset their password\"\n+                + \" the root cause error was [{}]\", ExceptionUtils.getRootCauseMessage(e));\n+        }\n+    }\n+\n+    private void handleResetPassword(UserReference userReference, Pair<String, String> mailData)\n+    {\n+        ResetPasswordManager resetPasswordManager = this.resetPasswordManagerProvider.get();\n+        try {\n+            ResetPasswordRequestResponse resetPasswordRequestResponse =\n+                resetPasswordManager.requestResetPassword(userReference);\n+            if (!StringUtils.isEmpty(resetPasswordRequestResponse.getVerificationCode())) {\n+\n+                this.resetPasswordMailSenderProvider.get().sendAuthenticationSecurityEmail(userReference,\n+                    mailData.getLeft(), mailData.getRight());\n+                resetPasswordManager.sendResetPasswordEmailRequest(resetPasswordRequestResponse);\n+            }\n+        } catch (ResetPasswordException e) {\n+            this.logger.warn(\"Error when trying to force user [{}] to reset their password: [{}]\",\n+                userReference,\n+                ExceptionUtils.getRootCauseMessage(e));\n+            this.logger.debug(\"Full stack trace for the reset password request: \", e);\n+        }\n+    }\n+\n+    private Pair<String, String> getMailData()\n+    {\n+        File mailTemplate = new File(this.environment.getPermanentDirectory(), MAIL_TEMPLATE);\n+        Pair<String, String> result = this.getMailDataFallback();\n+        if (Files.exists(mailTemplate.toPath())) {\n+            try {\n+                List<String> mailLines = Files.readAllLines(mailTemplate.toPath());\n+                result = getMailData(mailLines, result);\n+            } catch (IOException e) {\n+                this.logger.warn(\"Error while trying to read the security email template, \"\n+                    + \"fallback on default mail subject and content. Root cause error: [{}]\",\n+                    ExceptionUtils.getRootCauseMessage(e));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private Pair<String, String> getMailData(List<String> mailLines, Pair<String, String> fallback)\n+    {\n+        Pair<String, String> result = fallback;\n+        if (!mailLines.isEmpty()) {\n+            String subject;\n+            if (mailLines.get(0).toLowerCase().startsWith(SUBJECT_MARKER)) {\n+                subject = mailLines.remove(0).substring(SUBJECT_MARKER.length());\n+            } else {\n+                subject = fallback.getLeft();\n+            }\n+\n+            String content = String.join(\"\\n\", mailLines);\n+            result = Pair.of(subject, content);\n+        }\n+        return result;\n+    }\n+\n+    private Pair<String, String> getMailDataFallback()\n+    {\n+        ContextualLocalizationManager contextualLocalizationManager = this.contextualLocalizationManagerProvider.get();\n+        String translationPrefix = \"security.authentication.migration1400600000XWIKI19869.email.\";\n+        String subject = contextualLocalizationManager.getTranslationPlain(translationPrefix + \"subject\");\n+        String content = contextualLocalizationManager.getTranslationPlain(translationPrefix + \"content\");\n+        return Pair.of(subject, content);\n+    }\n+}"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/main/java/org/xwiki/security/authentication/internal/ResetPasswordMailSender.java",
          "status": "modified",
          "additions": 61,
          "deletions": 10,
          "patch": "@@ -35,7 +35,6 @@\n \n import org.apache.commons.lang3.StringUtils;\n import org.xwiki.component.annotation.Component;\n-import org.xwiki.component.manager.ComponentManager;\n import org.xwiki.localization.ContextualLocalizationManager;\n import org.xwiki.mail.MailListener;\n import org.xwiki.mail.MailSender;\n@@ -48,6 +47,9 @@\n import org.xwiki.model.reference.EntityReference;\n import org.xwiki.model.reference.LocalDocumentReference;\n import org.xwiki.security.authentication.ResetPasswordException;\n+import org.xwiki.user.UserProperties;\n+import org.xwiki.user.UserPropertiesResolver;\n+import org.xwiki.user.UserReference;\n \n import com.xpn.xwiki.XWikiContext;\n \n@@ -64,6 +66,10 @@ public class ResetPasswordMailSender\n     private static final LocalDocumentReference RESET_PASSWORD_MAIL_TEMPLATE_REFERENCE =\n         new LocalDocumentReference(\"XWiki\", \"ResetPasswordMailContent\");\n \n+    private static final String NO_REPLY = \"no-reply@\";\n+    private static final String FROM = \"from\";\n+    private static final String TO = \"to\";\n+\n     @Inject\n     private MailSenderConfiguration mailSenderConfiguration;\n \n@@ -75,11 +81,11 @@ public class ResetPasswordMailSender\n     private MimeMessageFactory<MimeMessage> mimeMessageFactory;\n \n     @Inject\n-    private MailSender mailSender;\n+    @Named(\"text\")\n+    private MimeMessageFactory<MimeMessage> textMimeMessageFactory;\n \n     @Inject\n-    @Named(\"context\")\n-    private ComponentManager componentManager;\n+    private MailSender mailSender;\n \n     @Inject\n     private SessionFactory sessionFactory;\n@@ -94,6 +100,9 @@ public class ResetPasswordMailSender\n     @Named(\"database\")\n     private Provider<MailListener> mailListenerProvider;\n \n+    @Inject\n+    private Provider<UserPropertiesResolver> userPropertiesResolverProvider;\n+\n     /**\n      * Send the reset password information by email.\n      *\n@@ -108,13 +117,13 @@ public void sendResetPasswordEmail(String username, InternetAddress email, URL r\n         XWikiContext context = this.contextProvider.get();\n         String fromAddress = this.mailSenderConfiguration.getFromAddress();\n         if (StringUtils.isEmpty(fromAddress)) {\n-            fromAddress = \"no-reply@\" + context.getRequest().getServerName();\n+            fromAddress = NO_REPLY + context.getRequest().getServerName();\n         }\n \n         Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"from\", fromAddress);\n-        parameters.put(\"to\", email);\n-        parameters.put(\"language\", context.getLocale());\n+        parameters.put(FROM, fromAddress);\n+        parameters.put(TO, email);\n+        parameters.put(\"language\", this.contextProvider.get().getLocale());\n         parameters.put(\"type\", \"Reset Password\");\n         Map<String, String> velocityVariables = new HashMap<>();\n         velocityVariables.put(\"userName\", username);\n@@ -124,14 +133,56 @@ public void sendResetPasswordEmail(String username, InternetAddress email, URL r\n         String localizedError =\n             this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.emailFailed\");\n \n-        MimeMessage message;\n         try {\n-            message =\n+            MimeMessage message =\n                 this.mimeMessageFactory.createMessage(\n                     this.documentReferenceResolver.resolve(RESET_PASSWORD_MAIL_TEMPLATE_REFERENCE), parameters);\n+            this.sendMessage(message, localizedError);\n         } catch (MessagingException e) {\n             throw new ResetPasswordException(localizedError, e);\n         }\n+    }\n+\n+    /**\n+     * Allows to send a text email for security purpose.\n+     *\n+     * @param userReference the user to whom to send the email.\n+     * @param subject the localized subject of the email\n+     * @param mailContent the localized content of the email\n+     * @throws ResetPasswordException in case of problem for preparing or sending the email\n+     * @since 14.6RC1\n+     * @since 14.4.3\n+     * @since 13.10.8\n+     */\n+    public void sendAuthenticationSecurityEmail(UserReference userReference, String subject, String mailContent)\n+        throws ResetPasswordException\n+    {\n+        XWikiContext context = this.contextProvider.get();\n+        String fromAddress = this.mailSenderConfiguration.getFromAddress();\n+        if (StringUtils.isEmpty(fromAddress)) {\n+            fromAddress = NO_REPLY + context.getRequest().getServerName();\n+        }\n+        UserProperties userProperties = this.userPropertiesResolverProvider.get().resolve(userReference);\n+        InternetAddress email = userProperties.getEmail();\n+\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(FROM, fromAddress);\n+        parameters.put(TO, email);\n+        parameters.put(\"subject\", subject);\n+\n+        String localizedError =\n+            this.localizationManager.getTranslationPlain(\"security.authentication.security.email.error\");\n+\n+        try {\n+            MimeMessage message = this.textMimeMessageFactory.createMessage(mailContent, parameters);\n+            this.sendMessage(message, localizedError);\n+        } catch (MessagingException e) {\n+            throw new ResetPasswordException(localizedError, e);\n+        }\n+    }\n+\n+    private void sendMessage(MimeMessage message, String localizedError) throws ResetPasswordException\n+    {\n         MailListener mailListener = this.mailListenerProvider.get();\n         this.mailSender.sendAsynchronously(Collections.singleton(message),\n             this.sessionFactory.create(Collections.emptyMap()),"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/main/resources/ApplicationResources.properties",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -20,3 +20,8 @@\n security.authentication.strategy.captcha.errorMessage=Please fill the captcha form to login.\n security.authentication.rest.blockedError=Your account may be blocked after too many attempts to login. Please go to the xwiki login page to get more information.\n security.authentication.strategy.disableAccount.errorMessage=This account has been disabled. Please ask the administrator to enable it back.\n+\n+security.authentication.security.email.error=Error when sending a security email\n+\n+security.authentication.migration1400600000XWIKI19869.email.subject=Important security issue\n+security.authentication.migration1400600000XWIKI19869.email.content=Dear user, \\n\\ndue to a bug your password was stored in plain text in our wiki. We cannot exclude that your plain text password was exposed in an attack. Therefore, you will receive a second email to choose a new password. \\nPlease contact the administrator in case of problem or for further questions.\n\\ No newline at end of file"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/main/resources/META-INF/components.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -9,3 +9,4 @@ org.xwiki.security.authentication.internal.resource.AuthenticationResourceRefere\n org.xwiki.security.authentication.internal.resource.AuthenticationResourceReferenceSerializer\n org.xwiki.security.authentication.internal.DefaultResetPasswordManager\n org.xwiki.security.authentication.internal.ResetPasswordMailSender\n+org.xwiki.security.authentication.internal.R140600000XWIKI19869DataMigrationListener"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/test/java/org/xwiki/security/authentication/internal/DefaultResetPasswordManagerTest.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -430,7 +430,7 @@ void resetPassword() throws Exception\n         String newPassword = \"mypassword\";\n         this.resetPasswordManager.resetPassword(this.userReference, newPassword);\n         verify(this.userDocument).removeXObjects(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE);\n-        verify(xObject).setStringValue(\"password\", newPassword);\n+        verify(xObject).set(\"password\", newPassword, context);\n     }\n \n     @Test"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/test/java/org/xwiki/security/authentication/internal/R140600000XWIKI19869DataMigrationListenerTest.java",
          "status": "added",
          "additions": 174,
          "deletions": 0,
          "patch": "@@ -0,0 +1,174 @@\n+/*\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.xwiki.security.authentication.internal;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+\n+import javax.inject.Inject;\n+import javax.inject.Provider;\n+import javax.mail.internet.AddressException;\n+import javax.mail.internet.InternetAddress;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.xwiki.environment.Environment;\n+import org.xwiki.localization.ContextualLocalizationManager;\n+import org.xwiki.security.authentication.ResetPasswordManager;\n+import org.xwiki.security.authentication.ResetPasswordRequestResponse;\n+import org.xwiki.test.LogLevel;\n+import org.xwiki.test.junit5.LogCaptureExtension;\n+import org.xwiki.test.junit5.XWikiTempDir;\n+import org.xwiki.test.junit5.mockito.ComponentTest;\n+import org.xwiki.test.junit5.mockito.InjectMockComponents;\n+import org.xwiki.test.junit5.mockito.MockComponent;\n+import org.xwiki.user.UserProperties;\n+import org.xwiki.user.UserPropertiesResolver;\n+import org.xwiki.user.UserReference;\n+import org.xwiki.user.UserReferenceResolver;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests for {@link R140600000XWIKI19869DataMigrationListener}.\n+ *\n+ * @version $Id$\n+ */\n+@ComponentTest\n+class R140600000XWIKI19869DataMigrationListenerTest\n+{\n+    @InjectMockComponents\n+    private R140600000XWIKI19869DataMigrationListener listener;\n+\n+    @MockComponent\n+    private ResetPasswordManager resetPasswordManager;\n+\n+    @MockComponent\n+    private ResetPasswordMailSender resetPasswordMailSender;\n+\n+    @MockComponent\n+    private UserReferenceResolver<String> userReferenceResolver;\n+\n+    @MockComponent\n+    private ContextualLocalizationManager contextualLocalizationManager;\n+\n+    @MockComponent\n+    private UserPropertiesResolver userPropertiesResolver;\n+\n+    @MockComponent\n+    private Environment environment;\n+\n+    @RegisterExtension\n+    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);\n+\n+    @Test\n+    void onEvent(@XWikiTempDir File tmpDir) throws Exception\n+    {\n+        when(this.environment.getPermanentDirectory()).thenReturn(tmpDir);\n+        File migrationFile = new File(tmpDir, \"140600000XWIKI19869DataMigration.txt\");\n+\n+        this.listener.onEvent(null, null, null);\n+        verifyNoInteractions(this.resetPasswordMailSender);\n+        verifyNoInteractions(this.resetPasswordManager);\n+        verifyNoInteractions(this.userReferenceResolver);\n+\n+        Files.writeString(migrationFile.toPath(), \"XWiki.Foo\\nXWiki.Bar\\nXWiki.Buz\", StandardOpenOption.CREATE_NEW);\n+\n+        String mailFallbackSubject = \"Subject fallback\";\n+        String mailFallbackContent = \"Mail content\";\n+        when(this.contextualLocalizationManager\n+            .getTranslationPlain(\"security.authentication.migration1400600000XWIKI19869.email.subject\"))\n+            .thenReturn(mailFallbackSubject);\n+        when(this.contextualLocalizationManager\n+            .getTranslationPlain(\"security.authentication.migration1400600000XWIKI19869.email.content\"))\n+            .thenReturn(mailFallbackContent);\n+\n+        UserReference fooRef = mock(UserReference.class, \"foo\");\n+        UserReference barRef = mock(UserReference.class, \"bar\");\n+        UserReference buzRef = mock(UserReference.class, \"buz\");\n+\n+        when(this.userReferenceResolver.resolve(\"XWiki.Foo\")).thenReturn(fooRef);\n+        when(this.userReferenceResolver.resolve(\"XWiki.Bar\")).thenReturn(barRef);\n+        when(this.userReferenceResolver.resolve(\"XWiki.Buz\")).thenReturn(buzRef);\n+\n+        UserProperties fooProp = mock(UserProperties.class, \"fooProp\");\n+        UserProperties barProp = mock(UserProperties.class, \"barProp\");\n+        UserProperties buzProp = mock(UserProperties.class, \"buzProp\");\n+\n+        when(this.userPropertiesResolver.resolve(fooRef)).thenReturn(fooProp);\n+        when(this.userPropertiesResolver.resolve(barRef)).thenReturn(barProp);\n+        when(this.userPropertiesResolver.resolve(buzRef)).thenReturn(buzProp);\n+\n+        when(fooProp.getEmail()).thenReturn(new InternetAddress(\"foo@xwiki.com\"));\n+        when(buzProp.getEmail()).thenReturn(new InternetAddress(\"buz@xwiki.com\"));\n+\n+        ResetPasswordRequestResponse responseFoo = mock(ResetPasswordRequestResponse.class);\n+        ResetPasswordRequestResponse responseBuz = mock(ResetPasswordRequestResponse.class);\n+        when(resetPasswordManager.requestResetPassword(fooRef)).thenReturn(responseFoo);\n+        when(resetPasswordManager.requestResetPassword(buzRef)).thenReturn(responseBuz);\n+\n+        when(responseFoo.getVerificationCode()).thenReturn(\"some code\");\n+        when(responseBuz.getVerificationCode()).thenReturn(\"some code\");\n+\n+        this.listener.onEvent(null, null, null);\n+        verify(this.resetPasswordMailSender)\n+            .sendAuthenticationSecurityEmail(fooRef, mailFallbackSubject, mailFallbackContent);\n+        verify(this.resetPasswordMailSender)\n+            .sendAuthenticationSecurityEmail(buzRef, mailFallbackSubject, mailFallbackContent);\n+        verify(this.resetPasswordMailSender, never()).sendAuthenticationSecurityEmail(eq(barRef), any(), any());\n+\n+        verify(this.resetPasswordManager).sendResetPasswordEmailRequest(responseFoo);\n+        verify(this.resetPasswordManager).sendResetPasswordEmailRequest(responseBuz);\n+\n+        assertEquals(1, this.logCapture.size());\n+        assertEquals(\"Reset email cannot be sent for user [bar] as no email address is provided.\",\n+            this.logCapture.getMessage(0));\n+\n+        // The file should have been deleted just after the first call\n+        this.listener.onEvent(null, null, null);\n+\n+        Files.writeString(migrationFile.toPath(), \"XWiki.Foo\", StandardOpenOption.CREATE);\n+        File mailTemplate = new File(tmpDir, \"140600000XWIKI19869-mail.txt\");\n+        String mailSubject = \"test\";\n+        String mailContent = \"Some mail content\";\n+        Files.writeString(mailTemplate.toPath(),\n+            String.format(\"Subject:%s\\n%s\", mailSubject, mailContent), StandardOpenOption.CREATE_NEW);\n+\n+        this.listener.onEvent(null, null, null);\n+\n+        verify(this.resetPasswordMailSender)\n+            .sendAuthenticationSecurityEmail(fooRef, mailSubject, mailContent);\n+\n+        verify(this.resetPasswordManager, times(2)).sendResetPasswordEmailRequest(responseFoo);\n+\n+        // This one should not have been called twice\n+        verify(this.resetPasswordManager).sendResetPasswordEmailRequest(responseBuz);\n+    }\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authentication/xwiki-platform-security-authentication-default/src/test/java/org/xwiki/security/authentication/internal/ResetPasswordMailSenderTest.java",
          "status": "modified",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -32,6 +32,7 @@\n import javax.inject.Provider;\n import javax.mail.MessagingException;\n import javax.mail.Session;\n+import javax.mail.internet.AddressException;\n import javax.mail.internet.InternetAddress;\n import javax.mail.internet.MimeMessage;\n \n@@ -56,6 +57,9 @@\n import org.xwiki.test.junit5.mockito.InjectMockComponents;\n import org.xwiki.test.junit5.mockito.MockComponent;\n import org.xwiki.test.mockito.MockitoComponentManager;\n+import org.xwiki.user.UserProperties;\n+import org.xwiki.user.UserPropertiesResolver;\n+import org.xwiki.user.UserReference;\n \n import com.xpn.xwiki.XWikiContext;\n \n@@ -107,6 +111,13 @@ class ResetPasswordMailSenderTest\n     @MockComponent\n     private Provider<XWikiContext> contextProvider;\n \n+    @MockComponent\n+    private UserPropertiesResolver userPropertiesResolver;\n+\n+    @MockComponent\n+    @Named(\"text\")\n+    private MimeMessageFactory<MimeMessage> textMimeMessageFactory;\n+\n     private XWikiContext xWikiContext;\n \n     private DocumentReference templateDocumentReference;\n@@ -241,6 +252,41 @@ void sendResetPasswordEmailErrorWhenSending() throws Exception\n         verify(this.mailSender).sendAsynchronously(Collections.singleton(message), session, this.mailListener);\n         verify(mailStatusResult).waitTillProcessed(30L);\n         assertEquals(\"Cannot send this email - Some sending error\", resetPasswordException.getMessage());\n+    }\n+\n+    @Test\n+    void sendAuthenticationSecurityEmail() throws MessagingException, ResetPasswordException\n+    {\n+        UserReference userReference = mock(UserReference.class);\n+        String content = \"some content\";\n+        String subject = \"some subject\";\n+\n+        String fromAdress = \"root@xwiki.com\";\n+        when(this.mailSenderConfiguration.getFromAddress()).thenReturn(fromAdress);\n+\n+        UserProperties userProp = mock(UserProperties.class);\n+        when(this.userPropertiesResolver.resolve(userReference)).thenReturn(userProp);\n+\n+        InternetAddress userAddress = new InternetAddress(\"foo@xwiki.com\");\n+        when(userProp.getEmail()).thenReturn(userAddress);\n+\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(\"from\", fromAdress);\n+        parameters.put(\"to\", userAddress);\n+        parameters.put(\"subject\", subject);\n+\n+        MimeMessage message = mock(MimeMessage.class);\n+        when(this.textMimeMessageFactory.createMessage(content, parameters)).thenReturn(message);\n+        Session session = Session.getInstance(new Properties());\n+        when(this.sessionFactory.create(Collections.emptyMap())).thenReturn(session);\n+        MailStatusResult mailStatusResult = mock(MailStatusResult.class);\n+        when(this.mailListener.getMailStatusResult()).thenReturn(mailStatusResult);\n+\n+        this.resetPasswordMailSender.sendAuthenticationSecurityEmail(userReference, subject, content);\n+\n+        verify(this.mailSender).sendAsynchronously(Collections.singleton(message), session, this.mailListener);\n+        verify(mailStatusResult).waitTillProcessed(30L);\n+        verify(mailStatusResult).getAllErrors();\n \n     }\n }"
        },
        {
          "filename": "xwiki-platform-tools/xwiki-platform-tool-configuration-resources/src/main/resources/xwiki.properties.vm",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -766,6 +766,26 @@ distribution.automaticStartOnWiki=$xwikiPropertiesAutomaticStartOnWiki\n #-# The default is:\n # security.authentication.resetPasswordTokenLifetime = 0\n \n+#-# [Since 14.6RC1]\n+#-# [Since 14.4.3]\n+#-# [Since 13.10.8]\n+#-# This option is only used when performing a migration from a wiki before the versions mentioning above.\n+#-# This parameter defines if as part of the migration R140600000XWIKI19869 the passwords of impacted user should be\n+#-# reset or not. It's advised to keep this value as true, now for some usecases advertised administrators might want\n+#-# their users to keep their passwords nevertheless, then enable the configuration and set it to false before the\n+#-# migration is executed.\n+# security.migration.R140600000XWIKI19869.resetPassword = true\n+\n+#-# [Since 14.6RC1]\n+#-# [Since 14.4.3]\n+#-# [Since 13.10.8]\n+#-# This option is only used when performing a migration from a wiki before the versions mentioning above.\n+#-# This parameter defines if the migration R140600000XWIKI19869 should be stopped if the migration file used to\n+#-# send notifications to users cannot be created or written. The default is to consider this file is required to avoid\n+#-# for the admin to have to notify all users. Now it's possible to skip this, in which case the admin will have to\n+#-# inform the users manually in case of problems.\n+# security.migration.R140600000XWIKI19869.requireMigrationFile = true\n+\n #-------------------------------------------------------------------------------------\n # URL\n #-------------------------------------------------------------------------------------"
        }
      ],
      "file_patterns": {
        "security_files": 8,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 10,
        "max_directory_depth": 13
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "88e3e7d23cbd3e6ed059dbcd6532f94016d42678",
            "date": "2025-01-13T16:58:06Z",
            "author_login": "Sereza7"
          },
          {
            "sha": "9b506ab2bed52744b52699ea05cde15986d42abb",
            "date": "2025-01-13T16:36:24Z",
            "author_login": "mflorea"
          },
          {
            "sha": "d53d6e347b97ac20f60e21fb2bae381f4aaf10f4",
            "date": "2025-01-13T13:25:24Z",
            "author_login": "tmortagne"
          },
          {
            "sha": "d85bd8f9c67c412e0cfb45fb4695b8d4e759bab6",
            "date": "2025-01-13T12:03:22Z",
            "author_login": "tmortagne"
          },
          {
            "sha": "6f210dabc99167cf9f020a048c88325eca34ceea",
            "date": "2025-01-13T08:54:32Z",
            "author_login": "tmortagne"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-312",
    "description": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. When the `reset a forgotten password` feature of XWiki was used, the password was then stored in plain text in database. This only concerns XWiki 13.1RC1 and newer versions. Note that it only concerns the reset password feature available from the \"Forgot your password\" link in the login view: the features allowing a user to change their password, or for an admin to change a user password are not impacted. This vulnerability is particularly dangerous in combination with other vulnerabilities allowing to perform data leak of personal data from users, such as GHSA-599v-w48h-rjrm. Note that this vulnerability only concerns the users of the main wiki: in case of farms, the users registered on subwiki are not impacted thanks to a bug we discovered when investigating this. The problem has been patched in version 14.6RC1, 14.4.3 and 13.10.8. The patch involves a migration of the impacted users as well as the history of the page, to ensure no password remains in plain text in the database. This migration also involves to inform the users about the possible disclosure of their passwords: by default, two emails are automatically sent to the impacted users. A first email to inform about the possibility that their password have been leaked, and a second email using the reset password feature to ask them to set a new password. It's also possible for administrators to set some properties for the migration: it's possible to decide if the user password should be reset (default) or if the passwords should be kept but only hashed. Note that in the first option, the users won't be able to login anymore until they set a new password if they were impacted. Note that in both options, mails will be sent to users to inform them and encourage them to change their passwords.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-11-23T21:15:10.813",
    "last_modified": "2024-11-21T07:24:06.053",
    "fix_date": "2022-07-01T13:47:31Z"
  },
  "references": [
    {
      "url": "https://github.com/xwiki/xwiki-platform/commit/443e8398b75a1295067d74afb5898370782d863a#diff-f8a8f8ba80dfc55f044e2e60b521ce379176430ca6921b0f87b79cf682531f79L322",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-599v-w48h-rjrm",
      "source": "security-advisories@github.com",
      "tags": [
        "Not Applicable"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-q2hm-2h45-v5g3",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jira.xwiki.org/browse/XWIKI-19869",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://jira.xwiki.org/browse/XWIKI-19945",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/commit/443e8398b75a1295067d74afb5898370782d863a#diff-f8a8f8ba80dfc55f044e2e60b521ce379176430ca6921b0f87b79cf682531f79L322",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-599v-w48h-rjrm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Not Applicable"
      ]
    },
    {
      "url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-q2hm-2h45-v5g3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://jira.xwiki.org/browse/XWIKI-19869",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://jira.xwiki.org/browse/XWIKI-19945",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.162221",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "xwiki-platform",
    "owner": "xwiki",
    "created_at": "2011-03-10T13:26:41Z",
    "updated_at": "2025-01-13T16:58:10Z",
    "pushed_at": "2025-01-14T12:32:03Z",
    "size": 561595,
    "stars": 1030,
    "forks": 554,
    "open_issues": 136,
    "watchers": 1030,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 34276921,
      "JavaScript": 2392892,
      "HTML": 388086,
      "Less": 318945,
      "AspectJ": 280487,
      "Vue": 222987,
      "CSS": 115460,
      "XSLT": 109285,
      "Clean": 44054,
      "Shell": 32569,
      "Batchfile": 14604,
      "Python": 5046,
      "Groovy": 3012,
      "AMPL": 1296
    },
    "commit_activity": {
      "total_commits_last_year": 1723,
      "avg_commits_per_week": 33.13461538461539,
      "days_active_last_year": 263
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T12:58:58.685838"
  }
}