{
  "cve_id": "CVE-2022-41953",
  "github_data": {
    "repository": "git-for-windows/git",
    "fix_commit": "7360767e8dfc1895a932324079f7d45d7791d39f",
    "related_commits": [
      "7360767e8dfc1895a932324079f7d45d7791d39f",
      "7360767e8dfc1895a932324079f7d45d7791d39f"
    ],
    "patch_url": "https://github.com/git-for-windows/git/commit/7360767e8dfc1895a932324079f7d45d7791d39f.patch",
    "fix_commit_details": {
      "sha": "7360767e8dfc1895a932324079f7d45d7791d39f",
      "commit_date": "2023-01-17T18:47:49Z",
      "author": {
        "login": "derrickstolee",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge v2.39.1.windows.1 (#4219)",
        "length": 337,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 713,
        "additions": 586,
        "deletions": 127
      },
      "files": [
        {
          "filename": "Documentation/RelNotes/2.30.7.txt",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+Git v2.30.7 Release Notes\n+=========================\n+\n+This release addresses the security issues CVE-2022-41903 and\n+CVE-2022-23521.\n+\n+\n+Fixes since v2.30.6\n+-------------------\n+\n+ * CVE-2022-41903:\n+\n+   git log has the ability to display commits using an arbitrary\n+   format with its --format specifiers. This functionality is also\n+   exposed to git archive via the export-subst gitattribute.\n+\n+   When processing the padding operators (e.g., %<(, %<|(, %>(,\n+   %>>(, or %><( ), an integer overflow can occur in\n+   pretty.c::format_and_pad_commit() where a size_t is improperly\n+   stored as an int, and then added as an offset to a subsequent\n+   memcpy() call.\n+\n+   This overflow can be triggered directly by a user running a\n+   command which invokes the commit formatting machinery (e.g., git\n+   log --format=...). It may also be triggered indirectly through\n+   git archive via the export-subst mechanism, which expands format\n+   specifiers inside of files within the repository during a git\n+   archive.\n+\n+   This integer overflow can result in arbitrary heap writes, which\n+   may result in remote code execution.\n+\n+* CVE-2022-23521:\n+\n+    gitattributes are a mechanism to allow defining attributes for\n+    paths. These attributes can be defined by adding a `.gitattributes`\n+    file to the repository, which contains a set of file patterns and\n+    the attributes that should be set for paths matching this pattern.\n+\n+    When parsing gitattributes, multiple integer overflows can occur\n+    when there is a huge number of path patterns, a huge number of\n+    attributes for a single pattern, or when the declared attribute\n+    names are huge.\n+\n+    These overflows can be triggered via a crafted `.gitattributes` file\n+    that may be part of the commit history. Git silently splits lines\n+    longer than 2KB when parsing gitattributes from a file, but not when\n+    parsing them from the index. Consequentially, the failure mode\n+    depends on whether the file exists in the working tree, the index or\n+    both.\n+\n+    This integer overflow can result in arbitrary heap reads and writes,\n+    which may result in remote code execution.\n+\n+Credit for finding CVE-2022-41903 goes to Joern Schneeweisz of GitLab.\n+An initial fix was authored by Markus Vervier of X41 D-Sec. Credit for\n+finding CVE-2022-23521 goes to Markus Vervier and Eric Sesterhenn of X41\n+D-Sec. This work was sponsored by OSTIF.\n+\n+The proposed fixes have been polished and extended to cover additional\n+findings by Patrick Steinhardt of GitLab, with help from others on the\n+Git security mailing list.\n+\n+Patrick Steinhardt (21):\n+      attr: fix overflow when upserting attribute with overly long name\n+      attr: fix out-of-bounds read with huge attribute names\n+      attr: fix integer overflow when parsing huge attribute names\n+      attr: fix out-of-bounds write when parsing huge number of attributes\n+      attr: fix out-of-bounds read with unreasonable amount of patterns\n+      attr: fix integer overflow with more than INT_MAX macros\n+      attr: harden allocation against integer overflows\n+      attr: fix silently splitting up lines longer than 2048 bytes\n+      attr: ignore attribute lines exceeding 2048 bytes\n+      attr: ignore overly large gitattributes files\n+      pretty: fix out-of-bounds write caused by integer overflow\n+      pretty: fix out-of-bounds read when left-flushing with stealing\n+      pretty: fix out-of-bounds read when parsing invalid padding format\n+      pretty: fix adding linefeed when placeholder is not expanded\n+      pretty: fix integer overflow in wrapping format\n+      utf8: fix truncated string lengths in `utf8_strnwidth()`\n+      utf8: fix returning negative string width\n+      utf8: fix overflow when returning string width\n+      utf8: fix checking for glyph width in `strbuf_utf8_replace()`\n+      utf8: refactor `strbuf_utf8_replace` to not rely on preallocated buffer\n+      pretty: restrict input lengths for padding and wrapping formats\n+"
        },
        {
          "filename": "Documentation/RelNotes/2.31.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.31.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.32.5.txt",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+Git v2.32.5 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details.\n+\n+In addition, included are additional code for \"git fsck\" to check\n+for questionable .gitattributes files."
        },
        {
          "filename": "Documentation/RelNotes/2.33.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.33.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.34.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.34.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.35.6.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.35.6 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.36.4.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.36.4 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.37.5.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.37.5 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.38.3.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.38.3 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/RelNotes/2.39.1.txt",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Git v2.39.1 Release Notes\n+=========================\n+\n+This release merges the security fix that appears in v2.30.7; see\n+the release notes for that version for details."
        },
        {
          "filename": "Documentation/fsck-msgids.txt",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -46,6 +46,18 @@\n `fullPathname`::\n \t(WARN) A path contains the full path starting with \"/\".\n \n+`gitattributesBlob`::\n+\t(ERROR) A non-blob found at `.gitattributes`.\n+\n+`gitattributesLarge`::\n+\t(ERROR) The `.gitattributes` blob is too large.\n+\n+`gitattributesLineLength`::\n+\t(ERROR) The `.gitattributes` blob contains too long lines.\n+\n+`gitattributesMissing`::\n+\t(ERROR) Unable to read `.gitattributes` blob.\n+\n `gitattributesSymlink`::\n \t(INFO) `.gitattributes` is a symlink.\n "
        },
        {
          "filename": "GIT-VERSION-GEN",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,7 +1,7 @@\n #!/bin/sh\n \n GVF=GIT-VERSION-FILE\n-DEF_VER=v2.39.0\n+DEF_VER=v2.39.1\n \n LF='\n '"
        },
        {
          "filename": "RelNotes",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-Documentation/RelNotes/2.39.0.txt\n\\ No newline at end of file\n+Documentation/RelNotes/2.39.1.txt\n\\ No newline at end of file"
        },
        {
          "filename": "attr.c",
          "status": "modified",
          "additions": 56,
          "deletions": 35,
          "patch": "@@ -24,7 +24,7 @@ static const char git_attr__unknown[] = \"(builtin)unknown\";\n #define ATTR__UNKNOWN git_attr__unknown\n \n struct git_attr {\n-\tint attr_nr; /* unique attribute number */\n+\tunsigned int attr_nr; /* unique attribute number */\n \tchar name[FLEX_ARRAY]; /* attribute name */\n };\n \n@@ -206,7 +206,7 @@ static void report_invalid_attr(const char *name, size_t len,\n  * dictionary.  If no entry is found, create a new attribute and store it in\n  * the dictionary.\n  */\n-static const struct git_attr *git_attr_internal(const char *name, int namelen)\n+static const struct git_attr *git_attr_internal(const char *name, size_t namelen)\n {\n \tstruct git_attr *a;\n \n@@ -222,8 +222,8 @@ static const struct git_attr *git_attr_internal(const char *name, int namelen)\n \t\ta->attr_nr = hashmap_get_size(&g_attr_hashmap.map);\n \n \t\tattr_hashmap_add(&g_attr_hashmap, a->name, namelen, a);\n-\t\tassert(a->attr_nr ==\n-\t\t       (hashmap_get_size(&g_attr_hashmap.map) - 1));\n+\t\tif (a->attr_nr != hashmap_get_size(&g_attr_hashmap.map) - 1)\n+\t\t\tdie(_(\"unable to add additional attribute\"));\n \t}\n \n \thashmap_unlock(&g_attr_hashmap);\n@@ -268,7 +268,7 @@ struct match_attr {\n \t\tconst struct git_attr *attr;\n \t} u;\n \tchar is_macro;\n-\tunsigned num_attr;\n+\tsize_t num_attr;\n \tstruct attr_state state[FLEX_ARRAY];\n };\n \n@@ -289,7 +289,7 @@ static const char *parse_attr(const char *src, int lineno, const char *cp,\n \t\t\t      struct attr_state *e)\n {\n \tconst char *ep, *equals;\n-\tint len;\n+\tsize_t len;\n \n \tep = cp + strcspn(cp, blank);\n \tequals = strchr(cp, '=');\n@@ -333,8 +333,7 @@ static const char *parse_attr(const char *src, int lineno, const char *cp,\n static struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\t\t\t  int lineno, unsigned flags)\n {\n-\tint namelen;\n-\tint num_attr, i;\n+\tsize_t namelen, num_attr, i;\n \tconst char *cp, *name, *states;\n \tstruct match_attr *res = NULL;\n \tint is_macro;\n@@ -345,6 +344,11 @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\treturn NULL;\n \tname = cp;\n \n+\tif (strlen(line) >= ATTR_MAX_LINE_LENGTH) {\n+\t\twarning(_(\"ignoring overly long attributes line %d\"), lineno);\n+\t\treturn NULL;\n+\t}\n+\n \tif (*cp == '\"' && !unquote_c_style(&pattern, name, &states)) {\n \t\tname = pattern.buf;\n \t\tnamelen = pattern.len;\n@@ -381,10 +385,9 @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\tgoto fail_return;\n \t}\n \n-\tres = xcalloc(1,\n-\t\t      sizeof(*res) +\n-\t\t      sizeof(struct attr_state) * num_attr +\n-\t\t      (is_macro ? 0 : namelen + 1));\n+\tres = xcalloc(1, st_add3(sizeof(*res),\n+\t\t\t\t st_mult(sizeof(struct attr_state), num_attr),\n+\t\t\t\t is_macro ? 0 : namelen + 1));\n \tif (is_macro) {\n \t\tres->u.attr = git_attr_internal(name, namelen);\n \t} else {\n@@ -447,11 +450,12 @@ struct attr_stack {\n \n static void attr_stack_free(struct attr_stack *e)\n {\n-\tint i;\n+\tunsigned i;\n \tfree(e->origin);\n \tfor (i = 0; i < e->num_matches; i++) {\n \t\tstruct match_attr *a = e->attrs[i];\n-\t\tint j;\n+\t\tsize_t j;\n+\n \t\tfor (j = 0; j < a->num_attr; j++) {\n \t\t\tconst char *setto = a->state[j].setto;\n \t\t\tif (setto == ATTR__TRUE ||\n@@ -660,8 +664,8 @@ static void handle_attr_line(struct attr_stack *res,\n \ta = parse_attr_line(line, src, lineno, flags);\n \tif (!a)\n \t\treturn;\n-\tALLOC_GROW(res->attrs, res->num_matches + 1, res->alloc);\n-\tres->attrs[res->num_matches++] = a;\n+\tALLOC_GROW_BY(res->attrs, res->num_matches, 1, res->alloc);\n+\tres->attrs[res->num_matches - 1] = a;\n }\n \n static struct attr_stack *read_attr_from_array(const char **list)\n@@ -701,11 +705,12 @@ void git_attr_set_direction(enum git_attr_direction new_direction)\n \n static struct attr_stack *read_attr_from_file(const char *path, unsigned flags)\n {\n+\tstruct strbuf buf = STRBUF_INIT;\n \tint fd;\n \tFILE *fp;\n \tstruct attr_stack *res;\n-\tchar buf[2048];\n \tint lineno = 0;\n+\tstruct stat st;\n \n \tif (flags & READ_ATTR_NOFOLLOW)\n \t\tfd = open_nofollow(path, O_RDONLY);\n@@ -717,15 +722,26 @@ static struct attr_stack *read_attr_from_file(const char *path, unsigned flags)\n \t\treturn NULL;\n \t}\n \tfp = xfdopen(fd, \"r\");\n+\tif (fstat(fd, &st)) {\n+\t\twarning_errno(_(\"cannot fstat gitattributes file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n+\tif (st.st_size >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res, 1);\n-\twhile (fgets(buf, sizeof(buf), fp)) {\n-\t\tchar *bufp = buf;\n-\t\tif (!lineno)\n-\t\t\tskip_utf8_bom(&bufp, strlen(bufp));\n-\t\thandle_attr_line(res, bufp, path, ++lineno, flags);\n+\twhile (strbuf_getline(&buf, fp) != EOF) {\n+\t\tif (!lineno && starts_with(buf.buf, utf8_bom))\n+\t\t\tstrbuf_remove(&buf, 0, strlen(utf8_bom));\n+\t\thandle_attr_line(res, buf.buf, path, ++lineno, flags);\n \t}\n+\n \tfclose(fp);\n+\tstrbuf_release(&buf);\n \treturn res;\n }\n \n@@ -736,6 +752,7 @@ static struct attr_stack *read_attr_from_index(struct index_state *istate,\n \tstruct attr_stack *res;\n \tchar *buf, *sp;\n \tint lineno = 0;\n+\tunsigned long size;\n \n \tif (!istate)\n \t\treturn NULL;\n@@ -754,9 +771,13 @@ static struct attr_stack *read_attr_from_index(struct index_state *istate,\n \tif (!path_in_cone_mode_sparse_checkout(path, istate))\n \t\treturn NULL;\n \n-\tbuf = read_blob_data_from_index(istate, path, NULL);\n+\tbuf = read_blob_data_from_index(istate, path, &size);\n \tif (!buf)\n \t\treturn NULL;\n+\tif (size >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes blob '%s'\"), path);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res, 1);\n \tfor (sp = buf; *sp; ) {\n@@ -999,12 +1020,12 @@ static int macroexpand_one(struct all_attrs_item *all_attrs, int nr, int rem);\n static int fill_one(struct all_attrs_item *all_attrs,\n \t\t    const struct match_attr *a, int rem)\n {\n-\tint i;\n+\tsize_t i;\n \n-\tfor (i = a->num_attr - 1; rem > 0 && i >= 0; i--) {\n-\t\tconst struct git_attr *attr = a->state[i].attr;\n+\tfor (i = a->num_attr; rem > 0 && i > 0; i--) {\n+\t\tconst struct git_attr *attr = a->state[i - 1].attr;\n \t\tconst char **n = &(all_attrs[attr->attr_nr].value);\n-\t\tconst char *v = a->state[i].setto;\n+\t\tconst char *v = a->state[i - 1].setto;\n \n \t\tif (*n == ATTR__UNKNOWN) {\n \t\t\t*n = v;\n@@ -1020,11 +1041,11 @@ static int fill(const char *path, int pathlen, int basename_offset,\n \t\tstruct all_attrs_item *all_attrs, int rem)\n {\n \tfor (; rem > 0 && stack; stack = stack->prev) {\n-\t\tint i;\n+\t\tunsigned i;\n \t\tconst char *base = stack->origin ? stack->origin : \"\";\n \n-\t\tfor (i = stack->num_matches - 1; 0 < rem && 0 <= i; i--) {\n-\t\t\tconst struct match_attr *a = stack->attrs[i];\n+\t\tfor (i = stack->num_matches; 0 < rem && 0 < i; i--) {\n+\t\t\tconst struct match_attr *a = stack->attrs[i - 1];\n \t\t\tif (a->is_macro)\n \t\t\t\tcontinue;\n \t\t\tif (path_matches(path, pathlen, basename_offset,\n@@ -1055,11 +1076,11 @@ static void determine_macros(struct all_attrs_item *all_attrs,\n \t\t\t     const struct attr_stack *stack)\n {\n \tfor (; stack; stack = stack->prev) {\n-\t\tint i;\n-\t\tfor (i = stack->num_matches - 1; i >= 0; i--) {\n-\t\t\tconst struct match_attr *ma = stack->attrs[i];\n+\t\tunsigned i;\n+\t\tfor (i = stack->num_matches; i > 0; i--) {\n+\t\t\tconst struct match_attr *ma = stack->attrs[i - 1];\n \t\t\tif (ma->is_macro) {\n-\t\t\t\tint n = ma->u.attr->attr_nr;\n+\t\t\t\tunsigned int n = ma->u.attr->attr_nr;\n \t\t\t\tif (!all_attrs[n].macro) {\n \t\t\t\t\tall_attrs[n].macro = ma;\n \t\t\t\t}\n@@ -1111,7 +1132,7 @@ void git_check_attr(struct index_state *istate,\n \tcollect_some_attrs(istate, path, check);\n \n \tfor (i = 0; i < check->nr; i++) {\n-\t\tsize_t n = check->items[i].attr->attr_nr;\n+\t\tunsigned int n = check->items[i].attr->attr_nr;\n \t\tconst char *value = check->all_attrs[n].value;\n \t\tif (value == ATTR__UNKNOWN)\n \t\t\tvalue = ATTR__UNSET;"
        },
        {
          "filename": "attr.h",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -107,6 +107,18 @@\n  * - Free the `attr_check` struct by calling `attr_check_free()`.\n  */\n \n+/**\n+ * The maximum line length for a gitattributes file. If the line exceeds this\n+ * length we will ignore it.\n+ */\n+#define ATTR_MAX_LINE_LENGTH 2048\n+\n+ /**\n+  * The maximum size of the giattributes file. If the file exceeds this size we\n+  * will ignore it.\n+  */\n+#define ATTR_MAX_FILE_SIZE (100 * 1024 * 1024)\n+\n struct index_state;\n \n /**"
        },
        {
          "filename": "column.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -23,7 +23,7 @@ struct column_data {\n /* return length of 's' in letters, ANSI escapes stripped */\n static int item_length(const char *s)\n {\n-\treturn utf8_strnwidth(s, -1, 1);\n+\treturn utf8_strnwidth(s, strlen(s), 1);\n }\n \n /*"
        },
        {
          "filename": "fsck.c",
          "status": "modified",
          "additions": 94,
          "deletions": 43,
          "patch": "@@ -2,6 +2,7 @@\n #include \"object-store.h\"\n #include \"repository.h\"\n #include \"object.h\"\n+#include \"attr.h\"\n #include \"blob.h\"\n #include \"tree.h\"\n #include \"tree-walk.h\"\n@@ -614,17 +615,22 @@ static int fsck_tree(const struct object_id *tree_oid,\n \t\t\t\t\t\t \".gitmodules is a symbolic link\");\n \t\t}\n \n+\t\tif (is_hfs_dotgitattributes(name) || is_ntfs_dotgitattributes(name)) {\n+\t\t\tif (!S_ISLNK(mode))\n+\t\t\t\toidset_insert(&options->gitattributes_found,\n+\t\t\t\t\t      entry_oid);\n+\t\t\telse\n+\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n+\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n+\t\t\t\t\t\t \".gitattributes is a symlink\");\n+\t\t}\n+\n \t\tif (S_ISLNK(mode)) {\n \t\t\tif (is_hfs_dotgitignore(name) ||\n \t\t\t    is_ntfs_dotgitignore(name))\n \t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n \t\t\t\t\t\t FSCK_MSG_GITIGNORE_SYMLINK,\n \t\t\t\t\t\t \".gitignore is a symlink\");\n-\t\t\tif (is_hfs_dotgitattributes(name) ||\n-\t\t\t    is_ntfs_dotgitattributes(name))\n-\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n-\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n-\t\t\t\t\t\t \".gitattributes is a symlink\");\n \t\t\tif (is_hfs_dotmailmap(name) ||\n \t\t\t    is_ntfs_dotmailmap(name))\n \t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n@@ -1159,38 +1165,70 @@ static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n static int fsck_blob(const struct object_id *oid, const char *buf,\n \t\t     unsigned long size, struct fsck_options *options)\n {\n-\tstruct fsck_gitmodules_data data;\n-\tstruct config_options config_opts = { 0 };\n-\n-\tif (!oidset_contains(&options->gitmodules_found, oid))\n-\t\treturn 0;\n-\toidset_insert(&options->gitmodules_done, oid);\n+\tint ret = 0;\n \n \tif (object_on_skiplist(options, oid))\n \t\treturn 0;\n \n-\tif (!buf) {\n-\t\t/*\n-\t\t * A missing buffer here is a sign that the caller found the\n-\t\t * blob too gigantic to load into memory. Let's just consider\n-\t\t * that an error.\n-\t\t */\n-\t\treturn report(options, oid, OBJ_BLOB,\n-\t\t\t      FSCK_MSG_GITMODULES_LARGE,\n-\t\t\t      \".gitmodules too large to parse\");\n+\tif (oidset_contains(&options->gitmodules_found, oid)) {\n+\t\tstruct config_options config_opts = { 0 };\n+\t\tstruct fsck_gitmodules_data data;\n+\n+\t\toidset_insert(&options->gitmodules_done, oid);\n+\n+\t\tif (!buf) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_LARGE,\n+\t\t\t\t\t\".gitmodules too large to parse\");\n+\t\t}\n+\n+\t\tdata.oid = oid;\n+\t\tdata.options = options;\n+\t\tdata.ret = 0;\n+\t\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n+\t\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n+\t\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n+\t\t\tdata.ret |= report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_PARSE,\n+\t\t\t\t\t\"could not parse gitmodules blob\");\n+\t\tret |= data.ret;\n \t}\n \n-\tdata.oid = oid;\n-\tdata.options = options;\n-\tdata.ret = 0;\n-\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n-\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n-\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n-\t\tdata.ret |= report(options, oid, OBJ_BLOB,\n-\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n-\t\t\t\t   \"could not parse gitmodules blob\");\n-\n-\treturn data.ret;\n+\tif (oidset_contains(&options->gitattributes_found, oid)) {\n+\t\tconst char *ptr;\n+\n+\t\toidset_insert(&options->gitattributes_done, oid);\n+\n+\t\tif (!buf || size > ATTR_MAX_FILE_SIZE) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITATTRIBUTES_LARGE,\n+\t\t\t\t\t\".gitattributes too large to parse\");\n+\t\t}\n+\n+\t\tfor (ptr = buf; *ptr; ) {\n+\t\t\tconst char *eol = strchrnul(ptr, '\\n');\n+\t\t\tif (eol - ptr >= ATTR_MAX_LINE_LENGTH) {\n+\t\t\t\tret |= report(options, oid, OBJ_BLOB,\n+\t\t\t\t\t      FSCK_MSG_GITATTRIBUTES_LINE_LENGTH,\n+\t\t\t\t\t      \".gitattributes has too long lines to parse\");\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tptr = *eol ? eol + 1 : eol;\n+\t\t}\n+\t}\n+\n+\treturn ret;\n }\n \n int fsck_object(struct object *obj, void *data, unsigned long size,\n@@ -1229,45 +1267,58 @@ int fsck_error_function(struct fsck_options *o,\n \treturn 1;\n }\n \n-int fsck_finish(struct fsck_options *options)\n+static int fsck_blobs(struct oidset *blobs_found, struct oidset *blobs_done,\n+\t\t      enum fsck_msg_id msg_missing, enum fsck_msg_id msg_type,\n+\t\t      struct fsck_options *options, const char *blob_type)\n {\n \tint ret = 0;\n \tstruct oidset_iter iter;\n \tconst struct object_id *oid;\n \n-\toidset_iter_init(&options->gitmodules_found, &iter);\n+\toidset_iter_init(blobs_found, &iter);\n \twhile ((oid = oidset_iter_next(&iter))) {\n \t\tenum object_type type;\n \t\tunsigned long size;\n \t\tchar *buf;\n \n-\t\tif (oidset_contains(&options->gitmodules_done, oid))\n+\t\tif (oidset_contains(blobs_done, oid))\n \t\t\tcontinue;\n \n \t\tbuf = read_object_file(oid, &type, &size);\n \t\tif (!buf) {\n \t\t\tif (is_promisor_object(oid))\n \t\t\t\tcontinue;\n \t\t\tret |= report(options,\n-\t\t\t\t      oid, OBJ_BLOB,\n-\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n-\t\t\t\t      \"unable to read .gitmodules blob\");\n+\t\t\t\t      oid, OBJ_BLOB, msg_missing,\n+\t\t\t\t      \"unable to read %s blob\", blob_type);\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (type == OBJ_BLOB)\n \t\t\tret |= fsck_blob(oid, buf, size, options);\n \t\telse\n-\t\t\tret |= report(options,\n-\t\t\t\t      oid, type,\n-\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n-\t\t\t\t      \"non-blob found at .gitmodules\");\n+\t\t\tret |= report(options, oid, type, msg_type,\n+\t\t\t\t      \"non-blob found at %s\", blob_type);\n \t\tfree(buf);\n \t}\n \n+\toidset_clear(blobs_found);\n+\toidset_clear(blobs_done);\n+\n+\treturn ret;\n+}\n+\n+int fsck_finish(struct fsck_options *options)\n+{\n+\tint ret = 0;\n+\n+\tret |= fsck_blobs(&options->gitmodules_found, &options->gitmodules_done,\n+\t\t\t  FSCK_MSG_GITMODULES_MISSING, FSCK_MSG_GITMODULES_BLOB,\n+\t\t\t  options, \".gitmodules\");\n+\tret |= fsck_blobs(&options->gitattributes_found, &options->gitattributes_done,\n+\t\t\t  FSCK_MSG_GITATTRIBUTES_MISSING, FSCK_MSG_GITATTRIBUTES_BLOB,\n+\t\t\t  options, \".gitattributes\");\n \n-\toidset_clear(&options->gitmodules_found);\n-\toidset_clear(&options->gitmodules_done);\n \treturn ret;\n }\n "
        },
        {
          "filename": "fsck.h",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -59,6 +59,10 @@ enum fsck_msg_type {\n \tFUNC(GITMODULES_URL, ERROR) \\\n \tFUNC(GITMODULES_PATH, ERROR) \\\n \tFUNC(GITMODULES_UPDATE, ERROR) \\\n+\tFUNC(GITATTRIBUTES_MISSING, ERROR) \\\n+\tFUNC(GITATTRIBUTES_LARGE, ERROR) \\\n+\tFUNC(GITATTRIBUTES_LINE_LENGTH, ERROR) \\\n+\tFUNC(GITATTRIBUTES_BLOB, ERROR) \\\n \t/* warnings */ \\\n \tFUNC(EMPTY_NAME, WARN) \\\n \tFUNC(FULL_PATHNAME, WARN) \\\n@@ -133,25 +137,33 @@ struct fsck_options {\n \tstruct oidset skiplist;\n \tstruct oidset gitmodules_found;\n \tstruct oidset gitmodules_done;\n+\tstruct oidset gitattributes_found;\n+\tstruct oidset gitattributes_done;\n \tkh_oid_map_t *object_names;\n };\n \n #define FSCK_OPTIONS_DEFAULT { \\\n \t.skiplist = OIDSET_INIT, \\\n \t.gitmodules_found = OIDSET_INIT, \\\n \t.gitmodules_done = OIDSET_INIT, \\\n+\t.gitattributes_found = OIDSET_INIT, \\\n+\t.gitattributes_done = OIDSET_INIT, \\\n \t.error_func = fsck_error_function \\\n }\n #define FSCK_OPTIONS_STRICT { \\\n \t.strict = 1, \\\n \t.gitmodules_found = OIDSET_INIT, \\\n \t.gitmodules_done = OIDSET_INIT, \\\n+\t.gitattributes_found = OIDSET_INIT, \\\n+\t.gitattributes_done = OIDSET_INIT, \\\n \t.error_func = fsck_error_function, \\\n }\n #define FSCK_OPTIONS_MISSING_GITMODULES { \\\n \t.strict = 1, \\\n \t.gitmodules_found = OIDSET_INIT, \\\n \t.gitmodules_done = OIDSET_INIT, \\\n+\t.gitattributes_found = OIDSET_INIT, \\\n+\t.gitattributes_done = OIDSET_INIT, \\\n \t.error_func = fsck_error_cb_print_missing_gitmodules, \\\n }\n "
        },
        {
          "filename": "git-compat-util.h",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -1051,6 +1051,14 @@ static inline unsigned long cast_size_t_to_ulong(size_t a)\n \treturn (unsigned long)a;\n }\n \n+static inline int cast_size_t_to_int(size_t a)\n+{\n+\tif (a > INT_MAX)\n+\t\tdie(\"number too large to represent as int on this platform: %\"PRIuMAX,\n+\t\t    (uintmax_t)a);\n+\treturn (int)a;\n+}\n+\n /*\n  * Limit size of IO chunks, because huge chunks only cause pain.  OS X\n  * 64-bit is buggy, returning EINVAL if len >= INT_MAX; and even in"
        },
        {
          "filename": "pretty.c",
          "status": "modified",
          "additions": 52,
          "deletions": 11,
          "patch": "@@ -14,6 +14,13 @@\n #include \"trailer.h\"\n #include \"run-command.h\"\n \n+/*\n+ * The limit for formatting directives, which enable the caller to append\n+ * arbitrarily many bytes to the formatted buffer. This includes padding\n+ * and wrapping formatters.\n+ */\n+#define FORMATTING_LIMIT (16 * 1024)\n+\n static char *user_format;\n static struct cmt_fmt_map {\n \tconst char *name;\n@@ -994,7 +1001,9 @@ static void strbuf_wrap(struct strbuf *sb, size_t pos,\n \tif (pos)\n \t\tstrbuf_add(&tmp, sb->buf, pos);\n \tstrbuf_add_wrapped_text(&tmp, sb->buf + pos,\n-\t\t\t\t(int) indent1, (int) indent2, (int) width);\n+\t\t\t\tcast_size_t_to_int(indent1),\n+\t\t\t\tcast_size_t_to_int(indent2),\n+\t\t\t\tcast_size_t_to_int(width));\n \tstrbuf_swap(&tmp, sb);\n \tstrbuf_release(&tmp);\n }\n@@ -1120,9 +1129,18 @@ static size_t parse_padding_placeholder(const char *placeholder,\n \t\tconst char *end = start + strcspn(start, \",)\");\n \t\tchar *next;\n \t\tint width;\n-\t\tif (!end || end == start)\n+\t\tif (!*end || end == start)\n \t\t\treturn 0;\n \t\twidth = strtol(start, &next, 10);\n+\n+\t\t/*\n+\t\t * We need to limit the amount of padding, or otherwise this\n+\t\t * would allow the user to pad the buffer by arbitrarily many\n+\t\t * bytes and thus cause resource exhaustion.\n+\t\t */\n+\t\tif (width < -FORMATTING_LIMIT || width > FORMATTING_LIMIT)\n+\t\t\treturn 0;\n+\n \t\tif (next == start || width == 0)\n \t\t\treturn 0;\n \t\tif (width < 0) {\n@@ -1405,6 +1423,16 @@ static size_t format_commit_one(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\tif (*next != ')')\n \t\t\t\t\treturn 0;\n \t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * We need to limit the format here as it allows the\n+\t\t\t * user to prepend arbitrarily many bytes to the buffer\n+\t\t\t * when rewrapping.\n+\t\t\t */\n+\t\t\tif (width > FORMATTING_LIMIT ||\n+\t\t\t    indent1 > FORMATTING_LIMIT ||\n+\t\t\t    indent2 > FORMATTING_LIMIT)\n+\t\t\t\treturn 0;\n \t\t\trewrap_message_tail(sb, c, width, indent1, indent2);\n \t\t\treturn end - placeholder + 1;\n \t\t} else\n@@ -1670,19 +1698,21 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t    struct format_commit_context *c)\n {\n \tstruct strbuf local_sb = STRBUF_INIT;\n-\tint total_consumed = 0, len, padding = c->padding;\n+\tsize_t total_consumed = 0;\n+\tint len, padding = c->padding;\n+\n \tif (padding < 0) {\n \t\tconst char *start = strrchr(sb->buf, '\\n');\n \t\tint occupied;\n \t\tif (!start)\n \t\t\tstart = sb->buf;\n-\t\toccupied = utf8_strnwidth(start, -1, 1);\n+\t\toccupied = utf8_strnwidth(start, strlen(start), 1);\n \t\toccupied += c->pretty_ctx->graph_width;\n \t\tpadding = (-padding) - occupied;\n \t}\n \twhile (1) {\n \t\tint modifier = *placeholder == 'C';\n-\t\tint consumed = format_commit_one(&local_sb, placeholder, c);\n+\t\tsize_t consumed = format_commit_one(&local_sb, placeholder, c);\n \t\ttotal_consumed += consumed;\n \n \t\tif (!modifier)\n@@ -1694,7 +1724,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\tplaceholder++;\n \t\ttotal_consumed++;\n \t}\n-\tlen = utf8_strnwidth(local_sb.buf, -1, 1);\n+\tlen = utf8_strnwidth(local_sb.buf, local_sb.len, 1);\n \n \tif (c->flush_type == flush_left_and_steal) {\n \t\tconst char *ch = sb->buf + sb->len - 1;\n@@ -1709,7 +1739,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t\tif (*ch != 'm')\n \t\t\t\tbreak;\n \t\t\tp = ch - 1;\n-\t\t\twhile (ch - p < 10 && *p != '\\033')\n+\t\t\twhile (p > sb->buf && ch - p < 10 && *p != '\\033')\n \t\t\t\tp--;\n \t\t\tif (*p != '\\033' ||\n \t\t\t    ch + 1 - p != display_mode_esc_sequence_len(p))\n@@ -1748,7 +1778,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t}\n \t\tstrbuf_addbuf(sb, &local_sb);\n \t} else {\n-\t\tint sb_len = sb->len, offset = 0;\n+\t\tsize_t sb_len = sb->len, offset = 0;\n \t\tif (c->flush_type == flush_left)\n \t\t\toffset = padding - len;\n \t\telse if (c->flush_type == flush_both)\n@@ -1771,8 +1801,7 @@ static size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t const char *placeholder,\n \t\t\t\t void *context)\n {\n-\tint consumed;\n-\tsize_t orig_len;\n+\tsize_t consumed, orig_len;\n \tenum {\n \t\tNO_MAGIC,\n \t\tADD_LF_BEFORE_NON_EMPTY,\n@@ -1793,9 +1822,21 @@ static size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \tdefault:\n \t\tbreak;\n \t}\n-\tif (magic != NO_MAGIC)\n+\tif (magic != NO_MAGIC) {\n \t\tplaceholder++;\n \n+\t\tswitch (placeholder[0]) {\n+\t\tcase 'w':\n+\t\t\t/*\n+\t\t\t * `%+w()` cannot ever expand to a non-empty string,\n+\t\t\t * and it potentially changes the layout of preceding\n+\t\t\t * contents. We're thus not able to handle the magic in\n+\t\t\t * this combination and refuse the pattern.\n+\t\t\t */\n+\t\t\treturn 0;\n+\t\t};\n+\t}\n+\n \torig_len = sb->len;\n \tif (((struct format_commit_context *)context)->flush_type != no_flush)\n \t\tconsumed = format_and_pad_commit(sb, placeholder, context);"
        },
        {
          "filename": "t/t0003-attributes.sh",
          "status": "modified",
          "additions": 59,
          "deletions": 0,
          "patch": "@@ -376,4 +376,63 @@ test_expect_success SYMLINKS 'symlinks not respected in-tree' '\n \ttest_i18ngrep \"unable to access.*gitattributes\" err\n '\n \n+test_expect_success 'large attributes line ignored in tree' '\n+\ttest_when_finished \"rm .gitattributes\" &&\n+\tprintf \"path %02043d\" 1 >.gitattributes &&\n+\tgit check-attr --all path >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success 'large attributes line ignores trailing content in tree' '\n+\ttest_when_finished \"rm .gitattributes\" &&\n+\t# older versions of Git broke lines at 2048 bytes; the 2045 bytes\n+\t# of 0-padding here is accounting for the three bytes of \"a 1\", which\n+\t# would knock \"trailing\" to the \"next\" line, where it would be\n+\t# erroneously parsed.\n+\tprintf \"a %02045dtrailing attribute\\n\" 1 >.gitattributes &&\n+\tgit check-attr --all trailing >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success EXPENSIVE 'large attributes file ignored in tree' '\n+\ttest_when_finished \"rm .gitattributes\" &&\n+\tdd if=/dev/zero of=.gitattributes bs=101M count=1 2>/dev/null &&\n+\tgit check-attr --all path >/dev/null 2>err &&\n+\techo \"warning: ignoring overly large gitattributes file ${SQ}.gitattributes${SQ}\" >expect &&\n+\ttest_cmp expect err\n+'\n+\n+test_expect_success 'large attributes line ignored in index' '\n+\ttest_when_finished \"git update-index --remove .gitattributes\" &&\n+\tblob=$(printf \"path %02043d\" 1 | git hash-object -w --stdin) &&\n+\tgit update-index --add --cacheinfo 100644,$blob,.gitattributes &&\n+\tgit check-attr --cached --all path >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success 'large attributes line ignores trailing content in index' '\n+\ttest_when_finished \"git update-index --remove .gitattributes\" &&\n+\tblob=$(printf \"a %02045dtrailing attribute\\n\" 1 | git hash-object -w --stdin) &&\n+\tgit update-index --add --cacheinfo 100644,$blob,.gitattributes &&\n+\tgit check-attr --cached --all trailing >actual 2>err &&\n+\techo \"warning: ignoring overly long attributes line 1\" >expect &&\n+\ttest_cmp expect err &&\n+\ttest_must_be_empty actual\n+'\n+\n+test_expect_success EXPENSIVE 'large attributes file ignored in index' '\n+\ttest_when_finished \"git update-index --remove .gitattributes\" &&\n+\tblob=$(dd if=/dev/zero bs=101M count=1 2>/dev/null | git hash-object -w --stdin) &&\n+\tgit update-index --add --cacheinfo 100644,$blob,.gitattributes &&\n+\tgit check-attr --cached --all path >/dev/null 2>err &&\n+\techo \"warning: ignoring overly large gitattributes blob ${SQ}.gitattributes${SQ}\" >expect &&\n+\ttest_cmp expect err\n+'\n+\n test_done"
        },
        {
          "filename": "t/t1450-fsck.sh",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -999,4 +999,28 @@ test_expect_success 'fsck error and recovery on invalid object type' '\n \t)\n '\n \n+test_expect_success 'fsck error on gitattributes with excessive line lengths' '\n+\tblob=$(printf \"pattern %02048d\" 1 | git hash-object -w --stdin) &&\n+\ttest_when_finished \"remove_object $blob\" &&\n+\ttree=$(printf \"100644 blob %s\\t%s\\n\" $blob .gitattributes | git mktree) &&\n+\ttest_when_finished \"remove_object $tree\" &&\n+\tcat >expected <<-EOF &&\n+\terror in blob $blob: gitattributesLineLength: .gitattributes has too long lines to parse\n+\tEOF\n+\ttest_must_fail git fsck --no-dangling >actual 2>&1 &&\n+\ttest_cmp expected actual\n+'\n+\n+test_expect_success 'fsck error on gitattributes with excessive size' '\n+\tblob=$(test-tool genzeros $((100 * 1024 * 1024 + 1)) | git hash-object -w --stdin) &&\n+\ttest_when_finished \"remove_object $blob\" &&\n+\ttree=$(printf \"100644 blob %s\\t%s\\n\" $blob .gitattributes | git mktree) &&\n+\ttest_when_finished \"remove_object $tree\" &&\n+\tcat >expected <<-EOF &&\n+\terror in blob $blob: gitattributesLarge: .gitattributes too large to parse\n+\tEOF\n+\ttest_must_fail git fsck --no-dangling >actual 2>&1 &&\n+\ttest_cmp expected actual\n+'\n+\n test_done"
        },
        {
          "filename": "t/t4205-log-pretty-formats.sh",
          "status": "modified",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -1018,4 +1018,80 @@ test_expect_success '%(describe:abbrev=...) vs git describe --abbrev=...' '\n \ttest_cmp expect actual\n '\n \n+test_expect_success 'log --pretty with space stealing' '\n+\tprintf mm0 >expect &&\n+\tgit log -1 --pretty=\"format:mm%>>|(1)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty with invalid padding format' '\n+\tprintf \"%s%%<(20\" \"$(git rev-parse HEAD)\" >expect &&\n+\tgit log -1 --pretty=\"format:%H%<(20\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty with magical wrapping directives' '\n+\tcommit_id=$(git commit-tree HEAD^{tree} -m \"describe me\") &&\n+\tgit tag describe-me $commit_id &&\n+\tprintf \"\\n(tag:\\ndescribe-me)%%+w(2)\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(1)%+d%+w(2)\" $commit_id >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success SIZE_T_IS_64BIT 'log --pretty with overflowing wrapping directive' '\n+\tprintf \"%%w(2147483649,1,1)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(2147483649,1,1)%x30\" >actual &&\n+\ttest_cmp expect actual &&\n+\tprintf \"%%w(1,2147483649,1)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(1,2147483649,1)%x30\" >actual &&\n+\ttest_cmp expect actual &&\n+\tprintf \"%%w(1,1,2147483649)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%w(1,1,2147483649)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success SIZE_T_IS_64BIT 'log --pretty with overflowing padding directive' '\n+\tprintf \"%%<(2147483649)0\" >expect &&\n+\tgit log -1 --pretty=\"format:%<(2147483649)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty with padding and preceding control chars' '\n+\tprintf \"\\20\\20   0\" >expect &&\n+\tgit log -1 --pretty=\"format:%x10%x10%>|(4)%x30\" >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success 'log --pretty truncation with control chars' '\n+\ttest_commit \"$(printf \"\\20\\20\\20\\20xxxx\")\" file contents commit-with-control-chars &&\n+\tprintf \"\\20\\20\\20\\20x..\" >expect &&\n+\tgit log -1 --pretty=\"format:%<(3,trunc)%s\" commit-with-control-chars >actual &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'log --pretty with huge commit message' '\n+\t# We only assert that this command does not crash. This needs to be\n+\t# executed with the address sanitizer to demonstrate failure.\n+\tgit log -1 --pretty=\"format:%>(2147483646)%x41%41%>(2147483646)%x41\" >/dev/null\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'set up huge commit' '\n+\ttest-tool genzeros 2147483649 | tr \"\\000\" \"1\" >expect &&\n+\thuge_commit=$(git commit-tree -F expect HEAD^{tree})\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'log --pretty with huge commit message' '\n+\tgit log -1 --format=\"%B%<(1)%x30\" $huge_commit >actual &&\n+\techo 0 >>expect &&\n+\ttest_cmp expect actual\n+'\n+\n+test_expect_success EXPENSIVE,SIZE_T_IS_64BIT 'log --pretty with huge commit message does not cause allocation failure' '\n+\ttest_must_fail git log -1 --format=\"%<(1)%B\" $huge_commit 2>error &&\n+\tcat >expect <<-EOF &&\n+\tfatal: number too large to represent as int on this platform: 2147483649\n+\tEOF\n+\ttest_cmp expect error\n+'\n+\n test_done"
        },
        {
          "filename": "utf8.c",
          "status": "modified",
          "additions": 43,
          "deletions": 34,
          "patch": "@@ -206,26 +206,34 @@ int utf8_width(const char **start, size_t *remainder_p)\n  * string, assuming that the string is utf8.  Returns strlen() instead\n  * if the string does not look like a valid utf8 string.\n  */\n-int utf8_strnwidth(const char *string, int len, int skip_ansi)\n+int utf8_strnwidth(const char *string, size_t len, int skip_ansi)\n {\n-\tint width = 0;\n \tconst char *orig = string;\n+\tsize_t width = 0;\n \n-\tif (len == -1)\n-\t\tlen = strlen(string);\n \twhile (string && string < orig + len) {\n-\t\tint skip;\n+\t\tint glyph_width;\n+\t\tsize_t skip;\n+\n \t\twhile (skip_ansi &&\n \t\t       (skip = display_mode_esc_sequence_len(string)) != 0)\n \t\t\tstring += skip;\n-\t\twidth += utf8_width(&string, NULL);\n+\n+\t\tglyph_width = utf8_width(&string, NULL);\n+\t\tif (glyph_width > 0)\n+\t\t\twidth += glyph_width;\n \t}\n-\treturn string ? width : len;\n+\n+\t/*\n+\t * TODO: fix the interface of this function and `utf8_strwidth()` to\n+\t * return `size_t` instead of `int`.\n+\t */\n+\treturn cast_size_t_to_int(string ? width : len);\n }\n \n int utf8_strwidth(const char *string)\n {\n-\treturn utf8_strnwidth(string, -1, 0);\n+\treturn utf8_strnwidth(string, strlen(string), 0);\n }\n \n int is_utf8(const char *text)\n@@ -357,51 +365,52 @@ void strbuf_add_wrapped_bytes(struct strbuf *buf, const char *data, int len,\n void strbuf_utf8_replace(struct strbuf *sb_src, int pos, int width,\n \t\t\t const char *subst)\n {\n-\tstruct strbuf sb_dst = STRBUF_INIT;\n-\tchar *src = sb_src->buf;\n-\tchar *end = src + sb_src->len;\n-\tchar *dst;\n-\tint w = 0, subst_len = 0;\n+\tconst char *src = sb_src->buf, *end = sb_src->buf + sb_src->len;\n+\tstruct strbuf dst;\n+\tint w = 0;\n \n-\tif (subst)\n-\t\tsubst_len = strlen(subst);\n-\tstrbuf_grow(&sb_dst, sb_src->len + subst_len);\n-\tdst = sb_dst.buf;\n+\tstrbuf_init(&dst, sb_src->len);\n \n \twhile (src < end) {\n-\t\tchar *old;\n+\t\tconst char *old;\n+\t\tint glyph_width;\n \t\tsize_t n;\n \n \t\twhile ((n = display_mode_esc_sequence_len(src))) {\n-\t\t\tmemcpy(dst, src, n);\n+\t\t\tstrbuf_add(&dst, src, n);\n \t\t\tsrc += n;\n-\t\t\tdst += n;\n \t\t}\n \n \t\tif (src >= end)\n \t\t\tbreak;\n \n \t\told = src;\n-\t\tn = utf8_width((const char**)&src, NULL);\n-\t\tif (!src) \t/* broken utf-8, do nothing */\n+\t\tglyph_width = utf8_width((const char**)&src, NULL);\n+\t\tif (!src) /* broken utf-8, do nothing */\n \t\t\tgoto out;\n-\t\tif (n && w >= pos && w < pos + width) {\n+\n+\t\t/*\n+\t\t * In case we see a control character we copy it into the\n+\t\t * buffer, but don't add it to the width.\n+\t\t */\n+\t\tif (glyph_width < 0)\n+\t\t\tglyph_width = 0;\n+\n+\t\tif (glyph_width && w >= pos && w < pos + width) {\n \t\t\tif (subst) {\n-\t\t\t\tmemcpy(dst, subst, subst_len);\n-\t\t\t\tdst += subst_len;\n+\t\t\t\tstrbuf_addstr(&dst, subst);\n \t\t\t\tsubst = NULL;\n \t\t\t}\n-\t\t\tw += n;\n-\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tstrbuf_add(&dst, old, src - old);\n \t\t}\n-\t\tmemcpy(dst, old, src - old);\n-\t\tdst += src - old;\n-\t\tw += n;\n+\n+\t\tw += glyph_width;\n \t}\n-\tstrbuf_setlen(&sb_dst, dst - sb_dst.buf);\n-\tstrbuf_swap(sb_src, &sb_dst);\n+\n+\tstrbuf_swap(sb_src, &dst);\n out:\n-\tstrbuf_release(&sb_dst);\n+\tstrbuf_release(&dst);\n }\n \n /*\n@@ -796,7 +805,7 @@ int skip_utf8_bom(char **text, size_t len)\n void strbuf_utf8_align(struct strbuf *buf, align_type position, unsigned int width,\n \t\t       const char *s)\n {\n-\tint slen = strlen(s);\n+\tsize_t slen = strlen(s);\n \tint display_len = utf8_strnwidth(s, slen, 0);\n \tint utf8_compensation = slen - display_len;\n "
        },
        {
          "filename": "utf8.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -7,7 +7,7 @@ typedef unsigned int ucs_char_t;  /* assuming 32bit int */\n \n size_t display_mode_esc_sequence_len(const char *s);\n int utf8_width(const char **start, size_t *remainder_p);\n-int utf8_strnwidth(const char *string, int len, int skip_ansi);\n+int utf8_strnwidth(const char *string, size_t len, int skip_ansi);\n int utf8_strwidth(const char *string);\n int is_utf8(const char *text);\n int is_encoding_utf8(const char *name);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "049f0cf1a5d000f1e24f0e80b79b0d043a8b83b2",
            "date": "2025-01-09T11:10:39Z",
            "author_login": "dscho"
          },
          {
            "sha": "9b81fae3f9084efa6028b6b45f11b4e1570422ec",
            "date": "2025-01-09T06:21:30Z",
            "author_login": "pks-t"
          },
          {
            "sha": "783fac4a953e6af08710a2ca08597bf224e064cc",
            "date": "2025-01-01T21:00:05Z",
            "author_login": "dscho"
          },
          {
            "sha": "19a0d610505c683dd44798430d66296b78913ae5",
            "date": "2018-06-07T06:45:01Z",
            "author_login": "dscho"
          },
          {
            "sha": "ef52c17b50f48a20b9765be66033953d55153269",
            "date": "2024-12-22T16:24:24Z",
            "author_login": "rimrul"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-426",
    "description": "Git GUI is a convenient graphical tool that comes with Git for Windows. Its target audience is users who are uncomfortable with using Git on the command-line. Git GUI has a function to clone repositories. Immediately after the local clone is available, Git GUI will automatically post-process it, among other things running a spell checker called `aspell.exe` if it was found. Git GUI is implemented as a Tcl/Tk script. Due to the unfortunate design of Tcl on Windows, the search path when looking for an executable _always includes the current directory_. Therefore, malicious repositories can ship with an `aspell.exe` in their top-level directory which is executed by Git GUI without giving the user a chance to inspect it first, i.e. running untrusted code. This issue has been addressed in version 2.39.1. Users are advised to upgrade. Users unable to upgrade should avoid using Git GUI for cloning. If that is not a viable option, at least avoid cloning from untrusted sources.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-17T22:15:10.747",
    "last_modified": "2024-11-21T07:24:08.677",
    "fix_date": "2023-01-17T18:47:49Z"
  },
  "references": [
    {
      "url": "https://github.com/git-for-windows/git/commit/7360767e8dfc1895a932324079f7d45d7791d39f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git-for-windows/git/pull/4219",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git-for-windows/git/security/advisories/GHSA-v4px-mx59-w99c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.tcl.tk/man/tcl8.6/TclCmd/exec.html#M23",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git-for-windows/git/commit/7360767e8dfc1895a932324079f7d45d7791d39f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git-for-windows/git/pull/4219",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/git-for-windows/git/security/advisories/GHSA-v4px-mx59-w99c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.tcl.tk/man/tcl8.6/TclCmd/exec.html#M23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.568477",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "git",
    "owner": "git-for-windows",
    "created_at": "2014-08-22T07:07:36Z",
    "updated_at": "2025-01-14T13:19:02Z",
    "pushed_at": "2025-01-09T17:42:38Z",
    "size": 325513,
    "stars": 8482,
    "forks": 2588,
    "open_issues": 206,
    "watchers": 8482,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C": 11981006,
      "Shell": 8634745,
      "Perl": 1170538,
      "Tcl": 857873,
      "Python": 183463,
      "Makefile": 170990,
      "C++": 116083,
      "Meson": 106489,
      "JavaScript": 49713,
      "CMake": 47919,
      "M4": 38265,
      "Roff": 26859,
      "SmPL": 15676,
      "Go": 15064,
      "Batchfile": 11440,
      "CSS": 10664,
      "Emacs Lisp": 660,
      "PowerShell": 478,
      "ReScript": 92
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0.0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:50:24.765409"
  }
}