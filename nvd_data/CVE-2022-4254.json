{
  "cve_id": "CVE-2022-4254",
  "github_data": {
    "repository": "SSSD/sssd",
    "fix_commit": "a2b9a84460429181f2a4fa7e2bb5ab49fd561274",
    "related_commits": [
      "a2b9a84460429181f2a4fa7e2bb5ab49fd561274",
      "a2b9a84460429181f2a4fa7e2bb5ab49fd561274"
    ],
    "patch_url": "https://github.com/SSSD/sssd/commit/a2b9a84460429181f2a4fa7e2bb5ab49fd561274.patch",
    "fix_commit_details": {
      "sha": "a2b9a84460429181f2a4fa7e2bb5ab49fd561274",
      "commit_date": "2019-12-09T10:31:14Z",
      "author": {
        "login": "sumit-bose",
        "type": "User",
        "stats": {
          "total_commits": 1601,
          "average_weekly_commits": 1.883529411764706,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 504
        }
      },
      "commit_message": {
        "title": "certmap: sanitize LDAP search filter",
        "length": 359,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 380,
        "additions": 272,
        "deletions": 108
      },
      "files": [
        {
          "filename": "Makefile.am",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -2163,7 +2163,7 @@ libsss_certmap_la_LIBADD = \\\n     $(NULL)\n libsss_certmap_la_LDFLAGS = \\\n     -Wl,--version-script,$(srcdir)/src/lib/certmap/sss_certmap.exports \\\n-    -version-info 1:0:1\n+    -version-info 2:0:2\n \n if HAVE_NSS\n libsss_certmap_la_SOURCES += \\"
        },
        {
          "filename": "src/lib/certmap/sss_certmap.c",
          "status": "modified",
          "additions": 37,
          "deletions": 5,
          "patch": "@@ -441,10 +441,12 @@ static int expand_san(struct sss_certmap_ctx *ctx,\n static int expand_template(struct sss_certmap_ctx *ctx,\n                            struct parsed_template *parsed_template,\n                            struct sss_cert_content *cert_content,\n+                           bool sanitize,\n                            char **expanded)\n {\n     int ret;\n     char *exp = NULL;\n+    char *exp_sanitized = NULL;\n \n     if (strcmp(\"issuer_dn\", parsed_template->name) == 0) {\n         ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n@@ -455,6 +457,8 @@ static int expand_template(struct sss_certmap_ctx *ctx,\n     } else if (strncmp(\"subject_\", parsed_template->name, 8) == 0) {\n         ret = expand_san(ctx, parsed_template, cert_content->san_list, &exp);\n     } else if (strcmp(\"cert\", parsed_template->name) == 0) {\n+        /* cert blob is already sanitized */\n+        sanitize = false;\n         ret = expand_cert(ctx, parsed_template, cert_content, &exp);\n     } else {\n         CM_DEBUG(ctx, \"Unsupported template name.\");\n@@ -471,6 +475,16 @@ static int expand_template(struct sss_certmap_ctx *ctx,\n         goto done;\n     }\n \n+    if (sanitize) {\n+        ret = sss_filter_sanitize(ctx, exp, &exp_sanitized);\n+        if (ret != EOK) {\n+            CM_DEBUG(ctx, \"Failed to sanitize expanded template.\");\n+            goto done;\n+        }\n+        talloc_free(exp);\n+        exp = exp_sanitized;\n+    }\n+\n     ret = 0;\n \n done:\n@@ -485,7 +499,7 @@ static int expand_template(struct sss_certmap_ctx *ctx,\n \n static int get_filter(struct sss_certmap_ctx *ctx,\n                       struct ldap_mapping_rule *parsed_mapping_rule,\n-                      struct sss_cert_content *cert_content,\n+                      struct sss_cert_content *cert_content, bool sanitize,\n                       char **filter)\n {\n     struct ldap_mapping_rule_comp *comp;\n@@ -503,7 +517,7 @@ static int get_filter(struct sss_certmap_ctx *ctx,\n             result = talloc_strdup_append(result, comp->val);\n         } else if (comp->type == comp_template) {\n             ret = expand_template(ctx, comp->parsed_template, cert_content,\n-                                  &expanded);\n+                                  sanitize, &expanded);\n             if (ret != 0) {\n                 CM_DEBUG(ctx, \"Failed to expanded template.\");\n                 goto done;\n@@ -791,8 +805,9 @@ int sss_certmap_match_cert(struct sss_certmap_ctx *ctx,\n     return ret;\n }\n \n-int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n+static int expand_mapping_rule_ex(struct sss_certmap_ctx *ctx,\n                                   const uint8_t *der_cert, size_t der_size,\n+                                  bool sanitize,\n                                   char **_filter, char ***_domains)\n {\n     int ret;\n@@ -819,7 +834,8 @@ int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n             return EINVAL;\n         }\n \n-        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n+        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, sanitize,\n+                         &filter);\n         goto done;\n     }\n \n@@ -829,7 +845,7 @@ int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n             if (ret == 0) {\n                 /* match */\n                 ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n-                                 &filter);\n+                                 sanitize, &filter);\n                 if (ret != 0) {\n                     CM_DEBUG(ctx, \"Failed to get filter\");\n                     goto done;\n@@ -873,6 +889,22 @@ int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n     return ret;\n }\n \n+int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n+                                  const uint8_t *der_cert, size_t der_size,\n+                                  char **_filter, char ***_domains)\n+{\n+    return expand_mapping_rule_ex(ctx, der_cert, der_size, true,\n+                                  _filter, _domains);\n+}\n+\n+int sss_certmap_expand_mapping_rule(struct sss_certmap_ctx *ctx,\n+                                    const uint8_t *der_cert, size_t der_size,\n+                                    char **_expanded, char ***_domains)\n+{\n+    return expand_mapping_rule_ex(ctx, der_cert, der_size, false,\n+                                  _expanded, _domains);\n+}\n+\n int sss_certmap_init(TALLOC_CTX *mem_ctx,\n                      sss_certmap_ext_debug *debug, void *debug_priv,\n                      struct sss_certmap_ctx **ctx)"
        },
        {
          "filename": "src/lib/certmap/sss_certmap.exports",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -16,3 +16,8 @@ SSS_CERTMAP_0.1 {\n     global:\n         sss_certmap_display_cert_content;\n } SSS_CERTMAP_0.0;\n+\n+SSS_CERTMAP_0.2 {\n+    global:\n+        sss_certmap_expand_mapping_rule;\n+} SSS_CERTMAP_0.1;"
        },
        {
          "filename": "src/lib/certmap/sss_certmap.h",
          "status": "modified",
          "additions": 30,
          "deletions": 5,
          "patch": "@@ -103,7 +103,7 @@ int sss_certmap_add_rule(struct sss_certmap_ctx *ctx,\n  *\n  * @param[in] ctx      certmap context previously initialized with\n  *                     @ref sss_certmap_init\n- * @param[in] der_cert binary blog with the DER encoded certificate\n+ * @param[in] der_cert binary blob with the DER encoded certificate\n  * @param[in] der_size size of the certificate blob\n  *\n  * @return\n@@ -119,10 +119,11 @@ int sss_certmap_match_cert(struct sss_certmap_ctx *ctx,\n  *\n  * @param[in] ctx      certmap context previously initialized with\n  *                     @ref sss_certmap_init\n- * @param[in] der_cert binary blog with the DER encoded certificate\n+ * @param[in] der_cert binary blob with the DER encoded certificate\n  * @param[in] der_size size of the certificate blob\n- * @param[out] filter  LDAP filter string, caller should free the data by\n- *                     calling sss_certmap_free_filter_and_domains\n+ * @param[out] filter  LDAP filter string, expanded templates are sanitized,\n+ *                     caller should free the data by calling\n+ *                     sss_certmap_free_filter_and_domains\n  * @param[out] domains NULL-terminated array of strings with the domains the\n  *                     rule applies, caller should free the data by calling\n  *                     sss_certmap_free_filter_and_domains\n@@ -136,8 +137,32 @@ int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                   const uint8_t *der_cert, size_t der_size,\n                                   char **filter, char ***domains);\n \n+/**\n+ * @brief Expand the mapping rule by replacing the templates\n+ *\n+ * @param[in] ctx        certmap context previously initialized with\n+ *                       @ref sss_certmap_init\n+ * @param[in] der_cert   binary blob with the DER encoded certificate\n+ * @param[in] der_size   size of the certificate blob\n+ * @param[out] expanded  expanded mapping rule, templates are filled in\n+ *                       verbatim in contrast to sss_certmap_get_search_filter,\n+ *                       caller should free the data by\n+ *                       calling sss_certmap_free_filter_and_domains\n+ * @param[out] domains   NULL-terminated array of strings with the domains the\n+ *                       rule applies, caller should free the data by calling\n+ *                       sss_certmap_free_filter_and_domains\n+ *\n+ * @return\n+ *  - 0:      certificate matches a rule\n+ *  - ENOENT: certificate does not match\n+ *  - EINVAL: internal error\n+ */\n+int sss_certmap_expand_mapping_rule(struct sss_certmap_ctx *ctx,\n+                                    const uint8_t *der_cert, size_t der_size,\n+                                    char **_expanded, char ***_domains);\n /**\n  * @brief Free data returned by @ref sss_certmap_get_search_filter\n+ *        and @ref sss_certmap_expand_mapping_rule\n  *\n  * @param[in] filter  LDAP filter strings returned by\n  *                    sss_certmap_get_search_filter\n@@ -150,7 +175,7 @@ void sss_certmap_free_filter_and_domains(char *filter, char **domains);\n  * @brief Get a string with the content of the certificate used by the library\n  *\n  * @param[in]  mem_ctx    Talloc memory context, may be NULL\n- * @param[in]  der_cert   binary blog with the DER encoded certificate\n+ * @param[in]  der_cert   binary blob with the DER encoded certificate\n  * @param[in]  der_size   size of the certificate blob\n  * @param[out] desc       Multiline string showing the certificate content\n  *                        which is used by libsss_certmap"
        },
        {
          "filename": "src/responder/pam/pamsrv_p11.c",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1049,9 +1049,10 @@ static char *get_cert_prompt(TALLOC_CTX *mem_ctx,\n         goto done;\n     }\n \n-    ret = sss_certmap_get_search_filter(ctx, der, der_size, &filter, &domains);\n+    ret = sss_certmap_expand_mapping_rule(ctx, der, der_size,\n+                                          &filter, &domains);\n     if (ret != 0) {\n-        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_get_search_filter failed.\\n\");\n+        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_expand_mapping_rule failed.\\n\");\n         goto done;\n     }\n "
        },
        {
          "filename": "src/tests/cmocka/test_certmap.c",
          "status": "modified",
          "additions": 97,
          "deletions": 1,
          "patch": "@@ -1431,6 +1431,15 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule100=<I>CN=Certificate\\\\20Authority,O=IPA.DEVEL\"\n+                                \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n+    assert_null(domains);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule100=<I>CN=Certificate Authority,O=IPA.DEVEL\"\n                                 \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n     assert_null(domains);\n@@ -1445,6 +1454,17 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule99=<I>CN=Certificate\\\\20Authority,O=IPA.DEVEL\"\n+                                \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule99=<I>CN=Certificate Authority,O=IPA.DEVEL\"\n                                 \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n     assert_non_null(domains);\n@@ -1466,6 +1486,16 @@ static void test_sss_certmap_get_search_filter(void **state)\n     assert_string_equal(domains[0], \"test.dom\");\n     assert_null(domains[1]);\n \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"rule98=userCertificate;binary=\" TEST_CERT_BIN);\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n+\n     ret = sss_certmap_add_rule(ctx, 97,\n                             \"KRB5:<ISSUER>CN=Certificate Authority,O=IPA.DEVEL\",\n                             \"LDAP:rule97=<I>{issuer_dn!nss_x500}<S>{subject_dn}\",\n@@ -1476,6 +1506,17 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule97=<I>O=IPA.DEVEL,CN=Certificate\\\\20Authority\"\n+                                \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule97=<I>O=IPA.DEVEL,CN=Certificate Authority\"\n                                 \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n     assert_non_null(domains);\n@@ -1492,6 +1533,17 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule96=<I>O=IPA.DEVEL,CN=Certificate\\\\20Authority\"\n+                                \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\");\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule96=<I>O=IPA.DEVEL,CN=Certificate Authority\"\n                                 \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\");\n     assert_non_null(domains);\n@@ -1510,6 +1562,14 @@ static void test_sss_certmap_get_search_filter(void **state)\n     assert_string_equal(filter, \"(userCertificate;binary=\" TEST_CERT_BIN \")\");\n     assert_null(domains);\n \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"(userCertificate;binary=\" TEST_CERT_BIN \")\");\n+    assert_null(domains);\n+\n     ret = sss_certmap_add_rule(ctx, 94,\n                       \"KRB5:<ISSUER>CN=Certificate Authority,O=IPA.DEVEL\",\n                       \"LDAP:rule94=<I>{issuer_dn!ad_x500}<S>{subject_dn!ad_x500}\",\n@@ -1520,12 +1580,22 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n-    assert_string_equal(filter, \"rule94=<I>O=IPA.DEVEL,CN=Certificate Authority\"\n+    assert_string_equal(filter, \"rule94=<I>O=IPA.DEVEL,CN=Certificate\\\\20Authority\"\n                                 \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\");\n     assert_non_null(domains);\n     assert_string_equal(domains[0], \"test.dom\");\n     assert_null(domains[1]);\n \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"rule94=<I>O=IPA.DEVEL,CN=Certificate Authority\"\n+                                \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\");\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n \n     ret = sss_certmap_add_rule(ctx, 89, NULL,\n                             \"(rule89={subject_nt_principal})\",\n@@ -1539,6 +1609,14 @@ static void test_sss_certmap_get_search_filter(void **state)\n     assert_string_equal(filter, \"(rule89=tu1@ad.devel)\");\n     assert_null(domains);\n \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert2_der),\n+                                          sizeof(test_cert2_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"(rule89=tu1@ad.devel)\");\n+    assert_null(domains);\n+\n     ret = sss_certmap_add_rule(ctx, 88, NULL,\n                             \"(rule88={subject_nt_principal.short_name})\",\n                             NULL);\n@@ -1560,6 +1638,15 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule87=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\n+                  \"<S>DC=devel,DC=ad,CN=Users,CN=t\\\\20u,E=test.user@email.domain\");\n+    assert_null(domains);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert2_der),\n+                                          sizeof(test_cert2_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule87=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\n                   \"<S>DC=devel,DC=ad,CN=Users,CN=t u,E=test.user@email.domain\");\n     assert_null(domains);\n@@ -1573,6 +1660,15 @@ static void test_sss_certmap_get_search_filter(void **state)\n                                         &filter, &domains);\n     assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule86=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\n+                  \"<S>DC=devel,DC=ad,CN=Users,CN=t\\\\20u,E=test.user@email.domain\");\n+    assert_null(domains);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert2_der),\n+                                          sizeof(test_cert2_der),\n+                                          &filter, &domains);\n+    assert_int_equal(ret, 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule86=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\n                   \"<S>DC=devel,DC=ad,CN=Users,CN=t u,E=test.user@email.domain\");\n     assert_null(domains);"
        },
        {
          "filename": "src/util/util.c",
          "status": "modified",
          "additions": 0,
          "deletions": 94,
          "patch": "@@ -436,100 +436,6 @@ errno_t sss_hash_create(TALLOC_CTX *mem_ctx, unsigned long count,\n     return sss_hash_create_ex(mem_ctx, count, tbl, 0, 0, 0, 0, NULL, NULL);\n }\n \n-errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n-                               const char *input,\n-                               char **sanitized,\n-                               const char *ignore)\n-{\n-    char *output;\n-    size_t i = 0;\n-    size_t j = 0;\n-    char *allowed;\n-\n-    /* Assume the worst-case. We'll resize it later, once */\n-    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n-    if (!output) {\n-        return ENOMEM;\n-    }\n-\n-    while (input[i]) {\n-        /* Even though this character might have a special meaning, if it's\n-         * explicitly allowed, just copy it and move on\n-         */\n-        if (ignore == NULL) {\n-            allowed = NULL;\n-        } else {\n-            allowed = strchr(ignore, input[i]);\n-        }\n-        if (allowed) {\n-            output[j++] = input[i++];\n-            continue;\n-        }\n-\n-        switch(input[i]) {\n-        case '\\t':\n-            output[j++] = '\\\\';\n-            output[j++] = '0';\n-            output[j++] = '9';\n-            break;\n-        case ' ':\n-            output[j++] = '\\\\';\n-            output[j++] = '2';\n-            output[j++] = '0';\n-            break;\n-        case '*':\n-            output[j++] = '\\\\';\n-            output[j++] = '2';\n-            output[j++] = 'a';\n-            break;\n-        case '(':\n-            output[j++] = '\\\\';\n-            output[j++] = '2';\n-            output[j++] = '8';\n-            break;\n-        case ')':\n-            output[j++] = '\\\\';\n-            output[j++] = '2';\n-            output[j++] = '9';\n-            break;\n-        case '\\\\':\n-            output[j++] = '\\\\';\n-            output[j++] = '5';\n-            output[j++] = 'c';\n-            break;\n-        case '\\r':\n-            output[j++] = '\\\\';\n-            output[j++] = '0';\n-            output[j++] = 'd';\n-            break;\n-        case '\\n':\n-            output[j++] = '\\\\';\n-            output[j++] = '0';\n-            output[j++] = 'a';\n-            break;\n-        default:\n-            output[j++] = input[i];\n-        }\n-\n-        i++;\n-    }\n-    output[j] = '\\0';\n-    *sanitized = talloc_realloc(mem_ctx, output, char, j+1);\n-    if (!*sanitized) {\n-        talloc_free(output);\n-        return ENOMEM;\n-    }\n-\n-    return EOK;\n-}\n-\n-errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n-                            const char *input,\n-                            char **sanitized)\n-{\n-    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n-}\n-\n char *\n sss_escape_ip_address(TALLOC_CTX *mem_ctx, int family, const char *addr)\n {"
        },
        {
          "filename": "src/util/util_ext.c",
          "status": "modified",
          "additions": 99,
          "deletions": 0,
          "patch": "@@ -29,6 +29,11 @@\n \n #define EOK 0\n \n+#ifndef HAVE_ERRNO_T\n+#define HAVE_ERRNO_T\n+typedef int errno_t;\n+#endif\n+\n int split_on_separator(TALLOC_CTX *mem_ctx, const char *str,\n                        const char sep, bool trim, bool skip_empty,\n                        char ***_list, int *size)\n@@ -141,3 +146,97 @@ bool string_in_list(const char *string, char **list, bool case_sensitive)\n \n     return false;\n }\n+\n+errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n+                               const char *input,\n+                               char **sanitized,\n+                               const char *ignore)\n+{\n+    char *output;\n+    size_t i = 0;\n+    size_t j = 0;\n+    char *allowed;\n+\n+    /* Assume the worst-case. We'll resize it later, once */\n+    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n+    if (!output) {\n+        return ENOMEM;\n+    }\n+\n+    while (input[i]) {\n+        /* Even though this character might have a special meaning, if it's\n+         * explicitly allowed, just copy it and move on\n+         */\n+        if (ignore == NULL) {\n+            allowed = NULL;\n+        } else {\n+            allowed = strchr(ignore, input[i]);\n+        }\n+        if (allowed) {\n+            output[j++] = input[i++];\n+            continue;\n+        }\n+\n+        switch(input[i]) {\n+        case '\\t':\n+            output[j++] = '\\\\';\n+            output[j++] = '0';\n+            output[j++] = '9';\n+            break;\n+        case ' ':\n+            output[j++] = '\\\\';\n+            output[j++] = '2';\n+            output[j++] = '0';\n+            break;\n+        case '*':\n+            output[j++] = '\\\\';\n+            output[j++] = '2';\n+            output[j++] = 'a';\n+            break;\n+        case '(':\n+            output[j++] = '\\\\';\n+            output[j++] = '2';\n+            output[j++] = '8';\n+            break;\n+        case ')':\n+            output[j++] = '\\\\';\n+            output[j++] = '2';\n+            output[j++] = '9';\n+            break;\n+        case '\\\\':\n+            output[j++] = '\\\\';\n+            output[j++] = '5';\n+            output[j++] = 'c';\n+            break;\n+        case '\\r':\n+            output[j++] = '\\\\';\n+            output[j++] = '0';\n+            output[j++] = 'd';\n+            break;\n+        case '\\n':\n+            output[j++] = '\\\\';\n+            output[j++] = '0';\n+            output[j++] = 'a';\n+            break;\n+        default:\n+            output[j++] = input[i];\n+        }\n+\n+        i++;\n+    }\n+    output[j] = '\\0';\n+    *sanitized = talloc_realloc(mem_ctx, output, char, j+1);\n+    if (!*sanitized) {\n+        talloc_free(output);\n+        return ENOMEM;\n+    }\n+\n+    return EOK;\n+}\n+\n+errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n+                            const char *input,\n+                            char **sanitized)\n+{\n+    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c6294f5ff32a917bb1286afcc23f92f4f8ebe010",
            "date": "2024-11-14T19:53:06Z",
            "author_login": "justin-stephenson"
          },
          {
            "sha": "e58cf803192c477857fe13b41e2fe2a3800cc9a1",
            "date": "2024-11-14T19:21:21Z",
            "author_login": "justin-stephenson"
          },
          {
            "sha": "c2d95a3b35524308c23c5ad880f29e0278df4049",
            "date": "2025-01-06T12:40:09Z",
            "author_login": "aplopez"
          },
          {
            "sha": "067dbf614d8aa4d00bec3425740762ff65890b37",
            "date": "2025-01-08T15:31:06Z",
            "author_login": "ikerexxe"
          },
          {
            "sha": "6bd231cda3dec7daf4dce01b8c35613bd197fbd0",
            "date": "2025-01-07T13:14:11Z",
            "author_login": "alexey-tikhonov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-90",
    "description": "sssd: libsss_certmap fails to sanitise certificate data used in LDAP filters",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-01T17:15:09.680",
    "last_modified": "2024-11-21T07:34:52.860",
    "fix_date": "2019-12-09T10:31:14Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/security/cve/CVE-2022-4254",
      "source": "secalert@redhat.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2149894",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/SSSD/sssd/commit/a2b9a84460429181f2a4fa7e2bb5ab49fd561274",
      "source": "secalert@redhat.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/SSSD/sssd/issues/5135",
      "source": "secalert@redhat.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00028.html",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/security/cve/CVE-2022-4254",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2149894",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/SSSD/sssd/commit/a2b9a84460429181f2a4fa7e2bb5ab49fd561274",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/SSSD/sssd/issues/5135",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00028.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:03.965093",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sssd",
    "owner": "SSSD",
    "created_at": "2015-06-15T17:09:48Z",
    "updated_at": "2025-01-13T16:22:54Z",
    "pushed_at": "2025-01-13T15:21:41Z",
    "size": 88872,
    "stars": 621,
    "forks": 253,
    "open_issues": 265,
    "watchers": 621,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 14139176,
      "Python": 2611027,
      "Makefile": 215241,
      "Smarty": 73378,
      "M4": 59727,
      "Shell": 40518,
      "PowerShell": 4936,
      "DTrace": 3095,
      "C++": 506
    },
    "commit_activity": {
      "total_commits_last_year": 446,
      "avg_commits_per_week": 8.576923076923077,
      "days_active_last_year": 185
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T13:37:23.084830"
  }
}