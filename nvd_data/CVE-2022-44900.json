{
  "cve_id": "CVE-2022-44900",
  "github_data": {
    "repository": "miurahr/py7zr",
    "fix_commit": "1bb43f17515c7f69673a1c88ab9cc72a7bbef406",
    "related_commits": [
      "1bb43f17515c7f69673a1c88ab9cc72a7bbef406",
      "1bb43f17515c7f69673a1c88ab9cc72a7bbef406"
    ],
    "patch_url": "https://github.com/miurahr/py7zr/commit/1bb43f17515c7f69673a1c88ab9cc72a7bbef406.patch",
    "fix_commit_details": {
      "sha": "1bb43f17515c7f69673a1c88ab9cc72a7bbef406",
      "commit_date": "2022-10-30T05:27:46Z",
      "author": {
        "login": "miurahr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix sanity check for path traversal attack",
        "length": 660,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 211,
        "additions": 158,
        "deletions": 53
      },
      "files": [
        {
          "filename": "MANIFEST.in",
          "status": "modified",
          "additions": 0,
          "deletions": 3,
          "patch": "@@ -3,8 +3,6 @@ include *.rst\n include *.svg\n include *.toml\n include LICENSE\n-include .coveragerc\n-include tox.ini\n include py7zr/py.typed\n recursive-include py7zr *.py\n recursive-include tests *.py\n@@ -25,7 +23,6 @@ recursive-include docs *.yml\n recursive-include docs *.odp\n recursive-include docs *.pdf\n recursive-include docs *.svg\n-recursive-include docs *.txt\n recursive-include docs Makefile\n prune .github\n exclude .gitignore"
        },
        {
          "filename": "py7zr/helpers.py",
          "status": "modified",
          "additions": 58,
          "deletions": 2,
          "patch": "@@ -33,6 +33,8 @@\n import _hashlib  # type: ignore  # noqa\n \n import py7zr.win32compat\n+from py7zr import Bad7zFile\n+from py7zr.win32compat import is_windows_native_python, is_windows_unc_path\n \n # String used at the beginning of relative paths\n RELATIVE_PATH_MARKER = \"./\"\n@@ -265,7 +267,7 @@ def from_now():\n def islink(path):\n     \"\"\"\n     Cross-platform islink implementation.\n-    Supports Windows NT symbolic links and reparse points.\n+    Support Windows NT symbolic links and reparse points.\n     \"\"\"\n     is_symlink = os.path.islink(str(path))\n     if sys.version_info >= (3, 8) or sys.platform != \"win32\" or sys.getwindowsversion()[0] < 6:\n@@ -280,7 +282,7 @@ def islink(path):\n def readlink(path: Union[str, pathlib.Path], *, dir_fd=None) -> Union[str, pathlib.Path]:\n     \"\"\"\n     Cross-platform compat implementation of os.readlink and Path.readlink().\n-    Supports Windows NT symbolic links and reparse points.\n+    Support Windows NT symbolic links and reparse points.\n     When called with path argument as pathlike(str), return result as a pathlike(str).\n     When called with Path object, return also Path object.\n     When called with path argument as bytes, return result as a bytes.\n@@ -431,3 +433,57 @@ def remove_relative_path_marker(path: str) -> str:\n         processed_path = path[len(RELATIVE_PATH_MARKER) :]\n \n     return processed_path\n+\n+\n+def get_sanitized_output_path(fname: str, path: Optional[pathlib.Path]) -> pathlib.Path:\n+    \"\"\"\n+    check f.filename has invalid directory traversals\n+    do following but is_relative_to introduced in py 3.9,\n+    so I replaced it with relative_to. when condition is not satisfied, raise ValueError\n+    if not pathlib.Path(...).joinpath(remove_relative_path_marker(outname)).is_relative_to(...):\n+        raise Bad7zFile\n+    \"\"\"\n+    if path is None:\n+        try:\n+            pathlib.Path(os.getcwd()).joinpath(fname).resolve().relative_to(os.getcwd())\n+            outfile = pathlib.Path(remove_relative_path_marker(fname))\n+        except ValueError:\n+            raise Bad7zFile(f\"Specified path is bad: {fname}\")\n+    else:\n+        try:\n+            outfile = path.joinpath(remove_relative_path_marker(fname))\n+            outfile.resolve().relative_to(path)\n+        except ValueError:\n+            raise Bad7zFile(f\"Specified path is bad: {fname}\")\n+    return outfile\n+\n+\n+def check_archive_path(arcname: str) -> bool:\n+    path = pathlib.Path(\"/foo/boo/fuga/hoge/a90sufoiasj09/dafj08sajfa/\")  # dummy path\n+    return is_target_path_valid(path, path.joinpath(arcname))\n+\n+\n+def is_target_path_valid(path: pathlib.Path, target: pathlib.Path) -> bool:\n+    try:\n+        if path.is_absolute():\n+            target.resolve().relative_to(path)\n+        else:\n+            target.resolve().relative_to(pathlib.Path(os.getcwd()).joinpath(path))\n+    except ValueError:\n+        return False\n+    return True\n+\n+\n+def check_win32_file_namespace(pathname: pathlib.Path) -> pathlib.Path:\n+    # When python on Windows and not python on Cygwin,\n+    # Add win32 file namespace to exceed Microsoft Windows\n+    # path length limitation to 260 bytes\n+    # ref.\n+    # https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n+    # In editions of Windows before Windows 10 version 1607,\n+    # the maximum length for a path is MAX_PATH, which is defined as\n+    # 260 characters. In later versions of Windows, changing a registry key\n+    # or select option when python installation is required to remove the limit.\n+    if is_windows_native_python() and pathname.is_absolute() and not is_windows_unc_path(pathname):\n+        pathname = pathlib.WindowsPath(\"\\\\\\\\?\\\\\" + str(pathname))\n+    return pathname"
        },
        {
          "filename": "py7zr/py7zr.py",
          "status": "modified",
          "additions": 51,
          "deletions": 47,
          "patch": "@@ -50,12 +50,13 @@\n     MemIO,\n     NullIO,\n     calculate_crc32,\n+    check_archive_path,\n     filetime_to_dt,\n+    get_sanitized_output_path,\n+    is_target_path_valid,\n     readlink,\n-    remove_relative_path_marker,\n )\n from py7zr.properties import DEFAULT_FILTERS, FILTER_DEFLATE64, MAGIC_7Z, get_default_blocksize, get_memory_limit\n-from py7zr.win32compat import is_windows_native_python, is_windows_unc_path\n \n if sys.platform.startswith(\"win\"):\n     import _winapi\n@@ -567,34 +568,10 @@ def _extract(\n                         break\n                     i += 1\n             fnames.append(outname)\n-            # check f.filename has invalid directory traversals\n-            if path is None:\n-                # do following but is_relative_to introduced in py 3.9\n-                # so I replaced it with relative_to. when condition is not satisfied, raise ValueError\n-                # if not pathlib.Path(...).joinpath(remove_relative_path_marker(outname)).is_relative_to(...):\n-                #    raise Bad7zFile\n-                try:\n-                    pathlib.Path(os.getcwd()).joinpath(remove_relative_path_marker(outname)).relative_to(os.getcwd())\n-                except ValueError:\n-                    raise Bad7zFile\n-                outfilename = pathlib.Path(remove_relative_path_marker(outname))\n+            if path is None or path.is_absolute():\n+                outfilename = get_sanitized_output_path(outname, path)\n             else:\n-                outfilename = path.joinpath(remove_relative_path_marker(outname))\n-                try:\n-                    outfilename.relative_to(path)\n-                except ValueError:\n-                    raise Bad7zFile\n-            # When python on Windows and not python on Cygwin,\n-            # Add win32 file namespace to exceed microsoft windows\n-            # path length limitation to 260 bytes\n-            # ref.\n-            # https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n-            # In editions of Windows before Windows 10 version 1607,\n-            # the maximum length for a path is MAX_PATH, which is defined as\n-            # 260 characters. In later versions of Windows, changing a registry key\n-            # or select option when python installation is required to remove the limit.\n-            if is_windows_native_python() and outfilename.is_absolute() and not is_windows_unc_path(outfilename):\n-                outfilename = pathlib.WindowsPath(\"\\\\\\\\?\\\\\" + str(outfilename))\n+                outfilename = get_sanitized_output_path(outname, pathlib.Path(os.getcwd()).joinpath(path))\n             if targets is not None and f.filename not in targets:\n                 self.worker.register_filelike(f.id, None)\n                 continue\n@@ -634,12 +611,14 @@ def _extract(\n         if callback is not None:\n             self.worker.extract(\n                 self.fp,\n+                path,\n                 parallel=(not self.password_protected and not self._filePassed),\n                 q=self.q,\n             )\n         else:\n             self.worker.extract(\n                 self.fp,\n+                path,\n                 parallel=(not self.password_protected and not self._filePassed),\n             )\n \n@@ -1040,6 +1019,11 @@ def writed(self, targets: Dict[str, IO[Any]]) -> None:\n             self.writef(input, target)\n \n     def writef(self, bio: IO[Any], arcname: str):\n+        if not check_archive_path(arcname):\n+            raise ValueError(f\"Specified path is bad: {arcname}\")\n+        return self._writef(bio, arcname)\n+\n+    def _writef(self, bio: IO[Any], arcname: str):\n         if isinstance(bio, io.BytesIO):\n             size = bio.getbuffer().nbytes\n         elif isinstance(bio, io.TextIOBase):\n@@ -1069,12 +1053,17 @@ def writef(self, bio: IO[Any], arcname: str):\n             self.files.append(file_info)\n \n     def writestr(self, data: Union[str, bytes, bytearray, memoryview], arcname: str):\n+        if not check_archive_path(arcname):\n+            raise ValueError(f\"Specified path is bad: {arcname}\")\n+        return self._writestr(data, arcname)\n+\n+    def _writestr(self, data: Union[str, bytes, bytearray, memoryview], arcname: str):\n         if not isinstance(arcname, str):\n             raise ValueError(\"Unsupported arcname\")\n         if isinstance(data, str):\n-            self.writef(io.BytesIO(data.encode(\"UTF-8\")), arcname)\n+            self._writef(io.BytesIO(data.encode(\"UTF-8\")), arcname)\n         elif isinstance(data, bytes) or isinstance(data, bytearray) or isinstance(data, memoryview):\n-            self.writef(io.BytesIO(data), arcname)\n+            self._writef(io.BytesIO(bytes(data)), arcname)\n         else:\n             raise ValueError(\"Unsupported data type.\")\n \n@@ -1131,7 +1120,9 @@ def testzip(self) -> Optional[str]:\n         for f in self.files:\n             self.worker.register_filelike(f.id, None)\n         try:\n-            self.worker.extract(self.fp, parallel=(not self.password_protected), skip_notarget=False)  # TODO: print progress\n+            self.worker.extract(\n+                self.fp, None, parallel=(not self.password_protected), skip_notarget=False\n+            )  # TODO: print progress\n         except CrcError as crce:\n             return crce.args[2]\n         else:\n@@ -1200,7 +1191,7 @@ def __init__(self, files, src_start: int, header, mp=False) -> None:\n         else:\n             self.concurrent = Thread\n \n-    def extract(self, fp: BinaryIO, parallel: bool, skip_notarget=True, q=None) -> None:\n+    def extract(self, fp: BinaryIO, path: Optional[pathlib.Path], parallel: bool, skip_notarget=True, q=None) -> None:\n         \"\"\"Extract worker method to handle 7zip folder and decompress each files.\"\"\"\n         if hasattr(self.header, \"main_streams\") and self.header.main_streams is not None:\n             src_end = self.src_start + self.header.main_streams.packinfo.packpositions[-1]\n@@ -1209,6 +1200,7 @@ def extract(self, fp: BinaryIO, parallel: bool, skip_notarget=True, q=None) -> N\n                 self.extract_single(\n                     fp,\n                     self.files,\n+                    path,\n                     self.src_start,\n                     src_end,\n                     q,\n@@ -1219,14 +1211,15 @@ def extract(self, fp: BinaryIO, parallel: bool, skip_notarget=True, q=None) -> N\n                 positions = self.header.main_streams.packinfo.packpositions\n                 empty_files = [f for f in self.files if f.emptystream]\n                 if not parallel:\n-                    self.extract_single(fp, empty_files, 0, 0, q)\n+                    self.extract_single(fp, empty_files, path, 0, 0, q)\n                     for i in range(numfolders):\n                         if skip_notarget:\n                             if not any([self.target_filepath.get(f.id, None) for f in folders[i].files]):\n                                 continue\n                         self.extract_single(\n                             fp,\n                             folders[i].files,\n+                            path,\n                             self.src_start + positions[i],\n                             self.src_start + positions[i + 1],\n                             q,\n@@ -1236,7 +1229,7 @@ def extract(self, fp: BinaryIO, parallel: bool, skip_notarget=True, q=None) -> N\n                     if getattr(fp, \"name\", None) is None:\n                         raise InternalError(\"Caught unknown variable status error\")\n                     filename: str = getattr(fp, \"name\", \"\")  # do not become \"\" but it is for type check.\n-                    self.extract_single(open(filename, \"rb\"), empty_files, 0, 0, q)\n+                    self.extract_single(open(filename, \"rb\"), empty_files, path, 0, 0, q)\n                     concurrent_tasks = []\n                     exc_q: queue.Queue = queue.Queue()\n                     for i in range(numfolders):\n@@ -1248,6 +1241,7 @@ def extract(self, fp: BinaryIO, parallel: bool, skip_notarget=True, q=None) -> N\n                             args=(\n                                 filename,\n                                 folders[i].files,\n+                                path,\n                                 self.src_start + positions[i],\n                                 self.src_start + positions[i + 1],\n                                 q,\n@@ -1266,12 +1260,13 @@ def extract(self, fp: BinaryIO, parallel: bool, skip_notarget=True, q=None) -> N\n                         raise exc_info[1].with_traceback(exc_info[2])\n         else:\n             empty_files = [f for f in self.files if f.emptystream]\n-            self.extract_single(fp, empty_files, 0, 0, q)\n+            self.extract_single(fp, empty_files, path, 0, 0, q)\n \n     def extract_single(\n         self,\n         fp: Union[BinaryIO, str],\n         files,\n+        path,\n         src_start: int,\n         src_end: int,\n         q: Optional[queue.Queue],\n@@ -1287,7 +1282,7 @@ def extract_single(\n             if isinstance(fp, str):\n                 fp = open(fp, \"rb\")\n             fp.seek(src_start)\n-            self._extract_single(fp, files, src_end, q, skip_notarget)\n+            self._extract_single(fp, files, path, src_end, q, skip_notarget)\n         except Exception as e:\n             if exc_q is None:\n                 raise e\n@@ -1299,6 +1294,7 @@ def _extract_single(\n         self,\n         fp: BinaryIO,\n         files,\n+        path,\n         src_end: int,\n         q: Optional[queue.Queue],\n         skip_notarget=True,\n@@ -1331,20 +1327,28 @@ def _extract_single(\n                         with io.BytesIO() as ofp:\n                             self.decompress(fp, f.folder, ofp, f.uncompressed, f.compressed, src_end)\n                             dst: str = ofp.read().decode(\"utf-8\")\n-                            # fileish.unlink(missing_ok=True) > py3.7\n-                            if fileish.exists():\n-                                fileish.unlink()\n-                            if sys.platform == \"win32\":  # hint for mypy\n-                                _winapi.CreateJunction(str(fileish), dst)  # noqa\n+                            if is_target_path_valid(path, fileish.parent.joinpath(dst)):\n+                                # fileish.unlink(missing_ok=True) > py3.7\n+                                if fileish.exists():\n+                                    fileish.unlink()\n+                                if sys.platform == \"win32\":  # hint for mypy\n+                                    _winapi.CreateJunction(str(fileish), dst)  # noqa\n+                            else:\n+                                raise Bad7zFile(\"Junction point out of target directory.\")\n                     elif f.is_symlink and not isinstance(fileish, MemIO):\n                         with io.BytesIO() as omfp:\n                             self.decompress(fp, f.folder, omfp, f.uncompressed, f.compressed, src_end)\n                             omfp.seek(0)\n-                            sym_target = pathlib.Path(omfp.read().decode(\"utf-8\"))\n-                            # fileish.unlink(missing_ok=True) > py3.7\n-                            if fileish.exists():\n-                                fileish.unlink()\n-                            fileish.symlink_to(sym_target)\n+                            dst = omfp.read().decode(\"utf-8\")\n+                            # check sym_target points inside an archive target?\n+                            if is_target_path_valid(path, fileish.parent.joinpath(dst)):\n+                                sym_target = pathlib.Path(dst)\n+                                # fileish.unlink(missing_ok=True) > py3.7\n+                                if fileish.exists():\n+                                    fileish.unlink()\n+                                fileish.symlink_to(sym_target)\n+                            else:\n+                                raise Bad7zFile(\"Symlink point out of target directory.\")\n                     else:\n                         with fileish.open(mode=\"wb\") as obfp:\n                             crc32 = self.decompress(fp, f.folder, obfp, f.uncompressed, f.compressed, src_end)"
        },
        {
          "filename": "tests/test_extract.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -332,7 +332,7 @@ def test_skip():\n     for i, cf in enumerate(archive.files):\n         assert cf is not None\n         archive.worker.register_filelike(cf.id, None)\n-    archive.worker.extract(archive.fp, parallel=True)\n+    archive.worker.extract(archive.fp, None, parallel=True)\n     archive.close()\n \n "
        },
        {
          "filename": "tests/test_zipslip.py",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+import os\n+\n+import pytest\n+\n+from py7zr import SevenZipFile\n+from py7zr.exceptions import Bad7zFile\n+from py7zr.helpers import check_archive_path, get_sanitized_output_path\n+from py7zr.properties import FILTER_LZMA2, PRESET_DEFAULT\n+\n+testdata_path = os.path.join(os.path.dirname(__file__), \"data\")\n+\n+\n+@pytest.mark.misc\n+def test_check_archive_path():\n+    bad_path = \"../../.../../../../../../tmp/evil.sh\"\n+    assert not check_archive_path(bad_path)\n+\n+\n+@pytest.mark.misc\n+def test_get_sanitized_output_path_1(tmp_path):\n+    bad_path = \"../../.../../../../../../tmp/evil.sh\"\n+    with pytest.raises(Bad7zFile):\n+        get_sanitized_output_path(bad_path, tmp_path)\n+\n+\n+@pytest.mark.misc\n+def test_get_sanitized_output_path_2(tmp_path):\n+    good_path = \"good.sh\"\n+    expected = tmp_path.joinpath(good_path)\n+    assert expected == get_sanitized_output_path(good_path, tmp_path)\n+\n+\n+@pytest.mark.misc\n+def test_extract_path_traversal_attack(tmp_path):\n+    my_filters = [\n+        {\"id\": FILTER_LZMA2, \"preset\": PRESET_DEFAULT},\n+    ]\n+    target = tmp_path.joinpath(\"target.7z\")\n+    good_data = b\"#!/bin/sh\\necho good\\n\"\n+    good_path = \"good.sh\"\n+    bad_data = b\"!#/bin/sh\\necho bad\\n\"\n+    bad_path = \"../../.../../../../../../tmp/evil.sh\"\n+    with SevenZipFile(target, \"w\", filters=my_filters) as archive:\n+        archive.writestr(good_data, good_path)\n+        archive._writestr(bad_data, bad_path)  # bypass a path check\n+    with pytest.raises(Bad7zFile):\n+        with SevenZipFile(target, \"r\") as archive:\n+            archive.extractall(path=tmp_path)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7aa9af85cea41b53a97a3192466588e4c007d42c",
            "date": "2024-12-23T05:48:25Z",
            "author_login": "miurahr"
          },
          {
            "sha": "33dca5e8479d2e1120b99e7a318fa36663af9873",
            "date": "2024-12-23T05:21:06Z",
            "author_login": "miurahr"
          },
          {
            "sha": "7ddf6e05ac0810e277399e1761a156f6e56ffe84",
            "date": "2024-12-19T00:59:35Z",
            "author_login": "miurahr"
          },
          {
            "sha": "d98b916ab04242ba706851882656b32a975c2d10",
            "date": "2024-12-15T04:57:54Z",
            "author_login": "miurahr"
          },
          {
            "sha": "e7017992a2bc0634c70cbdc8376bff91d9de1d1d",
            "date": "2024-12-14T14:49:43Z",
            "author_login": "miurahr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-22",
    "description": "A directory traversal vulnerability in the SevenZipFile.extractall() function of the python library py7zr v0.20.0 and earlier allows attackers to write arbitrary files via extracting a crafted 7z file.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-06T20:15:10.560",
    "last_modified": "2024-11-21T07:28:31.730",
    "fix_date": "2022-10-30T05:27:46Z"
  },
  "references": [
    {
      "url": "http://packetstormsecurity.com/files/170127/py7zr-0.20.0-Directory-Traversal.html",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/miurahr/py7zr/commit/1bb43f17515c7f69673a1c88ab9cc72a7bbef406",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lessonsec.com/cve/cve-2022-44900/",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://packetstormsecurity.com/files/170127/py7zr-0.20.0-Directory-Traversal.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "https://github.com/miurahr/py7zr/commit/1bb43f17515c7f69673a1c88ab9cc72a7bbef406",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://lessonsec.com/cve/cve-2022-44900/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.206860",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "py7zr",
    "owner": "miurahr",
    "created_at": "2019-03-17T03:33:35Z",
    "updated_at": "2025-01-13T12:05:53Z",
    "pushed_at": "2024-12-23T05:48:29Z",
    "size": 48714,
    "stars": 471,
    "forks": 75,
    "open_issues": 24,
    "watchers": 471,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 415872,
      "Shell": 9833,
      "C": 1280
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T22:01:19.730352"
  }
}