{
  "cve_id": "CVE-2022-45908",
  "github_data": {
    "repository": "PaddlePaddle/Paddle",
    "fix_commit": "26c419ca386aeae3c461faf2b828d00b48e908eb",
    "related_commits": [
      "26c419ca386aeae3c461faf2b828d00b48e908eb",
      "26c419ca386aeae3c461faf2b828d00b48e908eb"
    ],
    "patch_url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb.patch",
    "fix_commit_details": {
      "sha": "26c419ca386aeae3c461faf2b828d00b48e908eb",
      "commit_date": "2022-10-28T10:15:55Z",
      "author": {
        "login": "SmileGoat",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[audio]fix audio get_window security error (#47386)",
        "length": 92,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 44,
        "additions": 41,
        "deletions": 3
      },
      "files": [
        {
          "filename": "python/paddle/audio/functional/window.py",
          "status": "modified",
          "additions": 41,
          "deletions": 3,
          "patch": "@@ -19,17 +19,39 @@\n from paddle import Tensor\n \n \n+class WindowFunctionRegister(object):\n+    def __init__(self):\n+        self._functions_dict = dict()\n+\n+    def register(self, func=None):\n+        def add_subfunction(func):\n+            name = func.__name__\n+            self._functions_dict[name] = func\n+            return func\n+\n+        return add_subfunction\n+\n+    def get(self, name):\n+        return self._functions_dict[name]\n+\n+\n+window_function_register = WindowFunctionRegister()\n+\n+\n+@window_function_register.register()\n def _cat(x: List[Tensor], data_type: str) -> Tensor:\n     l = [paddle.to_tensor(_, data_type) for _ in x]\n     return paddle.concat(l)\n \n \n+@window_function_register.register()\n def _acosh(x: Union[Tensor, float]) -> Tensor:\n     if isinstance(x, float):\n         return math.log(x + math.sqrt(x**2 - 1))\n     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))\n \n \n+@window_function_register.register()\n def _extend(M: int, sym: bool) -> bool:\n     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"\n     if not sym:\n@@ -38,6 +60,7 @@ def _extend(M: int, sym: bool) -> bool:\n         return M, False\n \n \n+@window_function_register.register()\n def _len_guards(M: int) -> bool:\n     \"\"\"Handle small or incorrect window lengths.\"\"\"\n     if int(M) != M or M < 0:\n@@ -46,6 +69,7 @@ def _len_guards(M: int) -> bool:\n     return M <= 1\n \n \n+@window_function_register.register()\n def _truncate(w: Tensor, needed: bool) -> Tensor:\n     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"\n     if needed:\n@@ -54,6 +78,7 @@ def _truncate(w: Tensor, needed: bool) -> Tensor:\n         return w\n \n \n+@window_function_register.register()\n def _general_gaussian(\n     M: int, p, sig, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -70,6 +95,7 @@ def _general_gaussian(\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _general_cosine(\n     M: int, a: float, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -86,6 +112,7 @@ def _general_cosine(\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _general_hamming(\n     M: int, alpha: float, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -95,6 +122,7 @@ def _general_hamming(\n     return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)\n \n \n+@window_function_register.register()\n def _taylor(\n     M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -151,6 +179,7 @@ def W(n):\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     \"\"\"Compute a Hamming window.\n     The Hamming window is a taper formed by using a raised cosine with\n@@ -159,6 +188,7 @@ def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     return _general_hamming(M, 0.54, sym, dtype=dtype)\n \n \n+@window_function_register.register()\n def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     \"\"\"Compute a Hann window.\n     The Hann window is a taper formed by using a raised cosine or sine-squared\n@@ -167,6 +197,7 @@ def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     return _general_hamming(M, 0.5, sym, dtype=dtype)\n \n \n+@window_function_register.register()\n def _tukey(\n     M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -200,6 +231,7 @@ def _tukey(\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _kaiser(\n     M: int, beta: float, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -209,6 +241,7 @@ def _kaiser(\n     raise NotImplementedError()\n \n \n+@window_function_register.register()\n def _gaussian(\n     M: int, std: float, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -226,6 +259,7 @@ def _gaussian(\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _exponential(\n     M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'\n ) -> Tensor:\n@@ -245,6 +279,7 @@ def _exponential(\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     \"\"\"Compute a triangular window.\"\"\"\n     if _len_guards(M):\n@@ -262,6 +297,7 @@ def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     \"\"\"Compute a Bohman window.\n     The Bohman window is the autocorrelation of a cosine window.\n@@ -279,6 +315,7 @@ def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     return _truncate(w, needs_trunc)\n \n \n+@window_function_register.register()\n def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     \"\"\"Compute a Blackman window.\n     The Blackman window is a taper formed by using the first three terms of\n@@ -289,6 +326,7 @@ def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)\n \n \n+@window_function_register.register()\n def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n     \"\"\"Compute a window with a simple cosine shape.\"\"\"\n     if _len_guards(M):\n@@ -308,7 +346,7 @@ def get_window(\n     \"\"\"Return a window of a given length and type.\n \n     Args:\n-        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.\n+        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.\n         win_length (int): Number of samples.\n         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.\n         dtype (str, optional): The data type of the return window. Defaults to 'float64'.\n@@ -348,8 +386,8 @@ def get_window(\n         )\n \n     try:\n-        winfunc = eval('_' + winstr)\n-    except NameError as e:\n+        winfunc = window_function_register.get('_' + winstr)\n+    except KeyError as e:\n         raise ValueError(\"Unknown window type.\") from e\n \n     params = (win_length,) + args"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9c0b2411ca6a821dd9df74733f45a7b44a706035",
            "date": "2025-01-14T13:47:29Z",
            "author_login": "cqulilujia"
          },
          {
            "sha": "1a920613e7fb3b646eb998fc938f15268015e59c",
            "date": "2025-01-14T08:09:34Z",
            "author_login": "jerrywgz"
          },
          {
            "sha": "5b6fd9f28358e22ec4c5fce0cd27247e554e0ddf",
            "date": "2025-01-14T08:01:03Z",
            "author_login": "co63oc"
          },
          {
            "sha": "4f7808b44cb445db9d4b8a4d18f5856d9c74ee14",
            "date": "2025-01-14T07:19:50Z",
            "author_login": "co63oc"
          },
          {
            "sha": "7d27813ece2c30daace2f456f381f1e328bbb182",
            "date": "2025-01-14T07:17:33Z",
            "author_login": "zhink"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-94",
    "description": "In PaddlePaddle before 2.4, paddle.audio.functional.get_window is vulnerable to code injection because it calls eval on a user-supplied winstr. This may lead to arbitrary code execution.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-11-26T02:15:10.323",
    "last_modified": "2024-11-21T07:29:55.573",
    "fix_date": "2022-10-28T10:15:55Z"
  },
  "references": [
    {
      "url": "https://github.com/PaddlePaddle/Paddle/blob/develop/security/advisory/pdsa-2022-002.md",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/PaddlePaddle/Paddle/blob/develop/security/advisory/pdsa-2022-002.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.169906",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Paddle",
    "owner": "PaddlePaddle",
    "created_at": "2016-08-15T06:59:08Z",
    "updated_at": "2025-01-14T08:09:39Z",
    "pushed_at": "2025-01-14T08:09:34Z",
    "size": 483457,
    "stars": 22402,
    "forks": 5645,
    "open_issues": 1778,
    "watchers": 22402,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop",
      "incubate/fleety",
      "incubate/frl_train_eval",
      "incubate/infrt",
      "incubate/new_frlv",
      "master",
      "release/1.0.0",
      "release/1.1",
      "release/1.2"
    ],
    "languages": {
      "C++": 51967470,
      "Python": 48667682,
      "Cuda": 7300134,
      "CMake": 1156042,
      "Shell": 641706,
      "C": 297808,
      "Jinja": 93032,
      "Batchfile": 65950,
      "Go": 40964,
      "Java": 16293,
      "Dockerfile": 10472,
      "R": 1331
    },
    "commit_activity": {
      "total_commits_last_year": 6894,
      "avg_commits_per_week": 132.57692307692307,
      "days_active_last_year": 319
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:19:00.050185"
  }
}