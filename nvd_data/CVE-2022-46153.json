{
  "cve_id": "CVE-2022-46153",
  "github_data": {
    "repository": "traefik/traefik",
    "fix_commit": "7e3fe48b80083b41e9ff82a474a36484cabc701a",
    "related_commits": [
      "7e3fe48b80083b41e9ff82a474a36484cabc701a",
      "7e3fe48b80083b41e9ff82a474a36484cabc701a"
    ],
    "patch_url": "https://github.com/traefik/traefik/commit/7e3fe48b80083b41e9ff82a474a36484cabc701a.patch",
    "fix_commit_details": {
      "sha": "7e3fe48b80083b41e9ff82a474a36484cabc701a",
      "commit_date": "2022-12-06T17:28:05Z",
      "author": {
        "login": "mpl",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Handle broken TLS conf better",
        "length": 176,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 559,
        "additions": 402,
        "deletions": 157
      },
      "files": [
        {
          "filename": "integration/fixtures/https/https_invalid_tls_options.toml",
          "status": "added",
          "additions": 60,
          "deletions": 0,
          "patch": "@@ -0,0 +1,60 @@\n+[global]\n+  checkNewVersion = false\n+  sendAnonymousUsage = false\n+\n+[log]\n+  level = \"DEBUG\"\n+\n+[entryPoints.websecure]\n+  address = \":4443\"\n+\n+[api]\n+  insecure = true\n+\n+[providers.file]\n+  filename = \"{{ .SelfFilename }}\"\n+\n+## dynamic configuration ##\n+\n+[http.routers]\n+\n+  [http.routers.router1]\n+    entryPoints = [\"websecure\"]\n+    service = \"service1\"\n+    rule = \"Host(`snitest.com`)\"\n+    [http.routers.router1.tls]\n+      options = \"invalidTLSOptions\"\n+\n+  [http.routers.router2]\n+    entryPoints = [\"websecure\"]\n+    service = \"service1\"\n+    rule = \"Host(`snitest.org`)\"\n+    [http.routers.router2.tls]\n+\n+  # fallback router\n+  [http.routers.router3]\n+    entryPoints = [\"websecure\"]\n+    service = \"service1\"\n+    rule = \"Path(`/`)\"\n+    [http.routers.router3.tls]\n+\n+[[http.services.service1.loadBalancer.servers]]\n+  url = \"http://127.0.0.1:9010\"\n+\n+[[tls.certificates]]\n+  certFile = \"fixtures/https/snitest.com.cert\"\n+  keyFile = \"fixtures/https/snitest.com.key\"\n+\n+[[tls.certificates]]\n+  certFile = \"fixtures/https/snitest.org.cert\"\n+  keyFile = \"fixtures/https/snitest.org.key\"\n+\n+[tls.options]\n+\n+  [tls.options.default.clientAuth]\n+    # Missing caFile to have an invalid mTLS configuration.\n+    clientAuthType = \"RequireAndVerifyClientCert\"\n+\n+  [tls.options.invalidTLSOptions.clientAuth]\n+    # Missing caFile to have an invalid mTLS configuration.\n+    clientAuthType = \"RequireAndVerifyClientCert\""
        },
        {
          "filename": "integration/fixtures/tcp/multi-tls-options.toml",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -33,6 +33,13 @@\n       [tcp.routers.to-whoami-sni-strict.tls]\n         options = \"bar\"\n \n+    [tcp.routers.to-whoami-invalid-tls]\n+      rule = \"HostSNI(`whoami-i.test`)\"\n+      service = \"whoami-no-cert\"\n+      entryPoints = [ \"tcp\" ]\n+      [tcp.routers.to-whoami-invalid-tls.tls]\n+        options = \"invalid\"\n+\n     [tcp.services.whoami-no-cert]\n       [tcp.services.whoami-no-cert.loadBalancer]\n         [[tcp.services.whoami-no-cert.loadBalancer.servers]]\n@@ -45,3 +52,7 @@\n \n   [tls.options.bar]\n     minVersion = \"VersionTLS13\"\n+\n+  [tls.options.invalid.clientAuth]\n+    # Missing CA files to have an invalid mTLS configuration.\n+    clientAuthType = \"RequireAndVerifyClientCert\""
        },
        {
          "filename": "integration/https_test.go",
          "status": "modified",
          "additions": 50,
          "deletions": 0,
          "patch": "@@ -1226,3 +1226,53 @@ func (s *HTTPSSuite) TestWithDomainFronting(c *check.C) {\n \t\tc.Assert(err, checker.IsNil)\n \t}\n }\n+\n+// TestWithInvalidTLSOption verifies the behavior when using an invalid tlsOption configuration.\n+func (s *HTTPSSuite) TestWithInvalidTLSOption(c *check.C) {\n+\tbackend := startTestServer(\"9010\", http.StatusOK, \"server1\")\n+\tdefer backend.Close()\n+\n+\tfile := s.adaptFile(c, \"fixtures/https/https_invalid_tls_options.toml\", struct{}{})\n+\tdefer os.Remove(file)\n+\tcmd, display := s.traefikCmd(withConfigFile(file))\n+\tdefer display(c)\n+\terr := cmd.Start()\n+\tc.Assert(err, checker.IsNil)\n+\tdefer s.killCmd(cmd)\n+\n+\t// wait for Traefik\n+\terr = try.GetRequest(\"http://127.0.0.1:8080/api/rawdata\", 500*time.Millisecond, try.BodyContains(\"Host(`snitest.com`)\"))\n+\tc.Assert(err, checker.IsNil)\n+\n+\ttestCases := []struct {\n+\t\tdesc       string\n+\t\tserverName string\n+\t}{\n+\t\t{\n+\t\t\tdesc:       \"With invalid TLS Options specified\",\n+\t\t\tserverName: \"snitest.com\",\n+\t\t},\n+\t\t{\n+\t\t\tdesc:       \"With invalid Default TLS Options\",\n+\t\t\tserverName: \"snitest.org\",\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"With TLS Options without servername (fallback to default)\",\n+\t\t},\n+\t}\n+\n+\tfor _, test := range testCases {\n+\t\ttest := test\n+\n+\t\ttlsConfig := &tls.Config{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t}\n+\t\tif test.serverName != \"\" {\n+\t\t\ttlsConfig.ServerName = test.serverName\n+\t\t}\n+\n+\t\tconn, err := tls.Dial(\"tcp\", \"127.0.0.1:4443\", tlsConfig)\n+\t\tc.Assert(err, checker.NotNil, check.Commentf(\"connected to server successfully\"))\n+\t\tc.Assert(conn, checker.IsNil)\n+\t}\n+}"
        },
        {
          "filename": "integration/tcp_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -116,6 +116,14 @@ func (s *TCPSuite) TestTLSOptions(c *check.C) {\n \t_, err = guessWhoTLSMaxVersion(\"127.0.0.1:8093\", \"whoami-d.test\", true, tls.VersionTLS12)\n \tc.Assert(err, checker.NotNil)\n \tc.Assert(err.Error(), checker.Contains, \"protocol version not supported\")\n+\n+\t// Check that we can't reach a route with an invalid mTLS configuration.\n+\tconn, err := tls.Dial(\"tcp\", \"127.0.0.1:8093\", &tls.Config{\n+\t\tServerName:         \"whoami-i.test\",\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\tc.Assert(conn, checker.IsNil)\n+\tc.Assert(err, checker.NotNil)\n }\n \n func (s *TCPSuite) TestNonTLSFallback(c *check.C) {"
        },
        {
          "filename": "pkg/server/router/router.go",
          "status": "modified",
          "additions": 17,
          "deletions": 2,
          "patch": "@@ -3,6 +3,7 @@ package router\n import (\n \t\"context\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"net/http\"\n \n \t\"github.com/containous/alice\"\n@@ -16,6 +17,7 @@ import (\n \thttpmuxer \"github.com/traefik/traefik/v2/pkg/muxer/http\"\n \t\"github.com/traefik/traefik/v2/pkg/server/middleware\"\n \t\"github.com/traefik/traefik/v2/pkg/server/provider\"\n+\t\"github.com/traefik/traefik/v2/pkg/tls\"\n )\n \n type middlewareBuilder interface {\n@@ -35,17 +37,19 @@ type Manager struct {\n \tmiddlewaresBuilder middlewareBuilder\n \tchainBuilder       *middleware.ChainBuilder\n \tconf               *runtime.Configuration\n+\ttlsManager         *tls.Manager\n }\n \n-// NewManager Creates a new Manager.\n-func NewManager(conf *runtime.Configuration, serviceManager serviceManager, middlewaresBuilder middlewareBuilder, chainBuilder *middleware.ChainBuilder, metricsRegistry metrics.Registry) *Manager {\n+// NewManager creates a new Manager.\n+func NewManager(conf *runtime.Configuration, serviceManager serviceManager, middlewaresBuilder middlewareBuilder, chainBuilder *middleware.ChainBuilder, metricsRegistry metrics.Registry, tlsManager *tls.Manager) *Manager {\n \treturn &Manager{\n \t\trouterHandlers:     make(map[string]http.Handler),\n \t\tserviceManager:     serviceManager,\n \t\tmetricsRegistry:    metricsRegistry,\n \t\tmiddlewaresBuilder: middlewaresBuilder,\n \t\tchainBuilder:       chainBuilder,\n \t\tconf:               conf,\n+\t\ttlsManager:         tlsManager,\n \t}\n }\n \n@@ -141,6 +145,17 @@ func (m *Manager) buildRouterHandler(ctx context.Context, routerName string, rou\n \t\treturn handler, nil\n \t}\n \n+\tif routerConfig.TLS != nil {\n+\t\t// Don't build the router if the TLSOptions configuration is invalid.\n+\t\ttlsOptionsName := tls.DefaultTLSConfigName\n+\t\tif len(routerConfig.TLS.Options) > 0 && routerConfig.TLS.Options != tls.DefaultTLSConfigName {\n+\t\t\ttlsOptionsName = provider.GetQualifiedName(ctx, routerConfig.TLS.Options)\n+\t\t}\n+\t\tif _, err := m.tlsManager.Get(tls.DefaultTLSStoreName, tlsOptionsName); err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"building router handler: %w\", err)\n+\t\t}\n+\t}\n+\n \thandler, err := m.buildHTTPHandler(ctx, routerConfig, routerName)\n \tif err != nil {\n \t\treturn nil, err"
        },
        {
          "filename": "pkg/server/router/router_test.go",
          "status": "modified",
          "additions": 81,
          "deletions": 7,
          "patch": "@@ -20,6 +20,7 @@ import (\n \t\"github.com/traefik/traefik/v2/pkg/server/middleware\"\n \t\"github.com/traefik/traefik/v2/pkg/server/service\"\n \t\"github.com/traefik/traefik/v2/pkg/testhelpers\"\n+\t\"github.com/traefik/traefik/v2/pkg/tls\"\n \t\"github.com/traefik/traefik/v2/pkg/types\"\n )\n \n@@ -317,8 +318,9 @@ func TestRouterManager_Get(t *testing.T) {\n \t\t\tserviceManager := service.NewManager(rtConf.Services, nil, nil, roundTripperManager)\n \t\t\tmiddlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, nil)\n \t\t\tchainBuilder := middleware.NewChainBuilder(nil, nil, nil)\n+\t\t\ttlsManager := tls.NewManager()\n \n-\t\t\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry())\n+\t\t\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry(), tlsManager)\n \n \t\t\thandlers := routerManager.BuildHandlers(context.Background(), test.entryPoints, false)\n \n@@ -423,8 +425,9 @@ func TestAccessLog(t *testing.T) {\n \t\t\tserviceManager := service.NewManager(rtConf.Services, nil, nil, roundTripperManager)\n \t\t\tmiddlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, nil)\n \t\t\tchainBuilder := middleware.NewChainBuilder(nil, nil, nil)\n+\t\t\ttlsManager := tls.NewManager()\n \n-\t\t\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry())\n+\t\t\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry(), tlsManager)\n \n \t\t\thandlers := routerManager.BuildHandlers(context.Background(), test.entryPoints, false)\n \n@@ -462,6 +465,7 @@ func TestRuntimeConfiguration(t *testing.T) {\n \t\tserviceConfig    map[string]*dynamic.Service\n \t\trouterConfig     map[string]*dynamic.Router\n \t\tmiddlewareConfig map[string]*dynamic.Middleware\n+\t\ttlsOptions       map[string]tls.Options\n \t\texpectedError    int\n \t}{\n \t\t{\n@@ -665,7 +669,6 @@ func TestRuntimeConfiguration(t *testing.T) {\n \t\t\t},\n \t\t\texpectedError: 1,\n \t\t},\n-\n \t\t{\n \t\t\tdesc: \"Router with broken middleware\",\n \t\t\tserviceConfig: map[string]*dynamic.Service{\n@@ -696,8 +699,71 @@ func TestRuntimeConfiguration(t *testing.T) {\n \t\t\t},\n \t\t\texpectedError: 2,\n \t\t},\n+\t\t{\n+\t\t\tdesc: \"Router with broken tlsOption\",\n+\t\t\tserviceConfig: map[string]*dynamic.Service{\n+\t\t\t\t\"foo-service\": {\n+\t\t\t\t\tLoadBalancer: &dynamic.ServersLoadBalancer{\n+\t\t\t\t\t\tServers: []dynamic.Server{\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tURL: \"http://127.0.0.1\",\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tmiddlewareConfig: map[string]*dynamic.Middleware{},\n+\t\t\trouterConfig: map[string]*dynamic.Router{\n+\t\t\t\t\"bar\": {\n+\t\t\t\t\tEntryPoints: []string{\"web\"},\n+\t\t\t\t\tService:     \"foo-service\",\n+\t\t\t\t\tRule:        \"Host(`foo.bar`)\",\n+\t\t\t\t\tTLS: &dynamic.RouterTLSConfig{\n+\t\t\t\t\t\tOptions: \"broken-tlsOption\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttlsOptions: map[string]tls.Options{\n+\t\t\t\t\"broken-tlsOption\": {\n+\t\t\t\t\tClientAuth: tls.ClientAuth{\n+\t\t\t\t\t\tClientAuthType: \"foobar\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedError: 1,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"Router with broken default tlsOption\",\n+\t\t\tserviceConfig: map[string]*dynamic.Service{\n+\t\t\t\t\"foo-service\": {\n+\t\t\t\t\tLoadBalancer: &dynamic.ServersLoadBalancer{\n+\t\t\t\t\t\tServers: []dynamic.Server{\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tURL: \"http://127.0.0.1\",\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tmiddlewareConfig: map[string]*dynamic.Middleware{},\n+\t\t\trouterConfig: map[string]*dynamic.Router{\n+\t\t\t\t\"bar\": {\n+\t\t\t\t\tEntryPoints: []string{\"web\"},\n+\t\t\t\t\tService:     \"foo-service\",\n+\t\t\t\t\tRule:        \"Host(`foo.bar`)\",\n+\t\t\t\t\tTLS:         &dynamic.RouterTLSConfig{},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\ttlsOptions: map[string]tls.Options{\n+\t\t\t\t\"default\": {\n+\t\t\t\t\tClientAuth: tls.ClientAuth{\n+\t\t\t\t\t\tClientAuthType: \"foobar\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedError: 1,\n+\t\t},\n \t}\n-\n \tfor _, test := range testCases {\n \t\ttest := test\n \t\tt.Run(test.desc, func(t *testing.T) {\n@@ -711,17 +777,23 @@ func TestRuntimeConfiguration(t *testing.T) {\n \t\t\t\t\tRouters:     test.routerConfig,\n \t\t\t\t\tMiddlewares: test.middlewareConfig,\n \t\t\t\t},\n+\t\t\t\tTLS: &dynamic.TLSConfiguration{\n+\t\t\t\t\tOptions: test.tlsOptions,\n+\t\t\t\t},\n \t\t\t})\n \n \t\t\troundTripperManager := service.NewRoundTripperManager()\n \t\t\troundTripperManager.Update(map[string]*dynamic.ServersTransport{\"default@internal\": {}})\n \t\t\tserviceManager := service.NewManager(rtConf.Services, nil, nil, roundTripperManager)\n \t\t\tmiddlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, nil)\n \t\t\tchainBuilder := middleware.NewChainBuilder(nil, nil, nil)\n+\t\t\ttlsManager := tls.NewManager()\n+\t\t\ttlsManager.UpdateConfigs(context.Background(), nil, test.tlsOptions, nil)\n \n-\t\t\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry())\n+\t\t\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry(), tlsManager)\n \n \t\t\t_ = routerManager.BuildHandlers(context.Background(), entryPoints, false)\n+\t\t\t_ = routerManager.BuildHandlers(context.Background(), entryPoints, true)\n \n \t\t\t// even though rtConf was passed by argument to the manager builders above,\n \t\t\t// it's ok to use it as the result we check, because everything worth checking\n@@ -793,8 +865,9 @@ func TestProviderOnMiddlewares(t *testing.T) {\n \tserviceManager := service.NewManager(rtConf.Services, nil, nil, roundTripperManager)\n \tmiddlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, nil)\n \tchainBuilder := middleware.NewChainBuilder(nil, nil, nil)\n+\ttlsManager := tls.NewManager()\n \n-\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry())\n+\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry(), tlsManager)\n \n \t_ = routerManager.BuildHandlers(context.Background(), entryPoints, false)\n \n@@ -861,8 +934,9 @@ func BenchmarkRouterServe(b *testing.B) {\n \tserviceManager := service.NewManager(rtConf.Services, nil, nil, staticRoundTripperGetter{res})\n \tmiddlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, nil)\n \tchainBuilder := middleware.NewChainBuilder(nil, nil, nil)\n+\ttlsManager := tls.NewManager()\n \n-\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry())\n+\trouterManager := NewManager(rtConf, serviceManager, middlewaresBuilder, chainBuilder, metrics.NewVoidRegistry(), tlsManager)\n \n \thandlers := routerManager.BuildHandlers(context.Background(), entryPoints, false)\n "
        },
        {
          "filename": "pkg/server/router/tcp/manager.go",
          "status": "modified",
          "additions": 94,
          "deletions": 48,
          "patch": "@@ -103,18 +103,21 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \n \trouter.SetHTTPHandler(handlerHTTP)\n \n+\t// Even though the error is seemingly ignored (aside from logging it),\n+\t// we actually rely later on the fact that a tls config is nil (which happens when an error is returned) to take special steps\n+\t// when assigning a handler to a route.\n \tdefaultTLSConf, err := m.tlsManager.Get(traefiktls.DefaultTLSStoreName, traefiktls.DefaultTLSConfigName)\n \tif err != nil {\n \t\tlog.FromContext(ctx).Errorf(\"Error during the build of the default TLS configuration: %v\", err)\n \t}\n \n-\t// Keyed by domain. The source of truth for doing SNI checking, and for what TLS\n-\t// options will actually be used for the connection.\n+\t// Keyed by domain. The source of truth for doing SNI checking (domain fronting).\n \t// As soon as there's (at least) two different tlsOptions found for the same domain,\n \t// we set the value to the default TLS conf.\n \ttlsOptionsForHost := map[string]string{}\n \n \t// Keyed by domain, then by options reference.\n+\t// The actual source of truth for what TLS options will actually be used for the connection.\n \t// As opposed to tlsOptionsForHost, it keeps track of all the (different) TLS\n \t// options that occur for a given host name, so that later on we can set relevant\n \t// errors and logging for all the routers concerned (i.e. wrongly configured).\n@@ -142,21 +145,20 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\t}\n \n \t\tif len(domains) == 0 {\n-\t\t\t// Extra Host(*) rule, for HTTPS routers with no Host rule, and for requests for\n-\t\t\t// which the SNI does not match _any_ of the other existing routers Host. This is\n-\t\t\t// only about choosing the TLS configuration. The actual routing will be done\n-\t\t\t// further on by the HTTPS handler. See examples below.\n+\t\t\t// Extra Host(*) rule, for HTTPS routers with no Host rule,\n+\t\t\t// and for requests for which the SNI does not match _any_ of the other existing routers Host.\n+\t\t\t// This is only about choosing the TLS configuration.\n+\t\t\t// The actual routing will be done further on by the HTTPS handler.\n+\t\t\t// See examples below.\n \t\t\trouter.AddHTTPTLSConfig(\"*\", defaultTLSConf)\n \n-\t\t\t// The server name (from a Host(SNI) rule) is the only parameter (available in\n-\t\t\t// HTTP routing rules) on which we can map a TLS config, because it is the only one\n-\t\t\t// accessible before decryption (we obtain it during the ClientHello). Therefore,\n-\t\t\t// when a router has no Host rule, it does not make any sense to specify some TLS\n-\t\t\t// options. Consequently, when it comes to deciding what TLS config will be used,\n-\t\t\t// for a request that will match an HTTPS router with no Host rule, the result will\n-\t\t\t// depend on the _others_ existing routers (their Host rule, to be precise), and\n-\t\t\t// the TLS options associated with them, even though they don't match the incoming\n-\t\t\t// request. Consider the following examples:\n+\t\t\t// The server name (from a Host(SNI) rule) is the only parameter (available in HTTP routing rules) on which we can map a TLS config,\n+\t\t\t// because it is the only one accessible before decryption (we obtain it during the ClientHello).\n+\t\t\t// Therefore, when a router has no Host rule, it does not make any sense to specify some TLS options.\n+\t\t\t// Consequently, when it comes to deciding what TLS config will be used,\n+\t\t\t// for a request that will match an HTTPS router with no Host rule,\n+\t\t\t// the result will depend on the _others_ existing routers (their Host rule, to be precise), and the TLS options associated with them,\n+\t\t\t// even though they don't match the incoming request. Consider the following examples:\n \n \t\t\t//\t# conf1\n \t\t\t//\thttpRouter1:\n@@ -170,17 +172,19 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\t\t//\thttpRouter2:\n \t\t\t//\t\trule: Host(\"foo.com\") && PathPrefix(\"/bar\")\n \t\t\t//\t\ttlsoptions: myTLSOptions\n-\t\t\t//\t# When a request for \"/foo\" comes, even though it won't be routed by\n-\t\t\t//\thttpRouter2, if its SNI is set to foo.com, myTLSOptions will be used for the TLS\n-\t\t\t//\tconnection. Otherwise, it will fallback to the default TLS config.\n+\t\t\t//\t# When a request for \"/foo\" comes, even though it won't be routed by httpRouter2,\n+\t\t\t//\t# if its SNI is set to foo.com, myTLSOptions will be used for the TLS connection.\n+\t\t\t//\t# Otherwise, it will fallback to the default TLS config.\n \t\t\tlogger.Warnf(\"No domain found in rule %v, the TLS options applied for this router will depend on the SNI of each request\", routerHTTPConfig.Rule)\n \t\t}\n \n-\t\ttlsConf, err := m.tlsManager.Get(traefiktls.DefaultTLSStoreName, tlsOptionsName)\n-\t\tif err != nil {\n-\t\t\trouterHTTPConfig.AddError(err, true)\n-\t\t\tlogger.Error(err)\n-\t\t\tcontinue\n+\t\t// Even though the error is seemingly ignored (aside from logging it),\n+\t\t// we actually rely later on the fact that a tls config is nil (which happens when an error is returned) to take special steps\n+\t\t// when assigning a handler to a route.\n+\t\ttlsConf, tlsConfErr := m.tlsManager.Get(traefiktls.DefaultTLSStoreName, tlsOptionsName)\n+\t\tif tlsConfErr != nil {\n+\t\t\t// Note: we do not call AddError here because we already did so when buildRouterHandler errored for the same reason.\n+\t\t\tlogger.Error(tlsConfErr)\n \t\t}\n \n \t\tfor _, domain := range domains {\n@@ -204,6 +208,7 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \n \tsniCheck := snicheck.New(tlsOptionsForHost, handlerHTTPS)\n \n+\t// Keep in mind that defaultTLSConf might be nil here.\n \trouter.SetHTTPSHandler(sniCheck, defaultTLSConf)\n \n \tlogger := log.FromContext(ctx)\n@@ -217,22 +222,42 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\t\t\tbreak\n \t\t\t}\n \n-\t\t\tlogger.Debugf(\"Adding route for %s with TLS options %s\", hostSNI, optionsName)\n+\t\t\tif config == nil {\n+\t\t\t\t// we use nil config as a signal to insert a handler\n+\t\t\t\t// that enforces that TLS connection attempts to the corresponding (broken) router should fail.\n+\t\t\t\tlogger.Debugf(\"Adding special closing route for %s because broken TLS options %s\", hostSNI, optionsName)\n+\t\t\t\trouter.AddHTTPTLSConfig(hostSNI, nil)\n+\t\t\t\tcontinue\n+\t\t\t}\n \n+\t\t\tlogger.Debugf(\"Adding route for %s with TLS options %s\", hostSNI, optionsName)\n \t\t\trouter.AddHTTPTLSConfig(hostSNI, config)\n-\t\t} else {\n-\t\t\trouters := make([]string, 0, len(tlsConfigs))\n-\t\t\tfor _, v := range tlsConfigs {\n-\t\t\t\tconfigsHTTP[v.routerName].AddError(fmt.Errorf(\"found different TLS options for routers on the same host %v, so using the default TLS options instead\", hostSNI), false)\n-\t\t\t\trouters = append(routers, v.routerName)\n-\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// multiple tlsConfigs\n \n-\t\t\tlogger.Warnf(\"Found different TLS options for routers on the same host %v, so using the default TLS options instead for these routers: %#v\", hostSNI, routers)\n+\t\trouters := make([]string, 0, len(tlsConfigs))\n+\t\tfor _, v := range tlsConfigs {\n+\t\t\tconfigsHTTP[v.routerName].AddError(fmt.Errorf(\"found different TLS options for routers on the same host %v, so using the default TLS options instead\", hostSNI), false)\n+\t\t\trouters = append(routers, v.routerName)\n+\t\t}\n \n-\t\t\trouter.AddHTTPTLSConfig(hostSNI, defaultTLSConf)\n+\t\tlogger.Warnf(\"Found different TLS options for routers on the same host %v, so using the default TLS options instead for these routers: %#v\", hostSNI, routers)\n+\t\tif defaultTLSConf == nil {\n+\t\t\tlogger.Debugf(\"Adding special closing route for %s because broken default TLS options\", hostSNI)\n \t\t}\n+\n+\t\trouter.AddHTTPTLSConfig(hostSNI, defaultTLSConf)\n \t}\n \n+\tm.addTCPHandlers(ctx, configs, router)\n+\n+\treturn router, nil\n+}\n+\n+// addTCPHandlers creates the TCP handlers defined in configs, and adds them to router.\n+func (m *Manager) addTCPHandlers(ctx context.Context, configs map[string]*runtime.TCPRouterInfo, router *Router) {\n \tfor routerName, routerConfig := range configs {\n \t\tctxRouter := log.With(provider.AddInContext(ctx, routerName), log.Str(log.RouterName, routerName))\n \t\tlogger := log.FromContext(ctxRouter)\n@@ -251,13 +276,6 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\t\tcontinue\n \t\t}\n \n-\t\thandler, err := m.buildTCPHandler(ctxRouter, routerConfig)\n-\t\tif err != nil {\n-\t\t\trouterConfig.AddError(err, true)\n-\t\t\tlogger.Error(err)\n-\t\t\tcontinue\n-\t\t}\n-\n \t\tdomains, err := tcpmuxer.ParseHostSNI(routerConfig.Rule)\n \t\tif err != nil {\n \t\t\trouterErr := fmt.Errorf(\"invalid rule: %q , %w\", routerConfig.Rule, err)\n@@ -274,6 +292,16 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\t\tlogger.Error(routerErr)\n \t\t}\n \n+\t\tvar handler tcp.Handler\n+\t\tif routerConfig.TLS == nil || routerConfig.TLS.Passthrough {\n+\t\t\thandler, err = m.buildTCPHandler(ctxRouter, routerConfig)\n+\t\t\tif err != nil {\n+\t\t\t\trouterConfig.AddError(err, true)\n+\t\t\t\tlogger.Error(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n \t\tif routerConfig.TLS == nil {\n \t\t\tlogger.Debugf(\"Adding route for %q\", routerConfig.Rule)\n \t\t\tif err := router.AddRoute(routerConfig.Rule, routerConfig.Priority, handler); err != nil {\n@@ -285,7 +313,7 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \n \t\tif routerConfig.TLS.Passthrough {\n \t\t\tlogger.Debugf(\"Adding Passthrough route for %q\", routerConfig.Rule)\n-\t\t\tif err := router.AddRouteTLS(routerConfig.Rule, routerConfig.Priority, handler, nil); err != nil {\n+\t\t\tif err := router.muxerTCPTLS.AddRoute(routerConfig.Rule, routerConfig.Priority, handler); err != nil {\n \t\t\t\trouterConfig.AddError(err, true)\n \t\t\t\tlogger.Error(err)\n \t\t\t}\n@@ -315,7 +343,15 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\ttlsConf, err := m.tlsManager.Get(traefiktls.DefaultTLSStoreName, tlsOptionsName)\n \t\tif err != nil {\n \t\t\trouterConfig.AddError(err, true)\n+\n \t\t\tlogger.Error(err)\n+\t\t\tlogger.Debugf(\"Adding special TLS closing route for %q because broken TLS options %s\", routerConfig.Rule, tlsOptionsName)\n+\n+\t\t\terr = router.muxerTCPTLS.AddRoute(routerConfig.Rule, routerConfig.Priority, &brokenTLSRouter{})\n+\t\t\tif err != nil {\n+\t\t\t\trouterConfig.AddError(err, true)\n+\t\t\t\tlogger.Error(err)\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \n@@ -327,20 +363,30 @@ func (m *Manager) buildEntryPointHandler(ctx context.Context, configs map[string\n \t\t//\t\trule: HostSNI(foo.com) && ClientIP(IP2)\n \t\t//\t\ttlsOption: tlsTwo\n \t\t// i.e. same HostSNI but different tlsOptions\n-\t\t// This is only applicable if the muxer can decide about the routing _before_\n-\t\t// telling the client about the tlsConf (i.e. before the TLS HandShake). This seems\n-\t\t// to be the case so far with the existing matchers (HostSNI, and ClientIP), so\n-\t\t// it's all good. Otherwise, we would have to do as for HTTPS, i.e. disallow\n-\t\t// different TLS configs for the same HostSNIs.\n+\t\t// This is only applicable if the muxer can decide about the routing _before_ telling the client about the tlsConf (i.e. before the TLS HandShake).\n+\t\t// This seems to be the case so far with the existing matchers (HostSNI, and ClientIP), so it's all good.\n+\t\t// Otherwise, we would have to do as for HTTPS, i.e. disallow different TLS configs for the same HostSNIs.\n+\n+\t\thandler, err = m.buildTCPHandler(ctxRouter, routerConfig)\n+\t\tif err != nil {\n+\t\t\trouterConfig.AddError(err, true)\n+\t\t\tlogger.Error(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\thandler = &tcp.TLSHandler{\n+\t\t\tNext:   handler,\n+\t\t\tConfig: tlsConf,\n+\t\t}\n \n \t\tlogger.Debugf(\"Adding TLS route for %q\", routerConfig.Rule)\n-\t\tif err := router.AddRouteTLS(routerConfig.Rule, routerConfig.Priority, handler, tlsConf); err != nil {\n+\n+\t\terr = router.muxerTCPTLS.AddRoute(routerConfig.Rule, routerConfig.Priority, handler)\n+\t\tif err != nil {\n \t\t\trouterConfig.AddError(err, true)\n \t\t\tlogger.Error(err)\n \t\t}\n \t}\n-\n-\treturn router, nil\n }\n \n func (m *Manager) buildTCPHandler(ctx context.Context, router *runtime.TCPRouterInfo) (tcp.Handler, error) {"
        },
        {
          "filename": "pkg/server/router/tcp/router.go",
          "status": "modified",
          "additions": 54,
          "deletions": 44,
          "patch": "@@ -27,19 +27,20 @@ type Router struct {\n \tmuxerHTTPS tcpmuxer.Muxer\n \n \t// Forwarder handlers.\n-\t// Handles all HTTP requests.\n+\t// httpForwarder handles all HTTP requests.\n \thttpForwarder tcp.Handler\n-\t// Handles (indirectly through muxerHTTPS, or directly) all HTTPS requests.\n+\t// httpsForwarder handles (indirectly through muxerHTTPS, or directly) all HTTPS requests.\n \thttpsForwarder tcp.Handler\n \n-\t// Neither is used directly, but they are held here, and recreated on config\n-\t// reload, so that they can be passed to the Switcher at the end of the config\n-\t// reload phase.\n+\t// Neither is used directly, but they are held here, and recreated on config reload,\n+\t// so that they can be passed to the Switcher at the end of the config reload phase.\n \thttpHandler  http.Handler\n \thttpsHandler http.Handler\n \n \t// TLS configs.\n-\thttpsTLSConfig    *tls.Config            // default TLS config\n+\thttpsTLSConfig *tls.Config // default TLS config\n+\t// hostHTTPTLSConfig contains TLS configs keyed by SNI.\n+\t// A nil config is the hint to set up a brokenTLSRouter.\n \thostHTTPTLSConfig map[string]*tls.Config // TLS configs keyed by SNI\n }\n \n@@ -80,11 +81,11 @@ func (r *Router) GetTLSGetClientInfo() func(info *tls.ClientHelloInfo) (*tls.Con\n \n // ServeTCP forwards the connection to the right TCP/HTTP handler.\n func (r *Router) ServeTCP(conn tcp.WriteCloser) {\n-\t// Handling Non-TLS TCP connection early if there is neither HTTP(S) nor TLS\n-\t// routers on the entryPoint, and if there is at least one non-TLS TCP router.\n-\t// In the case of a non-TLS TCP client (that does not \"send\" first), we would\n-\t// block forever on clientHelloInfo, which is why we want to detect and\n-\t// handle that case first and foremost.\n+\t// Handling Non-TLS TCP connection early if there is neither HTTP(S) nor TLS routers on the entryPoint,\n+\t// and if there is at least one non-TLS TCP router.\n+\t// In the case of a non-TLS TCP client (that does not \"send\" first),\n+\t// we would block forever on clientHelloInfo,\n+\t// which is why we want to detect and handle that case first and foremost.\n \tif r.muxerTCP.HasRoutes() && !r.muxerTCPTLS.HasRoutes() && !r.muxerHTTPS.HasRoutes() {\n \t\tconnData, err := tcpmuxer.NewConnData(\"\", conn, nil)\n \t\tif err != nil {\n@@ -152,9 +153,9 @@ func (r *Router) ServeTCP(conn tcp.WriteCloser) {\n \t// (wrapped inside the returned handler) requested for the given HostSNI.\n \thandlerHTTPS, catchAllHTTPS := r.muxerHTTPS.Match(connData)\n \tif handlerHTTPS != nil && !catchAllHTTPS {\n-\t\t// In order not to depart from the behavior in 2.6, we only allow an HTTPS router\n-\t\t// to take precedence over a TCP-TLS router if it is _not_ an HostSNI(*) router (so\n-\t\t// basically any router that has a specific HostSNI based rule).\n+\t\t// In order not to depart from the behavior in 2.6,\n+\t\t// we only allow an HTTPS router to take precedence over a TCP-TLS router if it is _not_ an HostSNI(*) router\n+\t\t// (so basically any router that has a specific HostSNI based rule).\n \t\thandlerHTTPS.ServeTCP(r.GetConn(conn, hello.peeked))\n \t\treturn\n \t}\n@@ -180,7 +181,7 @@ func (r *Router) ServeTCP(conn tcp.WriteCloser) {\n \t\treturn\n \t}\n \n-\t// needed to handle 404s for HTTPS, as well as all non-Host (e.g. PathPrefix) matches.\n+\t// To handle 404s for HTTPS.\n \tif r.httpsForwarder != nil {\n \t\tr.httpsForwarder.ServeTCP(r.GetConn(conn, hello.peeked))\n \t\treturn\n@@ -194,19 +195,6 @@ func (r *Router) AddRoute(rule string, priority int, target tcp.Handler) error {\n \treturn r.muxerTCP.AddRoute(rule, priority, target)\n }\n \n-// AddRouteTLS defines a handler for a given rule and sets the matching tlsConfig.\n-func (r *Router) AddRouteTLS(rule string, priority int, target tcp.Handler, config *tls.Config) error {\n-\t// TLS PassThrough\n-\tif config == nil {\n-\t\treturn r.muxerTCPTLS.AddRoute(rule, priority, target)\n-\t}\n-\n-\treturn r.muxerTCPTLS.AddRoute(rule, priority, &tcp.TLSHandler{\n-\t\tNext:   target,\n-\t\tConfig: config,\n-\t})\n-}\n-\n // AddHTTPTLSConfig defines a handler for a given sniHost and sets the matching tlsConfig.\n func (r *Router) AddHTTPTLSConfig(sniHost string, config *tls.Config) {\n \tif r.hostHTTPTLSConfig == nil {\n@@ -242,20 +230,44 @@ func (r *Router) SetHTTPForwarder(handler tcp.Handler) {\n \tr.httpForwarder = handler\n }\n \n-// SetHTTPSForwarder sets the tcp handler that will forward the TLS connections to an http handler.\n+// brokenTLSRouter is associated to a Host(SNI) rule for which we know the TLS conf is broken.\n+// It is used to make sure any attempt to connect to that hostname is closed,\n+// since we cannot proceed with the intended TLS conf.\n+type brokenTLSRouter struct{}\n+\n+// ServeTCP instantly closes the connection.\n+func (t *brokenTLSRouter) ServeTCP(conn tcp.WriteCloser) {\n+\t_ = conn.Close()\n+}\n+\n+// SetHTTPSForwarder sets the tcp handler that will forward the TLS connections to an HTTP handler.\n+// It also sets up each TLS handler (with its TLS config) for each Host(SNI) rule we previously kept track of.\n+// It sets up a special handler that closes the connection if a TLS config is nil.\n func (r *Router) SetHTTPSForwarder(handler tcp.Handler) {\n \tfor sniHost, tlsConf := range r.hostHTTPTLSConfig {\n+\t\tvar tcpHandler tcp.Handler\n+\t\tif tlsConf == nil {\n+\t\t\ttcpHandler = &brokenTLSRouter{}\n+\t\t} else {\n+\t\t\ttcpHandler = &tcp.TLSHandler{\n+\t\t\t\tNext:   handler,\n+\t\t\t\tConfig: tlsConf,\n+\t\t\t}\n+\t\t}\n+\n \t\t// muxerHTTPS only contains single HostSNI rules (and no other kind of rules),\n \t\t// so there's no need for specifying a priority for them.\n-\t\terr := r.muxerHTTPS.AddRoute(\"HostSNI(`\"+sniHost+\"`)\", 0, &tcp.TLSHandler{\n-\t\t\tNext:   handler,\n-\t\t\tConfig: tlsConf,\n-\t\t})\n+\t\terr := r.muxerHTTPS.AddRoute(\"HostSNI(`\"+sniHost+\"`)\", 0, tcpHandler)\n \t\tif err != nil {\n \t\t\tlog.WithoutContext().Errorf(\"Error while adding route for host: %v\", err)\n \t\t}\n \t}\n \n+\tif r.httpsTLSConfig == nil {\n+\t\tr.httpsForwarder = &brokenTLSRouter{}\n+\t\treturn\n+\t}\n+\n \tr.httpsForwarder = &tcp.TLSHandler{\n \t\tNext:   handler,\n \t\tConfig: r.httpsTLSConfig,\n@@ -275,15 +287,14 @@ func (r *Router) SetHTTPSHandler(handler http.Handler, config *tls.Config) {\n \n // Conn is a connection proxy that handles Peeked bytes.\n type Conn struct {\n-\t// Peeked are the bytes that have been read from Conn for the\n-\t// purposes of route matching, but have not yet been consumed\n-\t// by Read calls. It set to nil by Read when fully consumed.\n+\t// Peeked are the bytes that have been read from Conn for the purposes of route matching,\n+\t// but have not yet been consumed by Read calls.\n+\t// It set to nil by Read when fully consumed.\n \tPeeked []byte\n \n \t// Conn is the underlying connection.\n-\t// It can be type asserted against *net.TCPConn or other types\n-\t// as needed. It should not be read from directly unless\n-\t// Peeked is nil.\n+\t// It can be type asserted against *net.TCPConn or other types as needed.\n+\t// It should not be read from directly unless Peeked is nil.\n \ttcp.WriteCloser\n }\n \n@@ -320,15 +331,14 @@ func clientHelloInfo(br *bufio.Reader) (*clientHello, error) {\n \t\treturn nil, err\n \t}\n \n-\t// No valid TLS record has a type of 0x80, however SSLv2 handshakes\n-\t// start with a uint16 length where the MSB is set and the first record\n-\t// is always < 256 bytes long. Therefore typ == 0x80 strongly suggests\n-\t// an SSLv2 client.\n+\t// No valid TLS record has a type of 0x80, however SSLv2 handshakes start with an uint16 length\n+\t// where the MSB is set and the first record is always < 256 bytes long.\n+\t// Therefore, typ == 0x80 strongly suggests an SSLv2 client.\n \tconst recordTypeSSLv2 = 0x80\n \tconst recordTypeHandshake = 0x16\n \tif hdr[0] != recordTypeHandshake {\n \t\tif hdr[0] == recordTypeSSLv2 {\n-\t\t\t// we consider SSLv2 as TLS and it will be refused by real TLS handshake.\n+\t\t\t// we consider SSLv2 as TLS, and it will be refused by real TLS handshake.\n \t\t\treturn &clientHello{\n \t\t\t\tisTLS:  true,\n \t\t\t\tpeeked: getPeeked(br),"
        },
        {
          "filename": "pkg/server/routerfactory.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -72,7 +72,7 @@ func (f *RouterFactory) CreateRouters(rtConf *runtime.Configuration) (map[string\n \n \tmiddlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, f.pluginBuilder)\n \n-\trouterManager := router.NewManager(rtConf, serviceManager, middlewaresBuilder, f.chainBuilder, f.metricsRegistry)\n+\trouterManager := router.NewManager(rtConf, serviceManager, middlewaresBuilder, f.chainBuilder, f.metricsRegistry, f.tlsManager)\n \n \thandlersNonTLS := routerManager.BuildHandlers(ctx, f.entryPointsTCP, false)\n \thandlersTLS := routerManager.BuildHandlers(ctx, f.entryPointsTCP, true)"
        },
        {
          "filename": "pkg/tls/tlsmanager.go",
          "status": "modified",
          "additions": 13,
          "deletions": 19,
          "patch": "@@ -157,27 +157,24 @@ func (m *Manager) Get(storeName, configName string) (*tls.Config, error) {\n \tm.lock.RLock()\n \tdefer m.lock.RUnlock()\n \n-\tvar tlsConfig *tls.Config\n-\tvar err error\n-\n \tsniStrict := false\n \tconfig, ok := m.configs[configName]\n-\tif ok {\n-\t\tsniStrict = config.SniStrict\n-\t\ttlsConfig, err = buildTLSConfig(config)\n-\t} else {\n-\t\terr = fmt.Errorf(\"unknown TLS options: %s\", configName)\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"unknown TLS options: %s\", configName)\n \t}\n+\n+\tsniStrict = config.SniStrict\n+\ttlsConfig, err := buildTLSConfig(config)\n \tif err != nil {\n-\t\ttlsConfig = &tls.Config{}\n+\t\treturn nil, fmt.Errorf(\"building TLS config: %w\", err)\n \t}\n \n \tstore := m.getStore(storeName)\n \tif store == nil {\n \t\terr = fmt.Errorf(\"TLS store %s not found\", storeName)\n \t}\n \tacmeTLSStore := m.getStore(tlsalpn01.ACMETLS1Protocol)\n-\tif acmeTLSStore == nil {\n+\tif acmeTLSStore == nil && err == nil {\n \t\terr = fmt.Errorf(\"ACME TLS store %s not found\", tlsalpn01.ACMETLS1Protocol)\n \t}\n \n@@ -188,15 +185,12 @@ func (m *Manager) Get(storeName, configName string) (*tls.Config, error) {\n \t\t\tcertificate := acmeTLSStore.GetBestCertificate(clientHello)\n \t\t\tif certificate == nil {\n \t\t\t\tlog.WithoutContext().Debugf(\"TLS: no certificate for TLSALPN challenge: %s\", domainToCheck)\n-\t\t\t\t// We want the user to eventually get the (alertUnrecognizedName) \"unrecognized\n-\t\t\t\t// name\" error.\n-\t\t\t\t// Unfortunately, if we returned an error here, since we can't use\n-\t\t\t\t// the unexported error (errNoCertificates) that our caller (config.getCertificate\n-\t\t\t\t// in crypto/tls) uses as a sentinel, it would report an (alertInternalError)\n-\t\t\t\t// \"internal error\" instead of an alertUnrecognizedName.\n-\t\t\t\t// Which is why we return no error, and we let the caller detect that there's\n-\t\t\t\t// actually no certificate, and fall back into the flow that will report\n-\t\t\t\t// the desired error.\n+\t\t\t\t// We want the user to eventually get the (alertUnrecognizedName) \"unrecognized name\" error.\n+\t\t\t\t// Unfortunately, if we returned an error here,\n+\t\t\t\t// since we can't use the unexported error (errNoCertificates) that our caller (config.getCertificate in crypto/tls) uses as a sentinel,\n+\t\t\t\t// it would report an (alertInternalError) \"internal error\" instead of an alertUnrecognizedName.\n+\t\t\t\t// Which is why we return no error, and we let the caller detect that there's actually no certificate,\n+\t\t\t\t// and fall back into the flow that will report the desired error.\n \t\t\t\t// https://cs.opensource.google/go/go/+/dev.boringcrypto.go1.17:src/crypto/tls/common.go;l=1058\n \t\t\t\treturn nil, nil\n \t\t\t}"
        },
        {
          "filename": "pkg/tls/tlsmanager_test.go",
          "status": "modified",
          "additions": 13,
          "deletions": 36,
          "patch": "@@ -119,8 +119,9 @@ func TestManager_Get(t *testing.T) {\n \t}}\n \n \ttlsConfigs := map[string]Options{\n-\t\t\"foo\": {MinVersion: \"VersionTLS12\"},\n-\t\t\"bar\": {MinVersion: \"VersionTLS11\"},\n+\t\t\"foo\":     {MinVersion: \"VersionTLS12\"},\n+\t\t\"bar\":     {MinVersion: \"VersionTLS11\"},\n+\t\t\"invalid\": {CurvePreferences: []string{\"42\"}},\n \t}\n \n \ttestCases := []struct {\n@@ -140,15 +141,20 @@ func TestManager_Get(t *testing.T) {\n \t\t\texpectedMinVersion: uint16(tls.VersionTLS11),\n \t\t},\n \t\t{\n-\t\t\tdesc:           \"Get an tls config from an invalid name\",\n+\t\t\tdesc:           \"Get a tls config from an invalid name\",\n \t\t\ttlsOptionsName: \"unknown\",\n \t\t\texpectedError:  true,\n \t\t},\n \t\t{\n-\t\t\tdesc:           \"Get an tls config from unexisting 'default' name\",\n+\t\t\tdesc:           \"Get a tls config from unexisting 'default' name\",\n \t\t\ttlsOptionsName: \"default\",\n \t\t\texpectedError:  true,\n \t\t},\n+\t\t{\n+\t\t\tdesc:           \"Get an invalid tls config\",\n+\t\t\ttlsOptionsName: \"invalid\",\n+\t\t\texpectedError:  true,\n+\t\t},\n \t}\n \n \ttlsManager := NewManager()\n@@ -161,42 +167,13 @@ func TestManager_Get(t *testing.T) {\n \n \t\t\tconfig, err := tlsManager.Get(\"default\", test.tlsOptionsName)\n \t\t\tif test.expectedError {\n-\t\t\t\tassert.Error(t, err)\n+\t\t\t\trequire.Nil(t, config)\n+\t\t\t\trequire.Error(t, err)\n \t\t\t\treturn\n \t\t\t}\n \n-\t\t\tassert.NoError(t, err)\n-\t\t\tassert.Equal(t, config.MinVersion, test.expectedMinVersion)\n-\t\t})\n-\t}\n-}\n-\n-func TestManager_Get_GetCertificate(t *testing.T) {\n-\ttestCases := []struct {\n-\t\tdesc                 string\n-\t\texpectedGetConfigErr require.ErrorAssertionFunc\n-\t\texpectedCertificate  assert.ValueAssertionFunc\n-\t}{\n-\t\t{\n-\t\t\tdesc:                 \"Get a default certificate from non-existing store\",\n-\t\t\texpectedGetConfigErr: require.Error,\n-\t\t\texpectedCertificate:  assert.Nil,\n-\t\t},\n-\t}\n-\n-\ttlsManager := NewManager()\n-\n-\tfor _, test := range testCases {\n-\t\ttest := test\n-\t\tt.Run(test.desc, func(t *testing.T) {\n-\t\t\tt.Parallel()\n-\n-\t\t\tconfig, err := tlsManager.Get(\"default\", \"foo\")\n-\t\t\ttest.expectedGetConfigErr(t, err)\n-\n-\t\t\tcertificate, err := config.GetCertificate(&tls.ClientHelloInfo{})\n \t\t\trequire.NoError(t, err)\n-\t\t\ttest.expectedCertificate(t, certificate)\n+\t\t\tassert.Equal(t, config.MinVersion, test.expectedMinVersion)\n \t\t})\n \t}\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 7,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "95dd17e0200e5a861e4519675d2f37acfc7b95eb",
            "date": "2025-01-09T16:20:06Z",
            "author_login": "yelvert"
          },
          {
            "sha": "b0a72960bcd43124cbd010001482fddd386bff58",
            "date": "2025-01-08T10:29:59Z",
            "author_login": "kevinpollet"
          },
          {
            "sha": "a57e118a1a666d22617f10cc9440760d1299d6ea",
            "date": "2025-01-08T10:10:59Z",
            "author_login": "kevinpollet"
          },
          {
            "sha": "d2414feaff6d00b6d180c643ac950a0eea25812e",
            "date": "2025-01-08T10:02:37Z",
            "author_login": "kevinpollet"
          },
          {
            "sha": "6aa56788ea78ddccf388bca63a2893a48833ce95",
            "date": "2025-01-08T08:36:04Z",
            "author_login": "jspiers"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-295",
    "description": "Traefik is an open source HTTP reverse proxy and load balancer. In affected versions there is a potential vulnerability in Traefik managing TLS connections. A router configured with a not well-formatted TLSOption is exposed with an empty TLSOption. For instance, a route secured using an mTLS connection set with a wrong CA file is exposed without verifying the client certificates. Users are advised to upgrade to version 2.9.6. Users unable to upgrade should check their logs to detect the error messages and fix your TLS options.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-08T22:15:10.563",
    "last_modified": "2024-11-21T07:30:12.953",
    "fix_date": "2022-12-06T17:28:05Z"
  },
  "references": [
    {
      "url": "https://doc.traefik.io/traefik/v2.9/https/tls/#tls-options",
      "source": "security-advisories@github.com",
      "tags": [
        "Product",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/traefik/traefik/commit/7e3fe48b80083b41e9ff82a474a36484cabc701a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/traefik/traefik/releases/tag/v2.9.6",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/traefik/traefik/security/advisories/GHSA-468w-8x39-gj5v",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://doc.traefik.io/traefik/v2.9/https/tls/#tls-options",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/traefik/traefik/commit/7e3fe48b80083b41e9ff82a474a36484cabc701a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/traefik/traefik/releases/tag/v2.9.6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/traefik/traefik/security/advisories/GHSA-468w-8x39-gj5v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:21.216903",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "traefik",
    "owner": "traefik",
    "created_at": "2015-09-13T19:04:02Z",
    "updated_at": "2025-01-14T13:58:16Z",
    "pushed_at": "2025-01-14T14:06:52Z",
    "size": 137630,
    "stars": 52693,
    "forks": 5174,
    "open_issues": 650,
    "watchers": 52693,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "v1.0",
      "v1.1",
      "v1.2",
      "v1.3",
      "v1.4",
      "v1.5",
      "v1.6",
      "v1.7",
      "v2.0",
      "v2.1",
      "v2.2",
      "v2.3",
      "v2.4",
      "v2.5",
      "v2.6",
      "v2.7",
      "v2.8",
      "v2.9",
      "v2.10",
      "v2.11",
      "v3.0",
      "v3.1",
      "v3.2",
      "v3.3"
    ],
    "languages": {
      "Go": 4580258,
      "Vue": 209833,
      "JavaScript": 86371,
      "Shell": 9816,
      "SCSS": 7832,
      "Makefile": 6463,
      "HTML": 1362,
      "Dockerfile": 1345
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T14:10:20.925864"
  }
}