{
  "cve_id": "CVE-2022-46174",
  "github_data": {
    "repository": "aws/efs-utils",
    "fix_commit": "f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d",
    "related_commits": [
      "f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d",
      "f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d"
    ],
    "patch_url": "https://github.com/aws/efs-utils/commit/f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d.patch",
    "fix_commit_details": {
      "sha": "f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d",
      "commit_date": "2022-12-14T06:13:07Z",
      "author": {
        "login": "RyanStan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": " Fix potential tlsport selection collision by using state file as",
        "length": 224,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 164,
        "additions": 130,
        "deletions": 34
      },
      "files": [
        {
          "filename": "amazon-efs-utils.spec",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -35,7 +35,7 @@\n %endif\n \n Name      : amazon-efs-utils\n-Version   : 1.34.3\n+Version   : 1.34.4\n Release   : 1%{platform}\n Summary   : This package provides utilities for simplifying the use of EFS file systems\n \n@@ -137,6 +137,9 @@ fi\n %clean\n \n %changelog\n+* Tue Dec 13 2022 Ryan Stankiewicz <rjstank@amazon.com> - 1.34.4\n+- Fix potential tlsport selection collision by using state file as tlsport lock file.\n+\n * Thu Dec 1 2022 Preetham Puneeth Munipalli <tmunipre@amazon.com> - 1.34.3\n - Fix potential tlsport selection race condition by closing socket right before establishing stunnel\n - Fix stunnel constantly restart issue when upgrading from 1.32.1 and before version to latest version"
        },
        {
          "filename": "build-deb.sh",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -11,7 +11,7 @@ set -ex\n \n BASE_DIR=$(pwd)\n BUILD_ROOT=${BASE_DIR}/build/debbuild\n-VERSION=1.34.3\n+VERSION=1.34.4\n RELEASE=1\n DEB_SYSTEM_RELEASE_PATH=/etc/os-release\n "
        },
        {
          "filename": "config.ini",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -7,5 +7,5 @@\n #\n \n [global]\n-version=1.34.3\n+version=1.34.4\n release=1"
        },
        {
          "filename": "dist/amazon-efs-utils.control",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n Package: amazon-efs-utils\n Architecture: all\n-Version: 1.34.3\n+Version: 1.34.4\n Section: utils\n Depends: python3, nfs-common, stunnel4 (>= 4.56), openssl (>= 1.0.2), util-linux\n Priority: optional"
        },
        {
          "filename": "src/mount_efs/__init__.py",
          "status": "modified",
          "additions": 67,
          "deletions": 16,
          "patch": "@@ -85,7 +85,7 @@\n     BOTOCORE_PRESENT = False\n \n \n-VERSION = \"1.34.3\"\n+VERSION = \"1.34.4\"\n SERVICE = \"elasticfilesystem\"\n \n AMAZON_LINUX_2_RELEASE_ID = \"Amazon Linux release 2 (Karoo)\"\n@@ -939,7 +939,7 @@ def get_tls_port_range(config):\n     return lower_bound, upper_bound\n \n \n-def choose_tls_port_and_get_bind_sock(config, options):\n+def choose_tls_port_and_get_bind_sock(config, options, state_file_dir):\n     if \"tlsport\" in options:\n         ports_to_try = [int(options[\"tlsport\"])]\n     else:\n@@ -951,10 +951,14 @@ def choose_tls_port_and_get_bind_sock(config, options):\n         random.shuffle(ports_to_try)\n \n     if \"netns\" not in options:\n-        tls_port_sock = find_tls_port_in_range_and_get_bind_sock(ports_to_try)\n+        tls_port_sock = find_tls_port_in_range_and_get_bind_sock(\n+            ports_to_try, state_file_dir\n+        )\n     else:\n         with NetNS(nspath=options[\"netns\"]):\n-            tls_port_sock = find_tls_port_in_range_and_get_bind_sock(ports_to_try)\n+            tls_port_sock = find_tls_port_in_range_and_get_bind_sock(\n+                ports_to_try, state_file_dir\n+            )\n \n     if tls_port_sock:\n         return tls_port_sock\n@@ -971,20 +975,44 @@ def choose_tls_port_and_get_bind_sock(config, options):\n         )\n \n \n-def find_tls_port_in_range_and_get_bind_sock(ports_to_try):\n+def find_tls_port_in_range_and_get_bind_sock(ports_to_try, state_file_dir):\n     sock = socket.socket()\n     for tls_port in ports_to_try:\n+        mount = find_existing_mount_using_tls_port(state_file_dir, tls_port)\n+        if mount:\n+            logging.debug(\n+                \"Skip binding TLS port %s as it is already assigned to %s\",\n+                tls_port,\n+                mount,\n+            )\n+            continue\n         try:\n             logging.info(\"binding %s\", tls_port)\n             sock.bind((\"localhost\", tls_port))\n             return sock\n         except socket.error as e:\n-            logging.info(e)\n+            logging.warning(e)\n             continue\n     sock.close()\n     return None\n \n \n+def find_existing_mount_using_tls_port(state_file_dir, tls_port):\n+    if not os.path.exists(state_file_dir):\n+        logging.debug(\n+            \"State file dir %s does not exist, assuming no existing mount using tls port %s\",\n+            state_file_dir,\n+            tls_port,\n+        )\n+        return None\n+\n+    for fname in os.listdir(state_file_dir):\n+        if fname.endswith(\".%s\" % tls_port):\n+            return fname\n+\n+    return None\n+\n+\n def is_ocsp_enabled(config, options):\n     if \"ocsp\" in options:\n         return True\n@@ -1301,6 +1329,24 @@ def write_tls_tunnel_state_file(\n     return state_file\n \n \n+def rewrite_tls_tunnel_state_file(state, state_file_dir, state_file):\n+    with open(os.path.join(state_file_dir, state_file), \"w\") as f:\n+        json.dump(state, f)\n+    return state_file\n+\n+\n+def update_tls_tunnel_temp_state_file_with_tunnel_pid(\n+    temp_tls_state_file, state_file_dir, stunnel_pid\n+):\n+    with open(os.path.join(state_file_dir, temp_tls_state_file), \"r\") as f:\n+        state = json.load(f)\n+    state[\"pid\"] = stunnel_pid\n+    temp_tls_state_file = rewrite_tls_tunnel_state_file(\n+        state, state_file_dir, temp_tls_state_file\n+    )\n+    return temp_tls_state_file\n+\n+\n def test_tunnel_process(tunnel_proc, fs_id):\n     tunnel_proc.poll()\n     if tunnel_proc.returncode is not None:\n@@ -1478,7 +1524,7 @@ def bootstrap_tls(\n     state_file_dir=STATE_FILE_DIR,\n     fallback_ip_address=None,\n ):\n-    tls_port_sock = choose_tls_port_and_get_bind_sock(config, options)\n+    tls_port_sock = choose_tls_port_and_get_bind_sock(config, options, state_file_dir)\n     tls_port = get_tls_port_from_sock(tls_port_sock)\n \n     try:\n@@ -1560,6 +1606,18 @@ def bootstrap_tls(\n         tunnel_args = [_stunnel_bin(), stunnel_config_file]\n         if \"netns\" in options:\n             tunnel_args = [\"nsenter\", \"--net=\" + options[\"netns\"]] + tunnel_args\n+\n+        # This temp state file is acting like a tlsport lock file, which is why pid =- 1\n+        temp_tls_state_file = write_tls_tunnel_state_file(\n+            fs_id,\n+            mountpoint,\n+            tls_port,\n+            -1,\n+            tunnel_args,\n+            [stunnel_config_file],\n+            state_file_dir,\n+            cert_details=cert_details,\n+        )\n     finally:\n         # Always close the socket we created when choosing TLS port only until now to\n         # 1. avoid concurrent TLS mount port collision 2. enable stunnel process to bind the port\n@@ -1577,15 +1635,8 @@ def bootstrap_tls(\n     )\n     logging.info(\"Started TLS tunnel, pid: %d\", tunnel_proc.pid)\n \n-    temp_tls_state_file = write_tls_tunnel_state_file(\n-        fs_id,\n-        mountpoint,\n-        tls_port,\n-        tunnel_proc.pid,\n-        tunnel_args,\n-        [stunnel_config_file],\n-        state_file_dir,\n-        cert_details=cert_details,\n+    update_tls_tunnel_temp_state_file_with_tunnel_pid(\n+        temp_tls_state_file, state_file_dir, tunnel_proc.pid\n     )\n \n     if \"netns\" not in options:"
        },
        {
          "filename": "src/watchdog/__init__.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -56,7 +56,7 @@\n     AMAZON_LINUX_2_RELEASE_ID,\n     AMAZON_LINUX_2_PRETTY_NAME,\n ]\n-VERSION = \"1.34.3\"\n+VERSION = \"1.34.4\"\n SERVICE = \"elasticfilesystem\"\n \n CONFIG_FILE = \"/etc/amazon/efs/efs-utils.conf\""
        },
        {
          "filename": "test/mount_efs_test/test_bootstrap_tls.py",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -44,6 +44,10 @@ def setup_mocks(mocker):\n     mocker.patch(\"mount_efs.create_certificate\")\n     mocker.patch(\"os.rename\")\n     mocker.patch(\"os.kill\")\n+    mocker.patch(\n+        \"mount_efs.update_tls_tunnel_temp_state_file_with_tunnel_pid\",\n+        return_value=\"~mocktempfile\",\n+    )\n \n     process_mock = MagicMock()\n     process_mock.communicate.return_value = (\n@@ -72,6 +76,10 @@ def setup_mocks_without_popen(mocker):\n     )\n     mocker.patch(\"mount_efs.write_tls_tunnel_state_file\", return_value=\"~mocktempfile\")\n     mocker.patch(\"os.kill\")\n+    mocker.patch(\n+        \"mount_efs.update_tls_tunnel_temp_state_file_with_tunnel_pid\",\n+        return_value=\"~mocktempfile\",\n+    )\n \n     write_config_mock = mocker.patch(\n         \"mount_efs.write_stunnel_config_file\", return_value=EXPECTED_STUNNEL_CONFIG_FILE\n@@ -115,6 +123,7 @@ def config_get_side_effect(section, field):\n     assert not os.path.exists(state_file_dir)\n \n     mocker.patch(\"mount_efs._stunnel_bin\", return_value=\"/usr/bin/stunnel\")\n+    mocker.patch(\"mount_efs.find_existing_mount_using_tls_port\", return_value=None)\n     with mount_efs.bootstrap_tls(\n         MOCK_CONFIG, INIT_SYSTEM, DNS_NAME, FS_ID, MOUNT_POINT, {}, state_file_dir\n     ):"
        },
        {
          "filename": "test/mount_efs_test/test_choose_tls_port.py",
          "status": "modified",
          "additions": 46,
          "deletions": 13,
          "patch": "@@ -3,9 +3,12 @@\n # Licensed under the MIT License. See the LICENSE accompanying this file\n # for the specific language governing permissions and limitations under\n # the License.\n-\n+import logging\n import random\n import socket\n+import sys\n+import tempfile\n+import unittest\n from unittest.mock import MagicMock\n \n import pytest\n@@ -45,42 +48,70 @@ def _get_config():\n     return config\n \n \n-def test_choose_tls_port_first_try(mocker):\n+def test_choose_tls_port_first_try(mocker, tmpdir):\n     sock_mock = MagicMock()\n     sock_mock.getsockname.return_value = (\"local_host\", DEFAULT_TLS_PORT)\n     mocker.patch(\"socket.socket\", return_value=sock_mock)\n     options = {}\n \n-    tls_port_sock = mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options)\n+    tls_port_sock = mount_efs.choose_tls_port_and_get_bind_sock(\n+        _get_config(), options, str(tmpdir)\n+    )\n     tls_port = mount_efs.get_tls_port_from_sock(tls_port_sock)\n     assert DEFAULT_TLS_PORT_RANGE_LOW <= tls_port <= DEFAULT_TLS_PORT_RANGE_HIGH\n \n \n-def test_choose_tls_port_second_try(mocker):\n+def test_choose_tls_port_second_try(mocker, tmpdir):\n     bad_sock = MagicMock()\n     bad_sock.bind.side_effect = [socket.error, None]\n     bad_sock.getsockname.return_value = (\"local_host\", DEFAULT_TLS_PORT)\n     options = {}\n \n     mocker.patch(\"socket.socket\", return_value=bad_sock)\n \n-    tls_port_sock = mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options)\n+    tls_port_sock = mount_efs.choose_tls_port_and_get_bind_sock(\n+        _get_config(), options, str(tmpdir)\n+    )\n     tls_port = mount_efs.get_tls_port_from_sock(tls_port_sock)\n \n     assert DEFAULT_TLS_PORT_RANGE_LOW <= tls_port <= DEFAULT_TLS_PORT_RANGE_HIGH\n     assert 2 == bad_sock.bind.call_count\n     assert 1 == bad_sock.getsockname.call_count\n \n \n-def test_choose_tls_port_never_succeeds(mocker, capsys):\n+@unittest.skipIf(sys.version_info < (3, 6), reason=\"requires python3.6\")\n+def test_choose_tls_port_collision(mocker, tmpdir, caplog):\n+    \"\"\"Ensure we don't choose a port that is pending mount\"\"\"\n+    sock = MagicMock()\n+    mocker.patch(\"socket.socket\", return_value=sock)\n+    mocker.patch(\n+        \"random.shuffle\",\n+        return_value=range(DEFAULT_TLS_PORT_RANGE_LOW, DEFAULT_TLS_PORT_RANGE_HIGH),\n+    )\n+\n+    port_suffix = \".%s\" % str(DEFAULT_TLS_PORT_RANGE_LOW)\n+    temp_state_file = tempfile.NamedTemporaryFile(\n+        suffix=port_suffix, prefix=\"~\", dir=tmpdir\n+    )\n+\n+    options = {}\n+    with caplog.at_level(logging.DEBUG):\n+        mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options, tmpdir)\n+\n+    temp_state_file.close()\n+    sock.bind.assert_called_once_with((\"localhost\", DEFAULT_TLS_PORT_RANGE_LOW + 1))\n+    assert \"Skip binding TLS port\" in caplog.text\n+\n+\n+def test_choose_tls_port_never_succeeds(mocker, tmpdir, capsys):\n     bad_sock = MagicMock()\n     bad_sock.bind.side_effect = socket.error()\n     options = {}\n \n     mocker.patch(\"socket.socket\", return_value=bad_sock)\n \n     with pytest.raises(SystemExit) as ex:\n-        mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options)\n+        mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options, str(tmpdir))\n \n     assert 0 != ex.value.code\n \n@@ -93,27 +124,29 @@ def test_choose_tls_port_never_succeeds(mocker, capsys):\n     )\n \n \n-def test_choose_tls_port_option_specified(mocker):\n+def test_choose_tls_port_option_specified(mocker, tmpdir):\n     sock_mock = MagicMock()\n     sock_mock.getsockname.return_value = (\"local_host\", DEFAULT_TLS_PORT)\n     mocker.patch(\"socket.socket\", return_value=sock_mock)\n     options = {\"tlsport\": DEFAULT_TLS_PORT}\n \n-    tls_port_sock = mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options)\n+    tls_port_sock = mount_efs.choose_tls_port_and_get_bind_sock(\n+        _get_config(), options, str(tmpdir)\n+    )\n     tls_port = mount_efs.get_tls_port_from_sock(tls_port_sock)\n \n     assert DEFAULT_TLS_PORT == tls_port\n \n \n-def test_choose_tls_port_option_specified_unavailable(mocker, capsys):\n+def test_choose_tls_port_option_specified_unavailable(mocker, tmpdir, capsys):\n     bad_sock = MagicMock()\n     bad_sock.bind.side_effect = socket.error()\n     options = {\"tlsport\": 1000}\n \n     mocker.patch(\"socket.socket\", return_value=bad_sock)\n \n     with pytest.raises(SystemExit) as ex:\n-        mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options)\n+        mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options, str(tmpdir))\n \n     assert 0 != ex.value.code\n \n@@ -123,13 +156,13 @@ def test_choose_tls_port_option_specified_unavailable(mocker, capsys):\n     assert 1 == bad_sock.bind.call_count\n \n \n-def test_choose_tls_port_under_netns(mocker, capsys):\n+def test_choose_tls_port_under_netns(mocker, tmpdir):\n     mocker.patch(\"builtins.open\")\n     setns_mock = mocker.patch(\"mount_efs.setns\", return_value=(None, None))\n     mocker.patch(\"socket.socket\", return_value=MagicMock())\n     options = {\"netns\": \"/proc/1000/ns/net\"}\n \n-    mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options)\n+    mount_efs.choose_tls_port_and_get_bind_sock(_get_config(), options, str(tmpdir))\n     utils.assert_called(setns_mock)\n \n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "942e73a51e4a3bfd3c755f5f392247c5fa826ad4",
            "date": "2024-11-20T16:05:55Z",
            "author_login": "anthotse"
          },
          {
            "sha": "15f6f88521cfeca3f008740645604e4d29765094",
            "date": "2024-11-20T14:37:02Z",
            "author_login": "anthotse"
          },
          {
            "sha": "20de38aa49f8293c2eb589007b9fd59e5ac3b84a",
            "date": "2024-11-19T22:01:23Z",
            "author_login": "anthotse"
          },
          {
            "sha": "615f154a92e5f87ba33d55af21820e71c4c81b9d",
            "date": "2024-11-19T22:00:50Z",
            "author_login": "anthotse"
          },
          {
            "sha": "87874bd1a18a262fdcb1264f9bc0b8e4b8a77bd6",
            "date": "2024-10-08T16:28:54Z",
            "author_login": "jrakas-dev"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:L",
    "cwe_id": "CWE-362",
    "description": "efs-utils is a set of Utilities for Amazon Elastic File System (EFS). A potential race condition issue exists within the Amazon EFS mount helper in efs-utils versions v1.34.3 and below. When using TLS to mount file systems, the mount helper allocates a local port for stunnel to receive NFS connections prior to applying the TLS tunnel. In affected versions, concurrent mount operations can allocate the same local port, leading to either failed mount operations or an inappropriate mapping from an EFS customer\u2019s local mount points to that customer\u2019s EFS file systems. This issue is patched in version v1.34.4. There is no recommended work around. We recommend affected users update the installed version of efs-utils to v1.34.4 or later.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2022-12-28T07:15:08.860",
    "last_modified": "2024-11-21T07:30:15.610",
    "fix_date": "2022-12-14T06:13:07Z"
  },
  "references": [
    {
      "url": "https://github.com/aws/efs-utils/commit/f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aws/efs-utils/issues/125",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aws/efs-utils/security/advisories/GHSA-4fv8-w65m-3932",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aws/efs-utils/commit/f3a8f88167d55caa2f78aeb72d4dc1987a9ed62d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aws/efs-utils/issues/125",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/aws/efs-utils/security/advisories/GHSA-4fv8-w65m-3932",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.226930",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "efs-utils",
    "owner": "aws",
    "created_at": "2017-12-14T00:31:52Z",
    "updated_at": "2025-01-10T07:58:36Z",
    "pushed_at": "2024-11-20T16:12:23Z",
    "size": 781,
    "stars": 307,
    "forks": 196,
    "open_issues": 51,
    "watchers": 307,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 631662,
      "Rust": 157663,
      "Shell": 2755,
      "Makefile": 1824,
      "RPC": 1145
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T16:14:23.645437"
  }
}