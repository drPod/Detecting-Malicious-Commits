{
  "cve_id": "CVE-2022-47934",
  "github_data": {
    "repository": "brave/brave-core",
    "fix_commit": "82d8e39043e691e0492519126437275511ee87e8",
    "related_commits": [
      "82d8e39043e691e0492519126437275511ee87e8",
      "82d8e39043e691e0492519126437275511ee87e8"
    ],
    "patch_url": "https://github.com/brave/brave-core/commit/82d8e39043e691e0492519126437275511ee87e8.patch",
    "fix_commit_details": {
      "sha": "82d8e39043e691e0492519126437275511ee87e8",
      "commit_date": "2022-08-08T19:22:25Z",
      "author": {
        "login": "LaurenWags",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #14484 from brave/pr14313_brave_24211_1.43.x",
        "length": 127,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 226,
        "additions": 212,
        "deletions": 14
      },
      "files": [
        {
          "filename": "browser/brave_content_browser_client.cc",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -139,6 +139,7 @@ using extensions::ChromeContentBrowserClientExtensionsPart;\n #if BUILDFLAG(ENABLE_IPFS)\n #include \"brave/browser/ipfs/content_browser_client_helper.h\"\n #include \"brave/browser/ipfs/ipfs_service_factory.h\"\n+#include \"brave/browser/ipfs/ipfs_subframe_navigation_throttle.h\"\n #include \"brave/components/ipfs/ipfs_constants.h\"\n #include \"brave/components/ipfs/ipfs_navigation_throttle.h\"\n #endif\n@@ -965,6 +966,9 @@ BraveContentBrowserClient::CreateThrottlesForNavigation(\n #endif\n \n #if BUILDFLAG(ENABLE_IPFS)\n+  throttles.insert(\n+      throttles.begin(),\n+      ipfs::IpfsSubframeNavigationThrottle::CreateThrottleFor(handle));\n   std::unique_ptr<content::NavigationThrottle> ipfs_navigation_throttle =\n       ipfs::IpfsNavigationThrottle::MaybeCreateThrottleFor(\n           handle, ipfs::IpfsServiceFactory::GetForContext(context),"
        },
        {
          "filename": "browser/ipfs/ipfs_subframe_navigation_throttle.cc",
          "status": "added",
          "additions": 43,
          "deletions": 0,
          "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (c) 2022 The Brave Authors. All rights reserved.\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n+ * You can obtain one at http://mozilla.org/MPL/2.0/. */\n+\n+#include \"brave/browser/ipfs/ipfs_subframe_navigation_throttle.h\"\n+\n+#include \"brave/components/ipfs/ipfs_constants.h\"\n+\n+namespace ipfs {\n+\n+// static\n+std::unique_ptr<IpfsSubframeNavigationThrottle>\n+IpfsSubframeNavigationThrottle::CreateThrottleFor(\n+    content::NavigationHandle* navigation_handle) {\n+  return std::make_unique<IpfsSubframeNavigationThrottle>(navigation_handle);\n+}\n+\n+IpfsSubframeNavigationThrottle::IpfsSubframeNavigationThrottle(\n+    content::NavigationHandle* navigation_handle)\n+    : content::NavigationThrottle(navigation_handle) {}\n+\n+IpfsSubframeNavigationThrottle::~IpfsSubframeNavigationThrottle() {}\n+\n+// content::NavigationThrottle implementation:\n+content::NavigationThrottle::ThrottleCheckResult\n+IpfsSubframeNavigationThrottle::WillFailRequest() {\n+  // Ignores subframe ipfs:// navigation. It is ok to commit toplevel\n+  // navigation.\n+  if (!navigation_handle()->IsInMainFrame() &&\n+      (navigation_handle()->GetURL().SchemeIs(ipfs::kIPFSScheme) ||\n+       navigation_handle()->GetURL().SchemeIs(ipfs::kIPNSScheme))) {\n+    return {content::NavigationThrottle::CANCEL_AND_IGNORE,\n+            navigation_handle()->GetNetErrorCode()};\n+  }\n+  return content::NavigationThrottle::PROCEED;\n+}\n+\n+const char* IpfsSubframeNavigationThrottle::GetNameForLogging() {\n+  return \"IpfsSubframeNavigationThrottle\";\n+}\n+\n+}  // namespace ipfs"
        },
        {
          "filename": "browser/ipfs/ipfs_subframe_navigation_throttle.h",
          "status": "added",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (c) 2022 The Brave Authors. All rights reserved.\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n+ * You can obtain one at http://mozilla.org/MPL/2.0/. */\n+\n+#ifndef BRAVE_BROWSER_IPFS_IPFS_SUBFRAME_NAVIGATION_THROTTLE_H_\n+#define BRAVE_BROWSER_IPFS_IPFS_SUBFRAME_NAVIGATION_THROTTLE_H_\n+\n+#include <memory>\n+\n+#include \"content/public/browser/navigation_handle.h\"\n+#include \"content/public/browser/navigation_throttle.h\"\n+\n+namespace ipfs {\n+\n+// Prevents commiting of subframe IPFS navigations.\n+// IPFS urls must be changed to proper gateway urls.\n+// See ipfs_redirect_network_delegate_helper.h for example.\n+class IpfsSubframeNavigationThrottle : public content::NavigationThrottle {\n+ public:\n+  static std::unique_ptr<IpfsSubframeNavigationThrottle> CreateThrottleFor(\n+      content::NavigationHandle* navigation_handle);\n+\n+  explicit IpfsSubframeNavigationThrottle(\n+      content::NavigationHandle* navigation_handle);\n+  ~IpfsSubframeNavigationThrottle() override;\n+\n+  IpfsSubframeNavigationThrottle(const IpfsSubframeNavigationThrottle&) =\n+      delete;\n+  IpfsSubframeNavigationThrottle& operator=(\n+      const IpfsSubframeNavigationThrottle&) = delete;\n+\n+  // content::NavigationThrottle implementation:\n+  // This is called before navigation commits with error.\n+  // Here we can cancel subframe navigation for ipfs:// urls.\n+  content::NavigationThrottle::ThrottleCheckResult WillFailRequest() override;\n+  const char* GetNameForLogging() override;\n+};\n+\n+}  // namespace ipfs\n+\n+#endif  // BRAVE_BROWSER_IPFS_IPFS_SUBFRAME_NAVIGATION_THROTTLE_H_"
        },
        {
          "filename": "browser/ipfs/sources.gni",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -25,6 +25,8 @@ if (enable_ipfs) {\n     \"//brave/browser/ipfs/ipfs_host_resolver.h\",\n     \"//brave/browser/ipfs/ipfs_service_factory.cc\",\n     \"//brave/browser/ipfs/ipfs_service_factory.h\",\n+    \"//brave/browser/ipfs/ipfs_subframe_navigation_throttle.cc\",\n+    \"//brave/browser/ipfs/ipfs_subframe_navigation_throttle.h\",\n     \"//brave/browser/ipfs/ipfs_tab_helper.cc\",\n     \"//brave/browser/ipfs/ipfs_tab_helper.h\",\n   ]"
        },
        {
          "filename": "browser/ipfs/test/ipfs_service_browsertest.cc",
          "status": "modified",
          "additions": 100,
          "deletions": 12,
          "patch": "@@ -431,6 +431,15 @@ class IpfsServiceBrowserTest : public InProcessBrowserTest {\n       http_response->set_content(\n           \"<iframe \"\n           \"src='ipfs://Qmc2JTQo4iXf24g98otZmGFQq176eQ2Cdbb88qA5ToMEvC/2'>\"\n+          \"</iframe>\"\n+          \"<iframe \"\n+          \"src='ipfs://10.10.1.1'>\"\n+          \"</iframe>\"\n+          \"<iframe \"\n+          \"src='ipns://10.10.1.1'>\"\n+          \"</iframe>\"\n+          \"<iframe \"\n+          \"src='ipfs://'>\"\n           \"</iframe>\");\n       http_response->set_code(net::HTTP_OK);\n     } else if (request_path ==\n@@ -840,8 +849,49 @@ IN_PROC_BROWSER_TEST_F(IpfsServiceBrowserTest, CanFetchIPFSResourcesFromIPFS) {\n   EXPECT_EQ(base::Value(true), got_fetch.value);\n }\n \n+// Make sure an <iframe src=\"ipfs://...\"> cannot load within http:// scheme in\n+// incognito\n+IN_PROC_BROWSER_TEST_F(IpfsServiceBrowserTest,\n+                       CannotLoadIframeFromHTTP_Incognito) {\n+  browser()->profile()->GetPrefs()->SetInteger(\n+      kIPFSResolveMethod,\n+      static_cast<int>(ipfs::IPFSResolveMethodTypes::IPFS_LOCAL));\n+\n+  ResetTestServer(\n+      base::BindRepeating(&IpfsServiceBrowserTest::HandleEmbeddedSrvrRequest,\n+                          base::Unretained(this)));\n+  SetIPFSDefaultGatewayForTest(GetURL(\"b.com\", \"/\"));\n+  Browser* private_browser = CreateIncognitoBrowser(nullptr);\n+\n+  ASSERT_TRUE(ui_test_utils::NavigateToURL(private_browser,\n+                                           GetURL(\"b.com\", \"/iframe.html\")));\n+  content::WebContents* contents =\n+      private_browser->tab_strip_model()->GetActiveWebContents();\n+\n+  int child_index = 0;\n+  while (auto* child_frame =\n+             ChildFrameAt(contents->GetMainFrame(), child_index++)) {\n+    auto location =\n+        EvalJs(child_frame,\n+               \"const timer = setInterval(function () {\"\n+               \"  if (document.readyState == 'complete') {\"\n+               \"    clearInterval(timer);\"\n+               \"    window.domAutomationController.send(window.location.href);\"\n+               \"  }\"\n+               \"}, 100);\",\n+               content::EXECUTE_SCRIPT_USE_MANUAL_REPLY);\n+\n+    ASSERT_TRUE(location.error.empty());\n+    EXPECT_EQ(base::Value(\"chrome-error://chromewebdata/\"), location.value);\n+  }\n+}\n+\n // Make sure an <iframe src=\"ipfs://...\"> cannot load within http:// scheme\n IN_PROC_BROWSER_TEST_F(IpfsServiceBrowserTest, CannotLoadIframeFromHTTP) {\n+  browser()->profile()->GetPrefs()->SetInteger(\n+      kIPFSResolveMethod,\n+      static_cast<int>(ipfs::IPFSResolveMethodTypes::IPFS_ASK));\n+\n   ResetTestServer(\n       base::BindRepeating(&IpfsServiceBrowserTest::HandleEmbeddedSrvrRequest,\n                           base::Unretained(this)));\n@@ -851,19 +901,57 @@ IN_PROC_BROWSER_TEST_F(IpfsServiceBrowserTest, CannotLoadIframeFromHTTP) {\n   content::WebContents* contents =\n       browser()->tab_strip_model()->GetActiveWebContents();\n \n-  auto* child_frame = ChildFrameAt(contents->GetMainFrame(), 0);\n-  auto location =\n-      EvalJs(child_frame,\n-             \"const timer = setInterval(function () {\"\n-             \"  if (document.readyState == 'complete') {\"\n-             \"    clearInterval(timer);\"\n-             \"    window.domAutomationController.send(window.location.href);\"\n-             \"  }\"\n-             \"}, 100);\",\n-             content::EXECUTE_SCRIPT_USE_MANUAL_REPLY);\n+  int child_index = 0;\n+  while (auto* child_frame =\n+             ChildFrameAt(contents->GetMainFrame(), child_index++)) {\n+    auto location =\n+        EvalJs(child_frame,\n+               \"const timer = setInterval(function () {\"\n+               \"  if (document.readyState == 'complete') {\"\n+               \"    clearInterval(timer);\"\n+               \"    window.domAutomationController.send(window.location.href);\"\n+               \"  }\"\n+               \"}, 100);\",\n+               content::EXECUTE_SCRIPT_USE_MANUAL_REPLY);\n+\n+    ASSERT_TRUE(location.error.empty());\n+    EXPECT_EQ(base::Value(\"chrome-error://chromewebdata/\"), location.value);\n+  }\n+}\n+\n+// Make sure an <iframe src=\"ipfs://...\"> cannot load within http:// scheme when\n+// ipfs is disabled\n+IN_PROC_BROWSER_TEST_F(IpfsServiceBrowserTest,\n+                       CannotLoadIframeFromHTTP_IPFSDisabled) {\n+  browser()->profile()->GetPrefs()->SetInteger(\n+      kIPFSResolveMethod,\n+      static_cast<int>(ipfs::IPFSResolveMethodTypes::IPFS_DISABLED));\n \n-  ASSERT_TRUE(location.error.empty());\n-  EXPECT_EQ(base::Value(\"chrome-error://chromewebdata/\"), location.value);\n+  ResetTestServer(\n+      base::BindRepeating(&IpfsServiceBrowserTest::HandleEmbeddedSrvrRequest,\n+                          base::Unretained(this)));\n+  SetIPFSDefaultGatewayForTest(GetURL(\"b.com\", \"/\"));\n+  ASSERT_TRUE(\n+      ui_test_utils::NavigateToURL(browser(), GetURL(\"b.com\", \"/iframe.html\")));\n+  content::WebContents* contents =\n+      browser()->tab_strip_model()->GetActiveWebContents();\n+\n+  int child_index = 0;\n+  while (auto* child_frame =\n+             ChildFrameAt(contents->GetMainFrame(), child_index++)) {\n+    auto location =\n+        EvalJs(child_frame,\n+               \"const timer = setInterval(function () {\"\n+               \"  if (document.readyState == 'complete') {\"\n+               \"    clearInterval(timer);\"\n+               \"    window.domAutomationController.send(window.location.href);\"\n+               \"  }\"\n+               \"}, 100);\",\n+               content::EXECUTE_SCRIPT_USE_MANUAL_REPLY);\n+\n+    ASSERT_TRUE(location.error.empty());\n+    EXPECT_EQ(base::Value(\"chrome-error://chromewebdata/\"), location.value);\n+  }\n }\n \n // Make sure an <iframe src=\"ipfs://...\"> can load within another ipfs:// scheme"
        },
        {
          "filename": "browser/net/ipfs_redirect_network_delegate_helper.cc",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -40,7 +40,10 @@ int OnBeforeURLRequest_IPFSRedirectWork(\n   if (has_ipfs_scheme && !brave::IsRegularProfile(ctx->browser_context)) {\n     // Don't allow IPFS requests without translation of IPFS urls.\n     ctx->blocked_by = brave::kOtherBlocked;\n-    return net::ERR_INCOGNITO_IPFS_NOT_ALLOWED;\n+    // Only net::OK navigation will be actually blocked without commit.\n+    return ctx->resource_type == blink::mojom::ResourceType::kMainFrame\n+               ? net::ERR_INCOGNITO_IPFS_NOT_ALLOWED\n+               : net::OK;\n   }\n \n   GURL new_url;"
        },
        {
          "filename": "browser/net/ipfs_redirect_network_delegate_helper_unittest.cc",
          "status": "modified",
          "additions": 17,
          "deletions": 1,
          "patch": "@@ -108,7 +108,7 @@ TEST_F(IPFSRedirectNetworkDelegateHelperTest,\n \n   GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n   auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n-  brave_request_info->resource_type = blink::mojom::ResourceType::kSubFrame;\n+  brave_request_info->resource_type = blink::mojom::ResourceType::kMainFrame;\n   brave_request_info->browser_context = profile()->GetOffTheRecordProfile(\n       Profile::OTRProfileID::CreateUnique(\"incognito\"), true);\n   int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n@@ -117,6 +117,22 @@ TEST_F(IPFSRedirectNetworkDelegateHelperTest,\n   EXPECT_EQ(brave_request_info->blocked_by, brave::kOtherBlocked);\n }\n \n+TEST_F(IPFSRedirectNetworkDelegateHelperTest,\n+       SubFrameRequestDisabledWhenIPFSDisabled_Incognito_Subframe) {\n+  profile()->GetPrefs()->SetInteger(\n+      kIPFSResolveMethod, static_cast<int>(IPFSResolveMethodTypes::IPFS_LOCAL));\n+\n+  GURL url(\"ipfs://QmfM2r8seH2GiRaC4esTjeraXEachRt8ZsSeGaWTPLyMoG\");\n+  auto brave_request_info = std::make_shared<brave::BraveRequestInfo>(url);\n+  brave_request_info->resource_type = blink::mojom::ResourceType::kSubFrame;\n+  brave_request_info->browser_context = profile()->GetOffTheRecordProfile(\n+      Profile::OTRProfileID::CreateUnique(\"incognito\"), true);\n+  int rc = ipfs::OnBeforeURLRequest_IPFSRedirectWork(brave::ResponseCallback(),\n+                                                     brave_request_info);\n+  EXPECT_EQ(rc, net::OK);\n+  EXPECT_EQ(brave_request_info->blocked_by, brave::kOtherBlocked);\n+}\n+\n TEST_F(IPFSRedirectNetworkDelegateHelperTest,\n        LoadDisabledWhenIPFS_WhenWrongIPFSUrl) {\n   profile()->GetPrefs()->SetInteger("
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2924268b3b3df4ee6ef85d27a46ebc518348dbb1",
            "date": "2025-01-14T17:49:47Z",
            "author_login": "brave-builds"
          },
          {
            "sha": "5e2b579caeaa460bf53d66e28ad9c36afacefc31",
            "date": "2025-01-14T17:12:35Z",
            "author_login": "mkarolin"
          },
          {
            "sha": "f7d55ff1be6d798993d1084891da37af4a731b2d",
            "date": "2025-01-14T16:20:58Z",
            "author_login": "tmancey"
          },
          {
            "sha": "886363cccfee3d0d19418354fe0894e2fa676a57",
            "date": "2025-01-14T16:03:23Z",
            "author_login": "brave-builds"
          },
          {
            "sha": "77ee2c01e3084089e2dac9f7984ea32522e85732",
            "date": "2025-01-14T15:16:24Z",
            "author_login": "AlexeyBarabash"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "Brave Browser before 1.43.88 allowed a remote attacker to cause a denial of service in private and guest windows via a crafted HTML file that mentions an ipfs:// or ipns:// URL. This is caused by an incomplete fix for CVE-2022-47932 and CVE-2022-47934.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-24T22:15:09.420",
    "last_modified": "2024-11-21T07:32:34.190",
    "fix_date": "2022-08-08T19:22:25Z"
  },
  "references": [
    {
      "url": "https://github.com/brave/brave-browser/issues/24211",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-browser/issues/25106",
      "source": "cve@mitre.org",
      "tags": [
        "Issue Tracking",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-core/commit/82d8e39043e691e0492519126437275511ee87e8",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-core/pull/14313",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/1646204",
      "source": "cve@mitre.org",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-browser/issues/24211",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-browser/issues/25106",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-core/commit/82d8e39043e691e0492519126437275511ee87e8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/brave/brave-core/pull/14313",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://hackerone.com/reports/1646204",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.206804",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "brave-core",
    "owner": "brave",
    "created_at": "2017-11-10T03:33:30Z",
    "updated_at": "2025-01-14T16:21:03Z",
    "pushed_at": "2025-01-14T16:20:59Z",
    "size": 3444770,
    "stars": 2542,
    "forks": 894,
    "open_issues": 233,
    "watchers": 2542,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "0.53.x",
      "0.54.x",
      "0.55.x",
      "0.56.x",
      "0.57.x",
      "0.58.x",
      "0.59.x",
      "0.60.x",
      "0.61.x",
      "0.62.x",
      "0.63.x",
      "0.64.x",
      "0.65.x",
      "0.66.x",
      "0.67.x",
      "0.68.x",
      "0.69.x",
      "0.70.x",
      "0.71.x",
      "0.72.x",
      "0.73.x",
      "1.0.x",
      "1.1.x",
      "1.2.x",
      "1.3.x",
      "1.4.x",
      "1.5.x"
    ],
    "languages": {
      "HTML": 35443155,
      "C++": 31337056,
      "Swift": 10041814,
      "TypeScript": 7425380,
      "Java": 4187275,
      "C": 1450874,
      "JavaScript": 1389751,
      "Objective-C++": 894217,
      "Python": 830483,
      "Rust": 566338,
      "Objective-C": 283142,
      "CSS": 132887,
      "SCSS": 49637,
      "Shell": 19438,
      "Jinja": 8990,
      "Roff": 8880,
      "Ruby": 7531,
      "PowerShell": 1506,
      "Batchfile": 416,
      "Makefile": 189
    },
    "commit_activity": {
      "total_commits_last_year": 8910,
      "avg_commits_per_week": 171.34615384615384,
      "days_active_last_year": 353
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mpl-2.0"
    },
    "collected_at": "2025-01-14T16:23:59.810342"
  }
}