{
  "cve_id": "CVE-2022-4810",
  "github_data": {
    "repository": "usememos/memos",
    "fix_commit": "3556ae4e651d9443dc3bb8a170dd3cc726517a53",
    "related_commits": [
      "3556ae4e651d9443dc3bb8a170dd3cc726517a53",
      "3556ae4e651d9443dc3bb8a170dd3cc726517a53"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "3556ae4e651d9443dc3bb8a170dd3cc726517a53",
      "commit_date": "2022-12-28T12:22:52Z",
      "author": {
        "login": "boojack",
        "type": "User",
        "stats": {
          "total_commits": 2204,
          "average_weekly_commits": 13.357575757575757,
          "total_additions": 418804,
          "total_deletions": 388073,
          "weeks_active": 155
        }
      },
      "commit_message": {
        "title": "fix: access control (#870)",
        "length": 26,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 511,
        "additions": 276,
        "deletions": 235
      },
      "files": [
        {
          "filename": "api/memo.go",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -46,7 +46,7 @@ type Memo struct {\n \n type MemoCreate struct {\n \t// Standard fields\n-\tCreatorID int\n+\tCreatorID int `json:\"-\"`\n \n \t// Domain specific fields\n \tVisibility Visibility `json:\"visibility\"`\n@@ -73,11 +73,11 @@ type MemoPatch struct {\n }\n \n type MemoFind struct {\n-\tID *int `json:\"id\"`\n+\tID *int\n \n \t// Standard fields\n-\tRowStatus *RowStatus `json:\"rowStatus\"`\n-\tCreatorID *int       `json:\"creatorId\"`\n+\tRowStatus *RowStatus\n+\tCreatorID *int\n \n \t// Domain specific fields\n \tPinned         *bool"
        },
        {
          "filename": "api/memo_organizer.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -9,15 +9,15 @@ type MemoOrganizer struct {\n \tPinned bool\n }\n \n-type MemoOrganizerFind struct {\n-\tMemoID int\n-\tUserID int\n+type MemoOrganizerUpsert struct {\n+\tMemoID int  `json:\"-\"`\n+\tUserID int  `json:\"-\"`\n+\tPinned bool `json:\"pinned\"`\n }\n \n-type MemoOrganizerUpsert struct {\n+type MemoOrganizerFind struct {\n \tMemoID int\n \tUserID int\n-\tPinned bool `json:\"pinned\"`\n }\n \n type MemoOrganizerDelete struct {"
        },
        {
          "filename": "api/memo_resource.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -8,7 +8,7 @@ type MemoResource struct {\n }\n \n type MemoResourceUpsert struct {\n-\tMemoID     int\n+\tMemoID     int `json:\"-\"`\n \tResourceID int\n \tUpdatedTs  *int64\n }"
        },
        {
          "filename": "api/resource.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -20,7 +20,7 @@ type Resource struct {\n \n type ResourceCreate struct {\n \t// Standard fields\n-\tCreatorID int\n+\tCreatorID int `json:\"-\"`\n \n \t// Domain specific fields\n \tFilename string `json:\"filename\"`"
        },
        {
          "filename": "api/shortcut.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -16,7 +16,7 @@ type Shortcut struct {\n \n type ShortcutCreate struct {\n \t// Standard fields\n-\tCreatorID int\n+\tCreatorID int `json:\"-\"`\n \n \t// Domain specific fields\n \tTitle   string `json:\"title\"`"
        },
        {
          "filename": "api/tag.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -7,7 +7,7 @@ type Tag struct {\n \n type TagUpsert struct {\n \tName      string\n-\tCreatorID int\n+\tCreatorID int `json:\"-\"`\n }\n \n type TagFind struct {"
        },
        {
          "filename": "api/user_setting.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -50,7 +50,7 @@ type UserSetting struct {\n }\n \n type UserSettingUpsert struct {\n-\tUserID int\n+\tUserID int            `json:\"-\"`\n \tKey    UserSettingKey `json:\"key\"`\n \tValue  string         `json:\"value\"`\n }"
        },
        {
          "filename": "server/auth.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -84,7 +84,7 @@ func (s *Server) registerAuthRoutes(g *echo.Group) {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find host user\").SetInternal(err)\n \t\t}\n \t\tif signup.Role == api.Host && hostUser != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly.\").SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly\").SetInternal(err)\n \t\t}\n \n \t\tsystemSettingAllowSignUpName := api.SystemSettingAllowSignUpName\n@@ -103,7 +103,7 @@ func (s *Server) registerAuthRoutes(g *echo.Group) {\n \t\t\t}\n \t\t}\n \t\tif !allowSignUpSettingValue && hostUser != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly.\").SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Site Host existed, please contact the site host to signin account firstly\").SetInternal(err)\n \t\t}\n \n \t\tuserCreate := &api.UserCreate{\n@@ -114,7 +114,7 @@ func (s *Server) registerAuthRoutes(g *echo.Group) {\n \t\t\tOpenID:   common.GenUUID(),\n \t\t}\n \t\tif err := userCreate.Validate(); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format.\").SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format\").SetInternal(err)\n \t\t}\n \n \t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)"
        },
        {
          "filename": "server/memo.go",
          "status": "modified",
          "additions": 170,
          "deletions": 155,
          "patch": "@@ -24,9 +24,7 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n \t\t}\n \n-\t\tmemoCreate := &api.MemoCreate{\n-\t\t\tCreatorID: userID,\n-\t\t}\n+\t\tmemoCreate := &api.MemoCreate{}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(memoCreate); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo request\").SetInternal(err)\n \t\t}\n@@ -57,6 +55,7 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\t\t}\n \t\t}\n \n+\t\tmemoCreate.CreatorID = userID\n \t\tmemo, err := s.Store.CreateMemo(ctx, memoCreate)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create memo\").SetInternal(err)\n@@ -98,13 +97,15 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n \t\t}\n \n-\t\tmemoFind := &api.MemoFind{\n-\t\t\tID:        &memoID,\n-\t\t\tCreatorID: &userID,\n-\t\t}\n-\t\tif _, err := s.Store.FindMemo(ctx, memoFind); err != nil {\n+\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n+\t\t\tID: &memoID,\n+\t\t})\n+\t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n \t\t}\n+\t\tif memo.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n+\t\t}\n \n \t\tcurrentTs := time.Now().Unix()\n \t\tmemoPatch := &api.MemoPatch{\n@@ -115,7 +116,7 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch memo request\").SetInternal(err)\n \t\t}\n \n-\t\tmemo, err := s.Store.PatchMemo(ctx, memoPatch)\n+\t\tmemo, err = s.Store.PatchMemo(ctx, memoPatch)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch memo\").SetInternal(err)\n \t\t}\n@@ -173,7 +174,7 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\t}\n \t\ttag := c.QueryParam(\"tag\")\n \t\tif tag != \"\" {\n-\t\t\tcontentSearch := \"#\" + tag + \" \"\n+\t\t\tcontentSearch := \"#\" + tag\n \t\t\tmemoFind.ContentSearch = &contentSearch\n \t\t}\n \t\tvisibilityListStr := c.QueryParam(\"visibility\")\n@@ -229,129 +230,6 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\treturn nil\n \t})\n \n-\tg.GET(\"/memo/amount\", func(c echo.Context) error {\n-\t\tctx := c.Request().Context()\n-\t\tnormalRowStatus := api.Normal\n-\t\tmemoFind := &api.MemoFind{\n-\t\t\tRowStatus: &normalRowStatus,\n-\t\t}\n-\t\tif userID, err := strconv.Atoi(c.QueryParam(\"userId\")); err == nil {\n-\t\t\tmemoFind.CreatorID = &userID\n-\t\t}\n-\n-\t\tmemoList, err := s.Store.FindMemoList(ctx, memoFind)\n-\t\tif err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)\n-\t\t}\n-\n-\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n-\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(len(memoList))); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo amount\").SetInternal(err)\n-\t\t}\n-\t\treturn nil\n-\t})\n-\n-\tg.GET(\"/memo/stats\", func(c echo.Context) error {\n-\t\tctx := c.Request().Context()\n-\t\tnormalStatus := api.Normal\n-\t\tmemoFind := &api.MemoFind{\n-\t\t\tRowStatus: &normalStatus,\n-\t\t}\n-\t\tif creatorID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n-\t\t\tmemoFind.CreatorID = &creatorID\n-\t\t}\n-\t\tif memoFind.CreatorID == nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n-\t\t}\n-\n-\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n-\t\tif !ok {\n-\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n-\t\t} else {\n-\t\t\tif *memoFind.CreatorID != currentUserID {\n-\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n-\t\t\t} else {\n-\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected, api.Private}\n-\t\t\t}\n-\t\t}\n-\n-\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n-\t\tif err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch memo list\").SetInternal(err)\n-\t\t}\n-\n-\t\tdisplayTsList := []int64{}\n-\t\tfor _, memo := range list {\n-\t\t\tdisplayTsList = append(displayTsList, memo.DisplayTs)\n-\t\t}\n-\n-\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n-\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(displayTsList)); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo stats response\").SetInternal(err)\n-\t\t}\n-\t\treturn nil\n-\t})\n-\n-\tg.GET(\"/memo/all\", func(c echo.Context) error {\n-\t\tctx := c.Request().Context()\n-\t\tmemoFind := &api.MemoFind{}\n-\n-\t\t_, ok := c.Get(getUserIDContextKey()).(int)\n-\t\tif !ok {\n-\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n-\t\t} else {\n-\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n-\t\t}\n-\n-\t\tpinnedStr := c.QueryParam(\"pinned\")\n-\t\tif pinnedStr != \"\" {\n-\t\t\tpinned := pinnedStr == \"true\"\n-\t\t\tmemoFind.Pinned = &pinned\n-\t\t}\n-\t\ttag := c.QueryParam(\"tag\")\n-\t\tif tag != \"\" {\n-\t\t\tcontentSearch := \"#\" + tag + \" \"\n-\t\t\tmemoFind.ContentSearch = &contentSearch\n-\t\t}\n-\t\tvisibilityListStr := c.QueryParam(\"visibility\")\n-\t\tif visibilityListStr != \"\" {\n-\t\t\tvisibilityList := []api.Visibility{}\n-\t\t\tfor _, visibility := range strings.Split(visibilityListStr, \",\") {\n-\t\t\t\tvisibilityList = append(visibilityList, api.Visibility(visibility))\n-\t\t\t}\n-\t\t\tmemoFind.VisibilityList = visibilityList\n-\t\t}\n-\t\tif limit, err := strconv.Atoi(c.QueryParam(\"limit\")); err == nil {\n-\t\t\tmemoFind.Limit = limit\n-\t\t}\n-\t\tif offset, err := strconv.Atoi(c.QueryParam(\"offset\")); err == nil {\n-\t\t\tmemoFind.Offset = offset\n-\t\t}\n-\n-\t\t// Only fetch normal status memos.\n-\t\tnormalStatus := api.Normal\n-\t\tmemoFind.RowStatus = &normalStatus\n-\n-\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n-\t\tif err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch all memo list\").SetInternal(err)\n-\t\t}\n-\n-\t\tsort.Slice(list, func(i, j int) bool {\n-\t\t\treturn list[i].DisplayTs > list[j].DisplayTs\n-\t\t})\n-\n-\t\tif memoFind.Limit != 0 {\n-\t\t\tlist = list[memoFind.Offset:common.Min(len(list), memoFind.Offset+memoFind.Limit)]\n-\t\t}\n-\n-\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n-\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode all memo list response\").SetInternal(err)\n-\t\t}\n-\t\treturn nil\n-\t})\n-\n \tg.GET(\"/memo/:memoId\", func(c echo.Context) error {\n \t\tctx := c.Request().Context()\n \t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n@@ -400,13 +278,12 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\tif !ok {\n \t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n \t\t}\n-\t\tmemoOrganizerUpsert := &api.MemoOrganizerUpsert{\n-\t\t\tMemoID: memoID,\n-\t\t\tUserID: userID,\n-\t\t}\n+\t\tmemoOrganizerUpsert := &api.MemoOrganizerUpsert{}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(memoOrganizerUpsert); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo organizer request\").SetInternal(err)\n \t\t}\n+\t\tmemoOrganizerUpsert.MemoID = memoID\n+\t\tmemoOrganizerUpsert.UserID = userID\n \n \t\terr = s.Store.UpsertMemoOrganizer(ctx, memoOrganizerUpsert)\n \t\tif err != nil {\n@@ -440,12 +317,12 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \n \t\tcurrentTs := time.Now().Unix()\n \t\tmemoResourceUpsert := &api.MemoResourceUpsert{\n-\t\t\tMemoID:    memoID,\n \t\t\tUpdatedTs: &currentTs,\n \t\t}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(memoResourceUpsert); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post memo resource request\").SetInternal(err)\n \t\t}\n+\t\tmemoResourceUpsert.MemoID = memoID\n \n \t\tif _, err := s.Store.UpsertMemoResource(ctx, memoResourceUpsert); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert memo resource\").SetInternal(err)\n@@ -488,26 +365,127 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\treturn nil\n \t})\n \n-\tg.DELETE(\"/memo/:memoId/resource/:resourceId\", func(c echo.Context) error {\n+\tg.GET(\"/memo/amount\", func(c echo.Context) error {\n \t\tctx := c.Request().Context()\n-\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n+\t\tnormalRowStatus := api.Normal\n+\t\tmemoFind := &api.MemoFind{\n+\t\t\tRowStatus: &normalRowStatus,\n+\t\t}\n+\t\tif userID, err := strconv.Atoi(c.QueryParam(\"userId\")); err == nil {\n+\t\t\tmemoFind.CreatorID = &userID\n+\t\t}\n+\n+\t\tmemoList, err := s.Store.FindMemoList(ctx, memoFind)\n \t\tif err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Memo ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)\n \t\t}\n-\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n+\n+\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n+\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(len(memoList))); err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo amount\").SetInternal(err)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\n+\tg.GET(\"/memo/stats\", func(c echo.Context) error {\n+\t\tctx := c.Request().Context()\n+\t\tnormalStatus := api.Normal\n+\t\tmemoFind := &api.MemoFind{\n+\t\t\tRowStatus: &normalStatus,\n+\t\t}\n+\t\tif creatorID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n+\t\t\tmemoFind.CreatorID = &creatorID\n+\t\t}\n+\t\tif memoFind.CreatorID == nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n+\t\t}\n+\n+\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n+\t\t} else {\n+\t\t\tif *memoFind.CreatorID != currentUserID {\n+\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n+\t\t\t} else {\n+\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected, api.Private}\n+\t\t\t}\n+\t\t}\n+\n+\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n \t\tif err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Resource ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch memo list\").SetInternal(err)\n \t\t}\n \n-\t\tmemoResourceDelete := &api.MemoResourceDelete{\n-\t\t\tMemoID:     &memoID,\n-\t\t\tResourceID: &resourceID,\n+\t\tdisplayTsList := []int64{}\n+\t\tfor _, memo := range list {\n+\t\t\tdisplayTsList = append(displayTsList, memo.DisplayTs)\n \t\t}\n-\t\tif err := s.Store.DeleteMemoResource(ctx, memoResourceDelete); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n+\n+\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n+\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(displayTsList)); err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode memo stats response\").SetInternal(err)\n \t\t}\n+\t\treturn nil\n+\t})\n \n-\t\treturn c.JSON(http.StatusOK, true)\n+\tg.GET(\"/memo/all\", func(c echo.Context) error {\n+\t\tctx := c.Request().Context()\n+\t\tmemoFind := &api.MemoFind{}\n+\n+\t\t_, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n+\t\t} else {\n+\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n+\t\t}\n+\n+\t\tpinnedStr := c.QueryParam(\"pinned\")\n+\t\tif pinnedStr != \"\" {\n+\t\t\tpinned := pinnedStr == \"true\"\n+\t\t\tmemoFind.Pinned = &pinned\n+\t\t}\n+\t\ttag := c.QueryParam(\"tag\")\n+\t\tif tag != \"\" {\n+\t\t\tcontentSearch := \"#\" + tag + \" \"\n+\t\t\tmemoFind.ContentSearch = &contentSearch\n+\t\t}\n+\t\tvisibilityListStr := c.QueryParam(\"visibility\")\n+\t\tif visibilityListStr != \"\" {\n+\t\t\tvisibilityList := []api.Visibility{}\n+\t\t\tfor _, visibility := range strings.Split(visibilityListStr, \",\") {\n+\t\t\t\tvisibilityList = append(visibilityList, api.Visibility(visibility))\n+\t\t\t}\n+\t\t\tmemoFind.VisibilityList = visibilityList\n+\t\t}\n+\t\tif limit, err := strconv.Atoi(c.QueryParam(\"limit\")); err == nil {\n+\t\t\tmemoFind.Limit = limit\n+\t\t}\n+\t\tif offset, err := strconv.Atoi(c.QueryParam(\"offset\")); err == nil {\n+\t\t\tmemoFind.Offset = offset\n+\t\t}\n+\n+\t\t// Only fetch normal status memos.\n+\t\tnormalStatus := api.Normal\n+\t\tmemoFind.RowStatus = &normalStatus\n+\n+\t\tlist, err := s.Store.FindMemoList(ctx, memoFind)\n+\t\tif err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch all memo list\").SetInternal(err)\n+\t\t}\n+\n+\t\tsort.Slice(list, func(i, j int) bool {\n+\t\t\treturn list[i].DisplayTs > list[j].DisplayTs\n+\t\t})\n+\n+\t\tif memoFind.Limit != 0 {\n+\t\t\tlist = list[memoFind.Offset:common.Min(len(list), memoFind.Offset+memoFind.Limit)]\n+\t\t}\n+\n+\t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n+\t\tif err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to encode all memo list response\").SetInternal(err)\n+\t\t}\n+\t\treturn nil\n \t})\n \n \tg.DELETE(\"/memo/:memoId\", func(c echo.Context) error {\n@@ -516,19 +494,20 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \t\tif !ok {\n \t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n \t\t}\n-\n \t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n \t\t}\n \n-\t\tmemoFind := &api.MemoFind{\n-\t\t\tID:        &memoID,\n-\t\t\tCreatorID: &userID,\n-\t\t}\n-\t\tif _, err := s.Store.FindMemo(ctx, memoFind); err != nil {\n+\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n+\t\t\tID: &memoID,\n+\t\t})\n+\t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n \t\t}\n+\t\tif memo.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n+\t\t}\n \n \t\tmemoDelete := &api.MemoDelete{\n \t\t\tID: memoID,\n@@ -542,4 +521,40 @@ func (s *Server) registerMemoRoutes(g *echo.Group) {\n \n \t\treturn c.JSON(http.StatusOK, true)\n \t})\n+\n+\tg.DELETE(\"/memo/:memoId/resource/:resourceId\", func(c echo.Context) error {\n+\t\tctx := c.Request().Context()\n+\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n+\t\t}\n+\t\tmemoID, err := strconv.Atoi(c.Param(\"memoId\"))\n+\t\tif err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Memo ID is not a number: %s\", c.Param(\"memoId\"))).SetInternal(err)\n+\t\t}\n+\t\tresourceID, err := strconv.Atoi(c.Param(\"resourceId\"))\n+\t\tif err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Resource ID is not a number: %s\", c.Param(\"resourceId\"))).SetInternal(err)\n+\t\t}\n+\n+\t\tmemo, err := s.Store.FindMemo(ctx, &api.MemoFind{\n+\t\t\tID: &memoID,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo\").SetInternal(err)\n+\t\t}\n+\t\tif memo.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n+\t\t}\n+\n+\t\tmemoResourceDelete := &api.MemoResourceDelete{\n+\t\t\tMemoID:     &memoID,\n+\t\t\tResourceID: &resourceID,\n+\t\t}\n+\t\tif err := s.Store.DeleteMemoResource(ctx, memoResourceDelete); err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to fetch resource list\").SetInternal(err)\n+\t\t}\n+\n+\t\treturn c.JSON(http.StatusOK, true)\n+\t})\n }"
        },
        {
          "filename": "server/resource.go",
          "status": "modified",
          "additions": 12,
          "deletions": 9,
          "patch": "@@ -56,13 +56,12 @@ func (s *Server) registerResourceRoutes(g *echo.Group) {\n \t\t}\n \n \t\tresourceCreate := &api.ResourceCreate{\n+\t\t\tCreatorID: userID,\n \t\t\tFilename:  filename,\n \t\t\tType:      filetype,\n \t\t\tSize:      size,\n \t\t\tBlob:      fileBytes,\n-\t\t\tCreatorID: userID,\n \t\t}\n-\n \t\tresource, err := s.Store.CreateResource(ctx, resourceCreate)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create resource\").SetInternal(err)\n@@ -158,6 +157,7 @@ func (s *Server) registerResourceRoutes(g *echo.Group) {\n \n \t\tc.Response().Writer.WriteHeader(http.StatusOK)\n \t\tc.Response().Writer.Header().Set(\"Content-Type\", resource.Type)\n+\t\tc.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, \"default-src 'self'\")\n \t\tif _, err := c.Response().Writer.Write(resource.Blob); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to write resource blob\").SetInternal(err)\n \t\t}\n@@ -177,23 +177,26 @@ func (s *Server) registerResourceRoutes(g *echo.Group) {\n \t\t}\n \n \t\tresourceFind := &api.ResourceFind{\n-\t\t\tID:        &resourceID,\n-\t\t\tCreatorID: &userID,\n+\t\t\tID: &resourceID,\n \t\t}\n-\t\tif _, err := s.Store.FindResource(ctx, resourceFind); err != nil {\n+\t\tresource, err := s.Store.FindResource(ctx, resourceFind)\n+\t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n \t\t}\n+\t\tif resource.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n+\t\t}\n \n \t\tcurrentTs := time.Now().Unix()\n \t\tresourcePatch := &api.ResourcePatch{\n-\t\t\tID:        resourceID,\n \t\t\tUpdatedTs: &currentTs,\n \t\t}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(resourcePatch); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch resource request\").SetInternal(err)\n \t\t}\n \n-\t\tresource, err := s.Store.PatchResource(ctx, resourcePatch)\n+\t\tresource.ID = resourceID\n+\t\tresource, err = s.Store.PatchResource(ctx, resourcePatch)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch resource\").SetInternal(err)\n \t\t}\n@@ -224,8 +227,8 @@ func (s *Server) registerResourceRoutes(g *echo.Group) {\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find resource\").SetInternal(err)\n \t\t}\n-\t\tif resource == nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Not find resource\").SetInternal(err)\n+\t\tif resource.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n \t\t}\n \n \t\tresourceDelete := &api.ResourceDelete{"
        },
        {
          "filename": "server/shortcut.go",
          "status": "modified",
          "additions": 40,
          "deletions": 16,
          "patch": "@@ -21,13 +21,12 @@ func (s *Server) registerShortcutRoutes(g *echo.Group) {\n \t\tif !ok {\n \t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n \t\t}\n-\t\tshortcutCreate := &api.ShortcutCreate{\n-\t\t\tCreatorID: userID,\n-\t\t}\n+\t\tshortcutCreate := &api.ShortcutCreate{}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post shortcut request\").SetInternal(err)\n \t\t}\n \n+\t\tshortcutCreate.CreatorID = userID\n \t\tshortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to create shortcut\").SetInternal(err)\n@@ -45,21 +44,36 @@ func (s *Server) registerShortcutRoutes(g *echo.Group) {\n \n \tg.PATCH(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n \t\tctx := c.Request().Context()\n+\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n+\t\t}\n \t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n \t\t}\n \n+\t\tshortcutFind := &api.ShortcutFind{\n+\t\t\tID: &shortcutID,\n+\t\t}\n+\t\tshortcut, err := s.Store.FindShortcut(ctx, shortcutFind)\n+\t\tif err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find shortcut\").SetInternal(err)\n+\t\t}\n+\t\tif shortcut.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n+\t\t}\n+\n \t\tcurrentTs := time.Now().Unix()\n \t\tshortcutPatch := &api.ShortcutPatch{\n-\t\t\tID:        shortcutID,\n \t\t\tUpdatedTs: &currentTs,\n \t\t}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch shortcut request\").SetInternal(err)\n \t\t}\n \n-\t\tshortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)\n+\t\tshortcutPatch.ID = shortcutID\n+\t\tshortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to patch shortcut\").SetInternal(err)\n \t\t}\n@@ -73,17 +87,12 @@ func (s *Server) registerShortcutRoutes(g *echo.Group) {\n \n \tg.GET(\"/shortcut\", func(c echo.Context) error {\n \t\tctx := c.Request().Context()\n-\t\tshortcutFind := &api.ShortcutFind{}\n-\n-\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n-\t\t\tshortcutFind.CreatorID = &userID\n-\t\t} else {\n-\t\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n-\t\t\tif !ok {\n-\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find shortcut\")\n-\t\t\t}\n-\n-\t\t\tshortcutFind.CreatorID = &userID\n+\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find shortcut\")\n+\t\t}\n+\t\tshortcutFind := &api.ShortcutFind{\n+\t\t\tCreatorID: &userID,\n \t\t}\n \n \t\tlist, err := s.Store.FindShortcutList(ctx, shortcutFind)\n@@ -122,11 +131,26 @@ func (s *Server) registerShortcutRoutes(g *echo.Group) {\n \n \tg.DELETE(\"/shortcut/:shortcutId\", func(c echo.Context) error {\n \t\tctx := c.Request().Context()\n+\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n+\t\t}\n \t\tshortcutID, err := strconv.Atoi(c.Param(\"shortcutId\"))\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"ID is not a number: %s\", c.Param(\"shortcutId\"))).SetInternal(err)\n \t\t}\n \n+\t\tshortcutFind := &api.ShortcutFind{\n+\t\t\tID: &shortcutID,\n+\t\t}\n+\t\tshortcut, err := s.Store.FindShortcut(ctx, shortcutFind)\n+\t\tif err != nil {\n+\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find shortcut\").SetInternal(err)\n+\t\t}\n+\t\tif shortcut.CreatorID != userID {\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n+\t\t}\n+\n \t\tshortcutDelete := &api.ShortcutDelete{\n \t\t\tID: &shortcutID,\n \t\t}"
        },
        {
          "filename": "server/system.go",
          "status": "modified",
          "additions": 19,
          "deletions": 10,
          "patch": "@@ -76,13 +76,24 @@ func (s *Server) registerSystemRoutes(g *echo.Group) {\n \t\t\t\tsystemStatus.AdditionalScript = value.(string)\n \t\t\t} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {\n \t\t\t\tvalueMap := value.(map[string]interface{})\n-\t\t\t\tsystemStatus.CustomizedProfile = api.CustomizedProfile{\n-\t\t\t\t\tName:        valueMap[\"name\"].(string),\n-\t\t\t\t\tLogoURL:     valueMap[\"logoUrl\"].(string),\n-\t\t\t\t\tDescription: valueMap[\"description\"].(string),\n-\t\t\t\t\tLocale:      valueMap[\"locale\"].(string),\n-\t\t\t\t\tAppearance:  valueMap[\"appearance\"].(string),\n-\t\t\t\t\tExternalURL: valueMap[\"externalUrl\"].(string),\n+\t\t\t\tsystemStatus.CustomizedProfile = api.CustomizedProfile{}\n+\t\t\t\tif v := valueMap[\"name\"]; v != nil {\n+\t\t\t\t\tsystemStatus.CustomizedProfile.Name = v.(string)\n+\t\t\t\t}\n+\t\t\t\tif v := valueMap[\"logoUrl\"]; v != nil {\n+\t\t\t\t\tsystemStatus.CustomizedProfile.LogoURL = v.(string)\n+\t\t\t\t}\n+\t\t\t\tif v := valueMap[\"description\"]; v != nil {\n+\t\t\t\t\tsystemStatus.CustomizedProfile.Description = v.(string)\n+\t\t\t\t}\n+\t\t\t\tif v := valueMap[\"locale\"]; v != nil {\n+\t\t\t\t\tsystemStatus.CustomizedProfile.Locale = v.(string)\n+\t\t\t\t}\n+\t\t\t\tif v := valueMap[\"appearance\"]; v != nil {\n+\t\t\t\t\tsystemStatus.CustomizedProfile.Appearance = v.(string)\n+\t\t\t\t}\n+\t\t\t\tif v := valueMap[\"externalUrl\"]; v != nil {\n+\t\t\t\t\tsystemStatus.CustomizedProfile.ExternalURL = v.(string)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -125,9 +136,7 @@ func (s *Server) registerSystemRoutes(g *echo.Group) {\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user\").SetInternal(err)\n \t\t}\n-\t\tif user == nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"Current signin user not found\")\n-\t\t} else if user.Role != api.Host {\n+\t\tif user == nil || user.Role != api.Host {\n \t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Unauthorized\")\n \t\t}\n "
        },
        {
          "filename": "server/tag.go",
          "status": "modified",
          "additions": 7,
          "deletions": 21,
          "patch": "@@ -23,16 +23,15 @@ func (s *Server) registerTagRoutes(g *echo.Group) {\n \t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n \t\t}\n \n-\t\ttagUpsert := &api.TagUpsert{\n-\t\t\tCreatorID: userID,\n-\t\t}\n+\t\ttagUpsert := &api.TagUpsert{}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post tag request\").SetInternal(err)\n \t\t}\n \t\tif tagUpsert.Name == \"\" {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Tag name shouldn't be empty\")\n \t\t}\n \n+\t\ttagUpsert.CreatorID = userID\n \t\ttag, err := s.Store.UpsertTag(ctx, tagUpsert)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to upsert tag\").SetInternal(err)\n@@ -82,31 +81,18 @@ func (s *Server) registerTagRoutes(g *echo.Group) {\n \n \tg.GET(\"/tag/suggestion\", func(c echo.Context) error {\n \t\tctx := c.Request().Context()\n+\t\tuserID, ok := c.Get(getUserIDContextKey()).(int)\n+\t\tif !ok {\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user session\")\n+\t\t}\n \t\tcontentSearch := \"#\"\n \t\tnormalRowStatus := api.Normal\n \t\tmemoFind := api.MemoFind{\n+\t\t\tCreatorID:     &userID,\n \t\t\tContentSearch: &contentSearch,\n \t\t\tRowStatus:     &normalRowStatus,\n \t\t}\n \n-\t\tif userID, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n-\t\t\tmemoFind.CreatorID = &userID\n-\t\t}\n-\n-\t\tcurrentUserID, ok := c.Get(getUserIDContextKey()).(int)\n-\t\tif !ok {\n-\t\t\tif memoFind.CreatorID == nil {\n-\t\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Missing user id to find memo\")\n-\t\t\t}\n-\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public}\n-\t\t} else {\n-\t\t\tif memoFind.CreatorID == nil {\n-\t\t\t\tmemoFind.CreatorID = &currentUserID\n-\t\t\t} else {\n-\t\t\t\tmemoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}\n-\t\t\t}\n-\t\t}\n-\n \t\tmemoList, err := s.Store.FindMemoList(ctx, &memoFind)\n \t\tif err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find memo list\").SetInternal(err)"
        },
        {
          "filename": "server/user.go",
          "status": "modified",
          "additions": 11,
          "deletions": 7,
          "patch": "@@ -29,18 +29,20 @@ func (s *Server) registerUserRoutes(g *echo.Group) {\n \t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user by id\").SetInternal(err)\n \t\t}\n \t\tif currentUser.Role != api.Host {\n-\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Only Host user can create member.\")\n+\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Only Host user can create member\")\n \t\t}\n \n-\t\tuserCreate := &api.UserCreate{\n-\t\t\tOpenID: common.GenUUID(),\n-\t\t}\n+\t\tuserCreate := &api.UserCreate{}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(userCreate); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted post user request\").SetInternal(err)\n \t\t}\n+\t\tif userCreate.Role == api.Host {\n+\t\t\treturn echo.NewHTTPError(http.StatusForbidden, \"Could not create host user\")\n+\t\t}\n+\t\tuserCreate.OpenID = common.GenUUID()\n \n \t\tif err := userCreate.Validate(); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format.\").SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user create format\").SetInternal(err)\n \t\t}\n \n \t\tpasswordHash, err := bcrypt.GenerateFromPassword([]byte(userCreate.Password), bcrypt.DefaultCost)\n@@ -74,6 +76,7 @@ func (s *Server) registerUserRoutes(g *echo.Group) {\n \t\tfor _, user := range userList {\n \t\t\t// data desensitize\n \t\t\tuser.OpenID = \"\"\n+\t\t\tuser.Email = \"\"\n \t\t}\n \n \t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n@@ -159,6 +162,7 @@ func (s *Server) registerUserRoutes(g *echo.Group) {\n \t\tif user != nil {\n \t\t\t// data desensitize\n \t\t\tuser.OpenID = \"\"\n+\t\t\tuser.Email = \"\"\n \t\t}\n \n \t\tc.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)\n@@ -192,14 +196,14 @@ func (s *Server) registerUserRoutes(g *echo.Group) {\n \n \t\tcurrentTs := time.Now().Unix()\n \t\tuserPatch := &api.UserPatch{\n-\t\t\tID:        userID,\n \t\t\tUpdatedTs: &currentTs,\n \t\t}\n \t\tif err := json.NewDecoder(c.Request().Body).Decode(userPatch); err != nil {\n \t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Malformatted patch user request\").SetInternal(err)\n \t\t}\n+\t\tuserPatch.ID = userID\n \t\tif err := userPatch.Validate(); err != nil {\n-\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user patch format.\").SetInternal(err)\n+\t\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user patch format\").SetInternal(err)\n \t\t}\n \n \t\tif userPatch.Password != nil && *userPatch.Password != \"\" {"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0334a4845fdc877ca784daf485153c8d8b3bfe5d",
            "date": "2025-01-21T14:55:57Z",
            "author_login": "johnnyjoygh"
          },
          {
            "sha": "ef3b7ac6aee5536abd266d73c3f6e10a92dbb26e",
            "date": "2025-01-21T14:55:35Z",
            "author_login": "johnnyjoygh"
          },
          {
            "sha": "f9b1df5d13f6f4017518524ed24c0c03ecf4d827",
            "date": "2025-01-21T14:46:09Z",
            "author_login": "johnnyjoygh"
          },
          {
            "sha": "d9a92b2ef8995368e2f53f6a83ece3da3522ea12",
            "date": "2025-01-21T10:02:21Z",
            "author_login": "ComixHe"
          },
          {
            "sha": "702c092289a03b16cfae4ac41fbff34230b9600f",
            "date": "2025-01-20T11:38:50Z",
            "author_login": "johnnyjoygh"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-284",
    "description": "Improper Access Control in GitHub repository usememos/memos prior to 0.9.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2022-12-28T14:15:11.293",
    "last_modified": "2024-11-21T07:35:59.190",
    "fix_date": "2022-12-28T12:22:52Z"
  },
  "references": [
    {
      "url": "https://github.com/usememos/memos/commit/3556ae4e651d9443dc3bb8a170dd3cc726517a53",
      "source": "security@huntr.dev",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/f0c8d778-db86-4ed3-85bb-5315ab56915e",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/usememos/memos/commit/3556ae4e651d9443dc3bb8a170dd3cc726517a53",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/f0c8d778-db86-4ed3-85bb-5315ab56915e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:23.230353",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "memos",
    "owner": "usememos",
    "created_at": "2021-12-08T15:30:18Z",
    "updated_at": "2025-01-26T07:17:42Z",
    "pushed_at": "2025-01-21T14:56:03Z",
    "size": 32860,
    "stars": 36398,
    "forks": 2600,
    "open_issues": 29,
    "watchers": 36398,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 492575,
      "TypeScript": 430526,
      "Less": 2572,
      "JavaScript": 1558,
      "Shell": 1124,
      "HTML": 1074,
      "Dockerfile": 900,
      "CSS": 439
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:38:18.971806"
  }
}