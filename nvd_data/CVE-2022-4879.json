{
  "cve_id": "CVE-2022-4879",
  "github_data": {
    "repository": "FAForever/fa",
    "fix_commit": "6880971bd3d73d942384aff62d53058c206ce644",
    "related_commits": [
      "6880971bd3d73d942384aff62d53058c206ce644",
      "6880971bd3d73d942384aff62d53058c206ce644"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "6880971bd3d73d942384aff62d53058c206ce644",
      "commit_date": "2022-11-15T17:05:38Z",
      "author": {
        "login": "Hdt80bro",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Update recall feature (#4398)",
        "length": 98,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 478,
        "additions": 330,
        "deletions": 148
      },
      "files": [
        {
          "filename": "lua/SimSync.lua",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -125,12 +125,12 @@ end\n function NoteFocusArmyChanged(new, old)\n     --LOG('NoteFocusArmyChanged(new=' .. repr(new) .. ', old=' .. repr(old) .. ')')\n     import(\"/lua/simping.lua\").OnArmyChange()\n+    import(\"/lua/sim/recall.lua\").OnArmyChange()\n     for entityID, data in UnitData do\n         if new == -1 or data.OwnerArmy == new then\n             Sync.UnitData[entityID] = data.Data\n         elseif old == -1 or data.OwnerArmy == old then\n             Sync.ReleaseIds[entityID] = true\n-        else\n         end\n     end\n     SyncUnitEnhancements()"
        },
        {
          "filename": "lua/SimUtils.lua",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -703,6 +703,7 @@ function BreakAlliance(data)\n         table.insert(Sync.BrokenAlliances, { From = data.From, To = data.To })\n     end\n     import(\"/lua/simping.lua\").OnAllianceChange()\n+    import(\"/lua/sim/recall.lua\").OnAllianceChange(data)\n end\n \n ---@param resultData {From: number, To: number, ResultValue: DiplomacyActionType}"
        },
        {
          "filename": "lua/sim/Recall.lua",
          "status": "modified",
          "additions": 279,
          "deletions": 122,
          "patch": "@@ -1,108 +1,186 @@\n \n+-- import recall parameters\n doscript \"/lua/shared/RecallParams.lua\"\n \n----@alias CannotRecallReason \"active\" | \"ai\" | \"gate\" | \"request\" | \"scenario\" | \"vote\" | false\n+local SyncAnnouncement = import(\"/lua/simdiplomacy.lua\").SyncAnnouncement\n+\n+\n+---@alias CannotRecallReason false\n+---| \"active\"\n+---| \"ai\"\n+---| \"gate\"\n+---| \"request\"\n+---| \"scenario\"\n+---| \"vote\"\n+---| \"observer\"\n+\n \n function init()\n+    -- setup sim recall state in the brains\n+    local playerCooldown = PlayerGateCooldown - PlayerRequestCooldown\n+    local teamCooldown = PlayerGateCooldown - TeamVoteCooldown\n     for _, brain in ArmyBrains do\n-        brain.LastRecallRequestTime = PlayerGateCooldown - PlayerRequestCooldown\n-        brain.LastRecallVoteTime = PlayerGateCooldown - TeamVoteCooldown\n-    end\n-    ForkThread(function()\n-        if ScenarioInfo.RecallDisabled then\n-            Sync.RecallRequest = {CannotRequest = \"scenario\"}\n-        else\n-            Sync.RecallRequest = {CannotRequest = \"gate\"}\n-            WaitTicks(PlayerGateCooldown + 1)\n-\n-            local focus = GetFocusArmy()\n-            local brain = GetArmyBrain(focus)\n-            for index, brainWith in ArmyBrains do\n-                if brain ~= brainWith then\n-                    if  not brain:IsDefeated() and\n-                        IsAlly(focus, index) and\n-                        brainWith.BrainType ~= \"Human\" and\n-                        not ArmyIsCivilian(index)\n-                    then\n-                        Sync.RecallRequest = {CannotRequest = \"ai\"}\n-                        return\n-                    end\n+        brain.LastRecallRequestTime = playerCooldown\n+        brain.LastRecallVoteTime = teamCooldown\n+    end\n+\n+    -- setup user recall state notifier in this thread\n+    SyncRecallStatus()\n+end\n+\n+function OnArmyChange()\n+    local focus = GetFocusArmy()\n+    if focus == -1 then\n+        SyncCancelRecallVote()\n+        SyncRecallStatus()\n+        return\n+    end\n+    local teamSize = 0\n+    local accept, veto = 0, 0\n+    local votingThreadBrain\n+    for index, brain in ArmyBrains do\n+        if IsAlly(focus, index) and not ArmyIsCivilian(index) then\n+            -- Found a voting thread. We really do need a better way to handle team data...\n+            teamSize = teamSize + 1\n+            if brain.Vote ~= nil then\n+                if brain.Vote then\n+                    accept = accept + 1\n+                else\n+                    veto = veto + 1\n                 end\n             end\n-            Sync.RecallRequest = {CannotRequest = false}\n+            if brain.recallVotingThread then\n+                votingThreadBrain = brain\n+            end\n+        end\n+    end\n+    if votingThreadBrain then\n+        Sync.RecallRequest = {\n+            StartTime = votingThreadBrain.RecallVoteStartTime,\n+            Open = VoteTime * 0.1,\n+            Blocks = teamSize,\n+            Accept = accept,\n+            Veto = veto,\n+            CanVote = GetArmyBrain(focus).Vote ~= nil,\n+        }\n+    end\n+    SyncRecallStatus()\n+end\n+\n+---@param data {From: number, To: number}\n+function OnAllianceChange(data)\n+    local armyFrom, armyTo = data.From, data.To\n+    local oldTeammates = 0\n+    local oldTeam = {}\n+    local votingThreadBrain\n+    for index, ally in ArmyBrains do\n+        if (IsAlly(armyFrom, index) or IsAlly(armyTo, index))\n+            and not ally:IsDefeated()\n+            and not ArmyIsCivilian(index)\n+        then\n+            oldTeammates = oldTeammates + 1\n+            oldTeam[oldTeammates] = ally.Nickname\n+            -- Found a voting thread. We really do need a better way to handle team data...\n+            if ally.recallVotingThread then\n+                votingThreadBrain = ally\n+            end\n+        end\n+    end\n+    if votingThreadBrain then\n+        SPEW(\"Canceling recall voting for team \" .. table.concat(oldTeam, \", \") .. \" due to alliance break\")\n+        votingThreadBrain.VoteCancelled = true\n+        coroutine.resume(votingThreadBrain.recallVotingThread)\n+        if IsAlly(votingThreadBrain, GetFocusArmy()) then\n+            SyncCancelRecallVote()\n+            SyncRecallStatus()\n         end\n-    end)\n+    end\n end\n \n+\n ---@param lastTeamVote number\n ---@param lastPlayerRequest number\n ---@param playerGatein? number\n----@return number cooldown\n----@return CannotRecallReason reason\n+---@return CannotRecallReason CannotRecallReason\n+---@return number? cooldown\n function RecallRequestCooldown(lastTeamVote, lastPlayerRequest, playerGatein)\n-    playerGatein = playerGatein or 0\n+    -- note that this doesn't always return the reason that currently has the longest cooldown, it\n+    -- returns the more \"fundamental\" one (i.e. the reason whose base cooldown is longest)\n+    -- this is more useful in reporting the reason, and isn't a problem when put in a loop\n     local gametime = GetGameTick()\n-    local reqCooldown = lastPlayerRequest + PlayerRequestCooldown - gametime\n-    local voteCooldown = lastTeamVote + TeamVoteCooldown - gametime\n-    local gateCooldown = playerGatein + PlayerGateCooldown - gametime\n-\n-    local largest, reason = reqCooldown, \"request\"\n-    if largest < voteCooldown then\n-        largest, reason = voteCooldown, \"vote\"\n+    local gateCooldown = (playerGatein or 0) + PlayerGateCooldown - gametime\n+    if gateCooldown > 0 then\n+        return \"gate\", gateCooldown\n     end\n-    if largest < gateCooldown then\n-        largest, reason = gateCooldown, \"gate\"\n+    local reqCooldown = lastPlayerRequest + PlayerRequestCooldown - gametime\n+    if reqCooldown > 0 then\n+        return \"request\", reqCooldown\n     end\n-    if largest < 0 then\n-        return 0, false\n+    local voteCooldown = lastTeamVote + TeamVoteCooldown - gametime\n+    if voteCooldown > 0 then\n+        return \"vote\", voteCooldown\n     end\n-    return largest, reason\n+    return false\n end\n \n---- Returns the recall request cooldown for an army\n+--- Returns the current reason an army cannot request recall and the cooldown of that reason, or\n+--- false\n ---@param army Army\n----@return number cooldown\n----@return string reason\n+---@return CannotRecallReason\n+---@return number? cooldown no timeout/cooldown if absent\n function ArmyRecallRequestCooldown(army)\n+    if army == -1 then\n+        return \"observer\"\n+    end\n     local brain = GetArmyBrain(army)\n     if ScenarioInfo.RecallDisabled then\n-        return 36000, \"scenario\"\n+        return \"scenario\"\n     end\n     if brain.RecallVote ~= nil then\n-        return 36000, \"active\"\n+        return \"active\", VoteTime\n     end\n     local lastPlayerRequest = brain.LastRecallRequestTime\n     local lastTeamVote\n     army = brain.Army\n     lastTeamVote = lastPlayerRequest\n     for index, ally in ArmyBrains do\n-        if not ally:IsDefeated() and IsAlly(army, index) and not ArmyIsCivilian(index) then\n+        if IsAlly(army, index) and not ally:IsDefeated() and not ArmyIsCivilian(index) then\n+            if ally.BrainType ~= \"Human\" then\n+                return \"ai\"\n+            end\n             local allyTeamVote = ally.LastRecallVoteTime\n             if allyTeamVote < lastTeamVote then\n                 lastTeamVote = allyTeamVote\n             end\n         end\n     end\n+    -- if someone adds a feature that gates in commanders at different times, that time should be\n+    -- added as an argument to this method call\n     return RecallRequestCooldown(lastTeamVote, lastPlayerRequest)\n end\n \n----@param reason CannotRecallReason\n-local function SetCannotRequestRecall(reason)\n-    local recallSync = Sync.RecallRequest\n-    if not recallSync then\n-        Sync.RecallRequest = {CannotRequest = reason}\n-    else\n-        recallSync.CannotRequest = reason\n-    end\n-end\n-\n+---@param requestingArmy number\n local function RecallVotingThread(requestingArmy)\n-    WaitTicks(VoteTime + 1)\n+    local requestingBrain = GetArmyBrain(requestingArmy)\n+    requestingBrain.RecallVoteStartTime = GetGameTick()\n+    WaitTicks(VoteTime) -- may be interrupted if the vote closes or is canceled by an alliance break\n+\n+    local focus = GetFocusArmy()\n+    if requestingBrain.VoteCancelled then\n+        if IsAlly(requestingArmy, focus) then\n+            SyncCancelRecallVote()\n+            SyncRecallStatus()\n+        end\n+        requestingBrain.VoteCancelled = nil\n+        requestingBrain.RecallVoteStartTime = nil\n+        requestingBrain.recallVotingThread = nil\n+        return\n+    end\n \n     local gametick = GetGameTick()\n     local recallAcceptance = 0\n-    local team = {}\n     local teammates = 0\n+    local team = {}\n     for index, brain in ArmyBrains do\n         if not brain:IsDefeated() and IsAlly(requestingArmy, brain.Army) and not ArmyIsCivilian(index) then\n             teammates = teammates + 1\n@@ -114,49 +192,47 @@ local function RecallVotingThread(requestingArmy)\n             brain.LastRecallVoteTime = gametick\n         end\n     end\n+    -- this function is found in the recall params file, for those looking\n     local recallAccepted = RecallRequestAccepted(recallAcceptance, teammates)\n-    local focus = GetFocusArmy()\n-    local brain = GetArmyBrain(requestingArmy)\n     if IsAlly(focus, requestingArmy) then\n-        Sync.RecallRequest = {\n-            Close = recallAccepted,\n-        }\n+        SyncCloseRecallVote(recallAccepted)\n+        -- the recall UI will handle the announcement in this case\n     elseif recallAccepted then\n-        local dip = Sync.DiplomacyAnnouncement\n-        if not dip then\n-            dip = {}\n-            Sync.DiplomacyAnnouncement = dip\n-        end\n-        table.insert(dip, {\n+        -- in this case though, we need to handle the announcement\n+        SyncAnnouncement {\n             Action = \"recall\",\n-            Team = brain.Nickname,\n-        })\n+            Team = requestingBrain.Nickname,\n+        }\n+    end\n+    local listTeam = team[1].Nickname\n+    for i = 2, table.getn(team) do\n+        listTeam = listTeam .. \", \" .. team[i].Nickname\n     end\n     if recallAccepted then\n-        SPEW(\"Vote passed; recalling!\")\n-        for army, brain in team do\n+        SPEW(\"Recalling team \" .. listTeam .. \" at the request of \" .. requestingBrain.Nickname .. \" (vote passed \" .. recallAcceptance .. \" to \" .. (teammates - recallAcceptance ) .. \")\")\n+        for _, brain in team do\n             brain:RecallAllCommanders()\n         end\n     else\n-        brain.LastRecallRequestTime = gametick\n-\n+        SPEW(\"Not recalling team \" .. listTeam .. \" (vote failed \" .. recallAcceptance .. \" to \" .. (teammates - recallAcceptance ) .. \")\")\n+        requestingBrain.LastRecallRequestTime = gametick\n+    end\n+    if IsAlly(requestingArmy, focus) then\n         -- update UI once the cooldown dissipates\n-        local cooldown, reason = ArmyRecallRequestCooldown(focus)\n-        repeat\n-            SetCannotRequestRecall(reason)\n-            WaitTicks(cooldown + 1)\n-\n-            cooldown, reason = ArmyRecallRequestCooldown(focus)\n-        until cooldown <= 0\n-        SetCannotRequestRecall(false)\n+        SyncRecallStatus()\n     end\n-    brain.recallVotingThread = nil\n+    requestingBrain.RecallVoteStartTime = nil\n+    requestingBrain.recallVotingThread = nil\n end\n \n+---@param army number\n+---@param vote boolean\n+---@param lastVote boolean\n+---@return boolean # if further user sync should happen\n local function ArmyVoteRecall(army, vote, lastVote)\n     if lastVote then\n         for index, ally in ArmyBrains do\n-            if army ~= index and not ally:IsDefeated() and IsAlly(army, index) then\n+            if army ~= index and IsAlly(army, index) and not ally:IsDefeated() then\n                 local thread = ally.recallVotingThread\n                 if thread then\n                     -- end voting period\n@@ -168,87 +244,82 @@ local function ArmyVoteRecall(army, vote, lastVote)\n     end\n \n     local focus = GetFocusArmy()\n-    -- don't update the recall panel for votes we aren't a part of\n-    if not IsAlly(focus, army) then\n-        return false\n-    end\n-    local recallSync = Sync.RecallRequest\n-    if not recallSync then\n-        recallSync = {}\n-        Sync.RecallRequest = recallSync\n-    end\n-    if vote then\n-        local accept = recallSync.Accept or 0\n-        recallSync.Accept = accept + 1\n-    else\n-        local veto = recallSync.Veto or 0\n-        recallSync.Veto = veto + 1\n+    if focus == -1 or not IsAlly(focus, army) then\n+        return false -- don't update the recall panel for votes we aren't a part of or for observers\n     end\n+    SyncRecallVote(vote)\n     if army == focus then\n-        recallSync.CannotRequest = \"active\"\n+        SyncCannotRequestRecall(\"active\")\n     end\n     return true\n end\n \n-local function ArmyRequestRecall(army, teammates, lastVote)\n+---@param army number\n+---@param teammates number\n+local function ArmyRequestRecall(army, teammates)\n+    local brain = GetArmyBrain(army)\n     if teammates > 0 then\n-        GetArmyBrain(army).recallVotingThread = ForkThread(RecallVotingThread, army)\n-        if ArmyVoteRecall(army, true, lastVote) then\n-            local recallSync = Sync.RecallRequest\n-            recallSync.Open = VoteTime * 0.1\n-            recallSync.CanVote = army ~= GetFocusArmy()\n-            recallSync.Blocks = teammates + 1\n+        brain.recallVotingThread = ForkThread(RecallVotingThread, army)\n+        if ArmyVoteRecall(army, true, false) then\n+            SyncOpenRecallVote(teammates + 1, army)\n         end\n-    elseif lastVote then\n-        -- if we're the first and last vote, it's just us; recall our army\n-        SPEW(\"Immediately recalling\")\n-        GetArmyBrain(army):RecallAllCommanders()\n+    else\n+        -- it's just us; recall our army\n+        SPEW(\"Recalling \" .. brain.Nickname)\n+        brain:RecallAllCommanders()\n+\n     end\n end\n \n ---@param data {From: number, Vote: boolean}\n function SetRecallVote(data)\n-    local focus = GetFocusArmy()\n     local army = data.From\n+    if not OkayToMessWithArmy(army) then\n+        return\n+    end\n+    local focus = GetFocusArmy()\n     if not ScenarioInfo.TeamGame then\n         if army == focus then\n-            SetCannotRequestRecall(\"scenario\")\n+            SyncCannotRequestRecall(\"scenario\")\n         end\n         return\n     end\n     local vote = data.Vote and true or false\n \n+    -- determine team voting status\n     local isRequest = true\n     local lastVote = true\n     local teammates = 0\n+    local team = {}\n     for index, ally in ArmyBrains do\n         if army ~= index and not ally:IsDefeated() and IsAlly(army, index) and not ArmyIsCivilian(index) then\n             if ally.BrainType ~= \"Human\" then\n                 if army == focus then\n-                    SetCannotRequestRecall(\"ai\")\n+                    SyncCannotRequestRecall(\"ai\")\n                 end\n                 return\n             end\n             local allyHasVoted = ally.RecallVote ~= nil\n-            lastVote = lastVote and allyHasVoted\n-            isRequest = isRequest and not allyHasVoted\n+            lastVote = lastVote and allyHasVoted -- only the last vote if all allies have also voted\n+            isRequest = isRequest and not allyHasVoted -- only the last vote if no allies have voted\n             teammates = teammates + 1\n+            team[teammates] = ally.Nickname\n         end\n     end\n \n     local brain = GetArmyBrain(army)\n     if isRequest then\n         -- the player is making a recall request; this will reset their recall request cooldown\n-        local cooldown, reason = ArmyRecallRequestCooldown(army)\n-        if cooldown > 0 then\n+        local reason = ArmyRecallRequestCooldown(army)\n+        if reason then\n             if army == focus then\n-                SetCannotRequestRecall(reason)\n+                SyncCannotRequestRecall(reason)\n             end\n             return\n         end\n-        SPEW(\"Army \" .. tostring(army) .. \" is requesting recall\")\n+        SPEW(\"Army \" .. tostring(army) .. \" is requesting recall for \" .. table.concat(team, ','))\n         brain.RecallVote = vote\n-        ArmyRequestRecall(army, teammates, lastVote)\n+        ArmyRequestRecall(army, teammates)\n     else\n         -- the player is responding to a recall request; we don't count this against their\n         -- individual recall request cooldown\n@@ -257,3 +328,89 @@ function SetRecallVote(data)\n         ArmyVoteRecall(army, vote, lastVote)\n     end\n end\n+\n+\n+---@param reason CannotRecallReason\n+function SyncCannotRequestRecall(reason)\n+    local recallSync = Sync.RecallRequest\n+    if not recallSync then\n+        Sync.RecallRequest = {CannotRequest = reason}\n+    else\n+        recallSync.CannotRequest = reason\n+    end\n+end\n+\n+---@param result boolean\n+function SyncCloseRecallVote(result)\n+    local recallSync = Sync.RecallRequest\n+    if not recallSync then\n+        Sync.RecallRequest = {Close = result}\n+    else\n+        recallSync.Close = result\n+    end\n+end\n+\n+function SyncCancelRecallVote()\n+    local recallSync = Sync.RecallRequest\n+    if not recallSync then\n+        Sync.RecallRequest = {Cancel = true}\n+    else\n+        recallSync.Cancel = true\n+    end\n+end\n+\n+---@param vote boolean\n+function SyncRecallVote(vote)\n+    local recallSync = Sync.RecallRequest\n+    if not recallSync then\n+        recallSync = {}\n+        Sync.RecallRequest = recallSync\n+    end\n+    if vote then\n+        recallSync.Accept = (recallSync.Accept or 0) + 1\n+    else\n+        recallSync.Veto = (recallSync.Veto or 0) + 1\n+    end\n+end\n+\n+---@param teamSize number\n+---@param army number\n+function SyncOpenRecallVote(teamSize, army)\n+    local recallSync = Sync.RecallRequest\n+    if not recallSync then\n+        recallSync = {}\n+        Sync.RecallRequest = recallSync\n+    end\n+    local focus = GetFocusArmy()\n+    recallSync.Open = VoteTime * 0.1\n+    recallSync.CanVote = focus ~= -1 and army ~= focus\n+    recallSync.Blocks = teamSize\n+end\n+\n+local UserRecallStatusThread\n+\n+local function SyncRecallStatusThread()\n+    local reason, cooldown = ArmyRecallRequestCooldown(GetFocusArmy())\n+    while reason do\n+        SyncCannotRequestRecall(reason)\n+        if not cooldown then\n+            UserRecallStatusThread = nil\n+            return\n+        end\n+        -- may be interrupted for various reasons, such as the focus army changing\n+        -- this will be fine, we'll pick up the proper cooldown reason anyway and loop again\n+        WaitTicks(cooldown)\n+\n+        reason, cooldown = ArmyRecallRequestCooldown(GetFocusArmy())\n+    end\n+    SyncCannotRequestRecall(false)\n+    UserRecallStatusThread = nil\n+end\n+\n+function SyncRecallStatus()\n+    if UserRecallStatusThread then\n+        coroutine.resume(UserRecallStatusThread) -- force update the existing thread\n+    else\n+        UserRecallStatusThread = ForkThread(SyncRecallStatusThread)\n+    end\n+end"
        },
        {
          "filename": "lua/ui/game/diplomacy.lua",
          "status": "modified",
          "additions": 32,
          "deletions": 20,
          "patch": "@@ -36,14 +36,14 @@ local offerQueue = {}\n local drawOffered = false\n \n ---@type CannotRecallReason\n-local cannotRequestRecall = false\n+local CannotRequestRecallReason = false\n \n-function CannotRequestRecall()\n-    return cannotRequestRecall\n+function GetCannotRequestRecallReason()\n+    return CannotRequestRecallReason\n end\n \n-function UpdateCannotRequestRecall(canRequest)\n-    cannotRequestRecall = canRequest\n+function SetCannotRequestRecallReason(canRequest)\n+    CannotRequestRecallReason = canRequest\n     if parent then\n         BuildPlayerLines()\n     end\n@@ -379,6 +379,12 @@ end\n function BuildPlayerLines()\n     local sessionOptions = SessionGetScenarioInfo().Options\n     local focusArmy = GetFocusArmy()\n+    if focusArmy == -1 then\n+        focusArmy = import(\"/lua/ui/game/gamemain.lua\").OriginalFocusArmy\n+        if focusArmy == -1 then\n+            return\n+        end\n+    end\n \n     local group = parent.personalGroup\n     if group then\n@@ -416,7 +422,8 @@ function BuildPlayerLines()\n \n     local belowEntry = parent\n \n-    if not import(\"/lua/ui/campaign/campaignmanager.lua\").campaignMode then\n+    local reason = GetCannotRequestRecallReason()\n+    if not import(\"/lua/ui/campaign/campaignmanager.lua\").campaignMode and reason ~= \"observer\" then\n         local personalGroup = CreateBitmapStd(parent, \"/game/options-diplomacy-panel/panel-recall\")\n         if belowEntry == parent then\n             LayoutHelpers.AtLeftTopIn(personalGroup, belowEntry, 0, 8)\n@@ -431,28 +438,32 @@ function BuildPlayerLines()\n             :Over(personalGroup, 5)\n         personalGroup.button = recallButton\n \n-        local reason = CannotRequestRecall()\n         if reason then\n             recallButton:Disable()\n             Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_\" .. reason)\n         else\n+            local function OnAcceptRecall()\n+                SimCallback({\n+                    Func = \"SetRecallVote\",\n+                    Args = {\n+                        From = GetFocusArmy(),\n+                        Vote = true,\n+                    },\n+                })\n+                -- preemptively expect the sim to accept our recall and disable the button so we\n+                -- can't possiblely confuse the sim with more than one request\n+                -- note that if--for some reason (*ahem* due to a mod maybe)--the sim *doesn't*\n+                -- end up accepting it, then we'll be stuck until the sim sends a new update\n+                recallButton:Disable()\n+                SetCannotRequestRecallReason(\"active\")\n+                Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_active\")\n+                import(\"/lua/ui/game/tabs.lua\").CollapseWindow()\n+            end\n             recallButton.OnClick = function(self, modifiers)\n                 UIUtil.QuickDialog(GetFrame(0),\n                     \"<LOC diplomacy_0019>Are you sure you're ready to recall from battle? This will send a request to your team.\",\n                     \"<LOC _Yes>\",\n-                    function()\n-                        SimCallback({\n-                            Func = \"SetRecallVote\",\n-                            Args = {\n-                                From = GetFocusArmy(),\n-                                Vote = true,\n-                            },\n-                        })\n-                        recallButton:Disable()\n-                        cannotRequestRecall = \"active\"\n-                        Tooltip.AddButtonTooltip(recallButton, \"dip_recall_request_dis_active\")\n-                        import(\"/lua/ui/game/tabs.lua\").CollapseWindow()\n-                    end,\n+                    OnAcceptRecall,\n                     \"<LOC _No>\", nil, nil, nil, nil,\n                     {worldCover = false, enterButton = 1, escapeButton = 2}\n                 )\n@@ -462,6 +473,7 @@ function BuildPlayerLines()\n \n         local recallIcon = CreateBitmapStd(recallButton, \"/game/recall-panel/icon-recall\")\n         Layouter(recallIcon)\n+            --:DisableHitTest()\n             :AtCenterIn(recallButton)\n             :Over(recallButton, 5)\n         recallButton.label = recallIcon"
        },
        {
          "filename": "lua/ui/game/recall.lua",
          "status": "modified",
          "additions": 17,
          "deletions": 5,
          "patch": "@@ -58,17 +58,19 @@ end\n \n function RequestHandler(data)\n     if data.CannotRequest ~= nil then\n-        import(\"/lua/ui/game/diplomacy.lua\").UpdateCannotRequestRecall(data.CannotRequest)\n+        import(\"/lua/ui/game/diplomacy.lua\").SetCannotRequestRecallReason(data.CannotRequest)\n     end\n     if data.Open then\n-        panel:StartVote(data.Blocks, data.Open, data.CanVote)\n+        panel:StartVote(data.Blocks, data.Open, data.CanVote, data.StartTime)\n     end\n     local accept, veto = data.Accept, data.Veto\n     if accept or veto then\n         panel:AddVotes(accept, veto)\n     end\n     if data.Close ~= nil then\n         panel:CloseVote(data.Close)\n+    elseif data.Cancel then\n+        panel:CancelVote()\n     end\n end\n \n@@ -266,10 +268,9 @@ RecallPanel = Class(NinePatch.NinePatch) {\n         end\n     end;\n \n-    StartVote = function(self, blocks, duration, canVote)\n-        SPEW(\"Recall voting!\")\n+    StartVote = function(self, blocks, duration, canVote, startingTime)\n         self.duration = duration\n-        self.startTime:Set(GetGameTimeSeconds())\n+        self.startTime:Set(startingTime or GetGameTimeSeconds())\n         self:SetCanVote(canVote)\n         self:LayoutBlocks(blocks) -- can depend on `canVote`, so put after it\n         self.collapseArrow:Enable()\n@@ -297,6 +298,16 @@ RecallPanel = Class(NinePatch.NinePatch) {\n         end\n     end;\n \n+    CancelVote = function(self)\n+        self:SetCanVote(false)\n+        self.startTime:Set(-9999) -- make sure the OnFrame animation ends\n+        if self.reviewResultsThread then\n+            KillThread(self.reviewResultsThread)\n+            self.reviewResultsThread = nil\n+        end\n+        self:OnResultsReviewed()\n+    end;\n+\n     CloseVote = function(self, accepted)\n         self:SetCanVote(false)\n         self.startTime:Set(-9999) -- make sure the OnFrame animation ends\n@@ -386,6 +397,7 @@ RecallPanel = Class(NinePatch.NinePatch) {\n             if time >= dur then\n                 self.startTime:Set(-9999)\n                 self.progressBar.Width:Set(0)\n+                self.progressBar:Hide()\n             else\n                 self.progressBar.Width:Set((1 - time / dur) * nominalWidth)\n             end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f6d432f831f045abfc68d9eb823b9d0a23bda7e0",
            "date": "2025-01-26T04:19:17Z",
            "author_login": "lL1l1"
          },
          {
            "sha": "e56cb1d92c7ece63b01776d0f6ef6e675a198c95",
            "date": "2025-01-25T20:03:21Z",
            "author_login": "Garanas"
          },
          {
            "sha": "5e11ed18e6327c54a817dc21fc4a3bf910325ee0",
            "date": "2025-01-25T20:00:28Z",
            "author_login": "lL1l1"
          },
          {
            "sha": "fbceb4c606b2e05b35e035a0e92fea0a0c5078aa",
            "date": "2025-01-25T19:53:05Z",
            "author_login": "relent0r"
          },
          {
            "sha": "e2ab8e54cf0080163c4c80a61a0e1768db16fd18",
            "date": "2025-01-25T19:51:10Z",
            "author_login": "lL1l1"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.6,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L",
    "cwe_id": "CWE-285",
    "description": "A vulnerability was found in Forged Alliance Forever up to 3746. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the component Vote Handler. The manipulation leads to improper authorization. Upgrading to version 3747 is able to address this issue. The patch is named 6880971bd3d73d942384aff62d53058c206ce644. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217555.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-06T11:15:09.557",
    "last_modified": "2024-11-21T07:36:07.660",
    "fix_date": "2022-11-15T17:05:38Z"
  },
  "references": [
    {
      "url": "https://github.com/FAForever/fa/commit/6880971bd3d73d942384aff62d53058c206ce644",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/FAForever/fa/pull/4398",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/FAForever/fa/releases/tag/3747",
      "source": "cna@vuldb.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217555",
      "source": "cna@vuldb.com",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217555",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FAForever/fa/commit/6880971bd3d73d942384aff62d53058c206ce644",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/FAForever/fa/pull/4398",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/FAForever/fa/releases/tag/3747",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.217555",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://vuldb.com/?id.217555",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.520121",
    "processing_status": "enhanced"
  }
}