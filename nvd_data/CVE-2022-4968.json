{
  "cve_id": "CVE-2022-4968",
  "github_data": {
    "repository": "canonical/netplan",
    "fix_commit": "4c39b75b5c6ae7d976bda6da68da60d9a7f085ee",
    "related_commits": [
      "4c39b75b5c6ae7d976bda6da68da60d9a7f085ee",
      "4c39b75b5c6ae7d976bda6da68da60d9a7f085ee"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4c39b75b5c6ae7d976bda6da68da60d9a7f085ee",
      "commit_date": "2024-05-22T14:44:16Z",
      "author": {
        "login": "daniloegea",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "libnetplan: use more restrictive file permissions",
        "length": 887,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 190,
        "additions": 152,
        "deletions": 38
      },
      "files": [
        {
          "filename": "src/networkd.c",
          "status": "modified",
          "additions": 9,
          "deletions": 31,
          "patch": "@@ -302,7 +302,6 @@ STATIC void\n write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n {\n     GString* s = NULL;\n-    mode_t orig_umask;\n \n     /* Don't write .link files for virtual devices; they use .netdev instead.\n      * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n@@ -374,9 +373,7 @@ write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char\n         g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n         (def->large_receive_offload ? \"true\" : \"false\"));\n \n-    orig_umask = umask(022);\n-    _netplan_g_string_free_to_file(s, rootdir, path, \".link\");\n-    umask(orig_umask);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".link\", \"root\", \"root\", 0640);\n }\n \n STATIC gboolean\n@@ -394,7 +391,7 @@ write_regdom(const NetplanNetDefinition* def, const char* rootdir, GError** erro\n     g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n     g_string_append_printf(s, \"ExecStart=\"SBINDIR\"/iw reg set %s\\n\", def->regulatory_domain);\n \n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n     _netplan_safe_mkdir_p_dir(link);\n     if (symlink(path, link) < 0 && errno != EEXIST) {\n         // LCOV_EXCL_START\n@@ -586,7 +583,6 @@ STATIC void\n write_netdev_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n {\n     GString* s = NULL;\n-    mode_t orig_umask;\n \n     g_assert(def->type >= NETPLAN_DEF_TYPE_VIRTUAL);\n \n@@ -685,11 +681,7 @@ write_netdev_file(const NetplanNetDefinition* def, const char* rootdir, const ch\n         default: g_assert_not_reached(); // LCOV_EXCL_LINE\n     }\n \n-    /* these do not contain secrets and need to be readable by\n-     * systemd-networkd - LP: #1736965 */\n-    orig_umask = umask(022);\n-    _netplan_g_string_free_to_file(s, rootdir, path, \".netdev\");\n-    umask(orig_umask);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".netdev\", \"root\", NETWORKD_GROUP, 0640);\n }\n \n STATIC void\n@@ -833,7 +825,6 @@ _netplan_netdef_write_network_file(\n     g_autoptr(GString) network = NULL;\n     g_autoptr(GString) link = NULL;\n     GString* s = NULL;\n-    mode_t orig_umask;\n \n     SET_OPT_OUT_PTR(has_been_written, FALSE);\n \n@@ -1099,11 +1090,7 @@ _netplan_netdef_write_network_file(\n         if (network->len > 0)\n             g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n \n-        /* these do not contain secrets and need to be readable by\n-         * systemd-networkd - LP: #1736965 */\n-        orig_umask = umask(022);\n-        _netplan_g_string_free_to_file(s, rootdir, path, \".network\");\n-        umask(orig_umask);\n+        _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".network\", \"root\", NETWORKD_GROUP, 0640);\n     }\n \n     SET_OPT_OUT_PTR(has_been_written, TRUE);\n@@ -1115,7 +1102,6 @@ write_rules_file(const NetplanNetDefinition* def, const char* rootdir)\n {\n     GString* s = NULL;\n     g_autofree char* path = g_strjoin(NULL, \"run/udev/rules.d/99-netplan-\", def->id, \".rules\", NULL);\n-    mode_t orig_umask;\n \n     /* do we need to write a .rules file?\n      * It's only required for reliably setting the name of a physical device\n@@ -1149,9 +1135,7 @@ write_rules_file(const NetplanNetDefinition* def, const char* rootdir)\n \n     g_string_append_printf(s, \"NAME=\\\"%s\\\"\\n\", def->set_name);\n \n-    orig_umask = umask(022);\n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n-    umask(orig_umask);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n }\n \n STATIC gboolean\n@@ -1300,7 +1284,6 @@ STATIC void\n write_wpa_unit(const NetplanNetDefinition* def, const char* rootdir)\n {\n     g_autofree gchar *stdouth = NULL;\n-    mode_t orig_umask;\n \n     stdouth = systemd_escape(def->id);\n \n@@ -1319,9 +1302,7 @@ write_wpa_unit(const NetplanNetDefinition* def, const char* rootdir)\n     } else {\n         g_string_append(s, \" -Dnl80211,wext\\n\");\n     }\n-    orig_umask = umask(022);\n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n-    umask(orig_umask);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n }\n \n STATIC gboolean\n@@ -1330,7 +1311,6 @@ write_wpa_conf(const NetplanNetDefinition* def, const char* rootdir, GError** er\n     GHashTableIter iter;\n     GString* s = g_string_new(\"ctrl_interface=/run/wpa_supplicant\\n\\n\");\n     g_autofree char* path = g_strjoin(NULL, \"run/netplan/wpa-\", def->id, \".conf\", NULL);\n-    mode_t orig_umask;\n \n     g_debug(\"%s: Creating wpa_supplicant configuration file %s\", def->id, path);\n     if (def->type == NETPLAN_DEF_TYPE_WIFI) {\n@@ -1423,9 +1403,7 @@ write_wpa_conf(const NetplanNetDefinition* def, const char* rootdir, GError** er\n     }\n \n     /* use tight permissions as this contains secrets */\n-    orig_umask = umask(077);\n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n-    umask(orig_umask);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0600);\n     return TRUE;\n }\n \n@@ -1569,7 +1547,7 @@ _netplan_networkd_write_wait_online(const NetplanState* np_state, const char* ro\n     GString* content = g_string_new(\"[Unit]\\n\"\n         \"ConditionPathIsSymbolicLink=/run/systemd/generator/network-online.target.wants/systemd-networkd-wait-online.service\\n\");\n     if (g_hash_table_size(non_optional_interfaces) == 0) {\n-        _netplan_g_string_free_to_file(content, rootdir, override, NULL);\n+        _netplan_g_string_free_to_file_with_permissions(content, rootdir, override, NULL, \"root\", \"root\", 0640);\n         g_hash_table_destroy(non_optional_interfaces);\n         return FALSE;\n     }\n@@ -1593,7 +1571,7 @@ _netplan_networkd_write_wait_online(const NetplanState* np_state, const char* ro\n     }\n     g_string_append(content, \"\\n\");\n \n-    _netplan_g_string_free_to_file(content, rootdir, override, NULL);\n+    _netplan_g_string_free_to_file_with_permissions(content, rootdir, override, NULL, \"root\", \"root\", 0640);\n     g_hash_table_destroy(non_optional_interfaces);\n     return TRUE;\n }"
        },
        {
          "filename": "src/networkd.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -20,6 +20,8 @@\n #include \"netplan.h\"\n #include <glib.h>\n \n+#define NETWORKD_GROUP \"systemd-network\"\n+\n NETPLAN_INTERNAL gboolean\n _netplan_netdef_write_networkd(\n         const NetplanState* np_state,"
        },
        {
          "filename": "src/nm.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1152,13 +1152,13 @@ netplan_state_finish_nm_write(\n \n     /* write generated NetworkManager drop-in config */\n     if (nm_conf->len > 0)\n-        _netplan_g_string_free_to_file(nm_conf, rootdir, \"run/NetworkManager/conf.d/netplan.conf\", NULL);\n+        _netplan_g_string_free_to_file_with_permissions(nm_conf, rootdir, \"run/NetworkManager/conf.d/netplan.conf\", NULL, \"root\", \"root\", 0640);\n     else\n         g_string_free(nm_conf, TRUE);\n \n     /* write generated udev rules */\n     if (udev_rules->len > 0)\n-        _netplan_g_string_free_to_file(udev_rules, rootdir, \"run/udev/rules.d/90-netplan.rules\", NULL);\n+        _netplan_g_string_free_to_file_with_permissions(udev_rules, rootdir, \"run/udev/rules.d/90-netplan.rules\", NULL, \"root\", \"root\", 0640);\n     else\n         g_string_free(udev_rules, TRUE);\n "
        },
        {
          "filename": "src/openvswitch.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -66,7 +66,7 @@ write_ovs_systemd_unit(const char* id, const GString* cmds, const char* rootdir,\n         g_string_append(s, \"StartLimitBurst=0\\n\");\n     g_string_append(s, cmds->str);\n \n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n \n     _netplan_safe_mkdir_p_dir(link);\n     if (symlink(path, link) < 0 && errno != EEXIST) {"
        },
        {
          "filename": "src/sriov.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -54,7 +54,7 @@ write_sriov_rebind_systemd_unit(GHashTable* pfs, const char* rootdir, GError** e\n     g_string_truncate(interfaces, interfaces->len-1); /* cut trailing whitespace */\n     g_string_append_printf(s, \"ExecStart=\" SBINDIR \"/netplan rebind --debug %s\\n\", interfaces->str);\n \n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n     g_string_free(interfaces, TRUE);\n \n     _netplan_safe_mkdir_p_dir(link);\n@@ -90,7 +90,7 @@ write_sriov_apply_systemd_unit(GHashTable* pfs, const char* rootdir, GError** er\n     g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n     g_string_append_printf(s, \"ExecStart=\" SBINDIR \"/netplan apply --sriov-only\\n\");\n \n-    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n+    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n \n     _netplan_safe_mkdir_p_dir(link);\n     if (symlink(path, link) < 0 && errno != EEXIST) {"
        },
        {
          "filename": "src/util-internal.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -40,6 +40,9 @@ _netplan_safe_mkdir_p_dir(const char* file_path);\n NETPLAN_INTERNAL void\n _netplan_g_string_free_to_file(GString* s, const char* rootdir, const char* path, const char* suffix);\n \n+void\n+_netplan_g_string_free_to_file_with_permissions(GString* s, const char* rootdir, const char* path, const char* suffix, const char* owner, const char* group, mode_t mode);\n+\n NETPLAN_INTERNAL void\n _netplan_unlink_glob(const char* rootdir, const char* _glob);\n "
        },
        {
          "filename": "src/util.c",
          "status": "modified",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -23,6 +23,9 @@\n #include <regex.h>\n #include <string.h>\n #include <sys/mman.h>\n+#include <sys/types.h>\n+#include <pwd.h>\n+#include <grp.h>\n \n #include <glib.h>\n #include <glib/gprintf.h>\n@@ -87,6 +90,49 @@ void _netplan_g_string_free_to_file(GString* s, const char* rootdir, const char*\n     }\n }\n \n+void _netplan_g_string_free_to_file_with_permissions(GString* s, const char* rootdir, const char* path, const char* suffix, const char* owner, const char* group, mode_t mode)\n+{\n+    g_autofree char* full_path = NULL;\n+    g_autofree char* path_suffix = NULL;\n+    g_autofree char* contents = g_string_free(s, FALSE);\n+    GError* error = NULL;\n+    struct passwd* pw = NULL;\n+    struct group* gr = NULL;\n+    int ret = 0;\n+\n+    path_suffix = g_strjoin(NULL, path, suffix, NULL);\n+    full_path = g_build_path(G_DIR_SEPARATOR_S, rootdir ?: G_DIR_SEPARATOR_S, path_suffix, NULL);\n+    _netplan_safe_mkdir_p_dir(full_path);\n+    if (!g_file_set_contents_full(full_path, contents, -1, G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING, mode, &error)) {\n+        /* the mkdir() just succeeded, there is no sensible\n+         * method to test this without root privileges, bind mounts, and\n+         * simulating ENOSPC */\n+        // LCOV_EXCL_START\n+        g_fprintf(stderr, \"ERROR: cannot create file %s: %s\\n\", path, error->message);\n+        exit(1);\n+        // LCOV_EXCL_STOP\n+    }\n+\n+    /* Here we take the owner and group names and look up for their IDs in the passwd and group files.\n+     * It's OK to fail to set the owners and mode as this code will be called from unit tests.\n+     * The autopkgtests will check if the owner/group and mode are correctly set.\n+     */\n+    pw = getpwnam(owner);\n+    if (!pw) {\n+        g_debug(\"Failed to determine the UID of user %s: %s\", owner, strerror(errno)); // LCOV_EXCL_LINE\n+    }\n+    gr = getgrnam(group);\n+    if (!gr) {\n+        g_debug(\"Failed to determine the GID of group %s: %s\", group, strerror(errno)); // LCOV_EXCL_LINE\n+    }\n+    if (pw && gr) {\n+        ret = chown(full_path, pw->pw_uid, gr->gr_gid);\n+        if (ret != 0) {\n+            g_debug(\"Failed to set owner and group for file %s: %s\", full_path, strerror(errno));\n+        }\n+    }\n+}\n+\n /**\n  * Remove all files matching given glob.\n  */"
        },
        {
          "filename": "tests/generator/test_auth.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -226,7 +226,7 @@ def test_auth_wired(self):\n \n         with open(os.path.join(self.workdir.name, 'run/systemd/system/netplan-wpa-eth0.service')) as f:\n             self.assertEqual(f.read(), SD_WPA % {'iface': 'eth0', 'drivers': 'wired'})\n-            self.assertEqual(stat.S_IMODE(os.fstat(f.fileno()).st_mode), 0o644)\n+            self.assertEqual(stat.S_IMODE(os.fstat(f.fileno()).st_mode), 0o640)\n         self.assertTrue(os.path.islink(os.path.join(\n             self.workdir.name, 'run/systemd/system/systemd-networkd.service.wants/netplan-wpa-eth0.service')))\n "
        },
        {
          "filename": "tests/generator/test_wifis.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -140,7 +140,7 @@ def test_wifi(self):\n             self.workdir.name, 'run/systemd/system/netplan-wpa-wl0.service')))\n         with open(os.path.join(self.workdir.name, 'run/systemd/system/netplan-wpa-wl0.service')) as f:\n             self.assertEqual(f.read(), SD_WPA % {'iface': 'wl0', 'drivers': 'nl80211,wext'})\n-            self.assertEqual(stat.S_IMODE(os.fstat(f.fileno()).st_mode), 0o644)\n+            self.assertEqual(stat.S_IMODE(os.fstat(f.fileno()).st_mode), 0o640)\n         self.assertTrue(os.path.islink(os.path.join(\n             self.workdir.name, 'run/systemd/system/systemd-networkd.service.wants/netplan-wpa-wl0.service')))\n "
        },
        {
          "filename": "tests/integration/base.py",
          "status": "modified",
          "additions": 85,
          "deletions": 0,
          "patch": "@@ -32,6 +32,8 @@\n import gi\n import glob\n import json\n+import pwd\n+import grp\n \n # make sure we point to libnetplan properly.\n os.environ.update({'LD_LIBRARY_PATH': '.:{}'.format(os.environ.get('LD_LIBRARY_PATH'))})\n@@ -375,6 +377,89 @@ def generate_and_settle(self, wait_interfaces=None, state_dir=None):\n             if state:\n                 self.wait_output(['ip', 'addr', 'show', iface], state, 30)\n \n+        # Assert file permissions\n+        self.assert_file_permissions()\n+\n+    def assert_file_permissions(self):\n+        \"\"\" Check if the generated files have the expected permissions \"\"\"\n+\n+        nd_expected_mode = 0o100640\n+        nd_expected_owner = 'root'\n+        nd_expected_group = 'systemd-network'\n+\n+        sd_expected_mode = 0o100640\n+        sd_expected_owner = 'root'\n+        sd_expected_group = 'root'\n+\n+        udev_expected_mode = 0o100640\n+        udev_expected_owner = 'root'\n+        udev_expected_group = 'root'\n+\n+        nm_expected_mode = 0o100600\n+        nm_expected_owner = 'root'\n+        nm_expected_group = 'root'\n+\n+        wpa_expected_mode = 0o100600\n+        wpa_expected_owner = 'root'\n+        wpa_expected_group = 'root'\n+\n+        # Check systemd-networkd files\n+        base_path = '/run/systemd/network'\n+        files = glob.glob(f'{base_path}/*.network') + glob.glob(f'{base_path}/*.netdev')\n+        for file in files:\n+            res = os.stat(file)\n+            user = pwd.getpwuid(res.st_uid)\n+            group = grp.getgrgid(res.st_gid)\n+            self.assertEqual(res.st_mode, nd_expected_mode, f'file {file}')\n+            self.assertEqual(user.pw_name, nd_expected_owner, f'file {file}')\n+            self.assertEqual(group.gr_name, nd_expected_group, f'file {file}')\n+\n+        # Check Network Manager files\n+        base_path = '/run/NetworkManager/system-connections'\n+        files = glob.glob(f'{base_path}/*.nmconnection')\n+        for file in files:\n+            res = os.stat(file)\n+            user = pwd.getpwuid(res.st_uid)\n+            group = grp.getgrgid(res.st_gid)\n+            self.assertEqual(res.st_mode, nm_expected_mode, f'file {file}')\n+            self.assertEqual(user.pw_name, nm_expected_owner, f'file {file}')\n+            self.assertEqual(group.gr_name, nm_expected_group, f'file {file}')\n+\n+        # Check wpa_supplicant configuration files\n+        base_path = '/run/netplan'\n+        files = glob.glob(f'{base_path}/wpa-*.conf')\n+        for file in files:\n+            res = os.stat(file)\n+            user = pwd.getpwuid(res.st_uid)\n+            group = grp.getgrgid(res.st_gid)\n+            self.assertEqual(res.st_mode, wpa_expected_mode, f'file {file}')\n+            self.assertEqual(user.pw_name, wpa_expected_owner, f'file {file}')\n+            self.assertEqual(group.gr_name, wpa_expected_group, f'file {file}')\n+\n+        # Check systemd service unit files\n+        base_path = '/run/systemd/system/'\n+        files = glob.glob(f'{base_path}/netplan-*.service')\n+        files += glob.glob(f'{base_path}/systemd-networkd-wait-online.service.d/*.conf')\n+        for file in files:\n+            res = os.stat(file)\n+            user = pwd.getpwuid(res.st_uid)\n+            group = grp.getgrgid(res.st_gid)\n+            self.assertEqual(res.st_mode, sd_expected_mode, f'file {file}')\n+            self.assertEqual(user.pw_name, sd_expected_owner, f'file {file}')\n+            self.assertEqual(group.gr_name, sd_expected_group, f'file {file}')\n+\n+        # Check systemd-udevd files\n+        udev_path = '/run/udev/rules.d'\n+        link_path = '/run/systemd/network'\n+        files = glob.glob(f'{udev_path}/*-netplan*.rules') + glob.glob(f'{link_path}/*.link')\n+        for file in files:\n+            res = os.stat(file)\n+            user = pwd.getpwuid(res.st_uid)\n+            group = grp.getgrgid(res.st_gid)\n+            self.assertEqual(res.st_mode, udev_expected_mode, f'file {file}')\n+            self.assertEqual(user.pw_name, udev_expected_owner, f'file {file}')\n+            self.assertEqual(group.gr_name, udev_expected_group, f'file {file}')\n+\n     def state(self, iface, state):\n         '''Tell generate_and_settle() to wait for a specific state'''\n         return iface + '/' + state"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0965bc92bb099e62073874578460cf722e1181df",
            "date": "2024-12-16T15:57:33Z",
            "author_login": "slyon"
          },
          {
            "sha": "a03d6149975f392aa6e9e957ab7444d9ac88780c",
            "date": "2024-12-13T10:51:22Z",
            "author_login": "seankingyang"
          },
          {
            "sha": "e76557002968c04231d95f751ab4895c2ee01af8",
            "date": "2024-12-16T15:33:35Z",
            "author_login": "daniloegea"
          },
          {
            "sha": "a28be211a45c36aba6dafb519c213036788f87bd",
            "date": "2024-12-10T18:51:06Z",
            "author_login": "MggMuggins"
          },
          {
            "sha": "f0d64c41be096358ed87061d5cdb06751825a2b8",
            "date": "2024-11-14T10:54:39Z",
            "author_login": "slyon"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-497",
    "description": "netplan leaks the private key of wireguard to local users. Versions after 1.0 are not affected.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-07T01:15:49.463",
    "last_modified": "2024-11-21T07:36:21.080",
    "fix_date": "2024-05-22T14:44:16Z"
  },
  "references": [
    {
      "url": "https://bugs.launchpad.net/netplan/+bug/1987842",
      "source": "security@ubuntu.com",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugs.launchpad.net/ubuntu/+source/netplan.io/+bug/2065738",
      "source": "security@ubuntu.com",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/canonical/netplan/commit/4c39b75b5c6ae7d976bda6da68da60d9a7f085ee",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://www.cve.org/CVERecord?id=CVE-2022-4968",
      "source": "security@ubuntu.com",
      "tags": [
        "US Government Resource"
      ]
    },
    {
      "url": "https://bugs.launchpad.net/netplan/+bug/1987842",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://bugs.launchpad.net/ubuntu/+source/netplan.io/+bug/2065738",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/canonical/netplan/commit/4c39b75b5c6ae7d976bda6da68da60d9a7f085ee",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://www.cve.org/CVERecord?id=CVE-2022-4968",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "US Government Resource"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:26.352917",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "netplan",
    "owner": "canonical",
    "created_at": "2018-01-24T22:22:14Z",
    "updated_at": "2025-01-26T06:39:17Z",
    "pushed_at": "2025-01-21T18:33:11Z",
    "size": 4480,
    "stars": 750,
    "forks": 206,
    "open_issues": 17,
    "watchers": 750,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 1504737,
      "C": 725269,
      "JavaScript": 87718,
      "Shell": 13360,
      "Meson": 11627,
      "Makefile": 1437
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-26T08:18:51.165986"
  }
}