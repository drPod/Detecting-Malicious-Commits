{
  "cve_id": "CVE-2023-0240",
  "github_data": {
    "repository": "gregkh/linux",
    "fix_commit": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
    "related_commits": [
      "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
      "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
      "commit_date": "2020-10-15T14:46:24Z",
      "author": {
        "login": "axboe",
        "type": "User",
        "stats": {
          "total_commits": 1150,
          "average_weekly_commits": 0.9655751469353484,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 283
        }
      },
      "commit_message": {
        "title": "io_uring: COW io_identity on mismatch",
        "length": 348,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 223,
        "additions": 171,
        "deletions": 52
      },
      "files": [
        {
          "filename": "fs/io_uring.c",
          "status": "modified",
          "additions": 170,
          "deletions": 52,
          "patch": "@@ -1040,6 +1040,27 @@ static inline void req_set_fail_links(struct io_kiocb *req)\n \t\treq->flags |= REQ_F_FAIL_LINK;\n }\n \n+/*\n+ * None of these are dereferenced, they are simply used to check if any of\n+ * them have changed. If we're under current and check they are still the\n+ * same, we're fine to grab references to them for actual out-of-line use.\n+ */\n+static void io_init_identity(struct io_identity *id)\n+{\n+\tid->files = current->files;\n+\tid->mm = current->mm;\n+#ifdef CONFIG_BLK_CGROUP\n+\trcu_read_lock();\n+\tid->blkcg_css = blkcg_css();\n+\trcu_read_unlock();\n+#endif\n+\tid->creds = current_cred();\n+\tid->nsproxy = current->nsproxy;\n+\tid->fs = current->fs;\n+\tid->fsize = rlimit(RLIMIT_FSIZE);\n+\trefcount_set(&id->count, 1);\n+}\n+\n /*\n  * Note: must call io_req_init_async() for the first time you\n  * touch any members of io_wq_work.\n@@ -1051,6 +1072,7 @@ static inline void io_req_init_async(struct io_kiocb *req)\n \n \tmemset(&req->work, 0, sizeof(req->work));\n \treq->flags |= REQ_F_WORK_INITIALIZED;\n+\tio_init_identity(&req->identity);\n \treq->work.identity = &req->identity;\n }\n \n@@ -1157,6 +1179,14 @@ static void __io_commit_cqring(struct io_ring_ctx *ctx)\n \t}\n }\n \n+static void io_put_identity(struct io_kiocb *req)\n+{\n+\tif (req->work.identity == &req->identity)\n+\t\treturn;\n+\tif (refcount_dec_and_test(&req->work.identity->count))\n+\t\tkfree(req->work.identity);\n+}\n+\n static void io_req_clean_work(struct io_kiocb *req)\n {\n \tif (!(req->flags & REQ_F_WORK_INITIALIZED))\n@@ -1189,75 +1219,147 @@ static void io_req_clean_work(struct io_kiocb *req)\n \t\t\tfree_fs_struct(fs);\n \t\treq->work.flags &= ~IO_WQ_WORK_FS;\n \t}\n+\n+\tio_put_identity(req);\n }\n \n-static void io_prep_async_work(struct io_kiocb *req)\n+/*\n+ * Create a private copy of io_identity, since some fields don't match\n+ * the current context.\n+ */\n+static bool io_identity_cow(struct io_kiocb *req)\n+{\n+\tconst struct cred *creds = NULL;\n+\tstruct io_identity *id;\n+\n+\tif (req->work.flags & IO_WQ_WORK_CREDS)\n+\t\tcreds = req->work.identity->creds;\n+\n+\tid = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);\n+\tif (unlikely(!id)) {\n+\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * We can safely just re-init the creds we copied  Either the field\n+\t * matches the current one, or we haven't grabbed it yet. The only\n+\t * exception is ->creds, through registered personalities, so handle\n+\t * that one separately.\n+\t */\n+\tio_init_identity(id);\n+\tif (creds)\n+\t\treq->work.identity->creds = creds;\n+\n+\t/* add one for this request */\n+\trefcount_inc(&id->count);\n+\n+\t/* drop old identity, assign new one. one ref for req, one for tctx */\n+\tif (req->work.identity != &req->identity &&\n+\t    refcount_sub_and_test(2, &req->work.identity->count))\n+\t\tkfree(req->work.identity);\n+\n+\treq->work.identity = id;\n+\treturn true;\n+}\n+\n+static bool io_grab_identity(struct io_kiocb *req)\n {\n \tconst struct io_op_def *def = &io_op_defs[req->opcode];\n+\tstruct io_identity *id = &req->identity;\n \tstruct io_ring_ctx *ctx = req->ctx;\n \n-\tio_req_init_async(req);\n+\tif (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))\n+\t\treturn false;\n \n-\tif (req->flags & REQ_F_ISREG) {\n-\t\tif (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))\n-\t\t\tio_wq_hash_work(&req->work, file_inode(req->file));\n-\t} else {\n-\t\tif (def->unbound_nonreg_file)\n-\t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;\n-\t}\n \tif (!(req->work.flags & IO_WQ_WORK_FILES) &&\n-\t    (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&\n+\t    (def->work_flags & IO_WQ_WORK_FILES) &&\n \t    !(req->flags & REQ_F_NO_FILE_TABLE)) {\n-\t\treq->work.identity->files = get_files_struct(current);\n-\t\tget_nsproxy(current->nsproxy);\n-\t\treq->work.identity->nsproxy = current->nsproxy;\n+\t\tif (id->files != current->files ||\n+\t\t    id->nsproxy != current->nsproxy)\n+\t\t\treturn false;\n+\t\tatomic_inc(&id->files->count);\n+\t\tget_nsproxy(id->nsproxy);\n \t\treq->flags |= REQ_F_INFLIGHT;\n \n \t\tspin_lock_irq(&ctx->inflight_lock);\n \t\tlist_add(&req->inflight_entry, &ctx->inflight_list);\n \t\tspin_unlock_irq(&ctx->inflight_lock);\n \t\treq->work.flags |= IO_WQ_WORK_FILES;\n \t}\n-\tif (!(req->work.flags & IO_WQ_WORK_MM) &&\n-\t    (def->work_flags & IO_WQ_WORK_MM)) {\n-\t\tmmgrab(current->mm);\n-\t\treq->work.identity->mm = current->mm;\n-\t\treq->work.flags |= IO_WQ_WORK_MM;\n-\t}\n #ifdef CONFIG_BLK_CGROUP\n \tif (!(req->work.flags & IO_WQ_WORK_BLKCG) &&\n \t    (def->work_flags & IO_WQ_WORK_BLKCG)) {\n \t\trcu_read_lock();\n-\t\treq->work.identity->blkcg_css = blkcg_css();\n+\t\tif (id->blkcg_css != blkcg_css()) {\n+\t\t\trcu_read_unlock();\n+\t\t\treturn false;\n+\t\t}\n \t\t/*\n \t\t * This should be rare, either the cgroup is dying or the task\n \t\t * is moving cgroups. Just punt to root for the handful of ios.\n \t\t */\n-\t\tif (css_tryget_online(req->work.identity->blkcg_css))\n+\t\tif (css_tryget_online(id->blkcg_css))\n \t\t\treq->work.flags |= IO_WQ_WORK_BLKCG;\n \t\trcu_read_unlock();\n \t}\n #endif\n \tif (!(req->work.flags & IO_WQ_WORK_CREDS)) {\n-\t\treq->work.identity->creds = get_current_cred();\n+\t\tif (id->creds != current_cred())\n+\t\t\treturn false;\n+\t\tget_cred(id->creds);\n \t\treq->work.flags |= IO_WQ_WORK_CREDS;\n \t}\n \tif (!(req->work.flags & IO_WQ_WORK_FS) &&\n \t    (def->work_flags & IO_WQ_WORK_FS)) {\n-\t\tspin_lock(&current->fs->lock);\n-\t\tif (!current->fs->in_exec) {\n-\t\t\treq->work.identity->fs = current->fs;\n-\t\t\treq->work.identity->fs->users++;\n+\t\tif (current->fs != id->fs)\n+\t\t\treturn false;\n+\t\tspin_lock(&id->fs->lock);\n+\t\tif (!id->fs->in_exec) {\n+\t\t\tid->fs->users++;\n \t\t\treq->work.flags |= IO_WQ_WORK_FS;\n \t\t} else {\n \t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n \t\t}\n \t\tspin_unlock(&current->fs->lock);\n \t}\n-\tif (def->needs_fsize)\n-\t\treq->work.identity->fsize = rlimit(RLIMIT_FSIZE);\n-\telse\n-\t\treq->work.identity->fsize = RLIM_INFINITY;\n+\n+\treturn true;\n+}\n+\n+static void io_prep_async_work(struct io_kiocb *req)\n+{\n+\tconst struct io_op_def *def = &io_op_defs[req->opcode];\n+\tstruct io_identity *id = &req->identity;\n+\tstruct io_ring_ctx *ctx = req->ctx;\n+\n+\tio_req_init_async(req);\n+\n+\tif (req->flags & REQ_F_ISREG) {\n+\t\tif (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))\n+\t\t\tio_wq_hash_work(&req->work, file_inode(req->file));\n+\t} else {\n+\t\tif (def->unbound_nonreg_file)\n+\t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;\n+\t}\n+\n+\t/* ->mm can never change on us */\n+\tif (!(req->work.flags & IO_WQ_WORK_MM) &&\n+\t    (def->work_flags & IO_WQ_WORK_MM)) {\n+\t\tmmgrab(id->mm);\n+\t\treq->work.flags |= IO_WQ_WORK_MM;\n+\t}\n+\n+\t/* if we fail grabbing identity, we must COW, regrab, and retry */\n+\tif (io_grab_identity(req))\n+\t\treturn;\n+\n+\tif (!io_identity_cow(req))\n+\t\treturn;\n+\n+\t/* can't fail at this point */\n+\tif (!io_grab_identity(req))\n+\t\tWARN_ON(1);\n }\n \n static void io_prep_async_link(struct io_kiocb *req)\n@@ -1696,12 +1798,10 @@ static void io_dismantle_req(struct io_kiocb *req)\n \n static void __io_free_req(struct io_kiocb *req)\n {\n-\tstruct io_uring_task *tctx;\n-\tstruct io_ring_ctx *ctx;\n+\tstruct io_uring_task *tctx = req->task->io_uring;\n+\tstruct io_ring_ctx *ctx = req->ctx;\n \n \tio_dismantle_req(req);\n-\ttctx = req->task->io_uring;\n-\tctx = req->ctx;\n \n \tatomic_long_inc(&tctx->req_complete);\n \tif (tctx->in_idle)\n@@ -6374,11 +6474,16 @@ static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,\n \n \tid = READ_ONCE(sqe->personality);\n \tif (id) {\n+\t\tstruct io_identity *iod;\n+\n \t\tio_req_init_async(req);\n-\t\treq->work.identity->creds = idr_find(&ctx->personality_idr, id);\n-\t\tif (unlikely(!req->work.identity->creds))\n+\t\tiod = idr_find(&ctx->personality_idr, id);\n+\t\tif (unlikely(!iod))\n \t\t\treturn -EINVAL;\n-\t\tget_cred(req->work.identity->creds);\n+\t\trefcount_inc(&iod->count);\n+\t\tio_put_identity(req);\n+\t\tget_cred(iod->creds);\n+\t\treq->work.identity = iod;\n \t\treq->work.flags |= IO_WQ_WORK_CREDS;\n \t}\n \n@@ -8171,11 +8276,14 @@ static int io_uring_fasync(int fd, struct file *file, int on)\n static int io_remove_personalities(int id, void *p, void *data)\n {\n \tstruct io_ring_ctx *ctx = data;\n-\tconst struct cred *cred;\n+\tstruct io_identity *iod;\n \n-\tcred = idr_remove(&ctx->personality_idr, id);\n-\tif (cred)\n-\t\tput_cred(cred);\n+\tiod = idr_remove(&ctx->personality_idr, id);\n+\tif (iod) {\n+\t\tput_cred(iod->creds);\n+\t\tif (refcount_dec_and_test(&iod->count))\n+\t\t\tkfree(iod);\n+\t}\n \treturn 0;\n }\n \n@@ -9245,23 +9353,33 @@ static int io_probe(struct io_ring_ctx *ctx, void __user *arg, unsigned nr_args)\n \n static int io_register_personality(struct io_ring_ctx *ctx)\n {\n-\tconst struct cred *creds = get_current_cred();\n-\tint id;\n+\tstruct io_identity *id;\n+\tint ret;\n \n-\tid = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,\n-\t\t\t\tUSHRT_MAX, GFP_KERNEL);\n-\tif (id < 0)\n-\t\tput_cred(creds);\n-\treturn id;\n+\tid = kmalloc(sizeof(*id), GFP_KERNEL);\n+\tif (unlikely(!id))\n+\t\treturn -ENOMEM;\n+\n+\tio_init_identity(id);\n+\tid->creds = get_current_cred();\n+\n+\tret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);\n+\tif (ret < 0) {\n+\t\tput_cred(id->creds);\n+\t\tkfree(id);\n+\t}\n+\treturn ret;\n }\n \n static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)\n {\n-\tconst struct cred *old_creds;\n+\tstruct io_identity *iod;\n \n-\told_creds = idr_remove(&ctx->personality_idr, id);\n-\tif (old_creds) {\n-\t\tput_cred(old_creds);\n+\tiod = idr_remove(&ctx->personality_idr, id);\n+\tif (iod) {\n+\t\tput_cred(iod->creds);\n+\t\tif (refcount_dec_and_test(&iod->count))\n+\t\t\tkfree(iod);\n \t\treturn 0;\n \t}\n "
        },
        {
          "filename": "include/linux/io_uring.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -15,6 +15,7 @@ struct io_identity {\n \tstruct nsproxy\t\t\t*nsproxy;\n \tstruct fs_struct\t\t*fs;\n \tunsigned long\t\t\tfsize;\n+\trefcount_t\t\t\tcount;\n };\n \n struct io_uring_task {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "95ec54a420b8f445e04a7ca0ea8deb72c51fe1d3",
            "date": "2025-01-21T05:40:19Z",
            "author_login": "torvalds"
          },
          {
            "sha": "9ad09c4f2868540130ad2d5dfe265f55c75c1705",
            "date": "2025-01-21T05:21:49Z",
            "author_login": "torvalds"
          },
          {
            "sha": "e7244cc382524ac5354dbf7b7cb351e926e8118f",
            "date": "2025-01-21T05:18:36Z",
            "author_login": "torvalds"
          },
          {
            "sha": "4f42d0bf72253dd01e9a8d168e28706803c98a9d",
            "date": "2025-01-21T05:14:49Z",
            "author_login": "torvalds"
          },
          {
            "sha": "a312e1706ce6c124f04ec85ddece240f3bb2a696",
            "date": "2025-01-21T04:27:33Z",
            "author_login": "torvalds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-416",
    "description": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-30T14:15:10.403",
    "last_modified": "2024-11-21T07:36:48.030",
    "fix_date": "2020-10-15T14:46:24Z"
  },
  "references": [
    {
      "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/io_uring?h=linux-5.10.y&id=788d0824269bef539fe31a785b1517882eafed93",
      "source": "cve-coordination@google.com",
      "tags": [
        "Mailing List",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
      "source": "cve-coordination@google.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://kernel.dance/#788d0824269bef539fe31a785b1517882eafed93",
      "source": "cve-coordination@google.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/io_uring?h=linux-5.10.y&id=788d0824269bef539fe31a785b1517882eafed93",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://kernel.dance/#788d0824269bef539fe31a785b1517882eafed93",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230316-0001/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:03.953976",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "linux",
    "owner": "gregkh",
    "created_at": "2019-05-22T13:50:43Z",
    "updated_at": "2025-01-14T11:05:15Z",
    "pushed_at": "2025-01-10T13:50:12Z",
    "size": 3878127,
    "stars": 478,
    "forks": 534,
    "open_issues": 4,
    "watchers": 478,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1326915550,
      "Assembly": 9568228,
      "Shell": 5071477,
      "Python": 2974128,
      "Makefile": 2713631,
      "Perl": 1253637,
      "Rust": 807711,
      "Roff": 202277,
      "C++": 173382,
      "SmPL": 165946,
      "Yacc": 127472,
      "Lex": 71321,
      "Awk": 69539,
      "Jinja": 30138,
      "UnrealScript": 16848,
      "Gherkin": 10172,
      "M4": 3329,
      "MATLAB": 2482,
      "sed": 2433,
      "Clojure": 2411,
      "XS": 1239,
      "RPC": 962
    },
    "commit_activity": {
      "total_commits_last_year": 16328,
      "avg_commits_per_week": 314.0,
      "days_active_last_year": 354
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T20:12:39.728484"
  }
}