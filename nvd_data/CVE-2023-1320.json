{
  "cve_id": "CVE-2023-1320",
  "github_data": {
    "repository": "osticket/osticket",
    "fix_commit": "86f9693dc64ed54220ed6c10e13e824ca4f6aacf",
    "related_commits": [
      "86f9693dc64ed54220ed6c10e13e824ca4f6aacf",
      "86f9693dc64ed54220ed6c10e13e824ca4f6aacf"
    ],
    "patch_url": "https://github.com/osticket/osticket/commit/86f9693dc64ed54220ed6c10e13e824ca4f6aacf.patch",
    "fix_commit_details": {
      "sha": "86f9693dc64ed54220ed6c10e13e824ca4f6aacf",
      "commit_date": "2023-03-08T16:31:12Z",
      "author": {
        "login": "JediKev",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "xss: Draft Files",
        "length": 89,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 150,
        "additions": 84,
        "deletions": 66
      },
      "files": [
        {
          "filename": "bootstrap.php",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -54,6 +54,15 @@ function exif_imagetype ($filename) {\n             }\n         }\n \n+        if (!function_exists('exif_imagetype')) {\n+            function exif_imagetype ($filename) {\n+                if ((list($width,$height,$type,) = getimagesize($filename)) !== false)\n+                    return $type;\n+\n+                return false;\n+            }\n+        }\n+\n         if (!isset($_SERVER['REMOTE_ADDR']))\n             $_SERVER['REMOTE_ADDR'] = '';\n     }"
        },
        {
          "filename": "include/ajax.draft.php",
          "status": "modified",
          "additions": 54,
          "deletions": 60,
          "patch": "@@ -53,78 +53,72 @@ static function _updateDraft($draft) {\n     static function _uploadInlineImage($draft) {\n         global $cfg;\n \n-        if (!isset($_POST['data']) && !isset($_FILES['file']))\n+        if (!isset($_FILES['file']))\n             Http::response(422, \"File not included properly\");\n \n         # Fixup for expected multiple attachments\n-        if (isset($_FILES['file'])) {\n-            $file = AttachmentFile::format($_FILES['file']);\n-\n-            # Allow for data-uri uploaded files\n-            $fp = fopen($file[0]['tmp_name'], 'rb');\n-            if (fread($fp, 5) == 'data:') {\n-                $data = 'data:';\n-                while ($block = fread($fp, 8192))\n-                  $data .= $block;\n-                $file[0] = Format::parseRfc2397($data);\n-                list(,$ext) = explode('/', $file[0]['type'], 2);\n-                $file[0] += array(\n-                    'name' => Misc::randCode(8).'.'.$ext,\n-                    'size' => strlen($file[0]['data']),\n-                );\n-            }\n-            fclose($fp);\n+        $file = AttachmentFile::format($_FILES['file']);\n+\n+        # Allow for data-uri uploaded files\n+        $fp = fopen($file[0]['tmp_name'], 'rb');\n+        if (fread($fp, 5) == 'data:') {\n+            $data = 'data:';\n+            while ($block = fread($fp, 8192))\n+              $data .= $block;\n+            $file[0] = Format::parseRfc2397($data);\n+            list(,$ext) = explode('/', $file[0]['type'], 2);\n+            $file[0] += array(\n+                'name' => Misc::randCode(8).'.'.$ext,\n+                'size' => strlen($file[0]['data']),\n+            );\n+        }\n+        fclose($fp);\n+\n+        // Check file type to ensure image\n+        $type = $file[0]['type'];\n+        if (strpos($file[0]['type'], 'image/') !== 0)\n+            return Http::response(403,\n+                JsonDataEncoder::encode(array(\n+                    'error' => 'File type is not allowed',\n+                ))\n+            );\n \n-            # TODO: Detect unacceptable attachment extension\n-            # TODO: Verify content-type and check file-content to ensure image\n-            $type = $file[0]['type'];\n-            if (strpos($file[0]['type'], 'image/') !== 0)\n-                return Http::response(403,\n-                    JsonDataEncoder::encode(array(\n-                        'error' => 'File type is not allowed',\n-                    ))\n-                );\n+        // Check if file is truly an image\n+        if (!FileUploadField::isValidFile($file[0]))\n+            return Http::response(403,\n+                JsonDataEncoder::encode(array(\n+                    'error' => 'File is not valid',\n+                ))\n+            );\n \n-            # TODO: Verify file size is acceptable\n-            if ($file[0]['size'] > $cfg->getMaxFileSize())\n+        // Verify file size is acceptable\n+        if ($file[0]['size'] > $cfg->getMaxFileSize())\n+            return Http::response(403,\n+                JsonDataEncoder::encode(array(\n+                    'error' => 'File is too large',\n+                ))\n+            );\n+\n+        // Paste uploads in Chrome will have a name of 'blob'\n+        if ($file[0]['name'] == 'blob')\n+            $file[0]['name'] = 'screenshot-'.Misc::randCode(4);\n+\n+        $ids = $draft->attachments->upload($file);\n+\n+        if (!$ids) {\n+            if ($file[0]['error']) {\n                 return Http::response(403,\n                     JsonDataEncoder::encode(array(\n-                        'error' => 'File is too large',\n+                        'error' => $file[0]['error'],\n                     ))\n                 );\n \n-            // Paste uploads in Chrome will have a name of 'blob'\n-            if ($file[0]['name'] == 'blob')\n-                $file[0]['name'] = 'screenshot-'.Misc::randCode(4);\n-\n-            $ids = $draft->attachments->upload($file);\n-\n-            if (!$ids) {\n-                if ($file[0]['error']) {\n-                    return Http::response(403,\n-                        JsonDataEncoder::encode(array(\n-                            'error' => $file[0]['error'],\n-                        ))\n-                    );\n-                }\n-                else\n-                    return Http::response(500, 'Unable to attach image');\n             }\n-\n-            $id = (is_array($ids)) ? $ids[0] : $ids;\n-        }\n-        else {\n-            $type = explode('/', $_POST['contentType']);\n-            $info = array(\n-                'data' => base64_decode($_POST['data']),\n-                'name' => Misc::randCode(10).'.'.$type[1],\n-                // TODO: Ensure _POST['contentType']\n-                'type' => $_POST['contentType'],\n-            );\n-            // TODO: Detect unacceptable filetype\n-            // TODO: Verify content-type and check file-content to ensure image\n-            $id = $draft->attachments->save($info);\n+            else\n+                return Http::response(500, 'Unable to attach image');\n         }\n+\n+        $id = (is_array($ids)) ? $ids[0] : $ids;\n         if (!($f = AttachmentFile::lookup($id)))\n             return Http::response(500, 'Unable to attach image');\n "
        },
        {
          "filename": "include/class.file.php",
          "status": "modified",
          "additions": 17,
          "deletions": 6,
          "patch": "@@ -1054,12 +1054,8 @@ function setMimeType($type) {\n     }\n \n     function getMimeType() {\n-        if (!isset($this->_mimetype)) {\n-            // Try to to auto-detect mime type\n-            $finfo = new finfo(FILEINFO_MIME);\n-            $this->_mimetype = $finfo->buffer($this->getContents(),\n-                    FILEINFO_MIME_TYPE);\n-        }\n+        if (!isset($this->_mimetype))\n+            $this->_mimetype = self::mime_type($this->getRealPath());\n \n         return $this->_mimetype;\n     }\n@@ -1075,6 +1071,21 @@ function getContents() {\n     function getData() {\n         return $this->getContents();\n     }\n+\n+    /*\n+     * Given a filepath - auto detect the mime type\n+     *\n+     */\n+    static function mime_type($filepath) {\n+        // Try to to auto-detect mime type\n+        $type = null;\n+        if (function_exists('finfo_open')) {\n+            $finfo = finfo_open(FILEINFO_MIME_TYPE);\n+            $type = finfo_file($finfo, $filepath);\n+            finfo_close($finfo);\n+        }\n+        return $type ?: mime_content_type($filepath);\n+    }\n }\n \n ?>"
        },
        {
          "filename": "include/class.forms.php",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -3911,6 +3911,10 @@ function uploadAttachment(&$file) {\n     }\n \n     static function isValidFile($file) {\n+        // Make sure mime type is valid\n+        if (strcasecmp(FileObject::mime_type($file['tmp_name']),\n+                    $file['type']) !== 0)\n+            return false;\n \n         // Check invalid image hacks\n         if ($file['tmp_name']"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4689926b2d3d25754f0ddcf8d4e181a2817f6d56",
            "date": "2023-10-25T15:45:33Z",
            "author_login": "JediKev"
          },
          {
            "sha": "03755768d9f239d70a1af7ddc7eb35c49bf6239d",
            "date": "2023-10-25T15:34:06Z",
            "author_login": "JediKev"
          },
          {
            "sha": "0f08e5b0b7474522d76416e7b57709c3ff619fef",
            "date": "2023-10-25T15:26:17Z",
            "author_login": "JediKev"
          },
          {
            "sha": "7c2003629dd7c11db33cd7d7f790704d87cfd412",
            "date": "2023-10-25T15:19:29Z",
            "author_login": "JediKev"
          },
          {
            "sha": "f878766863fc6e5bc8b8c53ae48afef31496b53a",
            "date": "2023-10-25T15:06:35Z",
            "author_login": "JediKev"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-79",
    "description": "Cross-site Scripting (XSS) - Stored in GitHub repository osticket/osticket prior to v1.16.6.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-10T16:15:11.010",
    "last_modified": "2024-11-21T07:38:55.037",
    "fix_date": "2023-03-08T16:31:12Z"
  },
  "references": [
    {
      "url": "https://github.com/osticket/osticket/commit/86f9693dc64ed54220ed6c10e13e824ca4f6aacf",
      "source": "security@huntr.dev",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/c2bb34ac-452d-4624-a1b9-c5b54f52f0cd",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/osticket/osticket/commit/86f9693dc64ed54220ed6c10e13e824ca4f6aacf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/c2bb34ac-452d-4624-a1b9-c5b54f52f0cd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.830918",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "osTicket",
    "owner": "osticket",
    "created_at": "2013-08-12T19:10:14Z",
    "updated_at": "2025-01-09T09:49:59Z",
    "pushed_at": "2024-11-14T16:43:24Z",
    "size": 76341,
    "stars": 3300,
    "forks": 1675,
    "open_issues": 1158,
    "watchers": 3300,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "PHP": 6160811,
      "JavaScript": 360520,
      "CSS": 239335,
      "Less": 15079,
      "Shell": 4233,
      "Perl": 2087,
      "HTML": 882,
      "Standard ML": 33
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T15:58:15.645478"
  }
}