{
  "cve_id": "CVE-2023-22474",
  "github_data": {
    "repository": "parse-community/parse-server",
    "fix_commit": "e016d813e083ce6828f9abce245d15b681a224d8",
    "related_commits": [
      "e016d813e083ce6828f9abce245d15b681a224d8",
      "e016d813e083ce6828f9abce245d15b681a224d8"
    ],
    "patch_url": "https://github.com/parse-community/parse-server/commit/e016d813e083ce6828f9abce245d15b681a224d8.patch",
    "fix_commit_details": {
      "sha": "e016d813e083ce6828f9abce245d15b681a224d8",
      "commit_date": "2023-01-05T13:20:40Z",
      "author": {
        "login": "mtrezza",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: The client IP address may be determined incorrectly in some cases; it is now required to set the Parse Server option `trustProxy` accordingly if Parse Server runs behind a proxy server, see the express framework's [trust proxy](https://expressjs.com/en/guide/behind-proxies.html) setting; this fixes a security vulnerability in which the Parse Server option `masterKeyIps` may be circumvented, see [GHSA-vm5r-c87r-pf6x](https://github.com/parse-community/parse-server/security/advisories/GHSA-vm5r-c87r-pf6x) (#8369)",
        "length": 521,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 152,
        "additions": 18,
        "deletions": 134
      },
      "files": [
        {
          "filename": "spec/Middlewares.spec.js",
          "status": "modified",
          "additions": 3,
          "deletions": 118,
          "patch": "@@ -158,78 +158,6 @@ describe('middlewares', () => {\n     });\n   });\n \n-  it('should not succeed if the connection.remoteAddress does not belong to masterKeyIps list', () => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1', 'ip2'],\n-    });\n-    fakeReq.connection = { remoteAddress: 'ip3' };\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes);\n-    expect(fakeRes.status).toHaveBeenCalledWith(403);\n-  });\n-\n-  it('should succeed if the connection.remoteAddress does belong to masterKeyIps list', done => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1', 'ip2'],\n-    });\n-    fakeReq.connection = { remoteAddress: 'ip1' };\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n-      expect(fakeRes.status).not.toHaveBeenCalled();\n-      done();\n-    });\n-  });\n-\n-  it('should not succeed if the socket.remoteAddress does not belong to masterKeyIps list', () => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1', 'ip2'],\n-    });\n-    fakeReq.socket = { remoteAddress: 'ip3' };\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes);\n-    expect(fakeRes.status).toHaveBeenCalledWith(403);\n-  });\n-\n-  it('should succeed if the socket.remoteAddress does belong to masterKeyIps list', done => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1', 'ip2'],\n-    });\n-    fakeReq.socket = { remoteAddress: 'ip1' };\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n-      expect(fakeRes.status).not.toHaveBeenCalled();\n-      done();\n-    });\n-  });\n-\n-  it('should not succeed if the connection.socket.remoteAddress does not belong to masterKeyIps list', () => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1', 'ip2'],\n-    });\n-    fakeReq.connection = { socket: { remoteAddress: 'ip3' } };\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes);\n-    expect(fakeRes.status).toHaveBeenCalledWith(403);\n-  });\n-\n-  it('should succeed if the connection.socket.remoteAddress does belong to masterKeyIps list', done => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1', 'ip2'],\n-    });\n-    fakeReq.connection = { socket: { remoteAddress: 'ip1' } };\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n-      expect(fakeRes.status).not.toHaveBeenCalled();\n-      done();\n-    });\n-  });\n-\n   it('should allow any ip to use masterKey if masterKeyIps is empty', done => {\n     AppCache.put(fakeReq.body._ApplicationId, {\n       masterKey: 'masterKey',\n@@ -243,52 +171,9 @@ describe('middlewares', () => {\n     });\n   });\n \n-  it('should succeed if xff header does belong to masterKeyIps', done => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1'],\n-    });\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    fakeReq.headers['x-forwarded-for'] = 'ip1, ip2, ip3';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n-      expect(fakeRes.status).not.toHaveBeenCalled();\n-      done();\n-    });\n-  });\n-\n-  it('should succeed if xff header with one ip does belong to masterKeyIps', done => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1'],\n-    });\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    fakeReq.headers['x-forwarded-for'] = 'ip1';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n-      expect(fakeRes.status).not.toHaveBeenCalled();\n-      done();\n-    });\n-  });\n-\n-  it('should not succeed if xff header does not belong to masterKeyIps', () => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip4'],\n-    });\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    fakeReq.headers['x-forwarded-for'] = 'ip1, ip2, ip3';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes);\n-    expect(fakeRes.status).toHaveBeenCalledWith(403);\n-  });\n-\n-  it('should not succeed if xff header is empty and masterKeyIps is set', () => {\n-    AppCache.put(fakeReq.body._ApplicationId, {\n-      masterKey: 'masterKey',\n-      masterKeyIps: ['ip1'],\n-    });\n-    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n-    fakeReq.headers['x-forwarded-for'] = '';\n-    middlewares.handleParseHeaders(fakeReq, fakeRes);\n-    expect(fakeRes.status).toHaveBeenCalledWith(403);\n+  it('can set trust proxy', async () => {\n+    const server = await reconfigureServer({ trustProxy: 1 });\n+    expect(server.app.parent.settings['trust proxy']).toBe(1);\n   });\n \n   it('should properly expose the headers', () => {"
        },
        {
          "filename": "src/Options/Definitions.js",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -477,6 +477,13 @@ module.exports.ParseServerOptions = {\n     help: 'Starts the liveQuery server',\n     action: parsers.booleanParser,\n   },\n+  trustProxy: {\n+    env: 'PARSE_SERVER_TRUST_PROXY',\n+    help:\n+      'The trust proxy settings. It is important to understand the exact setup of the reverse proxy, since this setting will trust values provided in the Parse Server API request. See the <a href=\"https://expressjs.com/en/guide/behind-proxies.html\">express trust proxy settings</a> documentation. Defaults to `false`.',\n+    action: parsers.objectParser,\n+    default: [],\n+  },\n   userSensitiveFields: {\n     env: 'PARSE_SERVER_USER_SENSITIVE_FIELDS',\n     help:"
        },
        {
          "filename": "src/Options/docs.js",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -88,6 +88,7 @@\n  * @property {Number} sessionLength Session duration, in seconds, defaults to 1 year\n  * @property {Boolean} silent Disables console output\n  * @property {Boolean} startLiveQueryServer Starts the liveQuery server\n+ * @property {Any} trustProxy The trust proxy settings. It is important to understand the exact setup of the reverse proxy, since this setting will trust values provided in the Parse Server API request. See the <a href=\"https://expressjs.com/en/guide/behind-proxies.html\">express trust proxy settings</a> documentation. Defaults to `false`.\n  * @property {String[]} userSensitiveFields Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields\n  * @property {Boolean} verbose Set the logging to verbose\n  * @property {Boolean} verifyUserEmails Set to `true` to require users to verify their email address to complete the sign-up process.<br><br>Default is `false`."
        },
        {
          "filename": "src/Options/index.js",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -238,6 +238,9 @@ export interface ParseServerOptions {\n   cluster: ?NumberOrBoolean;\n   /* middleware for express server, can be string or function */\n   middleware: ?((() => void) | string);\n+  /* The trust proxy settings. It is important to understand the exact setup of the reverse proxy, since this setting will trust values provided in the Parse Server API request. See the <a href=\"https://expressjs.com/en/guide/behind-proxies.html\">express trust proxy settings</a> documentation. Defaults to `false`.\n+  :DEFAULT: false */\n+  trustProxy: ?any;\n   /* Starts the liveQuery server */\n   startLiveQueryServer: ?boolean;\n   /* Live query server configuration options (will start the liveQuery server) */"
        },
        {
          "filename": "src/ParseServer.js",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -304,6 +304,9 @@ class ParseServer {\n         options\n       );\n     }\n+    if (options.trustProxy) {\n+      app.set('trust proxy', options.trustProxy);\n+    }\n     /* istanbul ignore next */\n     if (!process.env.TESTING) {\n       configureListeners(this);"
        },
        {
          "filename": "src/middlewares.js",
          "status": "modified",
          "additions": 1,
          "deletions": 16,
          "patch": "@@ -280,22 +280,7 @@ export function handleParseHeaders(req, res, next) {\n }\n \n function getClientIp(req) {\n-  if (req.headers['x-forwarded-for']) {\n-    // try to get from x-forwared-for if it set (behind reverse proxy)\n-    return req.headers['x-forwarded-for'].split(',')[0];\n-  } else if (req.connection && req.connection.remoteAddress) {\n-    // no proxy, try getting from connection.remoteAddress\n-    return req.connection.remoteAddress;\n-  } else if (req.socket) {\n-    // try to get it from req.socket\n-    return req.socket.remoteAddress;\n-  } else if (req.connection && req.connection.socket) {\n-    // try to get it form the connection.socket\n-    return req.connection.socket.remoteAddress;\n-  } else {\n-    // if non above, fallback.\n-    return req.ip;\n-  }\n+  return req.ip;\n }\n \n function httpAuth(req) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "28b3edee4e76679dedee9fe115283110fd952678",
            "date": "2025-01-13T15:19:51Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1b61cab81c4206ce135f1239f17a53dabbc698d7",
            "date": "2025-01-13T14:47:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a0efad88d2177f027ee3709beba13282a6ca9d35",
            "date": "2025-01-12T20:55:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "bb1daafef0f5f0b6a9c9b33c9d7e0529fd49afbf",
            "date": "2025-01-12T18:53:43Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3f0f29b4dfaf6038cb0f0dd205cfa8e1cf92c0c4",
            "date": "2025-01-12T14:04:34Z",
            "author_login": "semantic-release-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-290",
    "description": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Parse Server uses the request header `x-forwarded-for` to determine the client IP address. If Parse Server doesn't run behind a proxy server, then a client can set this header and Parse Server will trust the value of the header. The incorrect client IP address will be used by various features in Parse Server. This allows to circumvent the security mechanism of the Parse Server option `masterKeyIps` by setting an allowed IP address as the `x-forwarded-for` header value. This issue has been patched in version 5.4.1. The mechanism to determine the client IP address has been rewritten. The correct IP address determination now requires to set the Parse Server option `trustProxy`. ",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-03T20:15:10.197",
    "last_modified": "2024-11-21T07:44:52.713",
    "fix_date": "2023-01-05T13:20:40Z"
  },
  "references": [
    {
      "url": "https://github.com/parse-community/parse-server/commit/e016d813e083ce6828f9abce245d15b681a224d8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-vm5r-c87r-pf6x",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/commit/e016d813e083ce6828f9abce245d15b681a224d8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-vm5r-c87r-pf6x",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230309-0005/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:03.980865",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "parse-server",
    "owner": "parse-community",
    "created_at": "2016-01-28T18:29:14Z",
    "updated_at": "2025-01-13T16:51:06Z",
    "pushed_at": "2025-01-14T11:16:34Z",
    "size": 73208,
    "stars": 20994,
    "forks": 4781,
    "open_issues": 474,
    "watchers": 20994,
    "has_security_policy": false,
    "default_branch": "alpha",
    "protected_branches": [
      "alpha",
      "beta",
      "release",
      "release-4.x.x",
      "release-5.x.x",
      "release-6.x.x",
      "release-7.x.x"
    ],
    "languages": {
      "JavaScript": 4248231,
      "HTML": 25876,
      "Shell": 7825,
      "Handlebars": 2113,
      "Dockerfile": 1211
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:26:59.166995"
  }
}