{
  "cve_id": "CVE-2023-22737",
  "github_data": {
    "repository": "wireapp/wire-server",
    "fix_commit": "494a6881f5895d4ed9e5d011455242be0d5e6223",
    "related_commits": [
      "494a6881f5895d4ed9e5d011455242be0d5e6223",
      "494a6881f5895d4ed9e5d011455242be0d5e6223"
    ],
    "patch_url": "https://github.com/wireapp/wire-server/commit/494a6881f5895d4ed9e5d011455242be0d5e6223.patch",
    "fix_commit_details": {
      "sha": "494a6881f5895d4ed9e5d011455242be0d5e6223",
      "commit_date": "2022-11-25T11:36:24Z",
      "author": {
        "login": "battermann",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[SQSERVICES-1801] Prevent dead bots in database (#2870)",
        "length": 55,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 107,
        "additions": 101,
        "deletions": 6
      },
      "files": [
        {
          "filename": "changelog.d/3-bug-fixes/pr-2870",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Prevention of storing unnecessary data in the database if adding a bot to a conversation fails."
        },
        {
          "filename": "services/brig/src/Brig/Provider/API.hs",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -898,6 +898,14 @@ addBot zuid zcon cid add = do\n   let sid = addBotService add\n   -- Get the conversation and check preconditions\n   cnv <- lift (liftSem $ GalleyProvider.getConv zuid cid) >>= maybeConvNotFound\n+  -- Check that the user is a conversation admin and therefore is allowed to add a bot to this conversation.\n+  -- Note that this precondition is also checked in the internal galley API,\n+  -- but by having this check here we prevent any (useless) data to be written to the database\n+  -- as well as the unnecessary creation of the bot via the external service API call.\n+  -- However, in case we refine the roles model in the future, this check might not be granular enough.\n+  -- In that case we should rather do an internal call to galley to check for the correct permissions.\n+  -- Also see `removeBot` for a similar check.\n+  guardConvAdmin cnv\n   let mems = cnvMembers cnv\n   unless (cnvType cnv == RegularConv) $\n     throwStd invalidConv\n@@ -974,6 +982,12 @@ removeBot :: Members '[GalleyProvider] r => UserId -> ConnId -> ConvId -> BotId\n removeBot zusr zcon cid bid = do\n   -- Get the conversation and check preconditions\n   cnv <- lift (liftSem $ GalleyProvider.getConv zusr cid) >>= maybeConvNotFound\n+  -- Check that the user is a conversation admin and therefore is allowed to remove a bot from the conversation.\n+  -- Note that this precondition is also checked in the internal galley API.\n+  -- However, in case we refine the roles model in the future, this check might not be granular enough.\n+  -- In that case we should rather do an internal call to galley to check for the correct permissions.\n+  -- Also see `addBot` for a similar check.\n+  guardConvAdmin cnv\n   let mems = cnvMembers cnv\n   unless (cnvType cnv == RegularConv) $\n     throwStd invalidConv\n@@ -985,6 +999,11 @@ removeBot zusr zcon cid bid = do\n     Just _ -> do\n       lift $ Public.RemoveBotResponse <$$> wrapHttpClient (deleteBot zusr (Just zcon) bid cid)\n \n+guardConvAdmin :: Conversation -> ExceptT Error (AppT r) ()\n+guardConvAdmin conv = do\n+  let selfMember = cmSelf . cnvMembers $ conv\n+  unless (memConvRoleName selfMember == roleNameWireAdmin) $ throwStd accessDenied\n+\n --------------------------------------------------------------------------------\n -- Bot API\n "
        },
        {
          "filename": "services/brig/test/integration/API/Provider.hs",
          "status": "modified",
          "additions": 50,
          "deletions": 0,
          "patch": "@@ -148,6 +148,7 @@ tests dom conf p db b c g = do\n         testGroup\n           \"bot-teams\"\n           [ test p \"add-remove\" $ testAddRemoveBotTeam conf db b g c,\n+            test p \"add-remove-access-denied-for-non-conv-admin\" $ testNonConvAdminCannotAddRemoveBot conf db b g,\n             test p \"team-only\" $ testBotTeamOnlyConv conf db b g c,\n             test p \"message\" $ testMessageBotTeam conf db b g c,\n             test p \"delete conv\" $ testDeleteConvBotTeam conf db b g c,\n@@ -566,6 +567,30 @@ testAddBotBlocked config db brig galley = withTestService config db brig defServ\n     const 403 === statusCode\n     const (Just \"access-denied\") === fmap Error.label . responseJsonMaybe\n \n+testNonConvAdminCannotAddRemoveBot :: Config -> DB.ClientState -> Brig -> Galley -> Http ()\n+testNonConvAdminCannotAddRemoveBot config db brig galley = withTestService config db brig defServiceApp $ \\sref _buf -> do\n+  let pid = sref ^. serviceRefProvider\n+  let sid = sref ^. serviceRefId\n+  (ownerId, tid) <- Team.createUserWithTeam brig\n+  member <- Team.createTeamMember brig galley ownerId tid fullPermissions\n+  let memberId = userId member\n+  whitelistService brig ownerId tid pid sid\n+  cid <- Team.createTeamConvWithRole roleNameWireMember galley tid ownerId [memberId] Nothing\n+  addBot brig memberId pid sid cid !!! do\n+    const 403 === statusCode\n+    const (Just \"access-denied\") === fmap Error.label . responseJsonMaybe\n+  rs <- responseJsonError =<< addBot brig ownerId pid sid cid <!! const 201 === statusCode\n+  let bid = rsAddBotId rs\n+      buid = botUserId bid\n+  getUser brig ownerId buid !!! const 200 === statusCode\n+  removeBot brig memberId cid bid !!! do\n+    const 403 === statusCode\n+    const (Just \"access-denied\") === fmap Error.label . responseJsonMaybe\n+  -- also check the internal galley API\n+  removeBotInternal galley memberId cid bid !!! do\n+    const 403 === statusCode\n+    const (Just \"action-denied\") === fmap Error.label . responseJsonMaybe\n+\n testGetBotConvBlocked :: Config -> DB.ClientState -> Brig -> Galley -> Cannon -> Http ()\n testGetBotConvBlocked config db brig galley cannon = withTestService config db brig defServiceApp $ \\sref buf -> do\n   (user1, userId -> u2, _, tid, cid, pid, sid) <- prepareBotUsersTeam brig galley sref\n@@ -1305,6 +1330,31 @@ removeBot brig uid cid bid =\n       . header \"Z-User\" (toByteString' uid)\n       . header \"Z-Connection\" \"conn\"\n \n+data RemoveBot = RemoveBot\n+  { _rmBotConv :: !ConvId,\n+    _rmBotId :: !BotId\n+  }\n+\n+instance ToJSON RemoveBot where\n+  toJSON a =\n+    object\n+      [ \"conversation\" .= _rmBotConv a,\n+        \"bot\" .= _rmBotId a\n+      ]\n+\n+removeBotInternal ::\n+  Galley ->\n+  UserId ->\n+  ConvId ->\n+  BotId ->\n+  Http ResponseLBS\n+removeBotInternal galley uid cid bid =\n+  delete $\n+    galley\n+      . paths [\"i\", \"bots\"]\n+      . header \"Z-User\" (toByteString' uid)\n+      . Bilge.json (RemoveBot cid bid)\n+\n createConv ::\n   Galley ->\n   UserId ->"
        },
        {
          "filename": "services/brig/test/integration/API/Team/Util.hs",
          "status": "modified",
          "additions": 16,
          "deletions": 2,
          "patch": "@@ -214,10 +214,24 @@ updatePermissions from tid (to, perm) galley =\n     changeMember = Member.mkNewTeamMember to perm Nothing\n \n createTeamConv :: HasCallStack => Galley -> TeamId -> UserId -> [UserId] -> Maybe Milliseconds -> Http ConvId\n-createTeamConv g tid u us mtimer = do\n+createTeamConv = createTeamConvWithRole roleNameWireAdmin\n+\n+createTeamConvWithRole :: HasCallStack => RoleName -> Galley -> TeamId -> UserId -> [UserId] -> Maybe Milliseconds -> Http ConvId\n+createTeamConvWithRole role g tid u us mtimer = do\n   let tinfo = Just $ ConvTeamInfo tid\n   let conv =\n-        NewConv us [] Nothing (Set.fromList []) Nothing tinfo mtimer Nothing roleNameWireAdmin ProtocolProteusTag Nothing\n+        NewConv\n+          us\n+          []\n+          Nothing\n+          (Set.fromList [])\n+          Nothing\n+          tinfo\n+          mtimer\n+          Nothing\n+          role\n+          ProtocolProteusTag\n+          Nothing\n   r <-\n     post\n       ( g"
        },
        {
          "filename": "services/galley/src/Galley/API/Update.hs",
          "status": "modified",
          "additions": 15,
          "deletions": 4,
          "patch": "@@ -1571,6 +1571,8 @@ addBot lusr zcon b = do\n       unless (tUnqualified lusr `isMember` users) $ throwS @'ConvNotFound\n       ensureGroupConversation c\n       self <- getSelfMemberFromLocals (tUnqualified lusr) users\n+      -- Note that in brig from where this internal handler is called, we additionally check for conversation admin role.\n+      -- Remember to change this if we ever want to allow non admins to add bots.\n       ensureActionAllowed SAddConversationMember self\n       unless (any ((== b ^. addBotId) . botMemId) bots) $ do\n         let botId = qualifyAs lusr (botUserId (b ^. addBotId))\n@@ -1587,7 +1589,8 @@ rmBotH ::\n        Input (Local ()),\n        Input UTCTime,\n        MemberStore,\n-       WaiRoutes\n+       WaiRoutes,\n+       ErrorS ('ActionDenied 'RemoveConversationMember)\n      ]\n     r =>\n   UserId ::: Maybe ConnId ::: JsonRequest RemoveBot ->\n@@ -1605,7 +1608,8 @@ rmBot ::\n        ExternalAccess,\n        GundeckAccess,\n        Input UTCTime,\n-       MemberStore\n+       MemberStore,\n+       ErrorS ('ActionDenied 'RemoveConversationMember)\n      ]\n     r =>\n   Local UserId ->\n@@ -1615,10 +1619,17 @@ rmBot ::\n rmBot lusr zcon b = do\n   c <-\n     E.getConversation (b ^. rmBotConv) >>= noteS @'ConvNotFound\n-  let lcnv = qualifyAs lusr (Data.convId c)\n+  let (bots, users) = localBotsAndUsers (Data.convLocalMembers c)\n   unless (tUnqualified lusr `isMember` Data.convLocalMembers c) $\n     throwS @'ConvNotFound\n-  let (bots, users) = localBotsAndUsers (Data.convLocalMembers c)\n+  -- A bot can remove itself (which will internally be triggered when a service is deleted),\n+  -- otherwise we have to check for the correct permissions\n+  unless (botUserId (b ^. rmBotId) == tUnqualified lusr) $ do\n+    -- Note that in brig from where this internal handler is called, we additionally check for conversation admin role.\n+    -- Remember to change this if we ever want to allow non admins to remove bots.\n+    self <- getSelfMemberFromLocals (tUnqualified lusr) users\n+    ensureActionAllowed SRemoveConversationMember self\n+  let lcnv = qualifyAs lusr (Data.convId c)\n   if not (any ((== b ^. rmBotId) . botMemId) bots)\n     then pure Unchanged\n     else do"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "55dd92cff78dc7558686604e6b97af0774e5273d",
            "date": "2025-01-14T11:23:56Z",
            "author_login": "stefanwire"
          },
          {
            "sha": "d227425e538f604ea705f814aba3430e03abb810",
            "date": "2025-01-14T09:59:47Z",
            "author_login": "akshaymankar"
          },
          {
            "sha": "768bc78e8a7afc0162ffe8fd962f0f5379b2a020",
            "date": "2025-01-13T10:34:07Z",
            "author_login": "akshaymankar"
          },
          {
            "sha": "c7bb078b04d2921947ee6cfcdeac039d8b428de2",
            "date": "2025-01-10T16:19:22Z",
            "author_login": "battermann"
          },
          {
            "sha": "413d9d0d16b86c05706086de877920bea29a93e7",
            "date": "2025-01-08T12:38:35Z",
            "author_login": "akshaymankar"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-280",
    "description": "wire-server provides back end services for Wire, a team communication and collaboration platform. Prior to version 2022-12-09, every member of a Conversation can remove a Bot from a Conversation due to a missing permissions check. Only Conversation admins should be able to remove Bots. Regular Conversations are not allowed to do so. The issue is fixed in wire-server 2022-12-09 and is already deployed on all Wire managed services. On-premise instances of wire-server need to be updated to 2022-12-09/Chart 4.29.0, so that their backends are no longer affected. There are no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-01-28T00:15:08.863",
    "last_modified": "2024-11-21T07:45:19.600",
    "fix_date": "2022-11-25T11:36:24Z"
  },
  "references": [
    {
      "url": "https://github.com/wireapp/wire-server/commit/494a6881f5895d4ed9e5d011455242be0d5e6223",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/pull/2870",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/releases/tag/v2022-12-09",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/security/advisories/GHSA-xmjc-c6w3-pcp4",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/commit/494a6881f5895d4ed9e5d011455242be0d5e6223",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/pull/2870",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/releases/tag/v2022-12-09",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/wireapp/wire-server/security/advisories/GHSA-xmjc-c6w3-pcp4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:03.948488",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wire-server",
    "owner": "wireapp",
    "created_at": "2017-02-14T10:42:59Z",
    "updated_at": "2025-01-14T11:24:01Z",
    "pushed_at": "2025-01-14T12:55:53Z",
    "size": 69111,
    "stars": 2644,
    "forks": 325,
    "open_issues": 138,
    "watchers": 2644,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Haskell": 12352684,
      "HTML": 2542469,
      "Nix": 364952,
      "Shell": 128228,
      "Python": 79336,
      "Smarty": 52585,
      "Rust": 48416,
      "Makefile": 47259,
      "Mustache": 15835,
      "C": 12943,
      "jq": 10188,
      "DIGITAL Command Language": 2530,
      "JavaScript": 1883,
      "Dockerfile": 1192
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T16:28:19.649994"
  }
}