{
  "cve_id": "CVE-2023-22742",
  "github_data": {
    "repository": "libgit2/libgit2",
    "fix_commit": "42e5db98b963ae503229c63e44e06e439df50e56",
    "related_commits": [
      "42e5db98b963ae503229c63e44e06e439df50e56",
      "cd6f679af401eda1f172402006ef8265f8bd58ea",
      "42e5db98b963ae503229c63e44e06e439df50e56",
      "cd6f679af401eda1f172402006ef8265f8bd58ea"
    ],
    "patch_url": "https://github.com/libgit2/libgit2/commit/42e5db98b963ae503229c63e44e06e439df50e56.patch",
    "fix_commit_details": {
      "sha": "42e5db98b963ae503229c63e44e06e439df50e56",
      "commit_date": "2023-01-20T22:11:52Z",
      "author": {
        "login": "ethomson",
        "type": "User",
        "stats": {
          "total_commits": 3674,
          "average_weekly_commits": 4.337662337662338,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 412
        }
      },
      "commit_message": {
        "title": "Merge pull request #6450 from libgit2/1.5_ssh",
        "length": 88,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 445,
        "additions": 348,
        "deletions": 97
      },
      "files": [
        {
          "filename": "CMakeLists.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -6,7 +6,7 @@\n \n cmake_minimum_required(VERSION 3.5.1)\n \n-project(libgit2 VERSION \"1.5.0\" LANGUAGES C)\n+project(libgit2 VERSION \"1.5.1\" LANGUAGES C)\n \n # Add find modules to the path\n set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${PROJECT_SOURCE_DIR}/cmake\")"
        },
        {
          "filename": "ci/test.sh",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -144,6 +144,11 @@ if [ -z \"$SKIP_SSH_TESTS\" ]; then\n \t\techo \"[localhost]:2222 $algorithm $key\" >>\"${HOME}/.ssh/known_hosts\"\n \tdone <\"${SSHD_DIR}/id_rsa.pub\"\n \n+\t# Append the github.com keys for the tests that don't override checks.\n+\t# We ask for ssh-rsa to test that the selection based off of known_hosts\n+\t# is working.\n+\tssh-keyscan -t ssh-rsa github.com >>\"${HOME}/.ssh/known_hosts\"\n+\n \t# Get the fingerprint for localhost and remove the colons so we can\n \t# parse it as a hex number. Older versions have a different output\n \t# format."
        },
        {
          "filename": "docs/changelog.md",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -1,3 +1,14 @@\n+v1.5.1\n+------\n+\n+\ud83d\udd12 This is a security release to address CVE-2023-22742: when compiled using the optional, included libssh2 backend, libgit2 fails to verify SSH keys by default.\n+\n+When using an SSH remote with the optional, included libssh2 backend, libgit2 does not perform certificate checking by default. Prior versions of libgit2 require the caller to set the `certificate_check` field of libgit2's `git_remote_callbacks` structure - if a certificate check callback is not set, libgit2 does not perform any certificate checking. This means that by default - without configuring a certificate check callback, clients will not perform validation on the server SSH keys and may be subject to a man-in-the-middle attack.\n+\n+The libgit2 security team would like to thank the Julia and Rust security teams for responsibly disclosing this vulnerability and assisting with fixing the vulnerability.\n+\n+All users of the v1.5 release line are recommended to upgrade.\n+\n v1.5\n ----\n "
        },
        {
          "filename": "include/git2/version.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -11,7 +11,7 @@\n  * The version string for libgit2.  This string follows semantic\n  * versioning (v2) guidelines.\n  */\n-#define LIBGIT2_VERSION        \"1.5.0\"\n+#define LIBGIT2_VERSION        \"1.5.1\"\n \n /** The major version number for this version of libgit2. */\n #define LIBGIT2_VER_MAJOR      1\n@@ -20,7 +20,7 @@\n #define LIBGIT2_VER_MINOR      5\n \n /** The revision (\"teeny\") version number for this version of libgit2. */\n-#define LIBGIT2_VER_REVISION   0\n+#define LIBGIT2_VER_REVISION   1\n \n /** The Windows DLL patch number for this version of libgit2. */\n #define LIBGIT2_VER_PATCH      0"
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"libgit2\",\n-  \"version\": \"1.5.0\",\n+  \"version\": \"1.5.1\",\n   \"repo\": \"https://github.com/libgit2/libgit2\",\n   \"description\": \" A cross-platform, linkable library implementation of Git that you can use in your application.\",\n   \"install\": \"mkdir build && cd build && cmake .. && cmake --build .\""
        },
        {
          "filename": "src/libgit2/transports/ssh.c",
          "status": "modified",
          "additions": 326,
          "deletions": 91,
          "patch": "@@ -421,37 +421,345 @@ static int request_creds(git_credential **out, ssh_subtransport *t, const char *\n \treturn 0;\n }\n \n+#define KNOWN_HOSTS_FILE \".ssh/known_hosts\"\n+\n+/*\n+ * Load the known_hosts file.\n+ *\n+ * Returns success but leaves the output NULL if we couldn't find the file.\n+ */\n+static int load_known_hosts(LIBSSH2_KNOWNHOSTS **hosts, LIBSSH2_SESSION *session)\n+{\n+\tgit_str path = GIT_STR_INIT, home = GIT_STR_INIT;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts = NULL;\n+\tint error;\n+\n+\tGIT_ASSERT_ARG(hosts);\n+\n+\tif ((error = git__getenv(&home, \"HOME\")) < 0)\n+\t\treturn error;\n+\n+\tif ((error = git_str_joinpath(&path, git_str_cstr(&home), KNOWN_HOSTS_FILE)) < 0)\n+\t\tgoto out;\n+\n+\tif ((known_hosts = libssh2_knownhost_init(session)) == NULL) {\n+\t\tssh_error(session, \"error initializing known hosts\");\n+\t\terror = -1;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Try to read the file and consider not finding it as not trusting the\n+\t * host rather than an error.\n+\t */\n+\terror = libssh2_knownhost_readfile(known_hosts, git_str_cstr(&path), LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n+\tif (error == LIBSSH2_ERROR_FILE)\n+\t\terror = 0;\n+\tif (error < 0)\n+\t\tssh_error(session, \"error reading known_hosts\");\n+\n+out:\n+\t*hosts = known_hosts;\n+\n+\tgit_str_clear(&home);\n+\tgit_str_clear(&path);\n+\n+\treturn error;\n+}\n+\n+static const char *hostkey_type_to_string(int type)\n+{\n+\tswitch (type) {\n+\tcase LIBSSH2_KNOWNHOST_KEY_SSHRSA:\n+\t\treturn \"ssh-rsa\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_SSHDSS:\n+\t\treturn \"ssh-dss\";\n+#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_256\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_256:\n+\t\treturn \"ecdsa-sha2-nistp256\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_384:\n+\t\treturn \"ecdsa-sha2-nistp384\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n+\t\treturn \"ecdsa-sha2-nistp521\";\n+#endif\n+#ifdef LIBSSH2_KNOWNHOST_KEY_ED25519\n+\tcase LIBSSH2_KNOWNHOST_KEY_ED25519:\n+\t\treturn \"ssh-ed25519\";\n+#endif\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+/*\n+ * We figure out what kind of key we want to ask the remote for by trying to\n+ * look it up with a nonsense key and using that mismatch to figure out what key\n+ * we do have stored for the host.\n+ *\n+ * Returns the string to pass to libssh2_session_method_pref or NULL if we were\n+ * unable to find anything or an error happened.\n+ */\n+static const char *find_hostkey_preference(LIBSSH2_KNOWNHOSTS *known_hosts, const char *hostname, int port)\n+{\n+\tstruct libssh2_knownhost *host = NULL;\n+\t/* Specify no key type so we don't filter on that */\n+\tint type = LIBSSH2_KNOWNHOST_TYPE_PLAIN | LIBSSH2_KNOWNHOST_KEYENC_RAW;\n+\tconst char key = '\\0';\n+\tint error;\n+\n+\t/*\n+\t * In case of mismatch, we can find the type of key from known_hosts in\n+\t * the returned host's information as it means that an entry was found\n+\t * but our nonsense key obviously didn't match.\n+\t */\n+\terror = libssh2_knownhost_checkp(known_hosts, hostname, port, &key, 1, type, &host);\n+\tif (error == LIBSSH2_KNOWNHOST_CHECK_MISMATCH)\n+\t\treturn hostkey_type_to_string(host->typemask & LIBSSH2_KNOWNHOST_KEY_MASK);\n+\n+\treturn NULL;\n+}\n+\n static int _git_ssh_session_create(\n \tLIBSSH2_SESSION **session,\n+\tLIBSSH2_KNOWNHOSTS **hosts,\n+\tconst char *hostname,\n+\tint port,\n \tgit_stream *io)\n {\n \tint rc = 0;\n \tLIBSSH2_SESSION *s;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts;\n \tgit_socket_stream *socket = GIT_CONTAINER_OF(io, git_socket_stream, parent);\n+\tconst char *keytype = NULL;\n \n \tGIT_ASSERT_ARG(session);\n+\tGIT_ASSERT_ARG(hosts);\n \n \ts = libssh2_session_init();\n \tif (!s) {\n \t\tgit_error_set(GIT_ERROR_NET, \"failed to initialize SSH session\");\n \t\treturn -1;\n \t}\n \n+\tif ((rc = load_known_hosts(&known_hosts, s)) < 0) {\n+\t\tssh_error(s, \"error loading known_hosts\");\n+\t\tlibssh2_session_free(s);\n+\t\treturn -1;\n+\t}\n+\n+\tif ((keytype = find_hostkey_preference(known_hosts, hostname, port)) != NULL) {\n+\t\tdo {\n+\t\t\trc = libssh2_session_method_pref(s, LIBSSH2_METHOD_HOSTKEY, keytype);\n+\t\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n+\t\tif (rc != LIBSSH2_ERROR_NONE) {\n+\t\t\tssh_error(s, \"failed to set hostkey preference\");\n+\t\t\tgoto on_error;\n+\t\t}\n+\t}\n+\n+\n \tdo {\n \t\trc = libssh2_session_handshake(s, socket->s);\n \t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n \n \tif (rc != LIBSSH2_ERROR_NONE) {\n \t\tssh_error(s, \"failed to start SSH session\");\n-\t\tlibssh2_session_free(s);\n-\t\treturn -1;\n+\t\tgoto on_error;\n \t}\n \n \tlibssh2_session_set_blocking(s, 1);\n \n \t*session = s;\n+\t*hosts = known_hosts;\n \n \treturn 0;\n+\n+on_error:\n+\tlibssh2_knownhost_free(known_hosts);\n+\tlibssh2_session_free(s);\n+\treturn -1;\n+}\n+\n+\n+/*\n+ * Returns the typemask argument to pass to libssh2_knownhost_check{,p} based on\n+ * the type of key that libssh2_session_hostkey returns.\n+ */\n+static int fingerprint_type_mask(int keytype)\n+{\n+\tint mask = LIBSSH2_KNOWNHOST_TYPE_PLAIN | LIBSSH2_KNOWNHOST_KEYENC_RAW;\n+\treturn mask;\n+\n+\tswitch (keytype) {\n+\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_SSHRSA;\n+\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_SSHDSS;\n+\t\tbreak;\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_256;\n+\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_384;\n+\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_521:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_521;\n+\t\tbreak;\n+#endif\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n+\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ED25519;\n+\t\tbreak;\n+#endif\n+\t}\n+\n+\treturn mask;\n+}\n+\n+/*\n+ * Check the host against the user's known_hosts file.\n+ *\n+ * Returns 1/0 for valid/''not-valid or <0 for an error\n+ */\n+static int check_against_known_hosts(\n+\tLIBSSH2_SESSION *session,\n+\tLIBSSH2_KNOWNHOSTS *known_hosts,\n+\tconst char *hostname,\n+\tint port,\n+\tconst char *key,\n+\tsize_t key_len,\n+\tint key_type)\n+{\n+\tint check, typemask, ret = 0;\n+\tstruct libssh2_knownhost *host = NULL;\n+\n+\tif (known_hosts == NULL)\n+\t\treturn 0;\n+\n+\ttypemask = fingerprint_type_mask(key_type);\n+\tcheck = libssh2_knownhost_checkp(known_hosts, hostname, port, key, key_len, typemask, &host);\n+\tif (check == LIBSSH2_KNOWNHOST_CHECK_FAILURE) {\n+\t\tssh_error(session, \"error checking for known host\");\n+\t\treturn -1;\n+\t}\n+\n+\tret = check == LIBSSH2_KNOWNHOST_CHECK_MATCH ? 1 : 0;\n+\n+\treturn ret;\n+}\n+\n+/*\n+ * Perform the check for the session's certificate against known hosts if\n+ * possible and then ask the user if they have a callback.\n+ *\n+ * Returns 1/0 for valid/not-valid or <0 for an error\n+ */\n+static int check_certificate(\n+\tLIBSSH2_SESSION *session,\n+\tLIBSSH2_KNOWNHOSTS *known_hosts,\n+\tgit_transport_certificate_check_cb check_cb,\n+\tvoid *check_cb_payload,\n+\tconst char *host,\n+\tint port)\n+{\n+\tgit_cert_hostkey cert = {{ 0 }};\n+\tconst char *key;\n+\tsize_t cert_len;\n+\tint cert_type, cert_valid = 0, error = 0;\n+\n+\tif ((key = libssh2_session_hostkey(session, &cert_len, &cert_type)) == NULL) {\n+\t\tssh_error(session, \"failed to retrieve hostkey\");\n+\t\treturn -1;\n+\t}\n+\n+\tif ((cert_valid = check_against_known_hosts(session, known_hosts, host, port, key, cert_len, cert_type)) < 0)\n+\t\treturn -1;\n+\n+\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_RAW;\n+\t\tcert.hostkey = key;\n+\t\tcert.hostkey_len = cert_len;\n+\t\tswitch (cert_type) {\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_RSA;\n+\t\t\tbreak;\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;\n+\t\t\tbreak;\n+\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;\n+\t\t\tbreak;\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;\n+\t\t\tbreak;\n+\t\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;\n+\t\t\tbreak;\n+#endif\n+\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;\n+\t\t\tbreak;\n+#endif\n+\t\tdefault:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;\n+\t\t}\n+\t}\n+\n+#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n+\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA256);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_SHA256;\n+\t\tmemcpy(&cert.hash_sha256, key, 32);\n+\t}\n+#endif\n+\n+\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_SHA1;\n+\t\tmemcpy(&cert.hash_sha1, key, 20);\n+\t}\n+\n+\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_MD5;\n+\t\tmemcpy(&cert.hash_md5, key, 16);\n+\t}\n+\n+\tif (cert.type == 0) {\n+\t\tgit_error_set(GIT_ERROR_SSH, \"unable to get the host key\");\n+\t\treturn -1;\n+\t}\n+\n+\tgit_error_clear();\n+\terror = 0;\n+\tif (!cert_valid) {\n+\t\tgit_error_set(GIT_ERROR_SSH, \"invalid or unknown remote ssh hostkey\");\n+\t\terror = GIT_ECERTIFICATE;\n+\t}\n+\n+\tif (check_cb != NULL) {\n+\t\tgit_cert_hostkey *cert_ptr = &cert;\n+\t\tgit_error_state previous_error = {0};\n+\n+\t\tgit_error_state_capture(&previous_error, error);\n+\t\terror = check_cb((git_cert *) cert_ptr, cert_valid, host, check_cb_payload);\n+\t\tif (error == GIT_PASSTHROUGH) {\n+\t\t\terror = git_error_state_restore(&previous_error);\n+\t\t} else if (error < 0 && !git_error_last()) {\n+\t\t\tgit_error_set(GIT_ERROR_NET, \"user canceled hostkey check\");\n+\t\t}\n+\n+\t\tgit_error_state_free(&previous_error);\n+\t}\n+\n+\treturn error;\n }\n \n #define SSH_DEFAULT_PORT \"22\"\n@@ -462,11 +770,12 @@ static int _git_ssh_setup_conn(\n \tconst char *cmd,\n \tgit_smart_subtransport_stream **stream)\n {\n-\tint auth_methods, error = 0;\n+\tint auth_methods, error = 0, port;\n \tssh_stream *s;\n \tgit_credential *cred = NULL;\n \tLIBSSH2_SESSION *session=NULL;\n \tLIBSSH2_CHANNEL *channel=NULL;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts = NULL;\n \n \tt->current_stream = NULL;\n \n@@ -490,96 +799,20 @@ static int _git_ssh_setup_conn(\n \t    (error = git_stream_connect(s->io)) < 0)\n \t\tgoto done;\n \n-\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n-\t\tgoto done;\n-\n-\tif (t->owner->connect_opts.callbacks.certificate_check != NULL) {\n-\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n-\t\tconst char *key;\n-\t\tsize_t cert_len;\n-\t\tint cert_type;\n-\n-\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n-\n-\t\tkey = libssh2_session_hostkey(session, &cert_len, &cert_type);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_RAW;\n-\t\t\tcert.hostkey = key;\n-\t\t\tcert.hostkey_len = cert_len;\n-\t\t\tswitch (cert_type) {\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_RSA;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;\n-\t\t\t\t\tbreak;\n-\n-#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;\n-\t\t\t\t\tbreak;\n-#endif\n-\n-#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;\n-\t\t\t\t\tbreak;\n-#endif\n-\t\t\t\tdefault:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;\n-\t\t\t}\n-\t\t}\n-\n-#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA256);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_SHA256;\n-\t\t\tmemcpy(&cert.hash_sha256, key, 32);\n-\t\t}\n-#endif\n-\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n-\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n-\t\t}\n-\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n-\t\t\tmemcpy(&cert.hash_md5, key, 16);\n-\t\t}\n-\n-\t\tif (cert.type == 0) {\n-\t\t\tgit_error_set(GIT_ERROR_SSH, \"unable to get the host key\");\n-\t\t\terror = -1;\n-\t\t\tgoto done;\n-\t\t}\n-\n-\t\t/* We don't currently trust any hostkeys */\n-\t\tgit_error_clear();\n-\n-\t\tcert_ptr = &cert;\n-\n-\t\terror = t->owner->connect_opts.callbacks.certificate_check(\n-\t\t\t(git_cert *)cert_ptr,\n-\t\t\t0,\n-\t\t\ts->url.host,\n-\t\t\tt->owner->connect_opts.callbacks.payload);\n+\t/*\n+\t * Try to parse the port as a number, if we can't then fall back to\n+\t * default. It would be nice if we could get the port that was resolved\n+\t * as part of the stream connection, but that's not something that's\n+\t * exposed.\n+\t */\n+\tif (git__strntol32(&port, s->url.port, strlen(s->url.port), NULL, 10) < 0)\n+\t\tport = -1;\n \n-\t\tif (error < 0 && error != GIT_PASSTHROUGH) {\n-\t\t\tif (!git_error_last())\n-\t\t\t\tgit_error_set(GIT_ERROR_NET, \"user cancelled hostkey check\");\n+\tif ((error = _git_ssh_session_create(&session, &known_hosts, s->url.host, port, s->io)) < 0)\n+\t\tgoto done;\n \n-\t\t\tgoto done;\n-\t\t}\n-\t}\n+\tif ((error = check_certificate(session, known_hosts, t->owner->connect_opts.callbacks.certificate_check, t->owner->connect_opts.callbacks.payload, s->url.host, port)) < 0)\n+\t\tgoto done;\n \n \t/* we need the username to ask for auth methods */\n \tif (!s->url.username) {\n@@ -651,6 +884,8 @@ static int _git_ssh_setup_conn(\n \tif (error < 0) {\n \t\tssh_stream_free(*stream);\n \n+\t\tif (known_hosts)\n+\t\t\tlibssh2_knownhost_free(known_hosts);\n \t\tif (session)\n \t\t\tlibssh2_session_free(session);\n \t}"
        },
        {
          "filename": "tests/libgit2/CMakeLists.txt",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -66,10 +66,10 @@ endif()\n include(AddClarTest)\n add_clar_test(libgit2_tests offline             -v -xonline)\n add_clar_test(libgit2_tests invasive            -v -score::ftruncate -sfilter::stream::bigfile -sodb::largefiles -siterator::workdir::filesystem_gunk -srepo::init -srepo::init::at_filesystem_root)\n-add_clar_test(libgit2_tests online              -v -sonline -xonline::customcert)\n+add_clar_test(libgit2_tests online              -v -sonline -xonline::customcert -xonline::clone::ssh_auth_methods)\n add_clar_test(libgit2_tests online_customcert   -v -sonline::customcert)\n add_clar_test(libgit2_tests gitdaemon           -v -sonline::push)\n-add_clar_test(libgit2_tests ssh                 -v -sonline::push -sonline::clone::ssh_cert -sonline::clone::ssh_with_paths -sonline::clone::path_whitespace_ssh)\n+add_clar_test(libgit2_tests ssh                 -v -sonline::push -sonline::clone::ssh_cert -sonline::clone::ssh_with_paths -sonline::clone::path_whitespace_ssh -sonline::clone::ssh_auth_methods)\n add_clar_test(libgit2_tests proxy               -v -sonline::clone::proxy)\n add_clar_test(libgit2_tests auth_clone          -v -sonline::clone::cred)\n add_clar_test(libgit2_tests auth_clone_and_push -v -sonline::clone::push -sonline::push)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 2,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9692f45ca8d9286da96e8849cf75460382e7d02d",
            "date": "2025-01-14T15:45:52Z",
            "author_login": "ethomson"
          },
          {
            "sha": "f9e9ddd88400311d203ed4a9f86f3862abaec7a1",
            "date": "2025-01-14T12:48:28Z",
            "author_login": "ethomson"
          },
          {
            "sha": "7daaf6151a630cf0c6f2a3cda2f78a313fb6ec94",
            "date": "2025-01-13T23:19:48Z",
            "author_login": "ethomson"
          },
          {
            "sha": "02435d7647619107f90871b7c9420f9ec00b0805",
            "date": "2025-01-10T22:35:55Z",
            "author_login": "ethomson"
          },
          {
            "sha": "9c2b827cefb070c8dbbeea521d89473d082b8e1b",
            "date": "2025-01-10T22:28:05Z",
            "author_login": "ethomson"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-347",
    "description": "libgit2 is a cross-platform, linkable library implementation of Git. When using an SSH remote with the optional libssh2 backend, libgit2 does not perform certificate checking by default. Prior versions of libgit2 require the caller to set the `certificate_check` field of libgit2's `git_remote_callbacks` structure - if a certificate check callback is not set, libgit2 does not perform any certificate checking. This means that by default - without configuring a certificate check callback, clients will not perform validation on the server SSH keys and may be subject to a man-in-the-middle attack. Users are encouraged to upgrade to v1.4.5 or v1.5.1. Users unable to upgrade should ensure that all relevant certificates are manually checked.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-01-20T23:15:10.307",
    "last_modified": "2024-11-21T07:45:20.250",
    "fix_date": "2023-01-20T22:11:52Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2023/11/06/5",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/libgit2/libgit2/commit/42e5db98b963ae503229c63e44e06e439df50e56",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/commit/cd6f679af401eda1f172402006ef8265f8bd58ea",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/releases/tag/v1.4.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/releases/tag/v1.5.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/security/advisories/GHSA-8643-3wh5-rmjq",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.libssh2.org",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2023/11/06/5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/libgit2/libgit2/commit/42e5db98b963ae503229c63e44e06e439df50e56",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/commit/cd6f679af401eda1f172402006ef8265f8bd58ea",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/releases/tag/v1.4.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/releases/tag/v1.5.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/libgit2/libgit2/security/advisories/GHSA-8643-3wh5-rmjq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.libssh2.org",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:04:43.585432",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libgit2",
    "owner": "libgit2",
    "created_at": "2010-09-10T16:17:48Z",
    "updated_at": "2025-01-14T07:38:21Z",
    "pushed_at": "2025-01-14T12:48:46Z",
    "size": 72477,
    "stars": 9776,
    "forks": 2431,
    "open_issues": 439,
    "watchers": 9776,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C": 8196097,
      "Perl": 112049,
      "JavaScript": 93351,
      "CMake": 87027,
      "Shell": 57464,
      "Python": 20757,
      "Awk": 16256,
      "PHP": 5691
    },
    "commit_activity": {
      "total_commits_last_year": 573,
      "avg_commits_per_week": 11.01923076923077,
      "days_active_last_year": 141
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:39:41.885143"
  }
}