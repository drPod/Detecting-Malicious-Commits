{
  "cve_id": "CVE-2023-23626",
  "github_data": {
    "repository": "ipfs/go-bitfield",
    "fix_commit": "5e1d256fe043fc4163343ccca83862c69c52e579",
    "related_commits": [
      "5e1d256fe043fc4163343ccca83862c69c52e579",
      "5e1d256fe043fc4163343ccca83862c69c52e579"
    ],
    "patch_url": "https://github.com/ipfs/go-bitfield/commit/5e1d256fe043fc4163343ccca83862c69c52e579.patch",
    "fix_commit_details": {
      "sha": "5e1d256fe043fc4163343ccca83862c69c52e579",
      "commit_date": "2023-01-10T13:28:51Z",
      "author": {
        "login": "Jorropo",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "refactor: return errors instead of panics",
        "length": 236,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 81,
        "additions": 58,
        "deletions": 23
      },
      "files": [
        {
          "filename": "bitfield.go",
          "status": "modified",
          "additions": 14,
          "deletions": 9,
          "patch": "@@ -3,28 +3,33 @@ package bitfield\n // NOTE: Don't bother replacing the divisions/modulo with shifts/ands, go is smart.\n \n import (\n+\t\"fmt\"\n \t\"math/bits\"\n )\n \n // NewBitfield creates a new fixed-sized Bitfield (allocated up-front).\n-//\n-// Panics if size is not a multiple of 8.\n-func NewBitfield(size int) Bitfield {\n+func NewBitfield(size int) (Bitfield, error) {\n+\tif size < 0 {\n+\t\treturn nil, fmt.Errorf(\"bitfield size must be positive; got %d\", size)\n+\t}\n \tif size%8 != 0 {\n-\t\tpanic(\"Bitfield size must be a multiple of 8\")\n+\t\treturn nil, fmt.Errorf(\"bitfield size must be a multiple of 8; got %d\", size)\n \t}\n-\treturn make([]byte, size/8)\n+\treturn make([]byte, size/8), nil\n }\n \n // FromBytes constructs a new bitfield from a serialized bitfield.\n-func FromBytes(size int, bits []byte) Bitfield {\n-\tbf := NewBitfield(size)\n+func FromBytes(size int, bits []byte) (Bitfield, error) {\n+\tbf, err := NewBitfield(size)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tstart := len(bf) - len(bits)\n \tif start < 0 {\n-\t\tpanic(\"bitfield too small\")\n+\t\treturn nil, fmt.Errorf(\"bitfield too small: got %d; need %d\", size, len(bits)*8)\n \t}\n \tcopy(bf[start:], bits)\n-\treturn bf\n+\treturn bf, nil\n }\n \n func (bf Bitfield) offset(i int) (uint, uint8) {"
        },
        {
          "filename": "bitfield_test.go",
          "status": "modified",
          "additions": 44,
          "deletions": 14,
          "patch": "@@ -9,7 +9,8 @@ import (\n )\n \n func TestExhaustive24(t *testing.T) {\n-\tbf := NewBitfield(24)\n+\tbf, err := NewBitfield(24)\n+\tassertNoError(t, err)\n \tmax := 1 << 24\n \n \tbint := new(big.Int)\n@@ -58,7 +59,8 @@ func TestExhaustive24(t *testing.T) {\n }\n \n func TestBitfield(t *testing.T) {\n-\tbf := NewBitfield(128)\n+\tbf, err := NewBitfield(128)\n+\tassertNoError(t, err)\n \tif bf.OnesBefore(20) != 0 {\n \t\tt.Fatal(\"expected no bits set\")\n \t}\n@@ -91,10 +93,20 @@ func TestBitfield(t *testing.T) {\n \t}\n }\n \n+func TestBadSizeFails(t *testing.T) {\n+\tfor _, size := range [...]int{-8, 2, 1337, -3} {\n+\t\t_, err := NewBitfield(size)\n+\t\tif err == nil {\n+\t\t\tt.Fatalf(\"missing error for %d sized bitfield\", size)\n+\t\t}\n+\t}\n+}\n+\n var benchmarkSize = 512\n \n func BenchmarkBitfield(t *testing.B) {\n-\tbf := NewBitfield(benchmarkSize)\n+\tbf, err := NewBitfield(benchmarkSize)\n+\tassertNoError(t, err)\n \tt.ResetTimer()\n \tfor i := 0; i < t.N; i++ {\n \t\tif bf.Bit(i % benchmarkSize) {\n@@ -123,13 +135,14 @@ func BenchmarkBitfield(t *testing.B) {\n \t}\n }\n \n-func BenchmarkOnes(t *testing.B) {\n-\tbf := NewBitfield(benchmarkSize)\n-\tt.ResetTimer()\n-\tfor i := 0; i < t.N; i++ {\n+func BenchmarkOnes(b *testing.B) {\n+\tbf, err := NewBitfield(benchmarkSize)\n+\tassertNoError(b, err)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n \t\tfor j := 0; j*4 < benchmarkSize; j++ {\n \t\t\tif bf.Ones() != j {\n-\t\t\t\tt.Fatal(\"bad\", i)\n+\t\t\t\tb.Fatal(\"bad\", i)\n \t\t\t}\n \t\t\tbf.SetBit(j * 4)\n \t\t}\n@@ -139,14 +152,16 @@ func BenchmarkOnes(t *testing.B) {\n \t}\n }\n \n-func BenchmarkBytes(t *testing.B) {\n-\tbfa := NewBitfield(211)\n-\tbfb := NewBitfield(211)\n-\tfor j := 0; j*4 < 211; j++ {\n+func BenchmarkBytes(b *testing.B) {\n+\tbfa, err := NewBitfield(216)\n+\tassertNoError(b, err)\n+\tbfb, err := NewBitfield(216)\n+\tassertNoError(b, err)\n+\tfor j := 0; j*4 < 216; j++ {\n \t\tbfa.SetBit(j * 4)\n \t}\n-\tt.ResetTimer()\n-\tfor i := 0; i < t.N; i++ {\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n \t\tbfb.SetBytes(bfa.Bytes())\n \t}\n }\n@@ -180,3 +195,18 @@ func BenchmarkBigInt(t *testing.B) {\n \t\t}\n \t}\n }\n+\n+func FuzzFromBytes(f *testing.F) {\n+\tf.Fuzz(func(_ *testing.T, size int, bytes []byte) {\n+\t\tif size > 1<<20 { // We relly on consumers for limit checks, hopefully they understand that a New... factory allocates memory.\n+\t\t\treturn\n+\t\t}\n+\t\tFromBytes(size, bytes)\n+\t})\n+}\n+\n+func assertNoError(t testing.TB, e error) {\n+\tif e != nil {\n+\t\tt.Fatal(e)\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1bf14dcc4d77d8b358436f96e68e0cc0372663ca",
            "date": "2024-08-26T10:27:43Z",
            "author_login": "web3-bot"
          },
          {
            "sha": "a56e598edcaecaa42d4a3f6a8b117fd88752c802",
            "date": "2024-03-22T07:18:53Z",
            "author_login": "web3-bot"
          },
          {
            "sha": "ce076a4abd188ab23307319a06fa398978247d13",
            "date": "2024-03-14T11:27:23Z",
            "author_login": "web3-bot"
          },
          {
            "sha": "1ee929ce4eed0a8d48e0bf07d265d3908f9a32e3",
            "date": "2024-01-31T17:34:30Z",
            "author_login": "web-flow"
          },
          {
            "sha": "0d942eabded03edf5a327dbaf34d24003a33f1b2",
            "date": "2023-08-14T13:37:28Z",
            "author_login": "web3-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-754",
    "description": "go-bitfield is a simple bitfield package for the go language aiming to be more performant that the standard library. When feeding untrusted user input into the size parameter of `NewBitfield` and `FromBytes` functions, an attacker can trigger `panic`s. This happen when the `size` is a not a multiple of `8` or is negative. There were already a note in the `NewBitfield` documentation, however known users of this package are subject to this issue. Users are advised to upgrade. Users unable to upgrade should ensure that `size` is a multiple of 8 before calling `NewBitfield` or `FromBytes`.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-02-09T21:15:11.413",
    "last_modified": "2024-11-21T07:46:33.840",
    "fix_date": "2023-01-10T13:28:51Z"
  },
  "references": [
    {
      "url": "https://github.com/ipfs/go-bitfield/commit/5e1d256fe043fc4163343ccca83862c69c52e579",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/go-bitfield/security/advisories/GHSA-2h6c-j3gf-xp9r",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/ipfs/go-bitfield/commit/5e1d256fe043fc4163343ccca83862c69c52e579",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/go-bitfield/security/advisories/GHSA-2h6c-j3gf-xp9r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.009420",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "go-bitfield",
    "owner": "ipfs",
    "created_at": "2018-03-30T01:13:09Z",
    "updated_at": "2024-08-26T10:27:47Z",
    "pushed_at": "2024-10-10T08:17:06Z",
    "size": 38,
    "stars": 7,
    "forks": 2,
    "open_issues": 0,
    "watchers": 7,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 7458
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T19:17:05.662226"
  }
}