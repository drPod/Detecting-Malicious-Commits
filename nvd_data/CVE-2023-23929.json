{
  "cve_id": "CVE-2023-23929",
  "github_data": {
    "repository": "vantage6/vantage6",
    "fix_commit": "48ebfca42359e9a6743e9598684585e2522cdce8",
    "related_commits": [
      "48ebfca42359e9a6743e9598684585e2522cdce8",
      "48ebfca42359e9a6743e9598684585e2522cdce8"
    ],
    "patch_url": "https://github.com/vantage6/vantage6/commit/48ebfca42359e9a6743e9598684585e2522cdce8.patch",
    "fix_commit_details": {
      "sha": "48ebfca42359e9a6743e9598684585e2522cdce8",
      "commit_date": "2023-02-28T11:04:24Z",
      "author": {
        "login": "frankcorneliusmartin",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-4w59-c3gc-rrhp",
        "length": 87,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 196,
        "additions": 160,
        "deletions": 36
      },
      "files": [
        {
          "filename": "docs/server/yaml/server_config.yaml",
          "status": "modified",
          "additions": 9,
          "deletions": 3,
          "patch": "@@ -1,6 +1,6 @@\n application: {}\n   # you may also add your configuration here and leave environments empty\n-  ...\n+\n environments:\n   # name of the environment (should be 'test', 'prod', 'acc' or 'dev')\n   test:\n@@ -84,6 +84,11 @@ environments:\n     # set how long reset token provided via email are valid (default 1 hour)\n     email_token_validity_minutes: 60\n \n+    # set how long tokens and refresh tokens are valid (default 6 and 48\n+    # hours, respectively)\n+    token_expires_hours: 6\n+    refresh_token_expires_hours: 48\n+\n     # If algorithm containers need direct communication between each other\n     # the server also requires a VPN server. (!) This must be a EduVPN\n     # instance as vantage6 makes use of their API (!)\n@@ -102,5 +107,6 @@ environments:\n         portal_username: your_eduvpn_portal_user_name\n         portal_userpass: your_eduvpn_portal_user_password\n \n-  prod:\n-    ...\n\\ No newline at end of file\n+  prod: {}\n+  acc: {}\n+  dev: {}\n\\ No newline at end of file"
        },
        {
          "filename": "vantage6-client/vantage6/client/__init__.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -366,6 +366,7 @@ def refresh_token(self) -> None:\n             raise Exception(\"Authentication Error!\")\n \n         self._access_token = response.json()[\"access_token\"]\n+        self.__refresh_token = response.json()[\"refresh_token\"]\n \n     # TODO BvB 23-01-23 remove this method in v4+. It is only here for\n     # backwards compatibility"
        },
        {
          "filename": "vantage6-node/vantage6/node/__init__.py",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -486,6 +486,9 @@ def authenticate(self) -> None:\n             self.log.critical('Unable to authenticate. Exiting')\n             exit(1)\n \n+        # start thread to keep the connection alive by refreshing the token\n+        self.server_io.auto_refresh_token()\n+\n     def private_key_filename(self) -> Path:\n         \"\"\"Get the path to the private key.\"\"\"\n "
        },
        {
          "filename": "vantage6-node/vantage6/node/globals.py",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -44,3 +44,6 @@\n #   SSH TUNNEL RELATED CONSTANTS\n #\n SSH_TUNNEL_IMAGE = \"harbor2.vantage6.ai/infrastructure/ssh-tunnel\"\n+\n+# start trying to refresh the JWT token 10 minutes before it expires.\n+REFRESH_BEFORE_EXPIRES_SECONDS = 600"
        },
        {
          "filename": "vantage6-node/vantage6/node/server_io.py",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -4,10 +4,14 @@\n \"\"\"\n import jwt\n import datetime\n+import time\n+\n from typing import Dict, Tuple\n+from threading import Thread\n \n from vantage6.common import WhoAmI\n from vantage6.client import ClientBase\n+from vantage6.node.globals import REFRESH_BEFORE_EXPIRES_SECONDS\n \n \n class NodeClient(ClientBase):\n@@ -61,6 +65,26 @@ def authenticate(self, api_key: str):\n             organization_name=organization_name\n         )\n \n+    def auto_refresh_token(self) -> None:\n+        \"\"\" Start a thread that refreshes token before it expires. \"\"\"\n+        # set up thread to refresh token\n+        t = Thread(target=self.__refresh_token_worker, daemon=True)\n+        t.start()\n+\n+    def __refresh_token_worker(self) -> None:\n+        \"\"\" Keep refreshing token to prevent it from expiring. \"\"\"\n+        while True:\n+            # get the time until the token expires\n+            expiry_time = jwt.decode(\n+                self.token, options={\"verify_signature\": False})[\"exp\"]\n+            time_until_expiry = expiry_time - time.time()\n+            if time_until_expiry < REFRESH_BEFORE_EXPIRES_SECONDS:\n+                self.refresh_token()\n+            else:\n+                time.sleep(\n+                    int(time_until_expiry - REFRESH_BEFORE_EXPIRES_SECONDS + 1)\n+                )\n+\n     def request_token_for_container(self, task_id: int, image: str):\n         \"\"\" Request a container-token at the central server.\n "
        },
        {
          "filename": "vantage6-server/vantage6/server/__init__.py",
          "status": "modified",
          "additions": 78,
          "deletions": 8,
          "patch": "@@ -36,13 +36,15 @@\n from vantage6.server.permission import RuleNeed, PermissionManager\n from vantage6.server.globals import (\n     APPNAME,\n-    JWT_ACCESS_TOKEN_EXPIRES,\n+    ACCESS_TOKEN_EXPIRES_HOURS,\n     JWT_TEST_ACCESS_TOKEN_EXPIRES,\n     RESOURCES,\n     SUPER_USER_INFO,\n-    REFRESH_TOKENS_EXPIRE,\n+    REFRESH_TOKENS_EXPIRE_HOURS,\n     DEFAULT_SUPPORT_EMAIL_ADDRESS,\n-    MAX_RESPONSE_TIME_PING\n+    MAX_RESPONSE_TIME_PING,\n+    MIN_TOKEN_VALIDITY_SECONDS,\n+    MIN_REFRESH_TOKEN_EXPIRY_DELTA,\n )\n from vantage6.server.resource.common.swagger_templates import swagger_template\n from vantage6.server._version import __version__\n@@ -145,7 +147,7 @@ def setup_socket_connection(self):\n \n     @staticmethod\n     def configure_logging():\n-        \"\"\"Turn 3rd party loggers off.\"\"\"\n+        \"\"\"Set third party loggers to a warning level\"\"\"\n \n         # Prevent logging from urllib3\n         logging.getLogger(\"urllib3\").setLevel(logging.WARNING)\n@@ -165,9 +167,6 @@ def configure_flask(self):\n         # patch where to obtain token\n         self.app.config['JWT_AUTH_URL_RULE'] = '/api/token'\n \n-        # False means refresh tokens never expire\n-        self.app.config['JWT_REFRESH_TOKEN_EXPIRES'] = REFRESH_TOKENS_EXPIRE\n-\n         # If no secret is set in the config file, one is generated. This\n         # implies that all (even refresh) tokens will be invalidated on restart\n         self.app.config['JWT_SECRET_KEY'] = self.ctx.config.get(\n@@ -176,7 +175,20 @@ def configure_flask(self):\n         )\n \n         # Default expiration time\n-        self.app.config['JWT_ACCESS_TOKEN_EXPIRES'] = JWT_ACCESS_TOKEN_EXPIRES\n+        token_expiry_seconds = self._get_jwt_expiration_seconds(\n+            config_key='token_expires_hours',\n+            default_hours=ACCESS_TOKEN_EXPIRES_HOURS\n+        )\n+        self.app.config['JWT_ACCESS_TOKEN_EXPIRES'] = token_expiry_seconds\n+\n+        # Set refresh token expiration time\n+        self.app.config['JWT_REFRESH_TOKEN_EXPIRES'] = \\\n+                self._get_jwt_expiration_seconds(\n+            config_key='refresh_token_expires_hours',\n+            default_hours=REFRESH_TOKENS_EXPIRE_HOURS,\n+            longer_than=token_expiry_seconds + MIN_REFRESH_TOKEN_EXPIRY_DELTA,\n+            is_refresh=True\n+        )\n \n         # Set an extra long expiration time on access tokens for testing\n         # TODO: this does not seem needed...\n@@ -284,6 +296,64 @@ def static_from_root():\n             return send_from_directory(self.app.static_folder,\n                                        request.path[1:])\n \n+\n+    def _get_jwt_expiration_seconds(\n+        self, config_key: str, default_hours: int,\n+        longer_than: int = MIN_TOKEN_VALIDITY_SECONDS,\n+        is_refresh: bool = False\n+    ) -> int:\n+        \"\"\"\n+        Return the expiration time for JWT tokens.\n+\n+        This time may be specified in the config file. If it is not, the\n+        default value is returned.\n+\n+        Parameters\n+        ----------\n+        config_key: str\n+            The config key to look for that sets the expiration time\n+        default_hours: int\n+            The default expiration time in hours\n+        longer_than: int\n+            The minimum expiration time in hours.\n+        is_refresh: bool\n+            If True, the expiration time is for a refresh token. If False, it\n+            is for an access token.\n+\n+        Returns\n+        -------\n+        int:\n+            The JWT token expiration time in seconds\n+        \"\"\"\n+        hours_expire = self.ctx.config.get(config_key)\n+        if hours_expire is None:\n+            # No value is present in the config file, use default\n+            refresh_expire = int(float(default_hours) * 3600)\n+        elif isinstance(hours_expire, (int, float)) or \\\n+                hours_expire.is_numeric():\n+            # Numeric value is present in the config file\n+            refresh_expire = int(float(hours_expire) * 3600)\n+            if refresh_expire < longer_than:\n+                log.warning(\n+                    f\"Invalid value for '{config_key}': {hours_expire}. Tokens\"\n+                    f\" must be valid for at least {longer_than} seconds. Using\"\n+                    f\" default value: {REFRESH_TOKENS_EXPIRE_HOURS} hours\")\n+                if is_refresh:\n+                    log.warning(\"Note that refresh tokens should be valid at \"\n+                                f\"least {MIN_REFRESH_TOKEN_EXPIRY_DELTA} \"\n+                                \"seconds longer than access tokens.\")\n+                refresh_expire = int(float(REFRESH_TOKENS_EXPIRE_HOURS) * 3600)\n+        else:\n+            # Non-numeric value is present in the config file. Warn and use\n+            # default\n+            log.warning(\"Invalid value for 'refresh_token_expires_hours':\"\n+                        f\" {hours_expire}. Using default value: \"\n+                        f\"{REFRESH_TOKENS_EXPIRE_HOURS} hours\")\n+            refresh_expire = int(float(REFRESH_TOKENS_EXPIRE_HOURS) * 3600)\n+\n+        return refresh_expire\n+\n+\n     def configure_api(self):\n         \"\"\"\"Define global API output.\"\"\"\n "
        },
        {
          "filename": "vantage6-server/vantage6/server/globals.py",
          "status": "modified",
          "additions": 11,
          "deletions": 4,
          "patch": "@@ -16,7 +16,10 @@\n #\n \n # Expiretime of JWT tokens\n-JWT_ACCESS_TOKEN_EXPIRES = datetime.timedelta(hours=6)\n+ACCESS_TOKEN_EXPIRES_HOURS = datetime.timedelta(hours=6)\n+\n+# minimum validity of JWT Tokens in seconds\n+MIN_TOKEN_VALIDITY_SECONDS = 1800\n \n # Expiretime of JWT token in a test environment\n JWT_TEST_ACCESS_TOKEN_EXPIRES = datetime.timedelta(days=1)\n@@ -34,9 +37,13 @@\n     \"password\": \"root\"\n }\n \n-# Whenever the refresh tokens should expire. Note that setting this to true\n-# would mean that nodes will disconnect after some time\n-REFRESH_TOKENS_EXPIRE = False\n+# Expiration time of refresh tokens\n+REFRESH_TOKENS_EXPIRE_HOURS = 48\n+\n+# Minimum time in seconds that a refresh token must be valid *longer than* the\n+# access token. This is to prevent the access token from expiring before the\n+# refresh token.\n+MIN_REFRESH_TOKEN_EXPIRY_DELTA = 1\n \n # default support email address\n DEFAULT_SUPPORT_EMAIL_ADDRESS = 'support@vantage6.ai'"
        },
        {
          "filename": "vantage6-server/vantage6/server/resource/token.py",
          "status": "modified",
          "additions": 31,
          "deletions": 21,
          "patch": "@@ -14,6 +14,7 @@\n     create_refresh_token,\n     get_jwt_identity\n )\n+from flask_restful import Api\n from http import HTTPStatus\n \n from vantage6 import server\n@@ -152,18 +153,10 @@ def post(self):\n                                \"incorrect!\"\n                     }, HTTPStatus.UNAUTHORIZED\n \n-        token = create_access_token(user)\n-\n-        ret = {\n-            'access_token': token,\n-            'refresh_token': create_refresh_token(user),\n-            'user_url': self.api.url_for(server.resource.user.User,\n-                                         id=user.id),\n-            'refresh_url': self.api.url_for(RefreshToken),\n-        }\n+        token = _get_token_dict(user, self.api)\n \n         log.info(f\"Succesfull login from {username}\")\n-        return ret, HTTPStatus.OK, {'jwt-token': token}\n+        return token, HTTPStatus.OK, {'jwt-token': token['access_token']}\n \n     def user_login(self, username: str, password: str) -> Union[dict, db.User]:\n         \"\"\"Returns user a message in case of failed login attempt.\"\"\"\n@@ -292,17 +285,10 @@ def post(self):\n             return {\"msg\": \"Api key is not recognized!\"}, \\\n                 HTTPStatus.UNAUTHORIZED\n \n-        token = create_access_token(node)\n-        ret = {\n-            'access_token': token,\n-            'refresh_token': create_refresh_token(node),\n-            'node_url': self.api.url_for(server.resource.node.Node,\n-                                         id=node.id),\n-            'refresh_url': self.api.url_for(RefreshToken),\n-        }\n+        token = _get_token_dict(node, self.api)\n \n         log.info(f\"Succesfull login as node '{node.id}' ({node.name})\")\n-        return ret, HTTPStatus.OK, {'jwt-token': token}\n+        return token, HTTPStatus.OK, {'jwt-token': token['access_token']}\n \n \n class ContainerToken(ServicesResources):\n@@ -412,6 +398,30 @@ def post(self):\n         user_or_node_id = get_jwt_identity()\n         log.info(f'Refreshing token for user or node \"{user_or_node_id}\"')\n         user_or_node = db.Authenticatable.get(user_or_node_id)\n-        ret = {'access_token': create_access_token(user_or_node)}\n \n-        return ret, HTTPStatus.OK\n+        return _get_token_dict(user_or_node, self.api), HTTPStatus.OK\n+\n+\n+def _get_token_dict(user_or_node: db.Authenticatable, api: Api) -> dict:\n+    \"\"\"\n+    Create a dictionary with the tokens and urls for the user or node.\n+\n+    Parameters\n+    ----------\n+    user_or_node : db.Authenticatable\n+        The user or node to create the tokens for.\n+    api : Api\n+        The api to create the urls for.\n+    \"\"\"\n+    token_dict = {\n+        'access_token': create_access_token(user_or_node),\n+        'refresh_token': create_refresh_token(user_or_node),\n+        'refresh_url': api.url_for(RefreshToken),\n+    }\n+    if isinstance(user_or_node, db.User):\n+        token_dict['user_url'] = api.url_for(server.resource.user.User,\n+                                             id=user_or_node.id)\n+    else:\n+        token_dict['node_url'] = api.url_for(server.resource.node.Node,\n+                                             id=user_or_node.id)\n+    return token_dict"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7e08264dea67e84b35594893953001e8ea147d90",
            "date": "2025-01-09T16:31:08Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "c30ae94a7a4e5fda8eee9a937b26ff46c029109d",
            "date": "2024-12-13T09:10:55Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "7467646f458f773d0ee6aae6803682e1752a13f7",
            "date": "2024-12-13T08:54:45Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "4100ab5536ed2a5c675d6593cbebd8d98b4e5e14",
            "date": "2024-12-13T08:30:46Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "943a486a2e61185642fa75a0f55d24b776048838",
            "date": "2024-12-13T08:21:53Z",
            "author_login": "invalid-email-address"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-613",
    "description": "vantage6 is a privacy preserving federated learning infrastructure for secure insight exchange. Currently, the refresh token is valid indefinitely. The refresh token should get a validity of 24-48 hours. A fix was released in version 3.8.0.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-04T00:15:15.380",
    "last_modified": "2024-11-21T07:47:07.297",
    "fix_date": "2023-02-28T11:04:24Z"
  },
  "references": [
    {
      "url": "https://github.com/vantage6/vantage6/commit/48ebfca42359e9a6743e9598684585e2522cdce8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-4w59-c3gc-rrhp",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/commit/48ebfca42359e9a6743e9598684585e2522cdce8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-4w59-c3gc-rrhp",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.802561",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vantage6",
    "owner": "vantage6",
    "created_at": "2022-05-16T12:09:26Z",
    "updated_at": "2025-01-09T16:31:14Z",
    "pushed_at": "2025-01-14T13:14:06Z",
    "size": 44880,
    "stars": 31,
    "forks": 11,
    "open_issues": 248,
    "watchers": 31,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 1919355,
      "TypeScript": 526976,
      "HTML": 209327,
      "SCSS": 20209,
      "Makefile": 12871,
      "Dockerfile": 9054,
      "Jinja": 5974,
      "Shell": 4282,
      "JavaScript": 802
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:50:50.846103"
  }
}