{
  "cve_id": "CVE-2023-23930",
  "github_data": {
    "repository": "vantage6/vantage6",
    "fix_commit": "e62f03bacf2247bd59eed217e2e7338c3a01a5f0",
    "related_commits": [
      "e62f03bacf2247bd59eed217e2e7338c3a01a5f0",
      "e62f03bacf2247bd59eed217e2e7338c3a01a5f0"
    ],
    "patch_url": "https://github.com/vantage6/vantage6/commit/e62f03bacf2247bd59eed217e2e7338c3a01a5f0.patch",
    "fix_commit_details": {
      "sha": "e62f03bacf2247bd59eed217e2e7338c3a01a5f0",
      "commit_date": "2023-06-12T09:30:38Z",
      "author": {
        "login": "frankcorneliusmartin",
        "type": "User",
        "stats": {
          "total_commits": 2143,
          "average_weekly_commits": 5.23960880195599,
          "total_additions": 249317,
          "total_deletions": 1270399,
          "weeks_active": 185
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-5m22-cfq9-86x6",
        "length": 90,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 620,
        "additions": 91,
        "deletions": 529
      },
      "files": [
        {
          "filename": "docs/algorithms/classic_tutorial.rst",
          "status": "modified",
          "additions": 0,
          "deletions": 26,
          "patch": "@@ -519,29 +519,3 @@ address (harbor2.vantage6.ai) and the project name (demo).\n .. note::\n     Reach out to us on `Discord <https://discord.gg/yAyFf6Y>`__ if you want to\n     use our registries (harbor.vantage6.ai and harbor2.vantage6.ai).\n-\n-Cross-language serialization\n-----------------------------\n-\n-It is possible that a vantage6 algorithm is developed in one programming\n-language, but you would like to run the task from another language. For\n-these use-cases, the Python algorithm wrapper and client support\n-cross-language serialization. By default, input to the algorithms and\n-output back to the client are serialized using pickle. However, it is\n-possible to define a different serialization format.\n-\n-Input and output serialization can be specified as follows:\n-\n-.. code:: python\n-\n-   client.post_task(\n-       name='mytask',\n-       image='harbor2.vantage6.ai/testing/v6-test-py',\n-       collaboration_id=COLLABORATION_ID,\n-       organization_ids=ORGANIZATION_IDS,\n-       data_format='json', # Specify input format to the algorithm\n-       input_={\n-           'method': 'column_names',\n-           'kwargs': {'data_format': 'json'}, # Specify output format\n-       }\n-   )"
        },
        {
          "filename": "docs/user/pyclient.rst",
          "status": "modified",
          "additions": 2,
          "deletions": 6,
          "patch": "@@ -85,8 +85,6 @@ new user:\n    #        Human readable description\n    #    input : dict\n    #        Algorithm input\n-   #    data_format : str, optional\n-   #        IO data format used, by default LEGACY\n    #    database: str, optional\n    #        Name of the database to use. This should match the key\n    #        in the node configuration files. If not specified the\n@@ -396,8 +394,7 @@ us create a task that runs the master algorithm of the\n                                      name=\"an-awesome-task\",\n                                      image=\"harbor2.vantage6.ai/demo/average\",\n                                      description='',\n-                                     input=input_,\n-                                     data_format='json')\n+                                     input=input_)\n \n Note that the ``kwargs`` we specified in the ``input_`` are specific to\n this algorithm: this algorithm expects an argument ``column_name`` to be\n@@ -431,8 +428,7 @@ master algorithm will normally do:\n                                      name=\"an-awesome-task\",\n                                      image=\"harbor2.vantage6.ai/demo/average\",\n                                      description='',\n-                                     input=input_,\n-                                     data_format='json')\n+                                     input=input_)\n \n **Inspecting the results**\n "
        },
        {
          "filename": "vantage6-client/tests/test_client.py",
          "status": "modified",
          "additions": 12,
          "deletions": 37,
          "patch": "@@ -1,6 +1,6 @@\n import base64\n import json\n-import pickle\n+\n from unittest import TestCase\n from unittest.mock import patch, MagicMock\n \n@@ -26,48 +26,20 @@\n \n class TestClient(TestCase):\n \n-    def test_post_task_legacy_method(self):\n-        post_input = TestClient.post_task_on_mock_client(SAMPLE_INPUT, 'legacy')\n-        decoded_input = base64.b64decode(post_input)\n-        decoded_input = pickle.loads(decoded_input)\n-        assert {'method': 'test-task'} == decoded_input\n-\n-    def test_post_json_task(self):\n-        post_input = TestClient.post_task_on_mock_client(SAMPLE_INPUT, 'json')\n-        decoded_input = base64.b64decode(post_input)\n-        assert b'json.{\"method\": \"test-task\"}' == decoded_input\n-\n-    def test_post_pickle_task(self):\n-        post_input = TestClient.post_task_on_mock_client(SAMPLE_INPUT, 'pickle')\n+    def test_post_task(self):\n+        post_input = TestClient.post_task_on_mock_client(SAMPLE_INPUT)\n         decoded_input = base64.b64decode(post_input)\n+        assert b'{\"method\": \"test-task\"}' == decoded_input\n \n-        assert b'pickle.' == decoded_input[0:7]\n-\n-        assert {'method': 'test-task'} == pickle.loads(decoded_input[7:])\n-\n-    def test_get_legacy_results(self):\n-        mock_result = pickle.dumps(1)\n-\n-        results = TestClient._receive_results_on_mock_client(mock_result)\n-\n-        assert results == [{'result': 1}]\n-\n-    def test_get_json_results(self):\n-        mock_result = b'json.' + json.dumps({'some_key': 'some_value'}).encode()\n+    def test_get_results(self):\n+        mock_result = json.dumps({'some_key': 'some_value'}).encode()\n \n         results = TestClient._receive_results_on_mock_client(mock_result)\n \n         assert results == [{'result': {'some_key': 'some_value'}}]\n \n-    def test_get_pickle_results(self):\n-        mock_result = b'pickle.' + pickle.dumps([1, 2, 3, 4, 5])\n-\n-        results = TestClient._receive_results_on_mock_client(mock_result)\n-\n-        assert results == [{'result': [1, 2, 3, 4, 5]}]\n-\n     @staticmethod\n-    def post_task_on_mock_client(input_, serialization: str) -> dict[str, any]:\n+    def post_task_on_mock_client(input_) -> dict[str, any]:\n         mock_requests = MagicMock()\n         mock_requests.get.return_value.status_code = 200\n         mock_requests.post.return_value.status_code = 200\n@@ -76,8 +48,11 @@ def post_task_on_mock_client(input_, serialization: str) -> dict[str, any]:\n         with patch.multiple('vantage6.client', requests=mock_requests, jwt=mock_jwt):\n             client = TestClient.setup_client()\n \n-            client.post_task(name=TASK_NAME, image=TASK_IMAGE, collaboration_id=COLLABORATION_ID,\n-                             organization_ids=ORGANIZATION_IDS, input_=input_, data_format=serialization)\n+            client.post_task(\n+                name=TASK_NAME, image=TASK_IMAGE,\n+                collaboration_id=COLLABORATION_ID,\n+                organization_ids=ORGANIZATION_IDS, input_=input_\n+            )\n \n             # In a request.post call, json is provided with the keyword argument 'json'\n             # call_args provides a tuple with positional arguments followed by a dict with positional arguments"
        },
        {
          "filename": "vantage6-client/tests/test_deserialization.py",
          "status": "modified",
          "additions": 1,
          "deletions": 16,
          "patch": "@@ -1,7 +1,5 @@\n-import pickle\n from pathlib import Path\n from vantage6.tools import deserialization\n-from vantage6.tools.data_format import DataFormat\n \n SIMPLE_TARGET_DATA = {'key': 'value'}\n \n@@ -12,19 +10,6 @@ def test_deserialize_json(tmp_path: Path):\n     json_path.write_text(data)\n \n     with json_path.open('r') as f:\n-        result = deserialization.deserialize(f, DataFormat.JSON)\n+        result = deserialization.deserialize(f)\n \n         assert SIMPLE_TARGET_DATA == result\n-\n-\n-def test_deserialize_pickle(tmp_path: Path):\n-    data = {'key': 'value'}\n-\n-    pickle_path = tmp_path / 'picklefile.pkl'\n-\n-    with pickle_path.open('wb') as f:\n-        pickle.dump(data, f)\n-\n-    with pickle_path.open('rb') as f:\n-        result = deserialization.deserialize(f, DataFormat.PICKLE)\n-        assert SIMPLE_TARGET_DATA == result"
        },
        {
          "filename": "vantage6-client/tests/test_docker_wrapper.py",
          "status": "modified",
          "additions": 29,
          "deletions": 90,
          "patch": "@@ -1,13 +1,10 @@\n import json\n-import pickle\n from pathlib import Path\n from unittest.mock import patch, MagicMock\n \n import pandas as pd\n-from pytest import raises\n \n from vantage6.tools import wrapper\n-from vantage6.tools.exceptions import DeserializationException\n \n MODULE_NAME = 'algorithm_module'\n DATA = 'column1,column2\\n1,2'\n@@ -16,107 +13,49 @@\n JSON_FORMAT = 'json'\n SEPARATOR = '.'\n SAMPLE_DB = pd.DataFrame([[1, 2]], columns=['column1', 'column2'])\n-PICKLE_FORMAT = 'pickle'\n \n MOCK_SPARQL_ENDPOINT = 'sparql://some_triplestore'\n \n \n-def test_old_pickle_input_wrapper(tmp_path):\n-    \"\"\"\n-    Testing if wrapper still parses legacy input.\n-    \"\"\"\n-    input_file = tmp_path / 'input.pkl'\n-\n-    with input_file.open('wb') as f:\n-        pickle.dump(INPUT_PARAMETERS, f)\n+# def test_json_input_without_format_raises_deserializationexception(tmp_path):\n+#     \"\"\"\n+#     It should only be possible to provide json input if it is preceded by the\n+#     string \"json.\" in unicode. Otherwise a `DeserializationException` should\n+#     be thrown.\n+#     \"\"\"\n+#     input_file = tmp_path / 'input.json'\n \n-    output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n-    assert file_echoes_db(output_file)\n+#     with input_file.open('wb') as f:\n+#         f.write(json.dumps(INPUT_PARAMETERS).encode())\n \n+#     with raises(DeserializationException):\n+#         run_docker_wrapper_with_echo_db(input_file, tmp_path)\n \n-def test_json_input_without_format_raises_deserializationexception(tmp_path):\n-    \"\"\"\n-    It should only be possible to provide json input if it is preceded by the\n-    string \"json.\" in unicode. Otherwise a `DeserializationException` should\n-    be thrown.\n-    \"\"\"\n-    input_file = tmp_path / 'input.json'\n-\n-    with input_file.open('wb') as f:\n-        f.write(json.dumps(INPUT_PARAMETERS).encode())\n-\n-    with raises(DeserializationException):\n-        run_docker_wrapper_with_echo_db(input_file, tmp_path)\n-\n-\n-def test_json_input_with_format_succeeds(tmp_path):\n-    input_file = tmp_path / 'input.txt'\n-\n-    with input_file.open('wb') as f:\n-        f.write(f'JSON{SEPARATOR}'.encode())\n-        f.write(json.dumps(INPUT_PARAMETERS).encode())\n \n-    output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n-    assert file_echoes_db(output_file)\n+# def test_json_input_with_format_succeeds(tmp_path):\n+#     input_file = tmp_path / 'input.txt'\n \n+#     with input_file.open('wb') as f:\n+#         f.write(json.dumps(INPUT_PARAMETERS).encode())\n \n-def test_pickle_input_with_format_succeeds(tmp_path):\n-    input_file = create_pickle_input(tmp_path)\n-    output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n-    assert file_echoes_db(output_file)\n+#     output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n+#     assert file_echoes_db(output_file)\n \n \n-def test_wrapper_serializes_pickle_output(tmp_path):\n-    input_parameters = {\n-        'method': 'hello_world',\n-        'output_format': PICKLE_FORMAT\n-    }\n-    input_file = create_pickle_input(tmp_path, input_parameters)\n-\n-    output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n-\n-    with output_file.open('rb') as f:\n-        # Check whether the output starts with `pickle.` to indicate the pickle\n-        # data format\n-        assert f.read(len(PICKLE_FORMAT) + 1).decode() == f'{PICKLE_FORMAT}.'\n-\n-        result = pickle.loads(f.read())\n-        pd.testing.assert_frame_equal(SAMPLE_DB, result)\n-\n-\n-def test_wrapper_serializes_json_output(tmp_path):\n-    input_parameters = {'method': 'hello_world', 'output_format': JSON_FORMAT}\n-    input_file = create_pickle_input(tmp_path, input_parameters)\n-\n-    output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n-\n-    with output_file.open('rb') as f:\n-        # Check whether the data is preceded by json format string\n-        assert f.read(len(JSON_FORMAT) + 1).decode() == f'{JSON_FORMAT}.'\n-\n-        # Since the echo_db algorithm was triggered, output will be table that\n-        # can be read by pandas.\n-        result = pd.read_json(f.read())\n-        pd.testing.assert_frame_equal(SAMPLE_DB, result)\n-\n-\n-def create_pickle_input(tmp_path, input_parameters=None):\n-    if input_parameters is None:\n-        input_parameters = INPUT_PARAMETERS\n-\n-    input_file = tmp_path / 'input.pkl'\n-    with input_file.open('wb') as f:\n-        f.write(f'PICKLE{SEPARATOR}'.encode())\n-        f.write(pickle.dumps(input_parameters))\n-    return input_file\n+# def test_wrapper_serializes_json_output(tmp_path):\n+#     input_parameters = {'method': 'hello_world', 'output_format': JSON_FORMAT}\n+#     input_file = create_pickle_input(tmp_path, input_parameters)\n \n+#     output_file = run_docker_wrapper_with_echo_db(input_file, tmp_path)\n \n-def file_echoes_db(output_file):\n-    with output_file.open('rb') as f:\n-        result = pickle.load(f)\n-        target = SAMPLE_DB\n+#     with output_file.open('rb') as f:\n+#         # Check whether the data is preceded by json format string\n+#         assert f.read(len(JSON_FORMAT) + 1).decode() == f'{JSON_FORMAT}.'\n \n-        return target.equals(result)\n+#         # Since the echo_db algorithm was triggered, output will be table that\n+#         # can be read by pandas.\n+#         result = pd.read_json(f.read())\n+#         pd.testing.assert_frame_equal(SAMPLE_DB, result)\n \n \n def run_docker_wrapper_with_echo_db(input_file, tmp_path):\n@@ -169,7 +108,7 @@ def test_sparql_docker_wrapper_passes_dataframe(\n     input_args = {'query': 'select *'}\n \n     with input_file.open('wb') as f:\n-        pickle.dump(input_args, f)\n+        json.dumps(input_args, f)\n \n     with token_file.open('w') as f:\n         f.write(TOKEN)"
        },
        {
          "filename": "vantage6-client/tests/test_serialization.py",
          "status": "modified",
          "additions": 3,
          "deletions": 26,
          "patch": "@@ -1,14 +1,8 @@\n-import pickle\n-\n from pytest import mark\n \n from vantage6.tools import serialization\n import pandas as pd\n \n-from vantage6.tools.data_format import DataFormat\n-\n-JSON = 'json'\n-\n \n @mark.parametrize(\"data,target\", [\n     # Default serialization\n@@ -17,28 +11,11 @@\n     ({'hello': 'goodbye'}, '{\"hello\": \"goodbye\"}'),\n \n     # Pandas serialization\n-    (pd.DataFrame([[1, 2, 3]], columns=['one', 'two', 'three']), '{\"one\":{\"0\":1},\"two\":{\"0\":2},\"three\":{\"0\":3}}'),\n+    (pd.DataFrame([[1, 2, 3]], columns=['one', 'two', 'three']),\n+     '{\"one\":{\"0\":1},\"two\":{\"0\":2},\"three\":{\"0\":3}}'),\n     (pd.Series([1, 2, 3]), '{\"0\":1,\"1\":2,\"2\":3}')\n ])\n def test_json_serialization(data, target):\n-    result = serialization.serialize(data, DataFormat.JSON)\n+    result = serialization.serialize(data)\n \n     assert target == result.decode()\n-\n-\n-@mark.parametrize(\"data\", [\n-    ({'key': 'value'}),\n-    (123),\n-    ([1, 2, 3]),\n-])\n-def test_pickle_serialization(data):\n-    pickled = serialization.serialize(data, DataFormat.PICKLE)\n-\n-    assert data == pickle.loads(pickled)\n-\n-\n-def test_pickle_serialization_pandas():\n-    data = pd.DataFrame([1, 2, 3])\n-    pickled = serialization.serialize(data, DataFormat.PICKLE)\n-\n-    pd.testing.assert_frame_equal(data, pickle.loads(pickled))"
        },
        {
          "filename": "vantage6-client/vantage6/client/__init__.py",
          "status": "modified",
          "additions": 12,
          "deletions": 32,
          "patch": "@@ -5,7 +5,6 @@\n client (client used by master algorithms) and the user client are derived.\n \"\"\"\n import logging\n-import pickle\n import time\n import typing\n import jwt\n@@ -23,7 +22,7 @@\n from vantage6.common.globals import APPNAME\n from vantage6.common.encryption import RSACryptor, DummyCryptor\n from vantage6.common import WhoAmI\n-from vantage6.client import serialization, deserialization\n+from vantage6.tools import serialization, deserialization\n from vantage6.client.filter import post_filtering\n from vantage6.client.utils import print_qr_code, LogLevel\n \n@@ -438,9 +437,8 @@ def refresh_token(self) -> None:\n     # TODO BvB 23-01-23 remove this method in v4+. It is only here for\n     # backwards compatibility\n     def post_task(self, name: str, image: str, collaboration_id: int,\n-                  input_='', description='',\n-                  organization_ids: list = None,\n-                  data_format=LEGACY, database: str = 'default') -> dict:\n+                  input_='', description='', organization_ids: list = None,\n+                  database: str = 'default') -> dict:\n         \"\"\"Post a new task at the server\n \n         It will also encrypt `input_` for each receiving organization.\n@@ -461,11 +459,6 @@ def post_task(self, name: str, image: str, collaboration_id: int,\n         organization_ids : list, optional\n             Ids of organizations (within the collaboration) that need to\n             execute this task, by default None\n-        data_format : str, optional\n-            Type of data format to use to send and receive\n-            data. possible values: 'json', 'pickle', 'legacy'. 'legacy'\n-            will use pickle serialization. Default is 'legacy'., by default\n-            LEGACY\n         database : str, optional\n             Database label to use for the task, by default 'default'\n \n@@ -484,13 +477,8 @@ def post_task(self, name: str, image: str, collaboration_id: int,\n         if organization_ids is None:\n             organization_ids = []\n \n-        if data_format == LEGACY:\n-            serialized_input = pickle.dumps(input_)\n-        else:\n-            # Data will be serialized to bytes in the specified data format.\n-            # It will be prepended with 'DATA_FORMAT.' in unicode.\n-            serialized_input = data_format.encode() + b'.' \\\n-                + serialization.serialize(input_, data_format)\n+        # Data will be serialized in JSON.\n+        serialized_input = serialization.serialize(input_)\n \n         organization_json_list = []\n         for org_id in organization_ids:\n@@ -1871,7 +1859,6 @@ def list(self, initiator: int = None, initiating_user: int = None,\n         @post_filtering(iterable=False)\n         def create(self, collaboration: int, organizations: list, name: str,\n                    image: str, description: str, input: dict,\n-                   data_format: str = LEGACY,\n                    database: str = 'default') -> dict:\n             \"\"\"Create a new task\n \n@@ -1890,8 +1877,6 @@ def create(self, collaboration: int, organizations: list, name: str,\n                 Human readable description\n             input : dict\n                 Algorithm input\n-            data_format : str, optional\n-                IO data format used, by default LEGACY\n             database: str, optional\n                 Database name to be used at the node\n \n@@ -1902,7 +1887,7 @@ def create(self, collaboration: int, organizations: list, name: str,\n             \"\"\"\n             return self.parent.post_task(name, image, collaboration, input,\n                                          description, organizations,\n-                                         data_format, database)\n+                                         database)\n \n         def delete(self, id_: int) -> dict:\n             \"\"\"Delete a task\n@@ -2242,18 +2227,13 @@ def get_results(self, task_id: int):\n         )\n \n         res = []\n-        # Encryption is not done at the client level for the container.\n-        # Although I am not completely sure that the format is always\n-        # a pickle.\n-        # for result in results:\n-        #     self._decrypt_result(result)\n-        #     res.append(result.get(\"result\"))\n-        #\n         try:\n-            res = [pickle.loads(base64s_to_bytes(result.get(\"result\")))\n-                   for result in results if result.get(\"result\")]\n+            res = [\n+                json_lib.loads(base64s_to_bytes(result.get(\"result\")).decode())\n+                for result in results if result.get(\"result\")\n+            ]\n         except Exception as e:\n-            self.log.error('Unable to unpickle result')\n+            self.log.error('Unable to load results')\n             self.log.debug(e)\n \n         return res\n@@ -2351,7 +2331,7 @@ def post_task(self, name: str, image: str, collaboration_id: int,\n         \"\"\"\n         self.log.debug(\"post task without encryption (is handled by proxy)\")\n \n-        serialized_input = bytes_to_base64s(pickle.dumps(input_))\n+        serialized_input = bytes_to_base64s(serialization.serialize(input_))\n \n         organization_json_list = []\n         for org_id in organization_ids:"
        },
        {
          "filename": "vantage6-client/vantage6/client/deserialization.py",
          "status": "removed",
          "additions": 0,
          "deletions": 115,
          "patch": "@@ -1,115 +0,0 @@\n-\"\"\"\n-Module for deserialization of algorithm results.\n-\n-TODO: Merge with `vantage6.tools.deserialization` in `vantage6-toolkit` and move to `vantage6-common`\n-\"\"\"\n-\n-import json\n-import logging\n-import pickle\n-from .exceptions import DeserializationException\n-\n-_DATA_FORMAT_SEPARATOR = '.'\n-_MAX_FORMAT_STRING_LENGTH = 10\n-\n-logger = logging.getLogger(__name__)\n-\n-_deserializers = {}\n-\n-\n-def deserialize(file, data_format):\n-    \"\"\"\n-    Lookup data_format in deserializer mapping and return the associated\n-    :param file:\n-    :param data_format:\n-    :return:\n-    \"\"\"\n-    try:\n-        return _deserializers[data_format.lower()](file)\n-    except KeyError:\n-        raise Exception(f'Deserialization of {data_format} has not been implemented.')\n-\n-\n-def deserializer(data_format):\n-    \"\"\"\n-    Register function as deserializer by adding it to the `_deserializers` map with key `data_format`.\n-\n-    :param data_format:\n-    :return:\n-    \"\"\"\n-\n-    def decorator_deserializer(func):\n-        # Register deserialization function\n-        _deserializers[data_format] = func\n-\n-        # Return function without modifications so it can also be run without retrieving it from `_deserializers`.\n-        return func\n-\n-    return decorator_deserializer\n-\n-\n-@deserializer('json')\n-def deserialize_json(file):\n-    return json.loads(file)\n-\n-\n-@deserializer('pickle')\n-def deserialize_pickle(file):\n-    return pickle.loads(file)\n-\n-\n-def unpack_legacy_results(result):\n-    return pickle.loads(result.get(\"result\"))\n-\n-\n-def load_data(input_bytes: bytes):\n-    \"\"\"\n-    Try to read the specified data format and deserialize the rest of the stream accordingly. If this fails, assume\n-    the data format is pickle.\n-\n-    :param input_bytes:\n-    :return:\n-    \"\"\"\n-    try:\n-        input_data = _read_formatted(input_bytes)\n-    except DeserializationException:\n-        logger.info('No data format specified. Assuming input data is pickle format')\n-        try:\n-            input_data = pickle.loads(input_bytes)\n-        except pickle.UnpicklingError:\n-            raise DeserializationException('Could not deserialize input')\n-    return input_data\n-\n-\n-def _read_formatted(input_bytes):\n-    data_format = str.join('', list(_read_data_format(input_bytes)))\n-    return deserialize(input_bytes[len(data_format) + 1:], data_format)\n-\n-\n-def _read_data_format(input_bytes):\n-    \"\"\"\n-    Try to read the prescribed data format. The data format should be specified as follows: DATA_FORMAT.ACTUAL_BYTES.\n-    This function will attempt to read the string before the period. It will fail if the file is not in the right\n-    format.\n-\n-    :param input_bytes: Input file received from vantage infrastructure.\n-    :return:\n-    \"\"\"\n-    success = False\n-\n-    for i in range(_MAX_FORMAT_STRING_LENGTH):\n-        try:\n-            char = input_bytes[i:i+1].decode()\n-        except UnicodeDecodeError:\n-            # We aren't reading a unicode string\n-            raise DeserializationException('No data format specified')\n-\n-        if char == _DATA_FORMAT_SEPARATOR:\n-            success = True\n-            break\n-        else:\n-            yield char\n-\n-    if not success:\n-        # The file didn't have a format prepended\n-        raise DeserializationException('No data format specified')"
        },
        {
          "filename": "vantage6-client/vantage6/client/serialization.py",
          "status": "removed",
          "additions": 0,
          "deletions": 45,
          "patch": "@@ -1,45 +0,0 @@\n-import json\n-import pickle\n-\n-_serializers = {}\n-\n-\n-def serialize(data, data_format) -> bytes:\n-    \"\"\"\n-    Serialize data using the specified format\n-    :param data: the data to be serialized\n-    :param data_format: the desired data format. Valid options are 'json', 'pickle'.\n-    :return: a bytes-like object in the specified serialization format\n-    \"\"\"\n-    try:\n-        return _serializers[data_format.lower()](data)\n-    except KeyError:\n-        raise Exception(f'Serialization of {data_format} has not been implemented.')\n-\n-\n-def serializer(data_format):\n-    \"\"\"\n-    Register function as serializer by adding it to the `_serializers` map with key `data_format`.\n-\n-    :param data_format:\n-    :return:\n-    \"\"\"\n-\n-    def decorator_serializer(func):\n-        # Register deserialization function\n-        _serializers[data_format] = func\n-\n-        # Return function without modifications so it can also be run without retrieving it from `_serializers`.\n-        return func\n-\n-    return decorator_serializer\n-\n-\n-@serializer('json')\n-def serialize_json(file) -> bytes:\n-    return json.dumps(file).encode()\n-\n-\n-@serializer('pickle')\n-def serialize_pickle(file) -> bytes:\n-    return pickle.dumps(file)"
        },
        {
          "filename": "vantage6-client/vantage6/tools/data_format.py",
          "status": "removed",
          "additions": 0,
          "deletions": 16,
          "patch": "@@ -1,16 +0,0 @@\n-\"\"\"\n-Class DataFormat\n-\n-This Enum contains all the possible dataformats that can be used to serialize\n-or deserialize the data to and from the algorithm wrapper.\n-\n-When serialization to an additional data format is implemented it should be\n-added here.\n-\"\"\"\n-from enum import Enum\n-\n-\n-# TODO: Should ideally be shared with the client as well\n-class DataFormat(Enum):\n-    JSON = 'json'\n-    PICKLE = 'pickle'"
        },
        {
          "filename": "vantage6-client/vantage6/tools/deserialization.py",
          "status": "modified",
          "additions": 11,
          "deletions": 48,
          "patch": "@@ -1,56 +1,19 @@\n import json\n-import pickle\n+from typing import BinaryIO\n \n-from vantage6.tools.data_format import DataFormat\n \n-_deserializers = {}\n-\n-\n-def deserialize(file, data_format: DataFormat):\n-    \"\"\"\n-    Lookup data_format in deserializer mapping and return the associated\n-    function.\n-\n-    :param file:\n-    :param data_format:\n-    :return:\n-    \"\"\"\n-    try:\n-        return _deserializers[data_format](file)\n-    except KeyError:\n-        raise Exception(\n-            f'Deserialization of {data_format} has not been implemented.'\n-        )\n-\n-\n-def deserializer(data_format):\n+def deserialize(file: BinaryIO):\n     \"\"\"\n-    Register function as deserializer by adding it to the `_deserializers` map\n-    with key `data_format`.\n+    Deserialize data from a file using JSON\n \n-    These functions should receive a file-like as input and provide the data as\n-    output in the format specified with the decorator.\n+    Parameters\n+    ----------\n+    file: BinaryIO\n+        The file to deserialize the data from\n \n-    :param data_format:\n-    :return:\n+    Returns\n+    -------\n+    str\n+        The deserialized data\n     \"\"\"\n-\n-    def decorator_deserializer(func):\n-        # Register deserialization function\n-        _deserializers[data_format] = func\n-\n-        # Return function without modifications so it can also be run without\n-        # retrieving it from `_deserializers`.\n-        return func\n-\n-    return decorator_deserializer\n-\n-\n-@deserializer(DataFormat.JSON)\n-def deserialize_json(file):\n     return json.load(file)\n-\n-\n-@deserializer(DataFormat.PICKLE)\n-def deserialize_pickle(file):\n-    return pickle.load(file)"
        },
        {
          "filename": "vantage6-client/vantage6/tools/docker_wrapper.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -5,4 +5,4 @@\n     sparql_wrapper,\n     parquet_wrapper,\n     multidb_wrapper\n-)\n\\ No newline at end of file\n+)"
        },
        {
          "filename": "vantage6-client/vantage6/tools/mock_client.py",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -1,8 +1,10 @@\n import pandas\n-import pickle\n+import json\n \n from importlib import import_module\n \n+from vantage6.tools import serialization\n+\n \n class ClientMockProtocol:\n     \"\"\"\n@@ -78,7 +80,7 @@ def create_new_task(self, input_: dict,\n \n             idx = 999  # we dont need this now\n             results.append(\n-                {\"id\": idx, \"result\": pickle.dumps(result)}\n+                {\"id\": idx, \"result\": serialization.serialize(result)}\n             )\n \n         id_ = len(self.tasks)\n@@ -123,8 +125,7 @@ def get_results(self, task_id: int) -> list[dict]:\n         task = self.tasks[task_id]\n         results = []\n         for result in task.get(\"results\"):\n-            print(result)\n-            res = pickle.loads(result.get(\"result\"))\n+            res = json.loads(result.get(\"result\"))\n             results.append(res)\n \n         return results"
        },
        {
          "filename": "vantage6-client/vantage6/tools/serialization.py",
          "status": "modified",
          "additions": 12,
          "deletions": 65,
          "patch": "@@ -1,73 +1,20 @@\n import json\n-import pickle\n \n-import pandas as pd\n-from vantage6.tools.data_format import DataFormat\n-from vantage6.tools.util import info\n \n-_serializers = {}\n-\n-\n-def serialize(data, data_format: DataFormat):\n-    \"\"\"\n-    Look up serializer for `data_format` and use this to serialize `data`.\n-\n-    :param data:\n-    :param data_format:\n-    :return:\n+# TODO BvB 2023-02-03: I feel this function could be given a better name. And\n+# it might not have to be in a separate file.\n+def serialize(data: any) -> bytes:\n     \"\"\"\n-    return _serializers[data_format](data)\n+    Serialize data using the specified format\n \n+    Parameters\n+    ----------\n+    data: any\n+        The data to be serialized\n \n-def serializer(data_format: DataFormat):\n+    Returns\n+    -------\n+    bytes\n+        A JSON-serialized and then encoded bytes object representing the data\n     \"\"\"\n-    Register function as serializer by adding it to the `_serializers` map with\n-    key `data_format`. This function should ideally support a multitude of\n-    python objects.\n-\n-    There are two ways to extend serialization functionality:\n-\n-    1. Create and register a new serialization function for a previously\n-       unsupported serialization format.\n-    2. Implement support for additional objects within an existing serializer\n-       function.\n-\n-    :param data_format:\n-    :return:\n-    \"\"\"\n-\n-    def decorator_serializer(func):\n-        # Register serialization function\n-        _serializers[data_format] = func\n-\n-        # Return function without modifications so it can also be run without\n-        # retrieving it from `_serializers`.\n-        return func\n-\n-    return decorator_serializer\n-\n-\n-@serializer(DataFormat.JSON)\n-def serialize_to_json(data):\n-    info(f'Serializing type {type(data)} to json')\n-\n-    if isinstance(data, pd.DataFrame) | isinstance(data, pd.Series):\n-        return _serialize_pandas(data)\n-\n-    return _default_serialization(data)\n-\n-\n-def _default_serialization(data):\n-    info('Using default json serialization')\n     return json.dumps(data).encode()\n-\n-\n-def _serialize_pandas(data):\n-    info('Running pandas json serialization')\n-    return data.to_json().encode()\n-\n-\n-@serializer(DataFormat.PICKLE)\n-def serialize_to_pickle(data):\n-    info('Serializing to pickle')\n-    return pickle.dumps(data)"
        },
        {
          "filename": "vantage6-node/vantage6/node/docker/task_manager.py",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -2,7 +2,6 @@\n to be cleaned at some point. \"\"\"\n import logging\n import os\n-import pickle\n import docker.errors\n import json\n \n@@ -285,11 +284,13 @@ def _run_algorithm(self) -> list[dict]:\n             )\n \n         # try reading docker input\n+        # FIXME BvB 2023-02-03: why do we read docker input here? It is never\n+        # really used below. Should it?\n         deserialized_input = None\n         if self.docker_input:\n             self.log.debug(\"Deserialize input\")\n             try:\n-                deserialized_input = pickle.loads(self.docker_input)\n+                deserialized_input = json.loads(self.docker_input)\n             except Exception:\n                 pass\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7e08264dea67e84b35594893953001e8ea147d90",
            "date": "2025-01-09T16:31:08Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "c30ae94a7a4e5fda8eee9a937b26ff46c029109d",
            "date": "2024-12-13T09:10:55Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "7467646f458f773d0ee6aae6803682e1752a13f7",
            "date": "2024-12-13T08:54:45Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "4100ab5536ed2a5c675d6593cbebd8d98b4e5e14",
            "date": "2024-12-13T08:30:46Z",
            "author_login": "bartvanb"
          },
          {
            "sha": "943a486a2e61185642fa75a0f55d24b776048838",
            "date": "2024-12-13T08:21:53Z",
            "author_login": "invalid-email-address"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-502",
    "description": "vantage6 is privacy preserving federated learning infrastructure. Versions prior to 4.0.0 use pickle, which has known security issue, as a default serialization module but that has known security issues. All users of vantage6 that post tasks with the default serialization are affected. Version 4.0.0 contains a patch. Users may specify JSON serialization as a workaround.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-11T18:15:10.037",
    "last_modified": "2024-11-21T07:47:07.430",
    "fix_date": "2023-06-12T09:30:38Z"
  },
  "references": [
    {
      "url": "https://github.com/vantage6/vantage6/blob/0682c4288f43fee5bcc72dc448cdd99bd7e57f76/docs/release_notes.rst#400",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/commit/e62f03bacf2247bd59eed217e2e7338c3a01a5f0",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-5m22-cfq9-86x6",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://medium.com/ochrona/python-pickle-is-notoriously-insecure-d6651f1974c9",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Permissions Required",
        "Technical Description",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/blob/0682c4288f43fee5bcc72dc448cdd99bd7e57f76/docs/release_notes.rst#400",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/commit/e62f03bacf2247bd59eed217e2e7338c3a01a5f0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-5m22-cfq9-86x6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://medium.com/ochrona/python-pickle-is-notoriously-insecure-d6651f1974c9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Permissions Required",
        "Technical Description",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.592012",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vantage6",
    "owner": "vantage6",
    "created_at": "2022-05-16T12:09:26Z",
    "updated_at": "2025-01-09T16:31:14Z",
    "pushed_at": "2025-01-14T13:14:06Z",
    "size": 44880,
    "stars": 31,
    "forks": 11,
    "open_issues": 248,
    "watchers": 31,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 1919355,
      "TypeScript": 526976,
      "HTML": 209327,
      "SCSS": 20209,
      "Makefile": 12871,
      "Dockerfile": 9054,
      "Jinja": 5974,
      "Shell": 4282,
      "JavaScript": 802
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:50:50.846103"
  }
}