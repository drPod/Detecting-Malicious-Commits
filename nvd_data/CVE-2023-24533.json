{
  "cve_id": "CVE-2023-24533",
  "github_data": {
    "repository": "FiloSottile/nistec",
    "fix_commit": "c58aa1223ccf3943513e1e661cebce95af137244",
    "related_commits": [
      "c58aa1223ccf3943513e1e661cebce95af137244",
      "c58aa1223ccf3943513e1e661cebce95af137244"
    ],
    "patch_url": "https://github.com/FiloSottile/nistec/commit/c58aa1223ccf3943513e1e661cebce95af137244.patch",
    "fix_commit_details": {
      "sha": "c58aa1223ccf3943513e1e661cebce95af137244",
      "commit_date": "2023-02-13T14:16:27Z",
      "author": {
        "login": "FiloSottile",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "crypto/internal/nistec: reduce P-256 scalar",
        "length": 1139,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 99,
        "additions": 99,
        "deletions": 0
      },
      "files": [
        {
          "filename": "nistec_test.go",
          "status": "modified",
          "additions": 81,
          "deletions": 0,
          "patch": "@@ -7,6 +7,7 @@ package nistec_test\n import (\n \t\"bytes\"\n \t\"crypto/elliptic\"\n+\t\"fmt\"\n \t\"math/big\"\n \t\"math/rand\"\n \t\"testing\"\n@@ -163,6 +164,86 @@ func testEquivalents[P nistPoint[P]](t *testing.T, newPoint func() P, c elliptic\n \t}\n }\n \n+func TestScalarMult(t *testing.T) {\n+\tt.Run(\"P224\", func(t *testing.T) {\n+\t\ttestScalarMult(t, nistec.NewP224Point, elliptic.P224())\n+\t})\n+\tt.Run(\"P256\", func(t *testing.T) {\n+\t\ttestScalarMult(t, nistec.NewP256Point, elliptic.P256())\n+\t})\n+\tt.Run(\"P384\", func(t *testing.T) {\n+\t\ttestScalarMult(t, nistec.NewP384Point, elliptic.P384())\n+\t})\n+\tt.Run(\"P521\", func(t *testing.T) {\n+\t\ttestScalarMult(t, nistec.NewP521Point, elliptic.P521())\n+\t})\n+}\n+\n+func testScalarMult[P nistPoint[P]](t *testing.T, newPoint func() P, c elliptic.Curve) {\n+\tG := newPoint().SetGenerator()\n+\tcheckScalar := func(t *testing.T, scalar []byte) {\n+\t\tp1, err := newPoint().ScalarBaseMult(scalar)\n+\t\tfatalIfErr(t, err)\n+\t\tp2, err := newPoint().ScalarMult(G, scalar)\n+\t\tfatalIfErr(t, err)\n+\t\tif !bytes.Equal(p1.Bytes(), p2.Bytes()) {\n+\t\t\tt.Error(\"[k]G != ScalarBaseMult(k)\")\n+\t\t}\n+\n+\t\td := new(big.Int).SetBytes(scalar)\n+\t\td.Sub(c.Params().N, d)\n+\t\td.Mod(d, c.Params().N)\n+\t\tg1, err := newPoint().ScalarBaseMult(d.FillBytes(make([]byte, len(scalar))))\n+\t\tfatalIfErr(t, err)\n+\t\tg1.Add(g1, p1)\n+\t\tif !bytes.Equal(g1.Bytes(), newPoint().Bytes()) {\n+\t\t\tt.Error(\"[N - k]G + [k]G != \u221e\")\n+\t\t}\n+\t}\n+\n+\tbyteLen := len(c.Params().N.Bytes())\n+\tbitLen := c.Params().N.BitLen()\n+\tt.Run(\"0\", func(t *testing.T) { checkScalar(t, make([]byte, byteLen)) })\n+\tt.Run(\"1\", func(t *testing.T) {\n+\t\tcheckScalar(t, big.NewInt(1).FillBytes(make([]byte, byteLen)))\n+\t})\n+\tt.Run(\"N-1\", func(t *testing.T) {\n+\t\tcheckScalar(t, new(big.Int).Sub(c.Params().N, big.NewInt(1)).Bytes())\n+\t})\n+\tt.Run(\"N\", func(t *testing.T) { checkScalar(t, c.Params().N.Bytes()) })\n+\tt.Run(\"N+1\", func(t *testing.T) {\n+\t\tcheckScalar(t, new(big.Int).Add(c.Params().N, big.NewInt(1)).Bytes())\n+\t})\n+\tt.Run(\"all1s\", func(t *testing.T) {\n+\t\ts := new(big.Int).Lsh(big.NewInt(1), uint(bitLen))\n+\t\ts.Sub(s, big.NewInt(1))\n+\t\tcheckScalar(t, s.Bytes())\n+\t})\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < bitLen; i++ {\n+\t\tt.Run(fmt.Sprintf(\"1<<%d\", i), func(t *testing.T) {\n+\t\t\ts := new(big.Int).Lsh(big.NewInt(1), uint(i))\n+\t\t\tcheckScalar(t, s.FillBytes(make([]byte, byteLen)))\n+\t\t})\n+\t}\n+\t// Test N+1...N+32 since they risk overlapping with precomputed table values\n+\t// in the final additions.\n+\tfor i := int64(2); i <= 32; i++ {\n+\t\tt.Run(fmt.Sprintf(\"N+%d\", i), func(t *testing.T) {\n+\t\t\tcheckScalar(t, new(big.Int).Add(c.Params().N, big.NewInt(i)).Bytes())\n+\t\t})\n+\t}\n+}\n+\n+func fatalIfErr(t *testing.T, err error) {\n+\tt.Helper()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n func BenchmarkScalarMult(b *testing.B) {\n \tb.Run(\"P224\", func(b *testing.B) {\n \t\tbenchmarkScalarMult(b, nistec.NewP224Point().SetGenerator(), 28)"
        },
        {
          "filename": "p256_asm.go",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -364,6 +364,21 @@ func p256PointDoubleAsm(res, in *P256Point)\n // Montgomery domain (with R 2\u00b2\u2075\u2076) as four uint64 limbs in little-endian order.\n type p256OrdElement [4]uint64\n \n+// p256OrdReduce ensures s is in the range [0, ord(G)-1].\n+func p256OrdReduce(s *p256OrdElement) {\n+\t// Since 2 * ord(G) > 2\u00b2\u2075\u2076, we can just conditionally subtract ord(G),\n+\t// keeping the result if it doesn't underflow.\n+\tt0, b := bits.Sub64(s[0], 0xf3b9cac2fc632551, 0)\n+\tt1, b := bits.Sub64(s[1], 0xbce6faada7179e84, b)\n+\tt2, b := bits.Sub64(s[2], 0xffffffffffffffff, b)\n+\tt3, b := bits.Sub64(s[3], 0xffffffff00000000, b)\n+\ttMask := b - 1 // zero if subtraction underflowed\n+\ts[0] ^= (t0 ^ s[0]) & tMask\n+\ts[1] ^= (t1 ^ s[1]) & tMask\n+\ts[2] ^= (t2 ^ s[2]) & tMask\n+\ts[3] ^= (t3 ^ s[3]) & tMask\n+}\n+\n // Add sets q = p1 + p2, and returns q. The points may overlap.\n func (q *P256Point) Add(r1, r2 *P256Point) *P256Point {\n \tvar sum, double P256Point\n@@ -393,6 +408,7 @@ func (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error) {\n \t}\n \tscalarReversed := new(p256OrdElement)\n \tp256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))\n+\tp256OrdReduce(scalarReversed)\n \n \tr.p256BaseMult(scalarReversed)\n \treturn r, nil\n@@ -407,6 +423,7 @@ func (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)\n \t}\n \tscalarReversed := new(p256OrdElement)\n \tp256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))\n+\tp256OrdReduce(scalarReversed)\n \n \tr.Set(q).p256ScalarMult(scalarReversed)\n \treturn r, nil"
        },
        {
          "filename": "p256_ordinv.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ func p256OrdInverse(k []byte) ([]byte, error) {\n \n \tx := new(p256OrdElement)\n \tp256OrdBigToLittle(x, (*[32]byte)(k))\n+\tp256OrdReduce(x)\n \n \t// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.\n \t//"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "64718a545e3030023407a668dfee61340809ba0d",
            "date": "2023-08-29T14:58:19Z",
            "author_login": "FiloSottile"
          },
          {
            "sha": "4395cc3b44b2f71c196e2db646658e12cd29aa21",
            "date": "2023-06-12T16:38:51Z",
            "author_login": "FiloSottile"
          },
          {
            "sha": "165fbd7c672d26525f80778a253ea237f503d070",
            "date": "2023-04-11T18:54:46Z",
            "author_login": "ianlancetaylor"
          },
          {
            "sha": "5b0892cf02c5240444e246bb8fa2eb1dbeb84d8f",
            "date": "2023-03-23T18:18:19Z",
            "author_login": "prattmic"
          },
          {
            "sha": "da36eed264c27a8040846089d0dba67becb6e9bc",
            "date": "2023-02-13T19:49:38Z",
            "author_login": "FiloSottile"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-682",
    "description": "Multiplication of certain unreduced P-256 scalars produce incorrect results. There are no protocols known at this time that can be attacked due to this.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-08T20:15:09.497",
    "last_modified": "2024-11-21T07:48:04.520",
    "fix_date": "2023-02-13T14:16:27Z"
  },
  "references": [
    {
      "url": "https://github.com/FiloSottile/nistec/commit/c58aa1223ccf3943513e1e661cebce95af137244",
      "source": "security@golang.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://go.dev/issue/58647",
      "source": "security@golang.org",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://pkg.go.dev/vuln/GO-2023-1595",
      "source": "security@golang.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/FiloSottile/nistec/commit/c58aa1223ccf3943513e1e661cebce95af137244",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://go.dev/issue/58647",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://pkg.go.dev/vuln/GO-2023-1595",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.821755",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nistec",
    "owner": "FiloSottile",
    "created_at": "2022-05-09T18:28:11Z",
    "updated_at": "2024-12-16T08:25:20Z",
    "pushed_at": "2023-08-29T14:58:55Z",
    "size": 979,
    "stars": 48,
    "forks": 5,
    "open_issues": 0,
    "watchers": 48,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Assembly": 185775,
      "Go": 76113,
      "Dockerfile": 506
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T16:32:49.247096"
  }
}