{
  "cve_id": "CVE-2023-24824",
  "github_data": {
    "repository": "github/cmark-gfm",
    "fix_commit": "2300c1bd2c8226108885bf019655c4159cf26b59",
    "related_commits": [
      "2300c1bd2c8226108885bf019655c4159cf26b59",
      "2300c1bd2c8226108885bf019655c4159cf26b59"
    ],
    "patch_url": "https://github.com/github/cmark-gfm/commit/2300c1bd2c8226108885bf019655c4159cf26b59.patch",
    "fix_commit_details": {
      "sha": "2300c1bd2c8226108885bf019655c4159cf26b59",
      "commit_date": "2023-03-31T17:27:53Z",
      "author": {
        "login": "anticomputer",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-66g8-4hjf-77xh",
        "length": 92,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 224,
        "additions": 198,
        "deletions": 26
      },
      "files": [
        {
          "filename": "api_test/main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1133,6 +1133,7 @@ int main() {\n   int retval;\n   test_batch_runner *runner = test_batch_runner_new();\n \n+  cmark_enable_safety_checks(true);\n   version(runner);\n   constructor(runner);\n   accessors(runner);"
        },
        {
          "filename": "extensions/table.c",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -311,12 +311,18 @@ static cmark_node *try_opening_table_header(cmark_syntax_extension *self,\n     }\n   }\n \n+  assert(cmark_node_get_type(parent_container) == CMARK_NODE_PARAGRAPH);\n   if (!cmark_node_set_type(parent_container, CMARK_NODE_TABLE)) {\n     free_table_row(parser->mem, header_row);\n     free_table_row(parser->mem, marker_row);\n     return parent_container;\n   }\n \n+  // Update the node counts after parent_container changed type.\n+  assert(parent_container->next == NULL);\n+  decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);\n+  incr_open_block_count(parser, CMARK_NODE_TABLE);\n+\n   if (header_row->paragraph_offset) {\n     try_inserting_table_header_paragraph(parser, parent_container, (unsigned char *)parent_string,\n                                          header_row->paragraph_offset);"
        },
        {
          "filename": "src/blocks.c",
          "status": "modified",
          "additions": 107,
          "deletions": 12,
          "patch": "@@ -70,6 +70,22 @@ static void S_parser_feed(cmark_parser *parser, const unsigned char *buffer,\n static void S_process_line(cmark_parser *parser, const unsigned char *buffer,\n                            bufsize_t bytes);\n \n+static void subtract_open_block_counts(cmark_parser *parser, cmark_node *node) {\n+  do {\n+    decr_open_block_count(parser, S_type(node));\n+    node->flags &= ~CMARK_NODE__OPEN_BLOCK;\n+    node = node->last_child;\n+  } while (node);\n+}\n+\n+static void add_open_block_counts(cmark_parser *parser, cmark_node *node) {\n+  do {\n+    incr_open_block_count(parser, S_type(node));\n+    node->flags |= CMARK_NODE__OPEN_BLOCK;\n+    node = node->last_child;\n+  } while (node);\n+}\n+\n static cmark_node *make_block(cmark_mem *mem, cmark_node_type tag,\n                               int start_line, int start_column) {\n   cmark_node *e;\n@@ -129,6 +145,7 @@ static void cmark_parser_reset(cmark_parser *parser) {\n   parser->refmap = cmark_reference_map_new(parser->mem);\n   parser->root = document;\n   parser->current = document;\n+  add_open_block_counts(parser, document);\n \n   parser->syntax_extensions = saved_exts;\n   parser->inline_syntax_extensions = saved_inline_exts;\n@@ -242,15 +259,18 @@ static void remove_trailing_blank_lines(cmark_strbuf *ln) {\n // Check to see if a node ends with a blank line, descending\n // if needed into lists and sublists.\n static bool S_ends_with_blank_line(cmark_node *node) {\n-  if (S_last_line_checked(node)) {\n-    return(S_last_line_blank(node));\n-  } else if ((S_type(node) == CMARK_NODE_LIST ||\n-              S_type(node) == CMARK_NODE_ITEM) && node->last_child) {\n-    S_set_last_line_checked(node);\n-    return(S_ends_with_blank_line(node->last_child));\n-  } else {\n-    S_set_last_line_checked(node);\n-    return (S_last_line_blank(node));\n+  while (true) {\n+    if (S_last_line_checked(node)) {\n+      return(S_last_line_blank(node));\n+    } else if ((S_type(node) == CMARK_NODE_LIST ||\n+                S_type(node) == CMARK_NODE_ITEM) && node->last_child) {\n+      S_set_last_line_checked(node);\n+      node = node->last_child;\n+      continue;\n+    } else {\n+      S_set_last_line_checked(node);\n+      return (S_last_line_blank(node));\n+    }\n   }\n }\n \n@@ -310,6 +330,12 @@ static cmark_node *finalize(cmark_parser *parser, cmark_node *b) {\n     has_content = resolve_reference_link_definitions(parser, b);\n     if (!has_content) {\n       // remove blank node (former reference def)\n+      if (b->flags & CMARK_NODE__OPEN_BLOCK) {\n+        decr_open_block_count(parser, S_type(b));\n+        if (b->prev) {\n+          add_open_block_counts(parser, b->prev);\n+        }\n+      }\n       cmark_node_free(b);\n     }\n     break;\n@@ -382,6 +408,17 @@ static cmark_node *finalize(cmark_parser *parser, cmark_node *b) {\n   return parent;\n }\n \n+// Recalculates the number of open blocks. Returns true if it matches what's currently stored\n+// in parser. (Used to check that the counts in parser, which are updated incrementally, are\n+// correct.)\n+bool check_open_block_counts(cmark_parser *parser) {\n+  cmark_parser tmp_parser = {0}; // Only used for its open_block_counts and total_open_blocks fields.\n+  add_open_block_counts(&tmp_parser, parser->root);\n+  return\n+    tmp_parser.total_open_blocks == parser->total_open_blocks &&\n+    memcmp(tmp_parser.open_block_counts, parser->open_block_counts, sizeof(parser->open_block_counts)) == 0;\n+}\n+\n // Add a node as child of another.  Return pointer to child.\n static cmark_node *add_child(cmark_parser *parser, cmark_node *parent,\n                              cmark_node_type block_type, int start_column) {\n@@ -400,11 +437,14 @@ static cmark_node *add_child(cmark_parser *parser, cmark_node *parent,\n   if (parent->last_child) {\n     parent->last_child->next = child;\n     child->prev = parent->last_child;\n+    subtract_open_block_counts(parser, parent->last_child);\n   } else {\n     parent->first_child = child;\n     child->prev = NULL;\n   }\n   parent->last_child = child;\n+  add_open_block_counts(parser, child);\n+\n   return child;\n }\n \n@@ -1047,8 +1087,14 @@ static cmark_node *check_open_blocks(cmark_parser *parser, cmark_chunk *input,\n   *all_matched = false;\n   cmark_node *container = parser->root;\n   cmark_node_type cont_type;\n+  cmark_parser tmp_parser; // Only used for its open_block_counts and total_open_blocks fields.\n+  memcpy(tmp_parser.open_block_counts, parser->open_block_counts, sizeof(parser->open_block_counts));\n+  tmp_parser.total_open_blocks = parser->total_open_blocks;\n+\n+  assert(check_open_block_counts(parser));\n \n   while (S_last_child_is_open(container)) {\n+    decr_open_block_count(&tmp_parser, S_type(container));\n     container = container->last_child;\n     cont_type = S_type(container);\n \n@@ -1060,6 +1106,53 @@ static cmark_node *check_open_blocks(cmark_parser *parser, cmark_chunk *input,\n       continue;\n     }\n \n+    // This block of code is a workaround for the quadratic performance\n+    // issue described here (issue 2):\n+    //\n+    // https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh\n+    //\n+    // If the current line is empty then we might be able to skip directly\n+    // to the end of the list of open blocks. To determine whether this is\n+    // possible, we have been maintaining a count of the number of\n+    // different types of open blocks. The main criterium is that every\n+    // remaining block, except the last element of the list, is a LIST or\n+    // ITEM. The code below checks the conditions, and if they're ok, skips\n+    // forward to parser->current.\n+    if (parser->blank && parser->indent == 0) {  // Current line is empty\n+      // Make sure that parser->current doesn't point to a closed block.\n+      if (parser->current->flags & CMARK_NODE__OPEN_BLOCK) {\n+        if (parser->current->flags & CMARK_NODE__OPEN) {\n+          const size_t n_list = read_open_block_count(&tmp_parser, CMARK_NODE_LIST);\n+          const size_t n_item = read_open_block_count(&tmp_parser, CMARK_NODE_ITEM);\n+          // At most one block can be something other than a LIST or ITEM.\n+          if (n_list + n_item + 1 >= tmp_parser.total_open_blocks) {\n+            // Check that parser->current is suitable for jumping to.\n+            switch (S_type(parser->current)) {\n+            case CMARK_NODE_LIST:\n+            case CMARK_NODE_ITEM:\n+              if (n_list + n_item != tmp_parser.total_open_blocks) {\n+                if (parser->current->last_child == NULL) {\n+                  // There's another node type somewhere in the middle of\n+                  // the list, so don't attempt the optimization.\n+                  break;\n+                }\n+              }\n+              // fall through\n+            case CMARK_NODE_CODE_BLOCK:\n+            case CMARK_NODE_PARAGRAPH:\n+            case CMARK_NODE_HTML_BLOCK:\n+              // Jump to parser->current\n+              container = parser->current;\n+              cont_type = S_type(container);\n+              break;\n+            default:\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n     switch (cont_type) {\n     case CMARK_NODE_BLOCK_QUOTE:\n       if (!parse_block_quote_prefix(parser, input))\n@@ -1193,8 +1286,9 @@ static void open_new_blocks(cmark_parser *parser, cmark_node **container,\n       has_content = resolve_reference_link_definitions(parser, *container);\n \n       if (has_content) {\n-\n-        (*container)->type = (uint16_t)CMARK_NODE_HEADING;\n+        cmark_node_set_type(*container, CMARK_NODE_HEADING);\n+        decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);\n+        incr_open_block_count(parser, CMARK_NODE_HEADING);\n         (*container)->as.heading.level = lev;\n         (*container)->as.heading.setext = true;\n         S_advance_offset(parser, input, input->len - 1 - parser->offset, false);\n@@ -1349,7 +1443,7 @@ static void add_text_to_container(cmark_parser *parser, cmark_node *container,\n   S_set_last_line_blank(container, last_line_blank);\n \n   tmp = container;\n-  while (tmp->parent) {\n+  while (tmp->parent && S_last_line_blank(tmp->parent)) {\n     S_set_last_line_blank(tmp->parent, false);\n     tmp = tmp->parent;\n   }\n@@ -1478,6 +1572,7 @@ static void S_process_line(cmark_parser *parser, const unsigned char *buffer,\n \n   parser->line_number++;\n \n+  assert(parser->current->next == NULL);\n   last_matched_container = check_open_blocks(parser, &input, &all_matched);\n \n   if (!last_matched_container)"
        },
        {
          "filename": "src/cmark-gfm.h",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -37,6 +37,16 @@ char *cmark_markdown_to_html(const char *text, size_t len, int options);\n #define CMARK_NODE_TYPE_MASK (0xc000)\n #define CMARK_NODE_VALUE_MASK (0x3fff)\n \n+/**\n+ * This is the maximum number of block types (CMARK_NODE_DOCUMENT,\n+ * CMARK_NODE_HEADING, ...). It needs to be bigger than the number of\n+ * hardcoded block types (below) to allow for extensions (see\n+ * cmark_syntax_extension_add_node). But it also determines the size of the\n+ * open_block_counts array in the cmark_parser struct, so we don't want it\n+ * to be excessively large.\n+ */\n+#define CMARK_NODE_TYPE_BLOCK_LIMIT 0x20\n+\n typedef enum {\n   /* Error status */\n   CMARK_NODE_NONE = 0x0000,"
        },
        {
          "filename": "src/node.c",
          "status": "modified",
          "additions": 20,
          "deletions": 10,
          "patch": "@@ -5,6 +5,16 @@\n #include \"node.h\"\n #include \"syntax_extension.h\"\n \n+/**\n+ * Expensive safety checks are off by default, but can be enabled\n+ * by calling cmark_enable_safety_checks().\n+ */\n+static bool enable_safety_checks = false;\n+\n+void cmark_enable_safety_checks(bool enable) {\n+  enable_safety_checks = enable;\n+}\n+\n static void S_node_unlink(cmark_node *node);\n \n #define NODE_MEM(node) cmark_node_mem(node)\n@@ -70,23 +80,23 @@ bool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type) {\n }\n \n static bool S_can_contain(cmark_node *node, cmark_node *child) {\n-  cmark_node *cur;\n-\n   if (node == NULL || child == NULL) {\n     return false;\n   }\n   if (NODE_MEM(node) != NODE_MEM(child)) {\n     return 0;\n   }\n \n-  // Verify that child is not an ancestor of node or equal to node.\n-  cur = node;\n-  do {\n-    if (cur == child) {\n-      return false;\n-    }\n-    cur = cur->parent;\n-  } while (cur != NULL);\n+  if (enable_safety_checks) {\n+    // Verify that child is not an ancestor of node or equal to node.\n+    cmark_node *cur = node;\n+    do {\n+      if (cur == child) {\n+        return false;\n+      }\n+      cur = cur->parent;\n+    } while (cur != NULL);\n+  }\n \n   return cmark_node_can_contain_type(node, (cmark_node_type) child->type);\n }"
        },
        {
          "filename": "src/node.h",
          "status": "modified",
          "additions": 11,
          "deletions": 3,
          "patch": "@@ -50,12 +50,13 @@ typedef struct {\n \n enum cmark_node__internal_flags {\n   CMARK_NODE__OPEN = (1 << 0),\n-  CMARK_NODE__LAST_LINE_BLANK = (1 << 1),\n-  CMARK_NODE__LAST_LINE_CHECKED = (1 << 2),\n+  CMARK_NODE__OPEN_BLOCK = (1 << 1),\n+  CMARK_NODE__LAST_LINE_BLANK = (1 << 2),\n+  CMARK_NODE__LAST_LINE_CHECKED = (1 << 3),\n \n   // Extensions can register custom flags by calling `cmark_register_node_flag`.\n   // This is the starting value for the custom flags.\n-  CMARK_NODE__REGISTER_FIRST = (1 << 3),\n+  CMARK_NODE__REGISTER_FIRST = (1 << 4),\n };\n \n typedef uint16_t cmark_node_internal_flags;\n@@ -144,6 +145,13 @@ static CMARK_INLINE bool CMARK_NODE_INLINE_P(cmark_node *node) {\n \n CMARK_GFM_EXPORT bool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type);\n \n+/**\n+ * Enable (or disable) extra safety checks. These extra checks cause\n+ * extra performance overhead (in some cases quadratic), so they are only\n+ * intended to be used during testing.\n+ */\n+CMARK_GFM_EXPORT void cmark_enable_safety_checks(bool enable);\n+\n #ifdef __cplusplus\n }\n #endif"
        },
        {
          "filename": "src/parser.h",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -50,8 +50,47 @@ struct cmark_parser {\n   cmark_llist *syntax_extensions;\n   cmark_llist *inline_syntax_extensions;\n   cmark_ispunct_func backslash_ispunct;\n+\n+  /**\n+   * The \"open\" blocks are the blocks visited by the loop in\n+   * check_open_blocks (blocks.c). I.e. the blocks in this list:\n+   *\n+   *   parser->root->last_child->...->last_child\n+   *\n+   * open_block_counts is used to keep track of how many of each type of\n+   * node are currently in the open blocks list. Knowing these counts can\n+   * sometimes help to end the loop in check_open_blocks early, improving\n+   * efficiency.\n+   *\n+   * The count is stored at this offset: type - CMARK_NODE_TYPE_BLOCK - 1\n+   * For example, CMARK_NODE_LIST (0x8003) is stored at offset 2.\n+   */\n+  size_t open_block_counts[CMARK_NODE_TYPE_BLOCK_LIMIT];\n+  size_t total_open_blocks;\n };\n \n+static CMARK_INLINE void incr_open_block_count(cmark_parser *parser, cmark_node_type type) {\n+  assert(type > CMARK_NODE_TYPE_BLOCK);\n+  assert(type <= CMARK_NODE_TYPE_BLOCK + CMARK_NODE_TYPE_BLOCK_LIMIT);\n+  parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1]++;\n+  parser->total_open_blocks++;\n+}\n+\n+static CMARK_INLINE void decr_open_block_count(cmark_parser *parser, cmark_node_type type) {\n+  assert(type > CMARK_NODE_TYPE_BLOCK);\n+  assert(type <= CMARK_NODE_TYPE_BLOCK + CMARK_NODE_TYPE_BLOCK_LIMIT);\n+  assert(parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1] > 0);\n+  parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1]--;\n+  assert(parser->total_open_blocks > 0);\n+  parser->total_open_blocks--;\n+}\n+\n+static CMARK_INLINE size_t read_open_block_count(cmark_parser *parser, cmark_node_type type) {\n+  assert(type > CMARK_NODE_TYPE_BLOCK);\n+  assert(type <= CMARK_NODE_TYPE_BLOCK + CMARK_NODE_TYPE_BLOCK_LIMIT);\n+  return parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1];\n+}\n+\n #ifdef __cplusplus\n }\n #endif"
        },
        {
          "filename": "src/syntax_extension.c",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -29,7 +29,10 @@ cmark_syntax_extension *cmark_syntax_extension_new(const char *name) {\n cmark_node_type cmark_syntax_extension_add_node(int is_inline) {\n   cmark_node_type *ref = !is_inline ? &CMARK_NODE_LAST_BLOCK : &CMARK_NODE_LAST_INLINE;\n \n-  if ((*ref & CMARK_NODE_VALUE_MASK) == CMARK_NODE_VALUE_MASK) {\n+  if ((*ref & CMARK_NODE_VALUE_MASK) >= CMARK_NODE_TYPE_BLOCK_LIMIT) {\n+    // This assertion will fail if you try to register more extensions than\n+    // are currently allowed by CMARK_NODE_TYPE_BLOCK_MAXNUM. Try increasing\n+    // the limit.\n     assert(false);\n     return (cmark_node_type) 0;\n   }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "587a12bb54d95ac37241377e6ddc93ea0e45439b",
            "date": "2023-07-21T15:19:43Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "808bcfbac333d7e82d528d69aaaa33e184921eea",
            "date": "2023-07-20T16:19:53Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "63dd7b72e0b785a967cb2f760e22e4e5e45bcd4b",
            "date": "2023-07-20T16:15:27Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "c123e68e81725d59f30d5a9bee719125538a6c77",
            "date": "2023-07-20T16:14:55Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "049a6e389c8fe2cd75f9b2217411520d85b368d9",
            "date": "2023-07-20T16:14:28Z",
            "author_login": "anticomputer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library and program in C. A polynomial time complexity issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent denial of service. This CVE covers quadratic complexity issues when parsing text which leads with either large numbers of `>` or `-` characters. This issue has been addressed in version 0.29.0.gfm.10. Users are advised to upgrade. Users unable to upgrade should validate that their input comes from trusted sources.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-31T23:15:07.153",
    "last_modified": "2024-11-21T07:48:28.123",
    "fix_date": "2023-03-31T17:27:53Z"
  },
  "references": [
    {
      "url": "https://github.com/github/cmark-gfm/commit/2300c1bd2c8226108885bf019655c4159cf26b59",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/github/cmark-gfm/commit/2300c1bd2c8226108885bf019655c4159cf26b59",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:09.032642",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cmark-gfm",
    "owner": "github",
    "created_at": "2016-12-01T01:48:24Z",
    "updated_at": "2025-01-14T11:42:47Z",
    "pushed_at": "2024-08-19T05:13:47Z",
    "size": 6144,
    "stars": 919,
    "forks": 176,
    "open_issues": 121,
    "watchers": 919,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 768727,
      "C++": 201370,
      "Python": 50409,
      "CMake": 22945,
      "XSLT": 11938,
      "Racket": 8625,
      "Makefile": 7169,
      "Shell": 899,
      "Dockerfile": 820,
      "Perl": 525,
      "Ruby": 316,
      "Batchfile": 294,
      "JavaScript": 102
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0.0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:04:16.445615"
  }
}