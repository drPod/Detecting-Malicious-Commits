{
  "cve_id": "CVE-2023-25157",
  "github_data": {
    "repository": "geoserver/geoserver",
    "fix_commit": "145a8af798590288d270b240235e89c8f0b62e1d",
    "related_commits": [
      "145a8af798590288d270b240235e89c8f0b62e1d",
      "145a8af798590288d270b240235e89c8f0b62e1d"
    ],
    "patch_url": "https://github.com/geoserver/geoserver/commit/145a8af798590288d270b240235e89c8f0b62e1d.patch",
    "fix_commit_details": {
      "sha": "145a8af798590288d270b240235e89c8f0b62e1d",
      "commit_date": "2023-02-13T17:43:43Z",
      "author": {
        "login": "sikeoka",
        "type": "User",
        "stats": {
          "total_commits": 201,
          "average_weekly_commits": 0.29515418502202645,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 105
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-7g5f-wrx8-5ccf",
        "length": 222,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 1536,
        "additions": 1186,
        "deletions": 350
      },
      "files": [
        {
          "filename": "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/ConfigDatabase.java",
          "status": "modified",
          "additions": 17,
          "deletions": 10,
          "patch": "@@ -103,6 +103,7 @@\n import org.geoserver.config.impl.CoverageAccessInfoImpl;\n import org.geoserver.config.impl.GeoServerInfoImpl;\n import org.geoserver.config.impl.JAIInfoImpl;\n+import org.geoserver.jdbcloader.JDBCLoaderProperties;\n import org.geoserver.ows.util.OwsUtils;\n import org.geoserver.platform.ExtensionPriority;\n import org.geoserver.platform.resource.Resource;\n@@ -160,6 +161,8 @@ public class ConfigDatabase implements ApplicationContextAware {\n \n     private Dialect dialect;\n \n+    private JDBCLoaderProperties properties;\n+\n     private DataSource dataSource;\n \n     private DbMappings dbMappings;\n@@ -198,15 +201,19 @@ protected ConfigDatabase() {\n         //\n     }\n \n-    public ConfigDatabase(final DataSource dataSource, final XStreamInfoSerialBinding binding) {\n-        this(dataSource, binding, null);\n+    public ConfigDatabase(\n+            JDBCLoaderProperties properties,\n+            DataSource dataSource,\n+            XStreamInfoSerialBinding binding) {\n+        this(properties, dataSource, binding, null);\n     }\n \n     public ConfigDatabase(\n+            JDBCLoaderProperties properties,\n             final DataSource dataSource,\n             final XStreamInfoSerialBinding binding,\n             CacheProvider cacheProvider) {\n-\n+        this.properties = properties;\n         this.binding = binding;\n         this.template = new NamedParameterJdbcTemplate(dataSource);\n         // cannot use dataSource at this point due to spring context config hack\n@@ -227,7 +234,7 @@ public ConfigDatabase(\n \n     private Dialect dialect() {\n         if (dialect == null) {\n-            this.dialect = Dialect.detect(dataSource);\n+            this.dialect = Dialect.detect(dataSource, properties.isDebugMode());\n         }\n         return dialect;\n     }\n@@ -296,7 +303,7 @@ public <T extends CatalogInfo> int count(final Class<T> of, final Filter filter)\n \n         QueryBuilder<T> sqlBuilder = QueryBuilder.forCount(dialect, of, dbMappings).filter(filter);\n \n-        final StringBuilder sql = sqlBuilder.build();\n+        final String sql = sqlBuilder.build();\n         final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n         final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n         if (LOGGER.isLoggable(Level.FINER)) {\n@@ -309,7 +316,7 @@ public <T extends CatalogInfo> int count(final Class<T> of, final Filter filter)\n             final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n             logStatement(sql, namedParameters);\n \n-            count = template.queryForObject(sql.toString(), namedParameters, Integer.class);\n+            count = template.queryForObject(sql, namedParameters, Integer.class);\n         } else {\n             LOGGER.fine(\n                     \"Filter is not fully supported, doing scan of supported part to return the number of matches\");\n@@ -363,7 +370,7 @@ public <T extends Info> CloseableIterator<T> query(\n                         .offset(offset)\n                         .limit(limit)\n                         .sortOrder(sortOrder);\n-        final StringBuilder sql = sqlBuilder.build();\n+        final String sql = sqlBuilder.build();\n \n         List<String> ids = null;\n \n@@ -406,7 +413,7 @@ public <T extends Info> CloseableIterator<T> query(\n             // with rownum in the 2nd - queryForList will throw an exception\n             ids =\n                     template.query(\n-                            sql.toString(),\n+                            sql,\n                             namedParameters,\n                             new RowMapper<String>() {\n                                 @Override\n@@ -468,7 +475,7 @@ public <T extends Info> CloseableIterator<String> queryIds(\n \n         QueryBuilder<T> sqlBuilder = QueryBuilder.forIds(dialect, of, dbMappings).filter(filter);\n \n-        final StringBuilder sql = sqlBuilder.build();\n+        final String sql = sqlBuilder.build();\n         final Map<String, Object> namedParameters = sqlBuilder.getNamedParameters();\n         final Filter unsupportedFilter = sqlBuilder.getUnsupportedFilter();\n         final boolean fullySupported = Filter.INCLUDE.equals(unsupportedFilter);\n@@ -485,7 +492,7 @@ public <T extends Info> CloseableIterator<String> queryIds(\n         // with rownum in the 2nd - queryForList will throw an exception\n         List<String> ids =\n                 template.query(\n-                        sql.toString(),\n+                        sql,\n                         namedParameters,\n                         new RowMapper<String>() {\n                             @Override"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/Dialect.java",
          "status": "modified",
          "additions": 45,
          "deletions": 1,
          "patch": "@@ -8,12 +8,19 @@\n import com.google.common.base.Joiner;\n import java.sql.Connection;\n import java.sql.SQLException;\n+import java.util.regex.Pattern;\n import javax.annotation.Nullable;\n import javax.sql.DataSource;\n \n public class Dialect {\n \n-    public static Dialect detect(DataSource dataSource) {\n+    // see https://github.com/hibernate/hibernate-orm/commit/59fede7acaaa1579b561407aefa582311f7ebe78\n+    private static final Pattern ESCAPE_CLOSING_COMMENT_PATTERN = Pattern.compile(\"\\\\*/\");\n+    private static final Pattern ESCAPE_OPENING_COMMENT_PATTERN = Pattern.compile(\"/\\\\*\");\n+\n+    private boolean debugMode;\n+\n+    public static Dialect detect(DataSource dataSource, boolean debugMode) {\n         Dialect dialect;\n         try {\n             Connection conn = dataSource.getConnection();\n@@ -27,9 +34,46 @@ public static Dialect detect(DataSource dataSource) {\n         } catch (SQLException ex) {\n             throw new RuntimeException(ex);\n         }\n+        dialect.setDebugMode(debugMode);\n         return dialect;\n     }\n \n+    public boolean isDebugMode() {\n+        return debugMode;\n+    }\n+\n+    public void setDebugMode(boolean debugMode) {\n+        this.debugMode = debugMode;\n+    }\n+\n+    /** Escapes the contents of the SQL comment to prevent SQL injection. */\n+    public String escapeComment(String comment) {\n+        String escaped = ESCAPE_CLOSING_COMMENT_PATTERN.matcher(comment).replaceAll(\"*\\\\\\\\/\");\n+        return ESCAPE_OPENING_COMMENT_PATTERN.matcher(escaped).replaceAll(\"/\\\\\\\\*\");\n+    }\n+\n+    /** Appends the objects to the SQL in a comment if debug mode is enabled. */\n+    public StringBuilder appendComment(StringBuilder sql, Object... objects) {\n+        if (!debugMode) {\n+            return sql;\n+        }\n+        sql.append(\" /* \");\n+        for (Object object : objects) {\n+            sql.append(escapeComment(String.valueOf(object)));\n+        }\n+        return sql.append(\" */\\n\");\n+    }\n+\n+    /** Appends the objects to the SQL in an comment if debug mode is enabled. */\n+    public StringBuilder appendComment(Object sql, Object... objects) {\n+        return appendComment((StringBuilder) sql, objects);\n+    }\n+\n+    /** Appends one of the strings to the SQL depending on whether debug mode is enabled. */\n+    public StringBuilder appendIfDebug(StringBuilder sql, String ifEnabled, String ifDisabled) {\n+        return sql.append(debugMode ? ifEnabled : ifDisabled);\n+    }\n+\n     public void applyOffsetLimit(\n             StringBuilder sql, @Nullable Integer offset, @Nullable Integer limit) {\n         // some db's require limit to be present of offset is"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/FilterToCatalogSQL.java",
          "status": "modified",
          "additions": 141,
          "deletions": 201,
          "patch": "@@ -19,6 +19,7 @@\n import org.geotools.filter.Capabilities;\n import org.geotools.filter.LikeFilterImpl;\n import org.opengis.filter.And;\n+import org.opengis.filter.BinaryLogicOperator;\n import org.opengis.filter.ExcludeFilter;\n import org.opengis.filter.Filter;\n import org.opengis.filter.FilterFactory;\n@@ -94,13 +95,16 @@ public class FilterToCatalogSQL implements FilterVisitor, ExpressionVisitor {\n         CAPABILITIES = builder.getContents();\n     }\n \n+    private final Dialect dialect;\n+\n     private final Class<?> queryType;\n \n     private final DbMappings dbMappings;\n \n     private final Map<String, Object> namedParams = new LinkedHashMap<>();\n \n-    public FilterToCatalogSQL(Class<?> queryType, DbMappings dbMappings) {\n+    public FilterToCatalogSQL(Dialect dialect, Class<?> queryType, DbMappings dbMappings) {\n+        this.dialect = dialect;\n         this.queryType = queryType;\n         this.dbMappings = dbMappings;\n         List<Integer> concreteQueryTypes = dbMappings.getConcreteQueryTypes(queryType);\n@@ -132,8 +136,7 @@ public Object visitNullFilter(Object extraData) {\n      */\n     @Override\n     public Object visit(ExcludeFilter filter, Object extraData) {\n-        append(extraData, \"0 = 1 /* EXCLUDE */\\n\");\n-        return extraData;\n+        return dialect.appendComment(append(extraData, \"0 = 1\"), \"EXCLUDE\");\n     }\n \n     /**\n@@ -142,8 +145,7 @@ public Object visit(ExcludeFilter filter, Object extraData) {\n      */\n     @Override\n     public Object visit(IncludeFilter filter, Object extraData) {\n-        append(extraData, \"1 = 1 /* INCLUDE */\\n\");\n-        return extraData;\n+        return dialect.appendComment(append(extraData, \"1 = 1\"), \"INCLUDE\");\n     }\n \n     /**\n@@ -171,81 +173,57 @@ public Object visit(PropertyIsEqualTo filter, Object extraData) {\n             String valueCol1 = matchingCase ? \"o1.value\" : \"UPPER(o1.value)\";\n             String valueCol2 = matchingCase ? \"o2.value\" : \"UPPER(o2.value)\";\n \n-            StringBuilder builder;\n-\n             switch (matchAction) {\n                     // respect matchaction\n                 case ALL: // all = another value for the property may not occur\n-                    builder =\n-                            append(\n-                                    extraData,\n-                                    \"oid NOT IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n-                                    \"AND o1.property_type IN (:\",\n-                                    propertyTypesParam1,\n-                                    \") \",\n-                                    \"AND o2.property_type IN (:\",\n-                                    propertyTypesParam2,\n-                                    \") \",\n-                                    \"AND \",\n-                                    valueCol1,\n-                                    \" != \",\n-                                    valueCol2,\n-                                    \") /* \",\n-                                    filter.toString(),\n-                                    \" */\\n\");\n+                    append(\n+                            extraData,\n+                            \"oid NOT IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n+                            \"AND o1.property_type IN (:\",\n+                            propertyTypesParam1,\n+                            \") AND o2.property_type IN (:\",\n+                            propertyTypesParam2,\n+                            \") AND \",\n+                            valueCol1,\n+                            \" != \",\n+                            valueCol2,\n+                            \")\");\n                     break;\n                 case ANY: // any = the value for the property must occur at least once\n-                    builder =\n-                            append(\n-                                    extraData,\n-                                    \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n-                                    \"AND o1.property_type IN (:\",\n-                                    propertyTypesParam1,\n-                                    \") \",\n-                                    \"AND o2.property_type IN (:\",\n-                                    propertyTypesParam2,\n-                                    \") \",\n-                                    \"AND \",\n-                                    valueCol1,\n-                                    \" = \",\n-                                    valueCol2,\n-                                    \") /* \",\n-                                    filter.toString(),\n-                                    \" */\\n\");\n+                    append(\n+                            extraData,\n+                            \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n+                            \"AND o1.property_type IN (:\",\n+                            propertyTypesParam1,\n+                            \") AND o2.property_type IN (:\",\n+                            propertyTypesParam2,\n+                            \") AND \",\n+                            valueCol1,\n+                            \" = \",\n+                            valueCol2,\n+                            \")\");\n                     break;\n                 case ONE: // one = the value for the property must occur exactly once\n-                    builder =\n-                            append(\n-                                    extraData,\n-                                    \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n-                                    \"AND o1.property_type IN (:\",\n-                                    propertyTypesParam1,\n-                                    \") \",\n-                                    \"AND o2.property_type IN (:\",\n-                                    propertyTypesParam2,\n-                                    \") \",\n-                                    \"AND \",\n-                                    valueCol1,\n-                                    \" = \",\n-                                    valueCol2,\n-                                    \" GROUP BY (oid) HAVING COUNT(oid) = 1) /* \",\n-                                    filter.toString(),\n-                                    \"/* \",\n-                                    filter.toString(),\n-                                    \" */\\n\");\n+                    append(\n+                            extraData,\n+                            \"oid IN (SELECT o1.oid FROM object_property o1, object_property o2 WHERE o1.oid = o2.oid \",\n+                            \"AND o1.property_type IN (:\",\n+                            propertyTypesParam1,\n+                            \") AND o2.property_type IN (:\",\n+                            propertyTypesParam2,\n+                            \") AND \",\n+                            valueCol1,\n+                            \" = \",\n+                            valueCol2,\n+                            \" GROUP BY (oid) HAVING COUNT(oid) = 1)\");\n                     break;\n                 default:\n                     throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n             }\n-\n-            return builder;\n-\n         } else {\n \n             if (filter.getExpression1() instanceof IsInstanceOf) {\n-                StringBuilder builder =\n-                        append(extraData, handleInstanceOf((IsInstanceOf) filter.getExpression1()));\n-                return builder;\n+                return handleInstanceOf((IsInstanceOf) filter.getExpression1(), extraData);\n             }\n \n             // comparing a literal with a field\n@@ -271,74 +249,60 @@ public Object visit(PropertyIsEqualTo filter, Object extraData) {\n                 expectedValue = expectedValue.toUpperCase();\n             }\n             String valueParam = newParam(\"value\", expectedValue);\n-\n-            StringBuilder builder;\n             String valueCol = matchingCase ? \"value\" : \"UPPER(value)\";\n \n             switch (matchAction) {\n                     // respect match action\n                 case ALL: // all = another value for the property may not occur\n-                    builder =\n-                            append(\n-                                    extraData,\n-                                    \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                                    propertyTypesParam,\n-                                    \") AND \",\n-                                    valueCol,\n-                                    \" != :\",\n-                                    valueParam,\n-                                    \") /* \",\n-                                    filter.toString(),\n-                                    \" */\\n\");\n+                    append(\n+                            extraData,\n+                            \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                            propertyTypesParam,\n+                            \") AND \",\n+                            valueCol,\n+                            \" != :\",\n+                            valueParam,\n+                            \")\");\n                     break;\n                 case ANY: // any = the value for the property must occur at least once\n-                    builder =\n-                            append(\n-                                    extraData,\n-                                    \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                                    propertyTypesParam,\n-                                    \") AND \",\n-                                    valueCol,\n-                                    \" = :\",\n-                                    valueParam,\n-                                    \") /* \",\n-                                    filter.toString(),\n-                                    \" */\\n\");\n+                    append(\n+                            extraData,\n+                            \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                            propertyTypesParam,\n+                            \") AND \",\n+                            valueCol,\n+                            \" = :\",\n+                            valueParam,\n+                            \")\");\n                     break;\n                 case ONE: // one = the value for the property must occur exactly once\n-                    builder =\n-                            append(\n-                                    extraData,\n-                                    \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                                    propertyTypesParam,\n-                                    \") AND \",\n-                                    valueCol,\n-                                    \" = :\",\n-                                    valueParam,\n-                                    \" GROUP BY (oid) HAVING COUNT(oid) = 1) /* \",\n-                                    filter.toString(),\n-                                    \" */\\n\");\n+                    append(\n+                            extraData,\n+                            \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                            propertyTypesParam,\n+                            \") AND \",\n+                            valueCol,\n+                            \" = :\",\n+                            valueParam,\n+                            \" GROUP BY (oid) HAVING COUNT(oid) = 1)\");\n                     break;\n                 default:\n                     throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n             }\n-\n-            return builder;\n         }\n+        return dialect.appendComment(extraData, filter);\n     }\n \n-    private String handleInstanceOf(IsInstanceOf instanceOf) {\n+    private Object handleInstanceOf(IsInstanceOf instanceOf, Object extraData) {\n         Expression expression1 = instanceOf.getParameters().get(0);\n \n         Class<?> clazz = expression1.evaluate(null, Class.class);\n-\n-        if (clazz == null || dbMappings.getTypeId(clazz) == null) {\n-            return \"0 = 1 /* EXCLUDE */\\n\";\n-        }\n-\n         Integer typeId = dbMappings.getTypeId(clazz);\n-\n-        return \"type_id = \" + typeId + \" /* isInstanceOf \" + clazz.getName() + \" */\\n\";\n+        if (typeId == null) {\n+            return visit(Filter.EXCLUDE, extraData);\n+        }\n+        append(extraData, \"type_id = \", typeId.toString());\n+        return dialect.appendComment(extraData, \"isInstanceOf \", clazz.getName());\n     }\n \n     /**\n@@ -348,7 +312,6 @@ private String handleInstanceOf(IsInstanceOf instanceOf) {\n     @Override\n     public Object visit(PropertyIsLike filter, Object extraData) {\n         final PropertyName expression1 = (PropertyName) filter.getExpression();\n-        // TODO: check for indexed property name\n \n         final String propertyTypesParam = propertyTypesParam(expression1);\n \n@@ -360,63 +323,51 @@ public Object visit(PropertyIsLike filter, Object extraData) {\n         final boolean matchCase = filter.isMatchingCase();\n \n         final String pattern =\n-                LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal);\n+                LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal, false);\n \n         // respect match case\n+        String valueParam = newParam(\"value\", pattern);\n         String valueCol = matchCase ? \"value\" : \"UPPER(value)\";\n \n-        StringBuilder builder;\n-\n         switch (matchAction) {\n                 // respect match action\n             case ALL: // all = another value for the property may not occur\n-                builder =\n-                        append(\n-                                extraData,\n-                                \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                                propertyTypesParam,\n-                                \") AND \",\n-                                valueCol,\n-                                \" NOT LIKE '\",\n-                                pattern,\n-                                \"') /* \",\n-                                filter.toString(),\n-                                \" */\\n\");\n+                append(\n+                        extraData,\n+                        \"oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                        propertyTypesParam,\n+                        \") AND \",\n+                        valueCol,\n+                        \" NOT LIKE :\",\n+                        valueParam,\n+                        \")\");\n                 break;\n             case ANY: // any = the value for the property must occur at least once\n-                builder =\n-                        append(\n-                                extraData,\n-                                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                                propertyTypesParam,\n-                                \") AND \",\n-                                valueCol,\n-                                \" LIKE '\",\n-                                pattern,\n-                                \"') /* \",\n-                                filter.toString(),\n-                                \" */\\n\");\n+                append(\n+                        extraData,\n+                        \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                        propertyTypesParam,\n+                        \") AND \",\n+                        valueCol,\n+                        \" LIKE :\",\n+                        valueParam,\n+                        \")\");\n                 break;\n             case ONE: // one = the value for the property must occur exactly once\n-                builder =\n-                        append(\n-                                extraData,\n-                                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                                propertyTypesParam,\n-                                \") AND \",\n-                                valueCol,\n-                                \" LIKE '\",\n-                                pattern,\n-                                \"' \",\n-                                \"GROUP BY (oid) HAVING COUNT(oid) = 1) /* \",\n-                                filter.toString(),\n-                                \" */\\n\");\n+                append(\n+                        extraData,\n+                        \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                        propertyTypesParam,\n+                        \") AND \",\n+                        valueCol,\n+                        \" LIKE :\",\n+                        valueParam,\n+                        \" GROUP BY (oid) HAVING COUNT(oid) = 1)\");\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"MatchAction: \" + matchAction);\n         }\n-\n-        return builder;\n+        return dialect.appendComment(extraData, filter);\n     }\n \n     private String propertyTypesParam(final PropertyName property) {\n@@ -477,40 +428,30 @@ public Object visit(PropertyIsNotEqualTo filter, Object extraData) {\n     /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.And, java.lang.Object) */\n     @Override\n     public Object visit(And filter, Object extraData) {\n-        StringBuilder sql = (StringBuilder) extraData;\n-\n-        List<Filter> children = filter.getChildren();\n-        checkArgument(children.size() > 0);\n-        sql.append(\"(\\n    \");\n-\n-        for (Iterator<Filter> it = children.iterator(); it.hasNext(); ) {\n-            Filter child = it.next();\n-            sql = (StringBuilder) child.accept(this, sql);\n-            if (it.hasNext()) {\n-                sql = append(extraData, \"    AND\\n    \");\n-            }\n-        }\n-        sql.append(\")\");\n-        return sql;\n+        return visit(filter, \"AND\", extraData);\n     }\n \n     /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Or, java.lang.Object) */\n     @Override\n     public Object visit(Or filter, Object extraData) {\n-        StringBuilder sql = (StringBuilder) extraData;\n+        return visit(filter, \"OR\", extraData);\n+    }\n \n+    protected Object visit(BinaryLogicOperator filter, String type, Object extraData) {\n+        StringBuilder sql = (StringBuilder) extraData;\n         List<Filter> children = filter.getChildren();\n         checkArgument(children.size() > 0);\n-        sql.append(\"(\");\n+        sql.append('(');\n+        dialect.appendIfDebug(sql, \"\\n    \", \"\");\n         for (Iterator<Filter> it = children.iterator(); it.hasNext(); ) {\n-            Filter child = it.next();\n-            sql = (StringBuilder) child.accept(this, sql);\n+            it.next().accept(this, sql);\n             if (it.hasNext()) {\n-                sql = append(extraData, \"    OR\\n    \");\n+                dialect.appendIfDebug(sql, \"    \", \" \");\n+                sql.append(type);\n+                dialect.appendIfDebug(sql, \"\\n    \", \" \");\n             }\n         }\n-        sql.append(\")\");\n-        return sql;\n+        return sql.append(')');\n     }\n \n     /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Id, java.lang.Object) */\n@@ -523,8 +464,13 @@ public Object visit(Id filter, Object extraData) {\n     /** @see org.opengis.filter.FilterVisitor#visit(org.opengis.filter.Not, java.lang.Object) */\n     @Override\n     public Object visit(Not filter, Object extraData) {\n-        filter.getFilter().accept(this, append(extraData, \"NOT (\"));\n-        return append(extraData, \")\");\n+        Filter child = filter.getFilter();\n+        // these filter types are already enclosed in parentheses\n+        boolean extraParens =\n+                !(child instanceof And || child instanceof Or || child instanceof PropertyIsNull);\n+        append(extraData, \"NOT \", extraParens ? \"(\" : \"\");\n+        child.accept(this, extraData);\n+        return append(extraData, extraParens ? \")\" : \"\");\n     }\n \n     /**\n@@ -587,17 +533,14 @@ public Object visit(PropertyIsNull filter, Object extraData) {\n         final PropertyName propertyName = (PropertyName) filter.getExpression();\n         final String propertyTypesParam = propertyTypesParam(propertyName);\n \n-        StringBuilder builder =\n-                append(\n-                        extraData,\n-                        \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                        propertyTypesParam,\n-                        \") AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n-                                + propertyTypesParam\n-                                + \"))) /* \",\n-                        filter.toString(),\n-                        \" */\\n\");\n-        return builder;\n+        append(\n+                extraData,\n+                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                propertyTypesParam,\n+                \") AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                propertyTypesParam,\n+                \")))\");\n+        return dialect.appendComment(extraData, filter);\n     }\n \n     /**\n@@ -609,15 +552,12 @@ public Object visit(PropertyIsNil filter, Object extraData) {\n         final PropertyName propertyName = (PropertyName) filter.getExpression();\n         final String propertyTypesParam = propertyTypesParam(propertyName);\n \n-        StringBuilder builder =\n-                append(\n-                        extraData,\n-                        \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n-                        propertyTypesParam,\n-                        \") AND value IS NULL) /* \",\n-                        filter.toString(),\n-                        \" */\\n\");\n-        return builder;\n+        append(\n+                extraData,\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\",\n+                propertyTypesParam,\n+                \") AND value IS NULL)\");\n+        return dialect.appendComment(extraData, filter);\n     }\n \n     /**"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/OracleDialect.java",
          "status": "modified",
          "additions": 8,
          "deletions": 3,
          "patch": "@@ -21,12 +21,17 @@ public void applyOffsetLimit(\n             limit += 1; // not zero-based\n         }\n         if (offset != null && limit != null) {\n-            sql.insert(0, \"SELECT * FROM (SELECT query.*, rownum rnum FROM (\\n\");\n-            sql.append(\") query\\n\");\n+            sql.insert(\n+                    0,\n+                    \"SELECT * FROM (SELECT query.*, rownum rnum FROM (\"\n+                            + (isDebugMode() ? \"\\n\" : \"\"));\n+            sql.append(\") query\");\n+            appendIfDebug(sql, \"\\n\", \" \");\n             if (limit != Integer.MAX_VALUE) {\n                 limit = offset + limit;\n             }\n-            sql.append(\"WHERE rownum <= \").append(limit).append(\")\\n\");\n+            sql.append(\"WHERE rownum <= \").append(limit).append(\")\");\n+            appendIfDebug(sql, \"\\n\", \" \");\n             sql.append(\"WHERE rnum > \").append(offset);\n         }\n     }"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcconfig/internal/QueryBuilder.java",
          "status": "modified",
          "additions": 49,
          "deletions": 42,
          "patch": "@@ -128,7 +128,7 @@ public QueryBuilder<T> filter(Filter filter) {\n         return this;\n     }\n \n-    private void querySortBy(StringBuilder query, StringBuilder whereClause, SortBy[] orders) {\n+    private void querySortBy(StringBuilder query, String whereClause, SortBy[] orders) {\n \n         /*\n          * Start with the oid and id from the object table selecting for type and the filter.\n@@ -144,15 +144,15 @@ private void querySortBy(StringBuilder query, StringBuilder whereClause, SortBy[\n \n         int i = 0;\n \n-        query.append(\"SELECT id FROM \");\n-\n-        query.append(\"\\n    (SELECT oid, id FROM object WHERE \");\n-        if (queryType != null) {\n-            query.append(\"type_id IN (:types) /* \")\n-                    .append(queryType.getCanonicalName())\n-                    .append(\" */\\n      AND \");\n+        query.append(\"SELECT id FROM\");\n+        dialect.appendIfDebug(query, \"\\n    \", \" \");\n+        query.append(\"(SELECT oid, id FROM object WHERE type_id IN (:types)\");\n+        dialect.appendComment(query, queryType.getName());\n+        if (whereClause != null) {\n+            dialect.appendIfDebug(query, \"      \", \" \");\n+            query.append(\"AND \").append(whereClause);\n         }\n-        query.append(whereClause).append(\") object\");\n+        query.append(\") object\");\n \n         for (SortBy order : orders) {\n             final String sortProperty = order.getPropertyName().getPropertyName();\n@@ -167,35 +167,36 @@ private void querySortBy(StringBuilder query, StringBuilder whereClause, SortBy[\n             Map<String, Object> namedParameters = getNamedParameters();\n             namedParameters.put(propertyParamName, sortPropertyTypeIds);\n \n-            query.append(\"\\n  LEFT JOIN\");\n-            query.append(\"\\n    (SELECT oid, value \")\n-                    .append(attributeName)\n-                    .append(\" FROM \\n      object_property WHERE property_type IN (:\")\n+            dialect.appendIfDebug(query, \"\\n  \", \" \");\n+            query.append(\"LEFT JOIN\");\n+            dialect.appendIfDebug(query, \"\\n    \", \" \");\n+            query.append(\"(SELECT oid, value \").append(attributeName).append(\" FROM\");\n+            dialect.appendIfDebug(query, \"\\n      \", \" \");\n+            query.append(\"object_property WHERE property_type IN (:\")\n                     .append(propertyParamName)\n                     .append(\")) \")\n                     .append(subSelectName);\n-\n-            query.append(\" /* \")\n-                    .append(order.getPropertyName().getPropertyName())\n-                    .append(\" \")\n-                    .append(ascDesc(order))\n-                    .append(\" */\");\n-\n-            query.append(\"\\n  ON object.oid = \").append(subSelectName).append(\".oid\");\n+            dialect.appendComment(\n+                    query, order.getPropertyName().getPropertyName(), \" \", ascDesc(order));\n+            dialect.appendIfDebug(query, \"  \", \" \");\n+            query.append(\"ON object.oid = \").append(subSelectName).append(\".oid\");\n             // Update the ORDER BY clause to be added later\n             if (i > 0) orderBy.append(\", \");\n             orderBy.append(attributeName).append(\" \").append(ascDesc(order));\n \n             i++;\n         }\n-\n-        query.append(\"\\n  \").append(orderBy);\n+        dialect.appendIfDebug(query, \"\\n  \", \" \");\n+        query.append(orderBy);\n     }\n \n-    private StringBuilder buildWhereClause() {\n+    private String buildWhereClause() {\n+        this.predicateBuilder =\n+                new FilterToCatalogSQL(this.dialect, this.queryType, this.dbMappings);\n+        if (Filter.INCLUDE.equals(this.originalFilter)) {\n+            return null;\n+        }\n         final SimplifyingFilterVisitor filterSimplifier = new SimplifyingFilterVisitor();\n-\n-        this.predicateBuilder = new FilterToCatalogSQL(this.queryType, this.dbMappings);\n         Capabilities fcs = new Capabilities(FilterToCatalogSQL.CAPABILITIES);\n         FeatureType parent = null;\n         // use this to instruct the filter splitter which filters can be encoded depending on\n@@ -238,36 +239,42 @@ public Filter getDeleteFilter() {\n                 (Filter) supported.accept(new LiteralDemultiplyingFilterVisitor(), null);\n         this.supportedFilter = (Filter) demultipliedFilter.accept(filterSimplifier, null);\n         this.unsupportedFilter = (Filter) unsupported.accept(filterSimplifier, null);\n-\n+        if (Filter.INCLUDE.equals(this.supportedFilter)) {\n+            return null;\n+        }\n         StringBuilder whereClause = new StringBuilder();\n-        return (StringBuilder) this.supportedFilter.accept(predicateBuilder, whereClause);\n+        return this.supportedFilter.accept(predicateBuilder, whereClause).toString();\n     }\n \n-    public StringBuilder build() {\n+    public String build() {\n \n-        StringBuilder whereClause = buildWhereClause();\n+        String whereClause = buildWhereClause();\n \n         StringBuilder query = new StringBuilder();\n         if (isCountQuery) {\n-            if (Filter.INCLUDE.equals(this.originalFilter)) {\n-                query.append(\"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\");\n-            } else {\n-                query.append(\"SELECT COUNT(oid) FROM object WHERE type_id IN (:types) AND (\\n\");\n-                query.append(whereClause).append(\")\");\n+            query.append(\"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\");\n+            dialect.appendComment(query, queryType.getName());\n+            if (whereClause != null) {\n+                dialect.appendIfDebug(query, \"\", \" \");\n+                query.append(\"AND \").append(whereClause);\n             }\n         } else {\n-            SortBy[] orders = this.sortOrder;\n-            if (orders == null) {\n-                query.append(\"SELECT id FROM object WHERE type_id IN (:types) AND (\\n\");\n-                query.append(whereClause).append(\")\");\n-                query.append(\" ORDER BY oid\");\n+            if (sortOrder != null) {\n+                querySortBy(query, whereClause, sortOrder);\n             } else {\n-                querySortBy(query, whereClause, orders);\n+                query.append(\"SELECT id FROM object WHERE type_id IN (:types)\");\n+                dialect.appendComment(query, queryType.getName());\n+                dialect.appendIfDebug(query, \"\", \" \");\n+                if (whereClause != null) {\n+                    query.append(\"AND \").append(whereClause);\n+                    dialect.appendIfDebug(query, whereClause.endsWith(\"\\n\") ? \"\" : \" \", \" \");\n+                }\n+                query.append(\"ORDER BY oid\");\n             }\n             applyOffsetLimit(query);\n         }\n \n-        return query;\n+        return query.toString().trim();\n     }\n \n     /** When the query was built, were the offset and limit included. */"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/java/org/geoserver/jdbcloader/JDBCLoaderProperties.java",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -107,4 +107,12 @@ public String getDatasourceId() {\n     public void setDatasourceId(String datasourceId) {\n         this.datasourceId = datasourceId;\n     }\n+\n+    public boolean isDebugMode() {\n+        return Boolean.parseBoolean(getProperty(\"debugMode\", \"false\"));\n+    }\n+\n+    public void setDebugMode(boolean debugMode) {\n+        setProperty(\"debugMode\", String.valueOf(debugMode));\n+    }\n }"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/resources/applicationContext.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -33,6 +33,7 @@\n   </bean>\n \n   <bean id=\"JDBCConfigDB\" class=\"org.geoserver.jdbcconfig.internal.ConfigDatabase\">\n+    <constructor-arg ref=\"jdbcConfigProperties\" />\n     <constructor-arg ref=\"jdbcConfigDataSource\" />\n     <constructor-arg ref=\"jdbcPersistenceBinding\" />\n   </bean>"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/resources/jdbcconfig.properties",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -10,6 +10,11 @@ initScript=jdbcconfig/scripts/initdb.postgres.sql\n # flag controlling whether the existing (non-db) catalog should be imported\n import=true\n \n+# Flag controlling whether to add comments and some pretty-printing to SQL queries to\n+# assist with debugging.  Setting this to false may allow the module to better take\n+# advantage of prepared statement caching.\n+debugMode=false\n+\n # database connection info\n jdbcUrl=jdbc:postgresql://localhost:5432/gscatalog\n driverClassName=org.postgresql.Driver"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/resources/jdbcconfig.properties.h2",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -14,6 +14,11 @@ initdb=true\n initScript=jdbcconfig/scripts/initdb.h2.sql\n import=true\n \n+# Flag controlling whether to add comments and some pretty-printing to SQL queries to\n+# assist with debugging.  Setting this to false may allow the module to better take\n+# advantage of prepared statement caching.\n+debugMode=false\n+\n jdbcUrl=jdbc:h2:file:${GEOSERVER_DATA_DIR}/jdbcconfig/catalog;AUTO_SERVER=TRUE\n driverClassName=org.h2.Driver\n username=sa"
        },
        {
          "filename": "src/community/jdbcconfig/src/main/resources/jdbcconfig.properties.postgres",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -31,6 +31,11 @@ initScript=jdbcconfig/scripts/initdb.postgres.sql\n #\n import=true\n \n+# Flag controlling whether to add comments and some pretty-printing to SQL queries to\n+# assist with debugging.  Setting this to false may allow the module to better take\n+# advantage of prepared statement caching.\n+debugMode=false\n+\n #\n # The JNDI name for the data source.  Uncomment to use JNDI.\n #"
        },
        {
          "filename": "src/community/jdbcconfig/src/test/java/org/geoserver/jdbcconfig/JDBCConfigTestSupport.java",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -32,6 +32,7 @@\n import org.geoserver.jdbcconfig.internal.JDBCConfigXStreamPersisterInitializer;\n import org.geoserver.jdbcconfig.internal.Util;\n import org.geoserver.jdbcconfig.internal.XStreamInfoSerialBinding;\n+import org.geoserver.jdbcloader.JDBCLoaderProperties;\n import org.geoserver.platform.GeoServerExtensionsHelper;\n import org.geoserver.platform.GeoServerResourceLoader;\n import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n@@ -418,7 +419,9 @@ public PlatformTransactionManager jdbcConfigTransactionManager() {\n         @Bean\n         public ConfigDatabase configDatabase() {\n             return new ConfigDatabase(\n-                    dataSource(), new XStreamInfoSerialBinding(new XStreamPersisterFactory()));\n+                    new JDBCLoaderProperties(null),\n+                    dataSource(),\n+                    new XStreamInfoSerialBinding(new XStreamPersisterFactory()));\n         }\n \n         @Bean"
        },
        {
          "filename": "src/community/jdbcconfig/src/test/java/org/geoserver/jdbcconfig/internal/QueryBuilderTest.java",
          "status": "modified",
          "additions": 898,
          "deletions": 92,
          "patch": "@@ -16,8 +16,10 @@\n  */\n package org.geoserver.jdbcconfig.internal;\n \n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n \n import org.geoserver.catalog.LayerInfo;\n import org.geoserver.catalog.Predicates;\n@@ -27,13 +29,17 @@\n import org.junit.Before;\n import org.junit.Test;\n import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory;\n+import org.opengis.filter.sort.SortBy;\n \n /**\n  * @author groldan\n  * @author Kevin Smith, OpenGeo\n  */\n public class QueryBuilderTest {\n \n+    private static final FilterFactory FACTORY = Predicates.factory;\n+\n     private JDBCConfigTestSupport testSupport;\n \n     private DbMappings dbMappings;\n@@ -43,7 +49,6 @@ public class QueryBuilderTest {\n     @Before\n     public void setUp() throws Exception {\n         dialect = new Dialect();\n-        dbMappings = new DbMappings(dialect);\n         testSupport =\n                 new JDBCConfigTestSupport(\n                         (JDBCConfigTestSupport.DBConfig)\n@@ -58,125 +63,926 @@ public void tearDown() throws Exception {\n     }\n \n     @Test\n-    public void testQueryAll() {\n-        Filter filter = Predicates.equal(\"name\", \"ws1\");\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .build();\n+    public void testForIdsSort1DebugDisabled() {\n+        String expected =\n+                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types)) object \"\n+                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n+                        + \"ORDER BY prop0 ASC\";\n+        verifyForIds(expected, false, Predicates.acceptAll(), Predicates.asc(\"foo\"));\n     }\n \n     @Test\n-    public void testSort1() {\n-        Filter filter = Predicates.acceptAll();\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .sortOrder(Predicates.asc(\"foo\"))\n-                        .build();\n+    public void testForIdsSort1DebugEnabled() {\n+        String expected =\n+                \"SELECT id FROM\"\n+                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\n) object\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop0 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n+                        + \"\\n  ON object.oid = subSelect0.oid\"\n+                        + \"\\n  ORDER BY prop0 ASC\";\n+        verifyForIds(expected, true, Predicates.acceptAll(), Predicates.asc(\"foo\"));\n     }\n \n     @Test\n-    public void testSort2() {\n-        Filter filter = Predicates.acceptAll();\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .sortOrder(Predicates.asc(\"foo\"), Predicates.desc(\"bar\"))\n-                        .build();\n+    public void testForIdsSort2DebugDisabled() {\n+        String expected =\n+                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types)) object \"\n+                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n+                        + \"LEFT JOIN (SELECT oid, value prop1 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty1)) subSelect1 ON object.oid = subSelect1.oid \"\n+                        + \"ORDER BY prop0 ASC, prop1 DESC\";\n+        verifyForIds(\n+                expected,\n+                false,\n+                Predicates.acceptAll(),\n+                Predicates.asc(\"foo\"),\n+                Predicates.desc(\"bar\"));\n     }\n \n     @Test\n-    public void testSort3() {\n-        Filter filter = Predicates.acceptAll();\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .sortOrder(\n-                                Predicates.asc(\"foo\"),\n-                                Predicates.desc(\"bar\"),\n-                                Predicates.asc(\"baz\"))\n-                        .build();\n+    public void testForIdsSort2DebugEnabled() {\n+        String expected =\n+                \"SELECT id FROM\"\n+                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\n) object\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop0 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n+                        + \"\\n  ON object.oid = subSelect0.oid\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop1 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty1)) subSelect1 /* bar DESC */\"\n+                        + \"\\n  ON object.oid = subSelect1.oid\"\n+                        + \"\\n  ORDER BY prop0 ASC, prop1 DESC\";\n+        verifyForIds(\n+                expected,\n+                true,\n+                Predicates.acceptAll(),\n+                Predicates.asc(\"foo\"),\n+                Predicates.desc(\"bar\"));\n     }\n \n     @Test\n-    public void testSort3WithFilter() {\n-        Filter filter = Predicates.equal(\"name\", \"quux\");\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .sortOrder(\n-                                Predicates.asc(\"foo\"),\n-                                Predicates.desc(\"bar\"),\n-                                Predicates.asc(\"baz\"))\n-                        .build();\n+    public void testForIdsSort3DebugDisabled() {\n+        String expected =\n+                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types)) object \"\n+                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n+                        + \"LEFT JOIN (SELECT oid, value prop1 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty1)) subSelect1 ON object.oid = subSelect1.oid \"\n+                        + \"LEFT JOIN (SELECT oid, value prop2 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty2)) subSelect2 ON object.oid = subSelect2.oid \"\n+                        + \"ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n+        verifyForIds(\n+                expected,\n+                false,\n+                Predicates.acceptAll(),\n+                Predicates.asc(\"foo\"),\n+                Predicates.desc(\"bar\"),\n+                Predicates.asc(\"baz\"));\n     }\n \n     @Test\n-    public void testNotEquals() {\n-        // Create the filter\n-        Filter filter = Predicates.notEqual(\"name\", \"quux\");\n-        // Build it\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .build();\n-        String sql = build.toString();\n-        // Ensure the following sql is present\n-        assertThat(\n-                sql,\n-                containsString(\n-                        \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:ptype0) AND UPPER(value) = :value0)\"));\n+    public void testForIdsSort3DebugEnabled() {\n+        String expected =\n+                \"SELECT id FROM\"\n+                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\n) object\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop0 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n+                        + \"\\n  ON object.oid = subSelect0.oid\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop1 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty1)) subSelect1 /* bar DESC */\"\n+                        + \"\\n  ON object.oid = subSelect1.oid\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop2 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty2)) subSelect2 /* baz ASC */\"\n+                        + \"\\n  ON object.oid = subSelect2.oid\"\n+                        + \"\\n  ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n+        verifyForIds(\n+                expected,\n+                true,\n+                Predicates.acceptAll(),\n+                Predicates.asc(\"foo\"),\n+                Predicates.desc(\"bar\"),\n+                Predicates.asc(\"baz\"));\n+    }\n+\n+    @Test\n+    public void testForIdsSort3WithFilterDebugDisabled() {\n+        String expected =\n+                \"SELECT id FROM (SELECT oid, id FROM object WHERE type_id IN (:types) AND oid IN \"\n+                        + \"(SELECT oid FROM object_property WHERE property_type IN (:ptype0) AND value = :value0)) object \"\n+                        + \"LEFT JOIN (SELECT oid, value prop0 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty0)) subSelect0 ON object.oid = subSelect0.oid \"\n+                        + \"LEFT JOIN (SELECT oid, value prop1 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty1)) subSelect1 ON object.oid = subSelect1.oid \"\n+                        + \"LEFT JOIN (SELECT oid, value prop2 FROM object_property \"\n+                        + \"WHERE property_type IN (:sortProperty2)) subSelect2 ON object.oid = subSelect2.oid \"\n+                        + \"ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n+        verifyForIds(\n+                expected,\n+                false,\n+                Predicates.equal(\"name\", \"quux\"),\n+                Predicates.asc(\"foo\"),\n+                Predicates.desc(\"bar\"),\n+                Predicates.asc(\"baz\"));\n+    }\n+\n+    @Test\n+    public void testForIdsSort3WithFilterDebugEnabled() {\n+        String expected =\n+                \"SELECT id FROM\"\n+                        + \"\\n    (SELECT oid, id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\n      AND oid IN (SELECT oid FROM object_property WHERE property_type IN (:ptype0) AND value = :value0) /* [ name = quux ] */\"\n+                        + \"\\n) object\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop0 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty0)) subSelect0 /* foo ASC */\"\n+                        + \"\\n  ON object.oid = subSelect0.oid\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop1 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty1)) subSelect1 /* bar DESC */\"\n+                        + \"\\n  ON object.oid = subSelect1.oid\"\n+                        + \"\\n  LEFT JOIN\"\n+                        + \"\\n    (SELECT oid, value prop2 FROM\"\n+                        + \"\\n      object_property WHERE property_type IN (:sortProperty2)) subSelect2 /* baz ASC */\"\n+                        + \"\\n  ON object.oid = subSelect2.oid\"\n+                        + \"\\n  ORDER BY prop0 ASC, prop1 DESC, prop2 ASC\";\n+        verifyForIds(\n+                expected,\n+                true,\n+                Predicates.equal(\"name\", \"quux\"),\n+                Predicates.asc(\"foo\"),\n+                Predicates.desc(\"bar\"),\n+                Predicates.asc(\"baz\"));\n+    }\n+\n+    @Test\n+    public void testForCountUnknownProperty() {\n+        dialect.setDebugMode(false);\n+        String expected = \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\";\n+        Filter filter = Predicates.equal(\"foo.bar.baz\", \"quux\");\n+        QueryBuilder<?> builder =\n+                QueryBuilder.forCount(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n+        String actual = builder.build();\n+        assertEquals(expected, actual);\n+        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n+        assertEquals(filter, builder.getUnsupportedFilter());\n+        assertFalse(builder.isOffsetLimitApplied());\n+        assertEquals(1, builder.getNamedParameters().size());\n+    }\n+\n+    @Test\n+    public void testForIdsUnknownProperty() {\n+        dialect.setDebugMode(false);\n+        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid\";\n+        Filter filter = Predicates.equal(\"foo.bar.baz\", \"quux\");\n+        QueryBuilder<?> builder =\n+                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n+        String actual = builder.build();\n+        assertEquals(expected, actual);\n+        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n+        assertEquals(filter, builder.getUnsupportedFilter());\n+        assertFalse(builder.isOffsetLimitApplied());\n+        assertEquals(1, builder.getNamedParameters().size());\n+    }\n+\n+    @Test\n+    public void testForCountSimplifiedInclude() {\n+        dialect.setDebugMode(false);\n+        String expected = \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\";\n+        Filter filter = Predicates.and(Predicates.acceptAll(), Predicates.acceptAll());\n+        QueryBuilder<?> builder =\n+                QueryBuilder.forCount(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n+        String actual = builder.build();\n+        assertEquals(expected, actual);\n+        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n+        assertEquals(Filter.INCLUDE, builder.getUnsupportedFilter());\n+        assertFalse(builder.isOffsetLimitApplied());\n+        assertEquals(1, builder.getNamedParameters().size());\n+    }\n+\n+    @Test\n+    public void testForIdsSimplifiedInclude() {\n+        dialect.setDebugMode(false);\n+        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid\";\n+        Filter filter = Predicates.and(Predicates.acceptAll(), Predicates.acceptAll());\n+        QueryBuilder<?> builder =\n+                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).filter(filter);\n+        String actual = builder.build();\n+        assertEquals(expected, actual);\n+        assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n+        assertEquals(Filter.INCLUDE, builder.getUnsupportedFilter());\n+        assertTrue(builder.isOffsetLimitApplied());\n+        assertEquals(1, builder.getNamedParameters().size());\n     }\n \n     @Test\n-    public void testIsInstanceOf() {\n-        // Create the filter\n-        Filter filter = Predicates.isInstanceOf(LayerInfo.class);\n-        // Build it\n-        StringBuilder build =\n+    public void testForIdsIncludeWithOffSetDebugDisabled() {\n+        dialect.setDebugMode(false);\n+        String expected =\n+                \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid LIMIT 2147483647 OFFSET 5\";\n+        String actual =\n+                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).offset(5).build();\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testForIdsIncludeWithLimitDebugDisabled() {\n+        dialect.setDebugMode(false);\n+        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid LIMIT 10\";\n+        String actual =\n+                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).limit(10).build();\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testForIdsIncludeWithOffSetAndLimitDebugDisabled() {\n+        dialect.setDebugMode(false);\n+        String expected =\n+                \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid LIMIT 10 OFFSET 5\";\n+        String actual =\n                 QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n+                        .offset(5)\n+                        .limit(10)\n                         .build();\n-        String sql = build.toString();\n-        // Ensure the following sql is present\n-        assertThat(sql, containsString(\"type_id = \" + dbMappings.getTypeId(LayerInfo.class)));\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testForIdsIncludeWithOffSetDebugEnabled() {\n+        dialect.setDebugMode(true);\n+        String expected =\n+                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\nORDER BY oid LIMIT 2147483647 OFFSET 5\";\n+        String actual =\n+                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).offset(5).build();\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testForIdsIncludeWithLimitDebugEnabled() {\n+        dialect.setDebugMode(true);\n+        String expected =\n+                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\nORDER BY oid LIMIT 10\";\n+        String actual =\n+                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings).limit(10).build();\n+        assertEquals(expected, actual);\n     }\n \n     @Test\n-    public void testIsNull() {\n-        // Create the filter\n-        Filter filter = Predicates.isNull(\"name\");\n-        // Build it\n-        StringBuilder build =\n+    public void testForIdsIncludeWithOffSetAndLimitDebugEnabled() {\n+        dialect.setDebugMode(true);\n+        String expected =\n+                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\nORDER BY oid LIMIT 10 OFFSET 5\";\n+        String actual =\n                 QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n+                        .offset(5)\n+                        .limit(10)\n                         .build();\n-        String sql = build.toString();\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testForCountIncludeDebugDisabled() {\n+        String expected = \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types)\";\n+        verifyForCount(expected, false, Predicates.acceptAll());\n+    }\n+\n+    @Test\n+    public void testForCountIncludeDebugEnabled() {\n+        String expected =\n+                \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\";\n+        verifyForCount(expected, true, Predicates.acceptAll());\n+    }\n+\n+    @Test\n+    public void testForIdsIncludeDebugDisabled() {\n+        String expected = \"SELECT id FROM object WHERE type_id IN (:types) ORDER BY oid\";\n+        verifyForIds(expected, false, Predicates.acceptAll());\n+    }\n+\n+    @Test\n+    public void testForIdsIncludeDebugEnabled() {\n+        String expected =\n+                \"SELECT id FROM object WHERE type_id IN (:types) /* org.geoserver.catalog.WorkspaceInfo */\"\n+                        + \"\\nORDER BY oid\";\n+        verifyForIds(expected, true, Predicates.acceptAll());\n+    }\n+\n+    @Test\n+    public void testForCountAndIsInstanceofDebugDisabled() {\n+        String expected = \"(type_id = 14 AND 0 = 1)\";\n+        Filter filter =\n+                Predicates.and(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountAndIsInstanceofDebugEnabled() {\n+        String expected =\n+                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n+                        + \"\\n    AND\\n    0 = 1 /* EXCLUDE */\\n)\";\n+        Filter filter =\n+                Predicates.and(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForCount(expected, true, filter);\n+    }\n \n-        String sqlNull =\n-                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+    @Test\n+    public void testForIdsAndIsInstanceofDebugDisabled() {\n+        String expected = \"(type_id = 14 AND 0 = 1) \";\n+        Filter filter =\n+                Predicates.and(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsAndIsInstanceofDebugEnabled() {\n+        String expected =\n+                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n+                        + \"\\n    AND\\n    0 = 1 /* EXCLUDE */\\n) \";\n+        Filter filter =\n+                Predicates.and(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountOrIsInstanceofDebugDisabled() {\n+        String expected = \"(type_id = 14 OR 0 = 1)\";\n+        Filter filter =\n+                Predicates.or(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountOrIsInstanceofDebugEnabled() {\n+        String expected =\n+                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n+                        + \"\\n    OR\\n    0 = 1 /* EXCLUDE */\\n)\";\n+        Filter filter =\n+                Predicates.or(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsOrIsInstanceofDebugDisabled() {\n+        String expected = \"(type_id = 14 OR 0 = 1) \";\n+        Filter filter =\n+                Predicates.or(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsOrIsInstanceofDebugEnabled() {\n+        String expected =\n+                \"(\\n    type_id = 14 /* isInstanceOf org.geoserver.catalog.LayerInfo */\"\n+                        + \"\\n    OR\\n    0 = 1 /* EXCLUDE */\\n) \";\n+        Filter filter =\n+                Predicates.or(\n+                        Predicates.isInstanceOf(LayerInfo.class),\n+                        Predicates.isInstanceOf(String.class));\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsEqualToSensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0)\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsEqualToSensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsEqualToSensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsEqualToSensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) \";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsEqualToSensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\\n\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsEqualToSensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\\n\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsEqualToInsensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0)\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsEqualToInsensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsEqualToInsensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsEqualToInsensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) \";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsEqualToInsensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\\n\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsEqualToInsensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\\n\";\n+        Filter filter = FACTORY.equal(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNotEqualToSensitiveDebugDisabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0))\";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNotEqualToSensitiveDebugEnabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\\n)\";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNotEqualToSensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\\n)\";\n+        Filter filter =\n+                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotEqualToSensitiveDebugDisabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0)) \";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotEqualToSensitiveDebugEnabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = quux ] */\\n) \";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotEqualToSensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value = :value0) /* [ name = FOO*\\\\/BAR ] */\\n) \";\n+        Filter filter =\n+                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNotEqualToInsensitiveDebugDisabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0))\";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNotEqualToInsensitiveDebugEnabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\\n)\";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNotEqualToInsensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\\n)\";\n+        Filter filter =\n+                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotEqualToInsensitiveDebugDisabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0)) \";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotEqualToInsensitiveDebugEnabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = quux ] */\\n) \";\n+        Filter filter = FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"quux\"), false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotEqualToInsensitiveDebugEnabledEscaping() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) = :value0) /* [ name = FOO*\\\\/BAR ] */\\n) \";\n+        Filter filter =\n+                FACTORY.notEqual(FACTORY.property(\"name\"), FACTORY.literal(\"FOO*/BAR\"), false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeSensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0)\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeSensitiveDebugDisabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0)\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeSensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %quux% ] */\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeSensitiveDebugEnabledEscaping1() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %\\\\'FOO% ] */\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeSensitiveDebugEnabledEscaping2() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeSensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) \";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeSensitiveDebugDisabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) \";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeSensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %quux% ] */\\n\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeSensitiveDebugEnabledEscaping1() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %\\\\'FOO% ] */\\n\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeSensitiveDebugEnabledEscaping2() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND value LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\\n\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", true);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeInsensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0)\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeInsensitiveDebugDisabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0)\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForCount(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeInsensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %quux% ] */\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeInsensitiveDebugEnabledEscaping1() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %\\\\'FOO% ] */\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsLikeInsensitiveDebugEnabledEscaping2() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForCount(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeInsensitiveDebugDisabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) \";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeInsensitiveDebugDisabledEscaping() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) \";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForIds(expected, false, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeInsensitiveDebugEnabled() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %quux% ] */\\n\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%quux%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeInsensitiveDebugEnabledEscaping1() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %\\\\'FOO% ] */\\n\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%\\\\'FOO%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForIdsIsLikeInsensitiveDebugEnabledEscaping2() {\n+        String expected =\n+                \"oid IN (SELECT oid FROM object_property WHERE property_type \"\n+                        + \"IN (:ptype0) AND UPPER(value) LIKE :value0) /* [ name is like %FOO*\\\\/BAR% ] */\\n\";\n+        Filter filter = FACTORY.like(FACTORY.property(\"name\"), \"%FOO*/BAR%\", \"%\", \"_\", \"\\\\\", false);\n+        verifyForIds(expected, true, filter);\n+    }\n+\n+    @Test\n+    public void testForCountIsNullDebugDisabled() {\n+        String expected =\n+                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n                         + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n-                        + \"ptype0))\";\n-        // Ensure the following sql is present\n-        assertThat(sql, containsString(sqlNull));\n+                        + \"ptype0)))\";\n+        verifyForCount(expected, false, Predicates.isNull(\"name\"));\n     }\n \n     @Test\n-    public void testIsNil() {\n-        // Create the filter\n-        Filter filter = Predicates.isNull(\"name\");\n-        // Build it\n-        StringBuilder build =\n-                QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings)\n-                        .filter(filter)\n-                        .build();\n-        String sql = build.toString();\n+    public void testForCountIsNullDebugEnabled() {\n+        String expected =\n+                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0))) /* [ name IS NULL ] */\";\n+        verifyForCount(expected, true, Predicates.isNull(\"name\"));\n+    }\n+\n+    @Test\n+    public void testForIdsIsNullDebugDisabled() {\n+        String expected =\n+                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0))) \";\n+        verifyForIds(expected, false, Predicates.isNull(\"name\"));\n+    }\n+\n+    @Test\n+    public void testForIdsIsNullDebugEnabled() {\n+        String expected =\n+                \"(oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0))) /* [ name IS NULL ] */\\n\";\n+        verifyForIds(expected, true, Predicates.isNull(\"name\"));\n+    }\n+\n+    @Test\n+    public void testForCountIsNotNullDebugDisabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0)))\";\n+        verifyForCount(expected, false, Predicates.not(Predicates.isNull(\"name\")));\n+    }\n+\n+    @Test\n+    public void testForCountIsNotNullDebugEnabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0))) /* [ name IS NULL ] */\";\n+        verifyForCount(expected, true, Predicates.not(Predicates.isNull(\"name\")));\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotNullDebugDisabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0))) \";\n+        verifyForIds(expected, false, Predicates.not(Predicates.isNull(\"name\")));\n+    }\n+\n+    @Test\n+    public void testForIdsIsNotNullDebugEnabled() {\n+        String expected =\n+                \"NOT (oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0) AND value IS NULL) OR oid NOT IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n+                        + \"ptype0))) /* [ name IS NULL ] */\\n\";\n+        verifyForIds(expected, true, Predicates.not(Predicates.isNull(\"name\")));\n+    }\n+\n+    private void verifyForCount(String expectedSQL, boolean debugMode, Filter filter) {\n+        String expected = expectedSQL;\n+        if (!expected.startsWith(\"SELECT\")) {\n+            expected =\n+                    \"SELECT COUNT(oid) FROM object WHERE type_id IN (:types) \"\n+                            + (debugMode ? \"/* org.geoserver.catalog.WorkspaceInfo */\\n\" : \"\")\n+                            + \"AND \"\n+                            + expectedSQL;\n+        }\n+        QueryBuilder<?> builder = QueryBuilder.forCount(dialect, WorkspaceInfo.class, dbMappings);\n+        verifyQuery(builder, expected, debugMode, filter);\n+    }\n+\n+    private void verifyForIds(\n+            String expectedSQL, boolean debugMode, Filter filter, SortBy... order) {\n+        String expected = expectedSQL;\n+        if (!expected.startsWith(\"SELECT\")) {\n+            expected =\n+                    \"SELECT id FROM object WHERE type_id IN (:types) \"\n+                            + (debugMode ? \"/* org.geoserver.catalog.WorkspaceInfo */\\n\" : \"\")\n+                            + \"AND \"\n+                            + expectedSQL\n+                            + \"ORDER BY oid\";\n+        }\n+        QueryBuilder<?> builder = QueryBuilder.forIds(dialect, WorkspaceInfo.class, dbMappings);\n+        verifyQuery(builder, expected, debugMode, filter, order);\n+    }\n \n-        String sqlNil =\n-                \"oid IN (SELECT oid FROM object_property WHERE property_type IN (:\"\n-                        + \"ptype0) AND value IS NULL)\";\n-        // Ensure the following sql is present\n-        assertThat(sql, containsString(sqlNil));\n+    private void verifyQuery(\n+            QueryBuilder<?> builder,\n+            String expected,\n+            boolean debugMode,\n+            Filter filter,\n+            SortBy... order) {\n+        dialect.setDebugMode(debugMode);\n+        String actual = builder.filter(filter).sortOrder(order).build();\n+        assertEquals(expected, actual);\n+        if (Filter.INCLUDE.equals(filter)) {\n+            assertEquals(Filter.INCLUDE, builder.getSupportedFilter());\n+        } else {\n+            assertNotEquals(Filter.INCLUDE, builder.getSupportedFilter());\n+        }\n+        assertEquals(Filter.INCLUDE, builder.getUnsupportedFilter());\n+        assertEquals(!actual.startsWith(\"SELECT COUNT\"), builder.isOffsetLimitApplied());\n+        assertFalse(builder.getNamedParameters().isEmpty());\n     }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 12,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 10
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "159e5bf6afbfb9776f08cbe03d8ed09cb2d55507",
            "date": "2025-01-13T09:52:26Z",
            "author_login": "osgeoweblate"
          },
          {
            "sha": "87d9c20e47643bed223bf2a39d546b2a770c9b29",
            "date": "2025-01-13T09:01:15Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ae63d2cefb5114fec88c4831af61252fbef9dceb",
            "date": "2025-01-06T10:38:14Z",
            "author_login": "aaime"
          },
          {
            "sha": "31ed8d7da74d757bc199ed550ec52c2340781134",
            "date": "2025-01-08T11:01:24Z",
            "author_login": "aaime"
          },
          {
            "sha": "9eedb76aaa41300e4dcc0db538d26cd860ef8cc3",
            "date": "2025-01-08T04:32:41Z",
            "author_login": "jodygarnett"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-89",
    "description": "GeoServer is an open source software server written in Java that allows users to share and edit geospatial data. GeoServer includes support for the OGC Filter expression language and the OGC Common Query Language (CQL) as part of the Web Feature Service (WFS) and Web Map Service (WMS) protocols.  CQL is also supported through the Web Coverage Service (WCS) protocol for ImageMosaic coverages. Users are advised to upgrade to either version 2.21.4, or version 2.22.2 to resolve this issue. Users unable to upgrade should disable the PostGIS Datastore *encode functions* setting to mitigate ``strEndsWith``, ``strStartsWith`` and ``PropertyIsLike `` misuse and enable the PostGIS DataStore *preparedStatements* setting to mitigate the ``FeatureId`` misuse.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-21T22:15:10.620",
    "last_modified": "2024-11-21T07:49:13.160",
    "fix_date": "2023-02-13T17:43:43Z"
  },
  "references": [
    {
      "url": "https://github.com/geoserver/geoserver/commit/145a8af798590288d270b240235e89c8f0b62e1d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/geoserver/geoserver/security/advisories/GHSA-7g5f-wrx8-5ccf",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/geoserver/geoserver/commit/145a8af798590288d270b240235e89c8f0b62e1d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/geoserver/geoserver/security/advisories/GHSA-7g5f-wrx8-5ccf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.091213",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "geoserver",
    "owner": "geoserver",
    "created_at": "2011-11-10T19:56:06Z",
    "updated_at": "2025-01-13T14:27:07Z",
    "pushed_at": "2025-01-13T09:52:26Z",
    "size": 319674,
    "stars": 3917,
    "forks": 2193,
    "open_issues": 12,
    "watchers": 3917,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "2.1.x",
      "2.2.x",
      "2.3.x",
      "2.4.x",
      "2.5.x",
      "2.6.x",
      "2.6.0.x",
      "2.7.x",
      "2.7.1.x",
      "2.8.x",
      "2.9.x",
      "2.10.x",
      "2.11.x",
      "2.12.x",
      "2.13.x",
      "2.14.x",
      "2.15.x",
      "2.16.x",
      "2.17.x",
      "2.18.x",
      "2.19.x",
      "2.20.x",
      "2.21.x",
      "2.22.x",
      "2.23.x",
      "2.24.x",
      "2.25.x"
    ],
    "languages": {
      "Java": 44761611,
      "JavaScript": 1182828,
      "Scheme": 1167338,
      "HTML": 712425,
      "FreeMarker": 215786,
      "XSLT": 156026,
      "CSS": 120514,
      "Shell": 50551,
      "NSIS": 44051,
      "Python": 18317,
      "Makefile": 17825,
      "Batchfile": 13345,
      "AMPL": 8670,
      "Dockerfile": 3836,
      "Fluent": 117
    },
    "commit_activity": {
      "total_commits_last_year": 617,
      "avg_commits_per_week": 11.865384615384615,
      "days_active_last_year": 235
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:58:19.409251"
  }
}