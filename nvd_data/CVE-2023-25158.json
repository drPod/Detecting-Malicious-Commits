{
  "cve_id": "CVE-2023-25158",
  "github_data": {
    "repository": "geotools/geotools",
    "fix_commit": "64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
    "related_commits": [
      "64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
      "64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b"
    ],
    "patch_url": "https://github.com/geotools/geotools/commit/64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b.patch",
    "fix_commit_details": {
      "sha": "64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
      "commit_date": "2023-02-10T10:48:44Z",
      "author": {
        "login": "sikeoka",
        "type": "User",
        "stats": {
          "total_commits": 65,
          "average_weekly_commits": 0.09863429438543247,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 43
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-99c3-qc2q-p94m",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 784,
        "additions": 614,
        "deletions": 170
      },
      "files": [
        {
          "filename": "modules/library/jdbc/src/main/java/org/geotools/data/jdbc/FilterToSQL.java",
          "status": "modified",
          "additions": 28,
          "deletions": 12,
          "patch": "@@ -45,6 +45,7 @@\n import org.geotools.filter.function.InFunction;\n import org.geotools.filter.spatial.BBOXImpl;\n import org.geotools.jdbc.EnumMapper;\n+import org.geotools.jdbc.EscapeSql;\n import org.geotools.jdbc.JDBCDataStore;\n import org.geotools.jdbc.JoinId;\n import org.geotools.jdbc.JoinPropertyName;\n@@ -230,6 +231,9 @@ public class FilterToSQL implements FilterVisitor, ExpressionVisitor {\n     /** Whether the encoder should try to encode \"in\" function into a SQL IN operator */\n     protected boolean inEncodingEnabled = true;\n \n+    /** Whether to escape backslash characters in string literals */\n+    protected boolean escapeBackslash = false;\n+\n     /** Default constructor */\n     public FilterToSQL() {}\n \n@@ -265,6 +269,16 @@ public void setInEncodingEnabled(boolean inEncodingEnabled) {\n         this.inEncodingEnabled = inEncodingEnabled;\n     }\n \n+    /** @return whether to escape backslash characters in string literals */\n+    public boolean isEscapeBackslash() {\n+        return escapeBackslash;\n+    }\n+\n+    /** @param escapeBackslash whether to escape backslash characters in string literals */\n+    public void setEscapeBackslash(boolean escapeBackslash) {\n+        this.escapeBackslash = escapeBackslash;\n+    }\n+\n     /**\n      * Performs the encoding, sends the encoded sql to the writer passed in.\n      *\n@@ -529,7 +543,8 @@ public Object visit(PropertyIsLike filter, Object extraData) {\n             literal += multi;\n         }\n \n-        String pattern = LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal);\n+        String pattern =\n+                LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal, false);\n \n         try {\n             if (!matchCase) {\n@@ -539,13 +554,12 @@ public Object visit(PropertyIsLike filter, Object extraData) {\n             att.accept(this, extraData);\n \n             if (!matchCase) {\n-                out.write(\") LIKE '\");\n+                out.write(\") LIKE \");\n             } else {\n-                out.write(\" LIKE '\");\n+                out.write(\" LIKE \");\n             }\n \n-            out.write(pattern);\n-            out.write(\"' \");\n+            writeLiteral(pattern);\n         } catch (java.io.IOException ioe) {\n             throw new RuntimeException(IO_ERROR, ioe);\n         }\n@@ -1170,11 +1184,8 @@ public Object visit(Id filter, Object extraData) {\n                         out.write(\".\");\n                     }\n                     out.write(escapeName(columns.get(j).getName()));\n-                    out.write(\" = '\");\n-                    out.write(\n-                            attValues.get(j).toString()); // DJB: changed this to attValues[j] from\n-                    // attValues[i].\n-                    out.write(\"'\");\n+                    out.write(\" = \");\n+                    writeLiteral(attValues.get(j));\n \n                     if (j < (attValues.size() - 1)) {\n                         out.write(\" AND \");\n@@ -1747,12 +1758,17 @@ protected void writeLiteral(Object literal) throws IOException {\n                 encoding = literal.toString();\n             }\n \n-            // sigle quotes must be escaped to have a valid sql string\n-            String escaped = encoding.replaceAll(\"'\", \"''\");\n+            // single quotes must be escaped to have a valid sql string\n+            String escaped = escapeLiteral(encoding);\n             out.write(\"'\" + escaped + \"'\");\n         }\n     }\n \n+    /** Escapes the string literal. */\n+    public String escapeLiteral(String literal) {\n+        return EscapeSql.escapeLiteral(literal, escapeBackslash, false);\n+    }\n+\n     /**\n      * Subclasses must implement this method in order to encode geometry filters according to the\n      * specific database implementation"
        },
        {
          "filename": "modules/library/jdbc/src/main/java/org/geotools/jdbc/EscapeSql.java",
          "status": "modified",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -16,6 +16,8 @@\n  */\n package org.geotools.jdbc;\n \n+import java.util.regex.Pattern;\n+\n /**\n  * Perform basic SQL validation on input string. This is to allow safe encoding of parameters that\n  * must contain quotes, while still protecting users from SQL injection.\n@@ -24,6 +26,28 @@\n  * quotes. Backslashes are too risky to allow so are removed completely\n  */\n public class EscapeSql {\n+\n+    private static final Pattern SINGLE_QUOTE_PATTERN = Pattern.compile(\"'\");\n+\n+    private static final Pattern DOUBLE_QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n+\n+    private static final Pattern BACKSLASH_PATTERN = Pattern.compile(\"\\\\\\\\\");\n+\n+    public static String escapeLiteral(\n+            String literal, boolean escapeBackslash, boolean escapeDoubleQuote) {\n+        // ' --> ''\n+        String escaped = SINGLE_QUOTE_PATTERN.matcher(literal).replaceAll(\"''\");\n+        if (escapeBackslash) {\n+            // \\ --> \\\\\n+            escaped = BACKSLASH_PATTERN.matcher(escaped).replaceAll(\"\\\\\\\\\\\\\\\\\");\n+        }\n+        if (escapeDoubleQuote) {\n+            // \" --> \\\"\n+            escaped = DOUBLE_QUOTE_PATTERN.matcher(escaped).replaceAll(\"\\\\\\\\\\\"\");\n+        }\n+        return escaped;\n+    }\n+\n     public static String escapeSql(String str) {\n \n         // ' --> ''"
        },
        {
          "filename": "modules/library/jdbc/src/main/java/org/geotools/jdbc/SQLDialect.java",
          "status": "modified",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -28,6 +28,7 @@\n import java.sql.Timestamp;\n import java.sql.Types;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -39,6 +40,8 @@\n import java.util.logging.Logger;\n import org.geotools.data.Join.Type;\n import org.geotools.data.Query;\n+import org.geotools.data.jdbc.datasource.DataSourceFinder;\n+import org.geotools.data.jdbc.datasource.UnWrapper;\n import org.geotools.feature.visitor.AverageVisitor;\n import org.geotools.feature.visitor.CountVisitor;\n import org.geotools.feature.visitor.FeatureAttributeVisitor;\n@@ -164,6 +167,41 @@ public abstract class SQLDialect {\n                 }\n             };\n \n+    /**\n+     * Sentinel value used to mark that the unwrapper lookup happened already, and an unwrapper was\n+     * not found\n+     */\n+    protected static final UnWrapper UNWRAPPER_NOT_FOUND =\n+            new UnWrapper() {\n+\n+                @Override\n+                public Statement unwrap(Statement statement) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public Connection unwrap(Connection conn) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public boolean canUnwrap(Statement st) {\n+                    return false;\n+                }\n+\n+                @Override\n+                public boolean canUnwrap(Connection conn) {\n+                    return false;\n+                }\n+            };\n+\n+    /**\n+     * Map of {@code UnWrapper} objects keyed by the class of {@code Connection} it is an unwrapper\n+     * for. This avoids the overhead of searching the {@code DataSourceFinder} service registry at\n+     * each unwrap.\n+     */\n+    protected final Map<Class<? extends Connection>, UnWrapper> uwMap = new HashMap<>();\n+\n     /** The datastore using the dialect */\n     protected JDBCDataStore dataStore;\n \n@@ -1415,4 +1453,52 @@ public boolean canGroupOnGeometry() {\n     public Class<?> getMapping(String sqlTypeName) {\n         return null;\n     }\n+\n+    /** Obtains the native connection object given a database connection. */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    protected <T extends Connection> T unwrapConnection(Connection cx, Class<T> clazz)\n+            throws SQLException {\n+        if (clazz.isInstance(cx)) {\n+            return clazz.cast(cx);\n+        }\n+        try {\n+            // Unwrap the connection multiple levels as necessary to get at the underlying\n+            // connection. Maintain a map of UnWrappers to avoid searching the registry\n+            // every time we need to unwrap.\n+            Connection testCon = cx;\n+            Connection toUnwrap;\n+            do {\n+                UnWrapper unwrapper = uwMap.get(testCon.getClass());\n+                if (unwrapper == null) {\n+                    unwrapper = DataSourceFinder.getUnWrapper(testCon);\n+                    if (unwrapper == null) {\n+                        unwrapper = UNWRAPPER_NOT_FOUND;\n+                    }\n+                    uwMap.put(testCon.getClass(), unwrapper);\n+                }\n+                if (unwrapper == UNWRAPPER_NOT_FOUND) {\n+                    // give up and do Java unwrap below\n+                    break;\n+                }\n+                toUnwrap = testCon;\n+                testCon = unwrapper.unwrap(testCon);\n+                if (clazz.isInstance(testCon)) {\n+                    return clazz.cast(cx);\n+                }\n+            } while (testCon != null && testCon != toUnwrap);\n+            // try to use Java unwrapping\n+            try {\n+                if (cx.isWrapperFor(clazz)) {\n+                    return cx.unwrap(clazz);\n+                }\n+            } catch (Throwable t) {\n+                // not a mistake, old DBCP versions will throw an Error here, we need to catch it\n+                LOGGER.log(Level.FINER, \"Failed to unwrap connection using Java facilities\", t);\n+            }\n+        } catch (IOException e) {\n+            throw new SQLException(\n+                    \"Could not obtain \" + clazz.getName() + \" from \" + cx.getClass(), e);\n+        }\n+        throw new SQLException(\"Could not obtain \" + clazz.getName() + \" from \" + cx.getClass());\n+    }\n }"
        },
        {
          "filename": "modules/library/jdbc/src/test/java/org/geotools/data/jdbc/FilterToSQLTest.java",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -465,4 +465,18 @@ public void testEscapeName() {\n         encoder.setSqlNameEscape(\"\");\n         Assert.assertEquals(\"abc\", encoder.escapeName(\"abc\"));\n     }\n+\n+    @Test\n+    public void testLikeEscaping() throws Exception {\n+        Filter filter = ff.like(ff.property(\"testString\"), \"\\\\'FOO\", \"%\", \"-\", \"\\\\\", true);\n+        FilterToSQL encoder = new FilterToSQL(output);\n+        Assert.assertEquals(\"WHERE testString LIKE '''FOO'\", encoder.encodeToString(filter));\n+    }\n+\n+    @Test\n+    public void testIdEscaping() throws Exception {\n+        Id id = ff.id(Collections.singleton(ff.featureId(\"'FOO\")));\n+        encoder.encode(id);\n+        Assert.assertEquals(\"WHERE (id = '''FOO')\", output.toString());\n+    }\n }"
        },
        {
          "filename": "modules/library/main/src/main/java/org/geotools/filter/LikeFilterImpl.java",
          "status": "modified",
          "additions": 41,
          "deletions": 3,
          "patch": "@@ -79,13 +79,49 @@ public class LikeFilterImpl extends AbstractFilter implements PropertyIsLike {\n      * have a special char as another special char. Using this will throw an error\n      * (IllegalArgumentException).\n      */\n+    @Deprecated\n     public static String convertToSQL92(\n             char escape, char multi, char single, boolean matchCase, String pattern)\n             throws IllegalArgumentException {\n+        return convertToSQL92(escape, multi, single, matchCase, pattern, true);\n+    }\n+\n+    /**\n+     * Given OGC PropertyIsLike Filter information, construct an SQL-compatible 'like' pattern.\n+     *\n+     * <p>SQL % --> match any number of characters _ --> match a single character\n+     *\n+     * <p>NOTE; the SQL command is 'string LIKE pattern [ESCAPE escape-character]' We could\n+     * re-define the escape character, but I'm not doing to do that in this code since some\n+     * databases will not handle this case.\n+     *\n+     * <p>Method: 1.\n+     *\n+     * <p>Examples: ( escape ='!', multi='*', single='.' ) broadway* -> 'broadway%' broad_ay ->\n+     * 'broad_ay' broadway -> 'broadway'\n+     *\n+     * <p>broadway!* -> 'broadway*' (* has no significance and is escaped) can't -> 'can''t' ( '\n+     * escaped for SQL compliance)\n+     *\n+     * <p>NOTE: when the escapeSingleQuote parameter is false, this method will not convert ' to ''\n+     * (double single quote) and it is the caller's responsibility to ensure that the resulting\n+     * pattern is used safely in SQL queries.\n+     *\n+     * <p>NOTE: we dont handle \"'\" as a 'special' character because it would be too confusing to\n+     * have a special char as another special char. Using this will throw an error\n+     * (IllegalArgumentException).\n+     */\n+    public static String convertToSQL92(\n+            char escape,\n+            char multi,\n+            char single,\n+            boolean matchCase,\n+            String pattern,\n+            boolean escapeSingleQuote) {\n         if ((escape == '\\'') || (multi == '\\'') || (single == '\\''))\n             throw new IllegalArgumentException(\"do not use single quote (') as special char!\");\n \n-        StringBuffer result = new StringBuffer(pattern.length() + 5);\n+        StringBuilder result = new StringBuilder(pattern.length() + 5);\n         for (int i = 0; i < pattern.length(); i++) {\n             char chr = pattern.charAt(i);\n             if (chr == escape) {\n@@ -96,7 +132,7 @@ public static String convertToSQL92(\n                 result.append('_');\n             } else if (chr == multi) {\n                 result.append('%');\n-            } else if (chr == '\\'') {\n+            } else if (chr == '\\'' && escapeSingleQuote) {\n                 result.append('\\'');\n                 result.append('\\'');\n             } else {\n@@ -108,6 +144,7 @@ public static String convertToSQL92(\n     }\n \n     /** see convertToSQL92 */\n+    @Deprecated\n     public String getSQL92LikePattern() throws IllegalArgumentException {\n         if (escape.length() != 1) {\n             throw new IllegalArgumentException(\n@@ -126,7 +163,8 @@ public String getSQL92LikePattern() throws IllegalArgumentException {\n                 wildcardMulti.charAt(0),\n                 wildcardSingle.charAt(0),\n                 matchingCase,\n-                pattern);\n+                pattern,\n+                true);\n     }\n \n     public void setWildCard(String wildCard) {"
        },
        {
          "filename": "modules/library/main/src/test/java/org/geotools/filter/FilterTest.java",
          "status": "modified",
          "additions": 18,
          "deletions": 10,
          "patch": "@@ -187,29 +187,37 @@ public void setUp() throws SchemaException {\n     @Test\n     public void testLikeToSQL() {\n         Assert.assertEquals(\n-                \"BroadWay%\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"BroadWay*\"));\n+                \"BroadWay%\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"BroadWay*\", true));\n         Assert.assertEquals(\n-                \"broad#ay\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broad#ay\"));\n+                \"broad#ay\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broad#ay\", true));\n         Assert.assertEquals(\n-                \"broadway\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway\"));\n+                \"broadway\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway\", true));\n \n         Assert.assertEquals(\n-                \"broad_ay\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broad.ay\"));\n+                \"broad_ay\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broad.ay\", true));\n         Assert.assertEquals(\n-                \"broad.ay\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broad!.ay\"));\n+                \"broad.ay\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broad!.ay\", true));\n \n         Assert.assertEquals(\n-                \"broa''dway\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broa'dway\"));\n+                \"broa''dway\",\n+                LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broa'dway\", true));\n         Assert.assertEquals(\n                 \"broa''''dway\",\n-                LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broa\" + \"''dway\"));\n+                LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broa\" + \"''dway\", true));\n+        Assert.assertEquals(\n+                \"broa'dway\",\n+                LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broa'dway\", false));\n+        Assert.assertEquals(\n+                \"broa''dway\",\n+                LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broa\" + \"''dway\", false));\n \n         Assert.assertEquals(\n-                \"broadway_\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway.\"));\n+                \"broadway_\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway.\", true));\n         Assert.assertEquals(\n-                \"broadway\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway!\"));\n+                \"broadway\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway!\", true));\n         Assert.assertEquals(\n-                \"broadway!\", LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway!!\"));\n+                \"broadway!\",\n+                LikeFilterImpl.convertToSQL92('!', '*', '.', true, \"broadway!!\", true));\n     }\n \n     /**"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-mysql/src/main/java/org/geotools/data/mysql/MySQLDialectBasic.java",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -246,7 +246,12 @@ public void applyLimitOffset(StringBuffer sql, int limit, int offset) {\n \n     @Override\n     public FilterToSQL createFilterToSQL() {\n-        return new MySQLFilterToSQL(delegate.getUsePreciseSpatialOps());\n+        MySQLFilterToSQL fts = new MySQLFilterToSQL(delegate.getUsePreciseSpatialOps());\n+        // see https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_backslash_escapes\n+        // NOTE: for future enhancement, do not escape backslashes when the NO_BACKSLASH_ESCAPES\n+        // mode is enabled since that would create an incorrect string in the SQL\n+        fts.setEscapeBackslash(true);\n+        return fts;\n     }\n \n     @Override"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-mysql/src/test/java/org/geotools/data/mysql/MySQLFilterToSQLTest.java",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2023, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.data.mysql;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.geotools.data.jdbc.SQLFilterTestSupport;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.SchemaException;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.PropertyIsEqualTo;\n+\n+public class MySQLFilterToSQLTest extends SQLFilterTestSupport {\n+\n+    private static FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();\n+\n+    private MySQLFilterToSQL filterToSql;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws SchemaException {\n+        filterToSql = (MySQLFilterToSQL) new MySQLDialectBasic(null).createFilterToSQL();\n+        filterToSql.setFeatureType(testSchema);\n+    }\n+\n+    @Test\n+    public void testEncodeEqualToWithSpecialCharacters() throws Exception {\n+        PropertyIsEqualTo expr = ff.equals(ff.property(\"testString\"), ff.literal(\"\\\\'FOO\"));\n+        String actual = filterToSql.encodeToString(expr);\n+        assertEquals(\"WHERE testString = '\\\\\\\\''FOO'\", actual);\n+    }\n+}"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-oracle/src/main/java/org/geotools/data/oracle/OracleDialect.java",
          "status": "modified",
          "additions": 1,
          "deletions": 93,
          "patch": "@@ -26,7 +26,6 @@\n import java.sql.Statement;\n import java.sql.Struct;\n import java.sql.Types;\n-import java.sql.Wrapper;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -41,8 +40,6 @@\n import oracle.jdbc.OracleConnection;\n import oracle.jdbc.OracleStruct;\n import org.geotools.data.jdbc.FilterToSQL;\n-import org.geotools.data.jdbc.datasource.DataSourceFinder;\n-import org.geotools.data.jdbc.datasource.UnWrapper;\n import org.geotools.data.oracle.sdo.GeometryConverter;\n import org.geotools.data.oracle.sdo.SDOSqlDumper;\n import org.geotools.data.oracle.sdo.TT;\n@@ -84,34 +81,6 @@\n  */\n public class OracleDialect extends PreparedStatementSQLDialect {\n \n-    /**\n-     * Sentinel value used to mark that the unwrapper lookup happened already, and an unwrapper was\n-     * not found\n-     */\n-    UnWrapper UNWRAPPER_NOT_FOUND =\n-            new UnWrapper() {\n-\n-                @Override\n-                public Statement unwrap(Statement statement) {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                @Override\n-                public Connection unwrap(Connection conn) {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                @Override\n-                public boolean canUnwrap(Statement st) {\n-                    return false;\n-                }\n-\n-                @Override\n-                public boolean canUnwrap(Connection conn) {\n-                    return false;\n-                }\n-            };\n-\n     private static final int DEFAULT_AXIS_MAX = 10000000;\n \n     private static final int DEFAULT_AXIS_MIN = -10000000;\n@@ -121,13 +90,6 @@ public boolean canUnwrap(Connection conn) {\n     /** Marks a geometry column as geodetic */\n     public static final String GEODETIC = \"geodetic\";\n \n-    /**\n-     * Map of {@code UnWrapper} objects keyed by the class of {@code Connection} it is an unwrapper\n-     * for. This avoids the overhead of searching the {@code DataSourceFinder} service registry at\n-     * each unwrap.\n-     */\n-    Map<Class<? extends Connection>, UnWrapper> uwMap = new HashMap<>();\n-\n     private int nameLenghtLimit = 30;\n \n     /**\n@@ -653,62 +615,8 @@ public void setGeometryValue(\n     }\n \n     /** Obtains the native oracle connection object given a database connection. */\n-    @SuppressWarnings(\"PMD.CloseResource\")\n     OracleConnection unwrapConnection(Connection cx) throws SQLException {\n-        if (cx == null) {\n-            return null;\n-        }\n-\n-        if (cx instanceof OracleConnection) {\n-            return (OracleConnection) cx;\n-        }\n-\n-        try {\n-            // Unwrap the connection multiple levels as necessary to get at the underlying\n-            // OracleConnection. Maintain a map of UnWrappers to avoid searching\n-            // the registry every time we need to unwrap.\n-            Connection testCon = cx;\n-            Connection toUnwrap;\n-            do {\n-                UnWrapper unwrapper = uwMap.get(testCon.getClass());\n-                if (unwrapper == null) {\n-                    unwrapper = DataSourceFinder.getUnWrapper(testCon);\n-                    if (unwrapper == null) {\n-                        unwrapper = UNWRAPPER_NOT_FOUND;\n-                    }\n-                    uwMap.put(testCon.getClass(), unwrapper);\n-                }\n-                if (unwrapper == UNWRAPPER_NOT_FOUND) {\n-                    // give up and do Java 6 unwrap below\n-                    break;\n-                }\n-                toUnwrap = testCon;\n-                testCon = unwrapper.unwrap(testCon);\n-                if (testCon instanceof OracleConnection) {\n-                    return (OracleConnection) testCon;\n-                }\n-            } while (testCon != null && testCon != toUnwrap);\n-\n-            if (cx instanceof Wrapper) {\n-                // try to use java 6 unwrapping\n-                try {\n-                    Wrapper w = cx;\n-                    if (w.isWrapperFor(OracleConnection.class)) {\n-                        return w.unwrap(OracleConnection.class);\n-                    }\n-                } catch (Throwable t) {\n-                    // not a mistake, old DBCP versions will throw an Error here, we need to catch\n-                    // it\n-                    LOGGER.log(\n-                            Level.FINER, \"Failed to unwrap connection using java 6 facilities\", t);\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw (SQLException)\n-                    new SQLException(\"Could not obtain native oracle connection.\").initCause(e);\n-        }\n-\n-        throw new SQLException(\"Could not obtain native oracle connection for \" + cx.getClass());\n+        return unwrapConnection(cx, OracleConnection.class);\n     }\n \n     public FilterToSQL createFilterToSQL() {"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-oracle/src/main/java/org/geotools/data/oracle/OracleFilterToSQL.java",
          "status": "modified",
          "additions": 6,
          "deletions": 5,
          "patch": "@@ -546,9 +546,10 @@ protected void doSDODistance(\n         e2.accept(this, extraData);\n \n         // encode the unit verbatim when available\n-        if (unit != null && !\"\".equals(unit.trim()))\n+        if (unit != null && !\"\".equals(unit.trim())) {\n+            unit = escapeLiteral(unit);\n             out.write(\",'distance=\" + distance + \" unit=\" + unit + \"') = '\" + within + \"' \");\n-        else out.write(\",'distance=\" + distance + \"') = '\" + within + \"' \");\n+        } else out.write(\",'distance=\" + distance + \"') = '\" + within + \"' \");\n     }\n \n     /**\n@@ -625,10 +626,10 @@ public String jsonExists(Function function) {\n \n         String[] pointers = jsonPath.getValue().toString().split(\"/\");\n         if (pointers.length > 0) {\n-            String strJsonPath = String.join(\".\", pointers);\n+            String strJsonPath = escapeLiteral(String.join(\".\", pointers));\n+            String strExpected = escapeLiteral(expected.evaluate(null, String.class));\n             return String.format(\n-                    \"json_exists(%s, '$%s?(@ == \\\"%s\\\")')\",\n-                    columnName, strJsonPath, expected.evaluate(null));\n+                    \"json_exists(%s, '$%s?(@ == \\\"%s\\\")')\", columnName, strJsonPath, strExpected);\n         } else {\n             throw new IllegalArgumentException(\n                     \"Cannot encode filter Invalid pointer \" + jsonPath.getValue());"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-oracle/src/test/java/org/geotools/data/oracle/OracleFilterToSqlTest.java",
          "status": "modified",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -161,6 +161,18 @@ public void testDWithinFilterWithUnit() throws Exception {\n                 \"WHERE SDO_WITHIN_DISTANCE(\\\"GEOM\\\",?,'distance=10.0 unit=km') = 'TRUE' \", encoded);\n     }\n \n+    @Test\n+    public void testDWithinFilterWithUnitEscaping() throws Exception {\n+        Coordinate coordinate = new Coordinate();\n+        DWithin dwithin =\n+                ff.dwithin(\n+                        ff.property(\"GEOM\"), ff.literal(gf.createPoint(coordinate)), 10.0, \"'FOO\");\n+        String encoded = encoder.encodeToString(dwithin);\n+        assertEquals(\n+                \"WHERE SDO_WITHIN_DISTANCE(\\\"GEOM\\\",?,'distance=10.0 unit=''FOO') = 'TRUE' \",\n+                encoded);\n+    }\n+\n     @Test\n     public void testDWithinFilterWithoutUnit() throws Exception {\n         Coordinate coordinate = new Coordinate();\n@@ -210,6 +222,34 @@ public void testJsonArrayContainsNestedObject() throws Exception {\n                 \"WHERE json_exists(operations, '$.operations.parameters?(@ == \\\"1\\\")')\", encoded);\n     }\n \n+    @Test\n+    public void testFunctionJsonArrayContainsEscapingPointer() throws Exception {\n+        Function function =\n+                ff.function(\n+                        \"jsonArrayContains\",\n+                        ff.property(\"operations\"),\n+                        ff.literal(\"/'FOO\"),\n+                        ff.literal(1));\n+        Filter filter = ff.equals(function, ff.literal(true));\n+        String encoded = encoder.encodeToString(filter);\n+        assertEquals(\"WHERE json_exists(operations, '$.''FOO?(@ == \\\"1\\\")')\", encoded);\n+    }\n+\n+    @Test\n+    public void testFunctionJsonArrayContainsEscapingExpected() throws Exception {\n+        Function function =\n+                ff.function(\n+                        \"jsonArrayContains\",\n+                        ff.property(\"operations\"),\n+                        ff.literal(\"/operations/parameters\"),\n+                        ff.literal(\"'FOO\"));\n+        Filter filter = ff.equals(function, ff.literal(true));\n+        String encoded = encoder.encodeToString(filter);\n+        assertEquals(\n+                \"WHERE json_exists(operations, '$.operations.parameters?(@ == \\\"''FOO\\\")')\",\n+                encoded);\n+    }\n+\n     // THIS ONE WON'T PASS RIGHT NOW, BUT WE NEED TO PUT A TEST LIKE THIS\n     // SOMEHWERE\n     // THAT IS, SOMETHING CHECKING THAT TYPED FIDS GET CONVERTED INTO THE PROPER"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-postgis/src/main/java/org/geotools/data/postgis/FilterToSqlHelper.java",
          "status": "modified",
          "additions": 28,
          "deletions": 43,
          "patch": "@@ -25,7 +25,6 @@\n import java.sql.Time;\n import java.sql.Timestamp;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.TimeUnit;\n import java.util.function.BiConsumer;\n@@ -65,6 +64,7 @@\n import org.geotools.filter.function.math.FilterFunction_ceil;\n import org.geotools.filter.function.math.FilterFunction_floor;\n import org.geotools.geometry.jts.JTS;\n+import org.geotools.jdbc.EscapeSql;\n import org.geotools.jdbc.JDBCDataStore;\n import org.geotools.jdbc.PreparedFilterToSQL;\n import org.geotools.jdbc.PrimaryKeyColumn;\n@@ -569,30 +569,18 @@ public boolean visitFunction(Function function, Object extraData) throws IOExcep\n \n             out.write(\"(\");\n             str.accept(delegate, String.class);\n-            out.write(\" LIKE \");\n-            if (end instanceof Literal) {\n-                out.write(\"'%\" + end.evaluate(null, String.class) + \"'\");\n-            } else {\n-                out.write(\"('%' || \");\n-                end.accept(delegate, String.class);\n-                out.write(\")\");\n-            }\n-            out.write(\")\");\n+            out.write(\" LIKE ('%' || \");\n+            end.accept(delegate, String.class);\n+            out.write(\"))\");\n         } else if (function instanceof FilterFunction_strStartsWith) {\n             Expression str = getParameter(function, 0, true);\n             Expression start = getParameter(function, 1, true);\n \n             out.write(\"(\");\n             str.accept(delegate, String.class);\n-            out.write(\" LIKE \");\n-            if (start instanceof Literal) {\n-                out.write(\"'\" + start.evaluate(null, String.class) + \"%'\");\n-            } else {\n-                out.write(\"(\");\n-                start.accept(delegate, String.class);\n-                out.write(\" || '%')\");\n-            }\n-            out.write(\")\");\n+            out.write(\" LIKE (\");\n+            start.accept(delegate, String.class);\n+            out.write(\" || '%'))\");\n         } else if (function instanceof FilterFunction_strEqualsIgnoreCase) {\n             Expression first = getParameter(function, 0, true);\n             Expression second = getParameter(function, 1, true);\n@@ -703,45 +691,42 @@ private void encodeJsonPointer(Function jsonPointer, Object extraData) throws IO\n         }\n     }\n \n-    public String buildJsonFromStrPointer(String[] pointers, Expression expectedExp) {\n-        if (!\"\".equals(pointers[0])) {\n-            if (pointers.length == 1) {\n-                final String expected =\n-                        getBaseType(expectedExp).isAssignableFrom(String.class)\n-                                ? String.format(\n-                                        \"\\\"%s\\\"\", ((Literal) expectedExp).getValue().toString())\n-                                : ((Literal) expectedExp).getValue().toString();\n-                return String.format(\"\\\"%s\\\": [%s]\", pointers[0], expected);\n-            } else {\n-                return String.format(\n-                        \"\\\"%s\\\": { %s }\",\n-                        pointers[0],\n-                        buildJsonFromStrPointer(\n-                                Arrays.copyOfRange(pointers, 1, pointers.length), expectedExp));\n+    public String buildJsonFromStrPointer(String[] pointers, int index, Expression expected) {\n+        if (pointers[index].isEmpty()) {\n+            return buildJsonFromStrPointer(pointers, index + 1, expected);\n+        } else if (index == pointers.length - 1) {\n+            String strExpected = escapeJsonLiteral(expected.evaluate(null, String.class));\n+            if (getBaseType(expected).isAssignableFrom(String.class)) {\n+                strExpected = '\"' + strExpected + '\"';\n             }\n-        } else\n-            return buildJsonFromStrPointer(\n-                    Arrays.copyOfRange(pointers, 1, pointers.length), expectedExp);\n+            return String.format(\"\\\"%s\\\": [%s]\", pointers[index], strExpected);\n+        } else {\n+            String jsonPointers = buildJsonFromStrPointer(pointers, index + 1, expected);\n+            return String.format(\"\\\"%s\\\": { %s }\", pointers[index], jsonPointers);\n+        }\n     }\n \n     private void encodeJsonArrayContains(Function jsonArrayContains) throws IOException {\n         PropertyName column = (PropertyName) getParameter(jsonArrayContains, 0, true);\n         Literal jsonPath = (Literal) getParameter(jsonArrayContains, 1, true);\n         Expression expected = getParameter(jsonArrayContains, 2, true);\n \n-        String[] strJsonPath = jsonPath.getValue().toString().split(\"/\");\n+        String[] strJsonPath = escapeJsonLiteral(jsonPath.getValue().toString()).split(\"/\");\n         if (strJsonPath.length > 0) {\n-            String jsonFilter =\n-                    String.format(\"{ %s }\", buildJsonFromStrPointer(strJsonPath, expected));\n-            out.write(\n-                    String.format(\n-                            \"\\\"%s\\\"::jsonb @> '%s'::jsonb\", column.getPropertyName(), jsonFilter));\n+            column.accept(delegate, null);\n+            out.write(\"::jsonb @> '{ \");\n+            out.write(buildJsonFromStrPointer(strJsonPath, 0, expected));\n+            out.write(\" }'::jsonb\");\n         } else {\n             throw new IllegalArgumentException(\n                     \"Cannot encode filter Invalid pointer \" + jsonPath.getValue());\n         }\n     }\n \n+    private static String escapeJsonLiteral(String literal) {\n+        return EscapeSql.escapeLiteral(literal, true, true);\n+    }\n+\n     Expression getParameter(Function function, int idx, boolean mandatory) {\n         final List<Expression> params = function.getParameters();\n         if (params == null || params.size() <= idx) {"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-postgis/src/main/java/org/geotools/data/postgis/PostGISDialect.java",
          "status": "modified",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -82,6 +82,7 @@\n import org.opengis.filter.expression.Literal;\n import org.opengis.referencing.FactoryException;\n import org.opengis.referencing.crs.CoordinateReferenceSystem;\n+import org.postgresql.jdbc.PgConnection;\n \n public class PostGISDialect extends BasicSQLDialect {\n \n@@ -211,6 +212,9 @@ public PostGISDialect(JDBCDataStore dataStore) {\n \n     boolean topologyPreserved = false;\n \n+    // checkStandardConformingStrings will set this based on database configuration\n+    boolean escapeBackslash = true;\n+\n     Version version, pgsqlVersion;\n \n     public boolean isLooseBBOXEnabled() {\n@@ -250,6 +254,10 @@ public boolean isSimplifyEnabled() {\n         return simplifyEnabled;\n     }\n \n+    public boolean isEscapeBackslash() {\n+        return escapeBackslash;\n+    }\n+\n     @Override\n     public boolean canSimplifyPoints() {\n         // TWKB encoding is a form of simplified points representation (reduced precision)\n@@ -283,6 +291,7 @@ public void initializeConnection(Connection cx) throws SQLException {\n         super.initializeConnection(cx);\n         getPostgreSQLVersion(cx);\n         getVersion(cx);\n+        checkStandardConformingStrings(cx);\n     }\n \n     @Override\n@@ -1384,6 +1393,7 @@ public FilterToSQL createFilterToSQL() {\n         sql.setLooseBBOXEnabled(looseBBOXEnabled);\n         sql.setEncodeBBOXFilterAsEnvelope(encodeBBOXFilterAsEnvelope);\n         sql.setFunctionEncodingEnabled(functionEncodingEnabled);\n+        sql.setEscapeBackslash(escapeBackslash);\n         return sql;\n     }\n \n@@ -1517,6 +1527,40 @@ public Version getPostgreSQLVersion(Connection conn) throws SQLException {\n         return pgsqlVersion;\n     }\n \n+    /**\n+     * Determines whether or not to escape backslashes based on the PostgreSQL server's\n+     * standard_conforming_strings setting.\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private void checkStandardConformingStrings(Connection conn) throws SQLException {\n+        Boolean escape = null;\n+        // first, try to determine the setting from a native connection object\n+        try {\n+            PgConnection bc = unwrapConnection(conn, PgConnection.class);\n+            escape = !bc.getStandardConformingStrings();\n+        } catch (SQLException e) {\n+            LOGGER.log(Level.FINER, \"Unable to get native connection; falling back to query\", e);\n+        }\n+        // otherwise, try to determine the setting from a database query\n+        if (escape == null) {\n+            Statement st = null;\n+            ResultSet rs = null;\n+            try {\n+                st = conn.createStatement();\n+                rs = st.executeQuery(\"SHOW standard_conforming_strings\");\n+                escape = !rs.next() || !\"on\".equals(rs.getString(1));\n+            } catch (SQLException e) {\n+                LOGGER.warning(\n+                        \"Unable to check standard_conforming_strings setting: \" + e.getMessage());\n+            } finally {\n+                dataStore.closeSafe(rs);\n+                dataStore.closeSafe(st);\n+            }\n+        }\n+        // default to escape backslashes if both checks failed\n+        escapeBackslash = !Boolean.FALSE.equals(escape);\n+    }\n+\n     /** Returns true if the PostGIS version is >= 1.5.0 */\n     boolean supportsGeography(Connection cx) throws SQLException {\n         return getVersion(cx).compareTo(V_1_5_0) >= 0;"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-postgis/src/main/java/org/geotools/data/postgis/PostGISPSDialect.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -263,6 +263,7 @@ public PreparedFilterToSQL createPreparedFilterToSQL() {\n         fts.setFunctionEncodingEnabled(delegate.isFunctionEncodingEnabled());\n         fts.setLooseBBOXEnabled(delegate.isLooseBBOXEnabled());\n         fts.setEncodeBBOXFilterAsEnvelope(delegate.isEncodeBBOXFilterAsEnvelope());\n+        fts.setEscapeBackslash(delegate.isEscapeBackslash());\n         return fts;\n     }\n "
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-postgis/src/main/java/org/geotools/data/postgis/PostgisNGDataStoreFactory.java",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -29,6 +29,7 @@\n import java.util.logging.Logger;\n import javax.sql.DataSource;\n import org.geotools.data.Parameter;\n+import org.geotools.data.Transaction;\n import org.geotools.jdbc.JDBCDataStore;\n import org.geotools.jdbc.JDBCDataStoreFactory;\n import org.geotools.jdbc.SQLDialect;\n@@ -259,6 +260,15 @@ protected JDBCDataStore createDataStoreInternal(JDBCDataStore dataStore, Map<Str\n         }\n         dialect.setEncodeBBOXFilterAsEnvelope(Boolean.TRUE.equals(encodeBBOXAsEnvelope));\n \n+        Connection cx = dataStore.getConnection(Transaction.AUTO_COMMIT);\n+        try {\n+            // creating a new connection will internally call\n+            // org.geotools.data.postgis.PostGISDialect.initializeConnection(Connection)\n+            // the following line is really just to prevent empty try block PMD violation\n+            LOGGER.finest(\"escaping backslashes: \" + dialect.isEscapeBackslash());\n+        } finally {\n+            dataStore.closeSafe(cx);\n+        }\n         return dataStore;\n     }\n "
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-postgis/src/test/java/org/geotools/data/postgis/PostgisFilterToSQLTest.java",
          "status": "modified",
          "additions": 56,
          "deletions": 3,
          "patch": "@@ -235,6 +235,31 @@ public void testEncodeEqualToArraysAll() throws Exception {\n         assertEquals(\"where testarray = array['1', '2', '3']\", sql);\n     }\n \n+    @Test\n+    public void testFunctionStrEndsWithEscaping() throws Exception {\n+        filterToSql.setFeatureType(testSchema);\n+        Filter filter =\n+                ff.equals(\n+                        ff.literal(true),\n+                        ff.function(\"strEndsWith\", ff.property(\"testString\"), ff.literal(\"'FOO\")));\n+        filterToSql.encode(filter);\n+        String sql = writer.toString();\n+        assertEquals(\"WHERE true = (testString LIKE ('%' || '''FOO'))\", sql);\n+    }\n+\n+    @Test\n+    public void testFunctionStrStartsWithEscaping() throws Exception {\n+        filterToSql.setFeatureType(testSchema);\n+        Filter filter =\n+                ff.equals(\n+                        ff.literal(true),\n+                        ff.function(\n+                                \"strStartsWith\", ff.property(\"testString\"), ff.literal(\"'FOO\")));\n+        filterToSql.encode(filter);\n+        String sql = writer.toString();\n+        assertEquals(\"WHERE true = (testString LIKE ('''FOO' || '%'))\", sql);\n+    }\n+\n     @Test\n     public void testFunctionLike() throws Exception {\n         filterToSql.setFeatureType(testSchema);\n@@ -299,7 +324,7 @@ public void testFunctionJsonArrayContains() throws Exception {\n                         ff.literal(\"OP1\"));\n         filterToSql.encode(pointer);\n         String sql = writer.toString().trim();\n-        assertEquals(\"\\\"OPERATIONS\\\"::jsonb @> '{ \\\"operations\\\": [\\\"OP1\\\"] }'::jsonb\", sql);\n+        assertEquals(\"OPERATIONS::jsonb @> '{ \\\"operations\\\": [\\\"OP1\\\"] }'::jsonb\", sql);\n     }\n \n     @Test\n@@ -313,7 +338,7 @@ public void testFunctionJsonArrayContainsNumber() throws Exception {\n                         ff.literal(1));\n         filterToSql.encode(pointer);\n         String sql = writer.toString().trim();\n-        assertEquals(\"\\\"OPERATIONS\\\"::jsonb @> '{ \\\"operations\\\": [1] }'::jsonb\", sql);\n+        assertEquals(\"OPERATIONS::jsonb @> '{ \\\"operations\\\": [1] }'::jsonb\", sql);\n     }\n \n     @Test\n@@ -328,7 +353,35 @@ public void testNestedObjectJsonArrayContains() throws Exception {\n         filterToSql.encode(pointer);\n         String sql = writer.toString().trim();\n         assertEquals(\n-                \"\\\"OPERATIONS\\\"::jsonb @> '{ \\\"operations\\\": { \\\"parameters\\\": [\\\"P1\\\"] } }'::jsonb\",\n+                \"OPERATIONS::jsonb @> '{ \\\"operations\\\": { \\\"parameters\\\": [\\\"P1\\\"] } }'::jsonb\",\n                 sql);\n     }\n+\n+    @Test\n+    public void testFunctionJsonArrayContainsEscapingPointer() throws Exception {\n+        filterToSql.setFeatureType(testSchema);\n+        Function pointer =\n+                ff.function(\n+                        \"jsonArrayContains\",\n+                        ff.property(\"OPERATIONS\"),\n+                        ff.literal(\"/\\\"'FOO\"),\n+                        ff.literal(\"OP1\"));\n+        filterToSql.encode(pointer);\n+        String sql = writer.toString().trim();\n+        assertEquals(\"OPERATIONS::jsonb @> '{ \\\"\\\\\\\"''FOO\\\": [\\\"OP1\\\"] }'::jsonb\", sql);\n+    }\n+\n+    @Test\n+    public void testFunctionJsonArrayContainsEscapingExpected() throws Exception {\n+        filterToSql.setFeatureType(testSchema);\n+        Function pointer =\n+                ff.function(\n+                        \"jsonArrayContains\",\n+                        ff.property(\"OPERATIONS\"),\n+                        ff.literal(\"/operations\"),\n+                        ff.literal(\"\\\"'FOO\"));\n+        filterToSql.encode(pointer);\n+        String sql = writer.toString().trim();\n+        assertEquals(\"OPERATIONS::jsonb @> '{ \\\"operations\\\": [\\\"\\\\\\\"''FOO\\\"] }'::jsonb\", sql);\n+    }\n }"
        },
        {
          "filename": "modules/plugin/jdbc/jdbc-postgis/src/test/java/org/geotools/data/postgis/PostgisNGDataStoreFactoryTest.java",
          "status": "added",
          "additions": 163,
          "deletions": 0,
          "patch": "@@ -0,0 +1,163 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2023, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.data.postgis;\n+\n+import static org.geotools.data.postgis.PostgisNGDataStoreFactory.PREPARED_STATEMENTS;\n+import static org.geotools.jdbc.JDBCDataStoreFactory.DATASOURCE;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.sql.DataSource;\n+import org.geotools.jdbc.JDBCDataStore;\n+import org.geotools.jdbc.SQLDialect;\n+import org.geotools.util.Version;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.postgresql.jdbc.PgConnection;\n+\n+public class PostgisNGDataStoreFactoryTest {\n+\n+    @Mock private DataSource ds = null;\n+\n+    @Mock private Connection conn = null;\n+\n+    @Mock private PgConnection pgConn = null;\n+\n+    @Mock private DatabaseMetaData md = null;\n+\n+    @Mock private Statement st1 = null;\n+\n+    @Mock private Statement st2 = null;\n+\n+    @Mock private ResultSet rs1 = null;\n+\n+    @Mock private ResultSet rs2 = null;\n+\n+    private JDBCDataStore store = null;\n+\n+    private AutoCloseable mocks = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.mocks = MockitoAnnotations.openMocks(this);\n+        when(this.ds.getConnection()).thenReturn(this.conn);\n+        when(this.conn.getMetaData()).thenReturn(this.md);\n+        when(this.md.getDatabaseMajorVersion()).thenReturn(15);\n+        when(this.md.getDatabaseMinorVersion()).thenReturn(1);\n+        when(this.conn.createStatement()).thenReturn(this.st1, this.st2);\n+        when(this.st1.executeQuery(\"select PostGIS_Lib_Version()\")).thenReturn(this.rs1);\n+        when(this.rs1.next()).thenReturn(true);\n+        when(this.rs1.getString(1)).thenReturn(\"3.3.2\");\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        if (this.mocks != null) {\n+            this.mocks.close();\n+            this.mocks = null;\n+        }\n+        if (this.store != null) {\n+            this.store.dispose();\n+        }\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOnFromConnection() throws Exception {\n+        verifyFilterToSqlSettings(false, false, false);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOffFromConnection() throws Exception {\n+        verifyFilterToSqlSettings(true, false, false);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOnFromQuery() throws Exception {\n+        verifyFilterToSqlSettings(false, false, true);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOffFromQuery() throws Exception {\n+        verifyFilterToSqlSettings(true, false, true);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOnWithPSFromConnection() throws Exception {\n+        verifyFilterToSqlSettings(false, true, false);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOffWithPSFromConnection() throws Exception {\n+        verifyFilterToSqlSettings(true, true, false);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOnWithPSFromQuery() throws Exception {\n+        verifyFilterToSqlSettings(false, true, true);\n+    }\n+\n+    @Test\n+    public void testStandardConformingStringsOffWithPSFromQuery() throws Exception {\n+        verifyFilterToSqlSettings(true, true, true);\n+    }\n+\n+    private void verifyFilterToSqlSettings(\n+            boolean escapeBackslash, boolean withPS, boolean withQuery) throws Exception {\n+        if (withQuery) {\n+            when(this.st2.executeQuery(\"SHOW standard_conforming_strings\")).thenReturn(this.rs2);\n+            when(this.rs2.next()).thenReturn(true);\n+            when(this.rs2.getString(1)).thenReturn(escapeBackslash ? \"off\" : \"on\");\n+        } else {\n+            when(this.conn.isWrapperFor(PgConnection.class)).thenReturn(true);\n+            when(this.conn.unwrap(PgConnection.class)).thenReturn(this.pgConn);\n+            when(this.pgConn.getStandardConformingStrings()).thenReturn(!escapeBackslash);\n+        }\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(DATASOURCE.key, this.ds);\n+        params.put(PREPARED_STATEMENTS.key, withPS);\n+        this.store = new PostgisNGDataStoreFactory().createDataStore(params);\n+        assertNotNull(this.store);\n+        SQLDialect dialect = this.store.getSQLDialect();\n+        assertThat(dialect, instanceOf(withPS ? PostGISPSDialect.class : PostGISDialect.class));\n+        PostGISDialect pgDialect =\n+                withPS ? ((PostGISPSDialect) dialect).getDelegate() : (PostGISDialect) dialect;\n+        assertEquals(new Version(\"15.1\"), pgDialect.getPostgreSQLVersion(this.conn));\n+        assertEquals(new Version(\"3.3.2\"), pgDialect.getVersion(this.conn));\n+        assertEquals(escapeBackslash, pgDialect.isEscapeBackslash());\n+        verify(this.conn, withQuery ? times(2) : times(1)).createStatement();\n+        verify(this.conn).close();\n+        verify(this.st1).close();\n+        verify(this.rs1).close();\n+        verify(this.st2, withQuery ? times(1) : never()).close();\n+        verify(this.rs2, withQuery ? times(1) : never()).close();\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 6,
        "unique_directories": 11,
        "max_directory_depth": 11
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8960ffbe83404ceb20dc3033d2cbf3ca394040a4",
            "date": "2025-01-14T08:31:34Z",
            "author_login": "mprins"
          },
          {
            "sha": "bb5be37204ef75a7f396653f87d87b0d327b1d0a",
            "date": "2025-01-13T22:06:04Z",
            "author_login": "roarbra"
          },
          {
            "sha": "7ef12ec97e199696034e71d06978d21f2e435c08",
            "date": "2025-01-13T09:11:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "024f733c6ec9d95391b3d0f9c83a3a6530923a00",
            "date": "2025-01-13T08:56:40Z",
            "author_login": "mprins"
          },
          {
            "sha": "d682bc5ed4c5ab2d7f50a232df279bdb4b8b4249",
            "date": "2025-01-07T10:17:23Z",
            "author_login": "mprins"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-89",
    "description": "GeoTools is an open source Java library that provides tools for geospatial data. GeoTools includes support for OGC Filter expression language parsing, encoding and execution against a range of datastore. SQL Injection Vulnerabilities have been found when executing OGC Filters with JDBCDataStore implementations. Users are advised to upgrade to either version 27.4 or to 28.2 to resolve this issue. Users unable to upgrade may disable `encode functions` for PostGIS DataStores or enable `prepared statements` for JDBCDataStores as a partial mitigation.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-21T21:15:11.157",
    "last_modified": "2024-11-21T07:49:13.280",
    "fix_date": "2023-02-10T10:48:44Z"
  },
  "references": [
    {
      "url": "https://github.com/geotools/geotools/commit/64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/geotools/geotools/security/advisories/GHSA-99c3-qc2q-p94m",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/geotools/geotools/commit/64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/geotools/geotools/security/advisories/GHSA-99c3-qc2q-p94m",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.090413",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "geotools",
    "owner": "geotools",
    "created_at": "2011-11-10T23:22:12Z",
    "updated_at": "2025-01-14T08:31:40Z",
    "pushed_at": "2025-01-14T10:56:05Z",
    "size": 419761,
    "stars": 1751,
    "forks": 1157,
    "open_issues": 3,
    "watchers": 1751,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "10.x",
      "11.x",
      "12.x",
      "13.x",
      "14.x",
      "15.x",
      "16.x",
      "17.x",
      "18.x",
      "19.x",
      "20.x",
      "21.x",
      "22.x",
      "23.x",
      "24.x",
      "25.x",
      "26.x",
      "27.x",
      "28.x",
      "29.x",
      "30.x"
    ],
    "languages": {
      "Java": 94586016,
      "PLpgSQL": 3664254,
      "Scheme": 919603,
      "HTML": 178498,
      "CSS": 37887,
      "Shell": 19012,
      "Python": 15428,
      "Scala": 957,
      "nesC": 83
    },
    "commit_activity": {
      "total_commits_last_year": 222,
      "avg_commits_per_week": 4.269230769230769,
      "days_active_last_year": 137
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T13:20:27.489856"
  }
}