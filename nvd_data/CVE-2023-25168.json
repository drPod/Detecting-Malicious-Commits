{
  "cve_id": "CVE-2023-25168",
  "github_data": {
    "repository": "pterodactyl/wings",
    "fix_commit": "429ac62dba22997a278bc709df5ac00a5a25d83d",
    "related_commits": [
      "429ac62dba22997a278bc709df5ac00a5a25d83d",
      "429ac62dba22997a278bc709df5ac00a5a25d83d"
    ],
    "patch_url": "https://github.com/pterodactyl/wings/commit/429ac62dba22997a278bc709df5ac00a5a25d83d.patch",
    "fix_commit_details": {
      "sha": "429ac62dba22997a278bc709df5ac00a5a25d83d",
      "commit_date": "2023-02-08T21:20:13Z",
      "author": {
        "login": "matthewpi",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "server(filesystem): Delete tweaks",
        "length": 33,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 141,
        "additions": 127,
        "deletions": 14
      },
      "files": [
        {
          "filename": "server/filesystem/filesystem.go",
          "status": "modified",
          "additions": 53,
          "deletions": 14,
          "patch": "@@ -387,10 +387,9 @@ func (fs *Filesystem) TruncateRootDirectory() error {\n // Delete removes a file or folder from the system. Prevents the user from\n // accidentally (or maliciously) removing their root server data directory.\n func (fs *Filesystem) Delete(p string) error {\n-\twg := sync.WaitGroup{}\n \t// This is one of the few (only?) places in the codebase where we're explicitly not using\n \t// the SafePath functionality when working with user provided input. If we did, you would\n-\t// not be able to delete a file that is a symlink pointing to a location outside of the data\n+\t// not be able to delete a file that is a symlink pointing to a location outside the data\n \t// directory.\n \t//\n \t// We also want to avoid resolving a symlink that points _within_ the data directory and thus\n@@ -407,25 +406,65 @@ func (fs *Filesystem) Delete(p string) error {\n \t\treturn errors.New(\"cannot delete root server directory\")\n \t}\n \n-\tif st, err := os.Lstat(resolved); err != nil {\n+\tst, err := os.Lstat(resolved)\n+\tif err != nil {\n \t\tif !os.IsNotExist(err) {\n \t\t\tfs.error(err).Warn(\"error while attempting to stat file before deletion\")\n+\t\t\treturn err\n \t\t}\n-\t} else {\n-\t\tif !st.IsDir() {\n-\t\t\tfs.addDisk(-st.Size())\n-\t\t} else {\n-\t\t\twg.Add(1)\n-\t\t\tgo func(wg *sync.WaitGroup, st os.FileInfo, resolved string) {\n-\t\t\t\tdefer wg.Done()\n-\t\t\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n-\t\t\t\t\tfs.addDisk(-s)\n+\n+\t\t// The following logic is used to handle a case where a user attempts to\n+\t\t// delete a file that does not exist through a directory symlink.\n+\t\t// We don't want to reveal that the file does not exist, so we validate\n+\t\t// the path of the symlink and return a bad path error if it is invalid.\n+\n+\t\t// The requested file or directory doesn't exist, so at this point we\n+\t\t// need to iterate up the path chain until we hit a directory that\n+\t\t// _does_ exist and can be validated.\n+\t\tparts := strings.Split(filepath.Dir(resolved), \"/\")\n+\n+\t\t// Range over all the path parts and form directory paths from the end\n+\t\t// moving up until we have a valid resolution, or we run out of paths to\n+\t\t// try.\n+\t\tfor k := range parts {\n+\t\t\ttry := strings.Join(parts[:(len(parts)-k)], \"/\")\n+\t\t\tif !fs.unsafeIsInDataDirectory(try) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tt, err := filepath.EvalSymlinks(try)\n+\t\t\tif err == nil {\n+\t\t\t\tif !fs.unsafeIsInDataDirectory(t) {\n+\t\t\t\t\treturn NewBadPathResolution(p, t)\n \t\t\t\t}\n-\t\t\t}(&wg, st, resolved)\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t}\n+\n+\t\t// Always return early if the file does not exist.\n+\t\treturn nil\n \t}\n \n-\twg.Wait()\n+\t// If the file is not a symlink, we need to check that it is not within a\n+\t// symlinked directory that points outside the data directory.\n+\tif st.Mode()&os.ModeSymlink == 0 {\n+\t\tep, err := filepath.EvalSymlinks(resolved)\n+\t\tif err != nil {\n+\t\t\tif !os.IsNotExist(err) {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else if !fs.unsafeIsInDataDirectory(ep) {\n+\t\t\treturn NewBadPathResolution(p, ep)\n+\t\t}\n+\t}\n+\n+\tif st.IsDir() {\n+\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n+\t\t\tfs.addDisk(-s)\n+\t\t}\n+\t} else {\n+\t\tfs.addDisk(-st.Size())\n+\t}\n \n \treturn os.RemoveAll(resolved)\n }"
        },
        {
          "filename": "server/filesystem/filesystem_test.go",
          "status": "modified",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -537,6 +537,80 @@ func TestFilesystem_Delete(t *testing.T) {\n \t\t\t}\n \t\t})\n \n+\t\tg.It(\"deletes a symlink but not it's target within the root directory\", func() {\n+\t\t\t// Symlink to a file inside the root directory.\n+\t\t\terr := os.Symlink(filepath.Join(rfs.root, \"server/source.txt\"), filepath.Join(rfs.root, \"server/symlink.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Delete the symlink itself.\n+\t\t\terr = fs.Delete(\"symlink.txt\")\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Ensure the symlink was deleted.\n+\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"server/symlink.txt\"))\n+\t\t\tg.Assert(err).IsNotNil()\n+\n+\t\t\t// Ensure the symlink target still exists.\n+\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"server/source.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n+\t\t})\n+\n+\t\tg.It(\"does not delete files symlinked outside of the root directory\", func() {\n+\t\t\t// Create a file outside the root directory.\n+\t\t\terr := rfs.CreateServerFileFromString(\"/../source.txt\", \"test content\")\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Create a symlink to the file outside the root directory.\n+\t\t\terr = os.Symlink(filepath.Join(rfs.root, \"source.txt\"), filepath.Join(rfs.root, \"/server/symlink.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Delete the symlink. (This should pass as we will delete the symlink itself, not it's target)\n+\t\t\terr = fs.Delete(\"symlink.txt\")\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Ensure the file outside the root directory still exists.\n+\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"source.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n+\t\t})\n+\n+\t\tg.It(\"does not delete files symlinked through a directory outside of the root directory\", func() {\n+\t\t\t// Create a directory outside the root directory.\n+\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"foo\"), 0o755)\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Create a file inside the directory that is outside the root.\n+\t\t\terr = rfs.CreateServerFileFromString(\"/../foo/source.txt\", \"test content\")\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Symlink the directory that is outside the root to a file inside the root.\n+\t\t\terr = os.Symlink(filepath.Join(rfs.root, \"foo\"), filepath.Join(rfs.root, \"server/symlink\"))\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Delete a file inside the symlinked directory.\n+\t\t\terr = fs.Delete(\"symlink/source.txt\")\n+\t\t\tg.Assert(err).IsNotNil()\n+\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\n+\t\t\t// Ensure the file outside the root directory still exists.\n+\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"foo/source.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n+\t\t})\n+\n+\t\tg.It(\"returns an error when trying to delete a non-existent file symlinked through a directory outside of the root directory\", func() {\n+\t\t\t// Create a directory outside the root directory.\n+\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"foo2\"), 0o755)\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Symlink the directory that is outside the root to a file inside the root.\n+\t\t\terr = os.Symlink(filepath.Join(rfs.root, \"foo2\"), filepath.Join(rfs.root, \"server/symlink\"))\n+\t\t\tg.Assert(err).IsNil()\n+\n+\t\t\t// Delete a file inside the symlinked directory.\n+\t\t\terr = fs.Delete(\"symlink/source.txt\")\n+\t\t\tg.Assert(err).IsNotNil()\n+\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t})\n+\n \t\tg.AfterEach(func() {\n \t\t\trfs.reset()\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c6c235dbc07341d5f50606819624a2e4770648a7",
            "date": "2025-01-12T22:28:46Z",
            "author_login": "matthewpi"
          },
          {
            "sha": "a55277da471a7b559e7fa45bb07024b7629e7ba2",
            "date": "2025-01-12T21:45:16Z",
            "author_login": "matthewpi"
          },
          {
            "sha": "76a9f6dc5a3396a8e3b71fa1ebe2dcfa3ad93b3c",
            "date": "2025-01-12T21:25:34Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0e96ef3edffe9978a13553b907899fdfe30d80c6",
            "date": "2025-01-12T21:25:19Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1dee350268f632045203cf892f186e9c45f55a84",
            "date": "2025-01-12T21:22:18Z",
            "author_login": "matthewpi"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:H",
    "cwe_id": "CWE-59",
    "description": "Wings is Pterodactyl's server control plane. This vulnerability can be used to delete files and directories recursively on the host system.  This vulnerability can be combined with `GHSA-p8r3-83r8-jwj5` to overwrite files on the host system. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. This vulnerability has been resolved in version `v1.11.4` of Wings, and has been back-ported to the 1.7 release series in `v1.7.4`. Anyone running `v1.11.x` should upgrade to `v1.11.4` and anyone running `v1.7.x` should upgrade to `v1.7.4`. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-09T00:16:36.907",
    "last_modified": "2024-11-21T07:49:14.483",
    "fix_date": "2023-02-08T21:20:13Z"
  },
  "references": [
    {
      "url": "https://github.com/pterodactyl/wings/commit/429ac62dba22997a278bc709df5ac00a5a25d83d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-66p8-j459-rq63",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-p8r3-83r8-jwj5",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/pterodactyl/wings/commit/429ac62dba22997a278bc709df5ac00a5a25d83d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-66p8-j459-rq63",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-p8r3-83r8-jwj5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.006588",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wings",
    "owner": "pterodactyl",
    "created_at": "2017-05-17T10:49:28Z",
    "updated_at": "2025-01-13T06:01:10Z",
    "pushed_at": "2025-01-12T22:32:13Z",
    "size": 3463,
    "stars": 769,
    "forks": 335,
    "open_issues": 18,
    "watchers": 769,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "Go": 651888,
      "Nix": 1270,
      "Makefile": 963,
      "Dockerfile": 697,
      "Shell": 10
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:17:48.763579"
  }
}