{
  "cve_id": "CVE-2023-25568",
  "github_data": {
    "repository": "ipfs/go-libipfs",
    "fix_commit": "62cbac40b96f49e39cd7fedc77ee6b56adce4916",
    "related_commits": [
      "62cbac40b96f49e39cd7fedc77ee6b56adce4916",
      "9cb5cb54d40b57084d1221ba83b9e6bb3fcc3197",
      "baa748b682fabb21a4c1f7628a8af348d4645974",
      "62cbac40b96f49e39cd7fedc77ee6b56adce4916",
      "9cb5cb54d40b57084d1221ba83b9e6bb3fcc3197",
      "baa748b682fabb21a4c1f7628a8af348d4645974"
    ],
    "patch_url": "https://github.com/ipfs/go-libipfs/commit/62cbac40b96f49e39cd7fedc77ee6b56adce4916.patch",
    "fix_commit_details": {
      "sha": "62cbac40b96f49e39cd7fedc77ee6b56adce4916",
      "commit_date": "2023-02-17T06:51:53Z",
      "author": {
        "login": "Jorropo",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "bitswap/server/internal/decision: add filtering on CIDs",
        "length": 143,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 75,
        "additions": 71,
        "deletions": 4
      },
      "files": [
        {
          "filename": "bitswap/internal/defaults/defaults.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -1,6 +1,7 @@\n package defaults\n \n import (\n+\t\"encoding/binary\"\n \t\"time\"\n )\n \n@@ -27,4 +28,9 @@ const (\n \n \t// Maximum size of the wantlist we are willing to keep in memory.\n \tMaxQueuedWantlistEntiresPerPeer = 1024\n+\n+\t// Copied from github.com/ipfs/go-verifcid#maximumHashLength\n+\t// FIXME: expose this in go-verifcid.\n+\tMaximumHashLength = 128\n+\tMaximumAllowedCid = binary.MaxVarintLen64*4 + MaximumHashLength\n )"
        },
        {
          "filename": "bitswap/network/ipfs_impl.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -370,7 +370,7 @@ func (bsnet *impl) ConnectTo(ctx context.Context, p peer.ID) error {\n }\n \n func (bsnet *impl) DisconnectFrom(ctx context.Context, p peer.ID) error {\n-\tpanic(\"Not implemented: DisconnectFrom() is only used by tests\")\n+\treturn bsnet.host.Network().ClosePeer(p)\n }\n \n // FindProvidersAsync returns a channel of providers for the given key."
        },
        {
          "filename": "bitswap/options.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -33,6 +33,12 @@ func MaxQueuedWantlistEntriesPerPeer(count uint) Option {\n \treturn Option{server.MaxQueuedWantlistEntriesPerPeer(count)}\n }\n \n+// MaxCidSize only affects the server.\n+// If it is 0 no limit is applied.\n+func MaxCidSize(n uint) Option {\n+\treturn Option{server.MaxCidSize(n)}\n+}\n+\n func TaskWorkerCount(count int) Option {\n \treturn Option{server.TaskWorkerCount(count)}\n }"
        },
        {
          "filename": "bitswap/server/internal/decision/engine.go",
          "status": "modified",
          "additions": 43,
          "deletions": 2,
          "patch": "@@ -25,6 +25,7 @@ import (\n \t\"github.com/ipfs/go-peertaskqueue/peertracker\"\n \tprocess \"github.com/jbenet/goprocess\"\n \t\"github.com/libp2p/go-libp2p/core/peer\"\n+\tmh \"github.com/multiformats/go-multihash\"\n )\n \n // TODO consider taking responsibility for other types of requests. For\n@@ -187,6 +188,7 @@ type Engine struct {\n \tmaxOutstandingBytesPerPeer int\n \n \tmaxQueuedWantlistEntriesPerPeer uint\n+\tmaxCidSize                      uint\n }\n \n // TaskInfo represents the details of a request from a peer.\n@@ -272,13 +274,20 @@ func WithMaxOutstandingBytesPerPeer(count int) Option {\n \n // WithMaxQueuedWantlistEntriesPerPeer limits how much individual entries each peer is allowed to send.\n // If a peer send us more than this we will truncate newest entries.\n-// It defaults to DefaultMaxQueuedWantlistEntiresPerPeer.\n func WithMaxQueuedWantlistEntriesPerPeer(count uint) Option {\n \treturn func(e *Engine) {\n \t\te.maxQueuedWantlistEntriesPerPeer = count\n \t}\n }\n \n+// WithMaxQueuedWantlistEntriesPerPeer limits how much individual entries each peer is allowed to send.\n+// If a peer send us more than this we will truncate newest entries.\n+func WithMaxCidSize(n uint) Option {\n+\treturn func(e *Engine) {\n+\t\te.maxCidSize = n\n+\t}\n+}\n+\n func WithSetSendDontHave(send bool) Option {\n \treturn func(e *Engine) {\n \t\te.sendDontHaves = send\n@@ -357,6 +366,7 @@ func newEngine(\n \t\ttagQueued:                       fmt.Sprintf(tagFormat, \"queued\", uuid.New().String()),\n \t\ttagUseful:                       fmt.Sprintf(tagFormat, \"useful\", uuid.New().String()),\n \t\tmaxQueuedWantlistEntriesPerPeer: defaults.MaxQueuedWantlistEntiresPerPeer,\n+\t\tmaxCidSize:                      defaults.MaximumAllowedCid,\n \t}\n \n \tfor _, opt := range opts {\n@@ -617,7 +627,7 @@ func (e *Engine) Peers() []peer.ID {\n // MessageReceived is called when a message is received from a remote peer.\n // For each item in the wantlist, add a want-have or want-block entry to the\n // request queue (this is later popped off by the workerTasks)\n-func (e *Engine) MessageReceived(ctx context.Context, p peer.ID, m bsmsg.BitSwapMessage) {\n+func (e *Engine) MessageReceived(ctx context.Context, p peer.ID, m bsmsg.BitSwapMessage) (mustKillConnection bool) {\n \tentries := m.Wantlist()\n \n \tif len(entries) > 0 {\n@@ -676,10 +686,40 @@ func (e *Engine) MessageReceived(ctx context.Context, p peer.ID, m bsmsg.BitSwap\n \t\twants = wants[:available]\n \t}\n \n+\tfilteredWants := wants[:0] // shift inplace\n+\n \tfor _, entry := range wants {\n+\t\tif entry.Cid.Prefix().MhType == mh.IDENTITY {\n+\t\t\t// This is a truely broken client, let's kill the connection.\n+\t\t\te.lock.Unlock()\n+\t\t\tlog.Warnw(\"peer wants an identity CID\", \"local\", e.self, \"remote\", p)\n+\t\t\treturn true\n+\t\t}\n+\t\tif e.maxCidSize != 0 && uint(entry.Cid.ByteLen()) > e.maxCidSize {\n+\t\t\t// Ignore requests about CIDs that big.\n+\t\t\tcontinue\n+\t\t}\n+\n \t\te.peerLedger.Wants(p, entry.Entry)\n+\t\tfilteredWants = append(filteredWants, entry)\n+\t}\n+\tclear := wants[len(filteredWants):]\n+\tfor i := range clear {\n+\t\tclear[i] = bsmsg.Entry{} // early GC\n \t}\n+\twants = filteredWants\n \tfor _, entry := range cancels {\n+\t\tif entry.Cid.Prefix().MhType == mh.IDENTITY {\n+\t\t\t// This is a truely broken client, let's kill the connection.\n+\t\t\te.lock.Unlock()\n+\t\t\tlog.Warnw(\"peer canceled an identity CID\", \"local\", e.self, \"remote\", p)\n+\t\t\treturn true\n+\t\t}\n+\t\tif e.maxCidSize != 0 && uint(entry.Cid.ByteLen()) > e.maxCidSize {\n+\t\t\t// Ignore requests about CIDs that big.\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tlog.Debugw(\"Bitswap engine <- cancel\", \"local\", e.self, \"from\", p, \"cid\", entry.Cid)\n \t\tif e.peerLedger.CancelWant(p, entry.Cid) {\n \t\t\te.peerRequestQueue.Remove(entry.Cid, p)\n@@ -765,6 +805,7 @@ func (e *Engine) MessageReceived(ctx context.Context, p peer.ID, m bsmsg.BitSwap\n \t\te.peerRequestQueue.PushTasksTruncated(e.maxQueuedWantlistEntriesPerPeer, p, activeEntries...)\n \t\te.updateMetrics()\n \t}\n+\treturn false\n }\n \n // Split the want-have / want-block entries from the cancel entries"
        },
        {
          "filename": "bitswap/server/server.go",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -220,6 +220,17 @@ func MaxQueuedWantlistEntriesPerPeer(count uint) Option {\n \t}\n }\n \n+// MaxCidSize limits how big CIDs we are willing to serve.\n+// We will ignore CIDs over this limit.\n+// It defaults to [defaults.MaxCidSize].\n+// If it is 0 no limit is applied.\n+func MaxCidSize(n uint) Option {\n+\to := decision.WithMaxCidSize(n)\n+\treturn func(bs *Server) {\n+\t\tbs.engineOptions = append(bs.engineOptions, o)\n+\t}\n+}\n+\n // HasBlockBufferSize configure how big the new blocks buffer should be.\n func HasBlockBufferSize(count int) Option {\n \tif count < 0 {\n@@ -511,7 +522,10 @@ func (bs *Server) provideWorker(px process.Process) {\n func (bs *Server) ReceiveMessage(ctx context.Context, p peer.ID, incoming message.BitSwapMessage) {\n \t// This call records changes to wantlists, blocks received,\n \t// and number of bytes transfered.\n-\tbs.engine.MessageReceived(ctx, p, incoming)\n+\tmustKillConnection := bs.engine.MessageReceived(ctx, p, incoming)\n+\tif mustKillConnection {\n+\t\tbs.network.DisconnectFrom(ctx, p)\n+\t}\n \t// TODO: this is bad, and could be easily abused.\n \t// Should only track *useful* messages in ledger\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6397847842b6fc8667a23a36599e81ede1f283e8",
            "date": "2025-01-10T17:23:17Z",
            "author_login": "gammazero"
          },
          {
            "sha": "1097a4b524384fdb83dc2ea8000007e8e5963156",
            "date": "2025-01-08T22:15:11Z",
            "author_login": "lidel"
          },
          {
            "sha": "08526adad7242bd8bb0f6223f2015f5cabd93841",
            "date": "2025-01-08T20:23:08Z",
            "author_login": "lidel"
          },
          {
            "sha": "5518e1a21453ea185c7b2bc31590dcaebb1cd1d3",
            "date": "2025-01-08T19:56:08Z",
            "author_login": "lidel"
          },
          {
            "sha": "13869e2c2c35daa9ddf39875dd4e27205166b204",
            "date": "2025-01-08T07:22:49Z",
            "author_login": "Dreamacro"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H",
    "cwe_id": "CWE-400",
    "description": "Boxo, formerly known as go-libipfs, is a library for building IPFS applications and implementations. In versions 0.4.0 and 0.5.0, if an attacker is able allocate arbitrary many bytes in the Bitswap server, those allocations are lasting even if the connection is closed. This affects users accepting untrusted connections with the Bitswap server and also affects users using the old API stubs at `github.com/ipfs/go-libipfs/bitswap` because users then transitively import `github.com/ipfs/go-libipfs/bitswap/server`. Boxo versions 0.6.0 and 0.4.1 contain a patch for this issue. As a workaround, those who are using the stub object at `github.com/ipfs/go-libipfs/bitswap` not taking advantage of the features provided by the server can refactor their code to use the new split API that will allow them to run in a client only mode: `github.com/ipfs/go-libipfs/bitswap/client`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-05-10T14:15:32.187",
    "last_modified": "2024-11-21T07:49:44.800",
    "fix_date": "2023-02-17T06:51:53Z"
  },
  "references": [
    {
      "url": "https://github.com/ipfs/boxo/commit/62cbac40b96f49e39cd7fedc77ee6b56adce4916",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/boxo/commit/9cb5cb54d40b57084d1221ba83b9e6bb3fcc3197",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/boxo/commit/baa748b682fabb21a4c1f7628a8af348d4645974",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/go-libipfs/security/advisories/GHSA-m974-xj4j-7qv5",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/ipfs/boxo/commit/62cbac40b96f49e39cd7fedc77ee6b56adce4916",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/boxo/commit/9cb5cb54d40b57084d1221ba83b9e6bb3fcc3197",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/boxo/commit/baa748b682fabb21a4c1f7628a8af348d4645974",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ipfs/go-libipfs/security/advisories/GHSA-m974-xj4j-7qv5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:32.949230",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "boxo",
    "owner": "ipfs",
    "created_at": "2022-11-28T20:48:23Z",
    "updated_at": "2025-01-10T17:23:21Z",
    "pushed_at": "2025-01-14T05:44:04Z",
    "size": 22254,
    "stars": 221,
    "forks": 108,
    "open_issues": 191,
    "watchers": 221,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 2502508,
      "HTML": 12980,
      "CSS": 3662,
      "Makefile": 684
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T22:05:38.765333"
  }
}