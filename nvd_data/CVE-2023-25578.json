{
  "cve_id": "CVE-2023-25578",
  "github_data": {
    "repository": "starlite-api/starlite",
    "fix_commit": "9674fe803628f986c03fe60769048cbc55b5bf83",
    "related_commits": [
      "9674fe803628f986c03fe60769048cbc55b5bf83",
      "9674fe803628f986c03fe60769048cbc55b5bf83"
    ],
    "patch_url": "https://github.com/starlite-api/starlite/commit/9674fe803628f986c03fe60769048cbc55b5bf83.patch",
    "fix_commit_details": {
      "sha": "9674fe803628f986c03fe60769048cbc55b5bf83",
      "commit_date": "2023-02-15T01:05:56Z",
      "author": {
        "login": "peterschutt",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-p24m-863f-fm6q",
        "length": 744,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 205,
        "additions": 149,
        "deletions": 56
      },
      "files": [
        {
          "filename": "starlite/app.py",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -135,6 +135,7 @@ class Starlite(Router):\n         \"get_logger\",\n         \"logger\",\n         \"logging_config\",\n+        \"multipart_form_part_limit\",\n         \"on_shutdown\",\n         \"on_startup\",\n         \"openapi_config\",\n@@ -175,6 +176,7 @@ def __init__(\n         initial_state: Optional[\"InitialStateType\"] = None,\n         logging_config: Union[\"BaseLoggingConfig\", \"EmptyType\", None] = Empty,\n         middleware: Optional[List[\"Middleware\"]] = None,\n+        multipart_form_part_limit: int = 1000,\n         on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,\n         on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,\n         on_startup: Optional[List[\"LifeSpanHandler\"]] = None,\n@@ -238,6 +240,8 @@ def __init__(\n             initial_state: An object from which to initialize the app state.\n             logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.\n             middleware: A list of :class:`Middleware <starlite.types.Middleware>`.\n+            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.\n+                This limit is intended to protect from DoS attacks.\n             on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive\n                 an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with\n                 the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more\n@@ -300,6 +304,7 @@ def __init__(\n             initial_state=initial_state or {},\n             logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,  # type: ignore[arg-type]\n             middleware=middleware or [],\n+            multipart_form_part_limit=multipart_form_part_limit,\n             on_shutdown=on_shutdown or [],\n             on_startup=on_startup or [],\n             openapi_config=openapi_config,\n@@ -343,6 +348,7 @@ def __init__(\n         self.static_files_config = config.static_files_config\n         self.template_engine = config.template_config.engine_instance if config.template_config else None\n         self.websocket_class = config.websocket_class or WebSocket\n+        self.multipart_form_part_limit = config.multipart_form_part_limit\n \n         super().__init__(\n             after_request=config.after_request,"
        },
        {
          "filename": "starlite/config/app.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -178,6 +178,8 @@ class Config(BaseConfig):\n     \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"\n     websocket_class: Optional[Type[WebSocket]]\n     \"\"\"An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for websocket connections.\"\"\"\n+    multipart_form_part_limit: int\n+    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\"\n \n     @validator(\"allowed_hosts\", always=True)\n     def validate_allowed_hosts(  # pylint: disable=no-self-argument"
        },
        {
          "filename": "starlite/connection/request.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -150,7 +150,9 @@ async def form(self) -> FormMultiDict:\n             content_type, options = self.content_type\n             if content_type == RequestEncodingType.MULTI_PART:\n                 self._form = self.scope[\"_form\"] = form_values = parse_multipart_form(  # type: ignore[typeddict-item]\n-                    body=await self.body(), boundary=options.get(\"boundary\", \"\").encode()\n+                    body=await self.body(),\n+                    boundary=options.get(\"boundary\", \"\").encode(),\n+                    multipart_form_part_limit=self.app.multipart_form_part_limit,\n                 )\n                 return FormMultiDict(form_values)\n             if content_type == RequestEncodingType.URL_ENCODED:"
        },
        {
          "filename": "starlite/kwargs/extractors.py",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -19,6 +19,7 @@\n from starlite.enums import ParamType, RequestEncodingType\n from starlite.exceptions import ValidationException\n from starlite.multipart import parse_multipart_form\n+from starlite.params import BodyKwarg\n from starlite.parsers import (\n     parse_headers,\n     parse_query_string,\n@@ -289,15 +290,25 @@ def create_multipart_extractor(\n     Returns:\n         An extractor function.\n     \"\"\"\n+    body_kwarg_multipart_form_part_limit: Optional[int] = None\n+    if signature_field.kwarg_model and isinstance(signature_field.kwarg_model, BodyKwarg):\n+        body_kwarg_multipart_form_part_limit = signature_field.kwarg_model.multipart_form_part_limit\n \n     async def extract_multipart(\n         connection: \"Request[Any, Any]\",\n     ) -> Any:\n+        multipart_form_part_limit = (\n+            body_kwarg_multipart_form_part_limit\n+            if body_kwarg_multipart_form_part_limit is not None\n+            else connection.app.multipart_form_part_limit\n+        )\n         connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]\n             connection.scope[\"_form\"]  # type: ignore[typeddict-item]\n             if \"_form\" in connection.scope\n             else parse_multipart_form(\n-                body=await connection.body(), boundary=connection.content_type[-1].get(\"boundary\", \"\").encode()\n+                body=await connection.body(),\n+                boundary=connection.content_type[-1].get(\"boundary\", \"\").encode(),\n+                multipart_form_part_limit=multipart_form_part_limit,\n             )\n         )\n "
        },
        {
          "filename": "starlite/multipart.py",
          "status": "modified",
          "additions": 76,
          "deletions": 52,
          "patch": "@@ -30,10 +30,11 @@\n from urllib.parse import unquote\n \n from starlite.datastructures.upload_file import UploadFile\n-from starlite.exceptions import SerializationException\n+from starlite.exceptions import SerializationException, ValidationException\n from starlite.utils.serialization import decode_json\n \n-_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n+_token = r\"([\\w!#$%&'*+\\-.^_`|~]+)\"\n+_quoted = r'\"([^\"]*)\"'\n _param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n _firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n \n@@ -59,67 +60,90 @@ def parse_content_header(value: str) -> Tuple[str, Dict[str, str]]:\n     return value.strip().lower(), options\n \n \n-def parse_multipart_form(body: bytes, boundary: bytes) -> Dict[str, Any]:\n+def parse_body(body: bytes, boundary: bytes, multipart_form_part_limit: int) -> List[bytes]:\n+    \"\"\"Split the body using the boundary\n+        and validate the number of form parts is within the allowed limit.\n+\n+    :param body: The form body.\n+    :param boundary: The boundary used to separate form components.\n+    :param multipart_form_part_limit: The limit of allowed form components\n+    :return:\n+        A list of form components.\n+    \"\"\"\n+    if not (body and boundary):\n+        return []\n+\n+    form_parts = body.split(boundary, multipart_form_part_limit + 3)[1:-1]\n+\n+    if len(form_parts) > multipart_form_part_limit:\n+        raise ValidationException(\n+            f\"number of multipart components exceeds the allowed limit of {multipart_form_part_limit}, \"\n+            f\"this potentially indicates a DoS attack\"\n+        )\n+\n+    return form_parts\n+\n+\n+def parse_multipart_form(body: bytes, boundary: bytes, multipart_form_part_limit: int = 1000) -> Dict[str, Any]:\n     \"\"\"Parse multipart form data.\n \n     Args:\n         body: Body of the request.\n         boundary: Boundary of the multipart message.\n+        multipart_form_part_limit: Limit of the number of parts allowed.\n \n     Returns:\n         A dictionary of parsed results.\n     \"\"\"\n \n     fields: DefaultDict[str, List[Any]] = defaultdict(list)\n \n-    if body and boundary:\n-        form_parts = body.split(boundary)\n-        for form_part in form_parts[1:-1]:\n-            file_name = None\n-            content_type = \"text/plain\"\n-            content_charset = \"utf-8\"\n-            field_name = None\n-            line_index = 2\n-            line_end_index = 0\n-            headers: List[Tuple[str, str]] = []\n-\n-            while line_end_index != -1:\n-                line_end_index = form_part.find(b\"\\r\\n\", line_index)\n-                form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n-\n-                if not form_line:\n-                    break\n-\n-                line_index = line_end_index + 2\n-                colon_index = form_line.index(\":\")\n-                current_idx = colon_index + 2\n-                form_header_field = form_line[0:colon_index].lower()\n-                form_header_value, form_parameters = parse_content_header(form_line[current_idx:])\n-\n-                if form_header_field == \"content-disposition\":\n-                    field_name = form_parameters.get(\"name\")\n-                    file_name = form_parameters.get(\"filename\")\n-\n-                    if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):\n-                        encoding, _, value = decode_rfc2231(filename_with_asterisk)\n-                        file_name = unquote(value, encoding=encoding or content_charset)\n-\n-                elif form_header_field == \"content-type\":\n-                    content_type = form_header_value\n-                    content_charset = form_parameters.get(\"charset\", \"utf-8\")\n-                headers.append((form_header_field, form_header_value))\n-\n-            if field_name:\n-                post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")\n-                if file_name:\n-                    form_file = UploadFile(\n-                        content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)\n-                    )\n-                    fields[field_name].append(form_file)\n-                else:\n-                    try:\n-                        fields[field_name].append(decode_json(post_data))\n-                    except SerializationException:\n-                        fields[field_name].append(post_data.decode(content_charset))\n+    for form_part in parse_body(body=body, boundary=boundary, multipart_form_part_limit=multipart_form_part_limit):\n+        file_name = None\n+        content_type = \"text/plain\"\n+        content_charset = \"utf-8\"\n+        field_name = None\n+        line_index = 2\n+        line_end_index = 0\n+        headers: List[Tuple[str, str]] = []\n+\n+        while line_end_index != -1:\n+            line_end_index = form_part.find(b\"\\r\\n\", line_index)\n+            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n+\n+            if not form_line:\n+                break\n+\n+            line_index = line_end_index + 2\n+            colon_index = form_line.index(\":\")\n+            current_idx = colon_index + 2\n+            form_header_field = form_line[0:colon_index].lower()\n+            form_header_value, form_parameters = parse_content_header(form_line[current_idx:])\n+\n+            if form_header_field == \"content-disposition\":\n+                field_name = form_parameters.get(\"name\")\n+                file_name = form_parameters.get(\"filename\")\n+\n+                if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):\n+                    encoding, _, value = decode_rfc2231(filename_with_asterisk)\n+                    file_name = unquote(value, encoding=encoding or content_charset)\n+\n+            elif form_header_field == \"content-type\":\n+                content_type = form_header_value\n+                content_charset = form_parameters.get(\"charset\", \"utf-8\")\n+            headers.append((form_header_field, form_header_value))\n+\n+        if field_name:\n+            post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")\n+            if file_name:\n+                form_file = UploadFile(\n+                    content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)\n+                )\n+                fields[field_name].append(form_file)\n+            else:\n+                try:\n+                    fields[field_name].append(decode_json(post_data))\n+                except SerializationException:\n+                    fields[field_name].append(post_data.decode(content_charset))\n \n     return {k: v if len(v) > 1 else v[0] for k, v in fields.items()}"
        },
        {
          "filename": "starlite/params.py",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -286,6 +286,8 @@ class BodyKwarg:\n \n     Equivalent to pattern in the OpenAPI specification.\n     \"\"\"\n+    multipart_form_part_limit: Optional[int] = field(default=None)\n+    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\"\n \n     def __hash__(self) -> int:  # pragma: no cover\n         \"\"\"Hash the dataclass in a safe way.\n@@ -315,7 +317,8 @@ def Body(\n     max_items: Optional[int] = None,\n     min_length: Optional[int] = None,\n     max_length: Optional[int] = None,\n-    regex: Optional[str] = None\n+    regex: Optional[str] = None,\n+    multipart_form_part_limit: Optional[int] = None\n ) -> Any:\n     \"\"\"Create an extended request body kwarg definition.\n \n@@ -354,6 +357,8 @@ def Body(\n             maxLength in the OpenAPI specification.\n         regex: A string representing a regex against which the given string will be matched.\n             Equivalent to pattern in the OpenAPI specification.\n+        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.\n+            This limit is intended to protect from DoS attacks.\n     \"\"\"\n     return BodyKwarg(\n         media_type=media_type,\n@@ -374,6 +379,7 @@ def Body(\n         min_length=min_length,\n         max_length=max_length,\n         regex=regex,\n+        multipart_form_part_limit=multipart_form_part_limit,\n     )\n \n "
        },
        {
          "filename": "starlite/testing/create_test_client.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -78,6 +78,7 @@ def create_test_client(\n     initial_state: Optional[Union[\"ImmutableState\", Dict[str, Any], Iterable[Tuple[str, Any]]]] = None,\n     logging_config: Optional[\"BaseLoggingConfig\"] = None,\n     middleware: Optional[List[\"Middleware\"]] = None,\n+    multipart_form_part_limit: int = 1000,\n     on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,\n     on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,\n     on_startup: Optional[List[\"LifeSpanHandler\"]] = None,\n@@ -160,6 +161,8 @@ def test_my_handler() -> None:\n         initial_state: An object from which to initialize the app state.\n         logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.\n         middleware: A list of :class:`Middleware <starlite.types.Middleware>`.\n+        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.\n+            This limit is intended to protect from DoS attacks.\n         on_app_init:  A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive\n                 an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with\n                 the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more\n@@ -210,6 +213,7 @@ def test_my_handler() -> None:\n             initial_state=initial_state,\n             logging_config=logging_config,\n             middleware=middleware,\n+            multipart_form_part_limit=multipart_form_part_limit,\n             on_app_init=on_app_init,\n             on_shutdown=on_shutdown,\n             on_startup=on_startup,"
        },
        {
          "filename": "tests/app/test_app_config.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -35,6 +35,7 @@ def app_config_object() -> AppConfig:\n         initial_state={},\n         logging_config=None,\n         middleware=[],\n+        multipart_form_part_limit=1000,\n         on_shutdown=[],\n         on_startup=[],\n         openapi_config=None,"
        },
        {
          "filename": "tests/kwargs/test_multipart_data.py",
          "status": "modified",
          "additions": 38,
          "deletions": 1,
          "patch": "@@ -10,7 +10,7 @@\n \n from starlite import Body, Request, RequestEncodingType, post\n from starlite.datastructures import UploadFile\n-from starlite.status_codes import HTTP_201_CREATED\n+from starlite.status_codes import HTTP_201_CREATED, HTTP_400_BAD_REQUEST\n from starlite.testing import create_test_client\n from tests import Person, PersonFactory\n from tests.kwargs import Form\n@@ -405,3 +405,40 @@ async def hello_world(data: Optional[UploadFile] = Body(media_type=RequestEncodi\n     with create_test_client(route_handlers=[hello_world]) as client:\n         response = client.post(\"/\")\n         assert response.status_code == HTTP_201_CREATED\n+\n+\n+@pytest.mark.parametrize(\"limit\", (1000, 100, 10))\n+def test_multipart_form_part_limit(limit: int) -> None:\n+    @post(\"/\")\n+    async def hello_world(data: List[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n+        assert len(data) == limit\n+\n+    with create_test_client(route_handlers=[hello_world], multipart_form_part_limit=limit) as client:\n+        data = {str(i): \"a\" for i in range(limit)}\n+        response = client.post(\"/\", files=data)\n+        assert response.status_code == HTTP_201_CREATED\n+\n+        data = {str(i): \"a\" for i in range(limit)}\n+        data[str(limit + 1)] = \"b\"\n+        response = client.post(\"/\", files=data)\n+        assert response.status_code == HTTP_400_BAD_REQUEST\n+\n+\n+def test_multipart_form_part_limit_body_param_precedence() -> None:\n+    app_limit = 100\n+    route_limit = 10\n+\n+    @post(\"/\")\n+    async def hello_world(\n+        data: List[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART, multipart_form_part_limit=route_limit)\n+    ) -> None:\n+        assert len(data) == route_limit\n+\n+    with create_test_client(route_handlers=[hello_world], multipart_form_part_limit=app_limit) as client:\n+        data = {str(i): \"a\" for i in range(route_limit)}\n+        response = client.post(\"/\", files=data)\n+        assert response.status_code == HTTP_201_CREATED\n+\n+        data = {str(i): \"a\" for i in range(route_limit + 1)}\n+        response = client.post(\"/\", files=data)\n+        assert response.status_code == HTTP_400_BAD_REQUEST"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 7,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b140afb8ef8f60cab8a89c5d2afeb67cb3fbeb0b",
            "date": "2025-01-13T07:16:12Z",
            "author_login": "euri10"
          },
          {
            "sha": "2db1f4d2131d9902af15e00312e1673d0b3d0a61",
            "date": "2025-01-11T19:24:15Z",
            "author_login": "provinzkraut"
          },
          {
            "sha": "a814224eaeebae7511ec4ae5ad90559c6e26c6e1",
            "date": "2025-01-10T03:58:19Z",
            "author_login": "JacobCoffee"
          },
          {
            "sha": "79827933ac01fe0d8a0ad44498b173ae14023b0d",
            "date": "2025-01-10T02:56:10Z",
            "author_login": "cofin"
          },
          {
            "sha": "b09a549c4f0564cb19ff97cc2410b11afea297da",
            "date": "2025-01-10T02:47:15Z",
            "author_login": "cofin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "Starlite is an Asynchronous Server Gateway Interface (ASGI) framework. Prior to version 1.5.2, the request body parsing in `starlite` allows a potentially unauthenticated attacker to consume a large amount of CPU time and RAM. The multipart body parser processes an unlimited number of file parts and an unlimited number of field parts. This is a remote, potentially unauthenticated Denial of Service vulnerability. This vulnerability affects applications with a request handler that accepts a `Body(media_type=RequestEncodingType.MULTI_PART)`. The large amount of CPU time required for processing requests can block all available worker processes and significantly delay or slow down the processing of legitimate user requests. The large amount of RAM accumulated while processing requests can lead to Out-Of-Memory kills. Complete DoS is achievable by sending many concurrent multipart requests in a loop. Version 1.51.2 contains a patch for this issue.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-15T15:15:11.883",
    "last_modified": "2024-11-21T07:49:45.860",
    "fix_date": "2023-02-15T01:05:56Z"
  },
  "references": [
    {
      "url": "https://github.com/starlite-api/starlite/commit/9674fe803628f986c03fe60769048cbc55b5bf83",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/starlite-api/starlite/releases/tag/v1.51.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/starlite-api/starlite/security/advisories/GHSA-p24m-863f-fm6q",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/starlite-api/starlite/commit/9674fe803628f986c03fe60769048cbc55b5bf83",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/starlite-api/starlite/releases/tag/v1.51.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/starlite-api/starlite/security/advisories/GHSA-p24m-863f-fm6q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.060709",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "litestar",
    "owner": "starlite-api",
    "created_at": "2021-12-06T19:43:06Z",
    "updated_at": "2025-01-14T14:31:53Z",
    "pushed_at": "2025-01-13T18:57:11Z",
    "size": 127636,
    "stars": 5809,
    "forks": 390,
    "open_issues": 195,
    "watchers": 5809,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.51",
      "release-2.9.1",
      "release-2.10.0",
      "release-2.11.0",
      "v3.0"
    ],
    "languages": {
      "Python": 3474135,
      "Makefile": 5351,
      "HTML": 1855,
      "CSS": 1830,
      "JavaScript": 920,
      "Lua": 848,
      "Dockerfile": 689
    },
    "commit_activity": {
      "total_commits_last_year": 461,
      "avg_commits_per_week": 8.865384615384615,
      "days_active_last_year": 180
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T16:34:07.407078"
  }
}