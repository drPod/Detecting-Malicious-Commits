{
  "cve_id": "CVE-2023-25813",
  "github_data": {
    "repository": "sequelize/sequelize",
    "fix_commit": "ccaa3996047fe00048d5993ab2dd43ebadd4f78b",
    "related_commits": [
      "ccaa3996047fe00048d5993ab2dd43ebadd4f78b",
      "ccaa3996047fe00048d5993ab2dd43ebadd4f78b"
    ],
    "patch_url": "https://github.com/sequelize/sequelize/commit/ccaa3996047fe00048d5993ab2dd43ebadd4f78b.patch",
    "fix_commit_details": {
      "sha": "ccaa3996047fe00048d5993ab2dd43ebadd4f78b",
      "commit_date": "2022-05-13T12:27:50Z",
      "author": {
        "login": "ephys",
        "type": "User",
        "stats": {
          "total_commits": 231,
          "average_weekly_commits": 0.3051519154557464,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 70
        }
      },
      "commit_message": {
        "title": "fix: do not replace `:replacements` inside of strings (#14472)",
        "length": 62,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 997,
        "additions": 982,
        "deletions": 15
      },
      "files": [
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     \"@octokit/rest\": \"^18.12.0\",\n     \"@octokit/types\": \"^6.34.0\",\n     \"@types/chai\": \"^4.3.0\",\n+    \"@types/lodash\": \"4.14.182\",\n     \"@types/mocha\": \"^9.0.0\",\n     \"@types/node\": \"^16.11.17\",\n     \"@types/sinon\": \"^10.0.6\","
        },
        {
          "filename": "src/dialects/abstract/index.d.ts",
          "status": "added",
          "additions": 106,
          "deletions": 0,
          "patch": "@@ -0,0 +1,106 @@\n+import type { Dialect } from '../../sequelize.js';\n+import type { AbstractQuery } from './query.js';\n+\n+export declare type DialectSupports = {\n+  'DEFAULT': boolean;\n+  'DEFAULT VALUES': boolean;\n+  'VALUES ()': boolean;\n+  'LIMIT ON UPDATE': boolean;\n+  'ON DUPLICATE KEY': boolean;\n+  'ORDER NULLS': boolean;\n+  'UNION': boolean;\n+  'UNION ALL': boolean;\n+  'RIGHT JOIN': boolean;\n+  EXCEPTION: boolean;\n+  forShare?: 'LOCK IN SHARE MODE' | 'FOR SHARE' | undefined;\n+  lock: boolean;\n+  lockOf: boolean;\n+  lockKey: boolean;\n+  lockOuterJoinFailure: boolean;\n+  skipLocked: boolean;\n+  finalTable: boolean;\n+  returnValues: false | {\n+    output: boolean;\n+    returning: boolean;\n+  };\n+  autoIncrement: {\n+    identityInsert: boolean;\n+    defaultValue: boolean;\n+    update: boolean;\n+  };\n+  bulkDefault: boolean;\n+  schemas: boolean;\n+  transactions: boolean;\n+  settingIsolationLevelDuringTransaction: boolean;\n+  transactionOptions: {\n+    type: boolean;\n+  };\n+  migrations: boolean;\n+  upserts: boolean;\n+  inserts: {\n+    ignoreDuplicates: string;\n+    updateOnDuplicate: boolean | string;\n+    onConflictDoNothing: string;\n+    conflictFields: boolean;\n+  };\n+  constraints: {\n+    restrict: boolean;\n+    addConstraint: boolean;\n+    dropConstraint: boolean;\n+    unique: boolean;\n+    default: boolean;\n+    check: boolean;\n+    foreignKey: boolean;\n+    primaryKey: boolean;\n+    onUpdate: boolean;\n+  };\n+  index: {\n+    collate: boolean;\n+    length: boolean;\n+    parser: boolean;\n+    concurrently: boolean;\n+    type: boolean;\n+    using: boolean | number;\n+    functionBased: boolean;\n+    operator: boolean;\n+    where: boolean;\n+  };\n+  groupedLimit: boolean;\n+  indexViaAlter: boolean;\n+  JSON: boolean;\n+  JSONB: boolean;\n+  ARRAY: boolean;\n+  RANGE: boolean;\n+  NUMERIC: boolean;\n+  GEOMETRY: boolean;\n+  GEOGRAPHY: boolean;\n+  REGEXP: boolean;\n+  /**\n+   * Case-insensitive regexp operator support ('~*' in postgres).\n+   */\n+  IREGEXP: boolean;\n+  HSTORE: boolean;\n+  TSVECTOR: boolean;\n+  deferrableConstraints: boolean;\n+  tmpTableTrigger: boolean;\n+  indexHints: boolean;\n+  searchPath: boolean;\n+};\n+\n+export declare abstract class AbstractDialect {\n+  /**\n+   * List of features this dialect supports.\n+   *\n+   * Important: Dialect implementations inherit these values.\n+   * When changing a default, ensure the implementations still properly declare which feature they support.\n+   */\n+  static readonly supports: DialectSupports;\n+  readonly defaultVersion: string;\n+  readonly Query: typeof AbstractQuery;\n+  readonly name: Dialect;\n+  readonly TICK_CHAR: string;\n+  readonly TICK_CHAR_LEFT: string;\n+  readonly TICK_CHAR_RIGHT: string;\n+  readonly queryGenerator: unknown;\n+  get supports(): DialectSupports;\n+}"
        },
        {
          "filename": "src/sequelize.js",
          "status": "modified",
          "additions": 3,
          "deletions": 6,
          "patch": "@@ -26,6 +26,7 @@ const { BelongsTo } = require('./associations/belongs-to');\n const HasOne = require('./associations/has-one');\n const { BelongsToMany } = require('./associations/belongs-to-many');\n const { HasMany } = require('./associations/has-many');\n+const { injectReplacements } = require('./utils/sql');\n \n /**\n  * This is the main class, the entry point to sequelize.\n@@ -598,11 +599,7 @@ class Sequelize {\n     }\n \n     if (options.replacements) {\n-      if (Array.isArray(options.replacements)) {\n-        sql = Utils.format([sql].concat(options.replacements), this.options.dialect);\n-      } else {\n-        sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);\n-      }\n+      sql = injectReplacements(sql, this.dialect, options.replacements);\n     }\n \n     let bindParameters;\n@@ -629,7 +626,7 @@ class Sequelize {\n       checkTransaction();\n \n       const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));\n-      \n+\n       if (this.options.dialect === 'db2' && options.alter) {\n         if (options.alter.drop === false) {\n           connection.dropTable = false;"
        },
        {
          "filename": "src/sql-string.d.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,5 +1,5 @@\n export type Escapable = undefined | null | boolean | number | string | Date;\n export function escapeId(val: string, forbidQualified?: boolean): string;\n-export function escape(val: Escapable | Escapable[], timeZone?: string, dialect?: string, format?: string): string;\n+export function escape(val: Escapable | Escapable[], timeZone?: string, dialect?: string, format?: boolean): string;\n export function format(sql: string, values: unknown[], timeZone?: string, dialect?: string): string;\n export function formatNamedParameters(sql: string, values: unknown[], timeZone?: string, dialect?: string): string;"
        },
        {
          "filename": "src/utils.js",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -114,13 +114,26 @@ function pluralize(str) {\n }\n exports.pluralize = pluralize;\n \n+/**\n+ * @deprecated use {@link injectReplacements} instead. This method has been removed in v7.\n+ *\n+ * @param {[string, ...unknown[]]} arr - first item is the SQL, following items are the positional replacements.\n+ * @param {AbstractDialect} dialect\n+ */\n function format(arr, dialect) {\n   const timeZone = null;\n   // Make a clone of the array beacuse format modifies the passed args\n   return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n }\n exports.format = format;\n \n+/**\n+ * @deprecated use {@link injectReplacements} instead. This method has been removed in v7.\n+ *\n+ * @param {string} sql\n+ * @param {object} parameters\n+ * @param {AbstractDialect} dialect\n+ */\n function formatNamedParameters(sql, parameters, dialect) {\n   const timeZone = null;\n   return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);"
        },
        {
          "filename": "src/utils/sql.ts",
          "status": "added",
          "additions": 221,
          "deletions": 0,
          "patch": "@@ -0,0 +1,221 @@\n+import isPlainObject from 'lodash/isPlainObject';\n+import type { AbstractDialect } from '../dialects/abstract/index.js';\n+import { escape as escapeSqlValue } from '../sql-string';\n+\n+type BindOrReplacements = { [key: string]: unknown } | unknown[];\n+\n+/**\n+ * Inlines replacements in places where they would be valid SQL values.\n+ *\n+ * @param sqlString The SQL that contains the replacements\n+ * @param dialect The dialect of the SQL\n+ * @param replacements if provided, this method will replace ':named' replacements & positional replacements (?)\n+ *\n+ * @returns The SQL with replacements rewritten in their dialect-specific syntax.\n+ */\n+export function injectReplacements(\n+  sqlString: string,\n+  dialect: AbstractDialect,\n+  replacements: BindOrReplacements\n+): string {\n+  if (replacements == null) {\n+    return sqlString;\n+  }\n+\n+  if (!Array.isArray(replacements) && !isPlainObject(replacements)) {\n+    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n+  }\n+\n+  const isNamedReplacements = isPlainObject(replacements);\n+  const isPositionalReplacements = Array.isArray(replacements);\n+  let lastConsumedPositionalReplacementIndex = -1;\n+\n+  let output = '';\n+\n+  let currentDollarStringTagName = null;\n+  let isString = false;\n+  let isColumn = false;\n+  let previousSliceEnd = 0;\n+  let isSingleLineComment = false;\n+  let isCommentBlock = false;\n+\n+  for (let i = 0; i < sqlString.length; i++) {\n+    const char = sqlString[i];\n+\n+    if (isColumn) {\n+      if (char === dialect.TICK_CHAR_RIGHT) {\n+        isColumn = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isString) {\n+      if (char === '\\'' && !isBackslashEscaped(sqlString, i - 1)) {\n+        isString = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (currentDollarStringTagName !== null) {\n+      if (char !== '$') {\n+        continue;\n+      }\n+\n+      const remainingString = sqlString.slice(i, sqlString.length);\n+\n+      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_])?(\\$)/i);\n+      const tagName = dollarStringStartMatch?.groups?.name;\n+      if (currentDollarStringTagName === tagName) {\n+        currentDollarStringTagName = null;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isSingleLineComment) {\n+      if (char === '\\n') {\n+        isSingleLineComment = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isCommentBlock) {\n+      if (char === '*' && sqlString[i + 1] === '/') {\n+        isCommentBlock = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (char === dialect.TICK_CHAR_LEFT) {\n+      isColumn = true;\n+      continue;\n+    }\n+\n+    if (char === '\\'') {\n+      isString = true;\n+      continue;\n+    }\n+\n+    if (char === '-' && sqlString.slice(i, i + 3) === '-- ') {\n+      isSingleLineComment = true;\n+      continue;\n+    }\n+\n+    if (char === '/' && sqlString.slice(i, i + 2) === '/*') {\n+      isCommentBlock = true;\n+      continue;\n+    }\n+\n+    // either the start of a $bind parameter, or the start of a $tag$string$tag$\n+    if (char === '$') {\n+      const previousChar = sqlString[i - 1];\n+\n+      // we are part of an identifier\n+      if (/[0-9a-z_]/i.test(previousChar)) {\n+        continue;\n+      }\n+\n+      const remainingString = sqlString.slice(i, sqlString.length);\n+\n+      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?\\$/i);\n+      if (dollarStringStartMatch) {\n+        currentDollarStringTagName = dollarStringStartMatch.groups?.name ?? '';\n+\n+        continue;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isNamedReplacements && char === ':') {\n+      const previousChar = sqlString[i - 1];\n+      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n+      // users need to add a space before the bind parameter (except after '(', ',', and '=')\n+      if (previousChar !== undefined && !/[\\s(,=]/.test(previousChar)) {\n+        continue;\n+      }\n+\n+      const remainingString = sqlString.slice(i, sqlString.length);\n+\n+      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::)/i);\n+      const replacementName = match?.groups?.name;\n+      if (!replacementName) {\n+        continue;\n+      }\n+\n+      // @ts-expect-error -- isPlainObject does not tell typescript that replacements is a plain object, not an array\n+      const replacementValue = replacements[replacementName];\n+      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === undefined) {\n+        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n+      }\n+\n+      const escapedReplacement = escapeSqlValue(replacementValue, undefined, dialect.name, true);\n+\n+      // add everything before the bind parameter name\n+      output += sqlString.slice(previousSliceEnd, i);\n+      // continue after the bind parameter name\n+      previousSliceEnd = i + replacementName.length + 1;\n+\n+      output += escapedReplacement;\n+\n+      continue;\n+    }\n+\n+    if (isPositionalReplacements && char === '?') {\n+      const previousChar = sqlString[i - 1];\n+\n+      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n+      // users need to add a space before the bind parameter (except after '(', ',', and '=')\n+      if (previousChar !== undefined && !/[\\s(,=]/.test(previousChar)) {\n+        continue;\n+      }\n+\n+      // don't parse ?| and ?& operators as replacements\n+      const nextChar = sqlString[i + 1];\n+      if (nextChar === '|' || nextChar === '&') {\n+        continue;\n+      }\n+\n+      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+      // @ts-ignore -- ts < 4.4 loses the information that 'replacements' is an array when using 'isPositionalReplacements' instead of 'Array.isArray'\n+      //  but performance matters here.\n+      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n+\n+      if (replacementValue === undefined) {\n+        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n+      }\n+\n+      const escapedReplacement = escapeSqlValue(replacementValue as any, undefined, dialect.name, true);\n+\n+      // add everything before the bind parameter name\n+      output += sqlString.slice(previousSliceEnd, i);\n+      // continue after the bind parameter name\n+      previousSliceEnd = i + 1;\n+\n+      output += escapedReplacement;\n+    }\n+  }\n+\n+  output += sqlString.slice(previousSliceEnd, sqlString.length);\n+\n+  return output;\n+}\n+\n+function isBackslashEscaped(string: string, pos: number): boolean {\n+  let escaped = false;\n+  for (let i = pos; i >= 0; i--) {\n+    const char = string[i];\n+    if (char !== '\\\\') {\n+      break;\n+    }\n+\n+    escaped = !escaped;\n+  }\n+\n+  return escaped;\n+}"
        },
        {
          "filename": "test/integration/sequelize/query.test.js",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -457,27 +457,27 @@ describe(Support.getTestDialectTeaser('Sequelize'), () => {\n \n       it('reject when key is missing in the passed object', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar, :three as baz', { raw: true, replacements: { one: 1, two: 2 } })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, 'Named replacement \":three\" has no entry in the replacement map.');\n       });\n \n       it('reject with the passed number', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: 2 })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, '\"replacements\" must be an array or a plain object, but received 2 instead.');\n       });\n \n       it('reject with the passed empty object', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: {} })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, 'Named replacement \":one\" has no entry in the replacement map.');\n       });\n \n       it('reject with the passed string', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: 'foobar' })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, '\"replacements\" must be an array or a plain object, but received \"foobar\" instead.');\n       });\n \n       it('reject with the passed date', async function() {\n-        await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: new Date() })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+        await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: new Buffer([1]) })\n+          .should.be.rejectedWith(Error, '\"replacements\" must be an array or a plain object, but received {\"type\":\"Buffer\",\"data\":[1]} instead.');\n       });\n \n       it('reject when binds passed with object and numeric $1 is also present', async function() {"
        },
        {
          "filename": "test/support.js",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -241,7 +241,7 @@ const Support = {\n     if (query instanceof Error) {\n       expect(query.message).to.equal(expectation.message);\n     } else {\n-      expect(query.query || query).to.equal(expectation);\n+      expect(Support.minifySql(query.query || query)).to.equal(Support.minifySql(expectation));\n     }\n \n     if (assertions.bind) {\n@@ -267,8 +267,12 @@ const Support = {\n   minifySql(sql) {\n     // replace all consecutive whitespaces with a single plain space character\n     return sql.replace(/\\s+/g, ' ')\n-      // remove space before coma\n+      // remove space before comma\n       .replace(/ ,/g, ',')\n+      // remove space before )\n+      .replace(/ \\)/g, ')')\n+      // replace space after (\n+      .replace(/\\( /g, '(')\n       // remove whitespace at start & end\n       .trim();\n   }"
        },
        {
          "filename": "test/unit/dialects/abstract/query-interface.test.d.ts",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+export {};"
        },
        {
          "filename": "test/unit/logger.test.d.ts",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+export {};"
        },
        {
          "filename": "test/unit/query-interface/bulk-delete.test.js",
          "status": "added",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -0,0 +1,38 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#bulkDelete', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().bulkDelete(\n+      User.tableName,\n+      { id: ':id' },\n+      {\n+        logging: console.log,\n+        replacements: {\n+          limit: 1,\n+          id: '123'\n+        }\n+      },\n+      User\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'DELETE FROM [Users] WHERE [id] = \\':id\\'',\n+      mssql: 'DELETE FROM [Users] WHERE [id] = N\\':id\\'; SELECT @@ROWCOUNT AS AFFECTEDROWS;',\n+      snowflake: 'DELETE FROM \"Users\" WHERE \"id\" = \\':id\\';'\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/bulk-insert.test.js",
          "status": "added",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -0,0 +1,32 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#bulkInsert', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().bulkInsert(User.tableName, [{\n+      firstName: ':injection'\n+    }], {\n+      replacements: {\n+        injection: 'raw sql'\n+      }\n+    });\n+\n+    expectsql(getSql(), {\n+      default: 'INSERT INTO [Users] ([firstName]) VALUES (\\':injection\\');',\n+      mssql: 'INSERT INTO [Users] ([firstName]) VALUES (N\\':injection\\');'\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/decrement.test.js",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#decrement', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().decrement(\n+      User,\n+      User.tableName,\n+      // where\n+      { id: ':id' },\n+      // incrementAmountsByField\n+      { age: ':age' },\n+      // extraAttributesToBeUpdated\n+      { name: ':name' },\n+      // options\n+      {\n+        returning: [':data'],\n+        replacements: {\n+          age: 1,\n+          id: 2,\n+          data: 3\n+        }\n+      }\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'UPDATE [Users] SET [age]=[age]- \\':age\\',[name]=\\':name\\' WHERE [id] = \\':id\\'',\n+      postgres: 'UPDATE \"Users\" SET \"age\"=\"age\"- \\':age\\',\"name\"=\\':name\\' WHERE \"id\" = \\':id\\' RETURNING \":data\"',\n+      mssql: 'UPDATE [Users] SET [age]=[age]- N\\':age\\',[name]=N\\':name\\' OUTPUT INSERTED.[:data] WHERE [id] = N\\':id\\''\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/delete.test.js",
          "status": "added",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -0,0 +1,38 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#delete', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+    const instance = new User();\n+\n+    await sequelize.getQueryInterface().delete(\n+      instance,\n+      User.tableName,\n+      { id: ':id' },\n+      {\n+        replacements: {\n+          limit: 1,\n+          id: '123'\n+        }\n+      }\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'DELETE FROM [Users] WHERE [id] = \\':id\\'',\n+      mssql: 'DELETE FROM [Users] WHERE [id] = N\\':id\\'; SELECT @@ROWCOUNT AS AFFECTEDROWS;',\n+      snowflake: 'DELETE FROM \"Users\" WHERE \"id\" = \\':id\\';'\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/increment.test.js",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#increment', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().increment(\n+      User,\n+      User.tableName,\n+      // where\n+      { id: ':id' },\n+      // incrementAmountsByField\n+      { age: ':age' },\n+      // extraAttributesToBeUpdated\n+      { name: ':name' },\n+      // options\n+      {\n+        returning: [':data'],\n+        replacements: {\n+          age: 1,\n+          id: 2,\n+          data: 3\n+        }\n+      }\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'UPDATE [Users] SET [age]=[age]+ \\':age\\',[name]=\\':name\\' WHERE [id] = \\':id\\'',\n+      postgres: 'UPDATE \"Users\" SET \"age\"=\"age\"+ \\':age\\',\"name\"=\\':name\\' WHERE \"id\" = \\':id\\' RETURNING \":data\"',\n+      mssql: 'UPDATE [Users] SET [age]=[age]+ N\\':age\\',[name]=N\\':name\\' OUTPUT INSERTED.[:data] WHERE [id] = N\\':id\\''\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/raw-select.test.js",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#rawSelect', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse user-provided data as replacements', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().rawSelect(User.tableName, {\n+      // @ts-expect-error -- we'll fix the typings when we migrate query-generator to TypeScript\n+      attributes: ['id'],\n+      where: {\n+        username: 'some :data'\n+      },\n+      replacements: {\n+        data: 'OR \\' = '\n+      }\n+    }, 'id', User);\n+\n+    expectsql(getSql(), {\n+      default: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = \\'some :data\\';',\n+      mssql: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = N\\'some :data\\';'\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/select.test.js",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#select', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse user-provided data as replacements', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().select(User, User.tableName, {\n+      // @ts-expect-error -- we'll fix the typings when we migrate query-generator to TypeScript\n+      attributes: ['id'],\n+      where: {\n+        username: 'some :data'\n+      },\n+      replacements: {\n+        data: 'OR \\' = '\n+      }\n+    });\n+\n+    expectsql(getSql(), {\n+      default: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = \\'some :data\\';',\n+      mssql: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = N\\'some :data\\';'\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/unit/query-interface/stub-query-run.js",
          "status": "added",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -0,0 +1,22 @@\n+const sinon = require('sinon');\n+const { sequelize } = require('../../support');\n+\n+module.exports.stubQueryRun = function stubQueryRun() {\n+  let lastExecutedSql;\n+\n+  class FakeQuery {\n+    run(sql) {\n+      lastExecutedSql = sql;\n+\n+      return [];\n+    }\n+  }\n+\n+  sinon.stub(sequelize.dialect, 'Query').get(() => FakeQuery);\n+  sinon.stub(sequelize.connectionManager, 'getConnection').returns({});\n+  sinon.stub(sequelize.connectionManager, 'releaseConnection');\n+\n+  return () => {\n+    return lastExecutedSql;\n+  };\n+};"
        },
        {
          "filename": "test/unit/sequelize.test.d.ts",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+export {};"
        },
        {
          "filename": "test/unit/utils/sql.test.js",
          "status": "added",
          "additions": 327,
          "deletions": 0,
          "patch": "@@ -0,0 +1,327 @@\n+const { injectReplacements } = require('sequelize/lib/utils/sql');\n+const { expect } = require('chai');\n+const { expectsql, sequelize } = require('../../support');\n+\n+const dialect = sequelize.dialect;\n+\n+describe('injectReplacements (named replacements)', () => {\n+  it('parses named replacements', () => {\n+    const sql = injectReplacements(`SELECT ${dialect.TICK_CHAR_LEFT}:id${dialect.TICK_CHAR_RIGHT} FROM users WHERE id = ':id' OR id = :id OR id = ''':id'''`, dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT [:id] FROM users WHERE id = \\':id\\' OR id = 1 OR id = \\'\\'\\':id\\'\\'\\''\n+    });\n+  });\n+\n+  it('throws if a named replacement is not provided as an own property', () => {\n+    expect(() => {\n+      injectReplacements('SELECT * FROM users WHERE id = :toString', dialect, {\n+        id: 1\n+      });\n+    }).to.throw('Named replacement \":toString\" has no entry in the replacement map.');\n+\n+  });\n+\n+  it('parses named replacements followed by cast syntax', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = :id::string', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = 1::string'\n+    });\n+  });\n+\n+  it('parses single letter named replacements', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = :a', dialect, {\n+      a: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it does not follow \\'(\\', \\',\\', \\'=\\' or whitespace', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = fn(:id) OR id = fn(\\'a\\',:id) OR id=:id OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = fn(1) OR id = fn(\\'a\\',1) OR id=1 OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag$ :id $tag$ OR id = $$ :id $$', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag$ :id $tag$ OR id = $$ :id $$'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a nested $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag1$ $tag2$ :id $tag2$ $tag1$', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag1$ $tag2$ :id $tag2$ $tag1$'\n+    });\n+  });\n+\n+  it('does consider the token to be a replacement if it is in between two identifiers that look like $ quoted strings', () => {\n+    const sql = injectReplacements('SELECT z$$ :id x$$ * FROM users', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT z$$ 1 x$$ * FROM users'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\':id\\' OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\':id\\' OR id = 1'\n+    });\n+  });\n+\n+  it('considers the token to be a replacement if it is outside a string ending with an escaped backslash', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with an escaped backslash followed by a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\':id\\' OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\':id\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- WHERE id = :id\n+      WHERE id = :id\n+    `, dialect, { id: 1 });\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- WHERE id = :id\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in string but a previous comment included a string delimiter', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- '\n+      WHERE id = ' :id '\n+    `, dialect, { id: 1 });\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- '\n+        WHERE id = ' :id '\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users /*\n+      WHERE id = :id\n+      */\n+      WHERE id = :id\n+    `, dialect, { id: 1 });\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users /*\n+        WHERE id = :id\n+        */\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  it('does not interpret ::x as a replacement, as it is a cast', () => {\n+    expect(injectReplacements('(\\'foo\\')::string', dialect, [0])).to.equal('(\\'foo\\')::string');\n+  });\n+});\n+\n+describe('injectReplacements (positional replacements)', () => {\n+  it('parses positional replacements', () => {\n+    const sql = injectReplacements(`SELECT ${dialect.TICK_CHAR_LEFT}?${dialect.TICK_CHAR_RIGHT} FROM users WHERE id = '?' OR id = ? OR id = '''?''' OR id2 = ?`, dialect, [1, 2]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT [?] FROM users WHERE id = \\'?\\' OR id = 1 OR id = \\'\\'\\'?\\'\\'\\' OR id2 = 2'\n+    });\n+  });\n+\n+  it('parses positional replacements followed by cast syntax', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = ?::string', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = 1::string'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it does not follow \\'(\\', \\',\\', \\'=\\' or whitespace', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = fn(?) OR id = fn(\\'a\\',?) OR id=? OR id = ?', dialect, [2, 1, 3, 4]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = fn(2) OR id = fn(\\'a\\',1) OR id=3 OR id = 4'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag$ ? $tag$ OR id = $$ ? $$', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag$ ? $tag$ OR id = $$ ? $$'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a nested $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag1$ $tag2$ ? $tag2$ $tag1$', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag1$ $tag2$ ? $tag2$ $tag1$'\n+    });\n+  });\n+\n+  it('does consider the token to be a replacement if it is in between two identifiers that look like $ quoted strings', () => {\n+    const sql = injectReplacements('SELECT z$$ ? x$$ * FROM users', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT z$$ 1 x$$ * FROM users'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\'?\\' OR id = ?', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\'?\\' OR id = 1'\n+    });\n+  });\n+\n+  it('considers the token to be a replacement if it is outside a string ending with an escaped backslash', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = ?', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with an escaped backslash followed by a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\'?\\' OR id = ?', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\'?\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- WHERE id = ?\n+      WHERE id = ?\n+    `, dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- WHERE id = ?\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in string but a previous comment included a string delimiter', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- '\n+      WHERE id = ' ? '\n+    `, dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- '\n+        WHERE id = ' ? '\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users /*\n+      WHERE id = ?\n+      */\n+      WHERE id = ?\n+    `, dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users /*\n+        WHERE id = ?\n+        */\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  // https://github.com/sequelize/sequelize/issues/14358\n+  it('does not parse ?& and ?| operators as replacements (#14358)', async () => {\n+    const sql = injectReplacements('SELECT * FROM products WHERE tags ?& ARRAY[1] AND tags ?| ARRAY[1] AND id = ?;', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM products WHERE tags ?& ARRAY[1] AND tags ?| ARRAY[1] AND id = 1;',\n+      // 'default' removes the trailing ; for ibmi, but we actually need to test it's there this time, to ensure '?;' is treated as a replacement + ';'\n+      ibmi: 'SELECT * FROM products WHERE tags ?& ARRAY[1] AND tags ?| ARRAY[1] AND id = 1;'\n+    });\n+  });\n+\n+  it('formats where clause correctly when the value is falsy', () => {\n+    expect(injectReplacements('foo = ?', dialect, [0])).to.equal('foo = 0');\n+  });\n+\n+  it('formats arrays as an expression instead of an ARRAY data type', async () => {\n+    const sql = injectReplacements('INSERT INTO users (username, email, created_at, updated_at) VALUES ?;', dialect, [[\n+      ['john', 'john@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10'],\n+      ['michael', 'michael@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10']\n+    ]]);\n+\n+    expectsql(sql, {\n+      default: `\n+        INSERT INTO users (username, email, created_at, updated_at)\n+        VALUES\n+          ('john', 'john@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10'),\n+          ('michael', 'michael@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10');`,\n+      // 'default' removes the trailing ; for ibmi, but we actually need to test it's there this time, to ensure '?;' is treated as a replacement + ';'\n+      ibmi: `\n+        INSERT INTO users (username, email, created_at, updated_at)\n+        VALUES\n+          ('john', 'john@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10'),\n+          ('michael', 'michael@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10');`,\n+      mssql: `\n+        INSERT INTO users (username, email, created_at, updated_at)\n+        VALUES\n+          (N'john', N'john@gmail.com', N'2012-01-01 10:10:10', N'2012-01-01 10:10:10'),\n+          (N'michael', N'michael@gmail.com', N'2012-01-01 10:10:10', N'2012-01-01 10:10:10');`\n+    });\n+  });\n+});"
        },
        {
          "filename": "yarn.lock",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -990,6 +990,11 @@\n   resolved \"https://registry.yarnpkg.com/@types/json-schema/-/json-schema-7.0.9.tgz#97edc9037ea0c38585320b28964dde3b39e4660d\"\n   integrity sha512-qcUXuemtEu+E5wZSJHNxUXeCZhAfXKQ41D+duX+VYPde7xyEVZci+/oXKJL13tnRs9lR2pr4fod59GT6/X1/yQ==\n \n+\"@types/lodash@4.14.182\":\n+  version \"4.14.182\"\n+  resolved \"https://registry.yarnpkg.com/@types/lodash/-/lodash-4.14.182.tgz#05301a4d5e62963227eaafe0ce04dd77c54ea5c2\"\n+  integrity sha512-/THyiqyQAP9AfARo4pF+aCGcyiQ94tX/Is2I7HofNRqoYLgN1PBoOWu2/zTA5zMxzP5EFutMtWtGAFRKUe961Q==\n+\n \"@types/minimist@^1.2.0\":\n   version \"1.2.2\"\n   resolved \"https://registry.yarnpkg.com/@types/minimist/-/minimist-1.2.2.tgz#ee771e2ba4b3dc5b372935d549fd9617bf345b8c\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 14,
        "unique_directories": 10,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9c748ff91b4a84c7b2baf109e9a712648363f5ff",
            "date": "2025-01-14T14:29:59Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "4cbd411225dcd68c0360fa6787f1f3b45acc5259",
            "date": "2025-01-12T15:19:09Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "4e93406adfc78ea87ab1f04cec190e58f36ca9e4",
            "date": "2025-01-12T15:18:24Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "5774626dd6c09440838d816c5c82438712b6155a",
            "date": "2025-01-12T13:01:28Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "c7596f31e9508a971459432a52d0277934141fc4",
            "date": "2025-01-12T11:21:24Z",
            "author_login": "renovate[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 10.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-89",
    "description": "Sequelize is a Node.js ORM tool. In versions prior to 6.19.1 a SQL injection exploit exists related to replacements. Parameters which are passed through replacements are not properly escaped which can lead to arbitrary SQL injection depending on the specific queries in use. The issue has been fixed in Sequelize 6.19.1. Users are advised to upgrade. Users unable to upgrade should not use the `replacements` and the `where` option in the same query.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-02-22T19:15:11.777",
    "last_modified": "2024-11-21T07:50:15.077",
    "fix_date": "2022-05-13T12:27:50Z"
  },
  "references": [
    {
      "url": "https://github.com/sequelize/sequelize/commit/ccaa3996047fe00048d5993ab2dd43ebadd4f78b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/issues/14519",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/releases/tag/v6.19.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/security/advisories/GHSA-wrh9-cjv3-2hpw",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/commit/ccaa3996047fe00048d5993ab2dd43ebadd4f78b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/issues/14519",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/releases/tag/v6.19.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/sequelize/sequelize/security/advisories/GHSA-wrh9-cjv3-2hpw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:04.093557",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sequelize",
    "owner": "sequelize",
    "created_at": "2010-07-22T07:11:11Z",
    "updated_at": "2025-01-14T15:12:53Z",
    "pushed_at": "2025-01-14T14:30:31Z",
    "size": 68691,
    "stars": 29710,
    "forks": 4282,
    "open_issues": 949,
    "watchers": 29710,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "add-upsert-conflictWhere",
      "doc-snowflake",
      "fix/issue-15067/incorrect-query-on-findAndCountAll",
      "fix-upsert-conflictFields"
    ],
    "languages": {
      "TypeScript": 2629999,
      "JavaScript": 2563832,
      "Shell": 12926,
      "Batchfile": 117
    },
    "commit_activity": {
      "total_commits_last_year": 735,
      "avg_commits_per_week": 14.134615384615385,
      "days_active_last_year": 217
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T16:17:24.688022"
  }
}