{
  "cve_id": "CVE-2023-26053",
  "github_data": {
    "repository": "gradle/gradle",
    "fix_commit": "bf3cc0f2b463033037e67aaacda31291643ea1a9",
    "related_commits": [
      "bf3cc0f2b463033037e67aaacda31291643ea1a9",
      "bf3cc0f2b463033037e67aaacda31291643ea1a9"
    ],
    "patch_url": "https://github.com/gradle/gradle/commit/bf3cc0f2b463033037e67aaacda31291643ea1a9.patch",
    "fix_commit_details": {
      "sha": "bf3cc0f2b463033037e67aaacda31291643ea1a9",
      "commit_date": "2023-02-20T23:49:52Z",
      "author": {
        "login": "bot-gradle",
        "type": "User",
        "stats": {
          "total_commits": 5560,
          "average_weekly_commits": 6.318181818181818,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 201
        }
      },
      "commit_message": {
        "title": "Merge pull request #23946 Trusted GPG-key should only accept 160-bit fingerprints",
        "length": 176,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 537,
        "additions": 408,
        "deletions": 129
      },
      "files": [
        {
          "filename": "subprojects/dependency-management/src/integTest/groovy/org/gradle/integtests/resolve/verification/DependencyVerificationSignatureCheckIntegTest.groovy",
          "status": "modified",
          "additions": 6,
          "deletions": 41,
          "patch": "@@ -27,7 +27,7 @@ import spock.lang.Unroll\n import static org.gradle.security.fixtures.SigningFixtures.getValidPublicKeyLongIdHexString\n import static org.gradle.security.fixtures.SigningFixtures.signAsciiArmored\n import static org.gradle.security.fixtures.SigningFixtures.validPublicKeyHexString\n-import static org.gradle.security.internal.SecuritySupport.toLongIdHexString\n+import static org.gradle.security.internal.SecuritySupport.toHexString\n \n class DependencyVerificationSignatureCheckIntegTest extends AbstractSignatureVerificationIntegrationTest {\n \n@@ -60,36 +60,6 @@ class DependencyVerificationSignatureCheckIntegTest extends AbstractSignatureVer\n         outputContains(\"Dependency verification is an incubating feature.\")\n     }\n \n-    def \"doesn't need checksums if signature is verified and trust using long id\"() {\n-        createMetadataFile {\n-            keyServer(keyServerFixture.uri)\n-            verifySignatures()\n-            addTrustedKey(\"org:foo:1.0\", validPublicKeyLongIdHexString)\n-            addTrustedKey(\"org:foo:1.0\", validPublicKeyLongIdHexString, \"pom\", \"pom\")\n-        }\n-\n-        given:\n-        javaLibrary()\n-        uncheckedModule(\"org\", \"foo\", \"1.0\") {\n-            withSignature {\n-                signAsciiArmored(it)\n-            }\n-        }\n-        buildFile << \"\"\"\n-            dependencies {\n-                implementation \"org:foo:1.0\"\n-            }\n-        \"\"\"\n-\n-        when:\n-        serveValidKey()\n-        succeeds \":compileJava\"\n-\n-        then:\n-        outputContains(\"Dependency verification is an incubating feature.\")\n-    }\n-\n-    @Unroll\n     def \"if signature is verified and checksum is declared in configuration, verify checksum (terse output=#terse)\"() {\n         createMetadataFile {\n             keyServer(keyServerFixture.uri)\n@@ -490,8 +460,8 @@ If the artifacts are trustworthy, you will need to update the gradle/verificatio\n         createMetadataFile {\n             keyServer(keyServerFixture.uri)\n             verifySignatures()\n-            addTrustedKeyByFileName(\"org:foo:1.0\", \"foo-1.0-classy.jar\", trustedKey)\n-            addTrustedKey(\"org:foo:1.0\", trustedKey, \"pom\", \"pom\")\n+            addTrustedKeyByFileName(\"org:foo:1.0\", \"foo-1.0-classy.jar\", validPublicKeyHexString)\n+            addTrustedKey(\"org:foo:1.0\", validPublicKeyHexString, \"pom\", \"pom\")\n         }\n \n         given:\n@@ -519,11 +489,6 @@ If the artifacts are trustworthy, you will need to update the gradle/verificatio\n \n If the artifacts are trustworthy, you will need to update the gradle/verification-metadata.xml file by following the instructions at ${docsUrl}\"\"\"\n \n-        where:\n-        trustedKey << [\n-            validPublicKeyHexString,\n-            validPublicKeyLongIdHexString\n-        ]\n     }\n \n     @Unroll\n@@ -575,7 +540,7 @@ This can indicate that a dependency has been compromised. Please carefully verif\n         def keyring = newKeyRing()\n         def secondServer = new KeyServer(temporaryFolder.createDir(\"keyserver-${UUID.randomUUID()}\"))\n         secondServer.registerPublicKey(keyring.publicKey)\n-        def pkId = toLongIdHexString(keyring.publicKey.keyID)\n+        def pkId = toHexString(keyring.publicKey.fingerprint)\n         secondServer.start()\n         createMetadataFile {\n             keyServer(keyServerFixture.uri)\n@@ -1145,7 +1110,7 @@ This can indicate that a dependency has been compromised. Please carefully verif\n     def \"passes verification if an artifact is signed with multiple keys and one of them is ignored\"() {\n         def keyring = newKeyRing()\n         keyServerFixture.registerPublicKey(keyring.publicKey)\n-        def pkId = toLongIdHexString(keyring.publicKey.keyID)\n+        def pkId = toHexString(keyring.publicKey.fingerprint)\n         createMetadataFile {\n             keyServer(keyServerFixture.uri)\n             verifySignatures()\n@@ -1311,7 +1276,7 @@ If the artifacts are trustworthy, you will need to update the gradle/verificatio\n     def \"can read public keys from keyring\"() {\n         // key will not be published on the server fixture but available locally\n         def keyring = newKeyRing()\n-        def pkId = toLongIdHexString(keyring.publicKey.keyID)\n+        def pkId = toHexString(keyring.publicKey.fingerprint)\n \n         createMetadataFile {\n             keyServer(keyServerFixture.uri)"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/StartParameterResolutionOverride.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -16,7 +16,6 @@\n package org.gradle.api.internal.artifacts.ivyservice.ivyresolve;\n \n import org.gradle.StartParameter;\n-import org.gradle.api.GradleException;\n import org.gradle.api.artifacts.component.ModuleComponentIdentifier;\n import org.gradle.api.artifacts.result.ResolvedArtifactResult;\n import org.gradle.api.artifacts.verification.DependencyVerificationMode;\n@@ -28,6 +27,7 @@\n import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.writer.WriteDependencyVerificationFile;\n import org.gradle.api.internal.artifacts.ivyservice.resolutionstrategy.ExternalResourceCachePolicy;\n import org.gradle.api.internal.artifacts.repositories.resolver.MetadataFetchingCost;\n+import org.gradle.api.internal.artifacts.verification.exceptions.DependencyVerificationException;\n import org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationServiceFactory;\n import org.gradle.api.internal.component.ArtifactType;\n import org.gradle.api.internal.properties.GradleProperties;\n@@ -237,7 +237,7 @@ private FailureVerificationOverride(Exception error) {\n \n         @Override\n         public ModuleComponentRepository overrideDependencyVerification(ModuleComponentRepository original, String resolveContextName, ResolutionStrategyInternal resolutionStrategy) {\n-            throw new GradleException(\"Dependency verification cannot be performed\", error);\n+            throw new DependencyVerificationException(\"Dependency verification cannot be performed\", error);\n         }\n     }\n "
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/verification/ChecksumAndSignatureVerificationOverride.java",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -31,6 +31,7 @@\n import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\n import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.report.DependencyVerificationReportWriter;\n import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.report.VerificationReport;\n+import org.gradle.api.internal.artifacts.verification.exceptions.DependencyVerificationException;\n import org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlReader;\n import org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationService;\n import org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationServiceFactory;\n@@ -94,8 +95,8 @@ public ChecksumAndSignatureVerificationOverride(BuildOperationExecutor buildOper\n             this.reportWriter = new DependencyVerificationReportWriter(gradleUserHome.toPath(), documentationRegistry, verificationsFile, verifier.getSuggestedWriteFlags(), reportsDirectory, gradlePropertiesFactory);\n         } catch (FileNotFoundException e) {\n             throw UncheckedException.throwAsUncheckedException(e);\n-        } catch (InvalidUserDataException e) {\n-            throw new InvalidUserDataException(\"Unable to read dependency verification metadata from \" + verificationsFile, e.getCause());\n+        } catch (DependencyVerificationException e) {\n+            throw new DependencyVerificationException(\"Unable to read dependency verification metadata from \" + verificationsFile, e.getCause());\n         }\n         this.signatureVerificationService = signatureVerificationServiceFactory.create(keyRingsFile, keyServers());\n     }"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/verification/exceptions/ComponentVerificationException.java",
          "status": "added",
          "additions": 72,
          "deletions": 0,
          "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.gradle.api.internal.artifacts.verification.exceptions;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.artifacts.component.ModuleComponentIdentifier;\n+import org.gradle.internal.logging.text.TreeFormatter;\n+\n+import java.util.function.Consumer;\n+\n+public class ComponentVerificationException extends GradleException {\n+\n+    private final ModuleComponentIdentifier component;\n+    private final Consumer<TreeFormatter> causeErrorFormatter;\n+\n+    /**\n+     * Creates a new exception when a component cannot be verified - because of some reason.\n+     *\n+     * @param component the component which failed the verification\n+     */\n+    public ComponentVerificationException(String message, ModuleComponentIdentifier component) {\n+        super(message);\n+        this.component = component;\n+        this.causeErrorFormatter = null;\n+    }\n+\n+    /**\n+     * Creates a new exception when a component cannot be verified - because of some reason.\n+     *\n+     * @param component the component which failed the verification\n+     * @param causeErrorFormatter a consumer, which will be called with a {@link TreeFormatter}, and can put extra details what happened\n+     */\n+    public ComponentVerificationException(ModuleComponentIdentifier component, Consumer<TreeFormatter> causeErrorFormatter) {\n+        this.component = component;\n+        this.causeErrorFormatter = causeErrorFormatter;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        final TreeFormatter treeFormatter = new TreeFormatter();\n+        // Add our header first\n+        treeFormatter.node(\n+            String.format(\n+                \"An error happened meanwhile verifying '%s:%s:%s':\",\n+                component.getGroup(), component.getModule(), component.getVersion()\n+            )\n+        );\n+\n+        if (this.causeErrorFormatter != null) {\n+            treeFormatter.startChildren();\n+            // Let the underlying exception explain the situation\n+            causeErrorFormatter.accept(treeFormatter);\n+            treeFormatter.endChildren();\n+\n+        }\n+        return treeFormatter.toString();\n+    }\n+}"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/verification/exceptions/DependencyVerificationException.java",
          "status": "added",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.gradle.api.internal.artifacts.verification.exceptions;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.internal.exceptions.Contextual;\n+\n+@Contextual\n+public class DependencyVerificationException extends GradleException {\n+\n+    public DependencyVerificationException(String message) {\n+        super(message);\n+    }\n+\n+    public DependencyVerificationException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/verification/exceptions/InvalidGpgKeyIdsException.java",
          "status": "added",
          "additions": 70,
          "deletions": 0,
          "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.gradle.api.internal.artifacts.verification.exceptions;\n+\n+import org.gradle.api.GradleException;\n+import org.gradle.api.internal.DocumentationRegistry;\n+import org.gradle.internal.logging.text.TreeFormatter;\n+\n+import java.util.List;\n+\n+/**\n+ * Exception class used when a GPG IDs were not correct.\n+ *\n+ * <p>\n+ * An example is using short/long IDs instead of fingerprints when trusting keys\n+ */\n+public class InvalidGpgKeyIdsException extends GradleException {\n+    private final List<String> wrongKeys;\n+\n+    /**\n+     * Creates a new exception with a list of incorrect keys.\n+     *\n+     * @param wrongKeys the list of incorrect IDs, which will be nicely formatted as part of the exception messages so the user can find them\n+     */\n+    public InvalidGpgKeyIdsException(List<String> wrongKeys) {\n+        this.wrongKeys = wrongKeys;\n+    }\n+\n+    /**\n+     * Formats a nice error message by using a {@link TreeFormatter}.\n+     *\n+     * <p>\n+     * Idea for this method is that you can pass a higher-level {@link TreeFormatter} into here, and get a coherent, nice error message printed out - so the user will see a nice chain of causes.\n+     */\n+    public void formatMessage(TreeFormatter formatter) {\n+        final DocumentationRegistry documentationRegistry = new DocumentationRegistry();\n+        final String documentLink = documentationRegistry.getDocumentationFor(\"dependency_verification\", \"sec:understanding-signature-verification\");\n+\n+        formatter.node(\n+            String.format(\"The following trusted GPG IDs are not in a minimum 160-bit fingerprint format (see: %s):\", documentLink)\n+        );\n+        formatter.startChildren();\n+        wrongKeys\n+            .stream()\n+            .map(key -> String.format(\"'%s'\", key))\n+            .forEach(formatter::node);\n+        formatter.endChildren();\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        final TreeFormatter treeFormatter = new TreeFormatter();\n+        formatMessage(treeFormatter);\n+        return treeFormatter.toString();\n+    }\n+}"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/verification/serializer/DependencyVerificationsXmlReader.java",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -21,6 +21,7 @@\n import org.gradle.api.artifacts.ModuleIdentifier;\n import org.gradle.api.artifacts.component.ModuleComponentIdentifier;\n import org.gradle.api.internal.artifacts.DefaultModuleIdentifier;\n+import org.gradle.api.internal.artifacts.verification.exceptions.DependencyVerificationException;\n import org.gradle.api.internal.artifacts.verification.model.ChecksumKind;\n import org.gradle.api.internal.artifacts.verification.model.IgnoredKey;\n import org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifier;\n@@ -81,7 +82,7 @@ public static void readFromXml(InputStream in, DependencyVerifierBuilder builder\n             xmlReader.setContentHandler(handler);\n             xmlReader.parse(new InputSource(in));\n         } catch (Exception e) {\n-            throw new InvalidUserDataException(\"Unable to read dependency verification metadata\", e);\n+            throw new DependencyVerificationException(\"Unable to read dependency verification metadata\", e);\n         } finally {\n             try {\n                 in.close();"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/verification/verifier/DependencyVerificationConfiguration.java",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -17,11 +17,14 @@\n \n import com.google.common.collect.ImmutableList;\n import org.gradle.api.artifacts.component.ModuleComponentIdentifier;\n+import org.gradle.api.internal.artifacts.verification.exceptions.InvalidGpgKeyIdsException;\n import org.gradle.api.internal.artifacts.verification.model.IgnoredKey;\n import org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\n \n import javax.annotation.Nullable;\n import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n@@ -168,7 +171,19 @@ public static class TrustedKey extends TrustCoordinates {\n \n         TrustedKey(String keyId, @Nullable String group, @Nullable String name, @Nullable String version, @Nullable String fileName, boolean regex) {\n             super(group, name, version, fileName, regex);\n-            this.keyId = keyId;\n+\n+            // The key is 160 bits long, encoded in base32 (case-insensitive characters).\n+            //\n+            // Base32 gives us 4 bits per character, so the whole fingerprint will be:\n+            // (160 bits) / (4 bits / character) = 40 characters\n+            //\n+            // By getting ASCII bytes (aka. strictly 1 byte per character, no variable-length magic)\n+            // we can safely check if the fingerprint is of the correct length.\n+            if (keyId.getBytes(StandardCharsets.US_ASCII).length < 40) {\n+                throw new InvalidGpgKeyIdsException(Collections.singletonList(keyId));\n+            } else {\n+                this.keyId = keyId;\n+            }\n         }\n \n         public String getKeyId() {"
        },
        {
          "filename": "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/verification/verifier/DependencyVerifierBuilder.java",
          "status": "modified",
          "additions": 51,
          "deletions": 15,
          "patch": "@@ -21,9 +21,11 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.artifacts.component.ComponentIdentifier;\n import org.gradle.api.artifacts.component.ModuleComponentIdentifier;\n+import org.gradle.api.internal.artifacts.verification.exceptions.ComponentVerificationException;\n+import org.gradle.api.internal.artifacts.verification.exceptions.DependencyVerificationException;\n+import org.gradle.api.internal.artifacts.verification.exceptions.InvalidGpgKeyIdsException;\n import org.gradle.api.internal.artifacts.verification.model.ArtifactVerificationMetadata;\n import org.gradle.api.internal.artifacts.verification.model.Checksum;\n import org.gradle.api.internal.artifacts.verification.model.ChecksumKind;\n@@ -35,6 +37,7 @@\n \n import javax.annotation.Nullable;\n import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n@@ -108,7 +111,7 @@ public void addTrustedKey(String keyId, @Nullable String group, @Nullable String\n     private void validateUserInput(@Nullable String group, @Nullable String name, @Nullable String version, @Nullable String fileName) {\n         // because this can be called from parsing XML, we need to perform additional verification\n         if (group == null && name == null && version == null && fileName == null) {\n-            throw new InvalidUserDataException(\"A trusted artifact must have at least one of group, name, version or file name not null\");\n+            throw new DependencyVerificationException(\"A trusted artifact must have at least one of group, name, version or file name not null\");\n         }\n     }\n \n@@ -129,11 +132,11 @@ public void addKeyServer(URI uri) {\n         keyServers.add(uri);\n     }\n \n-    private static class ComponentVerificationsBuilder {\n+    protected static class ComponentVerificationsBuilder {\n         private final ModuleComponentIdentifier component;\n         private final Map<String, ArtifactVerificationBuilder> byArtifact = Maps.newHashMap();\n \n-        private ComponentVerificationsBuilder(ModuleComponentIdentifier component) {\n+        protected ComponentVerificationsBuilder(ModuleComponentIdentifier component) {\n             this.component = component;\n         }\n \n@@ -149,7 +152,7 @@ void addIgnoredKey(ModuleComponentArtifactIdentifier artifact, IgnoredKey key) {\n             byArtifact.computeIfAbsent(artifact.getFileName(), id -> new ArtifactVerificationBuilder()).addIgnoredKey(key);\n         }\n \n-        private static ArtifactVerificationMetadata toArtifactVerification(Map.Entry<String, ArtifactVerificationBuilder> entry) {\n+        private static ArtifactVerificationMetadata toArtifactVerification(Map.Entry<String, ArtifactVerificationBuilder> entry) throws InvalidGpgKeyIdsException {\n             String key = entry.getKey();\n             ArtifactVerificationBuilder value = entry.getValue();\n             return new ImmutableArtifactVerificationMetadata(\n@@ -160,17 +163,21 @@ private static ArtifactVerificationMetadata toArtifactVerification(Map.Entry<Str\n         }\n \n         ComponentVerificationMetadata build() {\n-            return new ImmutableComponentVerificationMetadata(component,\n-                byArtifact.entrySet()\n-                    .stream()\n-                    .map(ComponentVerificationsBuilder::toArtifactVerification)\n-                    .sorted(Comparator.comparing(ArtifactVerificationMetadata::getArtifactName))\n-                    .collect(Collectors.toList())\n-            );\n+            try {\n+                return new ImmutableComponentVerificationMetadata(component,\n+                    byArtifact.entrySet()\n+                        .stream()\n+                        .map(ComponentVerificationsBuilder::toArtifactVerification)\n+                        .sorted(Comparator.comparing(ArtifactVerificationMetadata::getArtifactName))\n+                        .collect(Collectors.toList())\n+                );\n+            } catch (InvalidGpgKeyIdsException ex) {\n+                throw new ComponentVerificationException(component, ex::formatMessage);\n+            }\n         }\n     }\n \n-    private static class ArtifactVerificationBuilder {\n+    protected static class ArtifactVerificationBuilder {\n         private final Map<ChecksumKind, ChecksumBuilder> builder = Maps.newEnumMap(ChecksumKind.class);\n         private final Set<String> pgpKeys = Sets.newLinkedHashSet();\n         private final Set<IgnoredKey> ignoredPgpKeys = Sets.newLinkedHashSet();\n@@ -199,8 +206,37 @@ public void addIgnoredKey(IgnoredKey key) {\n             ignoredPgpKeys.add(key);\n         }\n \n-        public Set<String> buildTrustedPgpKeys() {\n-            return pgpKeys;\n+        /**\n+         * Builds the list of trusted GPG keys.\n+         * <p>\n+         * This method will verify if all the trusted keys are in 160-bit fingerprint format.\n+         * We do not accept either short or long formats, as they can be vulnerable to collision attacks.\n+         *\n+         * <p>\n+         * Note: the fingerprints' formatting is not verified (i.e. if it's true base32 or not) at this stage.\n+         * It will happen when these fingerprints will be converted to {@link org.gradle.security.internal.Fingerprint}.\n+         *\n+         * @return a set of trusted GPG keys\n+         * @throws InvalidGpgKeyIdsException if keys not fitting the requirements were found\n+         */\n+        public Set<String> buildTrustedPgpKeys() throws InvalidGpgKeyIdsException {\n+            final List<String> wrongPgpKeys = pgpKeys\n+                .stream()\n+                // The key is 160 bits long, encoded in base32 (case-insensitive characters).\n+                //\n+                // Base32 gives us 4 bits per character, so the whole fingerprint will be:\n+                // (160 bits) / (4 bits / character) = 40 characters\n+                //\n+                // By getting ASCII bytes (aka. strictly 1 byte per character, no variable-length magic)\n+                // we can safely check if the fingerprint is of the correct length.\n+                .filter(key -> key.getBytes(StandardCharsets.US_ASCII).length < 40)\n+                .collect(Collectors.toList());\n+\n+            if (wrongPgpKeys.isEmpty()) {\n+                return pgpKeys;\n+            } else {\n+                throw new InvalidGpgKeyIdsException(wrongPgpKeys);\n+            }\n         }\n \n         public Set<IgnoredKey> buildIgnoredPgpKeys() {"
        },
        {
          "filename": "subprojects/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/verification/writer/PgpKeyGrouperTest.groovy",
          "status": "modified",
          "additions": 26,
          "deletions": 25,
          "patch": "@@ -23,14 +23,15 @@ import org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifie\n import org.gradle.internal.component.external.model.DefaultModuleComponentIdentifier\n import org.gradle.internal.component.external.model.ModuleComponentFileArtifactIdentifier\n import spock.lang.Specification\n-import spock.lang.Unroll\n \n class PgpKeyGrouperTest extends Specification {\n     private DependencyVerifierBuilder builder = new DependencyVerifierBuilder()\n     private DependencyVerifier verifier\n     private PgpKeyGrouper pgpKeyGrouper\n \n-    @Unroll\n+    private static final String KEY_1 = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n+    private static final String KEY_2 = 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'\n+\n     def \"common prefix for groups #groups == #expected\"() {\n         expect:\n         PgpKeyGrouper.tryComputeCommonPrefixes(groups) == expected\n@@ -66,65 +67,65 @@ class PgpKeyGrouperTest extends Specification {\n \n     def \"groups entries which have the same module component id\"() {\n         grouper {\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(\"key1\")\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(KEY_1)\n         }\n \n         when:\n         executeGrouping()\n \n         then:\n-        verifier.configuration.trustedKeys*.keyId == [\"key1\"]\n+        verifier.configuration.trustedKeys*.keyId == [KEY_1]\n         verifier.verificationMetadata.empty\n     }\n \n     def \"groups entries which have the same module id\"() {\n         grouper {\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.pom\").addVerifiedKey(\"key1\")\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.pom\").addVerifiedKey(KEY_1)\n         }\n \n         when:\n         executeGrouping()\n \n         then:\n-        verifier.configuration.trustedKeys*.keyId == [\"key1\"]\n+        verifier.configuration.trustedKeys*.keyId == [KEY_1]\n     }\n \n     def \"doesn't group entries which have the same module id but different keys\"() {\n         grouper {\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.jar\").addVerifiedKey(\"key2\")\n-            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.pom\").addVerifiedKey(\"key2\")\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.jar\").addVerifiedKey(KEY_2)\n+            entry(\"org\", \"foo\", \"1.1\", \"foo-1.1.pom\").addVerifiedKey(KEY_2)\n         }\n \n         when:\n         executeGrouping()\n \n         then:\n         def keys = verifier.configuration.trustedKeys\n-        keys*.keyId == [\"key1\", \"key2\"]\n+        keys*.keyId == [KEY_1, KEY_2]\n         keys[0].version == '1.0'\n         keys[1].version == '1.1'\n     }\n \n     def \"groups entries which have the same group id\"() {\n         grouper {\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"bar\", \"1.1\", \"bar-1.1.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org\", \"bar\", \"1.1\", \"bar-1.1.pom\").addVerifiedKey(\"key1\")\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"bar\", \"1.1\", \"bar-1.1.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org\", \"bar\", \"1.1\", \"bar-1.1.pom\").addVerifiedKey(KEY_1)\n         }\n \n         when:\n         executeGrouping()\n \n         then:\n         def keys = verifier.configuration.trustedKeys\n-        keys*.keyId == [\"key1\"]\n+        keys*.keyId == [KEY_1]\n         keys[0].group == 'org'\n         keys[0].name == null\n         keys[0].version == null\n@@ -133,18 +134,18 @@ class PgpKeyGrouperTest extends Specification {\n \n     def \"groups entries which have a common group prefix\"() {\n         grouper {\n-            entry(\"org.group.a\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org.group.a\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(\"key1\")\n-            entry(\"org.group.b\", \"bar\", \"1.1\", \"bar-1.1.jar\").addVerifiedKey(\"key1\")\n-            entry(\"org.group.b\", \"bar\", \"1.1\", \"bar-1.1.pom\").addVerifiedKey(\"key1\")\n+            entry(\"org.group.a\", \"foo\", \"1.0\", \"foo-1.0.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org.group.a\", \"foo\", \"1.0\", \"foo-1.0.pom\").addVerifiedKey(KEY_1)\n+            entry(\"org.group.b\", \"bar\", \"1.1\", \"bar-1.1.jar\").addVerifiedKey(KEY_1)\n+            entry(\"org.group.b\", \"bar\", \"1.1\", \"bar-1.1.pom\").addVerifiedKey(KEY_1)\n         }\n \n         when:\n         executeGrouping()\n \n         then:\n         def keys = verifier.configuration.trustedKeys\n-        keys*.keyId == [\"key1\"]\n+        keys*.keyId == [KEY_1]\n         keys[0].group == '^org[.]group($|([.].*))'\n         keys[0].name == null\n         keys[0].version == null"
        },
        {
          "filename": "subprojects/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/verification/serializer/DependencyVerificationsXmlReaderTest.groovy",
          "status": "modified",
          "additions": 13,
          "deletions": 13,
          "patch": "@@ -16,7 +16,7 @@\n \n package org.gradle.api.internal.artifacts.verification.serializer\n \n-import org.gradle.api.InvalidUserDataException\n+import org.gradle.api.internal.artifacts.verification.exceptions.DependencyVerificationException\n import org.gradle.api.internal.artifacts.verification.model.ChecksumKind\n import org.gradle.api.internal.artifacts.verification.model.IgnoredKey\n import org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifier\n@@ -31,7 +31,7 @@ class DependencyVerificationsXmlReaderTest extends Specification {\n         parse(\"invalid\")\n \n         then:\n-        InvalidUserDataException e = thrown()\n+        DependencyVerificationException e = thrown()\n         e.message == \"Unable to read dependency verification metadata\"\n     }\n \n@@ -55,7 +55,7 @@ class DependencyVerificationsXmlReaderTest extends Specification {\n </verification-metadata>\"\"\"\n \n         then:\n-        InvalidUserDataException e = thrown()\n+        DependencyVerificationException e = thrown()\n         e.message == \"Unable to read dependency verification metadata\"\n         e.cause.message == \"Invalid dependency verification metadata file: <component> must be found under the <components> tag\"\n     }\n@@ -167,7 +167,7 @@ class DependencyVerificationsXmlReaderTest extends Specification {\n </verification-metadata>\n \"\"\"\n         then:\n-        InvalidUserDataException ex = thrown()\n+        DependencyVerificationException ex = thrown()\n         ex.message == \"Unable to read dependency verification metadata\"\n         ex.cause.message == \"A trusted artifact must have at least one of group, name, version or file name not null\"\n     }\n@@ -197,13 +197,13 @@ class DependencyVerificationsXmlReaderTest extends Specification {\n       <verify-metadata>true</verify-metadata>\n       <verify-signatures>false</verify-signatures>\n       <trusted-keys>\n-         <trusted-key id=\"012345\" group=\"g2\" name=\"m1\" file=\"file.jar\" regex=\"true\"/>\n-         <trusted-key id=\"456DEF\">\n+         <trusted-key id=\"A000000000000000000000000000000000000000\" group=\"g2\" name=\"m1\" file=\"file.jar\" regex=\"true\"/>\n+         <trusted-key id=\"B000000000000000000000000000000000000000\">\n             <trusting name=\"m3\" version=\"1.4\" file=\"file.zip\"/>\n             <trusting name=\"m4\" file=\"other-file.zip\" regex=\"true\"/>\n          </trusted-key>\n-         <trusted-key id=\"ABC123\" group=\"g3\" name=\"m2\" version=\"1.0\" regex=\"true\"/>\n-         <trusted-key id=\"ABCDEF\" group=\"g1\"/>\n+         <trusted-key id=\"C000000000000000000000000000000000000000\" group=\"g3\" name=\"m2\" version=\"1.0\" regex=\"true\"/>\n+         <trusted-key id=\"D000000000000000000000000000000000000000\" group=\"g1\"/>\n       </trusted-keys>\n    </configuration>\n    <components/>\n@@ -214,35 +214,35 @@ class DependencyVerificationsXmlReaderTest extends Specification {\n         def trustedKeys = verifier.configuration.trustedKeys\n         trustedKeys.size() == 5\n \n-        trustedKeys[0].keyId == \"012345\"\n+        trustedKeys[0].keyId == \"A000000000000000000000000000000000000000\"\n         trustedKeys[0].group == \"g2\"\n         trustedKeys[0].name == \"m1\"\n         trustedKeys[0].version == null\n         trustedKeys[0].fileName == \"file.jar\"\n         trustedKeys[0].regex == true\n \n-        trustedKeys[1].keyId == \"456DEF\"\n+        trustedKeys[1].keyId == \"B000000000000000000000000000000000000000\"\n         trustedKeys[1].group == null\n         trustedKeys[1].name == \"m3\"\n         trustedKeys[1].version == \"1.4\"\n         trustedKeys[1].fileName == \"file.zip\"\n         trustedKeys[1].regex == false\n \n-        trustedKeys[2].keyId == \"456DEF\"\n+        trustedKeys[2].keyId == \"B000000000000000000000000000000000000000\"\n         trustedKeys[2].group == null\n         trustedKeys[2].name == \"m4\"\n         trustedKeys[2].version == null\n         trustedKeys[2].fileName == \"other-file.zip\"\n         trustedKeys[2].regex == true\n \n-        trustedKeys[3].keyId == \"ABC123\"\n+        trustedKeys[3].keyId == \"C000000000000000000000000000000000000000\"\n         trustedKeys[3].group == \"g3\"\n         trustedKeys[3].name == \"m2\"\n         trustedKeys[3].version == \"1.0\"\n         trustedKeys[3].fileName == null\n         trustedKeys[3].regex == true\n \n-        trustedKeys[4].keyId == \"ABCDEF\"\n+        trustedKeys[4].keyId == \"D000000000000000000000000000000000000000\"\n         trustedKeys[4].group == \"g1\"\n         trustedKeys[4].name == null\n         trustedKeys[4].version == null"
        },
        {
          "filename": "subprojects/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/verification/serializer/DependencyVerificationsXmlWriterTest.groovy",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -143,11 +143,11 @@ class DependencyVerificationsXmlWriterTest extends Specification {\n \n     def \"can declare trusted keys\"() {\n         when:\n-        builder.addTrustedKey(\"ABCDEF\", \"g1\", null, null, null, false)\n-        builder.addTrustedKey(\"012345\", \"g2\", \"m1\", null, \"file.jar\", true)\n-        builder.addTrustedKey(\"ABC123\", \"g3\", \"m2\", \"1.0\", null, true)\n-        builder.addTrustedKey(\"456DEF\", null, \"m3\", \"1.4\", \"file.zip\", false)\n-        builder.addTrustedKey(\"456DEF\", null, \"m4\", null, \"other-file.zip\", true)\n+        builder.addTrustedKey(\"A000000000000000000000000000000000000000\", \"g1\", null, null, null, false)\n+        builder.addTrustedKey(\"B000000000000000000000000000000000000000\", \"g2\", \"m1\", null, \"file.jar\", true)\n+        builder.addTrustedKey(\"C000000000000000000000000000000000000000\", \"g3\", \"m2\", \"1.0\", null, true)\n+        builder.addTrustedKey(\"D000000000000000000000000000000000000000\", null, \"m3\", \"1.4\", \"file.zip\", false)\n+        builder.addTrustedKey(\"D000000000000000000000000000000000000000\", null, \"m4\", null, \"other-file.zip\", true)\n         serialize()\n \n         then:\n@@ -157,13 +157,13 @@ class DependencyVerificationsXmlWriterTest extends Specification {\n       <verify-metadata>true</verify-metadata>\n       <verify-signatures>false</verify-signatures>\n       <trusted-keys>\n-         <trusted-key id=\"012345\" group=\"g2\" name=\"m1\" file=\"file.jar\" regex=\"true\"/>\n-         <trusted-key id=\"456DEF\">\n+         <trusted-key id=\"A000000000000000000000000000000000000000\" group=\"g1\"/>\n+         <trusted-key id=\"B000000000000000000000000000000000000000\" group=\"g2\" name=\"m1\" file=\"file.jar\" regex=\"true\"/>\n+         <trusted-key id=\"C000000000000000000000000000000000000000\" group=\"g3\" name=\"m2\" version=\"1.0\" regex=\"true\"/>\n+         <trusted-key id=\"D000000000000000000000000000000000000000\">\n             <trusting name=\"m3\" version=\"1.4\" file=\"file.zip\"/>\n             <trusting name=\"m4\" file=\"other-file.zip\" regex=\"true\"/>\n          </trusted-key>\n-         <trusted-key id=\"ABC123\" group=\"g3\" name=\"m2\" version=\"1.0\" regex=\"true\"/>\n-         <trusted-key id=\"ABCDEF\" group=\"g1\"/>\n       </trusted-keys>\n    </configuration>\n    <components/>"
        },
        {
          "filename": "subprojects/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/verification/verifier/DependencyVerifierBuilderTest.groovy",
          "status": "added",
          "additions": 88,
          "deletions": 0,
          "patch": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.gradle.api.internal.artifacts.verification.verifier\n+\n+\n+import org.gradle.api.internal.artifacts.DefaultModuleVersionIdentifier\n+import org.gradle.api.internal.artifacts.verification.exceptions.ComponentVerificationException\n+import org.gradle.api.internal.artifacts.verification.exceptions.InvalidGpgKeyIdsException\n+import org.gradle.internal.component.external.model.DefaultModuleComponentArtifactIdentifier\n+import org.gradle.internal.component.external.model.DefaultModuleComponentIdentifier\n+import spock.lang.Specification\n+\n+class DependencyVerifierBuilderTest extends Specification {\n+\n+    def \"ComponentVerificationsBuilder should fail if trusted GPG key is not a fingerprint but a #name\"() {\n+        given:\n+        def moduleComponentIdentifier = DefaultModuleComponentIdentifier.newId(\n+            DefaultModuleVersionIdentifier.newId(\"test.group\", \"test-module\", \"0.0.0\")\n+        )\n+        def componentArtifactIdentified = new DefaultModuleComponentArtifactIdentifier(\n+            moduleComponentIdentifier, \"artifact\", \"jar\", \".jar\"\n+        )\n+\n+        def dependencyVerifier = new DependencyVerifierBuilder.ComponentVerificationsBuilder(moduleComponentIdentifier);\n+        keyIds.forEach {\n+            dependencyVerifier.addTrustedKey(componentArtifactIdentified, it)\n+        }\n+\n+        when:\n+        dependencyVerifier.build()\n+\n+        then:\n+        def ex = thrown(ComponentVerificationException)\n+        println(ex.getMessage())\n+\n+        where:\n+        name                  | keyIds\n+        \"short id\"            | [\"AAAAAAA\"]\n+        \"long id\"             | [\"AAAAAAAAAAAAAA\"]\n+        \"mixed short/long id\" | [\"AAAAAAAA\", \"AAAAAAAAAAAAAA\"]\n+    }\n+\n+    def \"ArtifactVerificationBuilder should fail if trusted GPG key is not a fingerprint but a #name\"() {\n+        given:\n+        def verificationBuilder = new DependencyVerifierBuilder.ArtifactVerificationBuilder()\n+        keyIds.forEach { verificationBuilder.addTrustedKey(it) }\n+\n+        when:\n+        verificationBuilder.buildTrustedPgpKeys();\n+\n+        then:\n+        def ex = thrown(InvalidGpgKeyIdsException)\n+        println(ex.getMessage())\n+\n+        where:\n+        name                  | keyIds\n+        \"short id\"            | [\"AAAAAAA\"]\n+        \"long id\"             | [\"AAAAAAAAAAAAAA\"]\n+        \"mixed short/long id\" | [\"AAAAAAAA\", \"AAAAAAAAAAAAAA\"]\n+    }\n+\n+    def \"ArtifactVerificationBuilder should succeed if trusted GPG key is a fingerprint\"() {\n+        given:\n+        def verificationBuilder = new DependencyVerifierBuilder.ArtifactVerificationBuilder()\n+        verificationBuilder.addTrustedKey(\"d7bf96a169f77b28c934ab1614f53f0824875d73\")\n+\n+        when:\n+        verificationBuilder.buildTrustedPgpKeys();\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+}"
        },
        {
          "filename": "subprojects/docs/src/docs/userguide/dep-man/01-core-dependency-management/dependency_verification.adoc",
          "status": "modified",
          "additions": 18,
          "deletions": 20,
          "patch": "@@ -111,7 +111,6 @@ Therefore, it's recommended to always use the same parameters once you started b\n \n The dependency verification file can be generated with the following CLI instructions:\n \n-\n ----\n gradle --write-verification-metadata sha256 help\n ----\n@@ -161,7 +160,6 @@ There are situations where you would just want to _see_ what the generated verif\n \n For this purpose, you can just add `--dry-run`:\n \n-\n ----\n gradle --write-verification-metadata sha256 help --dry-run\n ----\n@@ -258,7 +256,6 @@ Changing the `origin` gives users a sense of how trustworthy your build it.\n Interestingly, using `pdfbox` will require _much more_ than those 2 artifacts, because it will also bring in transitive dependencies.\n If the dependency verification file only included the checksums for the main artifacts you used, the build would fail with an error like this one:\n \n-\n ----\n Execution failed for task ':compileJava'.\n > Dependency verification failed for configuration ':compileClasspath':\n@@ -287,7 +284,8 @@ For example, the following configuration would check both the `md5` and `sha256`\n \n There are multiple reasons why you'd like to do so:\n \n-1. an official site doesn't publish _secure_ checksums (SHA-256, SHA-512) but publishes multiple insecure ones (MD5, SHA1). While it's easy to fake a MD5 checksum and hard but possible to fake a SHA1 checksum, it's harder to fake both of them for the same artifact.\n+1. an official site doesn't publish _secure_ checksums (SHA-256, SHA-512) but publishes multiple insecure ones (MD5, SHA1).\n+While it's easy to fake a MD5 checksum and hard but possible to fake a SHA1 checksum, it's harder to fake both of them for the same artifact.\n 2. you might want to add generated checksums to the list above\n 3. when _updating_ dependency verification file with more secure checksums, you don't want to accidentally erase checksums\n \n@@ -370,10 +368,14 @@ In practice, it means you need to list the keys that you trust for each artifact\n </component>\n ----\n \n-[TIP]\n+[WARNING]\n ====\n-Gradle supports both full fingerprint ids or long (64-bit) key ids in `pgp`, `trusted-key` and `ignore-key` elements.\n-For maximum security, you should use full fingerprints as it's possible to have collisions for long key ids.\n+For the `pgp` and `trusted-key` elements, Gradle _requires_ full fingerprint IDs (e.g. `b801e2f8ef035068ec1139cc29579f18fa8fd93b` instead of a long ID `29579f18fa8fd93b`) .\n+This minimizes the chance of a https://en.wikipedia.org/wiki/Collision_attack[collision attack].\n+\n+At the time, https://www.rfc-editor.org/rfc/rfc4880#section-12.2[V4 key fingerprints] are of 160-bit (40 characters) length. We accept longer keys to be future-proof in case a longer key fingerprint is introduced.\n+\n+In `ignore-key` elements, either fingerprints or long (64-bit) IDs can be used. A shorter ID can only result in a bigger range of exclusion, therefore, it's safe to use.\n ====\n \n This effectively means that you trust `com.github.javaparser:javaparser-core:3.6.11` if it's signed with the key `8756c4f765c9ac3cb6b85d62379ce192d401ab61`.\n@@ -407,14 +409,14 @@ If this is the case, you can move the trusted key from the artifact level to the\n       <verify-metadata>true</verify-metadata>\n       <verify-signatures>true</verify-signatures>\n       <trusted-keys>\n-         <trusted-key id=\"379ce192d401ab61\" group=\"com.github.javaparser\"/>\n+         <trusted-key id=\"8756c4f765c9ac3cb6b85d62379ce192d401ab61\" group=\"com.github.javaparser\"/>\n       </trusted-keys>\n    </configuration>\n    <components/>\n </verification-metadata>\n ----\n \n-The configuration above means that for any artifact belonging to the group `com.github.javaparser`, we trust it if it's signed with the `379ce192d401ab61`.\n+The configuration above means that for any artifact belonging to the group `com.github.javaparser`, we trust it if it's signed with the `8756c4f765c9ac3cb6b85d62379ce192d401ab61` fingerprint.\n \n The `trusted-key` element works similarly to the <<sec:trusting-artifacts,trusted-artifact>> element:\n \n@@ -497,14 +499,14 @@ You can generate this file using GPG, for example issuing the following commands\n \n [source,bash]\n ----\n-$ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 379ce192d401ab61\n+$ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 8756c4f765c9ac3cb6b85d62379ce192d401ab61\n \n gpg: keybox 'gradle/verification-keyring.gpg' created\n gpg: key 379CE192D401AB61: public key \"Bintray (by JFrog) <****>\" imported\n gpg: Total number processed: 1\n gpg:               imported: 1\n \n-$ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 6a0975f8b1127b83\n+$ gpg --no-default-keyring --keyring gradle/verification-keyring.gpg --recv-keys 6f538074ccebf35f28af9b066a0975f8b1127b83\n \n gpg: key 0729A0AFF8999A87: public key \"Kotlin Release <****>\" imported\n gpg: Total number processed: 1\n@@ -575,14 +577,14 @@ This is the case for example if you use <<sec:checksum-verification,checksum ver\n \n Gradle will tell you what metadata is missing:\n \n-\n ----\n Execution failed for task ':compileJava'.\n > Dependency verification failed for configuration ':compileClasspath':\n     - On artifact commons-logging-1.2.jar (commons-logging:commons-logging:1.2) in repository 'MavenRepo': checksum is missing from verification metadata.\n ----\n \n-- the missing module group is `commons-logging`, it's artifact name is `commons-logging` and its version is `1.2`. The corresponding artifact is `commons-logging-1.2.jar` so you need to add the following entry to the verification file:\n+- the missing module group is `commons-logging`, it's artifact name is `commons-logging` and its version is `1.2`.\n+The corresponding artifact is `commons-logging-1.2.jar` so you need to add the following entry to the verification file:\n \n [source,xml]\n ----\n@@ -599,7 +601,6 @@ Alternatively, you can ask Gradle to generate the missing information by using t\n \n A more problematic issue is when the actual checksum verification fails:\n \n-\n ----\n Execution failed for task ':compileJava'.\n > Dependency verification failed for configuration ':compileClasspath':\n@@ -612,7 +613,8 @@ Such a failure indicates that a **dependency may have been compromised**.\n At this stage, you **must** perform manual verification and check what happens.\n Several things can happen:\n \n-* a dependency was tampered in the local dependency cache of Gradle. This is usually harmless: erase the file from the cache and Gradle would redownload the dependency.\n+* a dependency was tampered in the local dependency cache of Gradle.\n+This is usually harmless: erase the file from the cache and Gradle would redownload the dependency.\n * a dependency is available in multiple sources with slightly different binaries (additional whitespace, ...)\n ** please inform the maintainers of the library that they have such an issue\n ** you can use <<#sec:trusting-several-checksums,`also-trust`>> to accept the additional checksums\n@@ -626,7 +628,6 @@ Note that a variation of a compromised library is often _name squatting_, when a\n \n If you have signature verification enabled, Gradle will perform verification of the signatures but will not trust them automatically:\n \n-\n ----\n > Dependency verification failed for configuration ':compileClasspath':\n     - On artifact javaparser-core-3.6.11.jar (com.github.javaparser:javaparser-core:3.6.11) in repository 'MavenRepo': Artifact was signed with key '379ce192d401ab61' (Bintray (by JFrog) <****>) and passed verification but the key isn't in your trusted keys list.\n@@ -711,7 +712,7 @@ $ curl https://my-company-mirror.com/repo/com/google/j2objc/j2objc-annotations/1\n Then we can use the key information provided in the error message to import the key locally:\n \n ----\n-$ gpg --recv-keys 29579f18fa8fd93b\n+$ gpg --recv-keys B801E2F8EF035068EC1139CC29579F18FA8FD93B\n ----\n \n And perform verification:\n@@ -798,14 +799,12 @@ The verification errors will be displayed during the build without causing a bui\n \n All those modes can be activated on the CLI using the `--dependency-verification` flag, for example:\n \n-\n ----\n ./gradlew --dependency-verification lenient build\n ----\n \n Alternatively, you can set the `org.gradle.dependency.verification` system property, either on the CLI:\n \n-\n ----\n ./gradlew -Dorg.gradle.dependency.verification=lenient build\n ----\n@@ -928,7 +927,6 @@ Gradle caches missing keys for 24 hours, meaning it will not attempt to re-downl\n \n If you want to retry immediately, you can run with the `--refresh-keys` CLI flag:\n \n-\n ----\n ./gradlew build --refresh-keys\n ----"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 10,
        "max_directory_depth": 14
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8397d4444d926b04db1ff7c25759cdcb9228d820",
            "date": "2025-01-14T13:32:20Z",
            "author_login": "ov7a"
          },
          {
            "sha": "4685365f4b3576491cf3e12091be6a61929a876c",
            "date": "2025-01-14T12:29:16Z",
            "author_login": "cobexer"
          },
          {
            "sha": "868a7e0b83a23e0f3a2b6c6db49a1648649e858c",
            "date": "2025-01-14T12:08:22Z",
            "author_login": "blindpirate"
          },
          {
            "sha": "ce1b982073effd605ad78df9f2ff5bbb370d7b94",
            "date": "2025-01-14T11:41:31Z",
            "author_login": "ov7a"
          },
          {
            "sha": "fd9039feb390957178ba086aa866e160fedc36e5",
            "date": "2025-01-14T10:18:47Z",
            "author_login": "6hundreds"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-829",
    "description": "Gradle is a build tool with a focus on build automation and support for multi-language development. This is a collision attack on long IDs (64bits) for PGP keys. Users of dependency verification in Gradle are vulnerable if they use long IDs for PGP keys in a `trusted-key` or `pgp` element in their dependency verification metadata file. The fix is to fail dependency verification if anything but a fingerprint is used in a trust element in dependency verification metadata. The problem is fixed in Gradle 8.0 and above. The problem is also patched in Gradle 6.9.4 and 7.6.1. As a workaround, use only full fingerprint IDs for `trusted-key` or `pgp` element in the metadata is a protection against this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-03-02T04:15:11.147",
    "last_modified": "2024-11-21T07:50:40.060",
    "fix_date": "2023-02-20T23:49:52Z"
  },
  "references": [
    {
      "url": "https://github.com/gradle/gradle/commit/bf3cc0f2b463033037e67aaacda31291643ea1a9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/gradle/gradle/security/advisories/GHSA-c724-3xg7-g3hf",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230413-0002/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gradle/gradle/commit/bf3cc0f2b463033037e67aaacda31291643ea1a9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/gradle/gradle/security/advisories/GHSA-c724-3xg7-g3hf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230413-0002/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.794200",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gradle",
    "owner": "gradle",
    "created_at": "2009-09-09T18:27:19Z",
    "updated_at": "2025-01-14T11:57:21Z",
    "pushed_at": "2025-01-14T13:32:33Z",
    "size": 584073,
    "stars": 17169,
    "forks": 4814,
    "open_issues": 3031,
    "watchers": 17169,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Groovy": 35373708,
      "Java": 32924568,
      "Kotlin": 5104589,
      "C++": 888505,
      "JavaScript": 77171,
      "HTML": 15779,
      "CSS": 14880,
      "Shell": 12301,
      "XSLT": 7121,
      "C": 5785,
      "Scala": 2817,
      "Gherkin": 192,
      "Python": 58,
      "Brainfuck": 54
    },
    "commit_activity": {
      "total_commits_last_year": 9381,
      "avg_commits_per_week": 180.40384615384616,
      "days_active_last_year": 341
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:36:38.929346"
  }
}