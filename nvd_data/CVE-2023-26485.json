{
  "cve_id": "CVE-2023-26485",
  "github_data": {
    "repository": "github/cmark-gfm",
    "fix_commit": "07a66c9bc341f902878e37d7da8647d6ef150987",
    "related_commits": [
      "07a66c9bc341f902878e37d7da8647d6ef150987",
      "07a66c9bc341f902878e37d7da8647d6ef150987"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "07a66c9bc341f902878e37d7da8647d6ef150987",
      "commit_date": "2023-03-31T17:29:29Z",
      "author": {
        "login": "anticomputer",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-r8vr-c48j-fcc5",
        "length": 80,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 180,
        "additions": 80,
        "deletions": 100
      },
      "files": [
        {
          "filename": "src/commonmark.c",
          "status": "modified",
          "additions": 19,
          "deletions": 33,
          "patch": "@@ -153,23 +153,8 @@ static bool is_autolink(cmark_node *node) {\n                   link_text->as.literal.len) == 0);\n }\n \n-// if node is a block node, returns node.\n-// otherwise returns first block-level node that is an ancestor of node.\n-// if there is no block-level ancestor, returns NULL.\n-static cmark_node *get_containing_block(cmark_node *node) {\n-  while (node) {\n-    if (CMARK_NODE_BLOCK_P(node)) {\n-      return node;\n-    } else {\n-      node = node->parent;\n-    }\n-  }\n-  return NULL;\n-}\n-\n static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n                          cmark_event_type ev_type, int options) {\n-  cmark_node *tmp;\n   int list_number;\n   cmark_delim_type list_delim;\n   int numticks;\n@@ -189,14 +174,17 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n   // Don't adjust tight list status til we've started the list.\n   // Otherwise we loose the blank line between a paragraph and\n   // a following list.\n-  if (!(node->type == CMARK_NODE_ITEM && node->prev == NULL && entering)) {\n-    tmp = get_containing_block(node);\n-    renderer->in_tight_list_item =\n-        tmp && // tmp might be NULL if there is no containing block\n-        ((tmp->type == CMARK_NODE_ITEM &&\n-          cmark_node_get_list_tight(tmp->parent)) ||\n-         (tmp && tmp->parent && tmp->parent->type == CMARK_NODE_ITEM &&\n-          cmark_node_get_list_tight(tmp->parent->parent)));\n+  if (entering) {\n+    if (node->parent && node->parent->type == CMARK_NODE_ITEM) {\n+      renderer->in_tight_list_item = node->parent->parent->as.list.tight;\n+    }\n+  } else {\n+    if (node->type == CMARK_NODE_LIST) {\n+      renderer->in_tight_list_item =\n+        node->parent &&\n+        node->parent->type == CMARK_NODE_ITEM &&\n+        node->parent->parent->as.list.tight;\n+    }\n   }\n \n   if (node->extension && node->extension->commonmark_render_func) {\n@@ -228,19 +216,15 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n       LIT(\"<!-- end list -->\");\n       BLANKLINE();\n     }\n+    renderer->list_number = cmark_node_get_list_start(node);\n     break;\n \n   case CMARK_NODE_ITEM:\n     if (cmark_node_get_list_type(node->parent) == CMARK_BULLET_LIST) {\n       marker_width = 4;\n     } else {\n-      list_number = cmark_node_get_list_start(node->parent);\n+      list_number = renderer->list_number++;\n       list_delim = cmark_node_get_list_delim(node->parent);\n-      tmp = node;\n-      while (tmp->prev) {\n-        tmp = tmp->prev;\n-        list_number += 1;\n-      }\n       // we ensure a width of at least 4 so\n       // we get nice transition from single digits\n       // to double\n@@ -405,10 +389,12 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-    if (entering) {\n-      LIT(\"**\");\n-    } else {\n-      LIT(\"**\");\n+    if (node->parent == NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering) {\n+        LIT(\"**\");\n+      } else {\n+        LIT(\"**\");\n+      }\n     }\n     break;\n "
        },
        {
          "filename": "src/html.c",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -364,10 +364,12 @@ static int S_render_node(cmark_html_renderer *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-    if (entering) {\n-      cmark_strbuf_puts(html, \"<strong>\");\n-    } else {\n-      cmark_strbuf_puts(html, \"</strong>\");\n+    if (node->parent == NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering) {\n+        cmark_strbuf_puts(html, \"<strong>\");\n+      } else {\n+        cmark_strbuf_puts(html, \"</strong>\");\n+      }\n     }\n     break;\n "
        },
        {
          "filename": "src/latex.c",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -385,10 +385,12 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-    if (entering) {\n-      LIT(\"\\\\textbf{\");\n-    } else {\n-      LIT(\"}\");\n+    if (node->parent == NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering) {\n+        LIT(\"\\\\textbf{\");\n+      } else {\n+        LIT(\"}\");\n+      }\n     }\n     break;\n "
        },
        {
          "filename": "src/man.c",
          "status": "modified",
          "additions": 8,
          "deletions": 11,
          "patch": "@@ -74,7 +74,6 @@ static void S_outc(cmark_renderer *renderer, cmark_node *node,\n \n static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n                          cmark_event_type ev_type, int options) {\n-  cmark_node *tmp;\n   int list_number;\n   bool entering = (ev_type == CMARK_EVENT_ENTER);\n   bool allow_wrap = renderer->width > 0 && !(CMARK_OPT_NOBREAKS & options);\n@@ -114,6 +113,7 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_LIST:\n+    renderer->list_number = cmark_node_get_list_start(node);\n     break;\n \n   case CMARK_NODE_ITEM:\n@@ -123,12 +123,7 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n       if (cmark_node_get_list_type(node->parent) == CMARK_BULLET_LIST) {\n         LIT(\"\\\\[bu] 2\");\n       } else {\n-        list_number = cmark_node_get_list_start(node->parent);\n-        tmp = node;\n-        while (tmp->prev) {\n-          tmp = tmp->prev;\n-          list_number += 1;\n-        }\n+        list_number = renderer->list_number++;\n         char list_number_s[LIST_NUMBER_SIZE];\n         snprintf(list_number_s, LIST_NUMBER_SIZE, \"\\\"%d.\\\" 4\", list_number);\n         LIT(list_number_s);\n@@ -225,10 +220,12 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-    if (entering) {\n-      LIT(\"\\\\f[B]\");\n-    } else {\n-      LIT(\"\\\\f[]\");\n+    if (node->parent == NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering) {\n+        LIT(\"\\\\f[B]\");\n+      } else {\n+        LIT(\"\\\\f[]\");\n+      }\n     }\n     break;\n "
        },
        {
          "filename": "src/node.h",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -83,6 +83,14 @@ struct cmark_node {\n \n   cmark_syntax_extension *extension;\n \n+  /**\n+   * Used during cmark_render() to cache the most recent non-NULL\n+   * extension, if you go up the parent chain like this:\n+   *\n+   * node->parent->...parent->extension\n+   */\n+  cmark_syntax_extension *ancestor_extension;\n+\n   union {\n     int ref_ix;\n     int def_count;"
        },
        {
          "filename": "src/plaintext.c",
          "status": "modified",
          "additions": 13,
          "deletions": 29,
          "patch": "@@ -16,23 +16,8 @@ static CMARK_INLINE void outc(cmark_renderer *renderer, cmark_node *node,\n   cmark_render_code_point(renderer, c);\n }\n \n-// if node is a block node, returns node.\n-// otherwise returns first block-level node that is an ancestor of node.\n-// if there is no block-level ancestor, returns NULL.\n-static cmark_node *get_containing_block(cmark_node *node) {\n-  while (node) {\n-    if (CMARK_NODE_BLOCK_P(node)) {\n-      return node;\n-    } else {\n-      node = node->parent;\n-    }\n-  }\n-  return NULL;\n-}\n-\n static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n                          cmark_event_type ev_type, int options) {\n-  cmark_node *tmp;\n   int list_number;\n   cmark_delim_type list_delim;\n   int i;\n@@ -46,14 +31,17 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n   // Don't adjust tight list status til we've started the list.\n   // Otherwise we loose the blank line between a paragraph and\n   // a following list.\n-  if (!(node->type == CMARK_NODE_ITEM && node->prev == NULL && entering)) {\n-    tmp = get_containing_block(node);\n-    renderer->in_tight_list_item =\n-        tmp && // tmp might be NULL if there is no containing block\n-        ((tmp->type == CMARK_NODE_ITEM &&\n-          cmark_node_get_list_tight(tmp->parent)) ||\n-         (tmp && tmp->parent && tmp->parent->type == CMARK_NODE_ITEM &&\n-          cmark_node_get_list_tight(tmp->parent->parent)));\n+  if (entering) {\n+    if (node->parent && node->parent->type == CMARK_NODE_ITEM) {\n+      renderer->in_tight_list_item = node->parent->parent->as.list.tight;\n+    }\n+  } else {\n+    if (node->type == CMARK_NODE_LIST) {\n+      renderer->in_tight_list_item =\n+        node->parent &&\n+        node->parent->type == CMARK_NODE_ITEM &&\n+        node->parent->parent->as.list.tight;\n+    }\n   }\n \n   if (node->extension && node->extension->plaintext_render_func) {\n@@ -73,19 +61,15 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n                                     node->next->type == CMARK_NODE_LIST)) {\n       CR();\n     }\n+    renderer->list_number = cmark_node_get_list_start(node);\n     break;\n \n   case CMARK_NODE_ITEM:\n     if (cmark_node_get_list_type(node->parent) == CMARK_BULLET_LIST) {\n       marker_width = 4;\n     } else {\n-      list_number = cmark_node_get_list_start(node->parent);\n+      list_number = renderer->list_number++;\n       list_delim = cmark_node_get_list_delim(node->parent);\n-      tmp = node;\n-      while (tmp->prev) {\n-        tmp = tmp->prev;\n-        list_number += 1;\n-      }\n       // we ensure a width of at least 4 so\n       // we get nice transition from single digits\n       // to double"
        },
        {
          "filename": "src/render.c",
          "status": "modified",
          "additions": 8,
          "deletions": 9,
          "patch": "@@ -31,13 +31,7 @@ static void S_out(cmark_renderer *renderer, cmark_node *node,\n   cmark_chunk remainder = cmark_chunk_literal(\"\");\n   int k = renderer->buffer->size - 1;\n \n-  cmark_syntax_extension *ext = NULL;\n-  cmark_node *n = node;\n-  while (n && !ext) {\n-    ext = n->extension;\n-    if (!ext)\n-      n = n->parent;\n-  }\n+  cmark_syntax_extension *ext = node->ancestor_extension;\n   if (ext && !ext->commonmark_escape_func)\n     ext = NULL;\n \n@@ -177,11 +171,16 @@ char *cmark_render(cmark_mem *mem, cmark_node *root, int options, int width,\n \n   cmark_renderer renderer = {mem,   &buf, &pref, 0,           width,\n                              0,     0,    true,  true,        false,\n-                             false, outc, S_cr,  S_blankline, S_out,\n-                             0};\n+                             false, 0,    outc,  S_cr,        S_blankline,\n+                             S_out, 0};\n \n   while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n     cur = cmark_iter_get_node(iter);\n+    if (cur->extension) {\n+      cur->ancestor_extension = cur->extension;\n+    } else if (cur->parent) {\n+      cur->ancestor_extension = cur->parent->ancestor_extension;\n+    }\n     if (!render_node(&renderer, cur, ev_type, options)) {\n       // a false value causes us to skip processing\n       // the node's contents.  this is used for"
        },
        {
          "filename": "src/render.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -23,6 +23,7 @@ struct cmark_renderer {\n   bool begin_content;\n   bool no_linebreaks;\n   bool in_tight_list_item;\n+  int list_number;\n   void (*outc)(struct cmark_renderer *, cmark_node *, cmark_escaping, int32_t, unsigned char);\n   void (*cr)(struct cmark_renderer *);\n   void (*blankline)(struct cmark_renderer *);"
        },
        {
          "filename": "src/xml.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -11,6 +11,7 @@\n #include \"syntax_extension.h\"\n \n #define BUFFER_SIZE 100\n+#define MAX_INDENT 40\n \n // Functions to convert cmark_nodes to XML strings.\n \n@@ -26,7 +27,7 @@ struct render_state {\n \n static CMARK_INLINE void indent(struct render_state *state) {\n   int i;\n-  for (i = 0; i < state->indent; i++) {\n+  for (i = 0; i < state->indent && i < MAX_INDENT; i++) {\n     cmark_strbuf_putc(state->xml, ' ');\n   }\n }"
        },
        {
          "filename": "test/spec.txt",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -6926,7 +6926,7 @@ foo__bar__\n ```````````````````````````````` example\n __foo, __bar__, baz__\n .\n-<p><strong>foo, <strong>bar</strong>, baz</strong></p>\n+<p><strong>foo, bar, baz</strong></p>\n ````````````````````````````````\n \n \n@@ -7197,7 +7197,7 @@ foo***bar***baz\n ```````````````````````````````` example\n foo******bar*********baz\n .\n-<p>foo<strong><strong><strong>bar</strong></strong></strong>***baz</p>\n+<p>foo<strong>bar</strong>***baz</p>\n ````````````````````````````````\n \n \n@@ -7268,21 +7268,21 @@ __foo _bar_ baz__\n ```````````````````````````````` example\n __foo __bar__ baz__\n .\n-<p><strong>foo <strong>bar</strong> baz</strong></p>\n+<p><strong>foo bar baz</strong></p>\n ````````````````````````````````\n \n \n ```````````````````````````````` example\n ____foo__ bar__\n .\n-<p><strong><strong>foo</strong> bar</strong></p>\n+<p><strong>foo bar</strong></p>\n ````````````````````````````````\n \n \n ```````````````````````````````` example\n **foo **bar****\n .\n-<p><strong>foo <strong>bar</strong></strong></p>\n+<p><strong>foo bar</strong></p>\n ````````````````````````````````\n \n \n@@ -7567,14 +7567,14 @@ switching delimiters:\n ```````````````````````````````` example\n ****foo****\n .\n-<p><strong><strong>foo</strong></strong></p>\n+<p><strong>foo</strong></p>\n ````````````````````````````````\n \n \n ```````````````````````````````` example\n ____foo____\n .\n-<p><strong><strong>foo</strong></strong></p>\n+<p><strong>foo</strong></p>\n ````````````````````````````````\n \n \n@@ -7585,7 +7585,7 @@ delimiters:\n ```````````````````````````````` example\n ******foo******\n .\n-<p><strong><strong><strong>foo</strong></strong></strong></p>\n+<p><strong>foo</strong></p>\n ````````````````````````````````\n \n \n@@ -7601,7 +7601,7 @@ Rule 14:\n ```````````````````````````````` example\n _____foo_____\n .\n-<p><em><strong><strong>foo</strong></strong></em></p>\n+<p><em><strong>foo</strong></em></p>\n ````````````````````````````````\n \n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "587a12bb54d95ac37241377e6ddc93ea0e45439b",
            "date": "2023-07-21T15:19:43Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "808bcfbac333d7e82d528d69aaaa33e184921eea",
            "date": "2023-07-20T16:19:53Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "63dd7b72e0b785a967cb2f760e22e4e5e45bcd4b",
            "date": "2023-07-20T16:15:27Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "c123e68e81725d59f30d5a9bee719125538a6c77",
            "date": "2023-07-20T16:14:55Z",
            "author_login": "anticomputer"
          },
          {
            "sha": "049a6e389c8fe2cd75f9b2217411520d85b368d9",
            "date": "2023-07-20T16:14:28Z",
            "author_login": "anticomputer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library and program in C. A polynomial time complexity issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent denial of service. This CVE covers quadratic complexity issues when parsing text which leads with either large numbers of `_` characters. This issue has been addressed in version 0.29.0.gfm.10. Users are advised to upgrade. Users unable to upgrade should validate that their input comes from trusted sources.\n\n\n\n\n### Impact\n\nA polynomial time complexity issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent denial of service.\n\n### Proof of concept\n\n```\n$ ~/cmark-gfm$ python3 -c 'pad = \"_\" * 100000; print(pad + \".\" + pad, end=\"\")' | time ./build/src/cmark-gfm --to plaintext\n```\n\nIncreasing the number 10000 in the above commands causes the running time to increase quadratically.\n\n### Patches\n\nThis vulnerability have been patched in 0.29.0.gfm.10.\n\n### Note on cmark and cmark-gfm\n\nXXX: TBD\n\n[cmark-gfm](https://github.com/github/cmark-gfm) is a fork of [cmark](https://github.com/commonmark/cmark) that adds the GitHub Flavored Markdown extensions. The two codebases have diverged over time, but share a common core. These bugs affect both `cmark` and `cmark-gfm`. \n\n### Credit\n\nWe would like to thank @gravypod for reporting this vulnerability.\n\n### References\n\nhttps://en.wikipedia.org/wiki/Time_complexity\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n\n* Open an issue in [github/cmark-gfm](https://github.com/github/cmark-gfm)\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-31T23:15:07.250",
    "last_modified": "2024-11-21T07:51:36.963",
    "fix_date": "2023-03-31T17:29:29Z"
  },
  "references": [
    {
      "url": "https://github.com/github/cmark-gfm/commit/07a66c9bc341f902878e37d7da8647d6ef150987",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/github/cmark-gfm/security/advisories/GHSA-r8vr-c48j-fcc5",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/github/cmark-gfm/commit/07a66c9bc341f902878e37d7da8647d6ef150987",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/github/cmark-gfm/security/advisories/GHSA-r8vr-c48j-fcc5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:09.032771",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "cmark-gfm",
    "owner": "github",
    "created_at": "2016-12-01T01:48:24Z",
    "updated_at": "2025-01-23T16:28:03Z",
    "pushed_at": "2024-08-19T05:13:47Z",
    "size": 6144,
    "stars": 924,
    "forks": 177,
    "open_issues": 121,
    "watchers": 924,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 768727,
      "C++": 201370,
      "Python": 50409,
      "CMake": 22945,
      "XSLT": 11938,
      "Racket": 8625,
      "Makefile": 7169,
      "Shell": 899,
      "Dockerfile": 820,
      "Perl": 525,
      "Ruby": 316,
      "Batchfile": 294,
      "JavaScript": 102
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:08:09.307655"
  }
}