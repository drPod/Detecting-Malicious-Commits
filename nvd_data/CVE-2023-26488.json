{
  "cve_id": "CVE-2023-26488",
  "github_data": {
    "repository": "OpenZeppelin/openzeppelin-contracts",
    "fix_commit": "167bf67ed3907f4a674043496019fa346cee7705",
    "related_commits": [
      "167bf67ed3907f4a674043496019fa346cee7705",
      "167bf67ed3907f4a674043496019fa346cee7705"
    ],
    "patch_url": "https://github.com/OpenZeppelin/openzeppelin-contracts/commit/167bf67ed3907f4a674043496019fa346cee7705.patch",
    "fix_commit_details": {
      "sha": "167bf67ed3907f4a674043496019fa346cee7705",
      "commit_date": "2023-03-02T22:41:28Z",
      "author": {
        "login": "Amxx",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix ERC721Consecutive balance update on batch size 1",
        "length": 216,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 161,
        "additions": 149,
        "deletions": 12
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -1,5 +1,13 @@\n # Changelog\n \n+## 4.8.2\n+\n+- `ERC721Consecutive`: Fixed a bug when `_mintConsecutive` is used for batches of size 1 that could lead to balance overflow. Refer to the breaking changes section in the changelog for a note on the behavior of `ERC721._beforeTokenTransfer`.\n+\n+### Breaking changes\n+\n+- `ERC721`: The internal function `_beforeTokenTransfer` no longer updates balances, which it previously did when `batchSize` was greater than 1. This change has no consequence unless a custom ERC721 extension is explicitly invoking `_beforeTokenTransfer`. Balance updates in extensions must now be done explicitly using `__unsafe_increaseBalance`, with a name that indicates that there is an invariant that has to be manually verified.\n+\n ## 4.8.1 (2023-01-13)\n \n  * `ERC4626`: Use staticcall instead of call when fetching underlying ERC-20 decimals. ([#3943](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3943))"
        },
        {
          "filename": "contracts/token/ERC721/ERC721.sol",
          "status": "modified",
          "additions": 14,
          "deletions": 11,
          "patch": "@@ -467,18 +467,9 @@ contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n     function _beforeTokenTransfer(\n         address from,\n         address to,\n-        uint256, /* firstTokenId */\n+        uint256 firstTokenId,\n         uint256 batchSize\n-    ) internal virtual {\n-        if (batchSize > 1) {\n-            if (from != address(0)) {\n-                _balances[from] -= batchSize;\n-            }\n-            if (to != address(0)) {\n-                _balances[to] += batchSize;\n-            }\n-        }\n-    }\n+    ) internal virtual {}\n \n     /**\n      * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n@@ -500,4 +491,16 @@ contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n         uint256 firstTokenId,\n         uint256 batchSize\n     ) internal virtual {}\n+\n+    /**\n+     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n+     *\n+     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n+     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n+     * that `ownerOf(tokenId)` is `a`.\n+     */\n+    // solhint-disable-next-line func-name-mixedcase\n+    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n+        _balances[account] += amount;\n+    }\n }"
        },
        {
          "filename": "contracts/token/ERC721/extensions/ERC721Consecutive.sol",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -96,6 +96,11 @@ abstract contract ERC721Consecutive is IERC2309, ERC721 {\n             // push an ownership checkpoint & emit event\n             uint96 last = first + batchSize - 1;\n             _sequentialOwnership.push(last, uint160(to));\n+\n+            // The invariant required by this function is preserved because the new sequentialOwnership checkpoint\n+            // is attributing ownership of `batchSize` new tokens to account `to`.\n+            __unsafe_increaseBalance(to, batchSize);\n+\n             emit ConsecutiveTransfer(first, last, address(0), to);\n \n             // hook after"
        },
        {
          "filename": "test/token/ERC721/extensions/ERC721Consecutive.t.sol",
          "status": "added",
          "additions": 120,
          "deletions": 0,
          "patch": "@@ -0,0 +1,120 @@\n+// SPDX-License-Identifier: MIT\n+\n+pragma solidity ^0.8.0;\n+\n+import \"../../../../contracts/token/ERC721/extensions/ERC721Consecutive.sol\";\n+import \"forge-std/Test.sol\";\n+\n+function toSingleton(address account) pure returns (address[] memory) {\n+    address[] memory accounts = new address[](1);\n+    accounts[0] = account;\n+    return accounts;\n+}\n+\n+contract ERC721ConsecutiveTarget is StdUtils, ERC721Consecutive {\n+    uint256 public totalMinted = 0;\n+\n+    constructor(address[] memory receivers, uint256[] memory batches) ERC721(\"\", \"\") {\n+        for (uint256 i = 0; i < batches.length; i++) {\n+            address receiver = receivers[i % receivers.length];\n+            uint96 batchSize = uint96(bound(batches[i], 0, _maxBatchSize()));\n+            _mintConsecutive(receiver, batchSize);\n+            totalMinted += batchSize;\n+        }\n+    }\n+\n+    function burn(uint256 tokenId) public {\n+        _burn(tokenId);\n+    }\n+}\n+\n+contract ERC721ConsecutiveTest is Test {\n+    function test_balance(address receiver, uint256[] calldata batches) public {\n+        vm.assume(receiver != address(0));\n+\n+        ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(toSingleton(receiver), batches);\n+\n+        assertEq(token.balanceOf(receiver), token.totalMinted());\n+    }\n+\n+    function test_ownership(address receiver, uint256[] calldata batches, uint256[2] calldata unboundedTokenId) public {\n+        vm.assume(receiver != address(0));\n+\n+        ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(toSingleton(receiver), batches);\n+\n+        if (token.totalMinted() > 0) {\n+            uint256 validTokenId = bound(unboundedTokenId[0], 0, token.totalMinted() - 1);\n+            assertEq(token.ownerOf(validTokenId), receiver);\n+        }\n+\n+        uint256 invalidTokenId = bound(unboundedTokenId[1], token.totalMinted(), type(uint256).max);\n+        vm.expectRevert();\n+        token.ownerOf(invalidTokenId);\n+    }\n+\n+    function test_burn(address receiver, uint256[] calldata batches, uint256 unboundedTokenId) public {\n+        vm.assume(receiver != address(0));\n+\n+        ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(toSingleton(receiver), batches);\n+\n+        // only test if we minted at least one token\n+        uint256 supply = token.totalMinted();\n+        vm.assume(supply > 0);\n+\n+        // burn a token in [0; supply[\n+        uint256 tokenId = bound(unboundedTokenId, 0, supply - 1);\n+        token.burn(tokenId);\n+\n+        // balance should have decreased\n+        assertEq(token.balanceOf(receiver), supply - 1);\n+\n+        // token should be burnt\n+        vm.expectRevert();\n+        token.ownerOf(tokenId);\n+    }\n+\n+    function test_transfer(\n+        address[2] calldata accounts,\n+        uint256[2] calldata unboundedBatches,\n+        uint256[2] calldata unboundedTokenId\n+    ) public {\n+        vm.assume(accounts[0] != address(0));\n+        vm.assume(accounts[1] != address(0));\n+        vm.assume(accounts[0] != accounts[1]);\n+\n+        address[] memory receivers = new address[](2);\n+        receivers[0] = accounts[0];\n+        receivers[1] = accounts[1];\n+\n+        // We assume _maxBatchSize is 5000 (the default). This test will break otherwise.\n+        uint256[] memory batches = new uint256[](2);\n+        batches[0] = bound(unboundedBatches[0], 1, 5000);\n+        batches[1] = bound(unboundedBatches[1], 1, 5000);\n+\n+        ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(receivers, batches);\n+\n+        uint256 tokenId0 = bound(unboundedTokenId[0], 0, batches[0] - 1);\n+        uint256 tokenId1 = bound(unboundedTokenId[1], 0, batches[1] - 1) + batches[0];\n+\n+        assertEq(token.ownerOf(tokenId0), accounts[0]);\n+        assertEq(token.ownerOf(tokenId1), accounts[1]);\n+        assertEq(token.balanceOf(accounts[0]), batches[0]);\n+        assertEq(token.balanceOf(accounts[1]), batches[1]);\n+\n+        vm.prank(accounts[0]);\n+        token.transferFrom(accounts[0], accounts[1], tokenId0);\n+\n+        assertEq(token.ownerOf(tokenId0), accounts[1]);\n+        assertEq(token.ownerOf(tokenId1), accounts[1]);\n+        assertEq(token.balanceOf(accounts[0]), batches[0] - 1);\n+        assertEq(token.balanceOf(accounts[1]), batches[1] + 1);\n+\n+        vm.prank(accounts[1]);\n+        token.transferFrom(accounts[1], accounts[0], tokenId1);\n+\n+        assertEq(token.ownerOf(tokenId0), accounts[1]);\n+        assertEq(token.ownerOf(tokenId1), accounts[0]);\n+        assertEq(token.balanceOf(accounts[0]), batches[0]);\n+        assertEq(token.balanceOf(accounts[1]), batches[1]);\n+    }\n+}"
        },
        {
          "filename": "test/token/ERC721/extensions/ERC721Consecutive.test.js",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -12,7 +12,8 @@ contract('ERC721Consecutive', function (accounts) {\n   const symbol = 'NFT';\n   const batches = [\n     { receiver: user1, amount: 0 },\n-    { receiver: user1, amount: 3 },\n+    { receiver: user1, amount: 1 },\n+    { receiver: user1, amount: 2 },\n     { receiver: user2, amount: 5 },\n     { receiver: user3, amount: 0 },\n     { receiver: user1, amount: 7 },"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "96b40d02c3fe836ffa19b6ed9217c3719c996f78",
            "date": "2025-01-10T20:59:14Z",
            "author_login": "ernestognw"
          },
          {
            "sha": "13781c1f4982908d40d8936f58c36d5227e168a7",
            "date": "2025-01-10T16:43:28Z",
            "author_login": "Amxx"
          },
          {
            "sha": "2e27a0c74b228215d73be24a90260789c9cdb4ae",
            "date": "2025-01-10T16:43:11Z",
            "author_login": "arr00"
          },
          {
            "sha": "352ab136878f652658f8f4e3d70b4087563653c4",
            "date": "2025-01-10T01:48:32Z",
            "author_login": "Amxx"
          },
          {
            "sha": "7b74442c5e87ea51dde41c7f18a209fa5154f1a4",
            "date": "2025-01-09T16:16:31Z",
            "author_login": "github-actions[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-682",
    "description": "OpenZeppelin Contracts is a library for secure smart contract development. The ERC721Consecutive contract designed for minting NFTs in batches does not update balances when a batch has size 1 and consists of a single token. Subsequent transfers from the receiver of that token may overflow the balance as reported by `balanceOf`. The issue exclusively presents with batches of size 1. The issue has been patched in 4.8.2.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-03T22:15:09.897",
    "last_modified": "2024-11-21T07:51:37.320",
    "fix_date": "2023-03-02T22:41:28Z"
  },
  "references": [
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts/commit/167bf67ed3907f4a674043496019fa346cee7705",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.8.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-878m-3g6q-594q",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts/commit/167bf67ed3907f4a674043496019fa346cee7705",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v4.8.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-878m-3g6q-594q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.800690",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "openzeppelin-contracts",
    "owner": "OpenZeppelin",
    "created_at": "2016-08-01T20:54:54Z",
    "updated_at": "2025-01-14T13:39:35Z",
    "pushed_at": "2025-01-13T16:34:19Z",
    "size": 47412,
    "stars": 25188,
    "forks": 11862,
    "open_issues": 289,
    "watchers": 25188,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "audit/M-01",
      "audit/2023-03",
      "audit/2023-06",
      "audit/2023-07-10",
      "audit/2023-07-24",
      "audit/2023-08-01",
      "audit/2023-08-07",
      "docs-org",
      "docs-v2.x",
      "docs-v3.x",
      "docs-v4.x",
      "docs-v5.x",
      "master",
      "next-v5.0",
      "release-v2.3.0",
      "release-v2.4.0",
      "release-v2.5.0",
      "release-v3.0.0",
      "release-v3.1.0",
      "release-v3.2.0-solc-0.7",
      "release-v3.2.0",
      "release-v3.3-solc-0.7"
    ],
    "languages": {
      "Solidity": 1279163,
      "JavaScript": 1230104,
      "Python": 170889,
      "Ruby": 95064,
      "Shell": 9208,
      "Makefile": 1714
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:42:13.725104"
  }
}