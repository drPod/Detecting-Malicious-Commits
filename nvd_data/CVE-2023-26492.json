{
  "cve_id": "CVE-2023-26492",
  "github_data": {
    "repository": "directus/directus",
    "fix_commit": "ff53d3e69a602d05342e15d9bb616884833ddbff",
    "related_commits": [
      "ff53d3e69a602d05342e15d9bb616884833ddbff",
      "ff53d3e69a602d05342e15d9bb616884833ddbff"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "ff53d3e69a602d05342e15d9bb616884833ddbff",
      "commit_date": "2023-02-13T20:49:24Z",
      "author": {
        "login": "rijkvanzanten",
        "type": "User",
        "stats": {
          "total_commits": 6882,
          "average_weekly_commits": 26.367816091954023,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 247
        }
      },
      "commit_message": {
        "title": "Cleanup request handler",
        "length": 888,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 296,
        "additions": 223,
        "deletions": 73
      },
      "files": [
        {
          "filename": "api/src/env.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -257,7 +257,7 @@ const defaults: Record<string, any> = {\n \tIP_TRUST_PROXY: true,\n \tIP_CUSTOM_HEADER: false,\n \n-\tIMPORT_IP_DENY_LIST: '0.0.0.0',\n+\tIMPORT_IP_DENY_LIST: ['0.0.0.0', '169.254.169.254'],\n \n \tSERVE_APP: true,\n "
        },
        {
          "filename": "api/src/operations/request/index.test.ts",
          "status": "modified",
          "additions": 8,
          "deletions": 7,
          "patch": "@@ -2,13 +2,14 @@ import { afterEach, expect, test, vi } from 'vitest';\n \n const axiosDefault = vi.fn();\n \n-vi.mock('axios', () => ({\n-\tdefault: axiosDefault.mockResolvedValue({\n-\t\tstatus: 200,\n-\t\tstatusText: 'OK',\n-\t\theaders: {},\n-\t\tdata: {},\n-\t}),\n+vi.mock('../../request', () => ({\n+\tgetAxios: () =>\n+\t\taxiosDefault.mockResolvedValue({\n+\t\t\tstatus: 200,\n+\t\t\tstatusText: 'OK',\n+\t\t\theaders: {},\n+\t\t\tdata: {},\n+\t\t}),\n }));\n \n const url = '/';"
        },
        {
          "filename": "api/src/operations/request/index.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,5 +1,6 @@\n import { defineOperationApi, parseJSON } from '@directus/shared/utils';\n import encodeUrl from 'encodeurl';\n+import { getAxios } from '../../request/index';\n \n type Options = {\n \turl: string;\n@@ -12,8 +13,6 @@ export default defineOperationApi<Options>({\n \tid: 'request',\n \n \thandler: async ({ url, method, body, headers }) => {\n-\t\tconst axios = (await import('axios')).default;\n-\n \t\tconst customHeaders =\n \t\t\theaders?.reduce((acc, { header, value }) => {\n \t\t\t\tacc[header] = value;\n@@ -24,6 +23,7 @@ export default defineOperationApi<Options>({\n \t\t\tcustomHeaders['Content-Type'] = 'application/json';\n \t\t}\n \n+\t\tconst axios = await getAxios();\n \t\tconst result = await axios({\n \t\t\turl: encodeUrl(url),\n \t\t\tmethod,"
        },
        {
          "filename": "api/src/request/index.test.ts",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+import { test, vi, afterEach, beforeEach, expect } from 'vitest';\n+import { getAxios, _cache } from './index';\n+import axios from 'axios';\n+import type { AxiosInstance } from 'axios';\n+\n+vi.mock('axios');\n+\n+let mockAxiosInstance: AxiosInstance;\n+\n+beforeEach(() => {\n+\tmockAxiosInstance = {\n+\t\tinterceptors: {\n+\t\t\tresponse: {\n+\t\t\t\tuse: vi.fn(),\n+\t\t\t},\n+\t\t},\n+\t} as unknown as AxiosInstance;\n+\n+\tvi.mocked(axios.create).mockReturnValue(mockAxiosInstance);\n+});\n+\n+afterEach(() => {\n+\tvi.resetAllMocks();\n+\t_cache.axiosInstance = null;\n+});\n+\n+test('Creates and returns new axios instance if cache is empty', async () => {\n+\tconst instance = await getAxios();\n+\texpect(axios.create).toHaveBeenCalled();\n+\texpect(instance).toBe(mockAxiosInstance);\n+});"
        },
        {
          "filename": "api/src/request/index.ts",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+import type { AxiosInstance } from 'axios';\n+import { responseInterceptor } from './response-interceptor';\n+\n+export const _cache: { axiosInstance: AxiosInstance | null } = {\n+\taxiosInstance: null,\n+};\n+\n+export async function getAxios() {\n+\tif (!_cache.axiosInstance) {\n+\t\tconst axios = (await import('axios')).default;\n+\t\t_cache.axiosInstance = axios.create();\n+\t\t_cache.axiosInstance.interceptors.response.use(responseInterceptor);\n+\t}\n+\n+\treturn _cache.axiosInstance;\n+}"
        },
        {
          "filename": "api/src/request/response-interceptor.test.ts",
          "status": "added",
          "additions": 44,
          "deletions": 0,
          "patch": "@@ -0,0 +1,44 @@\n+import { randIp, randUrl } from '@ngneat/falso';\n+import type { AxiosResponse } from 'axios';\n+import { afterEach, beforeEach, expect, test, vi } from 'vitest';\n+import { responseInterceptor } from './response-interceptor';\n+import { validateIP } from './validate-ip';\n+\n+vi.mock('./validate-ip');\n+\n+let sample: {\n+\tremoteAddress: string;\n+\turl: string;\n+};\n+\n+let sampleResponseConfig: AxiosResponse<any, any>;\n+\n+beforeEach(() => {\n+\tsample = {\n+\t\tremoteAddress: randIp(),\n+\t\turl: randUrl(),\n+\t};\n+\n+\tsampleResponseConfig = {\n+\t\trequest: {\n+\t\t\tsocket: {\n+\t\t\t\tremoteAddress: sample.remoteAddress,\n+\t\t\t},\n+\t\t\turl: sample.url,\n+\t\t},\n+\t} as AxiosResponse<any, any>;\n+});\n+\n+afterEach(() => {\n+\tvi.resetAllMocks();\n+});\n+\n+test(`Calls validateIP with IP/url from axios request config`, async () => {\n+\tawait responseInterceptor(sampleResponseConfig);\n+\texpect(validateIP).toHaveBeenCalledWith(sample.remoteAddress, sample.url);\n+});\n+\n+test(`Returns passed in config as-is`, async () => {\n+\tconst config = await responseInterceptor(sampleResponseConfig);\n+\texpect(config).toBe(sampleResponseConfig);\n+});"
        },
        {
          "filename": "api/src/request/response-interceptor.ts",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+import type { AxiosResponse } from 'axios';\n+import { validateIP } from './validate-ip';\n+\n+export const responseInterceptor = async (config: AxiosResponse<any, any>) => {\n+\tawait validateIP(config.request.socket.remoteAddress, config.request.url);\n+\treturn config;\n+};"
        },
        {
          "filename": "api/src/request/validate-ip.test.ts",
          "status": "added",
          "additions": 81,
          "deletions": 0,
          "patch": "@@ -0,0 +1,81 @@\n+import { randIp, randUrl } from '@ngneat/falso';\n+import os from 'node:os';\n+import { afterEach, beforeEach, expect, test, vi } from 'vitest';\n+import { getEnv } from '../env';\n+import { validateIP } from './validate-ip';\n+\n+vi.mock('../env');\n+vi.mock('node:os');\n+\n+let sample: {\n+\tip: string;\n+\turl: string;\n+};\n+\n+beforeEach(() => {\n+\tsample = {\n+\t\tip: randIp(),\n+\t\turl: randUrl(),\n+\t};\n+});\n+\n+afterEach(() => {\n+\tvi.resetAllMocks();\n+});\n+\n+test(`Does nothing if IP is valid`, async () => {\n+\tvi.mocked(getEnv).mockReturnValue({ IMPORT_IP_DENY_LIST: [] });\n+\tawait validateIP(sample.ip, sample.url);\n+});\n+\n+test(`Throws error if passed IP is denylisted`, async () => {\n+\tvi.mocked(getEnv).mockReturnValue({ IMPORT_IP_DENY_LIST: [sample.ip] });\n+\n+\ttry {\n+\t\tawait validateIP(sample.ip, sample.url);\n+\t} catch (err: any) {\n+\t\texpect(err).toBeInstanceOf(Error);\n+\t\texpect(err.message).toBe(`Requested URL \"${sample.url}\" resolves to a denied IP address`);\n+\t}\n+});\n+\n+test(`Checks against IPs of local networkInterfaces if IP deny list contains 0.0.0.0`, async () => {\n+\tvi.mocked(getEnv).mockReturnValue({ IMPORT_IP_DENY_LIST: ['0.0.0.0'] });\n+\tvi.mocked(os.networkInterfaces).mockReturnValue({});\n+\tawait validateIP(sample.ip, sample.url);\n+\texpect(os.networkInterfaces).toHaveBeenCalledOnce();\n+});\n+\n+test(`Throws error if IP address matches resolved localhost IP`, async () => {\n+\tvi.mocked(getEnv).mockReturnValue({ IMPORT_IP_DENY_LIST: ['0.0.0.0'] });\n+\tvi.mocked(os.networkInterfaces).mockReturnValue({\n+\t\tfa0: undefined,\n+\t\tlo0: [\n+\t\t\t{\n+\t\t\t\taddress: '127.0.0.1',\n+\t\t\t\tnetmask: '255.0.0.0',\n+\t\t\t\tfamily: 'IPv4',\n+\t\t\t\tmac: '00:00:00:00:00:00',\n+\t\t\t\tinternal: true,\n+\t\t\t\tcidr: '127.0.0.1/8',\n+\t\t\t},\n+\t\t],\n+\t\ten0: [\n+\t\t\t{\n+\t\t\t\taddress: sample.ip,\n+\t\t\t\tnetmask: '255.0.0.0',\n+\t\t\t\tfamily: 'IPv4',\n+\t\t\t\tmac: '00:00:00:00:00:00',\n+\t\t\t\tinternal: true,\n+\t\t\t\tcidr: '127.0.0.1/8',\n+\t\t\t},\n+\t\t],\n+\t});\n+\n+\ttry {\n+\t\tawait validateIP(sample.ip, sample.url);\n+\t} catch (err: any) {\n+\t\texpect(err).toBeInstanceOf(Error);\n+\t\texpect(err.message).toBe(`Requested URL \"${sample.url}\" resolves to a denied IP address`);\n+\t}\n+});"
        },
        {
          "filename": "api/src/request/validate-ip.ts",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+import os from 'node:os';\n+import { getEnv } from '../env';\n+\n+export const validateIP = async (ip: string, url: string) => {\n+\tconst env = getEnv();\n+\n+\tif (env.IMPORT_IP_DENY_LIST.includes(ip)) {\n+\t\tthrow new Error(`Requested URL \"${url}\" resolves to a denied IP address`);\n+\t}\n+\n+\tif (env.IMPORT_IP_DENY_LIST.includes('0.0.0.0')) {\n+\t\tconst networkInterfaces = os.networkInterfaces();\n+\n+\t\tfor (const networkInfo of Object.values(networkInterfaces)) {\n+\t\t\tif (!networkInfo) continue;\n+\n+\t\t\tfor (const info of networkInfo) {\n+\t\t\t\tif (info.address === ip) {\n+\t\t\t\t\tthrow new Error(`Requested URL \"${url}\" resolves to a denied IP address`);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+};"
        },
        {
          "filename": "api/src/services/files.ts",
          "status": "modified",
          "additions": 4,
          "deletions": 58,
          "patch": "@@ -1,22 +1,19 @@\n import { toArray } from '@directus/shared/utils';\n-import { lookup } from 'dns';\n import encodeURL from 'encodeurl';\n import exif from 'exif-reader';\n import { parse as parseIcc } from 'icc';\n import { clone, pick } from 'lodash';\n import { extension } from 'mime-types';\n-import net from 'net';\n import type { Readable } from 'node:stream';\n import { pipeline } from 'node:stream/promises';\n-import os from 'os';\n import path from 'path';\n import sharp from 'sharp';\n-import url, { URL } from 'url';\n-import { promisify } from 'util';\n+import url from 'url';\n import emitter from '../emitter';\n import env from '../env';\n import { ForbiddenException, InvalidPayloadException, ServiceUnavailableException } from '../exceptions';\n import logger from '../logger';\n+import { getAxios } from '../request/index';\n import { getStorage } from '../storage';\n import { AbstractServiceOptions, File, Metadata, MutationOptions, PrimaryKey } from '../types';\n import { parseIptc, parseXmp } from '../utils/parse-image-metadata';\n@@ -25,8 +22,6 @@ import { ItemsService } from './items';\n // @ts-ignore\n import formatTitle from '@directus/format-title';\n \n-const lookupDNS = promisify(lookup);\n-\n export class FilesService extends ItemsService {\n \tconstructor(options: AbstractServiceOptions) {\n \t\tsuper('directus_files', options);\n@@ -224,8 +219,6 @@ export class FilesService extends ItemsService {\n \t * Import a single file from an external URL\n \t */\n \tasync importOne(importURL: string, body: Partial<File>): Promise<PrimaryKey> {\n-\t\tconst axios = (await import('axios')).default;\n-\n \t\tconst fileCreatePermissions = this.accountability?.permissions?.find(\n \t\t\t(permission) => permission.collection === 'directus_files' && permission.action === 'create'\n \t\t);\n@@ -234,62 +227,15 @@ export class FilesService extends ItemsService {\n \t\t\tthrow new ForbiddenException();\n \t\t}\n \n-\t\tlet resolvedUrl;\n-\n-\t\ttry {\n-\t\t\tresolvedUrl = new URL(importURL);\n-\t\t} catch (err: any) {\n-\t\t\tlogger.warn(err, `Requested URL ${importURL} isn't a valid URL`);\n-\t\t\tthrow new ServiceUnavailableException(`Couldn't fetch file from url \"${importURL}\"`, {\n-\t\t\t\tservice: 'external-file',\n-\t\t\t});\n-\t\t}\n-\n-\t\tlet ip = resolvedUrl.hostname;\n-\n-\t\tif (net.isIP(ip) === 0) {\n-\t\t\ttry {\n-\t\t\t\tip = (await lookupDNS(ip)).address;\n-\t\t\t} catch (err: any) {\n-\t\t\t\tlogger.warn(err, `Couldn't lookup the DNS for url ${importURL}`);\n-\t\t\t\tthrow new ServiceUnavailableException(`Couldn't fetch file from url \"${importURL}\"`, {\n-\t\t\t\t\tservice: 'external-file',\n-\t\t\t\t});\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (env.IMPORT_IP_DENY_LIST.includes('0.0.0.0')) {\n-\t\t\tconst networkInterfaces = os.networkInterfaces();\n-\n-\t\t\tfor (const networkInfo of Object.values(networkInterfaces)) {\n-\t\t\t\tif (!networkInfo) continue;\n-\n-\t\t\t\tfor (const info of networkInfo) {\n-\t\t\t\t\tif (info.address === ip) {\n-\t\t\t\t\t\tlogger.warn(`Requested URL ${importURL} resolves to localhost.`);\n-\t\t\t\t\t\tthrow new ServiceUnavailableException(`Couldn't fetch file from url \"${importURL}\"`, {\n-\t\t\t\t\t\t\tservice: 'external-file',\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (env.IMPORT_IP_DENY_LIST.includes(ip)) {\n-\t\t\tlogger.warn(`Requested URL ${importURL} resolves to a denied IP address.`);\n-\t\t\tthrow new ServiceUnavailableException(`Couldn't fetch file from url \"${importURL}\"`, {\n-\t\t\t\tservice: 'external-file',\n-\t\t\t});\n-\t\t}\n-\n \t\tlet fileResponse;\n \n \t\ttry {\n+\t\t\tconst axios = await getAxios();\n \t\t\tfileResponse = await axios.get<Readable>(encodeURL(importURL), {\n \t\t\t\tresponseType: 'stream',\n \t\t\t});\n \t\t} catch (err: any) {\n-\t\t\tlogger.warn(err, `Couldn't fetch file from url \"${importURL}\"`);\n+\t\t\tlogger.warn(err, `Couldn't fetch file from URL \"${importURL}\"`);\n \t\t\tthrow new ServiceUnavailableException(`Couldn't fetch file from url \"${importURL}\"`, {\n \t\t\t\tservice: 'external-file',\n \t\t\t});"
        },
        {
          "filename": "api/src/webhooks.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -1,11 +1,12 @@\n+import { ActionHandler } from '@directus/shared/types';\n import getDatabase from './database';\n import emitter from './emitter';\n import logger from './logger';\n-import { Webhook, WebhookHeader } from './types';\n+import { getMessenger } from './messenger';\n+import { getAxios } from './request/index';\n import { WebhooksService } from './services';\n+import { Webhook, WebhookHeader } from './types';\n import { getSchema } from './utils/get-schema';\n-import { ActionHandler } from '@directus/shared/types';\n-import { getMessenger } from './messenger';\n import { JobQueue } from './utils/job-queue';\n \n let registered: { event: string; handler: ActionHandler }[] = [];\n@@ -55,9 +56,8 @@ export function unregister(): void {\n \n function createHandler(webhook: Webhook, event: string): ActionHandler {\n \treturn async (meta, context) => {\n-\t\tconst axios = (await import('axios')).default;\n-\n \t\tif (webhook.collections.includes(meta.collection) === false) return;\n+\t\tconst axios = await getAxios();\n \n \t\tconst webhookPayload = {\n \t\t\tevent,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4779eb01c36b9463edfd1a515a52454e7fd04043",
            "date": "2025-01-24T13:17:27Z",
            "author_login": "formfcw"
          },
          {
            "sha": "d77a9d8037ae2777cc13278f1975f7845de42e61",
            "date": "2025-01-24T10:23:59Z",
            "author_login": "paescuj"
          },
          {
            "sha": "fb3b26d8868a57f9502401bdce8ef744de4db95e",
            "date": "2025-01-24T06:57:52Z",
            "author_login": "licitdev"
          },
          {
            "sha": "6c034d52662aa37515c0c5c4b646369b6ed71262",
            "date": "2025-01-23T19:40:39Z",
            "author_login": "formfcw"
          },
          {
            "sha": "e27ea0a09d6451278028b4bfc7027a1b807361f5",
            "date": "2025-01-23T18:43:33Z",
            "author_login": "connorwinston"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "Directus is a real-time API and App dashboard for managing SQL database content. Directus is vulnerable to Server-Side Request Forgery (SSRF) when importing a file from a remote web server (POST to `/files/import`). An attacker can bypass the security controls by performing a DNS rebinding attack and view sensitive data from internal servers or perform a local port scan. An attacker can exploit this vulnerability to access highly sensitive internal server(s) and steal sensitive information. This issue was fixed in version 9.23.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-03T22:15:09.987",
    "last_modified": "2024-11-21T07:51:37.847",
    "fix_date": "2023-02-13T20:49:24Z"
  },
  "references": [
    {
      "url": "https://github.com/directus/directus/commit/ff53d3e69a602d05342e15d9bb616884833ddbff",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/directus/directus/releases/tag/v9.23.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/directus/directus/security/advisories/GHSA-j3rg-3rgm-537h",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/directus/directus/commit/ff53d3e69a602d05342e15d9bb616884833ddbff",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/directus/directus/releases/tag/v9.23.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/directus/directus/security/advisories/GHSA-j3rg-3rgm-537h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.800840",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "directus",
    "owner": "directus",
    "created_at": "2012-12-12T01:35:36Z",
    "updated_at": "2025-01-25T22:22:57Z",
    "pushed_at": "2025-01-24T16:20:49Z",
    "size": 402776,
    "stars": 28836,
    "forks": 4021,
    "open_issues": 545,
    "watchers": 28836,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "TypeScript": 5101536,
      "Vue": 1874412,
      "SCSS": 58492,
      "Liquid": 28677,
      "CSS": 28575,
      "JavaScript": 26886,
      "Dockerfile": 1905,
      "HTML": 1189
    },
    "commit_activity": {
      "total_commits_last_year": 1794,
      "avg_commits_per_week": 34.5,
      "days_active_last_year": 259
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:42:44.832863"
  }
}