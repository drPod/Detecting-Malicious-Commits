{
  "cve_id": "CVE-2023-27580",
  "github_data": {
    "repository": "codeigniter4/shield",
    "fix_commit": "ea9688dd01d100193d834117dbfc2cfabcf9ea0b",
    "related_commits": [
      "ea9688dd01d100193d834117dbfc2cfabcf9ea0b",
      "ea9688dd01d100193d834117dbfc2cfabcf9ea0b"
    ],
    "patch_url": "https://github.com/codeigniter4/shield/commit/ea9688dd01d100193d834117dbfc2cfabcf9ea0b.patch",
    "fix_commit_details": {
      "sha": "ea9688dd01d100193d834117dbfc2cfabcf9ea0b",
      "commit_date": "2023-03-11T05:01:18Z",
      "author": {
        "login": "kenjis",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-c5vj-f36q-p9vg",
        "length": 1019,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 452,
        "additions": 435,
        "deletions": 17
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -86,3 +86,4 @@ within this library, in no particular order:\n - [Google Cloud: 13 best practices for user account, authentication, and password management, 2021 edition](https://cloud.google.com/blog/products/identity-security/account-authentication-and-password-management-best-practices)\n - [NIST Digital Identity Guidelines](https://pages.nist.gov/800-63-3/sp800-63b.html)\n - [Implementing Secure User Authentication in PHP Applications with Long-Term Persistence (Login with \"Remember Me\" Cookies) ](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence)\n+- [Password Storage - OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)"
        },
        {
          "filename": "UPGRADING.md",
          "status": "added",
          "additions": 51,
          "deletions": 0,
          "patch": "@@ -0,0 +1,51 @@\n+# Upgrade Guide\n+\n+## Version 1.0.0-beta.3 to 1.0.0-beta.4\n+\n+### Important Password Changes\n+\n+#### Password Incompatibility\n+\n+Shield 1.0.0-beta.4 fixes a [vulnerability related to password storage](https://github.com/codeigniter4/shield/security/advisories/GHSA-c5vj-f36q-p9vg).\n+As a result, hashed passwords already stored in the database are no longer compatible\n+and cannot be used by default.\n+\n+All hashed passwords stored in Shield v1.0.0-beta.3 or earlier are easier to\n+crack than expected due to the above vulnerability. Therefore, they should be\n+removed as soon as possible.\n+\n+Existing users will no longer be able to log in with their passwords and will\n+need to log in with the magic link and then set their passwords again.\n+\n+#### If You Want to Allow Login with Existing Passwords\n+\n+If you want to use passwords saved in Shield v1.0.0-beta.3 or earlier,\n+you must add the following property in `app/Config/Auth.php`:\n+\n+```php\n+    public bool $supportOldDangerousPassword = true;\n+```\n+\n+After upgrading, with the above setting, once a user logs in with the password,\n+the hashed password is updated and stored in the database.\n+\n+In this case, the existing hashed passwords are still easier to crack than expected.\n+Therefore, this setting should not be used for an extended period of time.\n+So you should change the setting to `false` as soon as possible, and remove old\n+hashed password.\n+\n+> **Note**\n+>\n+> This setting is deprecated. It will be removed in v1.0.0 official release.\n+\n+#### Limitations for the Default Password Handling\n+\n+By default, Shield uses the hashing algorithm `PASSWORD_DEFAULT` (see `app/Config/Auth.php`),\n+that is, `PASSWORD_BCRYPT` at the time of writing.\n+\n+Now there are two limitations when you use `PASSWORD_BCRYPT`.\n+\n+1. the password will be truncated to a maximum length of 72 bytes.\n+2. the password will be truncated at the first NULL byte (`\\0`).\n+\n+If these behaviors are unacceptable, see [How to Strengthen the Password](https://github.com/codeigniter4/shield/blob/develop/docs/guides/strengthen_password.md)."
        },
        {
          "filename": "docs/guides/strengthen_password.md",
          "status": "added",
          "additions": 122,
          "deletions": 0,
          "patch": "@@ -0,0 +1,122 @@\n+# How to Strengthen the Password\n+\n+Shield allows you to customize password-related settings to make your passwords more secure.\n+\n+## Minimum Password Length\n+\n+The most important factor when it comes to passwords is the number of characters in the password.\n+You can check password strength with [Password Strength Testing Tool](https://bitwarden.com/password-strength/).\n+Short passwords may be cracked in less than one day.\n+\n+In Shield, you can set the users' minimum password length. The setting is\n+`$minimumPasswordLength` in `app/Config/Auth.php`. The default value is 8 characters.\n+It is the recommended minimum value by NIST. However, some organizations recommend\n+12 to 14 characters.\n+\n+The longer the password, the stronger it is. Consider increasing the value.\n+\n+> **Note**\n+>\n+> This checking works when you validate passwords with the `strong_password`\n+> validation rule.\n+>\n+> If you disable `CompositionValidator` (enabled by default) in `$passwordValidators`,\n+> this checking will not work.\n+\n+## Password Hashing Algorithm\n+\n+You can change the password hashing algorithm by `$hashAlgorithm` in `app/Config/Auth.php`.\n+The default value is `PASSWORD_DEFAULT` that is `PASSWORD_BCRYPT` at the time of writing.\n+\n+`PASSWORD_BCRYPT` means to create new password hashes using the bcrypt algorithm.\n+\n+You can use `PASSWORD_ARGON2ID` if your PHP has been compiled with Argon2 support.\n+\n+### PASSWORD_BCRYPT\n+\n+`PASSWORD_BCRYPT` has one configuration `$hashCost`. The bigger the cost, hashed passwords will be the stronger.\n+\n+You can find your appropriate cost with the following code:\n+\n+```php\n+<?php\n+/**\n+ * This code will benchmark your server to determine how high of a cost you can\n+ * afford. You want to set the highest cost that you can without slowing down\n+ * you server too much. 8-10 is a good baseline, and more is good if your servers\n+ * are fast enough. The code below aims for \u2264 50 milliseconds stretching time,\n+ * which is a good baseline for systems handling interactive logins.\n+ *\n+ * From: https://www.php.net/manual/en/function.password-hash.php#refsect1-function.password-hash-examples\n+ */\n+$timeTarget = 0.05; // 50 milliseconds\n+\n+$cost = 8;\n+do {\n+    $cost++;\n+    $start = microtime(true);\n+    password_hash(\"test\", PASSWORD_BCRYPT, [\"cost\" => $cost]);\n+    $end = microtime(true);\n+} while (($end - $start) < $timeTarget);\n+\n+echo \"Appropriate Cost Found: \" . $cost;\n+```\n+\n+#### Limitations\n+\n+There are two limitations when you use `PASSWORD_BCRYPT`:\n+\n+1. the password will be truncated to a maximum length of 72 bytes.\n+2. the password will be truncated at the first NULL byte (`\\0`).\n+\n+##### 72 byte issue\n+\n+If a user submits a password longer than 72 bytes, the validation error will occur.\n+If this behavior is unacceptable, consider:\n+\n+1. change the hashing algorithm to `PASSWORD_ARGON2ID`. It does not have such a limitation.\n+\n+##### NULL byte issue\n+\n+This is because `PASSWORD_BCRYPT` is not binary-safe. Normal users cannot\n+send NULL bytes in a password string, so this is not a problem in most cases.\n+\n+But if this behavior is unacceptable, consider:\n+\n+1. adding a validation rule to prohibit NULL bytes or control codes.\n+2. or change the hashing algorithm to `PASSWORD_ARGON2ID`. It is binary-safe.\n+\n+### PASSWORD_ARGON2ID\n+\n+`PASSWORD_ARGON2ID` has three configuration `$hashMemoryCost`, `$hashTimeCost`,\n+and `$hashThreads`.\n+\n+If you use `PASSWORD_ARGON2ID`, you should use PHP's constants:\n+\n+```php\n+    public int $hashMemoryCost = PASSWORD_ARGON2_DEFAULT_MEMORY_COST;\n+\n+    public int $hashTimeCost = PASSWORD_ARGON2_DEFAULT_TIME_COST;\n+    public int $hashThreads  = PASSWORD_ARGON2_DEFAULT_THREADS;\n+```\n+\n+## Maximum Password Length\n+\n+By default, Shield has the validation rules for maximum password length.\n+\n+- 72 bytes for PASSWORD_BCRYPT\n+- 255 characters for others\n+\n+You can customize the validation rule. See [Customizing Shield](../customization.md).\n+\n+## $supportOldDangerousPassword\n+\n+In `app/Config/Auth.php` there is `$supportOldDangerousPassword`, which is a\n+setting for using passwords stored in older versions of Shield that were [vulnerable](https://github.com/codeigniter4/shield/security/advisories/GHSA-c5vj-f36q-p9vg).\n+\n+This setting is deprecated.  If you have this setting set to `true`, you should change\n+it to `false` as soon as possible, and remove old hashed password in your database.\n+\n+> **Note**\n+>\n+> This setting will be removed in v1.0.0 official release."
        },
        {
          "filename": "docs/index.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -14,3 +14,4 @@\n ## Guides\n * [Protecting an API with Access Tokens](guides/api_tokens.md)\n * [Mobile Authentication with Access Tokens](guides/mobile_apps.md)\n+* [How to Strengthen the Password](guides/strengthen_password.md)"
        },
        {
          "filename": "mkdocs.yml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -51,3 +51,4 @@ nav:\n   - Guides:\n     - guides/api_tokens.md\n     - guides/mobile_apps.md\n+    - guides/strengthen_password.md"
        },
        {
          "filename": "src/Authentication/Authenticators/Session.php",
          "status": "modified",
          "additions": 16,
          "deletions": 5,
          "patch": "@@ -336,19 +336,30 @@ public function check(array $credentials): Result\n         /** @var Passwords $passwords */\n         $passwords = service('passwords');\n \n+        // This is only for supportOldDangerousPassword.\n+        $needsRehash = false;\n+\n         // Now, try matching the passwords.\n         if (! $passwords->verify($givenPassword, $user->password_hash)) {\n-            return new Result([\n-                'success' => false,\n-                'reason'  => lang('Auth.invalidPassword'),\n-            ]);\n+            if (\n+                ! setting('Auth.supportOldDangerousPassword')\n+                || ! $passwords->verifyDanger($givenPassword, $user->password_hash) // @phpstan-ignore-line\n+            ) {\n+                return new Result([\n+                    'success' => false,\n+                    'reason'  => lang('Auth.invalidPassword'),\n+                ]);\n+            }\n+\n+            // Passed with old dangerous password.\n+            $needsRehash = true;\n         }\n \n         // Check to see if the password needs to be rehashed.\n         // This would be due to the hash algorithm or hash\n         // cost changing since the last time that a user\n         // logged in.\n-        if ($passwords->needsRehash($user->password_hash)) {\n+        if ($passwords->needsRehash($user->password_hash) || $needsRehash) {\n             $user->password_hash = $passwords->hash($givenPassword);\n             $this->provider->save($user);\n         }"
        },
        {
          "filename": "src/Authentication/Passwords.php",
          "status": "modified",
          "additions": 49,
          "deletions": 8,
          "patch": "@@ -31,26 +31,42 @@ public function __construct(Auth $config)\n      */\n     public function hash(string $password)\n     {\n-        if ((defined('PASSWORD_ARGON2I') && $this->config->hashAlgorithm === PASSWORD_ARGON2I)\n+        return password_hash($password, $this->config->hashAlgorithm, $this->getHashOptions());\n+    }\n+\n+    private function getHashOptions(): array\n+    {\n+        if (\n+            (defined('PASSWORD_ARGON2I') && $this->config->hashAlgorithm === PASSWORD_ARGON2I)\n             || (defined('PASSWORD_ARGON2ID') && $this->config->hashAlgorithm === PASSWORD_ARGON2ID)\n         ) {\n-            $hashOptions = [\n+            return [\n                 'memory_cost' => $this->config->hashMemoryCost,\n                 'time_cost'   => $this->config->hashTimeCost,\n                 'threads'     => $this->config->hashThreads,\n             ];\n-        } else {\n-            $hashOptions = [\n-                'cost' => $this->config->hashCost,\n-            ];\n         }\n \n+        return [\n+            'cost' => $this->config->hashCost,\n+        ];\n+    }\n+\n+    /**\n+     * Hash a password.\n+     *\n+     * @return false|string|null\n+     *\n+     * @deprecated This is only for backward compatibility.\n+     */\n+    public function hashDanger(string $password)\n+    {\n         return password_hash(\n             base64_encode(\n                 hash('sha384', $password, true)\n             ),\n             $this->config->hashAlgorithm,\n-            $hashOptions\n+            $this->getHashOptions()\n         );\n     }\n \n@@ -61,6 +77,19 @@ public function hash(string $password)\n      * @param string $hash     The previously hashed password\n      */\n     public function verify(string $password, string $hash): bool\n+    {\n+        return password_verify($password, $hash);\n+    }\n+\n+    /**\n+     * Verifies a password against a previously hashed password.\n+     *\n+     * @param string $password The password we're checking\n+     * @param string $hash     The previously hashed password\n+     *\n+     * @deprecated This is only for backward compatibility.\n+     */\n+    public function verifyDanger(string $password, string $hash): bool\n     {\n         return password_verify(base64_encode(\n             hash('sha384', $password, true)\n@@ -72,7 +101,7 @@ public function verify(string $password, string $hash): bool\n      */\n     public function needsRehash(string $hashedPassword): bool\n     {\n-        return password_needs_rehash($hashedPassword, $this->config->hashAlgorithm);\n+        return password_needs_rehash($hashedPassword, $this->config->hashAlgorithm, $this->getHashOptions());\n     }\n \n     /**\n@@ -110,4 +139,16 @@ public function check(string $password, ?User $user = null): Result\n             'success' => true,\n         ]);\n     }\n+\n+    /**\n+     * Returns the validation rule for max length.\n+     */\n+    public static function getMaxLenghtRule(): string\n+    {\n+        if (config('Auth')->hashAlgorithm === PASSWORD_BCRYPT) {\n+            return 'max_byte[72]';\n+        }\n+\n+        return 'max_length[255]';\n+    }\n }"
        },
        {
          "filename": "src/Authentication/Passwords/ValidationRules.php",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -55,6 +55,14 @@ public function strong_password(string $value, ?string &$error1 = null, array $d\n         return $result->isOk();\n     }\n \n+    /**\n+     * Returns true if $str is $val or fewer bytes in length.\n+     */\n+    public function max_byte(?string $str, string $val): bool\n+    {\n+        return is_numeric($val) && $val >= strlen($str ?? '');\n+    }\n+\n     /**\n      * Builds a new user instance from the global request.\n      */"
        },
        {
          "filename": "src/Config/Auth.php",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -360,6 +360,16 @@ class Auth extends BaseConfig\n      */\n     public int $hashCost = 10;\n \n+    /**\n+     * If you need to support passwords saved in versions prior to Shield v1.0.0-beta.4.\n+     * set this to true.\n+     *\n+     * See https://github.com/codeigniter4/shield/security/advisories/GHSA-c5vj-f36q-p9vg\n+     *\n+     * @deprecated This is only for backward compatibility.\n+     */\n+    public bool $supportOldDangerousPassword = false;\n+\n     /**\n      * ////////////////////////////////////////////////////////////////////\n      * OTHER SETTINGS"
        },
        {
          "filename": "src/Controllers/LoginController.php",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -7,6 +7,7 @@\n use App\\Controllers\\BaseController;\n use CodeIgniter\\HTTP\\RedirectResponse;\n use CodeIgniter\\Shield\\Authentication\\Authenticators\\Session;\n+use CodeIgniter\\Shield\\Authentication\\Passwords;\n use CodeIgniter\\Shield\\Traits\\Viewable;\n \n class LoginController extends BaseController\n@@ -90,8 +91,11 @@ protected function getValidationRules(): array\n                 'rules' => config('AuthSession')->emailValidationRules,\n             ],\n             'password' => [\n-                'label' => 'Auth.password',\n-                'rules' => 'required',\n+                'label'  => 'Auth.password',\n+                'rules'  => 'required|' . Passwords::getMaxLenghtRule(),\n+                'errors' => [\n+                    'max_byte' => 'Auth.errorPasswordTooLongBytes',\n+                ],\n             ],\n         ];\n     }"
        },
        {
          "filename": "src/Controllers/RegisterController.php",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -10,6 +10,7 @@\n use CodeIgniter\\HTTP\\RequestInterface;\n use CodeIgniter\\HTTP\\ResponseInterface;\n use CodeIgniter\\Shield\\Authentication\\Authenticators\\Session;\n+use CodeIgniter\\Shield\\Authentication\\Passwords;\n use CodeIgniter\\Shield\\Config\\Auth;\n use CodeIgniter\\Shield\\Entities\\User;\n use CodeIgniter\\Shield\\Exceptions\\ValidationException;\n@@ -195,8 +196,11 @@ protected function getValidationRules(): array\n                 'rules' => $registrationEmailRules,\n             ],\n             'password' => [\n-                'label' => 'Auth.password',\n-                'rules' => 'required|strong_password',\n+                'label'  => 'Auth.password',\n+                'rules'  => 'required|' . Passwords::getMaxLenghtRule() . '|strong_password',\n+                'errors' => [\n+                    'max_byte' => 'Auth.errorPasswordTooLongBytes',\n+                ],\n             ],\n             'password_confirm' => [\n                 'label' => 'Auth.passwordConfirm',"
        },
        {
          "filename": "src/Language/de/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'Das Passwort {0} wurde aufgrund einer Datenschutzverletzung aufgedeckt und wurde {1, number} Mal in {2} kompromittierten Passw\u00f6rtern gesehen.',\n     'suggestPasswordPwned'      => '{0} sollte niemals als Passwort verwendet werden. Wenn Sie es irgendwo verwenden, \u00e4ndern Sie es sofort.',\n     'errorPasswordEmpty'        => 'Ein Passwort ist erforderlich.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Passwort erfolgreich ge\u00e4ndert',\n     'userDoesNotExist'          => 'Passwort wurde nicht ge\u00e4ndert. Der Benutzer existiert nicht',\n     'resetTokenExpired'         => 'Tut mir leid. Ihr Reset-Token ist abgelaufen.',"
        },
        {
          "filename": "src/Language/en/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'The password {0} has been exposed due to a data breach and has been seen {1, number} times in {2} of compromised passwords.',\n     'suggestPasswordPwned'      => '{0} should never be used as a password. If you are using it anywhere change it immediately.',\n     'errorPasswordEmpty'        => 'A Password is required.',\n+    'errorPasswordTooLongBytes' => 'Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Password changed successfully',\n     'userDoesNotExist'          => 'Password was not changed. User does not exist',\n     'resetTokenExpired'         => 'Sorry. Your reset token has expired.',"
        },
        {
          "filename": "src/Language/es/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'La contrase\u00f1a {0} ha quedado expuesta debido a una violaci\u00f3n de datos y se ha visto comprometida {1, n\u00famero} veces en {2} contrase\u00f1as.',\n     'suggestPasswordPwned'      => '{0} no se debe usar nunca como contrase\u00f1a. Si la est\u00e1s usando en alg\u00fan sitio, c\u00e1mbiala inmediatamente.',\n     'errorPasswordEmpty'        => 'Se necesita una contrase\u00f1a.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Contrase\u00f1a modificada correctamente',\n     'userDoesNotExist'          => 'No se ha cambiado la contrase\u00f1a. No existe el usuario',\n     'resetTokenExpired'         => 'Lo sentimos. Tu token de reseteo ha caducado.',"
        },
        {
          "filename": "src/Language/fa/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => '\u0631\u0645\u0632 \u0639\u0628\u0648\u0631 {0} \u0628\u0627 \u062a\u0648\u062c\u0647 \u0628\u0647 \u0646\u0642\u0636 \u062f\u0627\u062f\u0647 \u0647\u0627 \u0648 \u062f\u06cc\u062f\u0647 \u0634\u062f\u0646 {1, number} \u0628\u0627\u0631\u0647\u0627 \u062f\u0627\u062e\u0644 \u0631\u0645\u0632 \u0647\u0627\u06cc \u0639\u0628\u0648\u0631 {2} \u0628\u0647 \u067e\u0633\u0648\u0631\u062f \u0647\u0627\u06cc \u0646\u0627\u0627\u0645\u0646 \u062a\u0628\u062f\u06cc\u0644 \u0634\u062f\u0647 \u0648 \u062f\u0631 \u0645\u0639\u0631\u0636 \u0642\u0631\u0627\u0631 \u06af\u0631\u0641\u062a\u0647 \u0627\u0633\u062a.',\n     'suggestPasswordPwned'      => '{0} \u0647\u0631\u06af\u0632 \u0646\u0628\u0627\u06cc\u062f \u0628\u0647 \u0639\u0646\u0648\u0627\u0646 \u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0634\u0648\u062f. \u0627\u06af\u0631 \u062f\u0631 \u0647\u0631 \u062c\u0627\u06cc\u06cc \u0627\u0632 \u0622\u0646 \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0645\u06cc \u06a9\u0646\u06cc\u062f \u0633\u0631\u06cc\u0639\u0627 \u0622\u0646 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f.',\n     'errorPasswordEmpty'        => '\u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0627\u0644\u0632\u0627\u0645\u06cc \u0627\u0633\u062a.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => '\u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0628\u0627 \u0645\u0648\u0641\u0642\u06cc\u062a \u062a\u063a\u06cc\u06cc\u0631 \u06a9\u0631\u062f',\n     'userDoesNotExist'          => '\u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u062a\u063a\u06cc\u06cc\u0631 \u0646\u06a9\u0631\u062f. \u06a9\u0627\u0631\u0628\u0631 \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u062f.',\n     'resetTokenExpired'         => '\u0645\u062a\u0627\u0633\u0641\u0627\u0646\u0647\u060c \u062a\u0648\u06a9\u0646 \u0628\u0627\u0632\u0646\u0634\u0627\u0646\u06cc \u0634\u0645\u0627 \u0645\u0646\u0642\u0636\u06cc \u0634\u062f\u0647 \u0627\u0633\u062a.',"
        },
        {
          "filename": "src/Language/fr/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'Le mot de passe {0} a \u00e9t\u00e9 expos\u00e9 \u00e0 la suite d\\'une violation de donn\u00e9es et a \u00e9t\u00e9 vu {1, number} fois dans {2} des mots de passe compromis.',\n     'suggestPasswordPwned'      => '{0} ne devrait jamais \u00eatre utilis\u00e9 comme mot de passe. Si vous l\\'utilisez quelque part, changez-le imm\u00e9diatement.',\n     'errorPasswordEmpty'        => 'Un mot de passe est obligatoire.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Mot de passe modifi\u00e9 avec succ\u00e8s',\n     'userDoesNotExist'          => 'Le mot de passe n\\'a pas \u00e9t\u00e9 modifi\u00e9. L\\'utilisateur n\\'existe pas',\n     'resetTokenExpired'         => 'D\u00e9sol\u00e9. Votre jeton de r\u00e9initialisation a expir\u00e9.',"
        },
        {
          "filename": "src/Language/id/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'Kata sandi {0} telah bocor karena pelanggaran data dan telah dilihat {1, number} kali dalam {2} sandi yang disusupi.',\n     'suggestPasswordPwned'      => '{0} tidak boleh digunakan sebagai kata sandi. Jika Anda menggunakannya di mana saja, segera ubah.',\n     'errorPasswordEmpty'        => 'Kata sandi wajib diisi.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Kata sandi berhasil diubah',\n     'userDoesNotExist'          => 'Kata sandi tidak diubah. User tidak ditemukan',\n     'resetTokenExpired'         => 'Maaf, token setel ulang Anda sudah habis waktu.',"
        },
        {
          "filename": "src/Language/it/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'La password {0} \u00e8 stata esposta ad un furto di dati ed \u00e8 stata vista {1, number} volte in {2} di password compromesse.',\n     'suggestPasswordPwned'      => '{0} non dovrebbe mai essere usata come password. Se la stai utilizzando da qualche parte, cambiala immediatamente.',\n     'errorPasswordEmpty'        => 'Una password \u00e8 richiesta.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'La password \u00e8 stata cambiata con successo',\n     'userDoesNotExist'          => 'La password non \u00e8 stata cambiata. L\\'utente non esiste',\n     'resetTokenExpired'         => 'Spiacente. Il tuo reset token \u00e8 scaduto.',"
        },
        {
          "filename": "src/Language/ja/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => '\u30d1\u30b9\u30ef\u30fc\u30c9 {0} \u306f\u30c7\u30fc\u30bf\u6f0f\u6d29\u306b\u3088\u308a\u516c\u958b\u3055\u308c\u3066\u304a\u308a\u3001{2} \u306e\u6f0f\u6d29\u3057\u305f\u30d1\u30b9\u30ef\u30fc\u30c9\u4e2d\u3067 {1, number} \u56de\u898b\u3089\u308c\u307e\u3059\u3002', // 'The password {0} has been exposed due to a data breach and has been seen {1, number} times in {2} of compromised passwords.',\n     'suggestPasswordPwned'      => '{0} \u306f\u7d76\u5bfe\u306b\u30d1\u30b9\u30ef\u30fc\u30c9\u3068\u3057\u3066\u4f7f\u3063\u3066\u306f\u3044\u3051\u307e\u305b\u3093\u3002\u3082\u3057\u3069\u3053\u304b\u3067\u4f7f\u3063\u3066\u3044\u305f\u3089\u3001\u3059\u3050\u306b\u5909\u66f4\u3057\u3066\u304f\u3060\u3055\u3044\u3002', // '{0} should never be used as a password. If you are using it anywhere change it immediately.',\n     'errorPasswordEmpty'        => '\u30d1\u30b9\u30ef\u30fc\u30c9\u304c\u5fc5\u8981\u3067\u3059\u3002', // 'A Password is required.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => '\u30d1\u30b9\u30ef\u30fc\u30c9\u306e\u5909\u66f4\u306b\u6210\u529f\u3057\u307e\u3057\u305f', // 'Password changed successfully',\n     'userDoesNotExist'          => '\u30d1\u30b9\u30ef\u30fc\u30c9\u306f\u5909\u66f4\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u30e6\u30fc\u30b6\u30fc\u306f\u5b58\u5728\u3057\u307e\u305b\u3093', // 'Password was not changed. User does not exist',\n     'resetTokenExpired'         => '\u7533\u3057\u8a33\u3042\u308a\u307e\u305b\u3093\u3002\u30ea\u30bb\u30c3\u30c8\u30c8\u30fc\u30af\u30f3\u306e\u6709\u52b9\u671f\u9650\u304c\u5207\u308c\u307e\u3057\u305f\u3002', // 'Sorry. Your reset token has expired.',"
        },
        {
          "filename": "src/Language/pt-BR/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'A senha {0} foi exposta devido a uma viola\u00e7\u00e3o de dados e foi vista {1, number} vezes em {2} de senhas comprometidas.',\n     'suggestPasswordPwned'      => '{0} nunca deve ser usado como uma senha. Se voc\u00ea estiver usando em algum lugar, altere imediatamente.',\n     'errorPasswordEmpty'        => '\u00c9 necess\u00e1ria uma senha.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Senha alterada com sucesso',\n     'userDoesNotExist'          => 'Senha n\u00e3o foi alterada. Usu\u00e1rio n\u00e3o existe',\n     'resetTokenExpired'         => 'Desculpe. Seu token de redefini\u00e7\u00e3o expirou.',"
        },
        {
          "filename": "src/Language/sk/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => 'Heslo {0} bolo odhalen\u00e9 z d\u00f4vodu poru\u0161enia ochrany \u00fadajov a bolo viden\u00e9 {1, number}-kr\u00e1t z {2} prelomen\u00fdch hesiel.',\n     'suggestPasswordPwned'      => '{0} by sa nikdy nemalo pou\u017e\u00edva\u0165 ako heslo. Ak ho niekde pou\u017e\u00edvate, okam\u017eite ho zme\u0148te.',\n     'errorPasswordEmpty'        => 'Vy\u017eaduje sa heslo.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => 'Heslo bolo \u00faspe\u0161ne zmenen\u00e9',\n     'userDoesNotExist'          => 'Heslo nebolo zmenen\u00e9. Pou\u017e\u00edvate\u013e neexistuje',\n     'resetTokenExpired'         => 'Prep\u00e1\u010dte. Platnos\u0165 v\u00e1\u0161ho resetovacieho tokenu vypr\u0161ala.',"
        },
        {
          "filename": "src/Language/tr/Auth.php",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@\n     'errorPasswordPwned'        => '{0} \u015fifresi, bir veri ihlali nedeniyle a\u00e7\u0131\u011fa \u00e7\u0131kt\u0131 ve g\u00fcvenli\u011fi ihlal edilmi\u015f \u015fifrelerin {2} tanesinde {1, say\u0131} kez g\u00f6r\u00fcld\u00fc.',\n     'suggestPasswordPwned'      => '{0} asla \u015fifre olarak kullan\u0131lmamal\u0131d\u0131r. Herhangi bir yerde kullan\u0131yorsan\u0131z hemen de\u011fi\u015ftirin.',\n     'errorPasswordEmpty'        => '\u015eifre gerekli.',\n+    'errorPasswordTooLongBytes' => '(To be translated) Password cannot exceed {param} bytes in length.',\n     'passwordChangeSuccess'     => '\u015eifre ba\u015far\u0131yla de\u011fi\u015ftirildi.',\n     'userDoesNotExist'          => '\u015eifre de\u011fi\u015ftirilmedi. Kullan\u0131c\u0131 yok.',\n     'resetTokenExpired'         => '\u00dczg\u00fcn\u00fcz. S\u0131f\u0131rlama anahtar\u0131n\u0131z\u0131n s\u00fcresi doldu.',"
        },
        {
          "filename": "tests/Authentication/Authenticators/SessionAuthenticatorTest.php",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -12,6 +12,7 @@\n use CodeIgniter\\Shield\\Entities\\User;\n use CodeIgniter\\Shield\\Exceptions\\LogicException;\n use CodeIgniter\\Shield\\Models\\RememberModel;\n+use CodeIgniter\\Shield\\Models\\UserIdentityModel;\n use CodeIgniter\\Shield\\Models\\UserModel;\n use CodeIgniter\\Shield\\Result;\n use CodeIgniter\\Test\\Mock\\MockEvents;\n@@ -303,6 +304,34 @@ public function testCheckSuccess(): void\n         $this->assertSame($this->user->id, $foundUser->id);\n     }\n \n+    public function testCheckSuccessOldDangerousPassword(): void\n+    {\n+        /** @var Auth $config */\n+        $config                              = config('Auth');\n+        $config->supportOldDangerousPassword = true; // @phpstan-ignore-line\n+\n+        fake(\n+            UserIdentityModel::class,\n+            [\n+                'user_id' => $this->user->id,\n+                'type'    => Session::ID_TYPE_EMAIL_PASSWORD,\n+                'secret'  => 'foo@example.com',\n+                'secret2' => '$2y$10$WswjNNcR24cJvsXvBc5TveVVVQ9/EYC0eq.Ad9e/2cVnmeSEYBOEm',\n+            ]\n+        );\n+\n+        $result = $this->auth->check([\n+            'email'    => 'foo@example.com',\n+            'password' => 'passw0rd!',\n+        ]);\n+\n+        $this->assertInstanceOf(Result::class, $result);\n+        $this->assertTrue($result->isOK());\n+\n+        $foundUser = $result->extraInfo();\n+        $this->assertSame($this->user->id, $foundUser->id);\n+    }\n+\n     public function testAttemptCannotFindUser(): void\n     {\n         $result = $this->auth->attempt(["
        },
        {
          "filename": "tests/Controllers/LoginTest.php",
          "status": "modified",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n use CodeIgniter\\Config\\Factories;\n use CodeIgniter\\I18n\\Time;\n use CodeIgniter\\Shield\\Authentication\\Actions\\Email2FA;\n+use CodeIgniter\\Shield\\Config\\Auth;\n use CodeIgniter\\Test\\FeatureTestTrait;\n use Config\\Services;\n use Config\\Validation;\n@@ -61,6 +62,52 @@ public function testLoginBadEmail(): void\n         $this->assertSame(lang('Auth.badAttempt'), session('error'));\n     }\n \n+    public function testLoginTooLongPasswordDefault(): void\n+    {\n+        $this->user->createEmailIdentity([\n+            'email'    => 'foo@example.com',\n+            'password' => 'secret123',\n+        ]);\n+\n+        $result = $this->post('/login', [\n+            'email'    => 'fooled@example.com',\n+            'password' => str_repeat('a', 73),\n+        ]);\n+\n+        $result->assertStatus(302);\n+        $result->assertRedirect();\n+        $result->assertSessionMissing('error');\n+        $result->assertSessionHas(\n+            'errors',\n+            ['password' => 'Password cannot exceed 72 bytes in length.']\n+        );\n+    }\n+\n+    public function testLoginTooLongPasswordArgon2id(): void\n+    {\n+        /** @var Auth $config */\n+        $config                = config('Auth');\n+        $config->hashAlgorithm = PASSWORD_ARGON2ID;\n+\n+        $this->user->createEmailIdentity([\n+            'email'    => 'foo@example.com',\n+            'password' => 'secret123',\n+        ]);\n+\n+        $result = $this->post('/login', [\n+            'email'    => 'fooled@example.com',\n+            'password' => str_repeat('a', 256),\n+        ]);\n+\n+        $result->assertStatus(302);\n+        $result->assertRedirect();\n+        $result->assertSessionMissing('error');\n+        $result->assertSessionHas(\n+            'errors',\n+            ['password' => 'The Password field cannot exceed 255 characters in length.']\n+        );\n+    }\n+\n     public function testLoginActionEmailSuccess(): void\n     {\n         if (version_compare(CodeIgniter::CI_VERSION, '4.3.0', '>=')) {"
        },
        {
          "filename": "tests/Controllers/RegisterTest.php",
          "status": "modified",
          "additions": 41,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n use CodeIgniter\\Shield\\Authentication\\Actions\\EmailActivator;\n use CodeIgniter\\Shield\\Authentication\\Authenticators\\Session;\n use CodeIgniter\\Shield\\Authentication\\Passwords\\ValidationRules;\n+use CodeIgniter\\Shield\\Config\\Auth;\n use CodeIgniter\\Shield\\Entities\\User;\n use CodeIgniter\\Shield\\Models\\UserModel;\n use CodeIgniter\\Test\\FeatureTestTrait;\n@@ -81,6 +82,46 @@ public function testRegisterActionSuccess(): void\n         $this->assertTrue($user->active);\n     }\n \n+    public function testRegisterTooLongPasswordDefault(): void\n+    {\n+        $result = $this->withSession()->post('/register', [\n+            'username'         => 'JohnDoe',\n+            'email'            => 'john.doe@example.com',\n+            'password'         => str_repeat('a', 73),\n+            'password_confirm' => str_repeat('a', 73),\n+        ]);\n+\n+        $result->assertStatus(302);\n+        $result->assertRedirect();\n+        $result->assertSessionMissing('error');\n+        $result->assertSessionHas(\n+            'errors',\n+            ['password' => 'Password cannot exceed 72 bytes in length.']\n+        );\n+    }\n+\n+    public function testRegisterTooLongPasswordArgon2id(): void\n+    {\n+        /** @var Auth $config */\n+        $config                = config('Auth');\n+        $config->hashAlgorithm = PASSWORD_ARGON2ID;\n+\n+        $result = $this->withSession()->post('/register', [\n+            'username'         => 'JohnDoe',\n+            'email'            => 'john.doe@example.com',\n+            'password'         => str_repeat('a', 256),\n+            'password_confirm' => str_repeat('a', 256),\n+        ]);\n+\n+        $result->assertStatus(302);\n+        $result->assertRedirect();\n+        $result->assertSessionMissing('error');\n+        $result->assertSessionHas(\n+            'errors',\n+            ['password' => 'The Password field cannot exceed 255 characters in length.']\n+        );\n+    }\n+\n     public function testRegisterDisplaysForm(): void\n     {\n         $result = $this->withSession()->get('/register');"
        },
        {
          "filename": "tests/Unit/PasswordsTest.php",
          "status": "modified",
          "additions": 36,
          "deletions": 0,
          "patch": "@@ -23,4 +23,40 @@ public function testEmptyPassword(): void\n         $this->assertFalse($result->isOK());\n         $this->assertSame('A Password is required.', $result->reason());\n     }\n+\n+    public function testHash(): string\n+    {\n+        $config    = new AuthConfig();\n+        $passwords = new Passwords($config);\n+\n+        $plainPassword  = 'passw0rd!';\n+        $hashedPassword = $passwords->hash($plainPassword);\n+\n+        $user = new User([\n+            'id'       => 1,\n+            'username' => 'John',\n+        ]);\n+        $user->email         = 'john@example.org';\n+        $user->password_hash = $hashedPassword;\n+\n+        $result = $passwords->check($plainPassword, $user);\n+\n+        $this->assertTrue($result->isOK());\n+\n+        return $hashedPassword;\n+    }\n+\n+    /**\n+     * @depends testHash\n+     */\n+    public function testNeedsRehashTakesCareOptions(string $hashedPassword): void\n+    {\n+        $config           = new AuthConfig();\n+        $config->hashCost = 12;\n+        $passwords        = new Passwords($config);\n+\n+        $result = $passwords->needsRehash($hashedPassword);\n+\n+        $this->assertTrue($result);\n+    }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 18,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 22,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b2ddb70df8072591c4c158a2192e3759286f3610",
            "date": "2024-11-18T15:55:57Z",
            "author_login": "datamweb"
          },
          {
            "sha": "9fd9ca3939e7e62e29dff58a0da87edbe25ecc69",
            "date": "2024-11-16T17:39:58Z",
            "author_login": "christianberkman"
          },
          {
            "sha": "031b63759054892a93244492860dc0a85c9757a8",
            "date": "2024-11-08T14:23:00Z",
            "author_login": "samsonasik"
          },
          {
            "sha": "6b43fa9845b02146e91cd2f739ac91c732824858",
            "date": "2024-11-08T14:15:17Z",
            "author_login": "samsonasik"
          },
          {
            "sha": "17d1a498fdb62adacda94a4a791879d2ff0871e6",
            "date": "2024-11-08T14:09:08Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-916",
    "description": "CodeIgniter Shield provides authentication and authorization for the CodeIgniter 4 PHP framework. An improper implementation was found in the password storage process. All hashed passwords stored in Shield v1.0.0-beta.3 or earlier are easier to crack than expected due to the vulnerability. Therefore, they should be removed as soon as possible. If an attacker gets (1) the user's hashed password by Shield, and (2) the hashed password (SHA-384 hash without salt) from somewhere, the attacker may easily crack the user's password. Upgrade to Shield v1.0.0-beta.4 or later to fix this issue. After upgrading, all users\u2019 hashed passwords should be updated (saved to the database). There are no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-13T18:15:12.970",
    "last_modified": "2024-11-21T07:53:11.463",
    "fix_date": "2023-03-11T05:01:18Z"
  },
  "references": [
    {
      "url": "https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pre-hashing-passwords",
      "source": "security-advisories@github.com",
      "tags": [
        "Not Applicable"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/blob/develop/UPGRADING.md",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/commit/ea9688dd01d100193d834117dbfc2cfabcf9ea0b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/security/advisories/GHSA-c5vj-f36q-p9vg",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.scottbrady91.com/authentication/beware-of-password-shucking",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pre-hashing-passwords",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Not Applicable"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/blob/develop/UPGRADING.md",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/commit/ea9688dd01d100193d834117dbfc2cfabcf9ea0b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/security/advisories/GHSA-c5vj-f36q-p9vg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.scottbrady91.com/authentication/beware-of-password-shucking",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.837337",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "shield",
    "owner": "codeigniter4",
    "created_at": "2020-12-30T06:55:29Z",
    "updated_at": "2025-01-13T08:00:48Z",
    "pushed_at": "2024-11-18T15:56:26Z",
    "size": 9749,
    "stars": 372,
    "forks": 132,
    "open_issues": 17,
    "watchers": 372,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "PHP": 865072,
      "Shell": 1111
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:50:28.047582"
  }
}