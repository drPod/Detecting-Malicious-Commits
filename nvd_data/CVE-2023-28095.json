{
  "cve_id": "CVE-2023-28095",
  "github_data": {
    "repository": "OpenSIPS/opensips",
    "fix_commit": "9cf3dd3398719dd91207495f76d7726701c5145c",
    "related_commits": [
      "9cf3dd3398719dd91207495f76d7726701c5145c",
      "9cf3dd3398719dd91207495f76d7726701c5145c"
    ],
    "patch_url": "https://github.com/OpenSIPS/opensips/commit/9cf3dd3398719dd91207495f76d7726701c5145c.patch",
    "fix_commit_details": {
      "sha": "9cf3dd3398719dd91207495f76d7726701c5145c",
      "commit_date": "2021-11-08T08:16:54Z",
      "author": {
        "login": "bogdan-iancu",
        "type": "User",
        "stats": {
          "total_commits": 4913,
          "average_weekly_commits": 4.8025415444770285,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 744
        }
      },
      "commit_message": {
        "title": "[core] build_res_buf_from_sip_req(): fix hdr correlation",
        "length": 249,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 259,
        "additions": 130,
        "deletions": 129
      },
      "files": [
        {
          "filename": "msg_translator.c",
          "status": "modified",
          "additions": 130,
          "deletions": 129,
          "patch": "@@ -134,9 +134,6 @@ int disable_503_translation = 0;\n \t\t(_dest) += (_len) ;\\\n \t}while(0);\n \n-#define append_str_trans(_dest,_src,_len,_msg) \\\n-\tappend_str( (_dest), (_src), (_len) );\n-\n extern char version[];\n extern int version_len;\n \n@@ -2489,39 +2486,40 @@ char * build_res_buf_from_sip_req( unsigned int code, const str *text ,str *new_\n \t/* first line */\n \tlen += SIP_VERSION_LEN + 1/*space*/ + 3/*code*/ + 1/*space*/ +\n \t\ttext->len + CRLF_LEN/*new line*/;\n-\t/*headers that will be copied (TO, FROM, CSEQ,CALLID,VIA)*/\n-\tfor ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {\n-\t\tswitch (hdr->type) {\n-\t\t\tcase HDR_TO_T:\n-\t\t\t\tif (new_tag && new_tag->len) {\n-\t\t\t\t\tto_tag=get_to(msg)->tag_value;\n-\t\t\t\t\tif (to_tag.len )\n-\t\t\t\t\t\tlen+=new_tag->len-to_tag.len;\n-\t\t\t\t\telse\n-\t\t\t\t\t\tlen+=new_tag->len+TOTAG_TOKEN_LEN/*\";tag=\"*/;\n-\t\t\t\t}\n-\t\t\t\tlen += hdr->len;\n-\t\t\t\tbreak;\n-\t\t\tcase HDR_VIA_T:\n-\t\t\t\t/* we always add CRLF to via*/\n-\t\t\t\tlen+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;\n-\t\t\t\tif (hdr==msg->h_via1) len += received_len+rport_len;\n-\t\t\t\tbreak;\n-\t\t\tcase HDR_RECORDROUTE_T:\n-\t\t\t\t/* RR only for 1xx and 2xx replies */\n-\t\t\t\tif (code<180 || code>=300)\n-\t\t\t\t\tbreak;\n-\t\t\tcase HDR_FROM_T:\n-\t\t\tcase HDR_CALLID_T:\n-\t\t\tcase HDR_CSEQ_T:\n-\t\t\t\t/* we keep the original termination for these headers*/\n-\t\t\t\tlen += hdr->len;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\t/* do nothing, we are interested only in the above headers */\n-\t\t\t\t;\n+\t/* copy the TO hdr */\n+\tif (msg->to) {\n+\t\tif (new_tag && new_tag->len) {\n+\t\t\tto_tag=get_to(msg)->tag_value;\n+\t\t\tif (to_tag.len )\n+\t\t\t\tlen+=new_tag->len-to_tag.len;\n+\t\t\telse\n+\t\t\t\tlen+=new_tag->len+TOTAG_TOKEN_LEN/*\";tag=\"*/;\n \t\t}\n-\t}\n+\t\tlen += msg->to->len;\n+\t}\n+\n+\t/* copy all VIA hdrs */\n+\tfor( hdr=msg->h_via1 ; hdr ; hdr=hdr->sibling) {\n+\t\t/* we always add CRLF to via*/\n+\t\tlen+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;\n+\t\tif (hdr==msg->h_via1) len += received_len+rport_len;\n+\t}\n+\t/* copy all Record-Route hdrs */\n+\tfor( hdr=msg->record_route ; hdr ; hdr=hdr->sibling) {\n+\t\t/* RR only for 1xx and 2xx replies */\n+\t\tif (code>=180 && code<300)\n+\t\t\tlen += hdr->len;\n+\t}\n+\t/* copy the FROM hdr */\n+\tif (msg->from)\n+\t\tlen += msg->from->len;\n+\t/* copy the CALLID hdr */\n+\tif (msg->callid)\n+\t\tlen += msg->callid->len;\n+\t/* copy the CSEQ hdr */\n+\tif (msg->cseq)\n+\t\tlen += msg->cseq->len;\n+\n \t/* lumps length */\n \tfor(lump=msg->reply_lump;lump;lump=lump->next) {\n \t\tlen += lump->text.len;\n@@ -2570,100 +2568,103 @@ char * build_res_buf_from_sip_req( unsigned int code, const str *text ,str *new_\n \tp += text->len;\n \tmemcpy( p, CRLF, CRLF_LEN );\n \tp+=CRLF_LEN;\n-\t/* headers*/\n-\tfor ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {\n-\t\tswitch (hdr->type)\n-\t\t{\n-\t\t\tcase HDR_VIA_T:\n-\t\t\t\tif (hdr==msg->h_via1){\n-\t\t\t\t\ti = 0;\n-\t\t\t\t\tif (received_buf) {\n-\t\t\t\t\t\ti = msg->via1->host.s - msg->via1->hdr.s +\n-\t\t\t\t\t\t\tmsg->via1->host.len + (msg->via1->port?\n-\t\t\t\t\t\t\tmsg->via1->port_str.len + 1 : 0);\n-\t\t\t\t\t\t/* copy via1 up to params */\n-\t\t\t\t\t\tappend_str( p, hdr->name.s, i);\n-\t\t\t\t\t\t/* copy received param */\n-\t\t\t\t\t\tappend_str( p, received_buf, received_len);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (rport_buf){\n-\t\t\t\t\t\tif (msg->via1->rport){ /* delete the old one */\n-\t\t\t\t\t\t\t/* copy until rport */\n-\t\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n-\t\t\t\t\t\t\t\tmsg->via1->rport->start-hdr->name.s-1-i,msg);\n-\t\t\t\t\t\t\t/* copy new rport */\n-\t\t\t\t\t\t\tappend_str(p, rport_buf, rport_len);\n-\t\t\t\t\t\t\t/* copy the rest of the via */\n-\t\t\t\t\t\t\tappend_str_trans(p, msg->via1->rport->start+\n-\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->size,\n-\t\t\t\t\t\t\t\t\t\t\t\thdr->body.s+hdr->body.len-\n-\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->start-\n-\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->size, msg);\n-\t\t\t\t\t\t}else{ /* just copy rport and rest of hdr */\n-\t\t\t\t\t\t\tappend_str(p, rport_buf, rport_len);\n-\t\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n-\t\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i,msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}else{\n-\t\t\t\t\t\t/* normal whole via copy */\n-\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n-\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i, msg);\n-\t\t\t\t\t}\n-\t\t\t\t}else{\n-\t\t\t\t\t/* normal whole via copy */\n-\t\t\t\t\tappend_str_trans( p, hdr->name.s,\n-\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s, msg);\n-\t\t\t\t}\n-\t\t\t\tappend_str( p, CRLF,CRLF_LEN);\n-\t\t\t\tbreak;\n-\t\t\tcase HDR_RECORDROUTE_T:\n-\t\t\t\t/* RR only for 1xx and 2xx replies */\n-\t\t\t\tif (code<180 || code>=300) break;\n-\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n-\t\t\t\tbreak;\n-\t\t\tcase HDR_TO_T:\n-\t\t\t\tif (new_tag && new_tag->len){\n-\t\t\t\t\tif (to_tag.len ) { /* replacement */\n-\t\t\t\t\t\t/* before to-tag */\n-\t\t\t\t\t\tappend_str( p, hdr->name.s, to_tag.s-hdr->name.s);\n-\t\t\t\t\t\t/* to tag replacement */\n-\t\t\t\t\t\tbmark->to_tag_val.s=p;\n-\t\t\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n-\t\t\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n-\t\t\t\t\t\t/* the rest after to-tag */\n-\t\t\t\t\t\tappend_str( p, to_tag.s+to_tag.len,\n-\t\t\t\t\t\t\thdr->name.s+hdr->len-(to_tag.s+to_tag.len));\n-\t\t\t\t\t}else{ /* adding a new to-tag */\n-\t\t\t\t\t\tafter_body=hdr->body.s+hdr->body.len;\n-\t\t\t\t\t\tappend_str( p, hdr->name.s, after_body-hdr->name.s);\n-\t\t\t\t\t\tappend_str(p, TOTAG_TOKEN, TOTAG_TOKEN_LEN);\n-\t\t\t\t\t\tbmark->to_tag_val.s=p;\n-\t\t\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n-\t\t\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n-\t\t\t\t\t\tappend_str( p, after_body,\n-\t\t\t\t\t\t\t\t\t\thdr->name.s+hdr->len-after_body);\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t} /* no new to-tag -- proceed to 1:1 copying  */\n-\t\t\t\ttotags=((struct to_body*)(hdr->parsed))->tag_value.s;\n-\t\t\t\tif (totags) {\n-\t\t\t\t\tbmark->to_tag_val.s=p+(totags-hdr->name.s);\n-\t\t\t\t\tbmark->to_tag_val.len=\n-\t\t\t\t\t\t\t((struct to_body*)(hdr->parsed))->tag_value.len;\n-\t\t\t\t} else {\n-\t\t\t\t\tbmark->to_tag_val.s = NULL;\n-\t\t\t\t\tbmark->to_tag_val.len = 0;\n-\t\t\t\t}\n-\t\t\tcase HDR_FROM_T:\n-\t\t\tcase HDR_CALLID_T:\n-\t\t\tcase HDR_CSEQ_T:\n-\t\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n-\t\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\t/* do nothing, we are interested only in the above headers */\n-\t\t\t\t;\n-\t\t} /* end switch */\n-\t} /* end for */\n+\t/* VIA headers */\n+\tif ( (hdr=msg->h_via1)!=NULL ) {\n+\t\t/* handle the VIA1, subject to changes */\n+\t\ti = 0;\n+\t\tif (received_buf) {\n+\t\t\ti = msg->via1->host.s - msg->via1->hdr.s +\n+\t\t\t\tmsg->via1->host.len + (msg->via1->port?\n+\t\t\t\tmsg->via1->port_str.len + 1 : 0);\n+\t\t\t/* copy via1 up to params */\n+\t\t\tappend_str( p, hdr->name.s, i);\n+\t\t\t/* copy received param */\n+\t\t\tappend_str( p, received_buf, received_len);\n+\t\t}\n+\t\tif (rport_buf){\n+\t\t\tif (msg->via1->rport){ /* delete the old one */\n+\t\t\t\t/* copy until rport */\n+\t\t\t\tappend_str( p, hdr->name.s+i ,\n+\t\t\t\t\tmsg->via1->rport->start-hdr->name.s-1-i);\n+\t\t\t\t/* copy new rport */\n+\t\t\t\tappend_str(p, rport_buf, rport_len);\n+\t\t\t\t/* copy the rest of the via */\n+\t\t\t\tappend_str(p, msg->via1->rport->start+\n+\t\t\t\t\t\t\t\t\tmsg->via1->rport->size,\n+\t\t\t\t\t\t\t\t\thdr->body.s+hdr->body.len-\n+\t\t\t\t\t\t\t\t\tmsg->via1->rport->start-\n+\t\t\t\t\t\t\t\t\tmsg->via1->rport->size);\n+\t\t\t}else{ /* just copy rport and rest of hdr */\n+\t\t\t\tappend_str(p, rport_buf, rport_len);\n+\t\t\t\tappend_str( p, hdr->name.s+i ,\n+\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i);\n+\t\t\t}\n+\t\t}else{\n+\t\t\t/* normal whole via copy */\n+\t\t\tappend_str( p, hdr->name.s+i ,\n+\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i);\n+\t\t}\n+\t\tappend_str( p, CRLF,CRLF_LEN);\n+\t\t/* and now the rest of the VIA hdrs */\n+\t\tfor( hdr=hdr->sibling ; hdr ; hdr=hdr->sibling) {\n+\t\t\t/* normal whole via copy */\n+\t\t\tappend_str( p, hdr->name.s,\n+\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s);\n+\t\t\tappend_str( p, CRLF,CRLF_LEN);\n+\t\t}\n+\t}\n+\t/* Record-Route headers */\n+\tfor( hdr=msg->record_route ; hdr ; hdr=hdr->sibling) {\n+\t\t/* RR only for 1xx and 2xx replies */\n+\t\tif (code>=180 && code<300)\n+\t\t\tappend_str(p, hdr->name.s, hdr->len);\n+\t}\n+\t/* TO hdr */\n+\tif ( (hdr=msg->to)!=NULL ) {\n+\t\tif (new_tag && new_tag->len){\n+\t\t\tif (to_tag.len ) { /* replacement */\n+\t\t\t\t/* before to-tag */\n+\t\t\t\tappend_str( p, hdr->name.s, to_tag.s-hdr->name.s);\n+\t\t\t\t/* to tag replacement */\n+\t\t\t\tbmark->to_tag_val.s=p;\n+\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n+\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n+\t\t\t\t/* the rest after to-tag */\n+\t\t\t\tappend_str( p, to_tag.s+to_tag.len,\n+\t\t\t\t\thdr->name.s+hdr->len-(to_tag.s+to_tag.len));\n+\t\t\t}else{ /* adding a new to-tag */\n+\t\t\t\tafter_body=hdr->body.s+hdr->body.len;\n+\t\t\t\tappend_str( p, hdr->name.s, after_body-hdr->name.s);\n+\t\t\t\tappend_str(p, TOTAG_TOKEN, TOTAG_TOKEN_LEN);\n+\t\t\t\tbmark->to_tag_val.s=p;\n+\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n+\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n+\t\t\t\tappend_str( p, after_body,\n+\t\t\t\t\t\t\t\thdr->name.s+hdr->len-after_body);\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* no new to-tag -- proceed to 1:1 copying  */\n+\t\t\ttotags=((struct to_body*)(hdr->parsed))->tag_value.s;\n+\t\t\tif (totags) {\n+\t\t\t\tbmark->to_tag_val.s=p+(totags-hdr->name.s);\n+\t\t\t\tbmark->to_tag_val.len=\n+\t\t\t\t\t((struct to_body*)(hdr->parsed))->tag_value.len;\n+\t\t\t} else {\n+\t\t\t\tbmark->to_tag_val.s = NULL;\n+\t\t\t\tbmark->to_tag_val.len = 0;\n+\t\t\t}\n+\t\t\tappend_str(p, hdr->name.s, hdr->len);\n+\t\t}\n+\t}\n+\t/* FROM header */\n+\tif (msg->from)\n+\t\tappend_str(p, msg->from->name.s, msg->from->len);\n+\t/* CALLID header */\n+\tif (msg->callid)\n+\t\tappend_str(p, msg->callid->name.s, msg->callid->len);\n+\t/* copy the CSEQ hdr */\n+\tif (msg->cseq)\n+\t\tappend_str(p, msg->cseq->name.s, msg->cseq->len);\n \t/* lumps */\n \tfor(lump=msg->reply_lump;lump;lump=lump->next)\n \t\tif (lump->flags&LUMP_RPL_HDR){"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "da7da69519b959e7395dad586ff50264b63ccd7f",
            "date": "2025-01-14T09:39:48Z",
            "author_login": "razvancrainea"
          },
          {
            "sha": "b8bb4446e114e612a5720b930d4b61b5aff94443",
            "date": "2025-01-14T10:16:21Z",
            "author_login": "bogdan-iancu"
          },
          {
            "sha": "cc7619070dab61029d2c023779e563ccfbb06b54",
            "date": "2025-01-14T10:01:47Z",
            "author_login": "bogdan-iancu"
          },
          {
            "sha": "12390b477235307cb5adda078fd815d5077e8f26",
            "date": "2025-01-14T08:22:45Z",
            "author_login": "bogdan-iancu"
          },
          {
            "sha": "7a12c9b5642a57c9490b422426051e8b0d51a8b2",
            "date": "2025-01-14T07:50:33Z",
            "author_login": "bogdan-iancu"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Versions prior to 3.1.7 and 3.2.4 have a potential issue in `msg_translator.c:2628` which might lead to a server crash. This issue was found while fuzzing the function `build_res_buf_from_sip_req` but could not be reproduced against a running instance of OpenSIPS. This issue could not be exploited against a running instance of OpenSIPS since no public function was found to make use of this vulnerable code. Even in the case of exploitation through unknown vectors, it is highly unlikely that this issue would lead to anything other than Denial of Service. This issue has been fixed in versions 3.1.7 and 3.2.4.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-15T22:15:10.440",
    "last_modified": "2024-11-21T07:54:23.533",
    "fix_date": "2021-11-08T08:16:54Z"
  },
  "references": [
    {
      "url": "https://github.com/OpenSIPS/opensips/commit/9cf3dd3398719dd91207495f76d7726701c5145c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-7pf3-24qg-8v9h",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenSIPS/opensips/commit/9cf3dd3398719dd91207495f76d7726701c5145c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-7pf3-24qg-8v9h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.847343",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "opensips",
    "owner": "OpenSIPS",
    "created_at": "2013-05-09T11:16:38Z",
    "updated_at": "2025-01-14T10:24:34Z",
    "pushed_at": "2025-01-14T10:24:31Z",
    "size": 167162,
    "stars": 1305,
    "forks": 583,
    "open_issues": 298,
    "watchers": 1305,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "3.4",
      "master"
    ],
    "languages": {
      "C": 17064426,
      "Makefile": 128559,
      "Yacc": 81038,
      "Perl": 72729,
      "Python": 64356,
      "C++": 62693,
      "Shell": 36152,
      "M4": 32463,
      "XS": 31933,
      "Lex": 31033,
      "PHP": 16028,
      "Roff": 10751,
      "Vim Script": 5424,
      "GDB": 2914,
      "CMake": 461
    },
    "commit_activity": {
      "total_commits_last_year": 932,
      "avg_commits_per_week": 17.923076923076923,
      "days_active_last_year": 234
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:37:09.249306"
  }
}