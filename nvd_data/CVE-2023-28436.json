{
  "cve_id": "CVE-2023-28436",
  "github_data": {
    "repository": "tailscale/tailscale",
    "fix_commit": "d00c046b723dff6e3775d7d35f891403ac21a47d",
    "related_commits": [
      "d00c046b723dff6e3775d7d35f891403ac21a47d",
      "d00c046b723dff6e3775d7d35f891403ac21a47d"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "d00c046b723dff6e3775d7d35f891403ac21a47d",
      "commit_date": "2023-03-20T17:37:28Z",
      "author": {
        "login": "andrew-d",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "ssh/tailssh: fix privilege dropping on FreeBSD; add tests",
        "length": 1807,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 414,
        "additions": 400,
        "deletions": 14
      },
      "files": [
        {
          "filename": "ssh/tailssh/incubator.go",
          "status": "modified",
          "additions": 105,
          "deletions": 14,
          "patch": "@@ -235,6 +235,7 @@ func beIncubator(args []string) error {\n \tif err == nil && sessionCloser != nil {\n \t\tdefer sessionCloser()\n \t}\n+\n \tvar groupIDs []int\n \tfor _, g := range strings.Split(ia.groups, \",\") {\n \t\tgid, err := strconv.ParseInt(g, 10, 32)\n@@ -244,22 +245,10 @@ func beIncubator(args []string) error {\n \t\tgroupIDs = append(groupIDs, int(gid))\n \t}\n \n-\tif err := setGroups(groupIDs); err != nil {\n+\tif err := dropPrivileges(logf, int(ia.uid), ia.gid, groupIDs); err != nil {\n \t\treturn err\n \t}\n-\tif egid := os.Getegid(); egid != ia.gid {\n-\t\tif err := syscall.Setgid(int(ia.gid)); err != nil {\n-\t\t\tlogf(err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t}\n-\tif euid != ia.uid {\n-\t\t// Switch users if required before starting the desired process.\n-\t\tif err := syscall.Setuid(int(ia.uid)); err != nil {\n-\t\t\tlogf(err.Error())\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t}\n+\n \tif ia.isSFTP {\n \t\tlogf(\"handling sftp\")\n \n@@ -304,6 +293,108 @@ func beIncubator(args []string) error {\n \treturn err\n }\n \n+// TODO(andrew-d): verify that this works in more configurations before\n+// enabling by default.\n+const assertDropPrivileges = false\n+\n+// dropPrivileges contains all the logic for dropping privileges to a different\n+// UID, GID, and set of supplementary groups. This function is\n+// security-sensitive and ordering-dependent; please be very cautious if/when\n+// refactoring.\n+//\n+// WARNING: if you change this function, you *MUST* run the TestDropPrivileges\n+// test in this package as root on at least Linux, FreeBSD and Darwin. This can\n+// be done by running:\n+//\n+//\tgo test -c ./ssh/tailssh/ && sudo ./tailssh.test -test.v -test.run TestDropPrivileges\n+func dropPrivileges(logf logger.Logf, wantUid, wantGid int, supplementaryGroups []int) error {\n+\tfatalf := func(format string, args ...any) {\n+\t\tlogf(format, args...)\n+\t\tos.Exit(1)\n+\t}\n+\n+\teuid := os.Geteuid()\n+\tegid := os.Getegid()\n+\n+\tif runtime.GOOS == \"darwin\" || runtime.GOOS == \"freebsd\" {\n+\t\t// On FreeBSD and Darwin, the first entry returned from the\n+\t\t// getgroups(2) syscall is the egid, and changing it with\n+\t\t// setgroups(2) changes the egid of the process. This is\n+\t\t// technically a violation of the POSIX standard; see the\n+\t\t// following article for more detail:\n+\t\t//    https://www.usenix.org/system/files/login/articles/325-tsafrir.pdf\n+\t\t//\n+\t\t// In this case, we add an entry at the beginning of the\n+\t\t// groupIDs list containing the expected gid if it's not\n+\t\t// already there, which modifies the egid and additional groups\n+\t\t// as one unit.\n+\t\tif len(supplementaryGroups) == 0 || supplementaryGroups[0] != wantGid {\n+\t\t\tsupplementaryGroups = append([]int{wantGid}, supplementaryGroups...)\n+\t\t}\n+\t}\n+\n+\tif err := setGroups(supplementaryGroups); err != nil {\n+\t\treturn err\n+\t}\n+\tif egid != wantGid {\n+\t\t// On FreeBSD and Darwin, we may have already called the\n+\t\t// equivalent of setegid(wantGid) via the call to setGroups,\n+\t\t// above. However, per the manpage, setgid(getegid()) is an\n+\t\t// allowed operation regardless of privilege level.\n+\t\t//\n+\t\t// FreeBSD:\n+\t\t//\tThe setgid() system call is permitted if the specified ID\n+\t\t//\tis equal to the real group ID or the effective group ID\n+\t\t//\tof the process, or if the effective user ID is that of\n+\t\t//\tthe super user.\n+\t\t//\n+\t\t// Darwin:\n+\t\t//\tThe setgid() function is permitted if the effective\n+\t\t//\tuser ID is that of the super user, or if the specified\n+\t\t//\tgroup ID is the same as the effective group ID.  If\n+\t\t//\tnot, but the specified group ID is the same as the real\n+\t\t//\tgroup ID, setgid() will set the effective group ID to\n+\t\t//\tthe real group ID.\n+\t\tif err := syscall.Setgid(wantGid); err != nil {\n+\t\t\tfatalf(\"Setgid(%d): %v\", wantGid, err)\n+\t\t}\n+\t}\n+\tif euid != wantUid {\n+\t\t// Switch users if required before starting the desired process.\n+\t\tif err := syscall.Setuid(wantUid); err != nil {\n+\t\t\tfatalf(\"Setuid(%d): %v\", wantUid, err)\n+\t\t}\n+\t}\n+\n+\t// If we changed either the UID or GID, defensively assert that we\n+\t// cannot reset the it back to our original values, and that the\n+\t// current egid/euid are the expected values after we change\n+\t// everything; if not, we exit the process.\n+\tif assertDropPrivileges {\n+\t\tif egid != wantGid {\n+\t\t\tif err := syscall.Setegid(egid); err == nil {\n+\t\t\t\tfatalf(\"unexpectedly able to set egid back to %d\", egid)\n+\t\t\t}\n+\t\t}\n+\t\tif euid != wantUid {\n+\t\t\tif err := syscall.Seteuid(euid); err == nil {\n+\t\t\t\tfatalf(\"unexpectedly able to set euid back to %d\", euid)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif got := os.Getegid(); got != wantGid {\n+\t\t\tfatalf(\"got egid=%d, want %d\", got, wantGid)\n+\t\t}\n+\t\tif got := os.Geteuid(); got != wantUid {\n+\t\t\tfatalf(\"got euid=%d, want %d\", got, wantUid)\n+\t\t}\n+\n+\t\t// TODO(andrew-d): assert that our supplementary groups are correct\n+\t}\n+\n+\treturn nil\n+}\n+\n // launchProcess launches an incubator process for the provided session.\n // It is responsible for configuring the process execution environment.\n // The caller can wait for the process to exit by calling cmd.Wait()."
        },
        {
          "filename": "ssh/tailssh/privs_test.go",
          "status": "added",
          "additions": 295,
          "deletions": 0,
          "patch": "@@ -0,0 +1,295 @@\n+// Copyright (c) Tailscale Inc & AUTHORS\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+//go:build linux || darwin || freebsd || openbsd || netbsd || dragonfly\n+\n+package tailssh\n+\n+import (\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"syscall\"\n+\t\"testing\"\n+\n+\t\"golang.org/x/exp/slices\"\n+\t\"tailscale.com/types/logger\"\n+)\n+\n+func TestDropPrivileges(t *testing.T) {\n+\ttype SubprocInput struct {\n+\t\tUID              int\n+\t\tGID              int\n+\t\tAdditionalGroups []int\n+\t}\n+\ttype SubprocOutput struct {\n+\t\tUID              int\n+\t\tGID              int\n+\t\tEUID             int\n+\t\tEGID             int\n+\t\tAdditionalGroups []int\n+\t}\n+\n+\tif v := os.Getenv(\"TS_TEST_DROP_PRIVILEGES_CHILD\"); v != \"\" {\n+\t\tt.Logf(\"in child process\")\n+\n+\t\tvar input SubprocInput\n+\t\tif err := json.Unmarshal([]byte(v), &input); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Get a handle to our provided JSON file before dropping privs.\n+\t\tf := os.NewFile(3, \"out.json\")\n+\n+\t\t// We're in our subprocess; actually drop privileges now.\n+\t\tdropPrivileges(t.Logf, input.UID, input.GID, input.AdditionalGroups)\n+\n+\t\tadditional, _ := syscall.Getgroups()\n+\n+\t\t// Print our IDs\n+\t\tjson.NewEncoder(f).Encode(SubprocOutput{\n+\t\t\tUID:              os.Getuid(),\n+\t\t\tGID:              os.Getgid(),\n+\t\t\tEUID:             os.Geteuid(),\n+\t\t\tEGID:             os.Getegid(),\n+\t\t\tAdditionalGroups: additional,\n+\t\t})\n+\n+\t\t// Close output file to ensure that it's flushed to disk before we exit\n+\t\tf.Close()\n+\n+\t\t// Always exit the process now that we have a different\n+\t\t// UID/GID/etc.; we don't want the Go test framework to try and\n+\t\t// clean anything up, since it might no longer have access.\n+\t\tos.Exit(0)\n+\t}\n+\n+\tif os.Getuid() != 0 {\n+\t\tt.Skip(\"test only works when run as root\")\n+\t}\n+\n+\trerunSelf := func(t *testing.T, input SubprocInput) []byte {\n+\t\tfpath := filepath.Join(t.TempDir(), \"out.json\")\n+\t\toutf, err := os.Create(fpath)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tinputb, err := json.Marshal(input)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tcmd := exec.Command(os.Args[0], \"-test.v\", \"-test.run\", \"^\"+regexp.QuoteMeta(t.Name())+\"$\")\n+\t\tcmd.Env = append(os.Environ(), \"TS_TEST_DROP_PRIVILEGES_CHILD=\"+string(inputb))\n+\t\tcmd.ExtraFiles = []*os.File{outf}\n+\t\tcmd.Stdout = logger.FuncWriter(logger.WithPrefix(t.Logf, \"child: \"))\n+\t\tcmd.Stderr = logger.FuncWriter(logger.WithPrefix(t.Logf, \"child: \"))\n+\t\tif err := cmd.Run(); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\toutf.Close()\n+\n+\t\tjj, err := os.ReadFile(fpath)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn jj\n+\t}\n+\n+\t// We want to ensure we're not colliding with existing users; find some\n+\t// unused UIDs and GIDs for the tests we run.\n+\tuid1 := findUnusedUID(t)\n+\tgid1 := findUnusedGID(t)\n+\tgid2 := findUnusedGID(t, gid1)\n+\tgid3 := findUnusedGID(t, gid1, gid2)\n+\n+\t// For some tests, we want a UID/GID pair with the same numerical\n+\t// value; this finds one.\n+\tuidgid1 := findUnusedUIDGID(t, uid1, gid1, gid2, gid3)\n+\n+\tt.Logf(\"uid1=%d gid1=%d gid2=%d gid3=%d uidgid1=%d\",\n+\t\tuid1, gid1, gid2, gid3, uidgid1)\n+\n+\ttestCases := []struct {\n+\t\tname             string\n+\t\tuid              int\n+\t\tgid              int\n+\t\tadditionalGroups []int\n+\t}{\n+\t\t{\n+\t\t\tname:             \"all_different_values\",\n+\t\t\tuid:              uid1,\n+\t\t\tgid:              gid1,\n+\t\t\tadditionalGroups: []int{gid2, gid3},\n+\t\t},\n+\t\t{\n+\t\t\tname:             \"no_additional_groups\",\n+\t\t\tuid:              uid1,\n+\t\t\tgid:              gid1,\n+\t\t\tadditionalGroups: []int{},\n+\t\t},\n+\t\t// This is a regression test for the following bug, triggered\n+\t\t// on Darwin & FreeBSD:\n+\t\t//    https://github.com/tailscale/tailscale/issues/7616\n+\t\t{\n+\t\t\tname:             \"same_values\",\n+\t\t\tuid:              uidgid1,\n+\t\t\tgid:              uidgid1,\n+\t\t\tadditionalGroups: []int{uidgid1},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range testCases {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tsubprocOut := rerunSelf(t, SubprocInput{\n+\t\t\t\tUID:              tt.uid,\n+\t\t\t\tGID:              tt.gid,\n+\t\t\t\tAdditionalGroups: tt.additionalGroups,\n+\t\t\t})\n+\n+\t\t\tvar out SubprocOutput\n+\t\t\tif err := json.Unmarshal(subprocOut, &out); err != nil {\n+\t\t\t\tt.Logf(\"%s\", subprocOut)\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tt.Logf(\"output: %+v\", out)\n+\n+\t\t\tif out.UID != tt.uid {\n+\t\t\t\tt.Errorf(\"got uid %d; want %d\", out.UID, tt.uid)\n+\t\t\t}\n+\t\t\tif out.GID != tt.gid {\n+\t\t\t\tt.Errorf(\"got gid %d; want %d\", out.GID, tt.gid)\n+\t\t\t}\n+\t\t\tif out.EUID != tt.uid {\n+\t\t\t\tt.Errorf(\"got euid %d; want %d\", out.EUID, tt.uid)\n+\t\t\t}\n+\t\t\tif out.EGID != tt.gid {\n+\t\t\t\tt.Errorf(\"got egid %d; want %d\", out.EGID, tt.gid)\n+\t\t\t}\n+\n+\t\t\t// On FreeBSD and Darwin, the set of additional groups\n+\t\t\t// is prefixed with the egid; handle that case by\n+\t\t\t// modifying our expected set.\n+\t\t\twantGroups := make(map[int]bool)\n+\t\t\tfor _, id := range tt.additionalGroups {\n+\t\t\t\twantGroups[id] = true\n+\t\t\t}\n+\t\t\tif runtime.GOOS == \"darwin\" || runtime.GOOS == \"freebsd\" {\n+\t\t\t\twantGroups[tt.gid] = true\n+\t\t\t}\n+\n+\t\t\tgotGroups := make(map[int]bool)\n+\t\t\tfor _, id := range out.AdditionalGroups {\n+\t\t\t\tgotGroups[id] = true\n+\t\t\t}\n+\n+\t\t\tif !reflect.DeepEqual(gotGroups, wantGroups) {\n+\t\t\t\tt.Errorf(\"got additional groups %+v; want %+v\", gotGroups, wantGroups)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func findUnusedUID(t *testing.T, not ...int) int {\n+\tfor i := 1000; i < 65535; i++ {\n+\t\t// Skip UIDs that might be valid\n+\t\tif maybeValidUID(i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Skip UIDs that we're avoiding\n+\t\tif slices.Contains(not, i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Not a valid UID, not one we're avoiding... all good!\n+\t\treturn i\n+\t}\n+\n+\tt.Fatalf(\"unable to find an unused UID\")\n+\treturn -1\n+}\n+\n+func findUnusedGID(t *testing.T, not ...int) int {\n+\tfor i := 1000; i < 65535; i++ {\n+\t\tif maybeValidGID(i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Skip GIDs that we're avoiding\n+\t\tif slices.Contains(not, i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Not a valid GID, not one we're avoiding... all good!\n+\t\treturn i\n+\t}\n+\n+\tt.Fatalf(\"unable to find an unused GID\")\n+\treturn -1\n+}\n+\n+func findUnusedUIDGID(t *testing.T, not ...int) int {\n+\tfor i := 1000; i < 65535; i++ {\n+\t\tif maybeValidUID(i) || maybeValidGID(i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Skip IDs that we're avoiding\n+\t\tif slices.Contains(not, i) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Not a valid ID, not one we're avoiding... all good!\n+\t\treturn i\n+\t}\n+\n+\tt.Fatalf(\"unable to find an unused UID/GID pair\")\n+\treturn -1\n+}\n+\n+func maybeValidUID(id int) bool {\n+\t_, err := user.LookupId(strconv.Itoa(id))\n+\tif err == nil {\n+\t\treturn true\n+\t}\n+\n+\tvar u1 user.UnknownUserIdError\n+\tif errors.As(err, &u1) {\n+\t\treturn false\n+\t}\n+\tvar u2 user.UnknownUserError\n+\tif errors.As(err, &u2) {\n+\t\treturn false\n+\t}\n+\n+\t// Some other error; might be valid\n+\treturn true\n+}\n+\n+func maybeValidGID(id int) bool {\n+\t_, err := user.LookupGroupId(strconv.Itoa(id))\n+\tif err == nil {\n+\t\treturn true\n+\t}\n+\n+\tvar u1 user.UnknownGroupIdError\n+\tif errors.As(err, &u1) {\n+\t\treturn false\n+\t}\n+\tvar u2 user.UnknownGroupError\n+\tif errors.As(err, &u2) {\n+\t\treturn false\n+\t}\n+\n+\t// Some other error; might be valid\n+\treturn true\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "68a66ee81b8e59de355a4b1a0688f28adf2c59b6",
            "date": "2025-01-24T04:39:28Z",
            "author_login": "bradfitz"
          },
          {
            "sha": "2c98c44d9a7c0b67aef7e72e7fed0766a7e7b1e6",
            "date": "2025-01-23T21:58:40Z",
            "author_login": "bradfitz"
          },
          {
            "sha": "82e41ddc427aa6d41b875642788cb12f765ed40c",
            "date": "2025-01-24T00:31:40Z",
            "author_login": "raggi"
          },
          {
            "sha": "2089f4b603e36501dd1a7497ab4de691b1560dd7",
            "date": "2025-01-25T00:29:00Z",
            "author_login": "tomhjp"
          },
          {
            "sha": "ca39c4e150366b0cdcb766a62c9c8bc3fb116083",
            "date": "2025-01-24T00:23:41Z",
            "author_login": "raggi"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.7,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:H/UI:R/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-269",
    "description": "Tailscale is software for using Wireguard and multi-factor authentication (MFA). A vulnerability identified in the implementation of Tailscale SSH starting in version 1.34.0 and prior to prior to 1.38.2 in FreeBSD allows commands to be run with a higher privilege group ID than that specified in Tailscale SSH access rules. A difference in the behavior of the FreeBSD `setgroups` system call from POSIX meant that the Tailscale client running on a FreeBSD-based operating system did not appropriately restrict groups on the host when using Tailscale SSH. When accessing a FreeBSD host over Tailscale SSH, the egid of the tailscaled process was used instead of that of the user specified in Tailscale SSH access rules.\n\nTailscale SSH commands may have been run with a higher privilege group ID than that specified in Tailscale SSH access rules if they met all of the following criteria: the destination node was a FreeBSD device with Tailscale SSH enabled; Tailscale SSH access rules permitted access for non-root users; and a non-interactive SSH session was used.\n\nAffected users should upgrade to version 1.38.2 to remediate the issue.\n\n",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-23T20:15:15.487",
    "last_modified": "2024-11-21T07:55:03.773",
    "fix_date": "2023-03-20T17:37:28Z"
  },
  "references": [
    {
      "url": "https://github.com/tailscale/tailscale/commit/d00c046b723dff6e3775d7d35f891403ac21a47d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/tailscale/tailscale/releases/tag/v1.38.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/tailscale/tailscale/security/advisories/GHSA-vfgq-g5x8-g595",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://tailscale.com/security-bulletins/#ts-2023-003",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/tailscale/tailscale/commit/d00c046b723dff6e3775d7d35f891403ac21a47d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/tailscale/tailscale/releases/tag/v1.38.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/tailscale/tailscale/security/advisories/GHSA-vfgq-g5x8-g595",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://tailscale.com/security-bulletins/#ts-2023-003",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:08.999899",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "tailscale",
    "owner": "tailscale",
    "created_at": "2020-01-31T22:00:03Z",
    "updated_at": "2025-01-26T05:57:33Z",
    "pushed_at": "2025-01-25T08:43:01Z",
    "size": 57399,
    "stars": 20596,
    "forks": 1633,
    "open_issues": 2988,
    "watchers": 20596,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 9989019,
      "C": 249384,
      "TypeScript": 163695,
      "Shell": 79941,
      "Swift": 39868,
      "HTML": 19335,
      "CSS": 12707,
      "PowerShell": 10360,
      "Nix": 8651,
      "Makefile": 8255,
      "Dockerfile": 6902,
      "Lua": 6535,
      "JavaScript": 3381
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-26T07:37:36.963231"
  }
}