{
  "cve_id": "CVE-2023-28487",
  "github_data": {
    "repository": "sudo-project/sudo",
    "fix_commit": "334daf92b31b79ce68ed75e2ee14fca265f029ca",
    "related_commits": [
      "334daf92b31b79ce68ed75e2ee14fca265f029ca",
      "334daf92b31b79ce68ed75e2ee14fca265f029ca"
    ],
    "patch_url": "https://github.com/sudo-project/sudo/commit/334daf92b31b79ce68ed75e2ee14fca265f029ca.patch",
    "fix_commit_details": {
      "sha": "334daf92b31b79ce68ed75e2ee14fca265f029ca",
      "commit_date": "2023-01-18T15:21:34Z",
      "author": {
        "login": "millert",
        "type": "User",
        "stats": {
          "total_commits": 12675,
          "average_weekly_commits": 7.608043217286915,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 1196
        }
      },
      "commit_message": {
        "title": "Escape control characters in log messages and \"sudoreplay -l\" output.",
        "length": 606,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 608,
        "additions": 383,
        "deletions": 225
      },
      "files": [
        {
          "filename": "docs/sudoers.man.in",
          "status": "modified",
          "additions": 34,
          "deletions": 10,
          "patch": "@@ -5877,14 +5877,31 @@ can log events via\n syslog(3),\n to a local log file, or both.\n The log format is almost identical in both cases.\n+Any control characters present in the log data are formatted in octal\n+with a leading\n+\\(oq#\\(cq\n+character.\n+For example, a horizontal tab is stored as\n+\\(oq#011\\(cq\n+and an embedded carriage return is stored as\n+\\(oq#015\\(cq.\n+In addition, space characters in the command path are stored as\n+\\(oq#040\\(cq.\n+Command line arguments that contain spaces are enclosed in single quotes\n+('').\n+This makes it possible to distinguish multiple command line arguments\n+from a single argument that contains spaces.\n+Literal single quotes and backslash characters\n+(\\(oq\\e\\(cq)\n+in command line arguments are escaped with a backslash.\n .SS \"Accepted command log entries\"\n Commands that sudo runs are logged using the following format (split\n into multiple lines for readability):\n .nf\n .sp\n .RS 4n\n-date hostname progname: username : TTY=ttyname ; PWD=cwd ; \\e\n-    USER=runasuser ; GROUP=runasgroup ; TSID=logid ; \\e\n+date hostname progname: username : TTY=ttyname ; CHROOT=chroot ; \\e\n+    PWD=cwd ; USER=runasuser ; GROUP=runasgroup ; TSID=logid ; \\e\n     ENV=env_vars COMMAND=command\n .RE\n .fi\n@@ -5933,6 +5950,9 @@ was run on, or\n \\(lqunknown\\(rq\n if there was no terminal present.\n .TP 14n\n+chroot\n+The root directory that the command was run in, if one was specified.\n+.TP 14n\n cwd\n The current working directory that\n \\fBsudo\\fR\n@@ -5957,7 +5977,7 @@ A list of environment variables specified on the command line,\n if specified.\n .TP 14n\n command\n-The actual command that was executed.\n+The actual command that was executed, including any command line arguments.\n .PP\n Messages are logged using the locale specified by\n \\fIsudoers_locale\\fR,\n@@ -6195,17 +6215,21 @@ with a few important differences:\n 1.\\&\n The\n \\fIprogname\\fR\n-and\n-\\fIhostname\\fR\n-fields are not present.\n+field is not present.\n .TP 5n\n 2.\\&\n-If the\n-\\fIlog_year\\fR\n-option is enabled,\n-the date will also include the year.\n+The\n+\\fIhostname\\fR\n+is only logged if the\n+\\fIlog_host\\fR\n+option is enabled.\n .TP 5n\n 3.\\&\n+The date does not include the year unless the\n+\\fIlog_year\\fR\n+option is enabled.\n+.TP 5n\n+4.\\&\n Lines that are longer than\n \\fIloglinelen\\fR\n characters (80 by default) are word-wrapped and continued on the"
        },
        {
          "filename": "docs/sudoers.mdoc.in",
          "status": "modified",
          "additions": 30,
          "deletions": 8,
          "patch": "@@ -5503,12 +5503,29 @@ can log events via\n .Xr syslog 3 ,\n to a local log file, or both.\n The log format is almost identical in both cases.\n+Any control characters present in the log data are formatted in octal\n+with a leading\n+.Ql #\n+character.\n+For example, a horizontal tab is stored as\n+.Ql #011\n+and an embedded carriage return is stored as\n+.Ql #015 .\n+In addition, space characters in the command path are stored as\n+.Ql #040 .\n+Command line arguments that contain spaces are enclosed in single quotes\n+.Pq '' .\n+This makes it possible to distinguish multiple command line arguments\n+from a single argument that contains spaces.\n+Literal single quotes and backslash characters\n+.Pq Ql \\e\n+in command line arguments are escaped with a backslash.\n .Ss Accepted command log entries\n Commands that sudo runs are logged using the following format (split\n into multiple lines for readability):\n .Bd -literal -offset 4n\n-date hostname progname: username : TTY=ttyname ; PWD=cwd ; \\e\n-    USER=runasuser ; GROUP=runasgroup ; TSID=logid ; \\e\n+date hostname progname: username : TTY=ttyname ; CHROOT=chroot ; \\e\n+    PWD=cwd ; USER=runasuser ; GROUP=runasgroup ; TSID=logid ; \\e\n     ENV=env_vars COMMAND=command\n .Ed\n .Pp\n@@ -5551,6 +5568,8 @@ or\n was run on, or\n .Dq unknown\n if there was no terminal present.\n+.It chroot\n+The root directory that the command was run in, if one was specified.\n .It cwd\n The current working directory that\n .Nm sudo\n@@ -5570,7 +5589,7 @@ option is enabled.\n A list of environment variables specified on the command line,\n if specified.\n .It command\n-The actual command that was executed.\n+The actual command that was executed, including any command line arguments.\n .El\n .Pp\n Messages are logged using the locale specified by\n@@ -5794,14 +5813,17 @@ with a few important differences:\n .It\n The\n .Em progname\n-and\n+field is not present.\n+.It\n+The\n .Em hostname\n-fields are not present.\n+is only logged if the\n+.Em log_host\n+option is enabled.\n .It\n-If the\n+The date does not include the year unless the\n .Em log_year\n-option is enabled,\n-the date will also include the year.\n+option is enabled.\n .It\n Lines that are longer than\n .Em loglinelen"
        },
        {
          "filename": "docs/sudoreplay.man.in",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -170,6 +170,15 @@ In this mode,\n will list available sessions in a format similar to the\n \\fBsudo\\fR\n log file format, sorted by file name (or sequence number).\n+Any control characters present in the log data are formated in octal\n+with a leading\n+\\(oq#\\(cq\n+character.\n+For example, a horizontal tab is displayed as\n+\\(oq#011\\(cq\n+and an embedded carriage return is displayed as\n+\\(oq#015\\(cq.\n+.sp\n If a\n \\fIsearch expression\\fR\n is specified, it will be used to restrict the IDs that are displayed."
        },
        {
          "filename": "docs/sudoreplay.mdoc.in",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -162,6 +162,16 @@ In this mode,\n will list available sessions in a format similar to the\n .Nm sudo\n log file format, sorted by file name (or sequence number).\n+Any control characters present in the log data are formatted in octal\n+with a leading\n+.Ql #\n+character.\n+For example, a horizontal tab is displayed as\n+.Ql #011\n+and an embedded carriage return is displayed as\n+.Ql #015 .\n+Space characters in the command name and arguments are also formatted in octal.\n+.Pp\n If a\n .Ar search expression\n is specified, it will be used to restrict the IDs that are displayed."
        },
        {
          "filename": "include/sudo_lbuf.h",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -36,9 +36,15 @@ struct sudo_lbuf {\n \n typedef int (*sudo_lbuf_output_t)(const char *);\n \n+/* Flags for sudo_lbuf_append_esc() */\n+#define LBUF_ESC_CNTRL\t0x01\n+#define LBUF_ESC_BLANK\t0x02\n+#define LBUF_ESC_QUOTE\t0x04\n+\n sudo_dso_public void sudo_lbuf_init_v1(struct sudo_lbuf *lbuf, sudo_lbuf_output_t output, int indent, const char *continuation, int cols);\n sudo_dso_public void sudo_lbuf_destroy_v1(struct sudo_lbuf *lbuf);\n sudo_dso_public bool sudo_lbuf_append_v1(struct sudo_lbuf *lbuf, const char *fmt, ...) sudo_printflike(2, 3);\n+sudo_dso_public bool sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const char *fmt, ...) sudo_printflike(3, 4);\n sudo_dso_public bool sudo_lbuf_append_quoted_v1(struct sudo_lbuf *lbuf, const char *set, const char *fmt, ...) sudo_printflike(3, 4);\n sudo_dso_public void sudo_lbuf_print_v1(struct sudo_lbuf *lbuf);\n sudo_dso_public bool sudo_lbuf_error_v1(struct sudo_lbuf *lbuf);\n@@ -47,6 +53,7 @@ sudo_dso_public void sudo_lbuf_clearerr_v1(struct sudo_lbuf *lbuf);\n #define sudo_lbuf_init(_a, _b, _c, _d, _e) sudo_lbuf_init_v1((_a), (_b), (_c), (_d), (_e))\n #define sudo_lbuf_destroy(_a) sudo_lbuf_destroy_v1((_a))\n #define sudo_lbuf_append sudo_lbuf_append_v1\n+#define sudo_lbuf_append_esc sudo_lbuf_append_esc_v1\n #define sudo_lbuf_append_quoted sudo_lbuf_append_quoted_v1\n #define sudo_lbuf_print(_a) sudo_lbuf_print_v1((_a))\n #define sudo_lbuf_error(_a) sudo_lbuf_error_v1((_a))"
        },
        {
          "filename": "lib/eventlog/eventlog.c",
          "status": "modified",
          "additions": 61,
          "deletions": 149,
          "patch": "@@ -1,7 +1,7 @@\n /*\n  * SPDX-License-Identifier: ISC\n  *\n- * Copyright (c) 1994-1996, 1998-2021 Todd C. Miller <Todd.Miller@sudo.ws>\n+ * Copyright (c) 1994-1996, 1998-2023 Todd C. Miller <Todd.Miller@sudo.ws>\n  *\n  * Permission to use, copy, modify, and distribute this software for any\n  * purpose with or without fee is hereby granted, provided that the above\n@@ -51,24 +51,13 @@\n #include \"sudo_compat.h\"\n #include \"sudo_debug.h\"\n #include \"sudo_eventlog.h\"\n+#include \"sudo_lbuf.h\"\n #include \"sudo_fatal.h\"\n #include \"sudo_gettext.h\"\n #include \"sudo_json.h\"\n #include \"sudo_queue.h\"\n #include \"sudo_util.h\"\n \n-#define\tLL_HOST_STR\t\"HOST=\"\n-#define\tLL_TTY_STR\t\"TTY=\"\n-#define\tLL_CHROOT_STR\t\"CHROOT=\"\n-#define\tLL_CWD_STR\t\"PWD=\"\n-#define\tLL_USER_STR\t\"USER=\"\n-#define\tLL_GROUP_STR\t\"GROUP=\"\n-#define\tLL_ENV_STR\t\"ENV=\"\n-#define\tLL_CMND_STR\t\"COMMAND=\"\n-#define\tLL_TSID_STR\t\"TSID=\"\n-#define\tLL_EXIT_STR\t\"EXIT=\"\n-#define\tLL_SIGNAL_STR\t\"SIGNAL=\"\n-\n #define IS_SESSID(s) ( \\\n     isalnum((unsigned char)(s)[0]) && isalnum((unsigned char)(s)[1]) && \\\n     (s)[2] == '/' && \\\n@@ -93,26 +82,28 @@ new_logline(int event_type, int flags, struct eventlog_args *args,\n     const struct eventlog *evlog)\n {\n     const struct eventlog_config *evl_conf = eventlog_getconf();\n-    char *line = NULL, *evstr = NULL;\n     const char *iolog_file;\n     const char *tty, *tsid = NULL;\n     char exit_str[(((sizeof(int) * 8) + 2) / 3) + 2];\n     char sessid[7], offsetstr[64] = \"\";\n-    size_t len = 0;\n+    struct sudo_lbuf lbuf;\n     int i;\n     debug_decl(new_logline, SUDO_DEBUG_UTIL);\n \n+    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);\n+\n     if (ISSET(flags, EVLOG_RAW) || evlog == NULL) {\n \tif (args->reason != NULL) {\n \t    if (args->errstr != NULL) {\n-\t\tif (asprintf(&line, \"%s: %s\", args->reason, args->errstr) == -1)\n-\t\t    goto oom;\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s: %s\",\n+\t\t    args->reason, args->errstr);\n \t    } else {\n-\t\tif ((line = strdup(args->reason)) == NULL)\n-\t\t    goto oom;\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s\", args->reason);\n \t    }\n+\t    if (sudo_lbuf_error(&lbuf))\n+\t\tgoto oom;\n \t}\n-\tdebug_return_str(line);\n+\tdebug_return_str(lbuf.buf);\n     }\n \n     /* A TSID may be a sudoers-style session ID or a free-form string. */\n@@ -150,169 +141,90 @@ new_logline(int event_type, int flags, struct eventlog_args *args,\n     }\n \n     /*\n-     * Compute line length\n+     * Format the log line as an lbuf, escaping control characters in\n+     * octal form (#0nn).  Error checking (ENOMEM) is done at the end.\n      */\n-    if (args->reason != NULL)\n-\tlen += strlen(args->reason) + 3;\n-    if (args->errstr != NULL)\n-\tlen += strlen(args->errstr) + 3;\n-    if (evlog->submithost != NULL && !evl_conf->omit_hostname)\n-\tlen += sizeof(LL_HOST_STR) + 2 + strlen(evlog->submithost);\n-    if (tty != NULL)\n-\tlen += sizeof(LL_TTY_STR) + 2 + strlen(tty);\n-    if (evlog->runchroot != NULL)\n-\tlen += sizeof(LL_CHROOT_STR) + 2 + strlen(evlog->runchroot);\n-    if (evlog->runcwd != NULL)\n-\tlen += sizeof(LL_CWD_STR) + 2 + strlen(evlog->runcwd);\n-    if (evlog->runuser != NULL)\n-\tlen += sizeof(LL_USER_STR) + 2 + strlen(evlog->runuser);\n-    if (evlog->rungroup != NULL)\n-\tlen += sizeof(LL_GROUP_STR) + 2 + strlen(evlog->rungroup);\n-    if (tsid != NULL) {\n-\tlen += sizeof(LL_TSID_STR) + 2 + strlen(tsid) + strlen(offsetstr);\n-    }\n-    if (evlog->env_add != NULL) {\n-\tsize_t evlen = 0;\n-\tchar * const *ep;\n-\n-\tfor (ep = evlog->env_add; *ep != NULL; ep++)\n-\t    evlen += strlen(*ep) + 1;\n-\tif (evlen != 0) {\n-\t    if ((evstr = malloc(evlen)) == NULL)\n-\t\tgoto oom;\n-\t    ep = evlog->env_add;\n-\t    if (strlcpy(evstr, *ep, evlen) >= evlen)\n-\t\tgoto toobig;\n-\t    while (*++ep != NULL) {\n-\t\tif (strlcat(evstr, \" \", evlen) >= evlen ||\n-\t\t    strlcat(evstr, *ep, evlen) >= evlen)\n-\t\t    goto toobig;\n-\t    }\n-\t    len += sizeof(LL_ENV_STR) + 2 + evlen;\n-\t}\n-    }\n-    if (evlog->command != NULL) {\n-\tlen += sizeof(LL_CMND_STR) - 1 + strlen(evlog->command);\n-\tif (evlog->argv != NULL && evlog->argv[0] != NULL) {\n-\t    for (i = 1; evlog->argv[i] != NULL; i++)\n-\t\tlen += strlen(evlog->argv[i]) + 1;\n-\t}\n-\tif (event_type == EVLOG_EXIT) {\n-\t    if (evlog->signal_name != NULL)\n-\t\tlen += sizeof(LL_SIGNAL_STR) + 2 + strlen(evlog->signal_name);\n-\t    if (evlog->exit_value != -1) {\n-\t\t(void)snprintf(exit_str, sizeof(exit_str), \"%d\", evlog->exit_value);\n-\t\tlen += sizeof(LL_EXIT_STR) + 2 + strlen(exit_str);\n-\t    }\n-\t}\n-    }\n-\n-    /*\n-     * Allocate and build up the line.\n-     */\n-    if ((line = malloc(++len)) == NULL)\n-\tgoto oom;\n-    line[0] = '\\0';\n-\n     if (args->reason != NULL) {\n-\tif (strlcat(line, args->reason, len) >= len ||\n-\t    strlcat(line, args->errstr ? \" : \" : \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s%s\", args->reason,\n+\t    args->errstr ? \" : \" : \" ; \");\n     }\n     if (args->errstr != NULL) {\n-\tif (strlcat(line, args->errstr, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s ; \", args->errstr);\n     }\n     if (evlog->submithost != NULL && !evl_conf->omit_hostname) {\n-\tif (strlcat(line, LL_HOST_STR, len) >= len ||\n-\t    strlcat(line, evlog->submithost, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"HOST=%s ; \",\n+\t    evlog->submithost);\n     }\n     if (tty != NULL) {\n-\tif (strlcat(line, LL_TTY_STR, len) >= len ||\n-\t    strlcat(line, tty, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"TTY=%s ; \", tty);\n     }\n     if (evlog->runchroot != NULL) {\n-\tif (strlcat(line, LL_CHROOT_STR, len) >= len ||\n-\t    strlcat(line, evlog->runchroot, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"CHROOT=%s ; \",\n+\t    evlog->runchroot);\n     }\n     if (evlog->runcwd != NULL) {\n-\tif (strlcat(line, LL_CWD_STR, len) >= len ||\n-\t    strlcat(line, evlog->runcwd, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"PWD=%s ; \",\n+\t    evlog->runcwd);\n     }\n     if (evlog->runuser != NULL) {\n-\tif (strlcat(line, LL_USER_STR, len) >= len ||\n-\t    strlcat(line, evlog->runuser, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"USER=%s ; \",\n+\t    evlog->runuser);\n     }\n     if (evlog->rungroup != NULL) {\n-\tif (strlcat(line, LL_GROUP_STR, len) >= len ||\n-\t    strlcat(line, evlog->rungroup, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"GROUP=%s ; \",\n+\t    evlog->rungroup);\n     }\n     if (tsid != NULL) {\n-\tif (strlcat(line, LL_TSID_STR, len) >= len ||\n-\t    strlcat(line, tsid, len) >= len ||\n-\t    strlcat(line, offsetstr, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n-    }\n-    if (evstr != NULL) {\n-\tif (strlcat(line, LL_ENV_STR, len) >= len ||\n-\t    strlcat(line, evstr, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n-\tfree(evstr);\n-\tevstr = NULL;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"TSID=%s%s ; \", tsid,\n+\t    offsetstr);\n+    }\n+    if (evlog->env_add != NULL && evlog->env_add[0] != NULL) {\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"ENV=%s\",\n+\t    evlog->env_add[0]);\n+\tfor (i = 1; evlog->env_add[i] != NULL; i++) {\n+\t    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \" %s\",\n+\t\tevlog->env_add[i]);\n+\t}\n     }\n     if (evlog->command != NULL) {\n-\tif (strlcat(line, LL_CMND_STR, len) >= len)\n-\t    goto toobig;\n-\tif (strlcat(line, evlog->command, len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL|LBUF_ESC_BLANK,\n+\t    \"COMMAND=%s\", evlog->command);\n \tif (evlog->argv != NULL && evlog->argv[0] != NULL) {\n \t    for (i = 1; evlog->argv[i] != NULL; i++) {\n-\t\tif (strlcat(line, \" \", len) >= len ||\n-\t\t    strlcat(line, evlog->argv[i], len) >= len)\n-\t\t    goto toobig;\n+\t\tsudo_lbuf_append(&lbuf, \" \");\n+\t\tif (strchr(evlog->argv[i], ' ') != NULL) {\n+\t\t    /* Wrap args containing spaces in single quotes. */\n+\t\t    sudo_lbuf_append(&lbuf, \"'\");\n+\t\t    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n+\t\t    sudo_lbuf_append(&lbuf, \"'\");\n+\t\t} else {\n+\t\t    /* Escape quotes here too for consistency. */\n+\t\t    sudo_lbuf_append_esc(&lbuf,\n+\t\t\tLBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n+\t\t}\n \t    }\n \t}\n \tif (event_type == EVLOG_EXIT) {\n \t    if (evlog->signal_name != NULL) {\n-\t\tif (strlcat(line, \" ; \", len) >= len ||\n-\t\t    strlcat(line, LL_SIGNAL_STR, len) >= len ||\n-\t\t    strlcat(line, evlog->signal_name, len) >= len)\n-\t\t    goto toobig;\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \" ; SIGNAL=%s\",\n+\t\t    evlog->signal_name);\n \t    }\n \t    if (evlog->exit_value != -1) {\n-\t\tif (strlcat(line, \" ; \", len) >= len ||\n-\t\t    strlcat(line, LL_EXIT_STR, len) >= len ||\n-\t\t    strlcat(line, exit_str, len) >= len)\n-\t\t    goto toobig;\n+\t\t(void)snprintf(exit_str, sizeof(exit_str), \"%d\",\n+\t\t    evlog->exit_value);\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \" ; EXIT=%s\",\n+\t\t    exit_str);\n \t    }\n \t}\n     }\n-\n-    debug_return_str(line);\n+    if (!sudo_lbuf_error(&lbuf))\n+\tdebug_return_str(lbuf.buf);\n oom:\n-    free(evstr);\n+    sudo_lbuf_destroy(&lbuf);\n     sudo_warnx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n     debug_return_str(NULL);\n-toobig:\n-    free(evstr);\n-    free(line);\n-    sudo_warnx(U_(\"internal error, %s overflow\"), __func__);\n-    debug_return_str(NULL);\n }\n \n static void"
        },
        {
          "filename": "lib/iolog/iolog_json.c",
          "status": "modified",
          "additions": 0,
          "deletions": 39,
          "patch": "@@ -551,45 +551,6 @@ iolog_parse_json_object(struct json_object *object, struct eventlog *evlog)\n \t}\n     }\n \n-    /* Merge cmd and argv as sudoreplay expects. */\n-    if (evlog->command != NULL && evlog->argv != NULL && evlog->argv[0] != NULL) {\n-\tsize_t len, bufsize = strlen(evlog->command) + 1;\n-\tchar *cp, *buf;\n-\tint ac;\n-\n-\t/* Skip argv[0], we use evlog->command instead. */\n-\tfor (ac = 1; evlog->argv[ac] != NULL; ac++)\n-\t    bufsize += strlen(evlog->argv[ac]) + 1;\n-\n-\tif ((buf = malloc(bufsize)) == NULL) {\n-\t    sudo_warnx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n-\t    goto done;\n-\t}\n-\tcp = buf;\n-\n-\tlen = strlcpy(cp, evlog->command, bufsize);\n-\tif (len >= bufsize)\n-\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n-\tcp += len;\n-\tbufsize -= len;\n-\n-\tfor (ac = 1; evlog->argv[ac] != NULL; ac++) {\n-\t    if (bufsize < 2)\n-\t\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n-\t    *cp++ = ' ';\n-\t    bufsize--;\n-\n-\t    len = strlcpy(cp, evlog->argv[ac], bufsize);\n-\t    if (len >= bufsize)\n-\t\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n-\t    cp += len;\n-\t    bufsize -= len;\n-\t}\n-\n-\tfree(evlog->command);\n-\tevlog->command = buf;\n-    }\n-\n     ret = true;\n \n done:"
        },
        {
          "filename": "lib/util/lbuf.c",
          "status": "modified",
          "additions": 106,
          "deletions": 0,
          "patch": "@@ -94,6 +94,112 @@ sudo_lbuf_expand(struct sudo_lbuf *lbuf, unsigned int extra)\n     debug_return_bool(true);\n }\n \n+/*\n+ * Escape a character in octal form (#0n) and store it as a string\n+ * in buf, which must have at least 6 bytes available.\n+ * Returns the length of buf, not counting the terminating NUL byte.\n+ */\n+static int\n+escape(unsigned char ch, char *buf)\n+{\n+    const int len = ch < 0100 ? (ch < 010 ? 3 : 4) : 5;\n+\n+    /* Work backwards from the least significant digit to most significant. */\n+    switch (len) {\n+    case 5:\n+\tbuf[4] = (ch & 7) + '0';\n+\tch >>= 3;\n+\tFALLTHROUGH;\n+    case 4:\n+\tbuf[3] = (ch & 7) + '0';\n+\tch >>= 3;\n+\tFALLTHROUGH;\n+    case 3:\n+\tbuf[2] = (ch & 7) + '0';\n+\tbuf[1] = '0';\n+\tbuf[0] = '#';\n+\tbreak;\n+    }\n+    buf[len] = '\\0';\n+\n+    return len;\n+}\n+\n+/*\n+ * Parse the format and append strings, only %s and %% escapes are supported.\n+ * Any non-printable characters are escaped in octal as #0nn.\n+ */\n+bool\n+sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const char *fmt, ...)\n+{\n+    unsigned int saved_len = lbuf->len;\n+    bool ret = false;\n+    const char *s;\n+    va_list ap;\n+    debug_decl(sudo_lbuf_append_esc, SUDO_DEBUG_UTIL);\n+\n+    if (sudo_lbuf_error(lbuf))\n+\tdebug_return_bool(false);\n+\n+#define should_escape(ch) \\\n+    ((ISSET(flags, LBUF_ESC_CNTRL) && iscntrl((unsigned char)ch)) || \\\n+    (ISSET(flags, LBUF_ESC_BLANK) && isblank((unsigned char)ch)))\n+#define should_quote(ch) \\\n+    (ISSET(flags, LBUF_ESC_QUOTE) && (ch == '\\'' || ch == '\\\\'))\n+\n+    va_start(ap, fmt);\n+    while (*fmt != '\\0') {\n+\tif (fmt[0] == '%' && fmt[1] == 's') {\n+\t    if ((s = va_arg(ap, char *)) == NULL)\n+\t\ts = \"(NULL)\";\n+\t    while (*s != '\\0') {\n+\t\tif (should_escape(*s)) {\n+\t\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n+\t\t\tgoto done;\n+\t\t    lbuf->len += escape(*s++, lbuf->buf + lbuf->len);\n+\t\t    continue;\n+\t\t}\n+\t\tif (should_quote(*s)) {\n+\t\t    if (!sudo_lbuf_expand(lbuf, 2))\n+\t\t\tgoto done;\n+\t\t    lbuf->buf[lbuf->len++] = '\\\\';\n+\t\t    lbuf->buf[lbuf->len++] = *s++;\n+\t\t    continue;\n+\t\t}\n+\t\tif (!sudo_lbuf_expand(lbuf, 1))\n+\t\t    goto done;\n+\t\tlbuf->buf[lbuf->len++] = *s++;\n+\t    }\n+\t    fmt += 2;\n+\t    continue;\n+\t}\n+\tif (should_escape(*fmt)) {\n+\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n+\t\tgoto done;\n+\t    if (*fmt == '\\'') {\n+\t\tlbuf->buf[lbuf->len++] = '\\\\';\n+\t\tlbuf->buf[lbuf->len++] = *fmt++;\n+\t    } else {\n+\t\tlbuf->len += escape(*fmt++, lbuf->buf + lbuf->len);\n+\t    }\n+\t    continue;\n+\t}\n+\tif (!sudo_lbuf_expand(lbuf, 1))\n+\t    goto done;\n+\tlbuf->buf[lbuf->len++] = *fmt++;\n+    }\n+    ret = true;\n+\n+done:\n+    if (!ret)\n+\tlbuf->len = saved_len;\n+    if (lbuf->size != 0)\n+\tlbuf->buf[lbuf->len] = '\\0';\n+    va_end(ap);\n+\n+    debug_return_bool(ret);\n+}\n+\n /*\n  * Parse the format and append strings, only %s and %% escapes are supported.\n  * Any characters in set are quoted with a backslash."
        },
        {
          "filename": "lib/util/util.exp.in",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -100,6 +100,7 @@ sudo_json_init_v1\n sudo_json_init_v2\n sudo_json_open_array_v1\n sudo_json_open_object_v1\n+sudo_lbuf_append_esc_v1\n sudo_lbuf_append_quoted_v1\n sudo_lbuf_append_v1\n sudo_lbuf_clearerr_v1"
        },
        {
          "filename": "plugins/sudoers/sudoreplay.c",
          "status": "modified",
          "additions": 125,
          "deletions": 19,
          "patch": "@@ -62,6 +62,7 @@\n #include \"sudo_debug.h\"\n #include \"sudo_event.h\"\n #include \"sudo_eventlog.h\"\n+#include \"sudo_lbuf.h\"\n #include \"sudo_fatal.h\"\n #include \"sudo_gettext.h\"\n #include \"sudo_iolog.h\"\n@@ -373,6 +374,10 @@ main(int argc, char *argv[])\n     if ((evlog = iolog_parse_loginfo(iolog_dir_fd, iolog_dir)) == NULL)\n \tgoto done;\n     printf(_(\"Replaying sudo session: %s\"), evlog->command);\n+    if (evlog->argv != NULL && evlog->argv[0] != NULL) {\n+\tfor (i = 1; evlog->argv[i] != NULL; i++)\n+\t    printf(\" %s\", evlog->argv[i]);\n+    }\n \n     /* Setup terminal if appropriate. */\n     if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO))\n@@ -1315,11 +1320,57 @@ parse_expr(struct search_node_list *head, char *argv[], bool sub_expr)\n     debug_return_int(av - argv);\n }\n \n+static char *\n+expand_command(struct eventlog *evlog, char **newbuf)\n+{\n+    size_t len, bufsize = strlen(evlog->command) + 1;\n+    char *cp, *buf;\n+    int ac;\n+    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n+\n+    if (evlog->argv == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n+\t/* No arguments, we can use the command as-is. */\n+\t*newbuf = NULL;\n+\tdebug_return_str(evlog->command);\n+    }\n+\n+    /* Skip argv[0], we use evlog->command instead. */\n+    for (ac = 1; evlog->argv[ac] != NULL; ac++)\n+\tbufsize += strlen(evlog->argv[ac]) + 1;\n+\n+    if ((buf = malloc(bufsize)) == NULL)\n+\tsudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n+    cp = buf;\n+\n+    len = strlcpy(cp, evlog->command, bufsize);\n+    if (len >= bufsize)\n+\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n+    cp += len;\n+    bufsize -= len;\n+\n+    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n+\tif (bufsize < 2)\n+\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n+\t*cp++ = ' ';\n+\tbufsize--;\n+\n+\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n+\tif (len >= bufsize)\n+\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n+\tcp += len;\n+\tbufsize -= len;\n+    }\n+\n+    *newbuf = buf;\n+    debug_return_str(buf);\n+}\n+\n static bool\n match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_match)\n {\n     struct search_node *sn;\n     bool res = false, matched = last_match;\n+    char *tofree;\n     int rc;\n     debug_decl(match_expr, SUDO_DEBUG_UTIL);\n \n@@ -1353,13 +1404,15 @@ match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_matc\n \t\tres = strcmp(sn->u.user, evlog->submituser) == 0;\n \t    break;\n \tcase ST_PATTERN:\n-\t    rc = regexec(&sn->u.cmdre, evlog->command, 0, NULL, 0);\n+\t    rc = regexec(&sn->u.cmdre, expand_command(evlog, &tofree),\n+\t\t0, NULL, 0);\n \t    if (rc && rc != REG_NOMATCH) {\n \t\tchar buf[BUFSIZ];\n \t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n \t\tsudo_fatalx(\"%s\", buf);\n \t    }\n \t    res = rc == REG_NOMATCH ? 0 : 1;\n+\t    free(tofree);\n \t    break;\n \tcase ST_FROMDATE:\n \t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, >=);\n@@ -1380,12 +1433,13 @@ match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_matc\n }\n \n static int\n-list_session(char *log_dir, regex_t *re, const char *user, const char *tty)\n+list_session(struct sudo_lbuf *lbuf, char *log_dir, regex_t *re,\n+    const char *user, const char *tty)\n {\n     char idbuf[7], *idstr, *cp;\n     struct eventlog *evlog = NULL;\n     const char *timestr;\n-    int ret = -1;\n+    int i, ret = -1;\n     debug_decl(list_session, SUDO_DEBUG_UTIL);\n \n     if ((evlog = iolog_parse_loginfo(-1, log_dir)) == NULL)\n@@ -1417,23 +1471,71 @@ list_session(char *log_dir, regex_t *re, const char *user, const char *tty)\n     }\n     /* XXX - print lines + cols? */\n     timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n-    printf(\"%s : %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n-    if (evlog->submithost != NULL)\n-\tprintf(\"HOST=%s ; \", evlog->submithost);\n-    if (evlog->ttyname != NULL)\n-\tprintf(\"TTY=%s ; \", evlog->ttyname);\n-    if (evlog->runchroot != NULL)\n-\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n-    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n-\tprintf(\"CWD=%s ; \", evlog->runcwd ? evlog->runcwd : evlog->cwd);\n-    printf(\"USER=%s ; \", evlog->runuser);\n-    if (evlog->rungroup != NULL)\n-\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n-    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n-\n-    ret = 0;\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"%s : %s : \",\n+\ttimestr ? timestr : \"invalid date\", evlog->submituser);\n+    if (evlog->submithost != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"HOST=%s ; \",\n+\t    evlog->submithost);\n+    }\n+    if (evlog->ttyname != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"TTY=%s ; \",\n+\t    evlog->ttyname);\n+    }\n+    if (evlog->runchroot != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"CHROOT=%s ; \",\n+\t    evlog->runchroot);\n+    }\n+    if (evlog->runcwd != NULL || evlog->cwd != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"CWD=%s ; \",\n+\t    evlog->runcwd ? evlog->runcwd : evlog->cwd);\n+    }\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"USER=%s ; \", evlog->runuser);\n+    if (evlog->rungroup != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"GROUP=%s ; \",\n+\t    evlog->rungroup);\n+    }\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"TSID=%s ; \", idstr);\n+\n+    /* \n+     * If we have both command and argv from info.json we can escape\n+     * blanks in the the command and arguments.  If all we have is a\n+     * single string containing both the command and arguments we cannot.\n+     */\n+    if (evlog->argv != NULL) {\n+\t/* Command plus argv from the info.json file. */\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL|LBUF_ESC_BLANK,\n+\t    \"COMMAND=%s\", evlog->command);\n+\tif (evlog->argv[0] != NULL) {\n+\t    for (i = 1; evlog->argv[i] != NULL; i++) {\n+\t\tsudo_lbuf_append(lbuf, \" \");\n+\t\tif (strchr(evlog->argv[i], ' ') != NULL) {\n+\t\t    /* Wrap args containing spaces in single quotes. */\n+\t\t    sudo_lbuf_append(lbuf, \"'\");\n+\t\t    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n+\t\t    sudo_lbuf_append(lbuf, \"'\");\n+\t\t} else {\n+\t\t    /* Escape quotes here too for consistency. */\n+\t\t    sudo_lbuf_append_esc(lbuf,\n+\t\t\tLBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n+\t\t}\n+\t    }\n+\t}\n+    } else {\n+\t/* Single string from the legacy info file. */\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"COMMAND=%s\",\n+\t    evlog->command);\n+    }\n+\n+    if (!sudo_lbuf_error(lbuf)) {\n+\tputs(lbuf->buf);\n+\tret = 0;\n+    }\n \n done:\n+    lbuf->error = 0;\n+    lbuf->len = 0;\n     eventlog_free(evlog);\n     debug_return_int(ret);\n }\n@@ -1453,6 +1555,7 @@ find_sessions(const char *dir, regex_t *re, const char *user, const char *tty)\n     DIR *d;\n     struct dirent *dp;\n     struct stat sb;\n+    struct sudo_lbuf lbuf;\n     size_t sdlen, sessions_len = 0, sessions_size = 0;\n     unsigned int i;\n     int len;\n@@ -1464,6 +1567,8 @@ find_sessions(const char *dir, regex_t *re, const char *user, const char *tty)\n #endif\n     debug_decl(find_sessions, SUDO_DEBUG_UTIL);\n \n+    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);\n+\n     d = opendir(dir);\n     if (d == NULL)\n \tsudo_fatal(U_(\"unable to open %s\"), dir);\n@@ -1524,7 +1629,7 @@ find_sessions(const char *dir, regex_t *re, const char *user, const char *tty)\n \t    /* Check for dir with a log file. */\n \t    if (lstat(pathbuf, &sb) == 0 && S_ISREG(sb.st_mode)) {\n \t\tpathbuf[sdlen + len - 4] = '\\0';\n-\t\tlist_session(pathbuf, re, user, tty);\n+\t\tlist_session(&lbuf, pathbuf, re, user, tty);\n \t    } else {\n \t\t/* Strip off \"/log\" and recurse if a non-log dir. */\n \t\tpathbuf[sdlen + len - 4] = '\\0';\n@@ -1535,6 +1640,7 @@ find_sessions(const char *dir, regex_t *re, const char *user, const char *tty)\n \t}\n \tfree(sessions);\n     }\n+    sudo_lbuf_destroy(&lbuf);\n \n     debug_return_int(0);\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "01b1410d615e3b83851290a9134fcd409003abd0",
            "date": "2025-01-05T21:11:18Z",
            "author_login": "millert"
          },
          {
            "sha": "7c121ff8340c6fa551ba4997dde9d450cf74e40c",
            "date": "2024-12-23T03:31:29Z",
            "author_login": "ivy864"
          },
          {
            "sha": "103af8cb27aa6e61899caca7a20879c58b15f3a4",
            "date": "2025-01-04T16:47:15Z",
            "author_login": "millert"
          },
          {
            "sha": "46831d6ef2c9853a4eaa540d5ee8088a605ac8e0",
            "date": "2025-01-04T15:20:59Z",
            "author_login": "millert"
          },
          {
            "sha": "b52ef1fbbb90df16da3676aeb8f3df90f291fcd8",
            "date": "2025-01-04T14:45:07Z",
            "author_login": "millert"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-116",
    "description": "Sudo before 1.9.13 does not escape control characters in sudoreplay output.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-03-16T01:15:47.067",
    "last_modified": "2024-11-21T07:55:12.590",
    "fix_date": "2023-01-18T15:21:34Z"
  },
  "references": [
    {
      "url": "https://github.com/sudo-project/sudo/commit/334daf92b31b79ce68ed75e2ee14fca265f029ca",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_13",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/02/msg00002.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202309-12",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230420-0002/",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/sudo-project/sudo/commit/334daf92b31b79ce68ed75e2ee14fca265f029ca",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_13",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/02/msg00002.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.gentoo.org/glsa/202309-12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230420-0002/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:06.848688",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sudo",
    "owner": "sudo-project",
    "created_at": "2016-05-03T13:41:24Z",
    "updated_at": "2025-01-14T12:51:41Z",
    "pushed_at": "2025-01-11T21:38:41Z",
    "size": 215573,
    "stars": 1218,
    "forks": 226,
    "open_issues": 27,
    "watchers": 1218,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "C": 5677215,
      "Shell": 678768,
      "Makefile": 615304,
      "Roff": 420421,
      "M4": 243119,
      "Yacc": 75763,
      "Perl": 53461,
      "Lex": 38443,
      "Pascal": 28666,
      "Python": 27031,
      "C++": 7720,
      "Puppet": 5732,
      "Dockerfile": 3343
    },
    "commit_activity": {
      "total_commits_last_year": 140,
      "avg_commits_per_week": 2.6923076923076925,
      "days_active_last_year": 80
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:06:44.047272"
  }
}