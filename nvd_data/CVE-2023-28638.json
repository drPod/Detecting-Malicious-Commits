{
  "cve_id": "CVE-2023-28638",
  "github_data": {
    "repository": "brantburnett/Snappier",
    "fix_commit": "d7ac5267b5b18439e6d108f8138edf48c436b32f",
    "related_commits": [
      "d7ac5267b5b18439e6d108f8138edf48c436b32f",
      "d7ac5267b5b18439e6d108f8138edf48c436b32f"
    ],
    "patch_url": "https://github.com/brantburnett/Snappier/commit/d7ac5267b5b18439e6d108f8138edf48c436b32f.patch",
    "fix_commit_details": {
      "sha": "d7ac5267b5b18439e6d108f8138edf48c436b32f",
      "commit_date": "2023-03-26T22:20:20Z",
      "author": {
        "login": "brantburnett",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Allow ref byte to point just past the end of spans (#73)",
        "length": 1005,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 101,
        "additions": 45,
        "deletions": 56
      },
      "files": [
        {
          "filename": "Snappier.Benchmarks/FindMatchLength.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -64,7 +64,7 @@ public void GlobalSetup()\n \n             ref byte s1 = ref _array[0];\n             ref byte s2 = ref Unsafe.Add(ref s1, 12);\n-            ref byte s2Limit = ref Unsafe.Add(ref s1, _array.Length - 1);\n+            ref byte s2Limit = ref Unsafe.Add(ref s1, _array.Length);\n \n             return SnappyCompressor.FindMatchLength(ref s1, ref s2, ref s2Limit, ref data);\n         }"
        },
        {
          "filename": "Snappier.Tests/Internal/SnappyCompressorTests.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -92,7 +92,7 @@ public void FindMatchLength(int expectedResult, string s1String, string s2String\n             ref byte s2 = ref Unsafe.Add(ref s1, s1String.Length);\n \n             var result =\n-                SnappyCompressor.FindMatchLength(ref s1, ref s2, ref Unsafe.Add(ref s2, length - 1), ref data);\n+                SnappyCompressor.FindMatchLength(ref s1, ref s2, ref Unsafe.Add(ref s2, length), ref data);\n \n             Assert.Equal(result.matchLength < 8, result.matchLengthLessThan8);\n             Assert.Equal(expectedResult, result.matchLength);"
        },
        {
          "filename": "Snappier/Internal/SnappyCompressor.cs",
          "status": "modified",
          "additions": 17,
          "deletions": 23,
          "patch": "@@ -125,16 +125,15 @@ private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output,\n                 uint mask = (uint)(2 * (tableSpan.Length - 1));\n \n                 ref byte inputStart = ref Unsafe.AsRef(in input[0]);\n-                // Last byte of the input, not one byte past the end, to avoid issues on GC moves\n-                ref byte inputEnd = ref Unsafe.Add(ref inputStart, input.Length - 1);\n+                ref byte inputEnd = ref Unsafe.Add(ref inputStart, input.Length);\n                 ref byte ip = ref inputStart;\n \n                 ref byte op = ref output[0];\n                 ref ushort table = ref tableSpan[0];\n \n                 if (input.Length >= Constants.InputMarginBytes)\n                 {\n-                    ref byte ipLimit = ref Unsafe.Subtract(ref inputEnd, Constants.InputMarginBytes - 1);\n+                    ref byte ipLimit = ref Unsafe.Subtract(ref inputEnd, Constants.InputMarginBytes);\n \n                     for (uint preload = Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref ip, 1));;)\n                     {\n@@ -288,7 +287,7 @@ private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output,\n                         // Step 2: A 4-byte match has been found.  We'll later see if more\n                         // than 4 bytes match.  But, prior to the match, input\n                         // bytes [next_emit, ip) are unmatched.  Emit them as \"literal bytes.\"\n-                        Debug.Assert(!Unsafe.IsAddressGreaterThan(ref Unsafe.Add(ref nextEmit, 16), ref Unsafe.Add(ref inputEnd, 1)));\n+                        Debug.Assert(!Unsafe.IsAddressGreaterThan(ref Unsafe.Add(ref nextEmit, 16), ref inputEnd));\n                         op = ref EmitLiteralFast(ref op, ref nextEmit, (uint) Unsafe.ByteOffset(ref nextEmit, ref ip));\n \n                         // Step 3: Call EmitCopy, and then see if another EmitCopy could\n@@ -350,9 +349,9 @@ private static int CompressFragment(ReadOnlySpan<byte> input, Span<byte> output,\n \n                 emit_remainder:\n                 // Emit the remaining bytes as a literal\n-                if (!Unsafe.IsAddressGreaterThan(ref ip, ref inputEnd))\n+                if (Unsafe.IsAddressLessThan(ref ip, ref inputEnd))\n                 {\n-                    op = ref EmitLiteralSlow(ref op, ref ip, (uint) Unsafe.ByteOffset(ref ip, ref inputEnd) + 1);\n+                    op = ref EmitLiteralSlow(ref op, ref ip, (uint) Unsafe.ByteOffset(ref ip, ref inputEnd));\n                 }\n \n                 return (int) Unsafe.ByteOffset(ref output[0], ref op);\n@@ -490,28 +489,23 @@ private static ref byte EmitCopyLenGreaterThanOrEqualTo12(ref byte op, long offs\n         /// Find the largest n such that\n         ///\n         ///   s1[0,n-1] == s2[0,n-1]\n-        ///   and n &lt;= (s2_limit - s2 + 1).\n+        ///   and n &lt;= (s2_limit - s2).\n         ///\n         /// Return (n, n &lt; 8).\n         /// Reads up to and including *s2_limit but not beyond.\n-        /// Does not read *(s1 + (s2_limit - s2 + 1)) or beyond.\n-        /// Requires that s2_limit+1 &gt;= s2.\n+        /// Does not read *(s1 + (s2_limit - s2)) or beyond.\n+        /// Requires that s2_limit &gt;= s2.\n         ///\n         /// In addition populate *data with the next 5 bytes from the end of the match.\n         /// This is only done if 8 bytes are available (s2_limit - s2 &gt;= 8). The point is\n         /// that on some arch's this can be done faster in this routine than subsequent\n         /// loading from s2 + n.\n         /// </summary>\n-        /// <remarks>\n-        /// The reference implementation has s2Limit as one byte past the end of the input,\n-        /// but this implementation has it at the end of the input. This ensures that it always\n-        /// points within the array in case GC moves the array.\n-        /// </remarks>\n         [MethodImpl(MethodImplOptions.AggressiveInlining)]\n         internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength(\n             ref byte s1, ref byte s2, ref byte s2Limit, ref ulong data)\n         {\n-            Debug.Assert(!Unsafe.IsAddressLessThan(ref Unsafe.Add(ref s2Limit, 1), ref s2));\n+            Debug.Assert(!Unsafe.IsAddressLessThan(ref s2Limit, ref s2));\n \n             if (BitConverter.IsLittleEndian && IntPtr.Size == 8)\n             {\n@@ -521,14 +515,14 @@ internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength(\n \n             int matched = 0;\n \n-            while (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 3))\n+            while (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)4\n                    && Helpers.UnsafeReadUInt32(ref s2) == Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched)))\n             {\n                 s2 = ref Unsafe.Add(ref s2, 4);\n                 matched += 4;\n             }\n \n-            if (BitConverter.IsLittleEndian && !Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 3)))\n+            if (BitConverter.IsLittleEndian && Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)4)\n             {\n                 uint x = Helpers.UnsafeReadUInt32(ref s2) ^ Helpers.UnsafeReadUInt32(ref Unsafe.Add(ref s1, matched));\n                 int matchingBits = Helpers.FindLsbSetNonZero(x);\n@@ -537,14 +531,14 @@ internal static (int matchLength, bool matchLengthLessThan8) FindMatchLength(\n             }\n             else\n             {\n-                while (!Unsafe.IsAddressGreaterThan(ref s2, ref s2Limit) && Unsafe.Add(ref s1, matched) == s2)\n+                while (Unsafe.IsAddressLessThan(ref s2, ref s2Limit) && Unsafe.Add(ref s1, matched) == s2)\n                 {\n                     s2 = ref Unsafe.Add(ref s2, 1);\n                     ++matched;\n                 }\n             }\n \n-            if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 7)))\n+            if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)8)\n             {\n                 data = Helpers.UnsafeReadUInt64(ref s2);\n             }\n@@ -562,7 +556,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64(\n             // immediately.  As an optimization though, it is useful.  It creates some not\n             // uncommon code paths that determine, without extra effort, whether the match\n             // length is less than 8.\n-            if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 15)))\n+            if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)16)\n             {\n                 ulong a1 = Helpers.UnsafeReadUInt64(ref s1);\n                 ulong a2 = Helpers.UnsafeReadUInt64(ref s2);\n@@ -590,7 +584,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64(\n             // time until we find a 64-bit block that doesn't match; then we find\n             // the first non-matching bit and use that to calculate the total\n             // length of the match.\n-            while (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 15)))\n+            while (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)16)\n             {\n                 ulong a1 = Helpers.UnsafeReadUInt64(ref Unsafe.Add(ref s1, matched));\n                 ulong a2 = Helpers.UnsafeReadUInt64(ref s2);\n@@ -615,7 +609,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64(\n                 }\n             }\n \n-            while (!Unsafe.IsAddressGreaterThan(ref s2, ref s2Limit))\n+            while (Unsafe.IsAddressLessThan(ref s2, ref s2Limit))\n             {\n                 if (Unsafe.Add(ref s1, matched) == s2)\n                 {\n@@ -624,7 +618,7 @@ private static (int matchLength, bool matchLengthLessThan8) FindMatchLengthX64(\n                 }\n                 else\n                 {\n-                    if (!Unsafe.IsAddressGreaterThan(ref s2, ref Unsafe.Subtract(ref s2Limit, 7)))\n+                    if (Unsafe.ByteOffset(ref s2, ref s2Limit) >= (nint)8)\n                     {\n                         data = Helpers.UnsafeReadUInt64(ref s2);\n                     }"
        },
        {
          "filename": "Snappier/Internal/SnappyDecompressor.cs",
          "status": "modified",
          "additions": 26,
          "deletions": 31,
          "patch": "@@ -186,17 +186,11 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n             unchecked\n             {\n                 ref byte input = ref Unsafe.AsRef(in inputSpan[0]);\n-\n-                // The reference Snappy implementation uses inputEnd as a pointer one byte past the end of the buffer.\n-                // However, this is not safe when using ref locals. The ref must point to somewhere within the array\n-                // so that GC can adjust the ref if the memory is moved.\n-                ref byte inputEnd = ref Unsafe.Add(ref input, inputSpan.Length - 1);\n+                ref byte inputEnd = ref Unsafe.Add(ref input, inputSpan.Length);\n \n                 // Track the point in the input before which input is guaranteed to have at least Constants.MaxTagLength bytes left\n-                ref byte inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, Math.Min(inputSpan.Length, Constants.MaximumTagLength - 1) - 1);\n+                ref byte inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd, Math.Min(inputSpan.Length, Constants.MaximumTagLength - 1));\n \n-                // We always allocate buffer with at least one extra byte on the end, so bufferEnd doesn't have the same\n-                // restrictions as inputEnd.\n                 ref byte buffer = ref _lookbackBuffer.Span[0];\n                 ref byte bufferEnd = ref Unsafe.Add(ref buffer, _lookbackBuffer.Length);\n                 ref byte op = ref Unsafe.Add(ref buffer, _lookbackPosition);\n@@ -239,9 +233,9 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n                     {\n                         // Data has been moved to the scratch buffer\n                         input = ref scratch;\n-                        inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1);\n+                        inputEnd = ref Unsafe.Add(ref input, newScratchLength);\n                         inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n-                            Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1);\n+                            Math.Min(newScratchLength, Constants.MaximumTagLength - 1));\n                     }\n                 }\n \n@@ -256,7 +250,7 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n                     {\n                         nint literalLength = unchecked((c >> 2) + 1);\n \n-                        if (TryFastAppend(ref op, ref bufferEnd, in input, Unsafe.ByteOffset(ref input, ref inputEnd) + 1, literalLength))\n+                        if (TryFastAppend(ref op, ref bufferEnd, in input, Unsafe.ByteOffset(ref input, ref inputEnd), literalLength))\n                         {\n                             Debug.Assert(literalLength < 61);\n                             op = ref Unsafe.Add(ref op, literalLength);\n@@ -280,7 +274,7 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n                             input = ref Unsafe.Add(ref input, literalLengthLength);\n                         }\n \n-                        nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd) + 1;\n+                        nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd);\n                         if (inputRemaining < literalLength)\n                         {\n                             Append(ref op, ref bufferEnd, in input, inputRemaining);\n@@ -306,9 +300,9 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n                                 {\n                                     // Data has been moved to the scratch buffer\n                                     input = ref scratch;\n-                                    inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1);\n+                                    inputEnd = ref Unsafe.Add(ref input, newScratchLength);\n                                     inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n-                                        Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1);\n+                                        Math.Min(newScratchLength, Constants.MaximumTagLength - 1));\n \n                                 }\n                             }\n@@ -367,9 +361,9 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n                             {\n                                 // Data has been moved to the scratch buffer\n                                 input = ref scratch;\n-                                inputEnd = ref Unsafe.Add(ref input, newScratchLength - 1);\n+                                inputEnd = ref Unsafe.Add(ref input, newScratchLength);\n                                 inputLimitMinMaxTagLength = ref Unsafe.Subtract(ref inputEnd,\n-                                    Math.Min(newScratchLength, Constants.MaximumTagLength - 1) - 1);\n+                                    Math.Min(newScratchLength, Constants.MaximumTagLength - 1));\n                             }\n                         }\n \n@@ -415,7 +409,7 @@ internal void DecompressAllTags(ReadOnlySpan<byte> inputSpan)\n                         (int) literalLengthLength) + 1;\n                 }\n \n-                nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd) + 1;\n+                nint inputRemaining = Unsafe.ByteOffset(ref input, ref inputEnd);\n                 if (inputRemaining < literalLength)\n                 {\n                     Append(ref op, ref bufferEnd, in input, inputRemaining);\n@@ -468,7 +462,7 @@ private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte sc\n         {\n             Debug.Assert(_scratchLength > 0);\n \n-            if (Unsafe.IsAddressGreaterThan(ref input, ref inputEnd))\n+            if (!Unsafe.IsAddressLessThan(ref input, ref inputEnd))\n             {\n                 return 0;\n             }\n@@ -477,7 +471,7 @@ private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte sc\n             uint entry = Constants.CharTable[scratch];\n             uint needed = (entry >> 11) + 1; // +1 byte for 'c'\n \n-            uint toCopy = Math.Min((uint)Unsafe.ByteOffset(ref input, ref inputEnd) + 1, needed - _scratchLength);\n+            uint toCopy = Math.Min((uint)Unsafe.ByteOffset(ref input, ref inputEnd), needed - _scratchLength);\n             Unsafe.CopyBlockUnaligned(ref Unsafe.Add(ref scratch, _scratchLength), ref input, toCopy);\n \n             _scratchLength += toCopy;\n@@ -502,7 +496,7 @@ private uint RefillTagFromScratch(ref byte input, ref byte inputEnd, ref byte sc\n         // always have some extra bytes on the end so we don't risk buffer overruns.\n         private uint RefillTag(ref byte input, ref byte inputEnd, ref byte scratch)\n         {\n-            if (Unsafe.IsAddressGreaterThan(ref input, ref inputEnd))\n+            if (!Unsafe.IsAddressLessThan(ref input, ref inputEnd))\n             {\n                 return uint.MaxValue;\n             }\n@@ -511,7 +505,7 @@ private uint RefillTag(ref byte input, ref byte inputEnd, ref byte scratch)\n             uint entry = Constants.CharTable[input];\n             uint needed = (entry >> 11) + 1; // +1 byte for 'c'\n \n-            uint inputLength = (uint)Unsafe.ByteOffset(ref input, ref inputEnd) + 1;\n+            uint inputLength = (uint)Unsafe.ByteOffset(ref input, ref inputEnd);\n             if (inputLength < needed)\n             {\n                 // Data is insufficient, copy to scratch\n@@ -555,11 +549,8 @@ private int? ExpectedLength\n                         ArrayPool<byte>.Shared.Return(_lookbackBufferArray);\n                     }\n \n-                    // Always pad the lookback buffer with an extra byte that we don't use. This allows a \"ref byte\" reference past\n-                    // the end of the perceived buffer that still points within the array. This is a requirement so that GC can recognize\n-                    // the \"ref byte\" points within the array and adjust it if the array is moved.\n-                    _lookbackBufferArray = ArrayPool<byte>.Shared.Rent(value.GetValueOrDefault() + 1);\n-                    _lookbackBuffer = _lookbackBufferArray.AsMemory(0, _lookbackBufferArray.Length - 1);\n+                    _lookbackBufferArray = ArrayPool<byte>.Shared.Rent(value.GetValueOrDefault());\n+                    _lookbackBuffer = _lookbackBufferArray.AsMemory(0, _lookbackBufferArray.Length);\n                 }\n             }\n         }\n@@ -595,7 +586,7 @@ private void Append(ReadOnlySpan<byte> input)\n         }\n \n         [MethodImpl(MethodImplOptions.AggressiveInlining)]\n-        private void Append(ref byte op, ref byte bufferEnd, in byte input, nint length)\n+        private static void Append(ref byte op, ref byte bufferEnd, in byte input, nint length)\n         {\n             if (length > Unsafe.ByteOffset(ref op, ref bufferEnd))\n             {\n@@ -606,7 +597,7 @@ private void Append(ref byte op, ref byte bufferEnd, in byte input, nint length)\n         }\n \n         [MethodImpl(MethodImplOptions.AggressiveInlining)]\n-        private bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint available, nint length)\n+        private static bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint available, nint length)\n         {\n             if (length <= 16 && available >= 16 + Constants.MaximumTagLength &&\n                 Unsafe.ByteOffset(ref op, ref bufferEnd) >= (nint) 16)\n@@ -619,10 +610,13 @@ private bool TryFastAppend(ref byte op, ref byte bufferEnd, in byte input, nint\n         }\n \n         [MethodImpl(MethodImplOptions.AggressiveInlining)]\n-        private void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, uint copyOffset, nint length)\n+        private static void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, uint copyOffset, nint length)\n         {\n-            ref byte source = ref Unsafe.Subtract(ref op, copyOffset);\n-            if (!Unsafe.IsAddressLessThan(ref source, ref op) || Unsafe.IsAddressLessThan(ref source, ref buffer))\n+            // ToInt64() ensures that this logic works correctly on x86 (with a slight perf hit on x86, though). This is because\n+            // nint is only 32-bit on x86, so casting uint copyOffset to an nint for the comparison can result in a negative number with some\n+            // forms of illegal data. This would then bypass the exception and cause unsafe memory access. Performing the comparison\n+            // as a long ensures we have enough bits to not lose data. On 64-bit platforms this is effectively a no-op.\n+            if (copyOffset == 0 || Unsafe.ByteOffset(ref buffer, ref op).ToInt64() < copyOffset)\n             {\n                 ThrowHelper.ThrowInvalidDataException(\"Invalid copy offset\");\n             }\n@@ -632,6 +626,7 @@ private void AppendFromSelf(ref byte op, ref byte buffer, ref byte bufferEnd, ui\n                 ThrowHelper.ThrowInvalidDataException(\"Data too long\");\n             }\n \n+            ref byte source = ref Unsafe.Subtract(ref op, copyOffset);\n             CopyHelpers.IncrementalCopy(ref source, ref op,\n                 ref Unsafe.Add(ref op, length), ref bufferEnd);\n         }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b6b2a97115ad7cc8903f934d69323693975db833",
            "date": "2024-12-23T14:05:03Z",
            "author_login": "brantburnett"
          },
          {
            "sha": "59d842b9fcafe92b41c99779043d855d01ac83db",
            "date": "2024-12-23T12:51:00Z",
            "author_login": "brantburnett"
          },
          {
            "sha": "2486587786947c7100d1453e83b870c933a37c0f",
            "date": "2024-12-23T01:47:00Z",
            "author_login": "brantburnett"
          },
          {
            "sha": "a7de589f60f4d120228ad2b72ec2b8416b8fb9e1",
            "date": "2024-12-23T01:10:04Z",
            "author_login": "brantburnett"
          },
          {
            "sha": "9067cab86b79ff3a4deb5099624851e55253488f",
            "date": "2024-12-22T21:36:42Z",
            "author_login": "brantburnett"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H",
    "cwe_id": "CWE-119",
    "description": "Snappier is a high performance C# implementation of the Snappy compression algorithm. This is a buffer overrun vulnerability that can affect any user of Snappier 1.1.0. In this release, much of the code was rewritten to use byte references rather than pointers to pinned buffers. This change generally improves performance and reduces workload on the garbage collector. However, when the garbage collector performs compaction and rearranges memory, it must update any byte references on the stack to refer to the updated location. The .NET garbage collector can only update these byte references if they still point within the buffer or to a point one byte past the end of the buffer. If they point outside this area, the buffer itself may be moved while the byte reference stays the same. There are several places in 1.1.0 where byte references very briefly point outside the valid areas of buffers. These are at locations in the code being used for buffer range checks. While the invalid references are never dereferenced directly, if a GC compaction were to occur during the brief window when they are on the stack then it could invalidate the buffer range check and allow other operations to overrun the buffer.  This should be very difficult for an attacker to trigger intentionally. It would require a repetitive bulk attack with the hope that a GC compaction would occur at precisely the right moment during one of the requests. However, one of the range checks with this problem is a check based on input data in the decompression buffer, meaning malformed input data could be used to increase the chance of success. Note that any resulting buffer overrun is likely to cause access to protected memory, which will then cause an exception and the process to be terminated. Therefore, the most likely result of an attack is a denial of service. This issue has been patched in release 1.1.1. Users are advised to upgrade. Users unable to upgrade may pin buffers to a fixed location before using them for compression or decompression to mitigate some, but not all, of these cases. At least one temporary decompression buffer is internal to the library and never pinned.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-03-27T21:15:12.603",
    "last_modified": "2024-11-21T07:55:43.073",
    "fix_date": "2023-03-26T22:20:20Z"
  },
  "references": [
    {
      "url": "https://github.com/brantburnett/Snappier/commit/d7ac5267b5b18439e6d108f8138edf48c436b32f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/brantburnett/Snappier/security/advisories/GHSA-838x-pcvx-6p5w",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/brantburnett/Snappier/commit/d7ac5267b5b18439e6d108f8138edf48c436b32f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/brantburnett/Snappier/security/advisories/GHSA-838x-pcvx-6p5w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:09.017114",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Snappier",
    "owner": "brantburnett",
    "created_at": "2020-10-08T20:10:17Z",
    "updated_at": "2024-12-25T18:41:34Z",
    "pushed_at": "2024-12-23T14:13:14Z",
    "size": 1852,
    "stars": 72,
    "forks": 7,
    "open_issues": 0,
    "watchers": 72,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "C#": 255527
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:45:04.442764"
  }
}