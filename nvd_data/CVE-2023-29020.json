{
  "cve_id": "CVE-2023-29020",
  "github_data": {
    "repository": "fastify/fastify-passport",
    "fix_commit": "07c90feab9cba0dd4779e47cfb0717a7e2f01d3d",
    "related_commits": [
      "07c90feab9cba0dd4779e47cfb0717a7e2f01d3d",
      "07c90feab9cba0dd4779e47cfb0717a7e2f01d3d"
    ],
    "patch_url": "https://github.com/fastify/fastify-passport/commit/07c90feab9cba0dd4779e47cfb0717a7e2f01d3d.patch",
    "fix_commit_details": {
      "sha": "07c90feab9cba0dd4779e47cfb0717a7e2f01d3d",
      "commit_date": "2023-04-20T07:47:36Z",
      "author": {
        "login": "RafaelGSS",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2ccf-ffrj-m4qw",
        "length": 208,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 13416,
        "additions": 396,
        "deletions": 13020
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -79,6 +79,11 @@ server.register(fastifyPassport.secureSession())\n fastifyPassport.use('test', new SomePassportStrategy()) // you'd probably use some passport strategy from npm here\n ```\n \n+## Session cleanup on logIn\n+\n+For security reasons the session is cleaned after login. You can manage this configuration at your own risk by using\n+`clearSessionOnLogin (default: true)` and `clearSessionIgnoreFields (default: ['passport', 'session'])`\n+\n ## Difference between `@fastify/secure-session` and `@fastify/session`\n `@fastify/secure-session` and `@fastify/session` are both session plugins for Fastify which are capable of encrypting/decrypting the session. The main difference is that `@fastify/secure-session` uses the stateless approach and stores the whole session in an encrypted cookie whereas `@fastify/session` uses the stateful approach for sessions and stores them in a session store.\n "
        },
        {
          "filename": "package-lock.json",
          "status": "removed",
          "additions": 0,
          "deletions": 12929,
          "patch": null
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -42,8 +42,9 @@\n   },\n   \"devDependencies\": {\n     \"@fastify/cookie\": \"^8.0.0\",\n+    \"@fastify/csrf-protection\": \"^6.2.0\",\n     \"@fastify/secure-session\": \"^6.0.0\",\n-    \"@fastify/session\": \"^10.0.0\",\n+    \"@fastify/session\": \"^10.2.0\",\n     \"@types/jest\": \"^27.0.0\",\n     \"@types/node\": \"^18.0.0\",\n     \"@types/passport\": \"^1.0.5\","
        },
        {
          "filename": "src/Authenticator.ts",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -20,6 +20,8 @@ export type InfoTransformerFunction = (info: any) => Promise<any>\n export interface AuthenticatorOptions {\n   key?: string\n   userProperty?: string\n+  clearSessionOnLogin?: boolean\n+  clearSessionIgnoreFields?: string[]\n }\n \n export class Authenticator {\n@@ -33,13 +35,23 @@ export class Authenticator {\n   private serializers: SerializeFunction<any, any>[] = []\n   private deserializers: DeserializeFunction<any, any>[] = []\n   private infoTransformers: InfoTransformerFunction[] = []\n+  private clearSessionOnLogin: boolean\n+  private clearSessionIgnoreFields: string[]\n \n   constructor(options: AuthenticatorOptions = {}) {\n     this.key = options.key || 'passport'\n     this.userProperty = options.userProperty || 'user'\n-\n     this.use(new SessionStrategy(this.deserializeUser.bind(this)))\n-    this.sessionManager = new SecureSessionManager({ key: this.key }, this.serializeUser.bind(this))\n+    this.clearSessionOnLogin = options.clearSessionOnLogin ?? true\n+    this.clearSessionIgnoreFields = ['passport', 'session', ...(options.clearSessionIgnoreFields || [])]\n+    this.sessionManager = new SecureSessionManager(\n+      {\n+        key: this.key,\n+        clearSessionOnLogin: this.clearSessionOnLogin,\n+        clearSessionIgnoreFields: this.clearSessionIgnoreFields,\n+      },\n+      this.serializeUser.bind(this)\n+    )\n   }\n \n   use(strategy: AnyStrategy): this"
        },
        {
          "filename": "src/session-managers/SecureSessionManager.ts",
          "status": "modified",
          "additions": 32,
          "deletions": 2,
          "patch": "@@ -5,25 +5,55 @@ import { SerializeFunction } from '../Authenticator'\n /** Class for storing passport data in the session using `@fastify/secure-session` or `@fastify/session` */\n export class SecureSessionManager {\n   key: string\n+  clearSessionOnLogin: boolean\n+  clearSessionIgnoreFields: string[] = ['session']\n   serializeUser: SerializeFunction\n \n   constructor(serializeUser: SerializeFunction)\n-  constructor(options: { key?: string }, serializeUser: SerializeFunction)\n-  constructor(options: SerializeFunction | { key?: string }, serializeUser?: SerializeFunction) {\n+  constructor(\n+    options: { key?: string; clearSessionOnLogin?: boolean; clearSessionIgnoreFields?: string[] },\n+    serializeUser: SerializeFunction\n+  )\n+  constructor(\n+    options: SerializeFunction | { key?: string; clearSessionOnLogin?: boolean; clearSessionIgnoreFields?: string[] },\n+    serializeUser?: SerializeFunction\n+  ) {\n     if (typeof options === 'function') {\n       this.serializeUser = options\n       this.key = 'passport'\n+      this.clearSessionOnLogin = true\n     } else if (typeof serializeUser === 'function') {\n       this.serializeUser = serializeUser\n       this.key =\n         (options && typeof options === 'object' && typeof options.key === 'string' && options.key) || 'passport'\n+      this.clearSessionOnLogin = options.clearSessionOnLogin ?? true\n+      this.clearSessionIgnoreFields = [...this.clearSessionIgnoreFields, ...(options.clearSessionIgnoreFields || [])]\n     } else {\n       throw new Error('SecureSessionManager#constructor must have a valid serializeUser-function passed as a parameter')\n     }\n   }\n \n   async logIn(request: FastifyRequest, user: any) {\n     const object = await this.serializeUser(user, request)\n+\n+    if (this.clearSessionOnLogin && object) {\n+      // Handle @fastify/session to prevent token/CSRF fixation\n+      if (request.session.regenerate) {\n+        await request.session.regenerate(this.clearSessionIgnoreFields)\n+      } else {\n+        const currentFields = request.session.data() || {}\n+        // Handle @fastify/secure-session against CSRF fixation\n+        // TODO: This is quite hacky. The best option would be having a regenerate method\n+        // on secure-session as well\n+        for (const field of Object.keys(currentFields)) {\n+          if (this.clearSessionIgnoreFields.includes(field)) {\n+            continue\n+          }\n+          request.session.set(field, undefined)\n+        }\n+      }\n+    }\n+\n     // Handle sessions using @fastify/session\n     if (request.session.regenerate) {\n       // regenerate session to guard against session fixation"
        },
        {
          "filename": "test/csrf-fixation.test.ts",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+/* eslint-disable @typescript-eslint/no-empty-function */\n+import { getConfiguredTestServer, TestBrowserSession } from './helpers'\n+import fastifyCsrfProtection from '@fastify/csrf-protection'\n+\n+function createServer(sessionPluginName: '@fastify/session' | '@fastify/secure-session') {\n+  const { server, fastifyPassport } = getConfiguredTestServer()\n+\n+  void server.register(fastifyCsrfProtection, { sessionPlugin: sessionPluginName })\n+\n+  server.post(\n+    '/login',\n+    { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n+    async () => 'success'\n+  )\n+\n+  server.get('/csrf', async (_req, reply) => {\n+    return reply.generateCsrf()\n+  })\n+  server.get('/session', async (req) => {\n+    return req.session.get('_csrf')\n+  })\n+  return server\n+}\n+\n+const suite = (sessionPluginName: '@fastify/session' | '@fastify/secure-session') => {\n+  process.env.SESSION_PLUGIN = sessionPluginName\n+  const server = createServer(sessionPluginName)\n+  describe(`${sessionPluginName} tests`, () => {\n+    describe('guard against fixation', () => {\n+      let user: TestBrowserSession\n+\n+      beforeEach(() => {\n+        user = new TestBrowserSession(server)\n+      })\n+\n+      test(`should renegerate csrf token on login`, async () => {\n+        {\n+          const sess = await user.inject({ method: 'GET', url: '/session' })\n+          expect(sess.body).toBe('')\n+        }\n+        await user.inject({ method: 'GET', url: '/csrf' })\n+        {\n+          const sess = await user.inject({ method: 'GET', url: '/session' })\n+          expect(sess.body).not.toBe('')\n+        }\n+        await user.inject({\n+          method: 'POST',\n+          url: '/login',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+        {\n+          const sess = await user.inject({ method: 'GET', url: '/session' })\n+          expect(sess.body).toBe('')\n+        }\n+      })\n+    })\n+  })\n+  delete process.env.SESSION_PLUGIN\n+}\n+\n+suite('@fastify/session')\n+suite('@fastify/secure-session')"
        },
        {
          "filename": "test/helpers.ts",
          "status": "modified",
          "additions": 10,
          "deletions": 7,
          "patch": "@@ -2,7 +2,7 @@ import * as fs from 'fs'\n import fastify, { FastifyInstance } from 'fastify'\n import fastifySecureSession, { SecureSessionPluginOptions } from '@fastify/secure-session'\n import fastifyCookie from '@fastify/cookie'\n-import Authenticator from '../src/Authenticator'\n+import Authenticator, { AuthenticatorOptions } from '../src/Authenticator'\n import { Strategy } from '../src/strategies'\n import { InjectOptions, Response as LightMyRequestResponse } from 'light-my-request'\n import * as parseCookies from 'set-cookie-parser'\n@@ -97,17 +97,19 @@ export const getTestServer = (sessionOptions: SessionOptions = null) => {\n   const server = fastify()\n   loadSessionPlugins(server, sessionOptions)\n \n-  server.setErrorHandler((error, request, reply) => {\n-    console.error(error)\n+  server.setErrorHandler((error, _request, reply) => {\n     void reply.status(500)\n     void reply.send(error)\n   })\n   return server\n }\n \n /** Create a fastify instance with fastify-passport plugin registered but with no strategies registered yet. */\n-export const getRegisteredTestServer = (sessionOptions: SessionOptions = null) => {\n-  const fastifyPassport = new Authenticator()\n+export const getRegisteredTestServer = (\n+  sessionOptions: SessionOptions = null,\n+  passportOptions: AuthenticatorOptions = {}\n+) => {\n+  const fastifyPassport = new Authenticator(passportOptions)\n   fastifyPassport.registerUserSerializer(async (user) => JSON.stringify(user))\n   fastifyPassport.registerUserDeserializer(async (serialized: string) => JSON.parse(serialized))\n \n@@ -122,9 +124,10 @@ export const getRegisteredTestServer = (sessionOptions: SessionOptions = null) =\n export const getConfiguredTestServer = (\n   name = 'test',\n   strategy = new TestStrategy('test'),\n-  sessionOptions: SessionOptions = null\n+  sessionOptions: SessionOptions = null,\n+  passportOptions: AuthenticatorOptions = {}\n ) => {\n-  const { fastifyPassport, server } = getRegisteredTestServer(sessionOptions)\n+  const { fastifyPassport, server } = getRegisteredTestServer(sessionOptions, passportOptions)\n   fastifyPassport.use(name, strategy)\n   return { fastifyPassport, server }\n }"
        },
        {
          "filename": "test/independent-strategy-instances.test.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -18,7 +18,7 @@ class WelcomeStrategy extends Strategy {\n const suite = (sessionPluginName) => {\n   describe(`${sessionPluginName} tests`, () => {\n     test(`should allow passing a specific Strategy instance to an authenticate call`, async () => {\n-      const { server, fastifyPassport } = getRegisteredTestServer()\n+      const { server, fastifyPassport } = getRegisteredTestServer(null, { clearSessionIgnoreFields: ['messages'] })\n       server.get(\n         '/',\n         {"
        },
        {
          "filename": "test/multi-instance.test.ts",
          "status": "modified",
          "additions": 256,
          "deletions": 72,
          "patch": "@@ -3,89 +3,96 @@ import { Authenticator } from '../src/Authenticator'\n import { Strategy } from '../src/strategies'\n import { getTestServer, TestBrowserSession } from './helpers'\n \n+let counter: number\n+let authenticators: Record<string, Authenticator>\n+\n+async function TestStrategyModule(instance: FastifyInstance, { namespace, clearSessionOnLogin }) {\n+  class TestStrategy extends Strategy {\n+    authenticate(request: any, _options?: { pauseStream?: boolean }) {\n+      if (request.isAuthenticated()) {\n+        return this.pass()\n+      }\n+      if (request.body && request.body.login === 'test' && request.body.password === 'test') {\n+        return this.success({ namespace, id: String(counter++) })\n+      }\n+\n+      this.fail()\n+    }\n+  }\n+\n+  const strategyName = `test-${namespace}`\n+  const authenticator = new Authenticator({\n+    key: `passport${namespace}`,\n+    userProperty: `user${namespace}`,\n+    clearSessionOnLogin,\n+  })\n+  authenticator.use(strategyName, new TestStrategy(strategyName))\n+  authenticator.registerUserSerializer<any, string>(async (user) => {\n+    if (user.namespace == namespace) {\n+      return namespace + '-' + JSON.stringify(user)\n+    }\n+    throw 'pass'\n+  })\n+  authenticator.registerUserDeserializer<string, any>(async (serialized: string) => {\n+    if (serialized.startsWith(`${namespace}-`)) {\n+      return JSON.parse(serialized.slice(`${namespace}-`.length))\n+    }\n+    throw 'pass'\n+  })\n+\n+  await instance.register(authenticator.initialize())\n+  await instance.register(authenticator.secureSession())\n+  authenticators[namespace] = authenticator\n+\n+  instance.get(\n+    `/${namespace}`,\n+    { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },\n+    async () => `hello ${namespace}!`\n+  )\n+\n+  instance.get(\n+    `/user/${namespace}`,\n+    { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },\n+    async (request) => JSON.stringify(request[`user${namespace}`])\n+  )\n+\n+  instance.post(\n+    `/login-${namespace}`,\n+    {\n+      preValidation: authenticator.authenticate(strategyName, {\n+        successRedirect: `/${namespace}`,\n+        authInfo: false,\n+      }),\n+    },\n+    () => {\n+      return\n+    }\n+  )\n+\n+  instance.post(\n+    `/logout-${namespace}`,\n+    { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },\n+    async (request, reply) => {\n+      await request.logout()\n+      void reply.send('logged out')\n+    }\n+  )\n+}\n+\n const suite = (sessionPluginName) => {\n   describe(`${sessionPluginName} tests`, () => {\n-    describe('multiple registered instances', () => {\n+    describe('multiple registered instances (clearSessionOnLogin: false)', () => {\n       let server: FastifyInstance\n-      let authenticators: Record<string, Authenticator>\n       let session: TestBrowserSession\n-      let counter: number\n \n       beforeEach(async () => {\n         counter = 0\n-        server = getTestServer()\n         authenticators = {}\n+        server = getTestServer()\n         session = new TestBrowserSession(server)\n \n         for (const namespace of ['a', 'b']) {\n-          await server.register(async (instance) => {\n-            class TestStrategy extends Strategy {\n-              authenticate(request: any, _options?: { pauseStream?: boolean }) {\n-                if (request.isAuthenticated()) {\n-                  return this.pass()\n-                }\n-                if (request.body && request.body.login === 'test' && request.body.password === 'test') {\n-                  return this.success({ namespace, id: String(counter++) })\n-                }\n-\n-                this.fail()\n-              }\n-            }\n-\n-            const strategyName = `test-${namespace}`\n-            const authenticator = new Authenticator({ key: `passport${namespace}`, userProperty: `user${namespace}` })\n-            authenticator.use(strategyName, new TestStrategy(strategyName))\n-            authenticator.registerUserSerializer<any, string>(async (user) => {\n-              if (user.namespace == namespace) {\n-                return namespace + '-' + JSON.stringify(user)\n-              }\n-              throw 'pass'\n-            })\n-            authenticator.registerUserDeserializer<string, any>(async (serialized: string) => {\n-              if (serialized.startsWith(`${namespace}-`)) {\n-                return JSON.parse(serialized.slice(`${namespace}-`.length))\n-              }\n-              throw 'pass'\n-            })\n-\n-            await instance.register(authenticator.initialize())\n-            await instance.register(authenticator.secureSession())\n-            authenticators[namespace] = authenticator\n-\n-            instance.get(\n-              `/${namespace}`,\n-              { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },\n-              async () => `hello ${namespace}!`\n-            )\n-\n-            instance.get(\n-              `/user/${namespace}`,\n-              { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },\n-              async (request) => JSON.stringify(request[`user${namespace}`])\n-            )\n-\n-            instance.post(\n-              `/login-${namespace}`,\n-              {\n-                preValidation: authenticator.authenticate(strategyName, {\n-                  successRedirect: `/${namespace}`,\n-                  authInfo: false,\n-                }),\n-              },\n-              () => {\n-                return\n-              }\n-            )\n-\n-            instance.post(\n-              `/logout-${namespace}`,\n-              { preValidation: authenticator.authenticate(strategyName, { authInfo: false }) },\n-              async (request, reply) => {\n-                await request.logout()\n-                void reply.send('logged out')\n-              }\n-            )\n-          })\n+          await server.register(TestStrategyModule, { namespace, clearSessionOnLogin: false })\n         }\n       })\n \n@@ -251,6 +258,183 @@ const suite = (sessionPluginName) => {\n         expect(userA.id).not.toEqual(userB.id)\n       })\n     })\n+\n+    describe('multiple registered instances (clearSessionOnLogin: true)', () => {\n+      let server: FastifyInstance\n+      let session: TestBrowserSession\n+\n+      beforeEach(async () => {\n+        server = getTestServer()\n+        session = new TestBrowserSession(server)\n+        authenticators = {}\n+        counter = 0\n+\n+        for (const namespace of ['a', 'b']) {\n+          await server.register(TestStrategyModule, { namespace, clearSessionOnLogin: true })\n+        }\n+      })\n+\n+      test('logging in with one instance should not log in the other instance', async () => {\n+        let response = await session.inject({ method: 'GET', url: '/a' })\n+        expect(response.body).toEqual('Unauthorized')\n+        expect(response.statusCode).toEqual(401)\n+\n+        response = await session.inject({ method: 'GET', url: '/b' })\n+        expect(response.body).toEqual('Unauthorized')\n+        expect(response.statusCode).toEqual(401)\n+\n+        // login a\n+        const loginResponse = await session.inject({\n+          method: 'POST',\n+          url: '/login-a',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+\n+        expect(loginResponse.statusCode).toEqual(302)\n+        expect(loginResponse.headers.location).toEqual('/a')\n+\n+        // access protected route\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/a',\n+        })\n+        expect(response.statusCode).toEqual(200)\n+        expect(response.body).toEqual('hello a!')\n+\n+        // access user data\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/user/a',\n+        })\n+        expect(response.statusCode).toEqual(200)\n+\n+        // try to access route protected by other instance\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/b',\n+        })\n+        expect(response.statusCode).toEqual(401)\n+      })\n+\n+      test('simultaneous login should NOT be possible', async () => {\n+        // login a\n+        let response = await session.inject({\n+          method: 'POST',\n+          url: '/login-a',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+\n+        expect(response.statusCode).toEqual(302)\n+        expect(response.headers.location).toEqual('/a')\n+\n+        // login b\n+        response = await session.inject({\n+          method: 'POST',\n+          url: '/login-b',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+\n+        expect(response.statusCode).toEqual(302)\n+        expect(response.headers.location).toEqual('/b')\n+\n+        // access a protected route (/a) was invalidated after login /b\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/a',\n+        })\n+        expect(response.statusCode).toEqual(401)\n+        expect(response.body).toEqual('Unauthorized')\n+\n+        // access b protected route\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/b',\n+        })\n+        expect(response.statusCode).toEqual(200)\n+        expect(response.body).toEqual('hello b!')\n+      })\n+\n+      test('logging out with one instance should log out the other instance', async () => {\n+        // login a\n+        let response = await session.inject({\n+          method: 'POST',\n+          url: '/login-a',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+\n+        expect(response.statusCode).toEqual(302)\n+        expect(response.headers.location).toEqual('/a')\n+\n+        // login b\n+        response = await session.inject({\n+          method: 'POST',\n+          url: '/login-b',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+\n+        expect(response.statusCode).toEqual(302)\n+        expect(response.headers.location).toEqual('/b')\n+\n+        // logout a\n+        response = await session.inject({\n+          method: 'POST',\n+          url: '/logout-a',\n+        })\n+        expect(response.statusCode).toEqual(401)\n+\n+        // try to access route protected by now logged out instance\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/a',\n+        })\n+        expect(response.statusCode).toEqual(401)\n+\n+        // access b protected route which should still be logged in\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/b',\n+        })\n+        expect(response.statusCode).toEqual(200)\n+        expect(response.body).toEqual('hello b!')\n+      })\n+\n+      test('user objects from different instances should be different', async () => {\n+        // login a\n+        let response = await session.inject({\n+          method: 'POST',\n+          url: '/login-a',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+        expect(response.statusCode).toEqual(302)\n+        expect(response.headers.location).toEqual('/a')\n+\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/user/a',\n+        })\n+        expect(response.statusCode).toEqual(200)\n+        const userA = JSON.parse(response.body)\n+\n+        // login b\n+        response = await session.inject({\n+          method: 'POST',\n+          url: '/login-b',\n+          payload: { login: 'test', password: 'test' },\n+        })\n+\n+        expect(response.statusCode).toEqual(302)\n+        expect(response.headers.location).toEqual('/b')\n+\n+        response = await session.inject({\n+          method: 'GET',\n+          url: '/user/b',\n+        })\n+        expect(response.statusCode).toEqual(200)\n+        const userB = JSON.parse(response.body)\n+\n+        expect(userA.id).not.toEqual(userB.id)\n+      })\n+    })\n   })\n }\n "
        },
        {
          "filename": "test/passport.test.ts",
          "status": "modified",
          "additions": 14,
          "deletions": 6,
          "patch": "@@ -24,7 +24,9 @@ const suite = (sessionPluginName) => {\n     })\n \n     test(`should allow login, and add successMessage to session upon logged in`, async () => {\n-      const { server, fastifyPassport } = getConfiguredTestServer()\n+      const { server, fastifyPassport } = getConfiguredTestServer('test', new TestStrategy('test'), null, {\n+        clearSessionIgnoreFields: ['messages'],\n+      })\n \n       server.get(\n         '/',\n@@ -79,7 +81,9 @@ const suite = (sessionPluginName) => {\n         }\n       }\n \n-      const { server, fastifyPassport } = getConfiguredTestServer('test', new WelcomeStrategy('test'))\n+      const { server, fastifyPassport } = getConfiguredTestServer('test', new WelcomeStrategy('test'), null, {\n+        clearSessionIgnoreFields: ['messages'],\n+      })\n       server.get(\n         '/',\n         {\n@@ -121,7 +125,7 @@ const suite = (sessionPluginName) => {\n \n     test(`should throw error if pauseStream is being used`, async () => {\n       jest.spyOn(console, 'error').mockImplementation(jest.fn())\n-      const fastifyPassport = new Authenticator()\n+      const fastifyPassport = new Authenticator({ clearSessionIgnoreFields: ['messages'] })\n       fastifyPassport.use('test', new TestStrategy('test'))\n       fastifyPassport.registerUserSerializer(async (user) => JSON.stringify(user))\n       fastifyPassport.registerUserDeserializer(async (serialized: string) => JSON.parse(serialized))\n@@ -164,7 +168,9 @@ const suite = (sessionPluginName) => {\n     })\n \n     test(`should execute successFlash if logged in`, async () => {\n-      const { server, fastifyPassport } = getConfiguredTestServer()\n+      const { server, fastifyPassport } = getConfiguredTestServer('test', new TestStrategy('test'), null, {\n+        clearSessionIgnoreFields: ['flash'],\n+      })\n       server.get(\n         '/',\n         { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n@@ -299,7 +305,9 @@ const suite = (sessionPluginName) => {\n     })\n \n     test(`should redirect to the returnTo set in the session upon login`, async () => {\n-      const { server, fastifyPassport } = getConfiguredTestServer()\n+      const { server, fastifyPassport } = getConfiguredTestServer('test', new TestStrategy('test'), null, {\n+        clearSessionIgnoreFields: ['returnTo'],\n+      })\n       server.addHook('preValidation', async (request, _reply) => {\n         request.session.set('returnTo', '/success')\n       })\n@@ -602,7 +610,7 @@ const suite = (sessionPluginName) => {\n     })\n \n     test(`should allow registering strategies after creating routes referring to those strategies by name`, async () => {\n-      const { server, fastifyPassport } = getRegisteredTestServer()\n+      const { server, fastifyPassport } = getRegisteredTestServer(null, { clearSessionIgnoreFields: ['messages'] })\n \n       server.get(\n         '/',"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 2,
        "dependency_files": 1,
        "test_files": 5,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c9ba9518b17f8cc989c5ff4f3b0ef7b565f66c40",
            "date": "2025-01-13T05:55:31Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e0c948bc17f4ecd27bc37414037cf04fa5891d8b",
            "date": "2025-01-13T05:55:20Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ad4cc9228c12e7c290672e1cca2d6f046480631e",
            "date": "2025-01-13T05:55:19Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "37e73962ba7b96c43274d0eceeab5994867e805a",
            "date": "2025-01-13T05:55:03Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "671fafef69bb9d090f82887f984b19cbadb946a5",
            "date": "2025-01-11T12:01:48Z",
            "author_login": "Fdawgs"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-352",
    "description": "@fastify/passport is a port of passport authentication library for the Fastify ecosystem. The CSRF (Cross-Site Request Forger) protection enforced by the `@fastify/csrf-protection` library, when combined with `@fastify/passport` in affected versions, can be bypassed by network and same-site attackers. `fastify/csrf-protection` implements the synchronizer token pattern (using plugins `@fastify/session` and `@fastify/secure-session`) by storing a random value used for CSRF token generation in the `_csrf` attribute of a user's session. The `@fastify/passport` library does not clear the session object upon authentication, preserving the `_csrf` attribute between pre-login and authenticated sessions. Consequently, CSRF tokens generated before authentication are still valid. Network and same-site attackers can thus obtain a CSRF token for their pre-session, fixate that pre-session in the victim's browser via cookie tossing, and then perform a CSRF attack after the victim authenticates. As a solution, newer versions of `@fastify/passport` include the configuration options: `clearSessionOnLogin (default: true)` and `clearSessionIgnoreFields (default: ['passport', 'session'])` to clear all the session attributes by default, preserving those explicitly defined in `clearSessionIgnoreFields`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-04-21T23:15:20.267",
    "last_modified": "2024-11-21T07:56:24.500",
    "fix_date": "2023-04-20T07:47:36Z"
  },
  "references": [
    {
      "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern",
      "source": "security-advisories@github.com",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/fastify/fastify-passport/commit/07c90feab9cba0dd4779e47cfb0717a7e2f01d3d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/fastify/fastify-passport/security/advisories/GHSA-2ccf-ffrj-m4qw",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://owasp.org/www-community/attacks/csrf",
      "source": "security-advisories@github.com",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/fastify/fastify-passport/commit/07c90feab9cba0dd4779e47cfb0717a7e2f01d3d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/fastify/fastify-passport/security/advisories/GHSA-2ccf-ffrj-m4qw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://owasp.org/www-community/attacks/csrf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Technical Description"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:11.823563",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fastify-passport",
    "owner": "fastify",
    "created_at": "2019-02-27T13:47:47Z",
    "updated_at": "2025-01-13T05:55:35Z",
    "pushed_at": "2025-01-13T05:56:12Z",
    "size": 4278,
    "stars": 266,
    "forks": 47,
    "open_issues": 11,
    "watchers": 266,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "TypeScript": 128835,
      "JavaScript": 344
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T17:17:41.885654"
  }
}