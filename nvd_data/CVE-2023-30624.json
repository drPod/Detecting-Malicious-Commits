{
  "cve_id": "CVE-2023-30624",
  "github_data": {
    "repository": "bytecodealliance/wasmtime",
    "fix_commit": "0977952dcd9d482bff7c288868ccb52769b3a92e",
    "related_commits": [
      "0977952dcd9d482bff7c288868ccb52769b3a92e",
      "0977952dcd9d482bff7c288868ccb52769b3a92e"
    ],
    "patch_url": "https://github.com/bytecodealliance/wasmtime/commit/0977952dcd9d482bff7c288868ccb52769b3a92e.patch",
    "fix_commit_details": {
      "sha": "0977952dcd9d482bff7c288868ccb52769b3a92e",
      "commit_date": "2023-04-27T16:50:26Z",
      "author": {
        "login": "alexcrichton",
        "type": "User",
        "stats": {
          "total_commits": 2087,
          "average_weekly_commits": 4.546840958605665,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 258
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-ch89-5g45-qwc7",
        "length": 1650,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 209,
        "additions": 127,
        "deletions": 82
      },
      "files": [
        {
          "filename": "RELEASES.md",
          "status": "modified",
          "additions": 43,
          "deletions": 0,
          "patch": "@@ -10,6 +10,27 @@ Unreleased.\n \n --------------------------------------------------------------------------------\n \n+## 8.0.1\n+\n+Released 2023-04-27.\n+\n+### Changed\n+\n+* Breaking: Files opened using Wasmtime's implementation of WASI on Windows now\n+  cannot be deleted until the file handle is closed. This was already true for\n+  open directories. The change was necessary for the bug fix in\n+  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163).\n+\n+### Fixed\n+\n+* Fixed wasi-common's implementation of the `O_DIRECTORY` flag to match POSIX.\n+  [#6163](https://github.com/bytecodealliance/wasmtime/pull/6163)\n+\n+* Undefined Behavior in Rust runtime functions\n+  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n+\n+--------------------------------------------------------------------------------\n+\n ## 8.0.0\n \n Released 2023-04-20\n@@ -110,6 +131,17 @@ Released 2023-04-20\n \n --------------------------------------------------------------------------------\n \n+## 7.0.1\n+\n+Released 2023-04-27.\n+\n+### Fixed\n+\n+* Undefined Behavior in Rust runtime functions\n+  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n+\n+--------------------------------------------------------------------------------\n+\n ## 7.0.0\n \n Released 2023-03-20\n@@ -174,6 +206,17 @@ Released 2023-03-20\n \n --------------------------------------------------------------------------------\n \n+## 6.0.2\n+\n+Released 2023-04-27.\n+\n+### Fixed\n+\n+* Undefined Behavior in Rust runtime functions\n+  [GHSA-ch89-5g45-qwc7](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7)\n+\n+--------------------------------------------------------------------------------\n+\n ## 6.0.1\n \n Released 2023-03-08."
        },
        {
          "filename": "crates/environ/src/module.rs",
          "status": "modified",
          "additions": 15,
          "deletions": 13,
          "patch": "@@ -241,8 +241,9 @@ impl ModuleTranslation<'_> {\n         }\n         let mut idx = 0;\n         let ok = self.module.memory_initialization.init_memory(\n+            &mut (),\n             InitMemory::CompileTime(&self.module),\n-            &mut |memory, init| {\n+            |(), memory, init| {\n                 // Currently `Static` only applies to locally-defined memories,\n                 // so if a data segment references an imported memory then\n                 // transitioning to a `Static` memory initializer is not\n@@ -525,10 +526,11 @@ impl MemoryInitialization {\n     /// question needs to be deferred to runtime, and at runtime this means\n     /// that an invalid initializer has been found and a trap should be\n     /// generated.\n-    pub fn init_memory(\n+    pub fn init_memory<T>(\n         &self,\n-        state: InitMemory<'_>,\n-        write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,\n+        state: &mut T,\n+        init: InitMemory<'_, T>,\n+        mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,\n     ) -> bool {\n         let initializers = match self {\n             // Fall through below to the segmented memory one-by-one\n@@ -543,7 +545,7 @@ impl MemoryInitialization {\n             MemoryInitialization::Static { map } => {\n                 for (index, init) in map {\n                     if let Some(init) = init {\n-                        let result = write(index, init);\n+                        let result = write(state, index, init);\n                         if !result {\n                             return result;\n                         }\n@@ -567,10 +569,10 @@ impl MemoryInitialization {\n             // (e.g. this is a task happening before instantiation at\n             // compile-time).\n             let base = match base {\n-                Some(index) => match &state {\n+                Some(index) => match &init {\n                     InitMemory::Runtime {\n                         get_global_as_u64, ..\n-                    } => get_global_as_u64(index),\n+                    } => get_global_as_u64(state, index),\n                     InitMemory::CompileTime(_) => return false,\n                 },\n                 None => 0,\n@@ -585,12 +587,12 @@ impl MemoryInitialization {\n                 None => return false,\n             };\n \n-            let cur_size_in_pages = match &state {\n+            let cur_size_in_pages = match &init {\n                 InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,\n                 InitMemory::Runtime {\n                     memory_size_in_pages,\n                     ..\n-                } => memory_size_in_pages(memory_index),\n+                } => memory_size_in_pages(state, memory_index),\n             };\n \n             // Note that this `minimum` can overflow if `minimum` is\n@@ -616,7 +618,7 @@ impl MemoryInitialization {\n                 offset: start,\n                 data: data.clone(),\n             };\n-            let result = write(memory_index, &init);\n+            let result = write(state, memory_index, &init);\n             if !result {\n                 return result;\n             }\n@@ -628,7 +630,7 @@ impl MemoryInitialization {\n \n /// Argument to [`MemoryInitialization::init_memory`] indicating the current\n /// status of the instance.\n-pub enum InitMemory<'a> {\n+pub enum InitMemory<'a, T> {\n     /// This evaluation of memory initializers is happening at compile time.\n     /// This means that the current state of memories is whatever their initial\n     /// state is, and additionally globals are not available if data segments\n@@ -640,10 +642,10 @@ pub enum InitMemory<'a> {\n     /// instance's state.\n     Runtime {\n         /// Returns the size, in wasm pages, of the the memory specified.\n-        memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,\n+        memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,\n         /// Returns the value of the global, as a `u64`. Note that this may\n         /// involve zero-extending a 32-bit global to a 64-bit number.\n-        get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,\n+        get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,\n     },\n }\n "
        },
        {
          "filename": "crates/runtime/src/instance.rs",
          "status": "modified",
          "additions": 44,
          "deletions": 36,
          "patch": "@@ -147,8 +147,14 @@ impl Instance {\n \n     /// Helper function to access various locations offset from our `*mut\n     /// VMContext` object.\n-    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {\n-        (self.vmctx_ptr().cast::<u8>())\n+    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {\n+        (std::ptr::addr_of!(self.vmctx).cast::<u8>())\n+            .add(usize::try_from(offset).unwrap())\n+            .cast()\n+    }\n+\n+    unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {\n+        (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())\n             .add(usize::try_from(offset).unwrap())\n             .cast()\n     }\n@@ -183,20 +189,20 @@ impl Instance {\n \n     /// Return the indexed `VMTableDefinition`.\n     #[allow(dead_code)]\n-    fn table(&self, index: DefinedTableIndex) -> VMTableDefinition {\n+    fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {\n         unsafe { *self.table_ptr(index) }\n     }\n \n     /// Updates the value for a defined table to `VMTableDefinition`.\n-    fn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {\n+    fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {\n         unsafe {\n             *self.table_ptr(index) = table;\n         }\n     }\n \n     /// Return the indexed `VMTableDefinition`.\n-    fn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {\n-        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }\n+    fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {\n+        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }\n     }\n \n     /// Get a locally defined or imported memory.\n@@ -238,21 +244,21 @@ impl Instance {\n     }\n \n     /// Return the indexed `VMGlobalDefinition`.\n-    fn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {\n+    fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {\n         unsafe { &*self.global_ptr(index) }\n     }\n \n     /// Return the indexed `VMGlobalDefinition`.\n-    fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {\n-        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }\n+    fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {\n+        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }\n     }\n \n     /// Get a raw pointer to the global at the given index regardless whether it\n     /// is defined locally or imported from another module.\n     ///\n     /// Panics if the index is out of bound or is the reserved value.\n     pub(crate) fn defined_or_imported_global_ptr(\n-        &self,\n+        &mut self,\n         index: GlobalIndex,\n     ) -> *mut VMGlobalDefinition {\n         if let Some(index) = self.module().defined_global_index(index) {\n@@ -263,18 +269,18 @@ impl Instance {\n     }\n \n     /// Return a pointer to the interrupts structure\n-    pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {\n-        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }\n+    pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {\n+        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }\n     }\n \n     /// Return a pointer to the global epoch counter used by this instance.\n-    pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {\n-        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }\n+    pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {\n+        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }\n     }\n \n     /// Return a pointer to the `VMExternRefActivationsTable`.\n-    pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {\n-        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }\n+    pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {\n+        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }\n     }\n \n     /// Gets a pointer to this instance's `Store` which was originally\n@@ -297,7 +303,7 @@ impl Instance {\n \n     pub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {\n         if let Some(store) = store {\n-            *self.vmctx_plus_offset(self.offsets().vmctx_store()) = store;\n+            *self.vmctx_plus_offset_mut(self.offsets().vmctx_store()) = store;\n             *self.runtime_limits() = (*store).vmruntime_limits();\n             *self.epoch_ptr() = (*store).epoch_ptr();\n             *self.externref_activations_table() = (*store).externref_activations_table().0;\n@@ -306,7 +312,7 @@ impl Instance {\n                 mem::size_of::<*mut dyn Store>(),\n                 mem::size_of::<[*mut (); 2]>()\n             );\n-            *self.vmctx_plus_offset::<[*mut (); 2]>(self.offsets().vmctx_store()) =\n+            *self.vmctx_plus_offset_mut::<[*mut (); 2]>(self.offsets().vmctx_store()) =\n                 [ptr::null_mut(), ptr::null_mut()];\n \n             *self.runtime_limits() = ptr::null_mut();\n@@ -316,7 +322,7 @@ impl Instance {\n     }\n \n     pub(crate) unsafe fn set_callee(&mut self, callee: Option<NonNull<VMFunctionBody>>) {\n-        *self.vmctx_plus_offset(self.offsets().vmctx_callee()) =\n+        *self.vmctx_plus_offset_mut(self.offsets().vmctx_callee()) =\n             callee.map_or(ptr::null_mut(), |c| c.as_ptr());\n     }\n \n@@ -402,7 +408,7 @@ impl Instance {\n     }\n \n     /// Return the table index for the given `VMTableDefinition`.\n-    unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {\n+    unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {\n         let index = DefinedTableIndex::new(\n             usize::try_from(\n                 (table as *const VMTableDefinition)\n@@ -515,7 +521,7 @@ impl Instance {\n     ) {\n         let type_index = unsafe {\n             let base: *const VMSharedSignatureIndex =\n-                *self.vmctx_plus_offset(self.offsets().vmctx_signature_ids_array());\n+                *self.vmctx_plus_offset_mut(self.offsets().vmctx_signature_ids_array());\n             *base.add(sig.index())\n         };\n \n@@ -584,7 +590,7 @@ impl Instance {\n             let func = &self.module().functions[index];\n             let sig = func.signature;\n             let anyfunc: *mut VMCallerCheckedFuncRef = self\n-                .vmctx_plus_offset::<VMCallerCheckedFuncRef>(\n+                .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(\n                     self.offsets().vmctx_anyfunc(func.anyfunc),\n                 );\n             self.construct_anyfunc(index, sig, anyfunc);\n@@ -923,40 +929,41 @@ impl Instance {\n     ) {\n         assert!(std::ptr::eq(module, self.module().as_ref()));\n \n-        *self.vmctx_plus_offset(offsets.vmctx_magic()) = VMCONTEXT_MAGIC;\n+        *self.vmctx_plus_offset_mut(offsets.vmctx_magic()) = VMCONTEXT_MAGIC;\n         self.set_callee(None);\n         self.set_store(store.as_raw());\n \n         // Initialize shared signatures\n         let signatures = self.runtime_info.signature_ids();\n-        *self.vmctx_plus_offset(offsets.vmctx_signature_ids_array()) = signatures.as_ptr();\n+        *self.vmctx_plus_offset_mut(offsets.vmctx_signature_ids_array()) = signatures.as_ptr();\n \n         // Initialize the built-in functions\n-        *self.vmctx_plus_offset(offsets.vmctx_builtin_functions()) = &VMBuiltinFunctionsArray::INIT;\n+        *self.vmctx_plus_offset_mut(offsets.vmctx_builtin_functions()) =\n+            &VMBuiltinFunctionsArray::INIT;\n \n         // Initialize the imports\n         debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);\n         ptr::copy_nonoverlapping(\n             imports.functions.as_ptr(),\n-            self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),\n+            self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),\n             imports.functions.len(),\n         );\n         debug_assert_eq!(imports.tables.len(), module.num_imported_tables);\n         ptr::copy_nonoverlapping(\n             imports.tables.as_ptr(),\n-            self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),\n+            self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),\n             imports.tables.len(),\n         );\n         debug_assert_eq!(imports.memories.len(), module.num_imported_memories);\n         ptr::copy_nonoverlapping(\n             imports.memories.as_ptr(),\n-            self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),\n+            self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),\n             imports.memories.len(),\n         );\n         debug_assert_eq!(imports.globals.len(), module.num_imported_globals);\n         ptr::copy_nonoverlapping(\n             imports.globals.as_ptr(),\n-            self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),\n+            self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),\n             imports.globals.len(),\n         );\n \n@@ -967,7 +974,7 @@ impl Instance {\n         // any state now.\n \n         // Initialize the defined tables\n-        let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());\n+        let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());\n         for i in 0..module.table_plans.len() - module.num_imported_tables {\n             ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());\n             ptr = ptr.add(1);\n@@ -978,8 +985,8 @@ impl Instance {\n         // time. Entries in `defined_memories` hold a pointer to a definition\n         // (all memories) whereas the `owned_memories` hold the actual\n         // definitions of memories owned (not shared) in the module.\n-        let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());\n-        let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());\n+        let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());\n+        let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());\n         for i in 0..module.memory_plans.len() - module.num_imported_memories {\n             let defined_memory_index = DefinedMemoryIndex::new(i);\n             let memory_index = module.memory_index(defined_memory_index);\n@@ -1068,8 +1075,9 @@ impl Instance {\n impl Drop for Instance {\n     fn drop(&mut self) {\n         // Drop any defined globals\n-        for (idx, global) in self.module().globals.iter() {\n-            let idx = match self.module().defined_global_index(idx) {\n+        let module = self.module().clone();\n+        for (idx, global) in module.globals.iter() {\n+            let idx = match module.defined_global_index(idx) {\n                 Some(idx) => idx,\n                 None => continue,\n             };\n@@ -1182,8 +1190,8 @@ impl InstanceHandle {\n     }\n \n     /// Return the table index for the given `VMTableDefinition` in this instance.\n-    pub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {\n-        self.instance().table_index(table)\n+    pub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {\n+        self.instance_mut().table_index(table)\n     }\n \n     /// Get a table defined locally within this module."
        },
        {
          "filename": "crates/runtime/src/instance/allocator.rs",
          "status": "modified",
          "additions": 22,
          "deletions": 30,
          "patch": "@@ -200,16 +200,10 @@ pub unsafe trait InstanceAllocator {\n     fn purge_module(&self, module: CompiledModuleId);\n }\n \n-fn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {\n+fn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {\n     match init.base {\n         Some(base) => {\n-            let val = unsafe {\n-                if let Some(def_index) = instance.module().defined_global_index(base) {\n-                    *instance.global(def_index).as_u32()\n-                } else {\n-                    *(*instance.imported_global(base).from).as_u32()\n-                }\n-            };\n+            let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };\n \n             init.offset\n                 .checked_add(val)\n@@ -256,10 +250,11 @@ fn initialize_tables(instance: &mut Instance, module: &Module) -> Result<()> {\n         TableInitialization::FuncTable { segments, .. }\n         | TableInitialization::Segments { segments } => {\n             for segment in segments {\n+                let start = get_table_init_start(segment, instance)?;\n                 instance.table_init_segment(\n                     segment.table_index,\n                     &segment.elements,\n-                    get_table_init_start(segment, instance)?,\n+                    start,\n                     0,\n                     segment.elements.len() as u32,\n                 )?;\n@@ -270,22 +265,18 @@ fn initialize_tables(instance: &mut Instance, module: &Module) -> Result<()> {\n     Ok(())\n }\n \n-fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {\n+fn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {\n     match init.base {\n         Some(base) => {\n             let mem64 = instance.module().memory_plans[init.memory_index]\n                 .memory\n                 .memory64;\n             let val = unsafe {\n-                let global = if let Some(def_index) = instance.module().defined_global_index(base) {\n-                    instance.global(def_index)\n-                } else {\n-                    &*instance.imported_global(base).from\n-                };\n+                let global = instance.defined_or_imported_global_ptr(base);\n                 if mem64 {\n-                    *global.as_u64()\n+                    *(*global).as_u64()\n                 } else {\n-                    u64::from(*global.as_u32())\n+                    u64::from(*(*global).as_u32())\n                 }\n             };\n \n@@ -297,7 +288,10 @@ fn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Resul\n     }\n }\n \n-fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {\n+fn check_memory_init_bounds(\n+    instance: &mut Instance,\n+    initializers: &[MemoryInitializer],\n+) -> Result<()> {\n     for init in initializers {\n         let memory = instance.get_memory(init.memory_index);\n         let start = get_memory_init_start(init, instance)?;\n@@ -319,21 +313,18 @@ fn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializ\n }\n \n fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {\n-    let memory_size_in_pages =\n-        &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);\n+    let memory_size_in_pages = &|instance: &mut Instance, memory| {\n+        (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)\n+    };\n \n     // Loads the `global` value and returns it as a `u64`, but sign-extends\n     // 32-bit globals which can be used as the base for 32-bit memories.\n-    let get_global_as_u64 = &|global| unsafe {\n-        let def = if let Some(def_index) = instance.module().defined_global_index(global) {\n-            instance.global(def_index)\n-        } else {\n-            &*instance.imported_global(global).from\n-        };\n+    let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {\n+        let def = instance.defined_or_imported_global_ptr(global);\n         if module.globals[global].wasm_ty == WasmType::I64 {\n-            *def.as_u64()\n+            *(*def).as_u64()\n         } else {\n-            u64::from(*def.as_u32())\n+            u64::from(*(*def).as_u32())\n         }\n     };\n \n@@ -346,11 +337,12 @@ fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {\n     // so errors only happen if an out-of-bounds segment is found, in which case\n     // a trap is returned.\n     let ok = module.memory_initialization.init_memory(\n+        instance,\n         InitMemory::Runtime {\n             memory_size_in_pages,\n             get_global_as_u64,\n         },\n-        &mut |memory_index, init| {\n+        |instance, memory_index, init| {\n             // If this initializer applies to a defined memory but that memory\n             // doesn't need initialization, due to something like copy-on-write\n             // pre-initializing it via mmap magic, then this initializer can be\n@@ -383,7 +375,7 @@ fn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {\n fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {\n     check_table_init_bounds(instance, module)?;\n \n-    match &instance.module().memory_initialization {\n+    match &module.memory_initialization {\n         MemoryInitialization::Segmented(initializers) => {\n             check_memory_init_bounds(instance, initializers)?;\n         }"
        },
        {
          "filename": "crates/runtime/src/libcalls.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -412,7 +412,7 @@ unsafe fn activations_table_insert_with_gc(vmctx: *mut VMContext, externref: *mu\n // Perform a Wasm `global.get` for `externref` globals.\n unsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {\n     let index = GlobalIndex::from_u32(index);\n-    let instance = (*vmctx).instance();\n+    let instance = (*vmctx).instance_mut();\n     let global = instance.defined_or_imported_global_ptr(index);\n     match (*global).as_externref().clone() {\n         None => ptr::null_mut(),\n@@ -435,7 +435,7 @@ unsafe fn externref_global_set(vmctx: *mut VMContext, index: u32, externref: *mu\n     };\n \n     let index = GlobalIndex::from_u32(index);\n-    let instance = (*vmctx).instance();\n+    let instance = (*vmctx).instance_mut();\n     let global = instance.defined_or_imported_global_ptr(index);\n \n     // Swap the new `externref` value into the global before we drop the old"
        },
        {
          "filename": "crates/runtime/src/traphandlers.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -219,7 +219,7 @@ pub unsafe fn catch_traps<'a, F>(\n where\n     F: FnMut(*mut VMContext),\n {\n-    let limits = (*caller).instance().runtime_limits();\n+    let limits = (*caller).instance_mut().runtime_limits();\n \n     let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {\n         wasmtime_setjmp("
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "75f7b2bed7b2c4360a1a01fdfdb2cfaac9b0b6ae",
            "date": "2025-01-14T15:49:21Z",
            "author_login": "nilsmartel"
          },
          {
            "sha": "e4fd50d1e27f3ba3d4757b85547d55f585d446f9",
            "date": "2025-01-14T01:28:53Z",
            "author_login": "alexcrichton"
          },
          {
            "sha": "8659e11c4ad12512defd6213de0a9d73f8ae6732",
            "date": "2025-01-14T00:47:04Z",
            "author_login": "fitzgen"
          },
          {
            "sha": "84f381fa1bc5c00438108d16fb14657a2c76a182",
            "date": "2025-01-13T22:31:43Z",
            "author_login": "saulecabrera"
          },
          {
            "sha": "a6a08570216d5c42b1c1fc9699fe5b9ae214f27e",
            "date": "2025-01-13T21:05:07Z",
            "author_login": "alexcrichton"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-758",
    "description": "Wasmtime is a standalone runtime for WebAssembly. Prior to versions 6.0.2, 7.0.1, and 8.0.1, Wasmtime's implementation of managing per-instance state, such as tables and memories, contains LLVM-level undefined behavior. This undefined behavior was found to cause runtime-level issues when compiled with LLVM 16 which causes some writes, which are critical for correctness, to be optimized away. Vulnerable versions of Wasmtime compiled with Rust 1.70, which is currently in beta, or later are known to have incorrectly compiled functions. Versions of Wasmtime compiled with the current Rust stable release, 1.69, and prior are not known at this time to have any issues, but can theoretically exhibit potential issues.\n\nThe underlying problem is that Wasmtime's runtime state for an instance involves a Rust-defined structure called `Instance` which has a trailing `VMContext` structure after it. This `VMContext` structure has a runtime-defined layout that is unique per-module. This representation cannot be expressed with safe code in Rust so `unsafe` code is required to maintain this state. The code doing this, however, has methods which take `&self` as an argument but modify data in the `VMContext` part of the allocation. This means that pointers derived from `&self` are mutated. This is typically not allowed, except in the presence of `UnsafeCell`, in Rust. When compiled to LLVM these functions have `noalias readonly` parameters which means it's UB to write through the pointers.\n\nWasmtime's internal representation and management of `VMContext` has been updated to use `&mut self` methods where appropriate. Additionally verification tools for `unsafe` code in Rust, such as `cargo miri`, are planned to be executed on the `main` branch soon to fix any Rust-level issues that may be exploited in future compiler versions.\n\nPrecomplied binaries available for Wasmtime from GitHub releases have been compiled with at most LLVM 15 so are not known to be vulnerable. As mentioned above, however, it's still recommended to update.\n\nWasmtime version 6.0.2, 7.0.1, and 8.0.1 have been issued which contain the patch necessary to work correctly on LLVM 16 and have no known UB on LLVM 15 and earlier. If Wasmtime is compiled with Rust 1.69 and prior, which use LLVM 15, then there are no known issues. There is a theoretical possibility for undefined behavior to exploited, however, so it's recommended that users upgrade to a patched version of Wasmtime. Users using beta Rust (1.70 at this time) or nightly Rust (1.71 at this time) must update to a patched version to work correctly.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-04-27T17:15:08.737",
    "last_modified": "2024-11-21T08:00:32.103",
    "fix_date": "2023-04-27T16:50:26Z"
  },
  "references": [
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/0977952dcd9d482bff7c288868ccb52769b3a92e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/commit/0977952dcd9d482bff7c288868ccb52769b3a92e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ch89-5g45-qwc7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:11.847934",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wasmtime",
    "owner": "bytecodealliance",
    "created_at": "2017-08-29T14:01:55Z",
    "updated_at": "2025-01-14T09:40:55Z",
    "pushed_at": "2025-01-14T01:52:50Z",
    "size": 111616,
    "stars": 15702,
    "forks": 1345,
    "open_issues": 787,
    "watchers": 15702,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-0.32.0",
      "release-0.33.0",
      "release-0.34.0",
      "release-0.35.0",
      "release-0.36.0",
      "release-0.37.0",
      "release-0.38.0",
      "release-0.39.0",
      "release-0.40.0",
      "release-1.0.0",
      "release-2.0.0",
      "release-3.0.0",
      "release-4.0.0",
      "release-5.0.0",
      "release-6.0.0",
      "release-7.0.0",
      "release-8.0.0",
      "release-9.0.0"
    ],
    "languages": {
      "Rust": 19224087,
      "WebAssembly": 6773216,
      "Common Lisp": 1793054,
      "C": 257019,
      "JavaScript": 24116,
      "Shell": 23820,
      "C++": 21050,
      "CMake": 7205,
      "OCaml": 6903,
      "Assembly": 4165,
      "Dockerfile": 2564,
      "Makefile": 1432,
      "CSS": 303
    },
    "commit_activity": {
      "total_commits_last_year": 1586,
      "avg_commits_per_week": 30.5,
      "days_active_last_year": 278
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:32:42.127815"
  }
}