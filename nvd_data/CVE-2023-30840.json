{
  "cve_id": "CVE-2023-30840",
  "github_data": {
    "repository": "fluid-cloudnative/fluid",
    "fix_commit": "77c8110a3d1ec077ae2bce6bd88d296505db1550",
    "related_commits": [
      "77c8110a3d1ec077ae2bce6bd88d296505db1550",
      "91c05c32db131997b5ca065e869c9918a125c149",
      "77c8110a3d1ec077ae2bce6bd88d296505db1550",
      "91c05c32db131997b5ca065e869c9918a125c149"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "77c8110a3d1ec077ae2bce6bd88d296505db1550",
      "commit_date": "2023-05-08T06:46:24Z",
      "author": {
        "login": "TrafalgarZZZ",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-93xx-cvmc-9w3v",
        "length": 293,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 263,
        "additions": 203,
        "deletions": 60
      },
      "files": [
        {
          "filename": "charts/fluid/fluid/CHANGELOG.md",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -53,4 +53,5 @@\n * Scale runtime controllers on demand\n \n ### 0.9.0\n-* Support pass image pull secrets from fluid charts to alluxioruntime controller\n\\ No newline at end of file\n+* Support pass image pull secrets from fluid charts to alluxioruntime controller\n+* Fix components rbacs and set Fluid CSI Plugin with node-authorized kube-client\n\\ No newline at end of file"
        },
        {
          "filename": "charts/fluid/fluid/templates/csi/daemonset.yaml",
          "status": "modified",
          "additions": 24,
          "deletions": 4,
          "patch": "@@ -104,8 +104,16 @@ spec:\n           - name: fluid-src-dir\n             mountPath: {{ .Values.runtime.mountRoot | quote }}\n             mountPropagation: \"Bidirectional\"\n-          - name: host-etc-dir\n-            mountPath: /host-etc\n+          - name: kubelet-kube-config\n+            mountPath: /etc/kubernetes/kubelet.conf\n+            readOnly: true\n+          - name: kubelet-cert-dir\n+            mountPath: {{ .Values.csi.kubelet.certDir | quote }}\n+            readOnly: true\n+          - name: updatedb-conf\n+            mountPath: /host-etc/updatedb.conf\n+          - name: updatedb-conf-bak\n+            mountPath: /host-etc/updatedb.conf.bak\n       volumes:\n         - name: kubelet-dir\n           hostPath:\n@@ -124,6 +132,18 @@ spec:\n             type: DirectoryOrCreate\n           name: fluid-src-dir\n         - hostPath:\n-            path: /etc\n+            path: {{ .Values.csi.kubelet.kubeConfigFile | quote }}\n+            type: File\n+          name: kubelet-kube-config\n+        - hostPath:\n+            path: {{ .Values.csi.kubelet.certDir | quote }}\n             type: Directory\n-          name: host-etc-dir\n+          name: kubelet-cert-dir\n+        - hostPath:\n+            path: /etc/updatedb.conf\n+            type: FileOrCreate\n+          name: updatedb-conf\n+        - hostPath:\n+            path: /etc/updatedb.conf.backup\n+            type: FileOrCreate\n+          name: updatedb-conf-bak"
        },
        {
          "filename": "charts/fluid/fluid/templates/role/csi/rbac.yaml",
          "status": "modified",
          "additions": 1,
          "deletions": 7,
          "patch": "@@ -41,13 +41,7 @@ rules:\n     verbs: [\"get\"]\n   - apiGroups: [\"\"]\n     resources: [\"events\"]\n-    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\"]\n-  - apiGroups: [\"\"]\n-    resources: [\"nodes\"]\n-    verbs: [\"get\", \"patch\"]\n-  - apiGroups: [\"\"]\n-    resources: [\"nodes/proxy\"]\n-    verbs: [\"*\"]\n+    verbs: [\"create\", \"patch\"]\n ---\n kind: ClusterRoleBinding\n apiVersion: rbac.authorization.k8s.io/v1"
        },
        {
          "filename": "charts/fluid/fluid/templates/role/webhook/rabc.yaml",
          "status": "modified",
          "additions": 45,
          "deletions": 10,
          "patch": "@@ -1,16 +1,59 @@\n {{ if .Values.webhook.enabled -}}\n apiVersion: rbac.authorization.k8s.io/v1\n+kind: Role\n+metadata:\n+  name: fluid-webhook\n+  namespace: {{ include \"fluid.namespace\" . }}\n+rules:\n+  - apiGroups:\n+      - \"\"\n+    resources:\n+      - secrets\n+    verbs:\n+      - get\n+      - update\n+    resourceNames:\n+      - fluid-webhook-certs\n+  # resourceNames won't protect create verb, so individually specify it for readability\n+  - apiGroups:\n+      - \"\"\n+    resources:\n+      - secrets\n+    verbs:\n+      - create\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: RoleBinding\n+metadata:\n+  name: fluid-webhook-rolebinding\n+  namespace: {{ include \"fluid.namespace\" . }}\n+roleRef:\n+  apiGroup: rbac.authorization.k8s.io\n+  kind: Role\n+  name: fluid-webhook\n+subjects:\n+  - kind: ServiceAccount\n+    name: fluid-webhook\n+    namespace: {{ include \"fluid.namespace\" . }}\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRole\n metadata:\n   name: fluid-webhook\n rules:\n+  # Can only list and watch secret `mutatingwebhookconfiguration` with a metadata.name field selector\n+  # See https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources\n   - apiGroups:\n       - admissionregistration.k8s.io\n     resources:\n-      - validatingwebhookconfigurations\n       - mutatingwebhookconfigurations\n+    resourceNames:\n+      - fluid-pod-admission-webhook\n     verbs:\n-      - '*'\n+      - get\n+      - patch\n+      - list\n+      - watch\n   - apiGroups:\n       - data.fluid.io\n     resources:\n@@ -38,9 +81,7 @@ rules:\n   - apiGroups:\n       - \"\"\n     resources:\n-      - secrets\n       - configmaps\n-      - events\n     verbs:\n       - get\n       - create\n@@ -56,12 +97,6 @@ rules:\n       - get\n       - list\n       - watch\n-  - apiGroups:\n-      - coordination.k8s.io\n-    resources:\n-      - leases\n-    verbs:\n-      - '*'\n ---\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding"
        },
        {
          "filename": "charts/fluid/fluid/templates/webhook/webhook.yaml",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -16,6 +16,8 @@ spec:\n       labels:\n         control-plane: fluid-webhook\n     spec:\n+      tolerations:\n+        - operator: Exists\n       {{- with .Values.image.imagePullSecrets }}\n       imagePullSecrets:\n         {{- toYaml . | nindent 8 }}"
        },
        {
          "filename": "charts/fluid/fluid/values.yaml",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -26,6 +26,8 @@ csi:\n   plugins:\n     image: fluidcloudnative/fluid-csi:v0.9.0-085b23e\n   kubelet:\n+    kubeConfigFile: /etc/kubernetes/kubelet.conf\n+    certDir: /var/lib/kubelet/pki\n     rootDir: /var/lib/kubelet\n   pruneFs: fuse.alluxio-fuse,fuse.jindofs-fuse,fuse.juicefs,fuse.goosefs-fuse,ossfs,alifuse.aliyun-alinas-efc\n "
        },
        {
          "filename": "cmd/csi/app/csi.go",
          "status": "modified",
          "additions": 13,
          "deletions": 10,
          "patch": "@@ -39,12 +39,13 @@ import (\n )\n \n var (\n-\tendpoint    string\n-\tnodeID      string\n-\tmetricsAddr string\n-\tpprofAddr   string\n-\tpruneFs     []string\n-\tprunePath   string\n+\tendpoint              string\n+\tnodeID                string\n+\tmetricsAddr           string\n+\tpprofAddr             string\n+\tpruneFs               []string\n+\tprunePath             string\n+\tkubeletKubeConfigPath string\n )\n \n var scheme = runtime.NewScheme()\n@@ -81,6 +82,7 @@ func init() {\n \tstartCmd.Flags().StringVarP(&prunePath, \"prune-path\", \"\", \"/runtime-mnt\", \"Prune path to add in /etc/updatedb.conf\")\n \tstartCmd.Flags().StringVarP(&metricsAddr, \"metrics-addr\", \"\", \":8080\", \"The address the metrics endpoint binds to.\")\n \tstartCmd.Flags().StringVarP(&pprofAddr, \"pprof-addr\", \"\", \"\", \"The address for pprof to use while exporting profiling results\")\n+\tstartCmd.Flags().StringVarP(&kubeletKubeConfigPath, \"kubelet-kube-config\", \"\", \"/etc/kubernetes/kubelet.conf\", \"The file path to kubelet kube config\")\n \tutilfeature.DefaultMutableFeatureGate.AddFlag(startCmd.Flags())\n \tstartCmd.Flags().AddGoFlagSet(flag.CommandLine)\n }\n@@ -109,10 +111,11 @@ func handle() {\n \t}\n \n \tconfig := config.Config{\n-\t\tNodeId:    nodeID,\n-\t\tEndpoint:  endpoint,\n-\t\tPruneFs:   pruneFs,\n-\t\tPrunePath: prunePath,\n+\t\tNodeId:            nodeID,\n+\t\tEndpoint:          endpoint,\n+\t\tPruneFs:           pruneFs,\n+\t\tPrunePath:         prunePath,\n+\t\tKubeletConfigPath: kubeletKubeConfigPath,\n \t}\n \n \tif err = csi.SetupWithManager(mgr, config); err != nil {"
        },
        {
          "filename": "pkg/csi/config/config.go",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -17,8 +17,9 @@ limitations under the License.\n package config\n \n type Config struct {\n-\tNodeId    string\n-\tEndpoint  string\n-\tPruneFs   []string\n-\tPrunePath string\n+\tNodeId            string\n+\tEndpoint          string\n+\tPruneFs           []string\n+\tPrunePath         string\n+\tKubeletConfigPath string\n }"
        },
        {
          "filename": "pkg/csi/plugins/driver.go",
          "status": "modified",
          "additions": 18,
          "deletions": 14,
          "patch": "@@ -23,6 +23,7 @@ import (\n \t\"path/filepath\"\n \t\"strings\"\n \n+\t\"k8s.io/client-go/kubernetes\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/manager\"\n \n@@ -38,15 +39,16 @@ const (\n )\n \n type driver struct {\n-\tclient           client.Client\n-\tapiReader        client.Reader\n-\tcsiDriver        *csicommon.CSIDriver\n-\tnodeId, endpoint string\n+\tclient               client.Client\n+\tapiReader            client.Reader\n+\tnodeAuthorizedClient *kubernetes.Clientset\n+\tcsiDriver            *csicommon.CSIDriver\n+\tnodeId, endpoint     string\n }\n \n var _ manager.Runnable = &driver{}\n \n-func NewDriver(nodeID, endpoint string, client client.Client, apiReader client.Reader) *driver {\n+func NewDriver(nodeID, endpoint string, client client.Client, apiReader client.Reader, nodeAuthorizedClient *kubernetes.Clientset) *driver {\n \tglog.Infof(\"Driver: %v version: %v\", driverName, version)\n \n \tproto, addr := utils.SplitSchemaAddr(endpoint)\n@@ -68,11 +70,12 @@ func NewDriver(nodeID, endpoint string, client client.Client, apiReader client.R\n \tcsiDriver.AddVolumeCapabilityAccessModes([]csi.VolumeCapability_AccessMode_Mode{csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER})\n \n \treturn &driver{\n-\t\tnodeId:    nodeID,\n-\t\tendpoint:  endpoint,\n-\t\tcsiDriver: csiDriver,\n-\t\tclient:    client,\n-\t\tapiReader: apiReader,\n+\t\tnodeId:               nodeID,\n+\t\tendpoint:             endpoint,\n+\t\tcsiDriver:            csiDriver,\n+\t\tclient:               client,\n+\t\tnodeAuthorizedClient: nodeAuthorizedClient,\n+\t\tapiReader:            apiReader,\n \t}\n }\n \n@@ -84,10 +87,11 @@ func (d *driver) newControllerServer() *controllerServer {\n \n func (d *driver) newNodeServer() *nodeServer {\n \treturn &nodeServer{\n-\t\tnodeId:            d.nodeId,\n-\t\tDefaultNodeServer: csicommon.NewDefaultNodeServer(d.csiDriver),\n-\t\tclient:            d.client,\n-\t\tapiReader:         d.apiReader,\n+\t\tnodeId:               d.nodeId,\n+\t\tDefaultNodeServer:    csicommon.NewDefaultNodeServer(d.csiDriver),\n+\t\tclient:               d.client,\n+\t\tapiReader:            d.apiReader,\n+\t\tnodeAuthorizedClient: d.nodeAuthorizedClient,\n \t}\n }\n "
        },
        {
          "filename": "pkg/csi/plugins/nodeserver.go",
          "status": "modified",
          "additions": 60,
          "deletions": 9,
          "patch": "@@ -17,6 +17,7 @@ limitations under the License.\n package plugins\n \n import (\n+\t\"encoding/json\"\n \t\"fmt\"\n \t\"os\"\n \t\"os/exec\"\n@@ -31,9 +32,11 @@ import (\n \t\"github.com/fluid-cloudnative/fluid/pkg/ddc/base\"\n \t\"github.com/fluid-cloudnative/fluid/pkg/utils\"\n \t\"github.com/fluid-cloudnative/fluid/pkg/utils/dataset/volume\"\n-\t\"github.com/fluid-cloudnative/fluid/pkg/utils/kubeclient\"\n \t\"github.com/pkg/errors\"\n \tv1 \"k8s.io/api/core/v1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/kubernetes\"\n \t\"k8s.io/utils/mount\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \n@@ -52,10 +55,11 @@ const (\n type nodeServer struct {\n \tnodeId string\n \t*csicommon.DefaultNodeServer\n-\tclient    client.Client\n-\tapiReader client.Reader\n-\tmutex     sync.Mutex\n-\tnode      *v1.Node\n+\tclient               client.Client\n+\tapiReader            client.Reader\n+\tnodeAuthorizedClient *kubernetes.Clientset\n+\tmutex                sync.Mutex\n+\tnode                 *v1.Node\n }\n \n func (ns *nodeServer) NodePublishVolume(ctx context.Context, req *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error) {\n@@ -267,7 +271,8 @@ func (ns *nodeServer) NodeUnstageVolume(ctx context.Context, req *csi.NodeUnstag\n \t\treturn nil, errors.Wrapf(err, \"NodeUnstageVolume: can't get node %s\", ns.nodeId)\n \t}\n \n-\t_, err = utils.ChangeNodeLabelWithPatchMode(ns.client, node, labelsToModify)\n+\t// _, err = utils.ChangeNodeLabelWithPatchMode(ns.client, node, labelsToModify)\n+\terr = ns.patchNodeWithLabel(node, labelsToModify)\n \tif err != nil {\n \t\tglog.Errorf(\"NodeUnstageVolume: error when patching labels on node %s: %v\", ns.nodeId, err)\n \t\treturn nil, errors.Wrapf(err, \"NodeUnstageVolume: error when patching labels on node %s\", ns.nodeId)\n@@ -315,7 +320,8 @@ func (ns *nodeServer) NodeStageVolume(ctx context.Context, req *csi.NodeStageVol\n \t\treturn nil, errors.Wrapf(err, \"NodeStageVolume: can't get node %s\", ns.nodeId)\n \t}\n \n-\t_, err = utils.ChangeNodeLabelWithPatchMode(ns.client, node, labelsToModify)\n+\t// _, err = utils.ChangeNodeLabelWithPatchMode(ns.client, node, labelsToModify)\n+\terr = ns.patchNodeWithLabel(node, labelsToModify)\n \tif err != nil {\n \t\tglog.Errorf(\"NodeStageVolume: error when patching labels on node %s: %v\", ns.nodeId, err)\n \t\treturn nil, errors.Wrapf(err, \"NodeStageVolume: error when patching labels on node %s\", ns.nodeId)\n@@ -373,14 +379,58 @@ func (ns *nodeServer) getNode() (node *v1.Node, err error) {\n \t\t}\n \t}\n \n-\tif node, err = kubeclient.GetNode(ns.apiReader, ns.nodeId); err != nil {\n+\tif node, err = ns.nodeAuthorizedClient.CoreV1().Nodes().Get(context.TODO(), ns.nodeId, metav1.GetOptions{}); err != nil {\n \t\treturn nil, err\n \t}\n+\n+\t// if node, err = kubeclient.GetNode(ns.apiReader, ns.nodeId); err != nil {\n+\t// return nil, err\n+\t// }\n+\n \tglog.V(1).Infof(\"Got node %s from api server\", node.Name)\n \tns.node = node\n \treturn ns.node, nil\n }\n \n+func (ns *nodeServer) patchNodeWithLabel(node *v1.Node, labelsToModify common.LabelsToModify) error {\n+\tlabels := labelsToModify.GetLabels()\n+\tlabelValuePair := map[string]interface{}{}\n+\n+\tfor _, labelToModify := range labels {\n+\t\toperationType := labelToModify.GetOperationType()\n+\t\tlabelToModifyKey := labelToModify.GetLabelKey()\n+\t\tlabelToModifyValue := labelToModify.GetLabelValue()\n+\n+\t\tswitch operationType {\n+\t\tcase common.AddLabel, common.UpdateLabel:\n+\t\t\tlabelValuePair[labelToModifyKey] = labelToModifyValue\n+\t\tcase common.DeleteLabel:\n+\t\t\tlabelValuePair[labelToModifyKey] = nil\n+\t\tdefault:\n+\t\t\terr := fmt.Errorf(\"fail to update the label due to the wrong operation: %s\", operationType)\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tmetadata := map[string]interface{}{\n+\t\t\"metadata\": map[string]interface{}{\n+\t\t\t\"labels\": labelValuePair,\n+\t\t},\n+\t}\n+\n+\tpatchByteData, err := json.Marshal(metadata)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t_, err = ns.nodeAuthorizedClient.CoreV1().Nodes().Patch(context.TODO(), node.Name, types.StrategicMergePatchType, patchByteData, metav1.PatchOptions{})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n func checkMountInUse(volumeName string) (bool, error) {\n \tvar inUse bool\n \tglog.Infof(\"Try to check if the volume %s is being used\", volumeName)\n@@ -454,7 +504,8 @@ func (ns *nodeServer) prepareSessMgr(workDir string) error {\n \t\treturn errors.Wrapf(err, \"can't get node %s\", ns.nodeId)\n \t}\n \n-\t_, err = utils.ChangeNodeLabelWithPatchMode(ns.client, node, labelsToModify)\n+\t// _, err = utils.ChangeNodeLabelWithPatchMode(ns.client, node, labelsToModify)\n+\terr = ns.patchNodeWithLabel(node, labelsToModify)\n \tif err != nil {\n \t\treturn errors.Wrapf(err, \"error when patching labels on node %s\", ns.nodeId)\n \t}"
        },
        {
          "filename": "pkg/csi/plugins/register.go",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -18,12 +18,18 @@ package plugins\n \n import (\n \t\"github.com/fluid-cloudnative/fluid/pkg/csi/config\"\n+\t\"github.com/fluid-cloudnative/fluid/pkg/utils/kubelet\"\n \t\"sigs.k8s.io/controller-runtime/pkg/manager\"\n )\n \n // Register initializes the csi driver and registers it to the controller manager.\n func Register(mgr manager.Manager, cfg config.Config) error {\n-\tcsiDriver := NewDriver(cfg.NodeId, cfg.Endpoint, mgr.GetClient(), mgr.GetAPIReader())\n+\tclient, err := kubelet.InitNodeAuthorizedClient(cfg.KubeletConfigPath)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tcsiDriver := NewDriver(cfg.NodeId, cfg.Endpoint, mgr.GetClient(), mgr.GetAPIReader(), client)\n \n \tif err := mgr.Add(csiDriver); err != nil {\n \t\treturn err"
        },
        {
          "filename": "pkg/utils/kubelet/node_auth_client.go",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+package kubelet\n+\n+import (\n+\t\"github.com/pkg/errors\"\n+\t\"k8s.io/client-go/kubernetes\"\n+\t\"k8s.io/client-go/tools/clientcmd\"\n+)\n+\n+// InitNodeAuthorizedClient initializes node authorized client with kubelet's kube config.\n+// This is now an available workaround to implement a node-scoped daemonset.\n+// See discussion https://github.com/kubernetes/enhancements/pull/944#issuecomment-490242290\n+func InitNodeAuthorizedClient(kubeletKubeConfigPath string) (*kubernetes.Clientset, error) {\n+\tconfig, err := clientcmd.BuildConfigFromFlags(\"\", kubeletKubeConfigPath)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"fail to build kubelet config\")\n+\t}\n+\n+\tclient, err := kubernetes.NewForConfig(config)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"fail to build client-go client from kubelet kubeconfig\")\n+\t}\n+\n+\treturn client, nil\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 9,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c43192368231c6a80867e85d721eb94ad2db61cf",
            "date": "2025-01-24T02:17:20Z",
            "author_login": "Syspretor"
          },
          {
            "sha": "73333a87e2beeb778cb8a6ff58650c5940bda201",
            "date": "2025-01-23T08:50:56Z",
            "author_login": "TrafalgarZZZ"
          },
          {
            "sha": "a97b9b8b5ac3a9a5a4a7a3825c9c45684400cbb4",
            "date": "2025-01-20T09:41:53Z",
            "author_login": "TrafalgarZZZ"
          },
          {
            "sha": "87efbe8a82d2224ac8bd66ec9b3c0c27a1838df3",
            "date": "2025-01-17T11:01:56Z",
            "author_login": "cheyang"
          },
          {
            "sha": "4353d624b59d844b5f67397f768638979539fc70",
            "date": "2025-01-16T11:37:08Z",
            "author_login": "Syspretor"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:L",
    "cwe_id": "CWE-863",
    "description": "Fluid is an open source Kubernetes-native distributed dataset orchestrator and accelerator for data-intensive applications. Starting in version 0.7.0 and prior to version 0.8.6, if a malicious user gains control of a Kubernetes node running fluid csi pod (controlled by the `csi-nodeplugin-fluid` node-daemonset), they can leverage the fluid-csi service account to modify specs of all the nodes in the cluster. However, since this service account lacks `list node` permissions, the attacker may need to use other techniques to identify vulnerable nodes.\n\nOnce the attacker identifies and modifies the node specs, they can manipulate system-level-privileged components to access all secrets in the cluster or execute pods on other nodes. This allows them to elevate privileges beyond the compromised node and potentially gain full privileged access to the whole cluster.\n\nTo exploit this vulnerability, the attacker can make all other nodes unschedulable (for example, patch node with taints) and wait for system-critical components with high privilege to appear on the compromised node. However, this attack requires two prerequisites: a compromised node and identifying all vulnerable nodes through other means.\n\nVersion 0.8.6 contains a patch for this issue. As a workaround, delete the `csi-nodeplugin-fluid` daemonset in `fluid-system` namespace and avoid using CSI mode to mount FUSE file systems. Alternatively, using sidecar mode to mount FUSE file systems is recommended.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-05-08T18:15:14.187",
    "last_modified": "2024-11-21T08:00:57.003",
    "fix_date": "2023-05-08T06:46:24Z"
  },
  "references": [
    {
      "url": "https://github.com/fluid-cloudnative/fluid/commit/77c8110a3d1ec077ae2bce6bd88d296505db1550",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/commit/91c05c32db131997b5ca065e869c9918a125c149",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/releases/tag/v0.8.6",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/security/advisories/GHSA-93xx-cvmc-9w3v",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/commit/77c8110a3d1ec077ae2bce6bd88d296505db1550",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/commit/91c05c32db131997b5ca065e869c9918a125c149",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/releases/tag/v0.8.6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/fluid-cloudnative/fluid/security/advisories/GHSA-93xx-cvmc-9w3v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:32.937382",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "fluid",
    "owner": "fluid-cloudnative",
    "created_at": "2020-07-11T22:57:18Z",
    "updated_at": "2025-01-26T01:32:41Z",
    "pushed_at": "2025-01-24T06:43:46Z",
    "size": 52555,
    "stars": 1706,
    "forks": 959,
    "open_issues": 263,
    "watchers": 1706,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 5861624,
      "Python": 165164,
      "Shell": 65636,
      "Mustache": 51447,
      "Makefile": 20128,
      "Smarty": 6238,
      "Dockerfile": 4369
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:43:08.822930"
  }
}