{
  "cve_id": "CVE-2023-31146",
  "github_data": {
    "repository": "vyperlang/vyper",
    "fix_commit": "4f8289a81206f767df1900ac48f485d90fc87edb",
    "related_commits": [
      "4f8289a81206f767df1900ac48f485d90fc87edb",
      "4f8289a81206f767df1900ac48f485d90fc87edb"
    ],
    "patch_url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb.patch",
    "fix_commit_details": {
      "sha": "4f8289a81206f767df1900ac48f485d90fc87edb",
      "commit_date": "2023-05-11T20:30:00Z",
      "author": {
        "login": "charles-cooper",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-3p37-3636-q8wv",
        "length": 956,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 138,
        "additions": 123,
        "deletions": 15
      },
      "files": [
        {
          "filename": "tests/parser/types/test_dynamic_array.py",
          "status": "modified",
          "additions": 92,
          "deletions": 0,
          "patch": "@@ -1748,3 +1748,95 @@ def foo(i: uint256) -> {return_type}:\n     return MY_CONSTANT[i]\n     \"\"\"\n     assert_compile_failed(lambda: get_contract(code), TypeMismatch)\n+\n+\n+dynarray_length_no_clobber_cases = [\n+    # GHSA-3p37-3636-q8wv cases\n+    \"\"\"\n+a: DynArray[uint256,3]\n+\n+@external\n+def should_revert() -> DynArray[uint256,3]:\n+    self.a = [1,2,3]\n+    self.a = empty(DynArray[uint256,3])\n+    self.a = [self.a[0], self.a[1], self.a[2]]\n+\n+    return self.a  # if bug: returns [1,2,3]\n+    \"\"\",\n+    \"\"\"\n+@external\n+def should_revert() -> DynArray[uint256,3]:\n+    self.a()\n+    return self.b() # if bug: returns [1,2,3]\n+\n+@internal\n+def a():\n+    a: uint256 = 0\n+    b: uint256 = 1\n+    c: uint256 = 2\n+    d: uint256 = 3\n+\n+@internal\n+def b() -> DynArray[uint256,3]:\n+    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n+    a = [a[0],a[1],a[2]]\n+    return a\n+    \"\"\",\n+    \"\"\"\n+a: DynArray[uint256,4]\n+\n+@external\n+def should_revert() -> DynArray[uint256,4]:\n+    self.a = [1,2,3]\n+    self.a = empty(DynArray[uint256,4])\n+    self.a = [4, self.a[0]]\n+\n+    return self.a  # if bug: return [4, 4]\n+    \"\"\",\n+    \"\"\"\n+@external\n+def should_revert() -> DynArray[uint256,4]:\n+    a: DynArray[uint256, 4] = [1,2,3]\n+    a = []\n+\n+    a = [a.pop()]  # if bug: return [1]\n+\n+    return a\n+    \"\"\",\n+    \"\"\"\n+@external\n+def should_revert():\n+    c: DynArray[uint256, 1] = []\n+    c.append(c[0])\n+    \"\"\",\n+    \"\"\"\n+@external\n+def should_revert():\n+    c: DynArray[uint256, 1] = [1]\n+    c[0] = c.pop()\n+    \"\"\",\n+    \"\"\"\n+@external\n+def should_revert():\n+    c: DynArray[DynArray[uint256, 1], 2] = [[]]\n+    c[0] = c.pop()\n+    \"\"\",\n+    \"\"\"\n+a: DynArray[String[65],2]\n+\n+@external\n+def should_revert() -> DynArray[String[65], 2]:\n+    self.a = [\"hello\", \"world\"]\n+    self.a = []\n+    self.a = [self.a[0], self.a[1]]\n+\n+    return self.a  # if bug: return [\"hello\", \"world\"]\n+    \"\"\",\n+]\n+\n+\n+@pytest.mark.parametrize(\"code\", dynarray_length_no_clobber_cases)\n+def test_dynarray_length_no_clobber(get_contract, assert_tx_failed, code):\n+    # check that length is not clobbered before dynarray data copy happens\n+    c = get_contract(code)\n+    assert_tx_failed(lambda: c.should_revert())"
        },
        {
          "filename": "vyper/codegen/core.py",
          "status": "modified",
          "additions": 31,
          "deletions": 15,
          "patch": "@@ -117,13 +117,15 @@ def make_byte_array_copier(dst, src):\n             max_bytes = src.typ.maxlen\n \n             ret = [\"seq\"]\n+\n+            dst_ = bytes_data_ptr(dst)\n+            src_ = bytes_data_ptr(src)\n+\n+            ret.append(copy_bytes(dst_, src_, len_, max_bytes))\n+\n             # store length\n             ret.append(STORE(dst, len_))\n \n-            dst = bytes_data_ptr(dst)\n-            src = bytes_data_ptr(src)\n-\n-            ret.append(copy_bytes(dst, src, len_, max_bytes))\n             return b1.resolve(b2.resolve(ret))\n \n \n@@ -148,25 +150,34 @@ def _dynarray_make_setter(dst, src):\n     if src.value == \"~empty\":\n         return IRnode.from_list(STORE(dst, 0))\n \n+    # copy contents of src dynarray to dst.\n+    # note that in case src and dst refer to the same dynarray,\n+    # in order for get_element_ptr oob checks on the src dynarray\n+    # to work, we need to wait until after the data is copied\n+    # before we clobber the length word.\n+\n     if src.value == \"multi\":\n         ret = [\"seq\"]\n         # handle literals\n \n-        # write the length word\n-        store_length = STORE(dst, len(src.args))\n-        ann = None\n-        if src.annotation is not None:\n-            ann = f\"len({src.annotation})\"\n-        store_length = IRnode.from_list(store_length, annotation=ann)\n-        ret.append(store_length)\n-\n+        # copy each item\n         n_items = len(src.args)\n+\n         for i in range(n_items):\n             k = IRnode.from_list(i, typ=UINT256_T)\n             dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n             src_i = get_element_ptr(src, k, array_bounds_check=False)\n             ret.append(make_setter(dst_i, src_i))\n \n+        # write the length word after data is copied\n+        store_length = STORE(dst, n_items)\n+        ann = None\n+        if src.annotation is not None:\n+            ann = f\"len({src.annotation})\"\n+        store_length = IRnode.from_list(store_length, annotation=ann)\n+\n+        ret.append(store_length)\n+\n         return ret\n \n     with src.cache_when_complex(\"darray_src\") as (b1, src):\n@@ -190,8 +201,6 @@ def _dynarray_make_setter(dst, src):\n         with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n             ret = [\"seq\"]\n \n-            ret.append(STORE(dst, count))\n-\n             if should_loop:\n                 i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=UINT256_T)\n \n@@ -213,6 +222,9 @@ def _dynarray_make_setter(dst, src):\n                 dst_ = dynarray_data_ptr(dst)\n                 ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n \n+            # write the length word after data is copied\n+            ret.append(STORE(dst, count))\n+\n             return b1.resolve(b2.resolve(ret))\n \n \n@@ -336,12 +348,14 @@ def append_dyn_array(darray_node, elem_node):\n         with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n             assertion = [\"assert\", [\"lt\", len_, darray_node.typ.count]]\n             ret.append(IRnode.from_list(assertion, error_msg=f\"{darray_node.typ} bounds check\"))\n-            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n             # NOTE: typechecks elem_node\n             # NOTE skip array bounds check bc we already asserted len two lines up\n             ret.append(\n                 make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n             )\n+\n+            # store new length\n+            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n             return IRnode.from_list(b1.resolve(b2.resolve(ret)))\n \n \n@@ -354,6 +368,7 @@ def pop_dyn_array(darray_node, return_popped_item):\n         new_len = IRnode.from_list([\"sub\", old_len, 1], typ=UINT256_T)\n \n         with new_len.cache_when_complex(\"new_len\") as (b2, new_len):\n+            # store new length\n             ret.append(STORE(darray_node, new_len))\n \n             # NOTE skip array bounds check bc we already asserted len two lines up\n@@ -364,6 +379,7 @@ def pop_dyn_array(darray_node, return_popped_item):\n                 location = popped_item.location\n             else:\n                 typ, location = None, None\n+\n             return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=typ, location=location)\n \n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "db8dcc713168b16977b5b07267653c9024f6acea",
            "date": "2025-01-12T17:01:49Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "10e91d5a2ba6eaab2f7194fd86cefb7a0ff19964",
            "date": "2025-01-12T16:34:14Z",
            "author_login": "tserg"
          },
          {
            "sha": "43259f8953672ef7a19167c6c048d020d82e05da",
            "date": "2025-01-12T16:32:46Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "9b5523e6131335c81714e7e8af63cc49404f5ce7",
            "date": "2025-01-12T16:19:30Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "f444c8fa3b02f34181cfa8768bcf572aedc29659",
            "date": "2025-01-11T20:14:12Z",
            "author_login": "charles-cooper"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-787",
    "description": "Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-05-11T21:15:10.240",
    "last_modified": "2024-11-21T08:01:29.300",
    "fix_date": "2023-05-11T20:30:00Z"
  },
  "references": [
    {
      "url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-3p37-3636-q8wv",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/commit/4f8289a81206f767df1900ac48f485d90fc87edb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-3p37-3636-q8wv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:32.957671",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vyper",
    "owner": "vyperlang",
    "created_at": "2016-11-11T08:56:41Z",
    "updated_at": "2025-01-13T17:32:27Z",
    "pushed_at": "2025-01-12T17:01:50Z",
    "size": 11939,
    "stars": 4948,
    "forks": 817,
    "open_issues": 489,
    "watchers": 4948,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 2662211,
      "Makefile": 2222,
      "Batchfile": 1614,
      "Dockerfile": 1145,
      "Shell": 472
    },
    "commit_activity": {
      "total_commits_last_year": 317,
      "avg_commits_per_week": 6.096153846153846,
      "days_active_last_year": 154
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:48:09.728520"
  }
}