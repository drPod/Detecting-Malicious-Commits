{
  "cve_id": "CVE-2023-32081",
  "github_data": {
    "repository": "vert-x3/vertx-stomp",
    "fix_commit": "0de4bc5a44ddb57e74d92c445f16456fa03f265b",
    "related_commits": [
      "0de4bc5a44ddb57e74d92c445f16456fa03f265b",
      "0de4bc5a44ddb57e74d92c445f16456fa03f265b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "0de4bc5a44ddb57e74d92c445f16456fa03f265b",
      "commit_date": "2023-05-09T21:02:08Z",
      "author": {
        "login": "vietj",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "STOMP server process client frames that would not send initially a connect frame",
        "length": 431,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 146,
        "additions": 137,
        "deletions": 9
      },
      "files": [
        {
          "filename": "src/main/java/io/vertx/ext/stomp/DefaultConnectHandler.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -39,6 +39,7 @@\n  * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n  */\n public class DefaultConnectHandler implements Handler<ServerFrame> {\n+\n   @Override\n   public void handle(ServerFrame sf) {\n     // Server negotiation"
        },
        {
          "filename": "src/main/java/io/vertx/ext/stomp/StompServerConnection.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -96,4 +96,5 @@ public interface StompServerConnection {\n    * @param pingHandler the ping handler\n    */\n   void configureHeartbeat(long ping, long pong, Handler<StompServerConnection> pingHandler);\n+\n }"
        },
        {
          "filename": "src/main/java/io/vertx/ext/stomp/impl/DefaultStompHandler.java",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -70,7 +70,7 @@ public class DefaultStompHandler implements StompServerHandler {\n   private final Vertx vertx;\n   private final Context context;\n \n-  private Handler<ServerFrame> connectHandler = new DefaultConnectHandler();\n+  private Handler<ServerFrame> connectHandler;\n \n   private Handler<ServerFrame> stompHandler;\n \n@@ -125,6 +125,7 @@ public DefaultStompHandler(Vertx vertx) {\n     this.context = Vertx.currentContext();\n     this.destinations = vertx.sharedData().getLocalMap(\"stomp.destinations\");\n     this.users = new ConcurrentHashMap<>();\n+    this.connectHandler = new DefaultConnectHandler();\n   }\n \n   @Override"
        },
        {
          "filename": "src/main/java/io/vertx/ext/stomp/impl/StompServerImpl.java",
          "status": "modified",
          "additions": 54,
          "deletions": 4,
          "patch": "@@ -27,7 +27,9 @@\n import io.vertx.core.net.NetServer;\n import io.vertx.ext.stomp.*;\n \n+import java.util.Collections;\n import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n  * Default implementation of the {@link StompServer}.\n@@ -109,7 +111,17 @@ public StompServer listen(int port, String host, Handler<AsyncResult<StompServer\n         \"server.\");\n     server\n         .connectHandler(socket -> {\n-          StompServerConnection connection = new StompServerTCPConnectionImpl(socket, this, writingFrameHandler);\n+          AtomicBoolean connected = new AtomicBoolean();\n+          AtomicBoolean firstFrame = new AtomicBoolean();\n+          StompServerConnection connection = new StompServerTCPConnectionImpl(socket, this, frame -> {\n+            if (frame.frame().getCommand() == Command.CONNECTED) {\n+              connected.set(true);\n+            }\n+            Handler<ServerFrame> h = writingFrameHandler;\n+            if (h != null) {\n+              h.handle(frame);\n+            }\n+          });\n           FrameParser parser = new FrameParser(options);\n           socket.exceptionHandler((exception) -> {\n             LOGGER.error(\"The STOMP server caught a TCP socket error - closing connection\", exception);\n@@ -123,7 +135,21 @@ public StompServer listen(int port, String host, Handler<AsyncResult<StompServer\n                     connection.close();\n                   }\n               )\n-              .handler(frame -> stomp.handle(new ServerFrameImpl(frame, connection)));\n+              .handler(frame -> {\n+                if (frame.getCommand() == Command.CONNECT || frame.getCommand() == Command.STOMP) {\n+                  if (firstFrame.compareAndSet(false, true)) {\n+                    stomp.handle(new ServerFrameImpl(frame, connection));\n+                  } else {\n+                    connection.write(Frames.createErrorFrame(\"Already connected\", Collections.emptyMap(), \"\"));\n+                    connection.close();\n+                  }\n+                } else if (connected.get()) {\n+                  stomp.handle(new ServerFrameImpl(frame, connection));\n+                } else {\n+                  connection.write(Frames.createErrorFrame(\"Not connected\", Collections.emptyMap(), \"\"));\n+                  connection.close();\n+                }\n+              });\n           socket.handler(parser);\n         })\n         .listen(port, host).onComplete(ar -> {\n@@ -218,7 +244,17 @@ public Handler<ServerWebSocket> webSocketHandler() {\n         socket.reject();\n         return;\n       }\n-      StompServerConnection connection = new StompServerWebSocketConnectionImpl(socket, this, writingFrameHandler);\n+      AtomicBoolean connected = new AtomicBoolean();\n+      AtomicBoolean firstFrame = new AtomicBoolean();\n+      StompServerConnection connection = new StompServerWebSocketConnectionImpl(socket, this, frame -> {\n+        if (frame.frame().getCommand() == Command.CONNECTED  || frame.frame().getCommand() == Command.STOMP) {\n+          connected.set(true);\n+        }\n+        Handler<ServerFrame> h = writingFrameHandler;\n+        if (h != null) {\n+          h.handle(frame);\n+        }\n+      });\n       FrameParser parser = new FrameParser(options);\n       socket.exceptionHandler((exception) -> {\n         LOGGER.error(\"The STOMP server caught a WebSocket error - closing connection\", exception);\n@@ -232,7 +268,21 @@ public Handler<ServerWebSocket> webSocketHandler() {\n                 connection.close();\n               }\n           )\n-          .handler(frame -> stomp.handle(new ServerFrameImpl(frame, connection)));\n+          .handler(frame -> {\n+            if (frame.getCommand() == Command.CONNECT) {\n+              if (firstFrame.compareAndSet(false, true)) {\n+                stomp.handle(new ServerFrameImpl(frame, connection));\n+              } else {\n+                connection.write(Frames.createErrorFrame(\"Already connected\", Collections.emptyMap(), \"\"));\n+                connection.close();\n+              }\n+            } else if (connected.get()) {\n+              stomp.handle(new ServerFrameImpl(frame, connection));\n+            } else {\n+              connection.write(Frames.createErrorFrame(\"Not connected\", Collections.emptyMap(), \"\"));\n+              connection.close();\n+            }\n+          });\n       socket.handler(parser);\n     };\n   }"
        },
        {
          "filename": "src/test/java/io/vertx/ext/stomp/impl/SecuredServerConnectionTest.java",
          "status": "modified",
          "additions": 79,
          "deletions": 4,
          "patch": "@@ -16,8 +16,14 @@\n \n package io.vertx.ext.stomp.impl;\n \n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n import io.vertx.core.Vertx;\n import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.net.NetClient;\n import io.vertx.core.net.NetSocket;\n import io.vertx.ext.auth.User;\n import io.vertx.ext.auth.authentication.AuthenticationProvider;\n@@ -38,15 +44,21 @@\n import org.junit.Test;\n import org.junit.runner.RunWith;\n \n+import java.util.Arrays;\n+\n /**\n  * Tests STOMP server with security.\n  *\n  * @author <a href=\"http://escoffier.me\">Clement Escoffier</a>\n  */\n @RunWith(VertxUnitRunner.class)\n public class SecuredServerConnectionTest {\n+\n   private Vertx vertx;\n   private StompServer server;\n+  private HttpServer wsServer;\n+  private HttpClient wsClient;\n+  private StompClient client;\n \n   @Rule\n   public RunTestOnContext rule = new RunTestOnContext();\n@@ -55,9 +67,17 @@ public class SecuredServerConnectionTest {\n   public void setUp(TestContext context) {\n     vertx = rule.vertx();\n     AuthenticationProvider provider = PropertyFileAuthentication.create(vertx, \"test-auth.properties\");\n-    server = StompServer.create(vertx, new StompServerOptions().setSecured(true))\n-        .handler(StompServerHandler.create(vertx).authProvider(provider));\n-    server.listen().onComplete(context.asyncAssertSuccess());\n+    server = StompServer.create(vertx, new StompServerOptions()\n+        .setSecured(true)\n+        .setWebsocketBridge(true)\n+        .setWebsocketPath(\"/stomp\"))\n+      .handler(StompServerHandler.create(vertx).authProvider(provider));\n+    server.listen(StompServerOptions.DEFAULT_STOMP_PORT).onComplete(context.asyncAssertSuccess());\n+    wsServer = vertx.createHttpServer(new HttpServerOptions().setWebSocketSubProtocols(Arrays.asList(\"v10.stomp\", \"v11.stomp\")))\n+      .webSocketHandler(server.webSocketHandler());\n+    wsServer.listen(8080).onComplete(context.asyncAssertSuccess());\n+    wsClient = vertx.createHttpClient();\n+    client = StompClient.create(vertx, new StompClientOptions().setLogin(\"admin\").setPasscode(\"admin\"));\n   }\n \n   @After\n@@ -162,11 +182,66 @@ public void testClientConnectRejection(TestContext context) {\n   }\n \n   void validate(TestContext context, Buffer buffer) {\n-    context.assertTrue(buffer.toString().contains(\"CONNECTED\"));\n+    context.assertTrue(buffer.toString().contains(\"CONNECTED\"), \"Was expected <\" + buffer.toString() + \"> to contain 'CONNECTED'\");\n     context.assertTrue(buffer.toString().contains(\"version:1.2\"));\n \n     User user = server.stompHandler().getUserBySession(extractSession(buffer.toString()));\n     context.assertNotNull(user);\n   }\n \n+  @Test\n+  public void testTCPClientMustBeConnected(TestContext context) {\n+    Async async = context.async();\n+    NetClient client = vertx.createNetClient();\n+    testClientMustBeConnected(context, v -> {\n+      client.connect(server.actualPort(), \"0.0.0.0\").onComplete(context.asyncAssertSuccess(so -> {\n+        Buffer received = Buffer.buffer();\n+        so.handler(received::appendBuffer);\n+        so.write(\n+          \"SEND\\n\" +\n+            \"destination:/test\\n\" +\n+            \"\\n\" +\n+            \"hello\" +\n+            FrameParser.NULL);\n+        so.endHandler(v2 -> {\n+          context.assertTrue(received.toString().startsWith(\"ERROR\\n\"));\n+          async.complete();\n+        });\n+      }));\n+    });\n+  }\n+\n+  @Test\n+  public void testWebSocketClientMustBeConnected(TestContext context) {\n+    Async async = context.async();\n+    testClientMustBeConnected(context, v -> {\n+      wsClient.webSocket(8080, \"localhost\", \"/stomp\").onComplete(context.asyncAssertSuccess(ws -> {\n+        Buffer received = Buffer.buffer();\n+        ws.binaryMessageHandler(received::appendBuffer);\n+        ws.writeBinaryMessage(\n+          Buffer.buffer(\"SEND\\n\" +\n+            \"destination:/test\\n\" +\n+            \"\\n\" +\n+            \"hello\" +\n+            FrameParser.NULL));\n+        ws.endHandler(v2 -> {\n+          context.assertTrue(received.toString().startsWith(\"ERROR\\n\"));\n+          async.complete();\n+        });\n+      }));\n+    });\n+  }\n+\n+  private void testClientMustBeConnected(TestContext context, Handler<Void> cont) {\n+    client\n+      .connect(server.actualPort(), \"localhost\")\n+      .onComplete(context.asyncAssertSuccess(conn -> {\n+        Future<String> fut = conn.subscribe(\"/test\", frame -> {\n+          context.fail(\"Should not receive a messsage\");\n+        });\n+        fut.onComplete(context.asyncAssertSuccess(v2 -> {\n+          cont.handle(null);\n+        }));\n+      }));\n+  }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4f13e188dac27850913d10da3837c95c94ebc42c",
            "date": "2024-12-11T08:11:13Z",
            "author_login": "vietj"
          },
          {
            "sha": "a6b2801bb40fe4cba350c96aabd1ab8258518a61",
            "date": "2024-12-11T07:43:32Z",
            "author_login": "vietj"
          },
          {
            "sha": "b5f349ecbc101039c98831d63dd3844f0f5e0f3b",
            "date": "2024-12-10T15:41:56Z",
            "author_login": "vietj"
          },
          {
            "sha": "1eff3110fdd98c9da646f41769908d75e8958685",
            "date": "2024-11-22T14:27:43Z",
            "author_login": "vietj"
          },
          {
            "sha": "ba53e380a4fecc2beff4fbed2b13434e25ac1942",
            "date": "2024-11-22T13:50:51Z",
            "author_login": "vietj"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-287",
    "description": "Vert.x STOMP is a vert.x implementation of the STOMP specification that provides a STOMP server and client. From versions 3.1.0 until 3.9.16 and 4.0.0 until 4.4.2, a Vert.x STOMP server processes client STOMP frames without checking that the client send an initial CONNECT frame replied with a successful CONNECTED frame. The client can subscribe to a destination or publish message without prior authentication. Any Vert.x STOMP server configured with an authentication handler is impacted. The issue is patched in Vert.x 3.9.16 and 4.4.2. There are no trivial workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-05-12T14:15:10.140",
    "last_modified": "2024-11-21T08:02:40.483",
    "fix_date": "2023-05-09T21:02:08Z"
  },
  "references": [
    {
      "url": "https://github.com/vert-x3/vertx-stomp/commit/0de4bc5a44ddb57e74d92c445f16456fa03f265b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vert-x3/vertx-stomp/security/advisories/GHSA-gvrq-cg5r-7chp",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/vert-x3/vertx-stomp/commit/0de4bc5a44ddb57e74d92c445f16456fa03f265b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vert-x3/vertx-stomp/security/advisories/GHSA-gvrq-cg5r-7chp",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:32.963650",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "vertx-stomp",
    "owner": "vert-x3",
    "created_at": "2015-08-10T13:38:10Z",
    "updated_at": "2025-01-13T00:23:05Z",
    "pushed_at": "2025-01-23T11:10:25Z",
    "size": 1195,
    "stars": 32,
    "forks": 28,
    "open_issues": 25,
    "watchers": 32,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Java": 522903
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:49:17.110754"
  }
}