{
  "cve_id": "CVE-2023-33199",
  "github_data": {
    "repository": "sigstore/rekor",
    "fix_commit": "140c5add105179e5ffd9e3e114fd1b6b93aebbd4",
    "related_commits": [
      "140c5add105179e5ffd9e3e114fd1b6b93aebbd4",
      "140c5add105179e5ffd9e3e114fd1b6b93aebbd4"
    ],
    "patch_url": "https://github.com/sigstore/rekor/commit/140c5add105179e5ffd9e3e114fd1b6b93aebbd4.patch",
    "fix_commit_details": {
      "sha": "140c5add105179e5ffd9e3e114fd1b6b93aebbd4",
      "commit_date": "2023-05-26T10:44:56Z",
      "author": {
        "login": "bobcallaway",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-frqx-jfcm-6jjr",
        "length": 457,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 154,
        "additions": 128,
        "deletions": 26
      },
      "files": [
        {
          "filename": "pkg/generated/models/intoto_v002_schema.go",
          "status": "modified",
          "additions": 35,
          "deletions": 2,
          "patch": "@@ -450,16 +450,49 @@ type IntotoV002SchemaContentEnvelopeSignaturesItems0 struct {\n \tKeyid string `json:\"keyid,omitempty\"`\n \n \t// public key that corresponds to this signature\n+\t// Required: true\n \t// Format: byte\n-\tPublicKey strfmt.Base64 `json:\"publicKey,omitempty\"`\n+\tPublicKey *strfmt.Base64 `json:\"publicKey\"`\n \n \t// signature of the payload\n+\t// Required: true\n \t// Format: byte\n-\tSig strfmt.Base64 `json:\"sig,omitempty\"`\n+\tSig *strfmt.Base64 `json:\"sig\"`\n }\n \n // Validate validates this intoto v002 schema content envelope signatures items0\n func (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) Validate(formats strfmt.Registry) error {\n+\tvar res []error\n+\n+\tif err := m.validatePublicKey(formats); err != nil {\n+\t\tres = append(res, err)\n+\t}\n+\n+\tif err := m.validateSig(formats); err != nil {\n+\t\tres = append(res, err)\n+\t}\n+\n+\tif len(res) > 0 {\n+\t\treturn errors.CompositeValidationError(res...)\n+\t}\n+\treturn nil\n+}\n+\n+func (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) validatePublicKey(formats strfmt.Registry) error {\n+\n+\tif err := validate.Required(\"publicKey\", \"body\", m.PublicKey); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (m *IntotoV002SchemaContentEnvelopeSignaturesItems0) validateSig(formats strfmt.Registry) error {\n+\n+\tif err := validate.Required(\"sig\", \"body\", m.Sig); err != nil {\n+\t\treturn err\n+\t}\n+\n \treturn nil\n }\n "
        },
        {
          "filename": "pkg/generated/restapi/embedded_spec.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -2167,6 +2167,10 @@ func init() {\n     \"IntotoV002SchemaContentEnvelopeSignaturesItems0\": {\n       \"description\": \"a signature of the envelope's payload along with the public key for the signature\",\n       \"type\": \"object\",\n+      \"required\": [\n+        \"sig\",\n+        \"publicKey\"\n+      ],\n       \"properties\": {\n         \"keyid\": {\n           \"description\": \"optional id of the key used to create the signature\","
        },
        {
          "filename": "pkg/types/dsse/v0.0.1/entry.go",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -75,6 +75,9 @@ func (v V001Entry) IndexKeys() ([]string, error) {\n \tvar result []string\n \n \tfor _, sig := range v.DSSEObj.Signatures {\n+\t\tif sig == nil || sig.Verifier == nil {\n+\t\t\treturn result, errors.New(\"missing or malformed public key\")\n+\t\t}\n \t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(*sig.Verifier))\n \t\tif err != nil {\n \t\t\treturn result, err\n@@ -202,6 +205,10 @@ func (v *V001Entry) Unmarshal(pe models.ProposedEntry) error {\n \n \tallPubKeyBytes := make([][]byte, 0)\n \tfor _, publicKey := range dsseObj.ProposedContent.Verifiers {\n+\t\tif publicKey == nil {\n+\t\t\treturn errors.New(\"an invalid null verifier was provided in ProposedContent\")\n+\t\t}\n+\n \t\tallPubKeyBytes = append(allPubKeyBytes, publicKey)\n \t}\n "
        },
        {
          "filename": "pkg/types/dsse/v0.0.1/entry_test.go",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -158,6 +158,9 @@ func TestV001Entry_Unmarshal(t *testing.T) {\n \t\t},\n \t}\n \n+\tvalidEnv := envelope(t, key, []byte(\"payload\"))\n+\tvalidEnvBytes, _ := json.Marshal(validEnv)\n+\n \tvalidPayload := \"hellothispayloadisvalid\"\n \n \ttests := []struct {\n@@ -218,6 +221,17 @@ func TestV001Entry_Unmarshal(t *testing.T) {\n \t\t\t},\n \t\t\twantErr: false,\n \t\t},\n+\t\t{\n+\t\t\tenv:  validEnv,\n+\t\t\tname: \"null verifier in array\",\n+\t\t\tit: &models.DSSEV001Schema{\n+\t\t\t\tProposedContent: &models.DSSEV001SchemaProposedContent{\n+\t\t\t\t\tEnvelope:  swag.String(string(validEnvBytes)),\n+\t\t\t\t\tVerifiers: []strfmt.Base64{pub, nil},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {"
        },
        {
          "filename": "pkg/types/intoto/v0.0.2/entry.go",
          "status": "modified",
          "additions": 21,
          "deletions": 9,
          "patch": "@@ -32,6 +32,7 @@ import (\n \t\"github.com/in-toto/in-toto-golang/in_toto\"\n \t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n \t\"github.com/spf13/viper\"\n+\t\"golang.org/x/exp/slices\"\n \n \t\"github.com/go-openapi/strfmt\"\n \t\"github.com/go-openapi/swag\"\n@@ -78,7 +79,10 @@ func (v V002Entry) IndexKeys() ([]string, error) {\n \t}\n \n \tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n-\t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(sig.PublicKey))\n+\t\tif sig == nil || sig.PublicKey == nil {\n+\t\t\treturn result, errors.New(\"malformed or missing signature\")\n+\t\t}\n+\t\tkeyObj, err := x509.NewPublicKey(bytes.NewReader(*sig.PublicKey))\n \t\tif err != nil {\n \t\t\treturn result, err\n \t\t}\n@@ -182,13 +186,17 @@ func (v *V002Entry) Unmarshal(pe models.ProposedEntry) error {\n \t}\n \n \tallPubKeyBytes := make([][]byte, 0)\n-\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n+\tfor i, sig := range v.IntotoObj.Content.Envelope.Signatures {\n+\t\tif sig == nil {\n+\t\t\tv.IntotoObj.Content.Envelope.Signatures = slices.Delete(v.IntotoObj.Content.Envelope.Signatures, i, i)\n+\t\t\tcontinue\n+\t\t}\n \t\tenv.Signatures = append(env.Signatures, dsse.Signature{\n \t\t\tKeyID: sig.Keyid,\n-\t\t\tSig:   string(sig.Sig),\n+\t\t\tSig:   string(*sig.Sig),\n \t\t})\n \n-\t\tallPubKeyBytes = append(allPubKeyBytes, sig.PublicKey)\n+\t\tallPubKeyBytes = append(allPubKeyBytes, *sig.PublicKey)\n \t}\n \n \tif _, err := verifyEnvelope(allPubKeyBytes, env); err != nil {\n@@ -381,10 +389,11 @@ func (v V002Entry) CreateFromArtifactProperties(_ context.Context, props types.A\n \t\t}\n \n \t\tkeyBytes := strfmt.Base64(canonKey)\n+\t\tsigBytes := strfmt.Base64([]byte(sig.Sig))\n \t\tre.IntotoObj.Content.Envelope.Signatures = append(re.IntotoObj.Content.Envelope.Signatures, &models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\tKeyid:     sig.KeyID,\n-\t\t\tSig:       strfmt.Base64([]byte(sig.Sig)),\n-\t\t\tPublicKey: keyBytes,\n+\t\t\tSig:       &sigBytes,\n+\t\t\tPublicKey: &keyBytes,\n \t\t})\n \t}\n \n@@ -458,7 +467,7 @@ func (v V002Entry) Verifier() (pki.PublicKey, error) {\n \t\treturn nil, errors.New(\"no signatures found on intoto entry\")\n \t}\n \n-\treturn x509.NewPublicKey(bytes.NewReader(v.IntotoObj.Content.Envelope.Signatures[0].PublicKey))\n+\treturn x509.NewPublicKey(bytes.NewReader(*v.IntotoObj.Content.Envelope.Signatures[0].PublicKey))\n }\n \n func (v V002Entry) Insertable() (bool, error) {\n@@ -480,10 +489,13 @@ func (v V002Entry) Insertable() (bool, error) {\n \t\treturn false, errors.New(\"missing signatures content\")\n \t}\n \tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n-\t\tif len(sig.Sig) == 0 {\n+\t\tif sig == nil {\n+\t\t\treturn false, errors.New(\"missing signature entry\")\n+\t\t}\n+\t\tif sig.Sig == nil || len(*sig.Sig) == 0 {\n \t\t\treturn false, errors.New(\"missing signature content\")\n \t\t}\n-\t\tif len(sig.PublicKey) == 0 {\n+\t\tif sig.PublicKey == nil || len(*sig.PublicKey) == 0 {\n \t\t\treturn false, errors.New(\"missing publicKey content\")\n \t\t}\n \t}"
        },
        {
          "filename": "pkg/types/intoto/v0.0.2/entry_test.go",
          "status": "modified",
          "additions": 45,
          "deletions": 14,
          "patch": "@@ -111,10 +111,12 @@ func createRekorEnvelope(dsseEnv *dsse.Envelope, pub [][]byte) *models.IntotoV00\n \tenv.PayloadType = &dsseEnv.PayloadType\n \n \tfor i, sig := range dsseEnv.Signatures {\n+\t\tkeyBytes := strfmt.Base64(pub[i])\n+\t\tsigBytes := strfmt.Base64([]byte(sig.Sig))\n \t\tenv.Signatures = append(env.Signatures, &models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\tKeyid:     sig.KeyID,\n-\t\t\tSig:       strfmt.Base64([]byte(sig.Sig)),\n-\t\t\tPublicKey: strfmt.Base64(pub[i]),\n+\t\t\tSig:       &sigBytes,\n+\t\t\tPublicKey: &keyBytes,\n \t\t})\n \t}\n \n@@ -172,6 +174,8 @@ func TestV002Entry_Unmarshal(t *testing.T) {\n \t}\n \n \tvalidPayload := \"hellothispayloadisvalid\"\n+\tkeyBytes := strfmt.Base64(\"key\")\n+\tsigBytes := strfmt.Base64(\"sig\")\n \n \ttests := []struct {\n \t\tenv             *dsse.Envelope\n@@ -273,6 +277,31 @@ func TestV002Entry_Unmarshal(t *testing.T) {\n \t\t\twantErr:         false,\n \t\t\twantVerifierErr: false,\n \t\t},\n+\t\t{\n+\t\t\tenv:  envelope(t, key, []byte(validPayload)),\n+\t\t\tname: \"null array entry\",\n+\t\t\tit: &models.IntotoV002Schema{\n+\t\t\t\tContent: &models.IntotoV002SchemaContent{\n+\t\t\t\t\tEnvelope: &models.IntotoV002SchemaContentEnvelope{\n+\t\t\t\t\t\tPayload:     strfmt.Base64(\"cGF5bG9hZAo=\"),\n+\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n+\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n+\t\t\t\t\t\t\t\tSig:       &sigBytes,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tnil,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tHash: &models.IntotoV002SchemaContentHash{\n+\t\t\t\t\t\tAlgorithm: swag.String(models.IntotoV002SchemaContentHashAlgorithmSha256),\n+\t\t\t\t\t\tValue:     swag.String(envelopeHash(t, envelope(t, key, []byte(validPayload)))),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\twantErr:         true,\n+\t\t\twantVerifierErr: true,\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n@@ -295,7 +324,7 @@ func TestV002Entry_Unmarshal(t *testing.T) {\n \n \t\t\t\twant := []string{}\n \t\t\t\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n-\t\t\t\t\tkeyHash := sha256.Sum256(sig.PublicKey)\n+\t\t\t\t\tkeyHash := sha256.Sum256(*sig.PublicKey)\n \t\t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n \t\t\t\t}\n \t\t\t\tdecodedPayload, err := base64.StdEncoding.DecodeString(tt.env.Payload)\n@@ -483,7 +512,7 @@ func TestV002Entry_IndexKeys(t *testing.T) {\n \t\t\t}\n \t\t\twant := []string{}\n \t\t\tfor _, sig := range v.IntotoObj.Content.Envelope.Signatures {\n-\t\t\t\tkeyHash := sha256.Sum256(sig.PublicKey)\n+\t\t\t\tkeyHash := sha256.Sum256(*sig.PublicKey)\n \t\t\t\twant = append(want, \"sha256:\"+hex.EncodeToString(keyHash[:]))\n \t\t\t}\n \n@@ -513,6 +542,8 @@ func TestInsertable(t *testing.T) {\n \t}\n \n \tenv := envelope(t, key, []byte(\"payload\"))\n+\tkeyBytes := strfmt.Base64([]byte(\"key\"))\n+\tsigBytes := strfmt.Base64([]byte(\"sig\"))\n \n \ttestCases := []TestCase{\n \t\t{\n@@ -525,8 +556,8 @@ func TestInsertable(t *testing.T) {\n \t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n \t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n-\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n+\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n+\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n@@ -546,8 +577,8 @@ func TestInsertable(t *testing.T) {\n \t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n \t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n-\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n+\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n+\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n@@ -567,7 +598,7 @@ func TestInsertable(t *testing.T) {\n \t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n \t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n+\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n \t\t\t\t\t\t\t\t\t//Sig:       strfmt.Base64([]byte(\"sig\")),\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n@@ -589,7 +620,7 @@ func TestInsertable(t *testing.T) {\n \t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\t//PublicKey: strfmt.Base64([]byte(\"key\")),\n-\t\t\t\t\t\t\t\t\tSig: strfmt.Base64([]byte(\"sig\")),\n+\t\t\t\t\t\t\t\t\tSig: &sigBytes,\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n@@ -633,8 +664,8 @@ func TestInsertable(t *testing.T) {\n \t\t\t\t\t\t\t//PayloadType: swag.String(\"payloadType\"),\n \t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n-\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n+\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n+\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n@@ -654,8 +685,8 @@ func TestInsertable(t *testing.T) {\n \t\t\t\t\t\t\tPayloadType: swag.String(\"payloadType\"),\n \t\t\t\t\t\t\tSignatures: []*models.IntotoV002SchemaContentEnvelopeSignaturesItems0{\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tPublicKey: strfmt.Base64([]byte(\"key\")),\n-\t\t\t\t\t\t\t\t\tSig:       strfmt.Base64([]byte(\"sig\")),\n+\t\t\t\t\t\t\t\t\tPublicKey: &keyBytes,\n+\t\t\t\t\t\t\t\t\tSig:       &sigBytes,\n \t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},"
        },
        {
          "filename": "pkg/types/intoto/v0.0.2/intoto_v0_0_2_schema.json",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -44,7 +44,8 @@\n                                         \"type\": \"string\",\n                                         \"format\": \"byte\"\n                                     }\n-                                }\n+                                },\n+                                \"required\": [\"sig\", \"publicKey\"]\n                             }\n                         }\n                     },"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "dcad58c3e99b6ed53b21cd6278b017a6625026f9",
            "date": "2025-01-13T14:19:39Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1082f4855b7d53fc766d91e9b8348b21905f0382",
            "date": "2025-01-13T14:00:21Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "362ccea02eee99dd8070e2e733fbbcb6935602ad",
            "date": "2025-01-13T13:59:53Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c505919d963bf020f6f421cc9b0eafa218eb33bc",
            "date": "2025-01-13T13:31:39Z",
            "author_login": "bobcallaway"
          },
          {
            "sha": "280c8c1c1764dbea56d41b48e7e97f0d05bc875e",
            "date": "2025-01-10T09:49:37Z",
            "author_login": "dnwe"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-617",
    "description": "Rekor's goals are to provide an immutable tamper resistant ledger of metadata generated within a software projects supply chain. A malformed proposed entry of the `intoto/v0.0.2` type can cause a panic on a thread within the Rekor process. The thread is recovered so the client receives a 500 error message and service still continues, so the availability impact of this is minimal. This has been fixed in v1.2.0 of Rekor. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-05-26T23:15:18.960",
    "last_modified": "2024-11-21T08:05:06.580",
    "fix_date": "2023-05-26T10:44:56Z"
  },
  "references": [
    {
      "url": "https://github.com/sigstore/rekor/commit/140c5add105179e5ffd9e3e114fd1b6b93aebbd4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sigstore/rekor/security/advisories/GHSA-frqx-jfcm-6jjr",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/sigstore/rekor/commit/140c5add105179e5ffd9e3e114fd1b6b93aebbd4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sigstore/rekor/security/advisories/GHSA-frqx-jfcm-6jjr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:59.259091",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rekor",
    "owner": "sigstore",
    "created_at": "2020-06-17T12:04:01Z",
    "updated_at": "2025-01-13T14:19:43Z",
    "pushed_at": "2025-01-13T14:19:40Z",
    "size": 16313,
    "stars": 917,
    "forks": 168,
    "open_issues": 81,
    "watchers": 917,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0"
    ],
    "languages": {
      "Go": 1242939,
      "Shell": 75833,
      "Makefile": 10412,
      "HCL": 4551,
      "Dockerfile": 1958,
      "Gnuplot": 1355,
      "Standard ML": 70
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:58:47.646777"
  }
}