{
  "cve_id": "CVE-2023-33957",
  "github_data": {
    "repository": "notaryproject/notation",
    "fix_commit": "ed22fde52f6d70ae0b53521bd28c9ccafa868c24",
    "related_commits": [
      "ed22fde52f6d70ae0b53521bd28c9ccafa868c24",
      "ed22fde52f6d70ae0b53521bd28c9ccafa868c24"
    ],
    "patch_url": "https://github.com/notaryproject/notation/commit/ed22fde52f6d70ae0b53521bd28c9ccafa868c24.patch",
    "fix_commit_details": {
      "sha": "ed22fde52f6d70ae0b53521bd28c9ccafa868c24",
      "commit_date": "2023-05-25T06:37:35Z",
      "author": {
        "login": "patrickzheng200",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-9m3v-v4r5-ppx7",
        "length": 1269,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 229,
        "additions": 139,
        "deletions": 90
      },
      "files": [
        {
          "filename": "cmd/notation/inspect.go",
          "status": "modified",
          "additions": 59,
          "deletions": 51,
          "patch": "@@ -14,6 +14,7 @@ import (\n \t\"github.com/notaryproject/notation-core-go/signature\"\n \t\"github.com/notaryproject/notation-go/plugin/proto\"\n \t\"github.com/notaryproject/notation-go/registry\"\n+\tcmderr \"github.com/notaryproject/notation/cmd/notation/internal/errors\"\n \t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n \t\"github.com/notaryproject/notation/internal/cmd\"\n \t\"github.com/notaryproject/notation/internal/envelope\"\n@@ -29,6 +30,7 @@ type inspectOpts struct {\n \treference         string\n \toutputFormat      string\n \tallowReferrersAPI bool\n+\tmaxSignatures     int\n }\n \n type inspectOutput struct {\n@@ -88,13 +90,17 @@ Example - [Experimental] Inspect signatures on an OCI artifact identified by a d\n \t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\")\n \t\t},\n \t\tRunE: func(cmd *cobra.Command, args []string) error {\n+\t\t\tif opts.maxSignatures <= 0 {\n+\t\t\t\treturn fmt.Errorf(\"max-signatures value %d must be a positive number\", opts.maxSignatures)\n+\t\t\t}\n \t\t\treturn runInspect(cmd, opts)\n \t\t},\n \t}\n \n \topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n \topts.SecureFlagOpts.ApplyFlags(command.Flags())\n \tcmd.SetPflagOutput(command.Flags(), &opts.outputFormat, cmd.PflagOutputUsage)\n+\tcommand.Flags().IntVar(&opts.maxSignatures, \"max-signatures\", 100, \"maximum number of signatures to evaluate or examine\")\n \tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"inspect\"))\n \texperimental.HideFlags(command, experimentalExamples, []string{\"allow-referrers-api\"})\n \treturn command\n@@ -120,72 +126,74 @@ func runInspect(command *cobra.Command, opts *inspectOpts) error {\n \t}\n \toutput := inspectOutput{MediaType: manifestDesc.MediaType, Signatures: []signatureOutput{}}\n \tskippedSignatures := false\n-\terr = sigRepo.ListSignatures(ctx, manifestDesc, func(signatureManifests []ocispec.Descriptor) error {\n-\t\tfor _, sigManifestDesc := range signatureManifests {\n-\t\t\tsigBlob, sigDesc, err := sigRepo.FetchSignatureBlob(ctx, sigManifestDesc)\n-\t\t\tif err != nil {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"Warning: unable to fetch signature %s due to error: %v\\n\", sigManifestDesc.Digest.String(), err)\n-\t\t\t\tskippedSignatures = true\n-\t\t\t\tcontinue\n-\t\t\t}\n+\terr = listSignatures(ctx, sigRepo, manifestDesc, opts.maxSignatures, func(sigManifestDesc ocispec.Descriptor) error {\n+\t\tsigBlob, sigDesc, err := sigRepo.FetchSignatureBlob(ctx, sigManifestDesc)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"Warning: unable to fetch signature %s due to error: %v\\n\", sigManifestDesc.Digest.String(), err)\n+\t\t\tskippedSignatures = true\n+\t\t\treturn nil\n+\t\t}\n \n-\t\t\tsigEnvelope, err := signature.ParseEnvelope(sigDesc.MediaType, sigBlob)\n-\t\t\tif err != nil {\n-\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n-\t\t\t\tskippedSignatures = true\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tsigEnvelope, err := signature.ParseEnvelope(sigDesc.MediaType, sigBlob)\n+\t\tif err != nil {\n+\t\t\tlogSkippedSignature(sigManifestDesc, err)\n+\t\t\tskippedSignatures = true\n+\t\t\treturn nil\n+\t\t}\n \n-\t\t\tenvelopeContent, err := sigEnvelope.Content()\n-\t\t\tif err != nil {\n-\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n-\t\t\t\tskippedSignatures = true\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tenvelopeContent, err := sigEnvelope.Content()\n+\t\tif err != nil {\n+\t\t\tlogSkippedSignature(sigManifestDesc, err)\n+\t\t\tskippedSignatures = true\n+\t\t\treturn nil\n+\t\t}\n \n-\t\t\tsignedArtifactDesc, err := envelope.DescriptorFromSignaturePayload(&envelopeContent.Payload)\n-\t\t\tif err != nil {\n-\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n-\t\t\t\tskippedSignatures = true\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tsignedArtifactDesc, err := envelope.DescriptorFromSignaturePayload(&envelopeContent.Payload)\n+\t\tif err != nil {\n+\t\t\tlogSkippedSignature(sigManifestDesc, err)\n+\t\t\tskippedSignatures = true\n+\t\t\treturn nil\n+\t\t}\n \n-\t\t\tsignatureAlgorithm, err := proto.EncodeSigningAlgorithm(envelopeContent.SignerInfo.SignatureAlgorithm)\n-\t\t\tif err != nil {\n-\t\t\t\tlogSkippedSignature(sigManifestDesc, err)\n-\t\t\t\tskippedSignatures = true\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tsignatureAlgorithm, err := proto.EncodeSigningAlgorithm(envelopeContent.SignerInfo.SignatureAlgorithm)\n+\t\tif err != nil {\n+\t\t\tlogSkippedSignature(sigManifestDesc, err)\n+\t\t\tskippedSignatures = true\n+\t\t\treturn nil\n+\t\t}\n \n-\t\t\tsig := signatureOutput{\n-\t\t\t\tMediaType:             sigDesc.MediaType,\n-\t\t\t\tDigest:                sigManifestDesc.Digest.String(),\n-\t\t\t\tSignatureAlgorithm:    string(signatureAlgorithm),\n-\t\t\t\tSignedAttributes:      getSignedAttributes(opts.outputFormat, envelopeContent),\n-\t\t\t\tUserDefinedAttributes: signedArtifactDesc.Annotations,\n-\t\t\t\tUnsignedAttributes:    getUnsignedAttributes(envelopeContent),\n-\t\t\t\tCertificates:          getCertificates(opts.outputFormat, envelopeContent),\n-\t\t\t\tSignedArtifact:        *signedArtifactDesc,\n-\t\t\t}\n+\t\tsig := signatureOutput{\n+\t\t\tMediaType:             sigDesc.MediaType,\n+\t\t\tDigest:                sigManifestDesc.Digest.String(),\n+\t\t\tSignatureAlgorithm:    string(signatureAlgorithm),\n+\t\t\tSignedAttributes:      getSignedAttributes(opts.outputFormat, envelopeContent),\n+\t\t\tUserDefinedAttributes: signedArtifactDesc.Annotations,\n+\t\t\tUnsignedAttributes:    getUnsignedAttributes(envelopeContent),\n+\t\t\tCertificates:          getCertificates(opts.outputFormat, envelopeContent),\n+\t\t\tSignedArtifact:        *signedArtifactDesc,\n+\t\t}\n \n-\t\t\t// clearing annotations from the SignedArtifact field since they're already\n-\t\t\t// displayed as UserDefinedAttributes\n-\t\t\tsig.SignedArtifact.Annotations = nil\n+\t\t// clearing annotations from the SignedArtifact field since they're already\n+\t\t// displayed as UserDefinedAttributes\n+\t\tsig.SignedArtifact.Annotations = nil\n+\n+\t\toutput.Signatures = append(output.Signatures, sig)\n \n-\t\t\toutput.Signatures = append(output.Signatures, sig)\n-\t\t}\n \t\treturn nil\n \t})\n-\n-\tif err != nil {\n+\tvar errorExceedMaxSignatures cmderr.ErrorExceedMaxSignatures\n+\tif err != nil && !errors.As(err, &errorExceedMaxSignatures) {\n \t\treturn err\n \t}\n \n-\terr = printOutput(opts.outputFormat, resolvedRef, output)\n-\tif err != nil {\n+\tif err := printOutput(opts.outputFormat, resolvedRef, output); err != nil {\n \t\treturn err\n \t}\n \n+\tif errorExceedMaxSignatures.MaxSignatures > 0 {\n+\t\tfmt.Println(\"Warning:\", errorExceedMaxSignatures)\n+\t}\n+\n \tif skippedSignatures {\n \t\treturn errors.New(\"at least one signature was skipped and not displayed\")\n \t}"
        },
        {
          "filename": "cmd/notation/inspect_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -16,7 +16,8 @@ func TestInspectCommand_SecretsFromArgs(t *testing.T) {\n \t\t\tInsecureRegistry: true,\n \t\t\tUsername:         \"user\",\n \t\t},\n-\t\toutputFormat: cmd.OutputPlaintext,\n+\t\toutputFormat:  cmd.OutputPlaintext,\n+\t\tmaxSignatures: 100,\n \t}\n \tif err := command.ParseFlags([]string{\n \t\t\"--password\", expected.Password,\n@@ -44,7 +45,8 @@ func TestInspectCommand_SecretsFromEnv(t *testing.T) {\n \t\t\tPassword: \"password\",\n \t\t\tUsername: \"user\",\n \t\t},\n-\t\toutputFormat: cmd.OutputJSON,\n+\t\toutputFormat:  cmd.OutputJSON,\n+\t\tmaxSignatures: 100,\n \t}\n \tcommand := inspectCommand(opts)\n \tif err := command.ParseFlags([]string{"
        },
        {
          "filename": "cmd/notation/internal/errors/errors.go",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -1,5 +1,7 @@\n package errors\n \n+import \"fmt\"\n+\n // ErrorReferrersAPINotSupported is used when the target registry does not\n // support the Referrers API\n type ErrorReferrersAPINotSupported struct {\n@@ -25,3 +27,13 @@ func (e ErrorOCILayoutMissingReference) Error() string {\n \t}\n \treturn \"reference is missing either digest or tag\"\n }\n+\n+// ErrorExceedMaxSignatures is used when the number of signatures has surpassed\n+// the maximum limit that can be evaluated.\n+type ErrorExceedMaxSignatures struct {\n+\tMaxSignatures int\n+}\n+\n+func (e ErrorExceedMaxSignatures) Error() string {\n+\treturn fmt.Sprintf(\"exceeded configured limit of max signatures %d to examine\", e.MaxSignatures)\n+}"
        },
        {
          "filename": "cmd/notation/list.go",
          "status": "modified",
          "additions": 40,
          "deletions": 20,
          "patch": "@@ -6,6 +6,7 @@ import (\n \t\"fmt\"\n \n \tnotationregistry \"github.com/notaryproject/notation-go/registry\"\n+\tcmderr \"github.com/notaryproject/notation/cmd/notation/internal/errors\"\n \t\"github.com/notaryproject/notation/cmd/notation/internal/experimental\"\n \t\"github.com/notaryproject/notation/internal/cmd\"\n \t\"github.com/opencontainers/go-digest\"\n@@ -20,6 +21,7 @@ type listOpts struct {\n \tallowReferrersAPI bool\n \tociLayout         bool\n \tinputType         inputType\n+\tmaxSignatures     int\n }\n \n func listCommand(opts *listOpts) *cobra.Command {\n@@ -47,6 +49,9 @@ func listCommand(opts *listOpts) *cobra.Command {\n \t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\", \"oci-layout\")\n \t\t},\n \t\tRunE: func(cmd *cobra.Command, args []string) error {\n+\t\t\tif opts.maxSignatures <= 0 {\n+\t\t\t\treturn fmt.Errorf(\"max-signatures value %d must be a positive number\", opts.maxSignatures)\n+\t\t\t}\n \t\t\treturn runList(cmd.Context(), opts)\n \t\t},\n \t}\n@@ -55,6 +60,7 @@ func listCommand(opts *listOpts) *cobra.Command {\n \tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"list\"))\n \tcommand.Flags().BoolVar(&opts.ociLayout, \"oci-layout\", false, \"[Experimental] list signatures stored in OCI image layout\")\n \texperimental.HideFlags(command, \"\", []string{\"allow-referrers-api\", \"oci-layout\"})\n+\tcommand.Flags().IntVar(&opts.maxSignatures, \"max-signatures\", 100, \"maximum number of signatures to evaluate or examine\")\n \treturn command\n }\n \n@@ -73,12 +79,12 @@ func runList(ctx context.Context, opts *listOpts) error {\n \t\treturn err\n \t}\n \t// print all signature manifest digests\n-\treturn printSignatureManifestDigests(ctx, targetDesc, sigRepo, resolvedRef)\n+\treturn printSignatureManifestDigests(ctx, targetDesc, sigRepo, resolvedRef, opts.maxSignatures)\n }\n \n // printSignatureManifestDigests returns the signature manifest digests of\n // the subject manifest.\n-func printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descriptor, sigRepo notationregistry.Repository, ref string) error {\n+func printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descriptor, sigRepo notationregistry.Repository, ref string, maxSigs int) error {\n \ttitlePrinted := false\n \tprintTitle := func() {\n \t\tif !titlePrinted {\n@@ -89,34 +95,48 @@ func printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descr\n \t}\n \n \tvar prevDigest digest.Digest\n-\terr := sigRepo.ListSignatures(ctx, targetDesc, func(signatureManifests []ocispec.Descriptor) error {\n-\t\tfor _, sigManifestDesc := range signatureManifests {\n-\t\t\tif prevDigest != \"\" {\n-\t\t\t\t// check and print title\n-\t\t\t\tprintTitle()\n-\n-\t\t\t\t// print each signature digest\n-\t\t\t\tfmt.Printf(\"    \u251c\u2500\u2500 %s\\n\", prevDigest)\n-\t\t\t}\n-\t\t\tprevDigest = sigManifestDesc.Digest\n+\terr := listSignatures(ctx, sigRepo, targetDesc, maxSigs, func(sigManifestDesc ocispec.Descriptor) error {\n+\t\t// print the previous signature digest\n+\t\tif prevDigest != \"\" {\n+\t\t\tprintTitle()\n+\t\t\tfmt.Printf(\"    \u251c\u2500\u2500 %s\\n\", prevDigest)\n \t\t}\n+\t\tprevDigest = sigManifestDesc.Digest\n \t\treturn nil\n \t})\n-\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n+\t// print the last signature digest\n \tif prevDigest != \"\" {\n-\t\t// check and print title\n \t\tprintTitle()\n-\n-\t\t// print last signature digest\n \t\tfmt.Printf(\"    \u2514\u2500\u2500 %s\\n\", prevDigest)\n \t}\n+\tif err != nil {\n+\t\tvar errExceedMaxSignatures cmderr.ErrorExceedMaxSignatures\n+\t\tif !errors.As(err, &errExceedMaxSignatures) {\n+\t\t\treturn err\n+\t\t}\n+\t\tfmt.Println(\"Warning:\", errExceedMaxSignatures)\n+\t}\n \n \tif !titlePrinted {\n \t\tfmt.Printf(\"%s has no associated signature\\n\", ref)\n \t}\n \treturn nil\n }\n+\n+// listSignatures lists signatures associated with manifestDesc with number of\n+// signatures limited by maxSig\n+func listSignatures(ctx context.Context, sigRepo notationregistry.Repository, manifestDesc ocispec.Descriptor, maxSig int, fn func(sigManifest ocispec.Descriptor) error) error {\n+\tnumOfSignatureProcessed := 0\n+\treturn sigRepo.ListSignatures(ctx, manifestDesc, func(signatureManifests []ocispec.Descriptor) error {\n+\t\tfor _, sigManifestDesc := range signatureManifests {\n+\t\t\tif numOfSignatureProcessed >= maxSig {\n+\t\t\t\treturn cmderr.ErrorExceedMaxSignatures{MaxSignatures: maxSig}\n+\t\t\t}\n+\t\t\tnumOfSignatureProcessed++\n+\t\t\tif err := fn(sigManifestDesc); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+}"
        },
        {
          "filename": "cmd/notation/list_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -14,6 +14,7 @@ func TestListCommand_SecretsFromArgs(t *testing.T) {\n \t\t\tInsecureRegistry: true,\n \t\t\tUsername:         \"user\",\n \t\t},\n+\t\tmaxSignatures: 100,\n \t}\n \tif err := cmd.ParseFlags([]string{\n \t\t\"--password\", expected.Password,\n@@ -40,6 +41,7 @@ func TestListCommand_SecretsFromEnv(t *testing.T) {\n \t\t\tPassword: \"password\",\n \t\t\tUsername: \"user\",\n \t\t},\n+\t\tmaxSignatures: 100,\n \t}\n \tcmd := listCommand(opts)\n \tif err := cmd.ParseFlags([]string{"
        },
        {
          "filename": "cmd/notation/verify.go",
          "status": "modified",
          "additions": 15,
          "deletions": 15,
          "patch": "@@ -3,7 +3,6 @@ package main\n import (\n \t\"errors\"\n \t\"fmt\"\n-\t\"math\"\n \t\"os\"\n \t\"reflect\"\n \n@@ -16,18 +15,17 @@ import (\n \t\"github.com/spf13/cobra\"\n )\n \n-const maxSignatureAttempts = math.MaxInt64\n-\n type verifyOpts struct {\n \tcmd.LoggingFlagOpts\n \tSecureFlagOpts\n-\treference         string\n-\tpluginConfig      []string\n-\tuserMetadata      []string\n-\tallowReferrersAPI bool\n-\tociLayout         bool\n-\ttrustPolicyScope  string\n-\tinputType         inputType\n+\treference            string\n+\tpluginConfig         []string\n+\tuserMetadata         []string\n+\tallowReferrersAPI    bool\n+\tociLayout            bool\n+\ttrustPolicyScope     string\n+\tinputType            inputType\n+\tmaxSignatureAttempts int\n }\n \n func verifyCommand(opts *verifyOpts) *cobra.Command {\n@@ -74,13 +72,17 @@ Example - [Experimental] Verify a signature on an OCI artifact identified by a t\n \t\t\treturn experimental.CheckFlagsAndWarn(cmd, \"allow-referrers-api\", \"oci-layout\", \"scope\")\n \t\t},\n \t\tRunE: func(cmd *cobra.Command, args []string) error {\n+\t\t\tif opts.maxSignatureAttempts <= 0 {\n+\t\t\t\treturn fmt.Errorf(\"max-signatures value %d must be a positive number\", opts.maxSignatureAttempts)\n+\t\t\t}\n \t\t\treturn runVerify(cmd, opts)\n \t\t},\n \t}\n \topts.LoggingFlagOpts.ApplyFlags(command.Flags())\n \topts.SecureFlagOpts.ApplyFlags(command.Flags())\n \tcommand.Flags().StringArrayVar(&opts.pluginConfig, \"plugin-config\", nil, \"{key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values\")\n \tcmd.SetPflagUserMetadata(command.Flags(), &opts.userMetadata, cmd.PflagUserMetadataVerifyUsage)\n+\tcommand.Flags().IntVar(&opts.maxSignatureAttempts, \"max-signatures\", 100, \"maximum number of signatures to evaluate or examine\")\n \tcmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, \"verify\"))\n \tcommand.Flags().BoolVar(&opts.ociLayout, \"oci-layout\", false, \"[Experimental] verify the artifact stored as OCI image layout\")\n \tcommand.Flags().StringVar(&opts.trustPolicyScope, \"scope\", \"\", \"[Experimental] set trust policy scope for artifact verification, required and can only be used when flag \\\"--oci-layout\\\" is set\")\n@@ -124,11 +126,9 @@ func runVerify(command *cobra.Command, opts *verifyOpts) error {\n \t}\n \tintendedRef := resolveArtifactDigestReference(resolvedRef, opts.trustPolicyScope)\n \tverifyOpts := notation.VerifyOptions{\n-\t\tArtifactReference: intendedRef,\n-\t\tPluginConfig:      configs,\n-\t\t// TODO: need to change MaxSignatureAttempts as a user input flag or\n-\t\t// a field in config.json\n-\t\tMaxSignatureAttempts: maxSignatureAttempts,\n+\t\tArtifactReference:    intendedRef,\n+\t\tPluginConfig:         configs,\n+\t\tMaxSignatureAttempts: opts.maxSignatureAttempts,\n \t\tUserMetadata:         userMetadata,\n \t}\n \t_, outcomes, err := notation.Verify(ctx, sigVerifier, sigRepo, verifyOpts)"
        },
        {
          "filename": "cmd/notation/verify_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -14,7 +14,8 @@ func TestVerifyCommand_BasicArgs(t *testing.T) {\n \t\t\tUsername: \"user\",\n \t\t\tPassword: \"password\",\n \t\t},\n-\t\tpluginConfig: []string{\"key1=val1\"},\n+\t\tpluginConfig:         []string{\"key1=val1\"},\n+\t\tmaxSignatureAttempts: 100,\n \t}\n \tif err := command.ParseFlags([]string{\n \t\texpected.reference,\n@@ -39,7 +40,8 @@ func TestVerifyCommand_MoreArgs(t *testing.T) {\n \t\tSecureFlagOpts: SecureFlagOpts{\n \t\t\tInsecureRegistry: true,\n \t\t},\n-\t\tpluginConfig: []string{\"key1=val1\", \"key2=val2\"},\n+\t\tpluginConfig:         []string{\"key1=val1\", \"key2=val2\"},\n+\t\tmaxSignatureAttempts: 100,\n \t}\n \tif err := command.ParseFlags([]string{\n \t\texpected.reference,"
        },
        {
          "filename": "specs/commandline/inspect.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -37,6 +37,7 @@ Flags:\n   -d, --debug                 debug mode\n   -h, --help                  help for inspect\n       --insecure-registry     use HTTP protocol while connecting to registries. Should be used only for testing\n+      --max-signatures int    maximum number of signatures to evaluate or examine (default 100)\n   -o, --output string         output format, options: 'json', 'text' (default \"text\")\n   -p, --password string       password for registry operations (default to $NOTATION_PASSWORD if not specified)\n   -u, --username string       username for registry operations (default to $NOTATION_USERNAME if not specified)"
        },
        {
          "filename": "specs/commandline/list.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -31,6 +31,7 @@ Flags:\n   -d, --debug                 debug mode\n   -h, --help                  help for list\n       --insecure-registry     use HTTP protocol while connecting to registries. Should be used only for testing\n+      --max-signatures int    maximum number of signatures to evaluate or examine (default 100)\n       --oci-layout            [Experimental] list signatures stored in OCI image layout\n   -p, --password string       password for registry operations (default to $NOTATION_PASSWORD if not specified)\n   -u, --username string       username for registry operations (default to $NOTATION_USERNAME if not specified)"
        },
        {
          "filename": "specs/commandline/verify.md",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -39,6 +39,7 @@ Flags:\n   -d,  --debug                       debug mode\n   -h,  --help                        help for verify\n        --insecure-registry           use HTTP protocol while connecting to registries. Should be used only for testing\n+       --max-signatures int          maximum number of signatures to evaluate or examine (default 100)\n        --oci-layout                  [Experimental] verify the artifact stored as OCI image layout\n   -p,  --password string             password for registry operations (default to $NOTATION_PASSWORD if not specified)\n        --plugin-config stringArray   {key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5b2a089435d5bab5f44715f1aa1413bc71501485",
            "date": "2025-01-14T10:00:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c323f8ef13d7ac57a55357d28df0fb0bed5a754b",
            "date": "2025-01-14T10:00:07Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "28b2df75e5c2588188010879c1ef1533ccce0299",
            "date": "2025-01-14T09:59:19Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "cd933daede84c390b5814c223c20751e3a5dcd75",
            "date": "2025-01-14T09:16:49Z",
            "author_login": "JeyJeyGao"
          },
          {
            "sha": "f134aca2ac10034c9475fd8f0766c52cd98f8a12",
            "date": "2025-01-14T09:00:33Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 2.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:N/I:N/A:L",
    "cwe_id": "CWE-400",
    "description": "notation is a CLI tool to sign and verify OCI artifacts and container images. An attacker who has compromised a registry and added a high number of signatures to an artifact can cause denial of service of services on the machine, if a user runs notation inspect command on the same machine. The problem has been fixed in the release v1.0.0-rc.6. Users should upgrade their notation packages to v1.0.0-rc.6 or above. Users are advised to upgrade. Users unable to upgrade may restrict container registries to a set of secure and trusted container registries.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-06-06T19:15:12.363",
    "last_modified": "2024-11-21T08:06:17.440",
    "fix_date": "2023-05-25T06:37:35Z"
  },
  "references": [
    {
      "url": "https://github.com/notaryproject/notation/commit/ed22fde52f6d70ae0b53521bd28c9ccafa868c24",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/notaryproject/notation/security/advisories/GHSA-9m3v-v4r5-ppx7",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/notaryproject/notation/commit/ed22fde52f6d70ae0b53521bd28c9ccafa868c24",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/notaryproject/notation/security/advisories/GHSA-9m3v-v4r5-ppx7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:59.311793",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "notation",
    "owner": "notaryproject",
    "created_at": "2020-04-20T16:56:00Z",
    "updated_at": "2025-01-14T10:00:37Z",
    "pushed_at": "2025-01-14T10:00:41Z",
    "size": 13014,
    "stars": 367,
    "forks": 86,
    "open_issues": 66,
    "watchers": 367,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.1",
      "release-1.2",
      "release-1.3"
    ],
    "languages": {
      "Go": 509383,
      "Shell": 17904,
      "Makefile": 3012,
      "Python": 2749
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:14:49.572884"
  }
}