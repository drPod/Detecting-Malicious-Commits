{
  "cve_id": "CVE-2023-34449",
  "github_data": {
    "repository": "paritytech/ink",
    "fix_commit": "f1407ee9f87e5f64d467a22d26ee88f61db7f3db",
    "related_commits": [
      "f1407ee9f87e5f64d467a22d26ee88f61db7f3db",
      "f1407ee9f87e5f64d467a22d26ee88f61db7f3db"
    ],
    "patch_url": "https://github.com/paritytech/ink/commit/f1407ee9f87e5f64d467a22d26ee88f61db7f3db.patch",
    "fix_commit_details": {
      "sha": "f1407ee9f87e5f64d467a22d26ee88f61db7f3db",
      "commit_date": "2023-06-14T17:44:19Z",
      "author": {
        "login": "HCastano",
        "type": "User",
        "stats": {
          "total_commits": 116,
          "average_weekly_commits": 0.36363636363636365,
          "total_additions": 21410,
          "total_deletions": 10271,
          "weeks_active": 51
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-853p-5678-hv8f",
        "length": 309,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 289,
        "additions": 269,
        "deletions": 20
      },
      "files": [
        {
          "filename": "crates/env/src/api.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -300,7 +300,7 @@ where\n /// - If the called code execution has trapped.\n pub fn invoke_contract_delegate<E, Args, R>(\n     params: &CallParams<E, DelegateCall<E>, Args, R>,\n-) -> Result<R>\n+) -> Result<ink_primitives::MessageResult<R>>\n where\n     E: Environment,\n     Args: scale::Encode,"
        },
        {
          "filename": "crates/env/src/backend.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -433,7 +433,7 @@ pub trait TypedEnvBackend: EnvBackend {\n     fn invoke_contract_delegate<E, Args, R>(\n         &mut self,\n         call_data: &CallParams<E, DelegateCall<E>, Args, R>,\n-    ) -> Result<R>\n+    ) -> Result<ink_primitives::MessageResult<R>>\n     where\n         E: Environment,\n         Args: scale::Encode,"
        },
        {
          "filename": "crates/env/src/call/call_builder.rs",
          "status": "modified",
          "additions": 21,
          "deletions": 15,
          "patch": "@@ -151,13 +151,17 @@ where\n     ///\n     /// # Panics\n     ///\n-    /// This method panics if it encounters an [`ink::env::Error`][`crate::Error`]. If you\n-    /// want to handle those use the [`try_invoke`][`CallParams::try_invoke`] method\n-    /// instead.\n+    /// This method panics if it encounters an [`ink::env::Error`][`crate::Error`] or an\n+    /// [`ink::primitives::LangError`][`ink_primitives::LangError`]. If you want to handle\n+    /// those use the [`try_invoke`][`CallParams::try_invoke`] method instead.\n     pub fn invoke(&self) -> R {\n-        crate::invoke_contract_delegate(self).unwrap_or_else(|env_error| {\n-            panic!(\"Cross-contract call failed with {env_error:?}\")\n-        })\n+        crate::invoke_contract_delegate(self)\n+            .unwrap_or_else(|env_error| {\n+                panic!(\"Cross-contract call failed with {env_error:?}\")\n+            })\n+            .unwrap_or_else(|lang_error| {\n+                panic!(\"Cross-contract call failed with {lang_error:?}\")\n+            })\n     }\n \n     /// Invoke the contract using Delegate Call semantics with the given built-up call\n@@ -167,9 +171,10 @@ where\n     ///\n     /// # Note\n     ///\n-    /// On failure this returns an [`ink::env::Error`][`crate::Error`] which can be\n+    /// On failure this returns an outer [`ink::env::Error`][`crate::Error`] or inner\n+    /// [`ink::primitives::LangError`][`ink_primitives::LangError`], both of which can be\n     /// handled by the caller.\n-    pub fn try_invoke(&self) -> Result<R, crate::Error> {\n+    pub fn try_invoke(&self) -> Result<ink_primitives::MessageResult<R>, crate::Error> {\n         crate::invoke_contract_delegate(self)\n     }\n }\n@@ -714,7 +719,7 @@ where\n     ///\n     /// On failure this an [`ink::env::Error`][`crate::Error`] which can be handled by the\n     /// caller.\n-    pub fn try_invoke(self) -> Result<(), Error> {\n+    pub fn try_invoke(self) -> Result<ink_primitives::MessageResult<()>, Error> {\n         self.params().try_invoke()\n     }\n }\n@@ -761,9 +766,9 @@ where\n     ///\n     /// # Panics\n     ///\n-    /// This method panics if it encounters an [`ink::env::Error`][`crate::Error`]\n-    /// If you want to handle those use the [`try_invoke`][`CallBuilder::try_invoke`]\n-    /// method instead.\n+    /// This method panics if it encounters an [`ink::env::Error`][`crate::Error`] or an\n+    /// [`ink::primitives::LangError`][`ink_primitives::LangError`]. If you want to handle\n+    /// those use the [`try_invoke`][`CallBuilder::try_invoke`] method instead.\n     pub fn invoke(self) -> R {\n         self.params().invoke()\n     }\n@@ -773,9 +778,10 @@ where\n     ///\n     /// # Note\n     ///\n-    /// On failure this an [`ink::env::Error`][`crate::Error`] which can be handled by the\n-    /// caller.\n-    pub fn try_invoke(self) -> Result<R, Error> {\n+    /// On failure this returns an outer [`ink::env::Error`][`crate::Error`] or inner\n+    /// [`ink::primitives::LangError`][`ink_primitives::LangError`], both of which can be\n+    /// handled by the caller.\n+    pub fn try_invoke(self) -> Result<ink_primitives::MessageResult<R>, Error> {\n         self.params().try_invoke()\n     }\n }"
        },
        {
          "filename": "crates/env/src/engine/off_chain/impls.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -453,7 +453,7 @@ impl TypedEnvBackend for EnvInstance {\n     fn invoke_contract_delegate<E, Args, R>(\n         &mut self,\n         params: &CallParams<E, DelegateCall<E>, Args, R>,\n-    ) -> Result<R>\n+    ) -> Result<ink_primitives::MessageResult<R>>\n     where\n         E: Environment,\n         Args: scale::Encode,"
        },
        {
          "filename": "crates/env/src/engine/on_chain/impls.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -444,7 +444,7 @@ impl TypedEnvBackend for EnvInstance {\n     fn invoke_contract_delegate<E, Args, R>(\n         &mut self,\n         params: &CallParams<E, DelegateCall<E>, Args, R>,\n-    ) -> Result<R>\n+    ) -> Result<ink_primitives::MessageResult<R>>\n     where\n         E: Environment,\n         Args: scale::Encode,"
        },
        {
          "filename": "crates/ink/src/env_access.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -631,7 +631,7 @@ where\n     pub fn invoke_contract_delegate<Args, R>(\n         self,\n         params: &CallParams<E, DelegateCall<E>, Args, R>,\n-    ) -> Result<R>\n+    ) -> Result<ink_primitives::MessageResult<R>>\n     where\n         Args: scale::Encode,\n         R: scale::Decode,"
        },
        {
          "filename": "integration-tests/lang-err-integration-tests/call-builder-delegate/Cargo.toml",
          "status": "added",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -0,0 +1,32 @@\n+[package]\n+name = \"call_builder_delegate\"\n+version = \"4.2.0\"\n+authors = [\"Parity Technologies <admin@parity.io>\"]\n+edition = \"2021\"\n+publish = false\n+\n+[dependencies]\n+ink = { path = \"../../../crates/ink\", default-features = false }\n+\n+scale = { package = \"parity-scale-codec\", version = \"3\", default-features = false, features = [\"derive\"] }\n+scale-info = { version = \"2.6\", default-features = false, features = [\"derive\"], optional = true }\n+\n+incrementer = { path = \"../../incrementer\", default-features = false, features = [\"ink-as-dependency\"] }\n+\n+[dev-dependencies]\n+ink_e2e = { path = \"../../../crates/e2e\" }\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[features]\n+default = [\"std\"]\n+std = [\n+    \"ink/std\",\n+    \"scale/std\",\n+    \"scale-info/std\",\n+\n+    \"incrementer/std\",\n+]\n+ink-as-dependency = []\n+e2e-tests = []"
        },
        {
          "filename": "integration-tests/lang-err-integration-tests/call-builder-delegate/lib.rs",
          "status": "added",
          "additions": 211,
          "deletions": 0,
          "patch": "@@ -0,0 +1,211 @@\n+//! # Integration Tests for `LangError`\n+//!\n+//! This contract is used to ensure that the behavior around `LangError`s works as\n+//! expected.\n+//!\n+//! In particular, it exercises the codepaths that stem from the usage of the\n+//! [`CallBuilder`](`ink::env::call::CallBuilder`) and\n+//! [`CreateBuilder`](`ink::env::call::CreateBuilder`) structs.\n+//!\n+//! This differs from the codepath used by external tooling, such as `cargo-contract` or\n+//! the `Contracts-UI` which instead depend on methods from the Contracts pallet which are\n+//! exposed via RPC.\n+//!\n+//! Note that during testing we make use of ink!'s end-to-end testing features, so ensure\n+//! that you have a node which includes the Contracts pallet running alongside your tests.\n+\n+#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n+\n+#[ink::contract]\n+mod call_builder {\n+    use ink::env::{\n+        call::{\n+            build_call,\n+            ExecutionInput,\n+            Selector,\n+        },\n+        DefaultEnvironment,\n+    };\n+\n+    #[ink(storage)]\n+    #[derive(Default)]\n+    pub struct CallBuilderDelegateTest {\n+        /// Since we're going to `DelegateCall` into the `incrementer` contract, we need\n+        /// to make sure our storage layout matches.\n+        value: i32,\n+    }\n+\n+    impl CallBuilderDelegateTest {\n+        #[ink(constructor)]\n+        pub fn new(value: i32) -> Self {\n+            Self { value }\n+        }\n+\n+        /// Call a contract using the `CallBuilder`.\n+        ///\n+        /// Since we can't use the `CallBuilder` in a test environment directly we need\n+        /// this wrapper to test things like crafting calls with invalid\n+        /// selectors.\n+        ///\n+        /// We also wrap the output in an `Option` since we can't return a `Result`\n+        /// directly from a contract message without erroring out ourselves.\n+        #[ink(message)]\n+        pub fn delegate(\n+            &mut self,\n+            code_hash: Hash,\n+            selector: [u8; 4],\n+        ) -> Option<ink::LangError> {\n+            let result = build_call::<DefaultEnvironment>()\n+                .delegate(code_hash)\n+                .exec_input(ExecutionInput::new(Selector::new(selector)))\n+                .returns::<bool>()\n+                .try_invoke()\n+                .expect(\"Error from the Contracts pallet.\");\n+\n+            match result {\n+                Ok(_) => None,\n+                Err(e @ ink::LangError::CouldNotReadInput) => Some(e),\n+                Err(_) => {\n+                    unimplemented!(\"No other `LangError` variants exist at the moment.\")\n+                }\n+            }\n+        }\n+\n+        /// Call a contract using the `CallBuilder`.\n+        ///\n+        /// Since we can't use the `CallBuilder` in a test environment directly we need\n+        /// this wrapper to test things like crafting calls with invalid\n+        /// selectors.\n+        ///\n+        /// This message does not allow the caller to handle any `LangErrors`, for that\n+        /// use the `call` message instead.\n+        #[ink(message)]\n+        pub fn invoke(&mut self, code_hash: Hash, selector: [u8; 4]) -> i32 {\n+            use ink::env::call::build_call;\n+\n+            build_call::<DefaultEnvironment>()\n+                .delegate(code_hash)\n+                .exec_input(ExecutionInput::new(Selector::new(selector)))\n+                .returns::<i32>()\n+                .invoke()\n+        }\n+    }\n+\n+    #[cfg(all(test, feature = \"e2e-tests\"))]\n+    mod e2e_tests {\n+        use super::*;\n+\n+        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n+\n+        #[ink_e2e::test]\n+        async fn e2e_call_builder_delegate_returns_correct_value(\n+            mut client: ink_e2e::Client<C, E>,\n+        ) -> E2EResult<()> {\n+            let origin = client\n+                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n+                .await;\n+\n+            let expected_value = 42;\n+            let constructor = CallBuilderDelegateTestRef::new(expected_value);\n+            let call_builder = client\n+                .instantiate(\"call_builder_delegate\", &origin, constructor, 0, None)\n+                .await\n+                .expect(\"instantiate failed\");\n+            let mut call_builder_call = call_builder.call::<CallBuilderDelegateTest>();\n+\n+            let code_hash = client\n+                .upload(\"incrementer\", &origin, None)\n+                .await\n+                .expect(\"upload `incrementer` failed\")\n+                .code_hash;\n+\n+            let selector = ink::selector_bytes!(\"get\");\n+            let call = call_builder_call.invoke(code_hash, selector);\n+            let call_result = client\n+                .call(&origin, &call, 0, None)\n+                .await\n+                .expect(\"Client failed to call `call_builder::invoke`.\")\n+                .return_value();\n+\n+            assert_eq!(\n+                call_result, expected_value,\n+                \"Decoded an unexpected value from the call.\"\n+            );\n+\n+            Ok(())\n+        }\n+\n+        #[ink_e2e::test]\n+        async fn e2e_invalid_message_selector_can_be_handled(\n+            mut client: ink_e2e::Client<C, E>,\n+        ) -> E2EResult<()> {\n+            let origin = client\n+                .create_and_fund_account(&ink_e2e::bob(), 10_000_000_000_000)\n+                .await;\n+\n+            let constructor = CallBuilderDelegateTestRef::new(Default::default());\n+            let call_builder_contract = client\n+                .instantiate(\"call_builder_delegate\", &origin, constructor, 0, None)\n+                .await\n+                .expect(\"instantiate failed\");\n+            let mut call_builder_call =\n+                call_builder_contract.call::<CallBuilderDelegateTest>();\n+\n+            let code_hash = client\n+                .upload(\"incrementer\", &origin, None)\n+                .await\n+                .expect(\"upload `incrementer` failed\")\n+                .code_hash;\n+\n+            let selector = ink::selector_bytes!(\"invalid_selector\");\n+            let call = call_builder_call.delegate(code_hash, selector);\n+            let call_result = client\n+                .call(&origin, &call, 0, None)\n+                .await\n+                .expect(\"Calling `call_builder::delegate` failed\");\n+\n+            assert!(matches!(\n+                call_result.return_value(),\n+                Some(ink::LangError::CouldNotReadInput)\n+            ));\n+\n+            Ok(())\n+        }\n+\n+        #[ink_e2e::test]\n+        async fn e2e_invalid_message_selector_panics_on_invoke(\n+            mut client: ink_e2e::Client<C, E>,\n+        ) -> E2EResult<()> {\n+            let origin = client\n+                .create_and_fund_account(&ink_e2e::charlie(), 10_000_000_000_000)\n+                .await;\n+\n+            let constructor = CallBuilderDelegateTestRef::new(Default::default());\n+            let call_builder_contract = client\n+                .instantiate(\"call_builder_delegate\", &origin, constructor, 0, None)\n+                .await\n+                .expect(\"instantiate failed\");\n+            let mut call_builder_call =\n+                call_builder_contract.call::<CallBuilderDelegateTest>();\n+\n+            let code_hash = client\n+                .upload(\"incrementer\", &origin, None)\n+                .await\n+                .expect(\"upload `incrementer` failed\")\n+                .code_hash;\n+\n+            // Since `LangError`s can't be handled by the `CallBuilder::invoke()` method\n+            // we expect this to panic.\n+            let selector = ink::selector_bytes!(\"invalid_selector\");\n+            let call = call_builder_call.invoke(code_hash, selector);\n+            let call_result = client.call_dry_run(&origin, &call, 0, None).await;\n+\n+            assert!(call_result.is_err());\n+            assert!(call_result\n+                .debug_message()\n+                .contains(\"Cross-contract call failed with CouldNotReadInput\"));\n+\n+            Ok(())\n+        }\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 2,
        "unique_directories": 6,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8aa3e1b5489cb93f4885a3ca85ba01e239413529",
            "date": "2025-01-09T16:22:32Z",
            "author_login": "0xwitty"
          },
          {
            "sha": "e903a5f2722b56e6bae401983a2a1c4680144b66",
            "date": "2025-01-09T16:21:58Z",
            "author_login": "DeVikingMark"
          },
          {
            "sha": "d7a66b6e87f03b477ff5f746ffec9bfb0e6da793",
            "date": "2025-01-09T16:20:22Z",
            "author_login": "Marcofann"
          },
          {
            "sha": "7b0d3cefb761d0f228ebe0f0c689ff1ff532d065",
            "date": "2025-01-09T16:19:17Z",
            "author_login": "goodfirm"
          },
          {
            "sha": "d728abf81e19fd244dc827f38538b3a0f1ea7857",
            "date": "2025-01-09T16:18:29Z",
            "author_login": "SoulcoIIector"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-253",
    "description": "ink! is an embedded domain specific language to write smart contracts in Rust for blockchains built on the Substrate framework. Starting in version 4.0.0 and prior to version 4.2.1, the return value when using delegate call mechanics, either through `CallBuilder::delegate` or `ink_env::invoke_contract_delegate`, is decoded incorrectly. This bug was related to the mechanics around decoding a call's return buffer, which was changed as part of pull request 1450. Since this feature was only released in ink! 4.0.0, no previous versions are affected. Users who have an ink! 4.x series contract should upgrade to 4.2.1 to receive a patch.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-06-14T21:15:09.790",
    "last_modified": "2024-11-21T08:07:16.673",
    "fix_date": "2023-06-14T17:44:19Z"
  },
  "references": [
    {
      "url": "https://docs.rs/ink_env/4.2.0/ink_env/call/struct.CallBuilder.html#method.delegate",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.rs/ink_env/4.2.0/ink_env/fn.invoke_contract_delegate.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/ink/commit/f1407ee9f87e5f64d467a22d26ee88f61db7f3db",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/paritytech/ink/pull/1450",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/ink/security/advisories/GHSA-853p-5678-hv8f",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://docs.rs/ink_env/4.2.0/ink_env/call/struct.CallBuilder.html#method.delegate",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://docs.rs/ink_env/4.2.0/ink_env/fn.invoke_contract_delegate.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/ink/commit/f1407ee9f87e5f64d467a22d26ee88f61db7f3db",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/paritytech/ink/pull/1450",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/paritytech/ink/security/advisories/GHSA-853p-5678-hv8f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:05:59.367505",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ink",
    "owner": "paritytech",
    "created_at": "2018-12-10T19:12:22Z",
    "updated_at": "2025-01-12T16:48:10Z",
    "pushed_at": "2025-01-14T20:00:29Z",
    "size": 346384,
    "stars": 1372,
    "forks": 443,
    "open_issues": 147,
    "watchers": 1372,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Rust": 2085376,
      "Shell": 13890,
      "WebAssembly": 697
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:56:32.045484"
  }
}