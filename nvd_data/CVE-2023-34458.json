{
  "cve_id": "CVE-2023-34458",
  "github_data": {
    "repository": "multiversx/mx-chain-go",
    "fix_commit": "babdb144f1316ab6176bf3dbd7d4621120414d43",
    "related_commits": [
      "babdb144f1316ab6176bf3dbd7d4621120414d43",
      "babdb144f1316ab6176bf3dbd7d4621120414d43"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "babdb144f1316ab6176bf3dbd7d4621120414d43",
      "commit_date": "2023-05-28T15:51:48Z",
      "author": {
        "login": "iulianpascalau",
        "type": "User",
        "stats": {
          "total_commits": 5713,
          "average_weekly_commits": 16.902366863905325,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 287
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-j494-7x2v-vvvp",
        "length": 90,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 544,
        "additions": 485,
        "deletions": 59
      },
      "files": [
        {
          "filename": "cmd/node/config/enableEpochs.toml",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -242,6 +242,9 @@\n     # RuntimeCodeSizeFixEnableEpoch represents the epoch when the code size fix in the VM is enabled\n     RuntimeCodeSizeFixEnableEpoch = 1\n \n+    # RelayedNonceFixEnableEpoch represents the epoch when the nonce fix for relayed txs is enabled\n+    RelayedNonceFixEnableEpoch = 2\n+\n     # BLSMultiSignerEnableEpoch represents the activation epoch for different types of BLS multi-signers\n     BLSMultiSignerEnableEpoch = [\n         { EnableEpoch = 0, Type = \"no-KOSK\"},"
        },
        {
          "filename": "common/enablers/enableEpochsHandler.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -118,6 +118,7 @@ func (handler *enableEpochsHandler) EpochConfirmed(epoch uint32, _ uint64) {\n \thandler.setFlagValue(epoch >= handler.enableEpochsConfig.MaxBlockchainHookCountersEnableEpoch, handler.maxBlockchainHookCountersFlag, \"maxBlockchainHookCountersFlag\")\n \thandler.setFlagValue(epoch >= handler.enableEpochsConfig.WipeSingleNFTLiquidityDecreaseEnableEpoch, handler.wipeSingleNFTLiquidityDecreaseFlag, \"wipeSingleNFTLiquidityDecreaseFlag\")\n \thandler.setFlagValue(epoch >= handler.enableEpochsConfig.AlwaysSaveTokenMetaDataEnableEpoch, handler.alwaysSaveTokenMetaDataFlag, \"alwaysSaveTokenMetaDataFlag\")\n+\thandler.setFlagValue(epoch >= handler.enableEpochsConfig.RelayedNonceFixEnableEpoch, handler.relayedNonceFixFlag, \"relayedNonceFixFlag\")\n }\n \n func (handler *enableEpochsHandler) setFlagValue(value bool, flag *atomic.Flag, flagName string) {\n@@ -215,6 +216,11 @@ func (handler *enableEpochsHandler) RefactorPeersMiniBlocksEnableEpoch() uint32\n \treturn handler.enableEpochsConfig.RefactorPeersMiniBlocksEnableEpoch\n }\n \n+// RelayedNonceFixEnableEpoch returns the epoch when relayed nonce fix becomes active\n+func (handler *enableEpochsHandler) RelayedNonceFixEnableEpoch() uint32 {\n+\treturn handler.enableEpochsConfig.RelayedNonceFixEnableEpoch\n+}\n+\n // IsInterfaceNil returns true if there is no value under the interface\n func (handler *enableEpochsHandler) IsInterfaceNil() bool {\n \treturn handler == nil"
        },
        {
          "filename": "common/enablers/enableEpochsHandler_test.go",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -1,6 +1,7 @@\n package enablers\n \n import (\n+\t\"math\"\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-core-go/core/check\"\n@@ -91,6 +92,7 @@ func createEnableEpochsConfig() config.EnableEpochs {\n \t\tWipeSingleNFTLiquidityDecreaseEnableEpoch:         75,\n \t\tAlwaysSaveTokenMetaDataEnableEpoch:                76,\n \t\tRuntimeCodeSizeFixEnableEpoch:                     77,\n+\t\tRelayedNonceFixEnableEpoch:                        78,\n \t}\n }\n \n@@ -129,7 +131,7 @@ func TestNewEnableEpochsHandler_EpochConfirmed(t *testing.T) {\n \t\thandler, _ := NewEnableEpochsHandler(cfg, &epochNotifier.EpochNotifierStub{})\n \t\trequire.False(t, check.IfNil(handler))\n \n-\t\thandler.EpochConfirmed(77, 0)\n+\t\thandler.EpochConfirmed(math.MaxUint32, 0)\n \n \t\tassert.Equal(t, cfg.BlockGasAndFeesReCheckEnableEpoch, handler.BlockGasAndFeesReCheckEnableEpoch())\n \t\tassert.True(t, handler.IsSCDeployFlagEnabled())\n@@ -213,11 +215,12 @@ func TestNewEnableEpochsHandler_EpochConfirmed(t *testing.T) {\n \t\tassert.True(t, handler.IsMaxBlockchainHookCountersFlagEnabled())\n \t\tassert.True(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n \t\tassert.True(t, handler.IsRuntimeCodeSizeFixEnabled())\n+\t\tassert.True(t, handler.IsRelayedNonceFixEnabled())\n \t})\n \tt.Run(\"flags with == condition should be set, along with all >=\", func(t *testing.T) {\n \t\tt.Parallel()\n \n-\t\tepoch := uint32(78)\n+\t\tepoch := uint32(math.MaxUint32)\n \t\tcfg := createEnableEpochsConfig()\n \t\tcfg.StakingV2EnableEpoch = epoch\n \t\tcfg.ESDTEnableEpoch = epoch\n@@ -313,6 +316,7 @@ func TestNewEnableEpochsHandler_EpochConfirmed(t *testing.T) {\n \t\tassert.True(t, handler.IsWipeSingleNFTLiquidityDecreaseEnabled())\n \t\tassert.True(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n \t\tassert.True(t, handler.IsRuntimeCodeSizeFixEnabled())\n+\t\tassert.True(t, handler.IsRelayedNonceFixEnabled())\n \t})\n \tt.Run(\"flags with < should be set\", func(t *testing.T) {\n \t\tt.Parallel()\n@@ -408,5 +412,6 @@ func TestNewEnableEpochsHandler_EpochConfirmed(t *testing.T) {\n \t\tassert.False(t, handler.IsWipeSingleNFTLiquidityDecreaseEnabled())\n \t\tassert.False(t, handler.IsAlwaysSaveTokenMetaDataEnabled())\n \t\tassert.False(t, handler.IsRuntimeCodeSizeFixEnabled())\n+\t\tassert.False(t, handler.IsRelayedNonceFixEnabled())\n \t})\n }"
        },
        {
          "filename": "common/enablers/epochFlags.go",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -90,6 +90,7 @@ type epochFlagsHolder struct {\n \tmaxBlockchainHookCountersFlag               *atomic.Flag\n \twipeSingleNFTLiquidityDecreaseFlag          *atomic.Flag\n \talwaysSaveTokenMetaDataFlag                 *atomic.Flag\n+\trelayedNonceFixFlag                         *atomic.Flag\n }\n \n func newEpochFlagsHolder() *epochFlagsHolder {\n@@ -179,6 +180,7 @@ func newEpochFlagsHolder() *epochFlagsHolder {\n \t\tmaxBlockchainHookCountersFlag:               &atomic.Flag{},\n \t\twipeSingleNFTLiquidityDecreaseFlag:          &atomic.Flag{},\n \t\talwaysSaveTokenMetaDataFlag:                 &atomic.Flag{},\n+\t\trelayedNonceFixFlag:                         &atomic.Flag{},\n \t}\n }\n \n@@ -659,3 +661,8 @@ func (holder *epochFlagsHolder) IsWipeSingleNFTLiquidityDecreaseEnabled() bool {\n func (holder *epochFlagsHolder) IsAlwaysSaveTokenMetaDataEnabled() bool {\n \treturn holder.alwaysSaveTokenMetaDataFlag.IsSet()\n }\n+\n+// IsRelayedNonceFixEnabled returns true if relayedNonceFixFlag is enabled\n+func (holder *epochFlagsHolder) IsRelayedNonceFixEnabled() bool {\n+\treturn holder.relayedNonceFixFlag.IsSet()\n+}"
        },
        {
          "filename": "common/interface.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -327,6 +327,7 @@ type EnableEpochsHandler interface {\n \tIsMaxBlockchainHookCountersFlagEnabled() bool\n \tIsWipeSingleNFTLiquidityDecreaseEnabled() bool\n \tIsAlwaysSaveTokenMetaDataEnabled() bool\n+\tIsRelayedNonceFixEnabled() bool\n \n \tIsInterfaceNil() bool\n }"
        },
        {
          "filename": "config/epochConfig.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -93,6 +93,7 @@ type EnableEpochs struct {\n \tMaxBlockchainHookCountersEnableEpoch              uint32\n \tWipeSingleNFTLiquidityDecreaseEnableEpoch         uint32\n \tAlwaysSaveTokenMetaDataEnableEpoch                uint32\n+\tRelayedNonceFixEnableEpoch                        uint32\n \tBLSMultiSignerEnableEpoch                         []MultiSignerConfig\n }\n "
        },
        {
          "filename": "config/tomlConfig_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -684,6 +684,9 @@ func TestEnableEpochConfig(t *testing.T) {\n     # RuntimeMemStoreLimitEnableEpoch represents the epoch when the condition for Runtime MemStore is enabled\n     RuntimeMemStoreLimitEnableEpoch = 63\n \n+    # RelayedNonceFixEnableEpoch represents the epoch when the nonce fix for relayed txs is enabled\n+    RelayedNonceFixEnableEpoch = 64\n+\n     # MaxNodesChangeEnableEpoch holds configuration for changing the maximum number of nodes and the enabling epoch\n     MaxNodesChangeEnableEpoch = [\n         { EpochEnable = 44, MaxNumNodes = 2169, NodesToShufflePerShard = 80 },\n@@ -779,6 +782,7 @@ func TestEnableEpochConfig(t *testing.T) {\n \t\t\tAlwaysSaveTokenMetaDataEnableEpoch:          61,\n \t\t\tRuntimeCodeSizeFixEnableEpoch:               62,\n \t\t\tRuntimeMemStoreLimitEnableEpoch:             63,\n+\t\t\tRelayedNonceFixEnableEpoch:                  64,\n \t\t\tBLSMultiSignerEnableEpoch: []MultiSignerConfig{\n \t\t\t\t{\n \t\t\t\t\tEnableEpoch: 0,"
        },
        {
          "filename": "integrationTests/multiShard/relayedTx/edgecases/edgecases_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -11,7 +11,7 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n )\n \n-func TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWrongNonce(t *testing.T) {\n+func TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWrongNonceShouldNotIncrementUserAccNonce(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"this is not a short test\")\n \t}\n@@ -68,7 +68,7 @@ func TestRelayedTransactionInMultiShardEnvironmentWithNormalTxButWrongNonce(t *t\n \tfor _, player := range players {\n \t\taccount := relayedTx.GetUserAccount(nodes, player.Address)\n \t\tassert.True(t, account.GetBalance().Cmp(big.NewInt(0)) == 0)\n-\t\tassert.Equal(t, uint64(nrRoundsToTest)*2, account.GetNonce())\n+\t\tassert.Equal(t, uint64(0), account.GetNonce())\n \t}\n \n \texpectedBalance := big.NewInt(0).Sub(relayerInitialValue, totalFees)"
        },
        {
          "filename": "integrationTests/testInitializer.go",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -59,6 +59,7 @@ import (\n \ttestStorage \"github.com/multiversx/mx-chain-go/testscommon/state\"\n \t\"github.com/multiversx/mx-chain-go/testscommon/statusHandler\"\n \tstatusHandlerMock \"github.com/multiversx/mx-chain-go/testscommon/statusHandler\"\n+\t\"github.com/multiversx/mx-chain-go/testscommon/txDataBuilder\"\n \t\"github.com/multiversx/mx-chain-go/trie\"\n \t\"github.com/multiversx/mx-chain-go/trie/hashesHolder\"\n \t\"github.com/multiversx/mx-chain-go/vm\"\n@@ -2538,3 +2539,22 @@ func SaveDelegationContractsList(nodes []*TestProcessorNode) {\n \t\t_, _ = n.AccntState.Commit()\n \t}\n }\n+\n+// PrepareRelayedTxDataV1 repares the data for a relayed transaction V1\n+func PrepareRelayedTxDataV1(innerTx *transaction.Transaction) []byte {\n+\tuserTxBytes, _ := TestMarshalizer.Marshal(innerTx)\n+\treturn []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxBytes))\n+}\n+\n+// PrepareRelayedTxDataV2 prepares the data for a relayed transaction V2\n+func PrepareRelayedTxDataV2(innerTx *transaction.Transaction) []byte {\n+\tdataBuilder := txDataBuilder.NewBuilder()\n+\ttxData := dataBuilder.\n+\t\tFunc(core.RelayedTransactionV2).\n+\t\tBytes(innerTx.RcvAddr).\n+\t\tInt64(int64(innerTx.Nonce)).\n+\t\tBytes(innerTx.Data).\n+\t\tBytes(innerTx.Signature)\n+\n+\treturn txData.ToBytes()\n+}"
        },
        {
          "filename": "integrationTests/vm/txsFee/multiShard/relayedBuiltInFunctions_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -56,7 +56,7 @@ func TestRelayedBuiltInFunctionExecuteOnRelayerAndDstShardShouldWork(t *testing.\n \n \t_, _ = vm.CreateAccount(testContextRelayer.Accounts, relayerAddr, 0, big.NewInt(15000))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/multiShard/relayedMoveBalance_test.go",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -6,6 +6,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n@@ -34,7 +35,7 @@ func TestRelayedMoveBalanceRelayerShard0InnerTxSenderAndReceiverShard1ShouldWork\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, []byte(\"aaaa\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -80,7 +81,7 @@ func TestRelayedMoveBalanceRelayerAndInnerTxSenderShard0ReceiverShard1(t *testin\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, nil)\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -131,7 +132,7 @@ func TestRelayedMoveBalanceExecuteOnSourceAndDestination(t *testing.T) {\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, nil)\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -193,7 +194,7 @@ func TestRelayedMoveBalanceExecuteOnSourceAndDestinationRelayerAndInnerTxSenderS\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -253,7 +254,7 @@ func TestRelayedMoveBalanceRelayerAndInnerTxReceiverShard0SenderShard1(t *testin\n \n \tinnerTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -329,7 +330,7 @@ func TestMoveBalanceRelayerShard0InnerTxSenderShard1InnerTxReceiverShard2ShouldW\n \n \tinnerTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, nil)\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/multiShard/relayedScDeploy_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -8,6 +8,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n@@ -39,7 +40,7 @@ func TestRelayedSCDeployShouldWork(t *testing.T) {\n \tscCode := wasm.GetSCCode(contractPath)\n \tuserTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/multiShard/relayedTxScCalls_test.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -10,6 +10,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n@@ -57,7 +58,7 @@ func TestRelayedTxScCallMultiShardShouldWork(t *testing.T) {\n \tgasLimit := uint64(500)\n \n \tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddr, gasPrice, gasLimit, []byte(\"increment\"))\n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -162,7 +163,7 @@ func TestRelayedTxScCallMultiShardFailOnInnerTxDst(t *testing.T) {\n \tgasLimit := uint64(500)\n \n \tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddr, gasPrice, gasLimit, []byte(\"incremeno\"))\n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedAsyncCall_test.go",
          "status": "modified",
          "additions": 29,
          "deletions": 4,
          "patch": "@@ -11,19 +11,42 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n+\t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n )\n \n func TestRelayedAsyncCallShouldWork(t *testing.T) {\n-\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n+\tsenderAddr := []byte(\"12345678901234567890123456789011\")\n+\n+\tt.Run(\"nonce fix is disabled, should increase the sender's nonce\", func(t *testing.T) {\n+\t\ttestContext := testRelayedAsyncCallShouldWork(t, config.EnableEpochs{\n+\t\t\tRelayedNonceFixEnableEpoch: 100000,\n+\t\t}, senderAddr)\n+\t\tdefer testContext.Close()\n+\n+\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n+\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n+\t})\n+\tt.Run(\"nonce fix is enabled, should still increase the sender's nonce\", func(t *testing.T) {\n+\t\ttestContext := testRelayedAsyncCallShouldWork(t, config.EnableEpochs{\n+\t\t\tRelayedNonceFixEnableEpoch: 0,\n+\t\t}, senderAddr)\n+\t\tdefer testContext.Close()\n+\n+\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n+\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n+\t})\n+}\n+\n+func testRelayedAsyncCallShouldWork(t *testing.T, enableEpochs config.EnableEpochs, senderAddr []byte) *vm.VMTestContext {\n+\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(enableEpochs)\n \trequire.Nil(t, err)\n-\tdefer testContext.Close()\n \n \tegldBalance := big.NewInt(100000000)\n-\tsenderAddr := []byte(\"12345678901234567890123456789011\")\n \townerAddr := []byte(\"12345678901234567890123456789010\")\n \trelayerAddr := []byte(\"12345678901234567890123456789017\")\n \n@@ -48,7 +71,7 @@ func TestRelayedAsyncCallShouldWork(t *testing.T) {\n \n \tinnerTx := vm.CreateTransaction(0, big.NewInt(0), senderAddr, secondSCAddress, gasPrice, gasLimit, []byte(\"doSomething\"))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, senderAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -69,4 +92,6 @@ func TestRelayedAsyncCallShouldWork(t *testing.T) {\n \n \trequire.Equal(t, big.NewInt(50001950), testContext.TxFeeHandler.GetAccumulatedFees())\n \trequire.Equal(t, big.NewInt(4999988), testContext.TxFeeHandler.GetDeveloperFees())\n+\n+\treturn testContext\n }"
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedAsyncESDT_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -11,6 +11,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n@@ -54,7 +55,7 @@ func TestRelayedAsyncESDTCallShouldWork(t *testing.T) {\n \tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n \tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractHalf\")))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -113,7 +114,7 @@ func TestRelayedAsyncESDTCall_InvalidCallFirstContract(t *testing.T) {\n \tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n \tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractRejected\")))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -172,7 +173,7 @@ func TestRelayedAsyncESDTCall_InvalidOutOfGas(t *testing.T) {\n \tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, firstSCAddress, token, big.NewInt(5000), gasPrice, gasLimit)\n \tinnerTx.Data = []byte(string(innerTx.Data) + \"@\" + hex.EncodeToString([]byte(\"transferToSecondContractHalf\")))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedBuiltInFunctions_test.go",
          "status": "modified",
          "additions": 28,
          "deletions": 7,
          "patch": "@@ -42,7 +42,7 @@ func TestRelayedBuildInFunctionChangeOwnerCallShouldWork(t *testing.T) {\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n \n@@ -89,7 +89,7 @@ func TestRelayedBuildInFunctionChangeOwnerCallWrongOwnerShouldConsumeGas(t *test\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n \n@@ -135,7 +135,7 @@ func TestRelayedBuildInFunctionChangeOwnerInvalidAddressShouldConsumeGas(t *test\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n \n@@ -162,7 +162,28 @@ func TestRelayedBuildInFunctionChangeOwnerInvalidAddressShouldConsumeGas(t *test\n }\n \n func TestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n-\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n+\tt.Run(\"nonce fix is disabled, should increase the sender's nonce\", func(t *testing.T) {\n+\t\ttestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t,\n+\t\t\tconfig.EnableEpochs{\n+\t\t\t\tRelayedNonceFixEnableEpoch: 1000,\n+\t\t\t},\n+\t\t\t2)\n+\t})\n+\tt.Run(\"nonce fix is enabled, should still increase the sender's nonce\", func(t *testing.T) {\n+\t\ttestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(t,\n+\t\t\tconfig.EnableEpochs{\n+\t\t\t\tRelayedNonceFixEnableEpoch: 0,\n+\t\t\t},\n+\t\t\t2)\n+\t})\n+}\n+\n+func testRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeGas(\n+\tt *testing.T,\n+\tenableEpochs config.EnableEpochs,\n+\texpectedOwnerNonce uint64,\n+) {\n+\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(enableEpochs)\n \trequire.Nil(t, err)\n \tdefer testContext.Close()\n \n@@ -180,7 +201,7 @@ func TestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeG\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n \n@@ -196,7 +217,7 @@ func TestRelayedBuildInFunctionChangeOwnerCallInsufficientGasLimitShouldConsumeG\n \tvm.TestAccount(t, testContext.Accounts, relayerAddr, 1, expectedBalanceRelayer)\n \n \texpectedBalance := big.NewInt(89030)\n-\tvm.TestAccount(t, testContext.Accounts, owner, 2, expectedBalance)\n+\tvm.TestAccount(t, testContext.Accounts, owner, expectedOwnerNonce, expectedBalance)\n \n \t// check accumulated fees\n \taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n@@ -225,7 +246,7 @@ func TestRelayedBuildInFunctionChangeOwnerCallOutOfGasShouldConsumeGas(t *testin\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, owner, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedDns_test.go",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -11,6 +11,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n@@ -40,7 +41,7 @@ func TestRelayedTxDnsTransaction_ShouldWork(t *testing.T) {\n \t// create user name for sender\n \tinnerTx := vm.CreateTransaction(0, big.NewInt(0), sndAddr, scAddress, gasPrice, gasLimit, txData)\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -62,7 +63,7 @@ func TestRelayedTxDnsTransaction_ShouldWork(t *testing.T) {\n \t// create user name for receiver\n \tinnerTx = vm.CreateTransaction(0, big.NewInt(0), rcvAddr, scAddress, gasPrice, gasLimit, txData)\n \n-\trtxData = utils.PrepareRelayerTxData(innerTx)\n+\trtxData = integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit = 1 + gasLimit + uint64(len(rtxData))\n \trtx = vm.CreateTransaction(1, innerTx.Value, relayerAddr, rcvAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -84,7 +85,7 @@ func TestRelayedTxDnsTransaction_ShouldWork(t *testing.T) {\n \tinnerTx.SndUserName = sndAddrUserName\n \tinnerTx.RcvUserName = rcvAddrUserName\n \n-\trtxData = utils.PrepareRelayerTxData(innerTx)\n+\trtxData = integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit = 1 + gasLimit + uint64(len(rtxData))\n \trtx = vm.CreateTransaction(2, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedESDT_test.go",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -10,6 +10,7 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n@@ -35,7 +36,7 @@ func TestRelayedESDTTransferShouldWork(t *testing.T) {\n \tgasLimit := uint64(40)\n \tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, rcvAddr, token, big.NewInt(100), gasPrice, gasLimit)\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -81,7 +82,7 @@ func TestTestRelayedESTTransferNotEnoughESTValueShouldConsumeGas(t *testing.T) {\n \tgasLimit := uint64(40)\n \tinnerTx := utils.CreateESDTTransferTx(0, sndAddr, rcvAddr, token, big.NewInt(100000001), gasPrice, gasLimit)\n \n-\trtxData := utils.PrepareRelayerTxData(innerTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(innerTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, innerTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedMoveBalance_test.go",
          "status": "modified",
          "additions": 196,
          "deletions": 6,
          "patch": "@@ -4,11 +4,16 @@ import (\n \t\"math/big\"\n \t\"testing\"\n \n+\t\"github.com/multiversx/mx-chain-core-go/data/block\"\n+\tdataTransaction \"github.com/multiversx/mx-chain-core-go/data/transaction\"\n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n-\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \t\"github.com/multiversx/mx-chain-go/process\"\n+\t\"github.com/multiversx/mx-chain-go/sharding\"\n+\t\"github.com/multiversx/mx-chain-go/testscommon/integrationtests\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n+\t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n )\n \n@@ -32,7 +37,7 @@ func TestRelayedMoveBalanceShouldWork(t *testing.T) {\n \t// gas consumed = 50\n \tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(100), sndAddr, rcvAddr, gasPrice, gasLimit, []byte(\"aaaa\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -73,7 +78,7 @@ func TestRelayedMoveBalanceInvalidGasLimitShouldConsumeGas(t *testing.T) {\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 2 + userTx.GasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n \n@@ -105,7 +110,7 @@ func TestRelayedMoveBalanceInvalidUserTxShouldConsumeGas(t *testing.T) {\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + userTx.GasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n \n@@ -124,7 +129,9 @@ func TestRelayedMoveBalanceInvalidUserTxShouldConsumeGas(t *testing.T) {\n }\n \n func TestRelayedMoveBalanceInvalidUserTxValueShouldConsumeGas(t *testing.T) {\n-\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{})\n+\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{\n+\t\tRelayedNonceFixEnableEpoch: 1,\n+\t})\n \trequire.Nil(t, err)\n \tdefer testContext.Close()\n \n@@ -137,7 +144,7 @@ func TestRelayedMoveBalanceInvalidUserTxValueShouldConsumeGas(t *testing.T) {\n \n \t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + userTx.GasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, big.NewInt(100), relayerAddr, sndAddr, 1, rTxGasLimit, rtxData)\n \n@@ -154,3 +161,186 @@ func TestRelayedMoveBalanceInvalidUserTxValueShouldConsumeGas(t *testing.T) {\n \taccumulatedFees := testContext.TxFeeHandler.GetAccumulatedFees()\n \trequire.Equal(t, big.NewInt(275), accumulatedFees)\n }\n+\n+func TestRelayedMoveBalanceHigherNonce(t *testing.T) {\n+\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{\n+\t\tRelayedNonceFixEnableEpoch: 1,\n+\t})\n+\trequire.Nil(t, err)\n+\tdefer testContext.Close()\n+\n+\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n+\tsndAddr := []byte(\"12345678901234567890123456789012\")\n+\trcvAddr := []byte(\"12345678901234567890123456789022\")\n+\n+\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 0, big.NewInt(0))\n+\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n+\tuserTx := vm.CreateTransaction(100, big.NewInt(150), sndAddr, rcvAddr, 1, 100, nil)\n+\n+\tt.Run(\"inactive flag should increment\", func(t *testing.T) {\n+\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n+\n+\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce+1, senderAccount.GetNonce())\n+\n+\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce+2, senderAccount.GetNonce())\n+\t})\n+\tt.Run(\"active flag should not increment\", func(t *testing.T) {\n+\t\ttestContext.EpochNotifier.CheckEpoch(&block.Header{Epoch: 1})\n+\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n+\n+\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n+\n+\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n+\t})\n+}\n+\n+func TestRelayedMoveBalanceLowerNonce(t *testing.T) {\n+\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(config.EnableEpochs{\n+\t\tRelayedNonceFixEnableEpoch: 1,\n+\t})\n+\trequire.Nil(t, err)\n+\tdefer testContext.Close()\n+\n+\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n+\tsndAddr := []byte(\"12345678901234567890123456789012\")\n+\trcvAddr := []byte(\"12345678901234567890123456789022\")\n+\n+\t_, _ = vm.CreateAccount(testContext.Accounts, sndAddr, 5, big.NewInt(0))\n+\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(3000))\n+\tuserTx := vm.CreateTransaction(4, big.NewInt(150), sndAddr, rcvAddr, 1, 100, nil)\n+\n+\tt.Run(\"inactive flag should increment\", func(t *testing.T) {\n+\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n+\n+\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce+1, senderAccount.GetNonce())\n+\n+\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce+2, senderAccount.GetNonce())\n+\t})\n+\tt.Run(\"active flag should not increment\", func(t *testing.T) {\n+\t\ttestContext.EpochNotifier.CheckEpoch(&block.Header{Epoch: 1})\n+\t\tinitialSenderNonce := getAccount(t, testContext, sndAddr).GetNonce()\n+\n+\t\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount := getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n+\n+\t\trtxDataV2 := integrationTests.PrepareRelayedTxDataV2(userTx)\n+\t\texecuteRelayedTransaction(t, testContext, relayerAddr, userTx, rtxDataV2, big.NewInt(0), sndAddr, vmcommon.UserError)\n+\n+\t\tsenderAccount = getAccount(t, testContext, sndAddr)\n+\t\trequire.NotNil(t, senderAccount)\n+\t\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n+\t})\n+}\n+\n+func TestRelayedMoveBalanceHigherNonceWithActivatedFixCrossShard(t *testing.T) {\n+\tenableEpochs := config.EnableEpochs{\n+\t\tRelayedNonceFixEnableEpoch: 0,\n+\t}\n+\n+\tshardCoordinator0, _ := sharding.NewMultiShardCoordinator(2, 0)\n+\ttestContext0, err := vm.CreatePreparedTxProcessorWithVMsWithShardCoordinatorDBAndGas(\n+\t\tenableEpochs,\n+\t\tshardCoordinator0,\n+\t\tintegrationtests.CreateMemUnit(),\n+\t\tvm.CreateMockGasScheduleNotifier(),\n+\t)\n+\trequire.Nil(t, err)\n+\n+\tshardCoordinator1, _ := sharding.NewMultiShardCoordinator(2, 1)\n+\ttestContext1, err := vm.CreatePreparedTxProcessorWithVMsWithShardCoordinatorDBAndGas(\n+\t\tenableEpochs,\n+\t\tshardCoordinator1,\n+\t\tintegrationtests.CreateMemUnit(),\n+\t\tvm.CreateMockGasScheduleNotifier(),\n+\t)\n+\trequire.Nil(t, err)\n+\tdefer testContext0.Close()\n+\tdefer testContext1.Close()\n+\n+\trelayerAddr := []byte(\"relayer-000000000000000000000000\")\n+\tassert.Equal(t, uint32(0), shardCoordinator0.ComputeId(relayerAddr)) // shard 0\n+\tsndAddr := []byte(\"sender-1111111111111111111111111\")\n+\tassert.Equal(t, uint32(1), shardCoordinator0.ComputeId(sndAddr)) // shard 1\n+\trcvAddr := []byte(\"receiver-22222222222222222222222\")\n+\tassert.Equal(t, uint32(0), shardCoordinator0.ComputeId(rcvAddr)) // shard 0\n+\n+\t_, _ = vm.CreateAccount(testContext0.Accounts, relayerAddr, 0, big.NewInt(3000)) // create relayer in shard 0\n+\t_, _ = vm.CreateAccount(testContext1.Accounts, sndAddr, 0, big.NewInt(0))        // create sender in shard 1\n+\n+\tuserTx := vm.CreateTransaction(1, big.NewInt(150), sndAddr, rcvAddr, 1, 100, nil)\n+\tinitialSenderNonce := getAccount(t, testContext1, sndAddr).GetNonce()\n+\n+\trtxDataV1 := integrationTests.PrepareRelayedTxDataV1(userTx)\n+\texecuteRelayedTransaction(t, testContext0, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.Ok)\n+\n+\tresults := testContext0.GetIntermediateTransactions(t)\n+\tassert.Equal(t, 0, len(results)) // no scrs, the exact relayed tx will be executed on the receiver shard\n+\n+\texecuteRelayedTransaction(t, testContext1, relayerAddr, userTx, rtxDataV1, big.NewInt(100), sndAddr, vmcommon.UserError)\n+\n+\tsenderAccount := getAccount(t, testContext1, sndAddr)\n+\trequire.NotNil(t, senderAccount)\n+\tassert.Equal(t, initialSenderNonce, senderAccount.GetNonce())\n+}\n+\n+func executeRelayedTransaction(\n+\ttb testing.TB,\n+\ttestContext *vm.VMTestContext,\n+\trelayerAddress []byte,\n+\tuserTx *dataTransaction.Transaction,\n+\tuserTxPrepared []byte,\n+\tvalue *big.Int,\n+\tsenderAddress []byte,\n+\texpectedReturnCode vmcommon.ReturnCode,\n+) {\n+\trelayerAccount := getAccount(tb, testContext, relayerAddress)\n+\tgasLimit := 1 + userTx.GasLimit + uint64(len(userTxPrepared))\n+\n+\trelayedTx := vm.CreateTransaction(relayerAccount.GetNonce(), value, relayerAddress, senderAddress, 1, gasLimit, userTxPrepared)\n+\tretCode, _ := testContext.TxProcessor.ProcessTransaction(relayedTx)\n+\trequire.Equal(tb, expectedReturnCode, retCode)\n+\n+\t_, err := testContext.Accounts.Commit()\n+\trequire.Nil(tb, err)\n+}\n+\n+func getAccount(tb testing.TB, testContext *vm.VMTestContext, address []byte) vmcommon.UserAccountHandler {\n+\taccount, err := testContext.Accounts.LoadAccount(address)\n+\trequire.Nil(tb, err)\n+\n+\treturn account.(vmcommon.UserAccountHandler)\n+}"
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedScCalls_test.go",
          "status": "modified",
          "additions": 78,
          "deletions": 5,
          "patch": "@@ -11,9 +11,11 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n+\t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n )\n \n@@ -35,7 +37,7 @@ func TestRelayedScCallShouldWork(t *testing.T) {\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -78,7 +80,7 @@ func TestRelayedScCallContractNotFoundShouldConsumeGas(t *testing.T) {\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddrBytes, gasPrice, gasLimit, []byte(\"increment\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -118,7 +120,7 @@ func TestRelayedScCallInvalidMethodShouldConsumeGas(t *testing.T) {\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"invalidMethod\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -158,7 +160,7 @@ func TestRelayedScCallInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -197,7 +199,7 @@ func TestRelayedScCallOutOfGasShouldConsumeGas(t *testing.T) {\n \n \tuserTx := vm.CreateTransaction(0, big.NewInt(100), sndAddr, scAddress, gasPrice, gasLimit, []byte(\"increment\"))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -218,3 +220,74 @@ func TestRelayedScCallOutOfGasShouldConsumeGas(t *testing.T) {\n \tdeveloperFees := testContext.TxFeeHandler.GetDeveloperFees()\n \trequire.Equal(t, big.NewInt(368), developerFees)\n }\n+\n+func TestRelayedDeployInvalidContractShouldIncrementNonceOnSender(t *testing.T) {\n+\tsenderAddr := []byte(\"12345678901234567890123456789011\")\n+\n+\tt.Run(\"nonce fix is disabled, should increase the sender's nonce if inner tx has correct nonce\", func(t *testing.T) {\n+\t\ttestContext := testRelayedDeployInvalidContractShouldIncrementNonceOnSender(t, config.EnableEpochs{\n+\t\t\tRelayedNonceFixEnableEpoch: 100000,\n+\t\t},\n+\t\t\tsenderAddr,\n+\t\t\t0)\n+\t\tdefer testContext.Close()\n+\n+\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n+\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n+\t})\n+\tt.Run(\"nonce fix is enabled, should still increase the sender's nonce if inner tx has correct nonce\", func(t *testing.T) {\n+\t\ttestContext := testRelayedDeployInvalidContractShouldIncrementNonceOnSender(t, config.EnableEpochs{\n+\t\t\tRelayedNonceFixEnableEpoch: 0,\n+\t\t},\n+\t\t\tsenderAddr,\n+\t\t\t0)\n+\t\tdefer testContext.Close()\n+\n+\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n+\t\tassert.Equal(t, uint64(1), senderAccount.GetNonce())\n+\t})\n+\tt.Run(\"nonce fix is enabled, should not increase the sender's nonce if inner tx has higher nonce\", func(t *testing.T) {\n+\t\ttestContext := testRelayedDeployInvalidContractShouldIncrementNonceOnSender(t, config.EnableEpochs{\n+\t\t\tRelayedNonceFixEnableEpoch: 0,\n+\t\t},\n+\t\t\tsenderAddr,\n+\t\t\t1) // higher nonce, the current is 0\n+\t\tdefer testContext.Close()\n+\n+\t\tsenderAccount := getAccount(t, testContext, senderAddr)\n+\t\tassert.Equal(t, uint64(0), senderAccount.GetNonce())\n+\t})\n+}\n+\n+func testRelayedDeployInvalidContractShouldIncrementNonceOnSender(\n+\tt *testing.T,\n+\tenableEpochs config.EnableEpochs,\n+\tsenderAddr []byte,\n+\tsenderNonce uint64,\n+) *vm.VMTestContext {\n+\ttestContext, err := vm.CreatePreparedTxProcessorWithVMs(enableEpochs)\n+\trequire.Nil(t, err)\n+\n+\trelayerAddr := []byte(\"12345678901234567890123456789033\")\n+\tgasPrice := uint64(10)\n+\tgasLimit := uint64(20)\n+\n+\t_, _ = vm.CreateAccount(testContext.Accounts, senderAddr, 0, big.NewInt(0))\n+\t_, _ = vm.CreateAccount(testContext.Accounts, relayerAddr, 0, big.NewInt(30000))\n+\n+\temptyAddress := make([]byte, len(senderAddr))\n+\tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(100), senderAddr, emptyAddress, gasPrice, gasLimit, nil)\n+\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n+\trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n+\trtx := vm.CreateTransaction(0, userTx.Value, relayerAddr, senderAddr, gasPrice, rTxGasLimit, rtxData)\n+\n+\tretCode, err := testContext.TxProcessor.ProcessTransaction(rtx)\n+\trequire.Equal(t, vmcommon.UserError, retCode)\n+\trequire.Nil(t, err)\n+\n+\t_, err = testContext.Accounts.Commit()\n+\trequire.Nil(t, err)\n+\n+\treturn testContext\n+}"
        },
        {
          "filename": "integrationTests/vm/txsFee/relayedScDeploy_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -10,8 +10,8 @@ import (\n \t\"testing\"\n \n \t\"github.com/multiversx/mx-chain-go/config\"\n+\t\"github.com/multiversx/mx-chain-go/integrationTests\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm\"\n-\t\"github.com/multiversx/mx-chain-go/integrationTests/vm/txsFee/utils\"\n \t\"github.com/multiversx/mx-chain-go/integrationTests/vm/wasm\"\n \tvmcommon \"github.com/multiversx/mx-chain-vm-common-go\"\n \t\"github.com/stretchr/testify/require\"\n@@ -36,7 +36,7 @@ func TestRelayedScDeployShouldWork(t *testing.T) {\n \tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n \tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -79,7 +79,7 @@ func TestRelayedScDeployInvalidCodeShouldConsumeGas(t *testing.T) {\n \tscCodeBytes = append(scCodeBytes, []byte(\"aaaaa\")...)\n \tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, scCodeBytes)\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -119,7 +119,7 @@ func TestRelayedScDeployInsufficientGasLimitShouldConsumeGas(t *testing.T) {\n \tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n \tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n \n@@ -159,7 +159,7 @@ func TestRelayedScDeployOutOfGasShouldConsumeGas(t *testing.T) {\n \tscCode := wasm.GetSCCode(\"../wasm/testdata/misc/fib_wasm/output/fib_wasm.wasm\")\n \tuserTx := vm.CreateTransaction(senderNonce, big.NewInt(0), sndAddr, vm.CreateEmptyAddress(), gasPrice, gasLimit, []byte(wasm.CreateDeployTxData(scCode)))\n \n-\trtxData := utils.PrepareRelayerTxData(userTx)\n+\trtxData := integrationTests.PrepareRelayedTxDataV1(userTx)\n \trTxGasLimit := 1 + gasLimit + uint64(len(rtxData))\n \trtx := vm.CreateTransaction(0, big.NewInt(0), relayerAddr, sndAddr, gasPrice, rTxGasLimit, rtxData)\n "
        },
        {
          "filename": "integrationTests/vm/txsFee/utils/utils.go",
          "status": "modified",
          "additions": 0,
          "deletions": 7,
          "patch": "@@ -11,7 +11,6 @@ import (\n \t\"strings\"\n \t\"testing\"\n \n-\t\"github.com/multiversx/mx-chain-core-go/core\"\n \t\"github.com/multiversx/mx-chain-core-go/data\"\n \t\"github.com/multiversx/mx-chain-core-go/data/scheduled\"\n \t\"github.com/multiversx/mx-chain-core-go/data/smartContractResult\"\n@@ -257,12 +256,6 @@ func DoDeployDNS(t *testing.T, testContext *vm.VMTestContext, pathToContract str\n \treturn scAddr, owner\n }\n \n-// PrepareRelayerTxData -\n-func PrepareRelayerTxData(innerTx *transaction.Transaction) []byte {\n-\tuserTxBytes, _ := protoMarshalizer.Marshal(innerTx)\n-\treturn []byte(core.RelayedTransaction + \"@\" + hex.EncodeToString(userTxBytes))\n-}\n-\n // CheckOwnerAddr -\n func CheckOwnerAddr(t *testing.T, testContext *vm.VMTestContext, scAddr []byte, owner []byte) {\n \tacc, err := testContext.Accounts.GetExistingAccount(scAddr)"
        },
        {
          "filename": "process/transaction/export_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -79,3 +79,8 @@ func (txProc *txProcessor) ExecuteFailedRelayedTransaction(\n \t\toriginalTxHash,\n \t\terrorMsg)\n }\n+\n+// ShouldIncreaseNonce -\n+func (txProc *txProcessor) ShouldIncreaseNonce(executionErr error) bool {\n+\treturn txProc.shouldIncreaseNonce(executionErr)\n+}"
        },
        {
          "filename": "process/transaction/shardProcess.go",
          "status": "modified",
          "additions": 20,
          "deletions": 3,
          "patch": "@@ -672,6 +672,7 @@ func (txProc *txProcessor) computeRelayedTxFees(tx *transaction.Transaction) rel\n func (txProc *txProcessor) removeValueAndConsumedFeeFromUser(\n \tuserTx *transaction.Transaction,\n \trelayedTxValue *big.Int,\n+\texecutionErr error,\n ) error {\n \tuserAcnt, err := txProc.getAccountFromAddress(userTx.SndAddr)\n \tif err != nil {\n@@ -690,7 +691,10 @@ func (txProc *txProcessor) removeValueAndConsumedFeeFromUser(\n \tif err != nil {\n \t\treturn err\n \t}\n-\tuserAcnt.IncreaseNonce(1)\n+\n+\tif txProc.shouldIncreaseNonce(executionErr) {\n+\t\tuserAcnt.IncreaseNonce(1)\n+\t}\n \n \terr = txProc.accounts.SaveAccount(userAcnt)\n \tif err != nil {\n@@ -735,7 +739,7 @@ func (txProc *txProcessor) processUserTx(\n \ttxType, dstShardTxType := txProc.txTypeHandler.ComputeTransactionType(userTx)\n \terr = txProc.checkTxValues(userTx, acntSnd, acntDst, true)\n \tif err != nil {\n-\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue)\n+\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue, err)\n \t\tif errRemove != nil {\n \t\t\treturn vmcommon.UserError, errRemove\n \t\t}\n@@ -787,7 +791,7 @@ func (txProc *txProcessor) processUserTx(\n \t\treturnCode, err = txProc.scProcessor.ExecuteBuiltInFunction(scrFromTx, acntSnd, acntDst)\n \tdefault:\n \t\terr = process.ErrWrongTransaction\n-\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue)\n+\t\terrRemove := txProc.removeValueAndConsumedFeeFromUser(userTx, relayedTxValue, err)\n \t\tif errRemove != nil {\n \t\t\treturn vmcommon.UserError, errRemove\n \t\t}\n@@ -940,6 +944,19 @@ func (txProc *txProcessor) executeFailedRelayedUserTx(\n \treturn nil\n }\n \n+func (txProc *txProcessor) shouldIncreaseNonce(executionErr error) bool {\n+\tif !txProc.enableEpochsHandler.IsRelayedNonceFixEnabled() {\n+\t\treturn true\n+\t}\n+\n+\t// todo add not executable for guardians\n+\tif errors.Is(executionErr, process.ErrLowerNonceInTransaction) || errors.Is(executionErr, process.ErrHigherNonceInTransaction) {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n+}\n+\n // IsInterfaceNil returns true if there is no value under the interface\n func (txProc *txProcessor) IsInterfaceNil() bool {\n \treturn txProc == nil"
        },
        {
          "filename": "process/transaction/shardProcess_test.go",
          "status": "modified",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@ import (\n \t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"math/big\"\n \t\"testing\"\n \n@@ -3236,3 +3237,37 @@ func TestTxProcessor_ExecuteFailingRelayedTxShouldNotHaveNegativeFee(t *testing.\n \tassert.Nil(t, err)\n \tassert.False(t, negativeCost)\n }\n+\n+func TestTxProcessor_shouldIncreaseNonce(t *testing.T) {\n+\tt.Parallel()\n+\n+\tt.Run(\"fix not enabled, should return true\", func(t *testing.T) {\n+\t\targs := createArgsForTxProcessor()\n+\t\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n+\t\t\tIsRelayedNonceFixEnabledField: false,\n+\t\t}\n+\t\ttxProc, _ := txproc.NewTxProcessor(args)\n+\n+\t\tassert.True(t, txProc.ShouldIncreaseNonce(nil))\n+\t})\n+\tt.Run(\"fix enabled, different errors should return true\", func(t *testing.T) {\n+\t\targs := createArgsForTxProcessor()\n+\t\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n+\t\t\tIsRelayedNonceFixEnabledField: true,\n+\t\t}\n+\t\ttxProc, _ := txproc.NewTxProcessor(args)\n+\n+\t\tassert.True(t, txProc.ShouldIncreaseNonce(nil))\n+\t\tassert.True(t, txProc.ShouldIncreaseNonce(fmt.Errorf(\"random error\")))\n+\t})\n+\tt.Run(\"fix enabled, errors for an un-executable transaction should return false\", func(t *testing.T) {\n+\t\targs := createArgsForTxProcessor()\n+\t\targs.EnableEpochsHandler = &testscommon.EnableEpochsHandlerStub{\n+\t\t\tIsRelayedNonceFixEnabledField: true,\n+\t\t}\n+\t\ttxProc, _ := txproc.NewTxProcessor(args)\n+\n+\t\tassert.False(t, txProc.ShouldIncreaseNonce(process.ErrLowerNonceInTransaction))\n+\t\tassert.False(t, txProc.ShouldIncreaseNonce(process.ErrHigherNonceInTransaction))\n+\t})\n+}"
        },
        {
          "filename": "sharding/mock/enableEpochsHandlerMock.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -566,6 +566,11 @@ func (mock *EnableEpochsHandlerMock) IsAlwaysSaveTokenMetaDataEnabled() bool {\n \treturn false\n }\n \n+// IsRelayedNonceFixEnabled -\n+func (mock *EnableEpochsHandlerMock) IsRelayedNonceFixEnabled() bool {\n+\treturn false\n+}\n+\n // IsInterfaceNil returns true if there is no value under the interface\n func (mock *EnableEpochsHandlerMock) IsInterfaceNil() bool {\n \treturn mock == nil"
        },
        {
          "filename": "testscommon/enableEpochsHandlerStub.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -117,6 +117,7 @@ type EnableEpochsHandlerStub struct {\n \tIsMaxBlockchainHookCountersFlagEnabledField                  bool\n \tIsWipeSingleNFTLiquidityDecreaseEnabledField                 bool\n \tIsAlwaysSaveTokenMetaDataEnabledField                        bool\n+\tIsRelayedNonceFixEnabledField                                bool\n }\n \n // ResetPenalizedTooMuchGasFlag -\n@@ -1014,6 +1015,14 @@ func (stub *EnableEpochsHandlerStub) IsAlwaysSaveTokenMetaDataEnabled() bool {\n \treturn stub.IsAlwaysSaveTokenMetaDataEnabledField\n }\n \n+// IsRelayedNonceFixEnabled -\n+func (stub *EnableEpochsHandlerStub) IsRelayedNonceFixEnabled() bool {\n+\tstub.RLock()\n+\tdefer stub.RUnlock()\n+\n+\treturn stub.IsRelayedNonceFixEnabledField\n+}\n+\n // IsInterfaceNil -\n func (stub *EnableEpochsHandlerStub) IsInterfaceNil() bool {\n \treturn stub == nil"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 20,
        "unique_directories": 12,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "54bce4bb3ac2cb0d38aa265c9a9fd05b8680bedd",
            "date": "2024-12-09T15:16:51Z",
            "author_login": "sstanculeanu"
          },
          {
            "sha": "861b336a4fb9061d43e0806f2e2444f9b87dc365",
            "date": "2024-12-05T11:30:51Z",
            "author_login": "sstanculeanu"
          },
          {
            "sha": "e1b7df8259c19e17b03cb00babd7dac102ffd609",
            "date": "2024-12-05T10:48:30Z",
            "author_login": "sstanculeanu"
          },
          {
            "sha": "e65a3d42addd57c5e4264489f3b8e5c30bb3c902",
            "date": "2024-12-05T10:47:00Z",
            "author_login": "sstanculeanu"
          },
          {
            "sha": "1bccd60e6a584f1746cc1a0e8fd9c456a098b196",
            "date": "2024-12-05T10:28:09Z",
            "author_login": "sstanculeanu"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:H",
    "cwe_id": "CWE-400",
    "description": "mx-chain-go is the official implementation of the MultiversX blockchain protocol, written in golang. When executing a relayed transaction, if the inner transaction failed, it would have increased the inner transaction's sender account nonce. This could have contributed to a limited DoS attack on a targeted account. The fix is a breaking change so a new flag `RelayedNonceFixEnableEpoch` was needed. This was a strict processing issue while validating blocks on a chain. This vulnerability has been patched in version 1.4.17.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-07-13T19:15:09.263",
    "last_modified": "2024-11-21T08:07:17.777",
    "fix_date": "2023-05-28T15:51:48Z"
  },
  "references": [
    {
      "url": "https://github.com/multiversx/mx-chain-go/blob/babdb144f1316ab6176bf3dbd7d4621120414d43/integrationTests/vm/txsFee/relayedMoveBalance_test.go#LL165C14-L165C14",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/commit/babdb144f1316ab6176bf3dbd7d4621120414d43",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/releases/tag/v1.4.17",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/security/advisories/GHSA-j494-7x2v-vvvp",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/blob/babdb144f1316ab6176bf3dbd7d4621120414d43/integrationTests/vm/txsFee/relayedMoveBalance_test.go#LL165C14-L165C14",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/commit/babdb144f1316ab6176bf3dbd7d4621120414d43",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/releases/tag/v1.4.17",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/multiversx/mx-chain-go/security/advisories/GHSA-j494-7x2v-vvvp",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.237809",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "mx-chain-go",
    "owner": "multiversx",
    "created_at": "2018-08-17T09:42:40Z",
    "updated_at": "2024-12-26T15:51:21Z",
    "pushed_at": "2025-01-23T16:34:27Z",
    "size": 355403,
    "stars": 935,
    "forks": 204,
    "open_issues": 115,
    "watchers": 935,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 19946001,
      "Shell": 82189,
      "Makefile": 3207,
      "Dockerfile": 3107
    },
    "commit_activity": {
      "total_commits_last_year": 1550,
      "avg_commits_per_week": 29.807692307692307,
      "days_active_last_year": 195
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-26T08:26:00.465580"
  }
}