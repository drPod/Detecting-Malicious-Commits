{
  "cve_id": "CVE-2023-34462",
  "github_data": {
    "repository": "netty/netty",
    "fix_commit": "535da17e45201ae4278c0479e6162bb4127d4c32",
    "related_commits": [
      "535da17e45201ae4278c0479e6162bb4127d4c32",
      "535da17e45201ae4278c0479e6162bb4127d4c32"
    ],
    "patch_url": "https://github.com/netty/netty/commit/535da17e45201ae4278c0479e6162bb4127d4c32.patch",
    "fix_commit_details": {
      "sha": "535da17e45201ae4278c0479e6162bb4127d4c32",
      "commit_date": "2023-06-20T12:53:08Z",
      "author": {
        "login": "normanmaurer",
        "type": "User",
        "stats": {
          "total_commits": 3013,
          "average_weekly_commits": 3.507566938300349,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 506
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-6mjq-h674-j845",
        "length": 424,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 138,
        "additions": 127,
        "deletions": 11
      },
      "files": [
        {
          "filename": "handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java",
          "status": "modified",
          "additions": 11,
          "deletions": 2,
          "patch": "@@ -126,14 +126,23 @@ private static String extractSniHostname(ByteBuf in) {\n     private String hostname;\n \n     /**\n-     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n+     * @param handshakeTimeoutMillis    the handshake timeout in milliseconds\n      */\n     protected AbstractSniHandler(long handshakeTimeoutMillis) {\n+        this(0, handshakeTimeoutMillis);\n+    }\n+\n+    /**\n+     * @paramm maxClientHelloLength     the maximum length of the client hello message.\n+     * @param handshakeTimeoutMillis    the handshake timeout in milliseconds\n+     */\n+    protected AbstractSniHandler(int maxClientHelloLength, long handshakeTimeoutMillis) {\n+        super(maxClientHelloLength);\n         this.handshakeTimeoutMillis = checkPositiveOrZero(handshakeTimeoutMillis, \"handshakeTimeoutMillis\");\n     }\n \n     public AbstractSniHandler() {\n-        this(0L);\n+        this(0, 0L);\n     }\n \n     @Override"
        },
        {
          "filename": "handler/src/main/java/io/netty/handler/ssl/SniHandler.java",
          "status": "modified",
          "additions": 31,
          "deletions": 5,
          "patch": "@@ -56,10 +56,12 @@ public SniHandler(Mapping<? super String, ? extends SslContext> mapping) {\n      * maintained by {@link Mapping}\n      *\n      * @param mapping the mapping of domain name to {@link SslContext}\n+     * @param maxClientHelloLength the maximum length of the client hello message\n      * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n      */\n-    public SniHandler(Mapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n-        this(new AsyncMappingAdapter(mapping), handshakeTimeoutMillis);\n+    public SniHandler(Mapping<? super String, ? extends SslContext> mapping,\n+                      int maxClientHelloLength, long handshakeTimeoutMillis) {\n+        this(new AsyncMappingAdapter(mapping), maxClientHelloLength, handshakeTimeoutMillis);\n     }\n \n     /**\n@@ -80,22 +82,46 @@ public SniHandler(DomainNameMapping<? extends SslContext> mapping) {\n      */\n     @SuppressWarnings(\"unchecked\")\n     public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping) {\n-        this(mapping, 0L);\n+        this(mapping, 0, 0L);\n     }\n \n     /**\n      * Creates a SNI detection handler with configured {@link SslContext}\n      * maintained by {@link AsyncMapping}\n      *\n      * @param mapping the mapping of domain name to {@link SslContext}\n+     * @param maxClientHelloLength the maximum length of the client hello message\n      * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n-        super(handshakeTimeoutMillis);\n+    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping,\n+                      int maxClientHelloLength, long handshakeTimeoutMillis) {\n+        super(maxClientHelloLength, handshakeTimeoutMillis);\n         this.mapping = (AsyncMapping<String, SslContext>) ObjectUtil.checkNotNull(mapping, \"mapping\");\n     }\n \n+    /**\n+     * Creates a SNI detection handler with configured {@link SslContext}\n+     * maintained by {@link Mapping}\n+     *\n+     * @param mapping the mapping of domain name to {@link SslContext}\n+     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n+     */\n+    public SniHandler(Mapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n+        this(new AsyncMappingAdapter(mapping), handshakeTimeoutMillis);\n+    }\n+\n+    /**\n+     * Creates a SNI detection handler with configured {@link SslContext}\n+     * maintained by {@link AsyncMapping}\n+     *\n+     * @param mapping the mapping of domain name to {@link SslContext}\n+     * @param handshakeTimeoutMillis the handshake timeout in milliseconds\n+     */\n+    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping, long handshakeTimeoutMillis) {\n+        this(mapping, 0, handshakeTimeoutMillis);\n+    }\n+\n     /**\n      * @return the selected hostname\n      */"
        },
        {
          "filename": "handler/src/main/java/io/netty/handler/ssl/SslClientHelloHandler.java",
          "status": "modified",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -22,8 +22,10 @@\n import io.netty.channel.ChannelPromise;\n import io.netty.handler.codec.ByteToMessageDecoder;\n import io.netty.handler.codec.DecoderException;\n+import io.netty.handler.codec.TooLongFrameException;\n import io.netty.util.concurrent.Future;\n import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.internal.ObjectUtil;\n import io.netty.util.internal.PlatformDependent;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n@@ -36,14 +38,32 @@\n  */\n public abstract class SslClientHelloHandler<T> extends ByteToMessageDecoder implements ChannelOutboundHandler {\n \n+    /**\n+     * The maximum length of client hello message as defined by\n+     * <a href=\"https://www.rfc-editor.org/rfc/rfc5246#section-6.2.1\">RFC5246</a>.\n+     */\n+    public static final int MAX_CLIENT_HELLO_LENGTH = 0xFFFFFF;\n+\n     private static final InternalLogger logger =\n             InternalLoggerFactory.getInstance(SslClientHelloHandler.class);\n \n+    private final int maxClientHelloLength;\n     private boolean handshakeFailed;\n     private boolean suppressRead;\n     private boolean readPending;\n     private ByteBuf handshakeBuffer;\n \n+    public SslClientHelloHandler() {\n+        this(MAX_CLIENT_HELLO_LENGTH);\n+    }\n+\n+    protected SslClientHelloHandler(int maxClientHelloLength) {\n+        // 16MB is the maximum as per RFC:\n+        // See https://www.rfc-editor.org/rfc/rfc5246#section-6.2.1\n+        this.maxClientHelloLength =\n+                ObjectUtil.checkInRange(maxClientHelloLength, 0, MAX_CLIENT_HELLO_LENGTH, \"maxClientHelloLength\");\n+    }\n+\n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n         if (!suppressRead && !handshakeFailed) {\n@@ -117,6 +137,15 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t\n                                     handshakeLength = in.getUnsignedMedium(readerIndex +\n                                             SslUtils.SSL_RECORD_HEADER_LENGTH + 1);\n \n+                                    if (handshakeLength > maxClientHelloLength && maxClientHelloLength != 0) {\n+                                        TooLongFrameException e = new TooLongFrameException(\n+                                                \"ClientHello length exceeds \" + maxClientHelloLength +\n+                                                        \": \" + handshakeLength);\n+                                        in.skipBytes(in.readableBytes());\n+                                        ctx.fireUserEventTriggered(new SniCompletionEvent(e));\n+                                        SslUtils.handleHandshakeFailure(ctx, e, true);\n+                                        throw e;\n+                                    }\n                                     // Consume handshakeType and handshakeLength (this sums up as 4 bytes)\n                                     readerIndex += 4;\n                                     packetLength -= 4;\n@@ -161,6 +190,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t\n             } catch (NotSslRecordException e) {\n                 // Just rethrow as in this case we also closed the channel and this is consistent with SslHandler.\n                 throw e;\n+            } catch (TooLongFrameException e) {\n+                // Just rethrow as in this case we also closed the channel\n+                throw e;\n             } catch (Exception e) {\n                 // unexpected encoding, ignore sni and use default\n                 if (logger.isDebugEnabled()) {"
        },
        {
          "filename": "handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java",
          "status": "modified",
          "additions": 53,
          "deletions": 4,
          "patch": "@@ -25,11 +25,10 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import javax.net.ssl.HandshakeCompletedEvent;\n-import javax.net.ssl.SSLContext;\n import javax.net.ssl.SSLEngine;\n import javax.net.ssl.SSLException;\n \n+import io.netty.handler.codec.TooLongFrameException;\n import io.netty.util.concurrent.Future;\n \n import io.netty.bootstrap.Bootstrap;\n@@ -715,14 +714,64 @@ private static List<ByteBuf> split(ByteBuf clientHello, int maxSize) {\n         return result;\n     }\n \n+    @Test\n+    public void testSniHandlerFailsOnTooBigClientHello() throws Exception {\n+        SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n+            @Override\n+            public SslContext map(String input) {\n+                throw new UnsupportedOperationException(\"Should not be called\");\n+            }\n+        }, 10, 0);\n+\n+        final AtomicReference<SniCompletionEvent> completionEventRef =\n+                new AtomicReference<SniCompletionEvent>();\n+        final EmbeddedChannel ch = new EmbeddedChannel(handler, new ChannelInboundHandlerAdapter() {\n+            @Override\n+            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+                if (evt instanceof SniCompletionEvent) {\n+                    completionEventRef.set((SniCompletionEvent) evt);\n+                }\n+            }\n+        });\n+        final ByteBuf buffer = ch.alloc().buffer();\n+        buffer.writeByte(0x16);      // Content Type: Handshake\n+        buffer.writeShort((short) 0x0303); // TLS 1.2\n+        buffer.writeShort((short) 0x0006); // Packet length\n+\n+        // 16_777_215\n+        buffer.writeByte((byte) 0x01); // Client Hello\n+        buffer.writeMedium(0xFFFFFF); // Length\n+        buffer.writeShort((short) 0x0303); // TLS 1.2\n+\n+        assertThrows(TooLongFrameException.class, new Executable() {\n+            @Override\n+            public void execute() throws Throwable {\n+                ch.writeInbound(buffer);\n+            }\n+        });\n+        try {\n+            while (completionEventRef.get() == null) {\n+                Thread.sleep(100);\n+                // We need to run all pending tasks as the handshake timeout is scheduled on the EventLoop.\n+                ch.runPendingTasks();\n+            }\n+            SniCompletionEvent completionEvent = completionEventRef.get();\n+            assertNotNull(completionEvent);\n+            assertNotNull(completionEvent.cause());\n+            assertEquals(TooLongFrameException.class, completionEvent.cause().getClass());\n+        } finally {\n+            ch.finishAndReleaseAll();\n+        }\n+    }\n+\n     @Test\n     public void testSniHandlerFiresHandshakeTimeout() throws Exception {\n         SniHandler handler = new SniHandler(new Mapping<String, SslContext>() {\n             @Override\n             public SslContext map(String input) {\n                 throw new UnsupportedOperationException(\"Should not be called\");\n             }\n-        }, 10);\n+        }, 0, 10);\n \n         final AtomicReference<SniCompletionEvent> completionEventRef =\n             new AtomicReference<SniCompletionEvent>();\n@@ -758,7 +807,7 @@ public void testSslHandlerFiresHandshakeTimeout(SslProvider provider) throws Exc\n             public SslContext map(String input) {\n                 return context;\n             }\n-        }, 100);\n+        }, 0, 100);\n \n         final AtomicReference<SniCompletionEvent> sniCompletionEventRef =\n             new AtomicReference<SniCompletionEvent>();"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5194d1306ef9fef002878673bbb7b3463e32387f",
            "date": "2025-01-14T07:19:29Z",
            "author_login": "netty-project-bot"
          },
          {
            "sha": "3b036489e24eb2a1e3bb45022a02a09eceaa8293",
            "date": "2025-01-14T07:19:25Z",
            "author_login": "netty-project-bot"
          },
          {
            "sha": "28a81c687725f6d3403341656b26a8b70391402f",
            "date": "2025-01-13T20:42:26Z",
            "author_login": "normanmaurer"
          },
          {
            "sha": "1bd459ac11ff8486641e619abdd732c7bbd94c70",
            "date": "2025-01-13T20:24:00Z",
            "author_login": "normanmaurer"
          },
          {
            "sha": "ad00d19e5d1b488bb04c5da56571b1484ff547ef",
            "date": "2025-01-13T19:10:08Z",
            "author_login": "normanmaurer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. The `SniHandler` can allocate up to 16MB of heap for each channel during the TLS handshake. When the handler or the channel does not have an idle timeout, it can be used to make a TCP server using the `SniHandler` to allocate 16MB of heap. The `SniHandler` class is a handler that waits for the TLS handshake to configure a `SslHandler` according to the indicated server name by the `ClientHello` record. For this matter it allocates a `ByteBuf` using the value defined in the `ClientHello` record. Normally the value of the packet should be smaller than the handshake packet but there are not checks done here and the way the code is written, it is possible to craft a packet that makes the `SslClientHelloHandler`. This vulnerability has been fixed in version 4.1.94.Final.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-06-22T23:15:09.573",
    "last_modified": "2024-11-21T08:07:18.337",
    "fix_date": "2023-06-20T12:53:08Z"
  },
  "references": [
    {
      "url": "https://github.com/netty/netty/commit/535da17e45201ae4278c0479e6162bb4127d4c32",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/netty/netty/security/advisories/GHSA-6mjq-h674-j845",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230803-0001/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240621-0007/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.debian.org/security/2023/dsa-5558",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/netty/netty/commit/535da17e45201ae4278c0479e6162bb4127d4c32",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/netty/netty/security/advisories/GHSA-6mjq-h674-j845",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20230803-0001/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240621-0007/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.debian.org/security/2023/dsa-5558",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:01.854664",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "netty",
    "owner": "netty",
    "created_at": "2010-11-09T09:22:21Z",
    "updated_at": "2025-01-14T09:10:40Z",
    "pushed_at": "2025-01-14T12:48:52Z",
    "size": 92623,
    "stars": 33671,
    "forks": 15993,
    "open_issues": 609,
    "watchers": 33671,
    "has_security_policy": false,
    "default_branch": "4.1",
    "protected_branches": [
      "3.2",
      "3.5",
      "3.6",
      "3.7",
      "3.8",
      "3.9",
      "3.10",
      "main"
    ],
    "languages": {
      "Java": 19621935,
      "C": 228044,
      "HTML": 21029,
      "Shell": 18570,
      "JavaScript": 16232,
      "Makefile": 1814,
      "Groovy": 1755,
      "Dockerfile": 1116,
      "CSS": 49
    },
    "commit_activity": {
      "total_commits_last_year": 406,
      "avg_commits_per_week": 7.8076923076923075,
      "days_active_last_year": 156
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:57:47.084896"
  }
}