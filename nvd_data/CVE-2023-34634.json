{
  "cve_id": "CVE-2023-34634",
  "github_data": {
    "repository": "greenshot/greenshot",
    "fix_commit": "a152e2883fca7f78051b3bd6b1e5cc57355cb44c",
    "related_commits": [
      "a152e2883fca7f78051b3bd6b1e5cc57355cb44c",
      "a152e2883fca7f78051b3bd6b1e5cc57355cb44c"
    ],
    "patch_url": "https://github.com/greenshot/greenshot/commit/a152e2883fca7f78051b3bd6b1e5cc57355cb44c.patch",
    "fix_commit_details": {
      "sha": "a152e2883fca7f78051b3bd6b1e5cc57355cb44c",
      "commit_date": "2023-03-27T19:51:01Z",
      "author": {
        "login": "Lakritzator",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "This should improve the backwards compatibility for the .greenshot file from earlier versions. This was also addressed in #375",
        "length": 126,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 771,
        "additions": 446,
        "deletions": 325
      },
      "files": [
        {
          "filename": "src/Greenshot.Editor/Drawing/FreehandContainer.cs",
          "status": "modified",
          "additions": 324,
          "deletions": 322,
          "patch": "@@ -1,323 +1,325 @@\n-\ufeff/*\n- * Greenshot - a free and open source screenshot tool\n- * Copyright (C) 2007-2021 Thomas Braun, Jens Klingen, Robin Krom\n- * \n- * For more information see: https://getgreenshot.org/\n- * The Greenshot project is hosted on GitHub https://github.com/greenshot/greenshot\n- * \n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU General Public License as published by\n- * the Free Software Foundation, either version 1 of the License, or\n- * (at your option) any later version.\n- * \n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- * \n- * You should have received a copy of the GNU General Public License\n- * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n- */\n-\n-using System;\n-using System.Collections.Generic;\n-using System.Drawing;\n-using System.Drawing.Drawing2D;\n-using System.Runtime.Serialization;\n-using Dapplo.Windows.Common.Structs;\n-using Greenshot.Base.Interfaces;\n-using Greenshot.Base.Interfaces.Drawing;\n-using Greenshot.Editor.Drawing.Fields;\n-using Greenshot.Editor.Helpers;\n-\n-namespace Greenshot.Editor.Drawing\n-{\n-    /// <summary>\n-    /// Description of PathContainer.\n-    /// </summary>\n-    [Serializable]\n-    public class FreehandContainer : DrawableContainer\n-    {\n-        private static readonly float[] PointOffset =\n-        {\n-            0.5f, 0.25f, 0.75f\n-        };\n-\n-        [NonSerialized] private GraphicsPath freehandPath = new GraphicsPath();\n-        private NativeRect myBounds = NativeRect.Empty;\n-        private NativePoint lastMouse = NativePoint.Empty;\n-        private readonly List<Point> capturePoints = new List<Point>();\n-        private bool isRecalculated;\n-\n-        /// <summary>\n-        /// Constructor\n-        /// </summary>\n-        public FreehandContainer(ISurface parent) : base(parent)\n-        {\n-            Width = parent.Image.Width;\n-            Height = parent.Image.Height;\n-            Top = 0;\n-            Left = 0;\n-        }\n-\n-        protected override void InitializeFields()\n-        {\n-            AddField(GetType(), FieldType.LINE_THICKNESS, 3);\n-            AddField(GetType(), FieldType.LINE_COLOR, Color.Red);\n-        }\n-\n-        public override void Transform(Matrix matrix)\n-        {\n-            Point[] points = capturePoints.ToArray();\n-\n-            matrix.TransformPoints(points);\n-            capturePoints.Clear();\n-            capturePoints.AddRange(points);\n-            RecalculatePath();\n-        }\n-\n-        protected override void OnDeserialized(StreamingContext context)\n-        {\n-            RecalculatePath();\n-        }\n-\n-        /// <summary>\n-        /// This Dispose is called from the Dispose and the Destructor.\n-        /// </summary>\n-        /// <param name=\"disposing\">When disposing==true all non-managed resources should be freed too!</param>\n-        protected override void Dispose(bool disposing)\n-        {\n-            base.Dispose(disposing);\n-            if (disposing)\n-            {\n-                freehandPath?.Dispose();\n-            }\n-\n-            freehandPath = null;\n-        }\n-\n-        /// <summary>\n-        /// Called from Surface (the parent) when the drawing begins (mouse-down)\n-        /// </summary>\n-        /// <returns>true if the surface doesn't need to handle the event</returns>\n-        public override bool HandleMouseDown(int mouseX, int mouseY)\n-        {\n-            lastMouse = new Point(mouseX, mouseY);\n-            capturePoints.Add(lastMouse);\n-            return true;\n-        }\n-\n-        /// <summary>\n-        /// Called from Surface (the parent) if a mouse move is made while drawing\n-        /// </summary>\n-        /// <returns>true if the surface doesn't need to handle the event</returns>\n-        public override bool HandleMouseMove(int mouseX, int mouseY)\n-        {\n-            Point previousPoint = capturePoints[capturePoints.Count - 1];\n-\n-            if (GeometryHelper.Distance2D(previousPoint.X, previousPoint.Y, mouseX, mouseY) >= 2 * EditorConfig.FreehandSensitivity)\n-            {\n-                capturePoints.Add(new Point(mouseX, mouseY));\n-            }\n-\n-            if (GeometryHelper.Distance2D(lastMouse.X, lastMouse.Y, mouseX, mouseY) < EditorConfig.FreehandSensitivity)\n-            {\n-                return true;\n-            }\n-\n-            //path.AddCurve(new Point[]{lastMouse, new Point(mouseX, mouseY)});\n-            lastMouse = new Point(mouseX, mouseY);\n-            freehandPath.AddLine(lastMouse, new Point(mouseX, mouseY));\n-            // Only re-calculate the bounds & redraw when we added something to the path\n-            myBounds = Rectangle.Round(freehandPath.GetBounds());\n-\n-            Invalidate();\n-            return true;\n-        }\n-\n-        /// <summary>\n-        /// Called when the surface finishes drawing the element\n-        /// </summary>\n-        public override void HandleMouseUp(int mouseX, int mouseY)\n-        {\n-            // Make sure we don't loose the ending point\n-            if (GeometryHelper.Distance2D(lastMouse.X, lastMouse.Y, mouseX, mouseY) >= EditorConfig.FreehandSensitivity)\n-            {\n-                capturePoints.Add(new Point(mouseX, mouseY));\n-            }\n-\n-            RecalculatePath();\n-        }\n-\n-        /// <summary>\n-        /// Here we recalculate the freehand path by smoothing out the lines with Beziers.\n-        /// </summary>\n-        private void RecalculatePath()\n-        {\n-            // Store the previous path, to dispose it later when we are finished\n-            var previousFreehandPath = freehandPath;\n-            var newFreehandPath = new GraphicsPath();\n-\n-            // Here we can put some cleanup... like losing all the uninteresting  points.\n-            if (capturePoints.Count >= 3)\n-            {\n-                int index = 0;\n-                while ((capturePoints.Count - 1) % 3 != 0)\n-                {\n-                    // duplicate points, first at 50% than 25% than 75%\n-                    capturePoints.Insert((int) (capturePoints.Count * PointOffset[index]), capturePoints[(int) (capturePoints.Count * PointOffset[index++])]);\n-                }\n-\n-                newFreehandPath.AddBeziers(capturePoints.ToArray());\n-            }\n-            else if (capturePoints.Count == 2)\n-            {\n-                newFreehandPath.AddLine(capturePoints[0], capturePoints[1]);\n-            }\n-\n-            // Recalculate the bounds\n-            myBounds = Rectangle.Round(newFreehandPath.GetBounds());\n-\n-            // assign\n-            isRecalculated = true;\n-            freehandPath = newFreehandPath;\n-\n-            // dispose previous\n-            previousFreehandPath?.Dispose();\n-        }\n-\n-        /// <summary>\n-        /// Do the drawing of the freehand \"stroke\"\n-        /// </summary>\n-        /// <param name=\"graphics\"></param>\n-        /// <param name=\"renderMode\"></param>\n-        public override void Draw(Graphics graphics, RenderMode renderMode)\n-        {\n-            graphics.SmoothingMode = SmoothingMode.HighQuality;\n-            graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;\n-            graphics.CompositingQuality = CompositingQuality.HighQuality;\n-            graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;\n-\n-            int lineThickness = GetFieldValueAsInt(FieldType.LINE_THICKNESS);\n-            Color lineColor = GetFieldValueAsColor(FieldType.LINE_COLOR);\n-            using var pen = new Pen(lineColor)\n-            {\n-                Width = lineThickness\n-            };\n-            if (!(pen.Width > 0))\n-            {\n-                return;\n-            }\n-\n-            // Make sure the lines are nicely rounded\n-            pen.EndCap = LineCap.Round;\n-            pen.StartCap = LineCap.Round;\n-            pen.LineJoin = LineJoin.Round;\n-            // Move to where we need to draw\n-            graphics.TranslateTransform(Left, Top);\n-            var currentFreehandPath = freehandPath;\n-            if (currentFreehandPath != null)\n-            {\n-                if (isRecalculated && Selected && renderMode == RenderMode.EDIT)\n-                {\n-                    isRecalculated = false;\n-                    DrawSelectionBorder(graphics, pen, currentFreehandPath);\n-                }\n-\n-                graphics.DrawPath(pen, currentFreehandPath);\n-            }\n-\n-            // Move back, otherwise everything is shifted\n-            graphics.TranslateTransform(-Left, -Top);\n-        }\n-\n-        /// <summary>\n-        /// Draw a selectionborder around the freehand path\n-        /// </summary>\n-        /// <param name=\"graphics\">Graphics</param>\n-        /// <param name=\"linePen\">Pen</param>\n-        /// <param name=\"path\">GraphicsPath</param>\n-        protected static void DrawSelectionBorder(Graphics graphics, Pen linePen, GraphicsPath path)\n-        {\n-            using var selectionPen = (Pen) linePen.Clone();\n-            using var selectionPath = (GraphicsPath) path.Clone();\n-            selectionPen.Width += 5;\n-            selectionPen.Color = Color.FromArgb(120, Color.LightSeaGreen);\n-            graphics.DrawPath(selectionPen, selectionPath);\n-            selectionPath.Widen(selectionPen);\n-            selectionPen.DashPattern = new float[]\n-            {\n-                2, 2\n-            };\n-            selectionPen.Color = Color.LightSeaGreen;\n-            selectionPen.Width = 1;\n-            graphics.DrawPath(selectionPen, selectionPath);\n-        }\n-\n-        /// <summary>\n-        /// Get the bounds in which we have something drawn, plus safety margin, these are not the normal bounds...\n-        /// </summary>\n-        public override NativeRect DrawingBounds\n-        {\n-            get\n-            {\n-                if (!myBounds.IsEmpty)\n-                {\n-                    int lineThickness = Math.Max(10, GetFieldValueAsInt(FieldType.LINE_THICKNESS));\n-                    int safetyMargin = 10;\n-                    return new NativeRect(myBounds.Left + Left - (safetyMargin + lineThickness), myBounds.Top + Top - (safetyMargin + lineThickness),\n-                        myBounds.Width + 2 * (lineThickness + safetyMargin), myBounds.Height + 2 * (lineThickness + safetyMargin));\n-                }\n-\n-                if (_parent?.Image is Image image)\n-                {\n-                    return new NativeRect(0, 0, image.Width, image.Height);\n-                }\n-\n-                return NativeRect.Empty;\n-            }\n-        }\n-\n-        /// <summary>\n-        /// FreehandContainer are regarded equal if they are of the same type and their paths are equal.\n-        /// </summary>\n-        /// <param name=\"obj\">object</param>\n-        /// <returns>bool</returns>\n-        public override bool Equals(object obj)\n-        {\n-            bool ret = false;\n-            if (obj == null || GetType() != obj.GetType())\n-            {\n-                return false;\n-            }\n-\n-            if (obj is FreehandContainer other && Equals(freehandPath, other.freehandPath))\n-            {\n-                ret = true;\n-            }\n-\n-            return ret;\n-        }\n-\n-        public override int GetHashCode()\n-        {\n-            return freehandPath?.GetHashCode() ?? 0;\n-        }\n-\n-        public override bool ClickableAt(int x, int y)\n-        {\n-            bool returnValue = base.ClickableAt(x, y);\n-            if (returnValue)\n-            {\n-                int lineThickness = GetFieldValueAsInt(FieldType.LINE_THICKNESS);\n-                using var pen = new Pen(Color.White)\n-                {\n-                    Width = lineThickness + 10\n-                };\n-                returnValue = freehandPath.IsOutlineVisible(x - Left, y - Top, pen);\n-            }\n-\n-            return returnValue;\n-        }\n-    }\n+\ufeff/*\r\n+ * Greenshot - a free and open source screenshot tool\r\n+ * Copyright (C) 2007-2021 Thomas Braun, Jens Klingen, Robin Krom\r\n+ * \r\n+ * For more information see: https://getgreenshot.org/\r\n+ * The Greenshot project is hosted on GitHub https://github.com/greenshot/greenshot\r\n+ * \r\n+ * This program is free software: you can redistribute it and/or modify\r\n+ * it under the terms of the GNU General Public License as published by\r\n+ * the Free Software Foundation, either version 1 of the License, or\r\n+ * (at your option) any later version.\r\n+ * \r\n+ * This program is distributed in the hope that it will be useful,\r\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n+ * GNU General Public License for more details.\r\n+ * \r\n+ * You should have received a copy of the GNU General Public License\r\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n+ */\r\n+\r\n+using System;\r\n+using System.Collections.Generic;\r\n+using System.Drawing;\r\n+using System.Drawing.Drawing2D;\r\n+using System.Runtime.Serialization;\r\n+using Dapplo.Windows.Common.Structs;\r\n+using Greenshot.Base.Interfaces;\r\n+using Greenshot.Base.Interfaces.Drawing;\r\n+using Greenshot.Editor.Drawing.Fields;\r\n+using Greenshot.Editor.Helpers;\r\n+\r\n+namespace Greenshot.Editor.Drawing\r\n+{\r\n+    /// <summary>\r\n+    /// Description of PathContainer.\r\n+    /// </summary>\r\n+    [Serializable]\r\n+    public class FreehandContainer : DrawableContainer\r\n+    {\r\n+        private static readonly float[] PointOffset =\r\n+        {\r\n+            0.5f, 0.25f, 0.75f\r\n+        };\r\n+\r\n+        [NonSerialized]\r\n+        private GraphicsPath freehandPath = new GraphicsPath();\r\n+\r\n+        private Rectangle myBounds = NativeRect.Empty;\r\n+        private Point lastMouse = NativePoint.Empty;\r\n+        private List<Point> capturePoints = new List<Point>();\r\n+        private bool isRecalculated;\r\n+\r\n+        /// <summary>\r\n+        /// Constructor\r\n+        /// </summary>\r\n+        public FreehandContainer(ISurface parent) : base(parent)\r\n+        {\r\n+            Width = parent.Image.Width;\r\n+            Height = parent.Image.Height;\r\n+            Top = 0;\r\n+            Left = 0;\r\n+        }\r\n+\r\n+        protected override void InitializeFields()\r\n+        {\r\n+            AddField(GetType(), FieldType.LINE_THICKNESS, 3);\r\n+            AddField(GetType(), FieldType.LINE_COLOR, Color.Red);\r\n+        }\r\n+\r\n+        public override void Transform(Matrix matrix)\r\n+        {\r\n+            Point[] points = capturePoints.ToArray();\r\n+\r\n+            matrix.TransformPoints(points);\r\n+            capturePoints.Clear();\r\n+            capturePoints.AddRange(points);\r\n+            RecalculatePath();\r\n+        }\r\n+\r\n+        protected override void OnDeserialized(StreamingContext context)\r\n+        {\r\n+            RecalculatePath();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// This Dispose is called from the Dispose and the Destructor.\r\n+        /// </summary>\r\n+        /// <param name=\"disposing\">When disposing==true all non-managed resources should be freed too!</param>\r\n+        protected override void Dispose(bool disposing)\r\n+        {\r\n+            base.Dispose(disposing);\r\n+            if (disposing)\r\n+            {\r\n+                freehandPath?.Dispose();\r\n+            }\r\n+\r\n+            freehandPath = null;\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Called from Surface (the parent) when the drawing begins (mouse-down)\r\n+        /// </summary>\r\n+        /// <returns>true if the surface doesn't need to handle the event</returns>\r\n+        public override bool HandleMouseDown(int mouseX, int mouseY)\r\n+        {\r\n+            lastMouse = new Point(mouseX, mouseY);\r\n+            capturePoints.Add(lastMouse);\r\n+            return true;\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Called from Surface (the parent) if a mouse move is made while drawing\r\n+        /// </summary>\r\n+        /// <returns>true if the surface doesn't need to handle the event</returns>\r\n+        public override bool HandleMouseMove(int mouseX, int mouseY)\r\n+        {\r\n+            Point previousPoint = capturePoints[capturePoints.Count - 1];\r\n+\r\n+            if (GeometryHelper.Distance2D(previousPoint.X, previousPoint.Y, mouseX, mouseY) >= 2 * EditorConfig.FreehandSensitivity)\r\n+            {\r\n+                capturePoints.Add(new Point(mouseX, mouseY));\r\n+            }\r\n+\r\n+            if (GeometryHelper.Distance2D(lastMouse.X, lastMouse.Y, mouseX, mouseY) < EditorConfig.FreehandSensitivity)\r\n+            {\r\n+                return true;\r\n+            }\r\n+\r\n+            //path.AddCurve(new Point[]{lastMouse, new Point(mouseX, mouseY)});\r\n+            lastMouse = new Point(mouseX, mouseY);\r\n+            freehandPath.AddLine(lastMouse, new Point(mouseX, mouseY));\r\n+            // Only re-calculate the bounds & redraw when we added something to the path\r\n+            myBounds = Rectangle.Round(freehandPath.GetBounds());\r\n+\r\n+            Invalidate();\r\n+            return true;\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Called when the surface finishes drawing the element\r\n+        /// </summary>\r\n+        public override void HandleMouseUp(int mouseX, int mouseY)\r\n+        {\r\n+            // Make sure we don't loose the ending point\r\n+            if (GeometryHelper.Distance2D(lastMouse.X, lastMouse.Y, mouseX, mouseY) >= EditorConfig.FreehandSensitivity)\r\n+            {\r\n+                capturePoints.Add(new Point(mouseX, mouseY));\r\n+            }\r\n+\r\n+            RecalculatePath();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Here we recalculate the freehand path by smoothing out the lines with Beziers.\r\n+        /// </summary>\r\n+        private void RecalculatePath()\r\n+        {\r\n+            // Store the previous path, to dispose it later when we are finished\r\n+            var previousFreehandPath = freehandPath;\r\n+            var newFreehandPath = new GraphicsPath();\r\n+\r\n+            // Here we can put some cleanup... like losing all the uninteresting  points.\r\n+            if (capturePoints.Count >= 3)\r\n+            {\r\n+                int index = 0;\r\n+                while ((capturePoints.Count - 1) % 3 != 0)\r\n+                {\r\n+                    // duplicate points, first at 50% than 25% than 75%\r\n+                    capturePoints.Insert((int) (capturePoints.Count * PointOffset[index]), capturePoints[(int) (capturePoints.Count * PointOffset[index++])]);\r\n+                }\r\n+\r\n+                newFreehandPath.AddBeziers(capturePoints.ToArray());\r\n+            }\r\n+            else if (capturePoints.Count == 2)\r\n+            {\r\n+                newFreehandPath.AddLine(capturePoints[0], capturePoints[1]);\r\n+            }\r\n+\r\n+            // Recalculate the bounds\r\n+            myBounds = Rectangle.Round(newFreehandPath.GetBounds());\r\n+\r\n+            // assign\r\n+            isRecalculated = true;\r\n+            freehandPath = newFreehandPath;\r\n+\r\n+            // dispose previous\r\n+            previousFreehandPath?.Dispose();\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Do the drawing of the freehand \"stroke\"\r\n+        /// </summary>\r\n+        /// <param name=\"graphics\"></param>\r\n+        /// <param name=\"renderMode\"></param>\r\n+        public override void Draw(Graphics graphics, RenderMode renderMode)\r\n+        {\r\n+            graphics.SmoothingMode = SmoothingMode.HighQuality;\r\n+            graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;\r\n+            graphics.CompositingQuality = CompositingQuality.HighQuality;\r\n+            graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;\r\n+\r\n+            int lineThickness = GetFieldValueAsInt(FieldType.LINE_THICKNESS);\r\n+            Color lineColor = GetFieldValueAsColor(FieldType.LINE_COLOR);\r\n+            using var pen = new Pen(lineColor)\r\n+            {\r\n+                Width = lineThickness\r\n+            };\r\n+            if (!(pen.Width > 0))\r\n+            {\r\n+                return;\r\n+            }\r\n+\r\n+            // Make sure the lines are nicely rounded\r\n+            pen.EndCap = LineCap.Round;\r\n+            pen.StartCap = LineCap.Round;\r\n+            pen.LineJoin = LineJoin.Round;\r\n+            // Move to where we need to draw\r\n+            graphics.TranslateTransform(Left, Top);\r\n+            var currentFreehandPath = freehandPath;\r\n+            if (currentFreehandPath != null)\r\n+            {\r\n+                if (isRecalculated && Selected && renderMode == RenderMode.EDIT)\r\n+                {\r\n+                    isRecalculated = false;\r\n+                    DrawSelectionBorder(graphics, pen, currentFreehandPath);\r\n+                }\r\n+\r\n+                graphics.DrawPath(pen, currentFreehandPath);\r\n+            }\r\n+\r\n+            // Move back, otherwise everything is shifted\r\n+            graphics.TranslateTransform(-Left, -Top);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Draw a selectionborder around the freehand path\r\n+        /// </summary>\r\n+        /// <param name=\"graphics\">Graphics</param>\r\n+        /// <param name=\"linePen\">Pen</param>\r\n+        /// <param name=\"path\">GraphicsPath</param>\r\n+        protected static void DrawSelectionBorder(Graphics graphics, Pen linePen, GraphicsPath path)\r\n+        {\r\n+            using var selectionPen = (Pen) linePen.Clone();\r\n+            using var selectionPath = (GraphicsPath) path.Clone();\r\n+            selectionPen.Width += 5;\r\n+            selectionPen.Color = Color.FromArgb(120, Color.LightSeaGreen);\r\n+            graphics.DrawPath(selectionPen, selectionPath);\r\n+            selectionPath.Widen(selectionPen);\r\n+            selectionPen.DashPattern = new float[]\r\n+            {\r\n+                2, 2\r\n+            };\r\n+            selectionPen.Color = Color.LightSeaGreen;\r\n+            selectionPen.Width = 1;\r\n+            graphics.DrawPath(selectionPen, selectionPath);\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// Get the bounds in which we have something drawn, plus safety margin, these are not the normal bounds...\r\n+        /// </summary>\r\n+        public override NativeRect DrawingBounds\r\n+        {\r\n+            get\r\n+            {\r\n+                if (!myBounds.IsEmpty)\r\n+                {\r\n+                    int lineThickness = Math.Max(10, GetFieldValueAsInt(FieldType.LINE_THICKNESS));\r\n+                    int safetyMargin = 10;\r\n+                    return new NativeRect(myBounds.Left + Left - (safetyMargin + lineThickness), myBounds.Top + Top - (safetyMargin + lineThickness),\r\n+                        myBounds.Width + 2 * (lineThickness + safetyMargin), myBounds.Height + 2 * (lineThickness + safetyMargin));\r\n+                }\r\n+\r\n+                if (_parent?.Image is Image image)\r\n+                {\r\n+                    return new NativeRect(0, 0, image.Width, image.Height);\r\n+                }\r\n+\r\n+                return NativeRect.Empty;\r\n+            }\r\n+        }\r\n+\r\n+        /// <summary>\r\n+        /// FreehandContainer are regarded equal if they are of the same type and their paths are equal.\r\n+        /// </summary>\r\n+        /// <param name=\"obj\">object</param>\r\n+        /// <returns>bool</returns>\r\n+        public override bool Equals(object obj)\r\n+        {\r\n+            bool ret = false;\r\n+            if (obj == null || GetType() != obj.GetType())\r\n+            {\r\n+                return false;\r\n+            }\r\n+\r\n+            if (obj is FreehandContainer other && Equals(freehandPath, other.freehandPath))\r\n+            {\r\n+                ret = true;\r\n+            }\r\n+\r\n+            return ret;\r\n+        }\r\n+\r\n+        public override int GetHashCode()\r\n+        {\r\n+            return freehandPath?.GetHashCode() ?? 0;\r\n+        }\r\n+\r\n+        public override bool ClickableAt(int x, int y)\r\n+        {\r\n+            bool returnValue = base.ClickableAt(x, y);\r\n+            if (returnValue)\r\n+            {\r\n+                int lineThickness = GetFieldValueAsInt(FieldType.LINE_THICKNESS);\r\n+                using var pen = new Pen(Color.White)\r\n+                {\r\n+                    Width = lineThickness + 10\r\n+                };\r\n+                returnValue = freehandPath.IsOutlineVisible(x - Left, y - Top, pen);\r\n+            }\r\n+\r\n+            return returnValue;\r\n+        }\r\n+   }\r\n }\n\\ No newline at end of file"
        },
        {
          "filename": "src/Greenshot.Editor/Drawing/SpeechbubbleContainer.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -39,10 +39,10 @@ namespace Greenshot.Editor.Drawing\n     [Serializable]\n     public class SpeechbubbleContainer : TextContainer\n     {\n-        private NativePoint _initialGripperPoint;\n+        private Point _initialGripperPoint;\n \n         // Only used for serializing the TargetGripper location\n-        private NativePoint _storedTargetGripperLocation;\n+        private Point _storedTargetGripperLocation;\n \n         /// <summary>\n         /// Store the current location of the target gripper\n@@ -120,7 +120,8 @@ public override bool HandleMouseMove(int x, int y)\n             int xOffset = leftAligned ? -20 : 20;\n             int yOffset = topAligned ? -20 : 20;\n \n-            NativePoint newGripperLocation = _initialGripperPoint.Offset(xOffset, yOffset);\n+            NativePoint initialGripperPoint = _initialGripperPoint;\n+            NativePoint newGripperLocation = initialGripperPoint.Offset(xOffset, yOffset);\n \n             if (TargetAdorner.Location != newGripperLocation)\n             {"
        },
        {
          "filename": "src/Greenshot.Editor/Drawing/Surface.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -28,6 +28,7 @@\n using System.IO;\n using System.Linq;\n using System.Runtime.Serialization.Formatters.Binary;\n+using System.ServiceModel.Security;\r\n using System.Windows.Forms;\n using Dapplo.Windows.Common.Extensions;\n using Dapplo.Windows.Common.Structs;\n@@ -40,6 +41,7 @@\n using Greenshot.Base.Interfaces.Drawing.Adorners;\n using Greenshot.Editor.Configuration;\n using Greenshot.Editor.Drawing.Fields;\n+using Greenshot.Editor.Helpers;\r\n using Greenshot.Editor.Memento;\n using log4net;\n \n@@ -722,6 +724,7 @@ public void LoadElementsFromStream(Stream streamRead)\n             try\n             {\n                 BinaryFormatter binaryRead = new BinaryFormatter();\n+                binaryRead.Binder = new BinaryFormatterHelper();\n                 IDrawableContainerList loadedElements = (IDrawableContainerList) binaryRead.Deserialize(streamRead);\n                 loadedElements.Parent = this;\n                 // Make sure the steplabels are sorted according to their number\n@@ -731,6 +734,10 @@ public void LoadElementsFromStream(Stream streamRead)\n                 SelectElements(loadedElements);\n                 FieldAggregator.BindElements(loadedElements);\n             }\n+            catch (SecurityAccessDeniedException)\r\n+            {\r\n+                throw;\r\n+            }\n             catch (Exception e)\n             {\n                 LOG.Error(\"Error serializing elements from stream.\", e);"
        },
        {
          "filename": "src/Greenshot.Editor/Helpers/BinaryFormatterHelper.cs",
          "status": "added",
          "additions": 111,
          "deletions": 0,
          "patch": "@@ -0,0 +1,111 @@\n+\ufeff/*\r\n+ * Greenshot - a free and open source screenshot tool\r\n+ * Copyright (C) 2007-2021 Thomas Braun, Jens Klingen, Robin Krom\r\n+ * \r\n+ * For more information see: https://getgreenshot.org/\r\n+ * The Greenshot project is hosted on GitHub https://github.com/greenshot/greenshot\r\n+ * \r\n+ * This program is free software: you can redistribute it and/or modify\r\n+ * it under the terms of the GNU General Public License as published by\r\n+ * the Free Software Foundation, either version 1 of the License, or\r\n+ * (at your option) any later version.\r\n+ * \r\n+ * This program is distributed in the hope that it will be useful,\r\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n+ * GNU General Public License for more details.\r\n+ * \r\n+ * You should have received a copy of the GNU General Public License\r\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n+ */\r\n+\r\n+using System;\r\n+using System.Collections.Generic;\r\n+using System.Runtime.Serialization;\r\n+using System.ServiceModel.Security;\r\n+using Greenshot.Base.Interfaces.Drawing;\r\n+using Greenshot.Editor.Drawing;\r\n+using Greenshot.Editor.Drawing.Fields;\r\n+using Greenshot.Editor.Drawing.Filters;\r\n+using log4net;\r\n+using static Greenshot.Editor.Drawing.FilterContainer;\r\n+\r\n+namespace Greenshot.Editor.Helpers\r\n+{\r\n+    internal class BinaryFormatterHelper : SerializationBinder\r\n+    {\r\n+        private static readonly ILog LOG = LogManager.GetLogger(typeof(BinaryFormatterHelper));\r\n+        private static readonly IDictionary<string, Type> TypeMapper = new Dictionary<string, Type>\r\n+        {\r\n+            {\"System.Guid\",typeof(Guid) },\r\n+            {\"System.Drawing.Rectangle\",typeof(System.Drawing.Rectangle) },\r\n+            {\"System.Drawing.Point\",typeof(System.Drawing.Point) },\r\n+            {\"System.Drawing.Color\",typeof(System.Drawing.Color) },\r\n+            {\"System.Drawing.Bitmap\",typeof(System.Drawing.Bitmap) },\r\n+            {\"System.Drawing.StringAlignment\",typeof(System.Drawing.StringAlignment) },\r\n+            {\"System.Collections.Generic.List`1[[Greenshot.Base.Interfaces.Drawing.IFieldHolder\", typeof(List<IFieldHolder>)},\r\n+            {\"System.Collections.Generic.List`1[[Greenshot.Base.Interfaces.Drawing.IField\", typeof(List<IField>)},\r\n+            {\"System.Collections.Generic.List`1[[System.Drawing.Point\", typeof(List<System.Drawing.Point>)},\r\n+            {\"Greenshot.Editor.Drawing.ArrowContainer\", typeof(ArrowContainer) },\r\n+            {\"Greenshot.Editor.Drawing.LineContainer\", typeof(LineContainer) },\r\n+            {\"Greenshot.Editor.Drawing.TextContainer\", typeof(TextContainer) },\r\n+            {\"Greenshot.Editor.Drawing.SpeechbubbleContainer\", typeof(SpeechbubbleContainer) },\r\n+            {\"Greenshot.Editor.Drawing.RectangleContainer\", typeof(RectangleContainer) },\r\n+            {\"Greenshot.Editor.Drawing.EllipseContainer\", typeof(EllipseContainer) },\r\n+            {\"Greenshot.Editor.Drawing.FreehandContainer\", typeof(FreehandContainer) },\r\n+            {\"Greenshot.Editor.Drawing.HighlightContainer\", typeof(HighlightContainer) },\r\n+            {\"Greenshot.Editor.Drawing.IconContainer\", typeof(IconContainer) },\r\n+            {\"Greenshot.Editor.Drawing.ObfuscateContainer\", typeof(ObfuscateContainer) },\r\n+            {\"Greenshot.Editor.Drawing.StepLabelContainer\", typeof(StepLabelContainer) },\r\n+            {\"Greenshot.Editor.Drawing.SvgContainer\", typeof(SvgContainer) },\r\n+            {\"Greenshot.Editor.Drawing.VectorGraphicsContainer\", typeof(VectorGraphicsContainer) },\r\n+            {\"Greenshot.Editor.Drawing.MetafileContainer\", typeof(MetafileContainer) },\r\n+            {\"Greenshot.Editor.Drawing.ImageContainer\", typeof(ImageContainer) },\r\n+            {\"Greenshot.Editor.Drawing.FilterContainer\", typeof(FilterContainer) },\r\n+            {\"Greenshot.Editor.Drawing.DrawableContainer\", typeof(DrawableContainer) },\r\n+            {\"Greenshot.Editor.Drawing.DrawableContainerList\", typeof(DrawableContainerList) },\r\n+            {\"Greenshot.Editor.Drawing.CursorContainer\", typeof(CursorContainer) },\r\n+            {\"Greenshot.Editor.Drawing.Filters.HighlightFilter\", typeof(HighlightFilter) },\r\n+            {\"Greenshot.Editor.Drawing.Filters.GrayscaleFilter\", typeof(GrayscaleFilter) },\r\n+            {\"Greenshot.Editor.Drawing.Filters.MagnifierFilter\", typeof(MagnifierFilter) },\r\n+            {\"Greenshot.Editor.Drawing.Filters.BrightnessFilter\", typeof(BrightnessFilter) },\r\n+            {\"Greenshot.Editor.Drawing.Filters.BlurFilter\", typeof(BlurFilter) },\r\n+            {\"Greenshot.Editor.Drawing.Filters.PixelizationFilter\", typeof(PixelizationFilter) },\r\n+            {\"Greenshot.Base.Interfaces.Drawing.IDrawableContainer\", typeof(IDrawableContainer) },\r\n+            {\"Greenshot.Base.Interfaces.Drawing.EditStatus\", typeof(EditStatus) },\r\n+            {\"Greenshot.Base.Interfaces.Drawing.IFieldHolder\", typeof(IFieldHolder) },\r\n+            {\"Greenshot.Base.Interfaces.Drawing.IField\", typeof(IField) },\r\n+            {\"Greenshot.Base.Interfaces.Drawing.FieldFlag\", typeof(FieldFlag) },\r\n+            {\"Greenshot.Editor.Drawing.Fields.Field\", typeof(Field) },\r\n+            {\"Greenshot.Editor.Drawing.Fields.FieldType\", typeof(FieldType) },\r\n+            {\"Greenshot.Editor.Drawing.FilterContainer+PreparedFilter\", typeof(PreparedFilter) },\r\n+        };\r\n+        // Greenshot.Plugin.Drawing.EditStatus -> Greenshot.Base.Interfaces.Drawing.EditStatus\r\n+        // GreenshotPlugin.Interfaces.Drawing.IFieldHolder -> Greenshot.Base.Interfaces.Drawing.IFieldHolder\r\n+        // Greenshot.Drawing.FilterContainer+PreparedFilter -> Greenshot.Editor.Drawing\r\n+        public override Type BindToType(string assemblyName, string typeName)\r\n+        {\r\n+            if (string.IsNullOrEmpty(typeName))\r\n+            {\r\n+                return null;\r\n+            }\r\n+            var typeNameCommaLocation = typeName.IndexOf(\",\");\r\n+            var comparingTypeName = typeName.Substring(0, typeNameCommaLocation > 0 ? typeNameCommaLocation : typeName.Length);\r\n+\r\n+            // Correct wrong types\r\n+            comparingTypeName = comparingTypeName.Replace(\"Greenshot.Drawing\", \"Greenshot.Editor.Drawing\");\r\n+            comparingTypeName = comparingTypeName.Replace(\"Greenshot.Plugin.Drawing\", \"Greenshot.Base.Interfaces.Drawing\");\r\n+            comparingTypeName = comparingTypeName.Replace(\"GreenshotPlugin.Interfaces.Drawing\", \"Greenshot.Base.Interfaces.Drawing\");\r\n+            comparingTypeName = comparingTypeName.Replace(\"Greenshot.Drawing.Fields\", \"Greenshot.Editor.Drawing.Fields\");\r\n+            comparingTypeName = comparingTypeName.Replace(\"Greenshot.Drawing.Filters\", \"Greenshot.Editor.Drawing.Filters\");\r\n+\r\n+            if (TypeMapper.TryGetValue(comparingTypeName, out var returnType))\r\n+            {\r\n+                LOG.Info($\"Mapped {assemblyName} - {typeName} to {returnType.FullName}\");\r\n+                return returnType;\r\n+            }\r\n+            LOG.Warn($\"Unexpected Greenshot type in .greenshot file detected, maybe vulnerability attack created with ysoserial? Suspicious type: {assemblyName} - {typeName}\");\r\n+            throw new SecurityAccessDeniedException($\"Suspicious type in .greenshot file: {assemblyName} - {typeName}\");\r\n+        }\r\n+    }\r\n+}\r"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "245f6f261bb49a7ba6f51cd6de488af411a1bd6f",
            "date": "2024-08-18T09:22:45Z",
            "author_login": "jklingen"
          },
          {
            "sha": "bb7a3743905f80ec8459771aa49cb24c55e60cc7",
            "date": "2023-10-03T14:11:09Z",
            "author_login": "jklingen"
          },
          {
            "sha": "a3e65fee6f21b321daeb0eba9b6871396b60e1d6",
            "date": "2023-04-16T17:25:14Z",
            "author_login": "jglathe"
          },
          {
            "sha": "f862e794858631c2e2ebdb2678617071208cfd8b",
            "date": "2023-03-27T20:43:03Z",
            "author_login": "Lakritzator"
          },
          {
            "sha": "099e6569633d8bc678f96d066d0cdcc744698638",
            "date": "2023-03-27T20:27:02Z",
            "author_login": "Lakritzator"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": null,
    "description": "Greenshot 1.2.10 and below allows arbitrary code execution because .NET content is insecurely deserialized when a .greenshot file is opened.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-08-01T14:15:10.070",
    "last_modified": "2024-11-21T08:07:28.073",
    "fix_date": "2023-03-27T19:51:01Z"
  },
  "references": [
    {
      "url": "http://packetstormsecurity.com/files/173825/GreenShot-1.2.10-Arbitrary-Code-Execution.html",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://packetstormsecurity.com/files/174222/Greenshot-1.3.274-Deserialization-Command-Execution.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/greenshot/greenshot/commit/a152e2883fca7f78051b3bd6b1e5cc57355cb44c",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://greenshot.atlassian.net/browse/BUG-3061",
      "source": "cve@mitre.org",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.exploit-db.com/exploits/51633",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://packetstormsecurity.com/files/173825/GreenShot-1.2.10-Arbitrary-Code-Execution.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://packetstormsecurity.com/files/174222/Greenshot-1.3.274-Deserialization-Command-Execution.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/greenshot/greenshot/commit/a152e2883fca7f78051b3bd6b1e5cc57355cb44c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://greenshot.atlassian.net/browse/BUG-3061",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.exploit-db.com/exploits/51633",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.287813",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "greenshot",
    "owner": "greenshot",
    "created_at": "2015-06-02T19:34:01Z",
    "updated_at": "2025-01-13T13:31:03Z",
    "pushed_at": "2024-08-18T09:22:45Z",
    "size": 47790,
    "stars": 4087,
    "forks": 588,
    "open_issues": 236,
    "watchers": 4087,
    "has_security_policy": false,
    "default_branch": "release/1.3",
    "protected_branches": [
      "master",
      "release/1.2.10"
    ],
    "languages": {
      "C#": 2855737,
      "Inno Setup": 1548624,
      "HTML": 368972,
      "Pascal": 9283,
      "Smalltalk": 3396,
      "NSIS": 274
    },
    "commit_activity": {
      "total_commits_last_year": 1,
      "avg_commits_per_week": 0.019230769230769232,
      "days_active_last_year": 1
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T12:55:27.650240"
  }
}