{
  "cve_id": "CVE-2023-35163",
  "github_data": {
    "repository": "vegaprotocol/vega",
    "fix_commit": "56b09bf57af8cd9eca5996252d86f469a3e34c68",
    "related_commits": [
      "56b09bf57af8cd9eca5996252d86f469a3e34c68",
      "56b09bf57af8cd9eca5996252d86f469a3e34c68"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "56b09bf57af8cd9eca5996252d86f469a3e34c68",
      "commit_date": "2023-06-20T09:21:26Z",
      "author": {
        "login": "jeremyletang",
        "type": "User",
        "stats": {
          "total_commits": 6429,
          "average_weekly_commits": 17.517711171662125,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 278
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-8rc9-vxjh-qjf2",
        "length": 82,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 109,
        "additions": 63,
        "deletions": 46
      },
      "files": [
        {
          "filename": "core/banking/asset_action.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -154,29 +154,29 @@ func (t *assetAction) checkBuiltinAssetDeposit() error {\n \n func (t *assetAction) checkERC20BridgeStopped() error {\n \treturn t.bridgeView.FindBridgeStopped(\n-\t\tt.erc20BridgeStopped, t.blockHeight, t.logIndex)\n+\t\tt.erc20BridgeStopped, t.blockHeight, t.logIndex, t.txHash)\n }\n \n func (t *assetAction) checkERC20BridgeResumed() error {\n \treturn t.bridgeView.FindBridgeResumed(\n-\t\tt.erc20BridgeResumed, t.blockHeight, t.logIndex)\n+\t\tt.erc20BridgeResumed, t.blockHeight, t.logIndex, t.txHash)\n }\n \n func (t *assetAction) checkERC20Deposit() error {\n \tasset, _ := t.asset.ERC20()\n \treturn t.bridgeView.FindDeposit(\n-\t\tt.erc20D, t.blockHeight, t.logIndex, asset.Address(),\n+\t\tt.erc20D, t.blockHeight, t.logIndex, asset.Address(), t.txHash,\n \t)\n }\n \n func (t *assetAction) checkERC20AssetList() error {\n-\treturn t.bridgeView.FindAssetList(t.erc20AL, t.blockHeight, t.logIndex)\n+\treturn t.bridgeView.FindAssetList(t.erc20AL, t.blockHeight, t.logIndex, t.txHash)\n }\n \n func (t *assetAction) checkERC20AssetLimitsUpdated() error {\n \tasset, _ := t.asset.ERC20()\n \treturn t.bridgeView.FindAssetLimitsUpdated(\n-\t\tt.erc20AssetLimitsUpdated, t.blockHeight, t.logIndex, asset.Address(),\n+\t\tt.erc20AssetLimitsUpdated, t.blockHeight, t.logIndex, asset.Address(), t.txHash,\n \t)\n }\n "
        },
        {
          "filename": "core/banking/erc20.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -34,11 +34,11 @@ var (\n )\n \n type ERC20BridgeView interface {\n-\tFindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64) error\n-\tFindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64) error\n-\tFindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64) error\n-\tFindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string) error\n-\tFindAssetLimitsUpdated(update *types.ERC20AssetLimitsUpdated, blockNumber uint64, logIndex uint64, ethAssetAddress string) error\n+\tFindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64, txHash string) error\n+\tFindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64, txHash string) error\n+\tFindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64, txHash string) error\n+\tFindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error\n+\tFindAssetLimitsUpdated(update *types.ERC20AssetLimitsUpdated, blockNumber uint64, logIndex uint64, ethAssetAddress string, txHash string) error\n }\n \n func (e *Engine) EnableERC20("
        },
        {
          "filename": "core/banking/mocks/mocks.go",
          "status": "modified",
          "additions": 20,
          "deletions": 20,
          "patch": "@@ -504,73 +504,73 @@ func (m *MockERC20BridgeView) EXPECT() *MockERC20BridgeViewMockRecorder {\n }\n \n // FindAssetLimitsUpdated mocks base method.\n-func (m *MockERC20BridgeView) FindAssetLimitsUpdated(arg0 *types.ERC20AssetLimitsUpdated, arg1, arg2 uint64, arg3 string) error {\n+func (m *MockERC20BridgeView) FindAssetLimitsUpdated(arg0 *types.ERC20AssetLimitsUpdated, arg1, arg2 uint64, arg3, arg4 string) error {\n \tm.ctrl.T.Helper()\n-\tret := m.ctrl.Call(m, \"FindAssetLimitsUpdated\", arg0, arg1, arg2, arg3)\n+\tret := m.ctrl.Call(m, \"FindAssetLimitsUpdated\", arg0, arg1, arg2, arg3, arg4)\n \tret0, _ := ret[0].(error)\n \treturn ret0\n }\n \n // FindAssetLimitsUpdated indicates an expected call of FindAssetLimitsUpdated.\n-func (mr *MockERC20BridgeViewMockRecorder) FindAssetLimitsUpdated(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n+func (mr *MockERC20BridgeViewMockRecorder) FindAssetLimitsUpdated(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n \tmr.mock.ctrl.T.Helper()\n-\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetLimitsUpdated\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetLimitsUpdated), arg0, arg1, arg2, arg3)\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetLimitsUpdated\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetLimitsUpdated), arg0, arg1, arg2, arg3, arg4)\n }\n \n // FindAssetList mocks base method.\n-func (m *MockERC20BridgeView) FindAssetList(arg0 *types.ERC20AssetList, arg1, arg2 uint64) error {\n+func (m *MockERC20BridgeView) FindAssetList(arg0 *types.ERC20AssetList, arg1, arg2 uint64, arg3 string) error {\n \tm.ctrl.T.Helper()\n-\tret := m.ctrl.Call(m, \"FindAssetList\", arg0, arg1, arg2)\n+\tret := m.ctrl.Call(m, \"FindAssetList\", arg0, arg1, arg2, arg3)\n \tret0, _ := ret[0].(error)\n \treturn ret0\n }\n \n // FindAssetList indicates an expected call of FindAssetList.\n-func (mr *MockERC20BridgeViewMockRecorder) FindAssetList(arg0, arg1, arg2 interface{}) *gomock.Call {\n+func (mr *MockERC20BridgeViewMockRecorder) FindAssetList(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n \tmr.mock.ctrl.T.Helper()\n-\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetList\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetList), arg0, arg1, arg2)\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAssetList\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindAssetList), arg0, arg1, arg2, arg3)\n }\n \n // FindBridgeResumed mocks base method.\n-func (m *MockERC20BridgeView) FindBridgeResumed(arg0 *types.ERC20EventBridgeResumed, arg1, arg2 uint64) error {\n+func (m *MockERC20BridgeView) FindBridgeResumed(arg0 *types.ERC20EventBridgeResumed, arg1, arg2 uint64, arg3 string) error {\n \tm.ctrl.T.Helper()\n-\tret := m.ctrl.Call(m, \"FindBridgeResumed\", arg0, arg1, arg2)\n+\tret := m.ctrl.Call(m, \"FindBridgeResumed\", arg0, arg1, arg2, arg3)\n \tret0, _ := ret[0].(error)\n \treturn ret0\n }\n \n // FindBridgeResumed indicates an expected call of FindBridgeResumed.\n-func (mr *MockERC20BridgeViewMockRecorder) FindBridgeResumed(arg0, arg1, arg2 interface{}) *gomock.Call {\n+func (mr *MockERC20BridgeViewMockRecorder) FindBridgeResumed(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n \tmr.mock.ctrl.T.Helper()\n-\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeResumed\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeResumed), arg0, arg1, arg2)\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeResumed\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeResumed), arg0, arg1, arg2, arg3)\n }\n \n // FindBridgeStopped mocks base method.\n-func (m *MockERC20BridgeView) FindBridgeStopped(arg0 *types.ERC20EventBridgeStopped, arg1, arg2 uint64) error {\n+func (m *MockERC20BridgeView) FindBridgeStopped(arg0 *types.ERC20EventBridgeStopped, arg1, arg2 uint64, arg3 string) error {\n \tm.ctrl.T.Helper()\n-\tret := m.ctrl.Call(m, \"FindBridgeStopped\", arg0, arg1, arg2)\n+\tret := m.ctrl.Call(m, \"FindBridgeStopped\", arg0, arg1, arg2, arg3)\n \tret0, _ := ret[0].(error)\n \treturn ret0\n }\n \n // FindBridgeStopped indicates an expected call of FindBridgeStopped.\n-func (mr *MockERC20BridgeViewMockRecorder) FindBridgeStopped(arg0, arg1, arg2 interface{}) *gomock.Call {\n+func (mr *MockERC20BridgeViewMockRecorder) FindBridgeStopped(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n \tmr.mock.ctrl.T.Helper()\n-\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeStopped\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeStopped), arg0, arg1, arg2)\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindBridgeStopped\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindBridgeStopped), arg0, arg1, arg2, arg3)\n }\n \n // FindDeposit mocks base method.\n-func (m *MockERC20BridgeView) FindDeposit(arg0 *types.ERC20Deposit, arg1, arg2 uint64, arg3 string) error {\n+func (m *MockERC20BridgeView) FindDeposit(arg0 *types.ERC20Deposit, arg1, arg2 uint64, arg3, arg4 string) error {\n \tm.ctrl.T.Helper()\n-\tret := m.ctrl.Call(m, \"FindDeposit\", arg0, arg1, arg2, arg3)\n+\tret := m.ctrl.Call(m, \"FindDeposit\", arg0, arg1, arg2, arg3, arg4)\n \tret0, _ := ret[0].(error)\n \treturn ret0\n }\n \n // FindDeposit indicates an expected call of FindDeposit.\n-func (mr *MockERC20BridgeViewMockRecorder) FindDeposit(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n+func (mr *MockERC20BridgeViewMockRecorder) FindDeposit(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n \tmr.mock.ctrl.T.Helper()\n-\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindDeposit\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindDeposit), arg0, arg1, arg2, arg3)\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindDeposit\", reflect.TypeOf((*MockERC20BridgeView)(nil).FindDeposit), arg0, arg1, arg2, arg3, arg4)\n }\n \n // MockEthereumEventSource is a mock of EthereumEventSource interface."
        },
        {
          "filename": "core/bridges/erc20_logic_view.go",
          "status": "modified",
          "additions": 18,
          "deletions": 6,
          "patch": "@@ -111,6 +111,7 @@ func (e *ERC20LogicView) FindAssetList(\n \tal *types.ERC20AssetList,\n \tblockNumber,\n \tlogIndex uint64,\n+\ttxHash string,\n ) error {\n \tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n \t\te.clt.CollateralBridgeAddress(), e.clt)\n@@ -145,7 +146,8 @@ func (e *ERC20LogicView) FindAssetList(\n \tfor iter.Next() {\n \t\tif hex.EncodeToString(iter.Event.VegaAssetId[:]) == assetID &&\n \t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n-\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n+\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n \t\t\tevent = iter.Event\n \n \t\t\tbreak\n@@ -170,6 +172,7 @@ func (e *ERC20LogicView) FindBridgeStopped(\n \tal *types.ERC20EventBridgeStopped,\n \tblockNumber,\n \tlogIndex uint64,\n+\ttxHash string,\n ) error {\n \tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n \t\te.clt.CollateralBridgeAddress(), e.clt)\n@@ -200,7 +203,8 @@ func (e *ERC20LogicView) FindBridgeStopped(\n \n \tfor iter.Next() {\n \t\tif iter.Event.Raw.BlockNumber == blockNumber &&\n-\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n+\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n \t\t\tevent = iter.Event\n \n \t\t\tbreak\n@@ -225,6 +229,7 @@ func (e *ERC20LogicView) FindBridgeResumed(\n \tal *types.ERC20EventBridgeResumed,\n \tblockNumber,\n \tlogIndex uint64,\n+\ttxHash string,\n ) error {\n \tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n \t\te.clt.CollateralBridgeAddress(), e.clt)\n@@ -255,7 +260,8 @@ func (e *ERC20LogicView) FindBridgeResumed(\n \n \tfor iter.Next() {\n \t\tif iter.Event.Raw.BlockNumber == blockNumber &&\n-\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n+\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n \t\t\tevent = iter.Event\n \n \t\t\tbreak\n@@ -278,6 +284,7 @@ func (e *ERC20LogicView) FindDeposit(\n \td *types.ERC20Deposit,\n \tblockNumber, logIndex uint64,\n \tethAssetAddress string,\n+\ttxHash string,\n ) error {\n \tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n \t\te.clt.CollateralBridgeAddress(), e.clt)\n@@ -315,7 +322,8 @@ func (e *ERC20LogicView) FindDeposit(\n \t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == targetPartyID &&\n \t\t\titer.Event.Amount.Cmp(depamount) == 0 &&\n \t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n-\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n+\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n \t\t\tevent = iter.Event\n \t\t\tbreak\n \t\t}\n@@ -337,6 +345,7 @@ func (e *ERC20LogicView) FindWithdrawal(\n \tw *types.ERC20Withdrawal,\n \tblockNumber, logIndex uint64,\n \tethAssetAddress string,\n+\ttxHash string,\n ) (*big.Int, string, uint, error) {\n \tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n \t\te.clt.CollateralBridgeAddress(), e.clt)\n@@ -376,7 +385,8 @@ func (e *ERC20LogicView) FindWithdrawal(\n \tfor iter.Next() {\n \t\tif nonce.Cmp(iter.Event.Nonce) == 0 &&\n \t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n-\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n+\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n \t\t\tevent = iter.Event\n \n \t\t\tbreak\n@@ -399,6 +409,7 @@ func (e *ERC20LogicView) FindAssetLimitsUpdated(\n \tupdate *types.ERC20AssetLimitsUpdated,\n \tblockNumber uint64, logIndex uint64,\n \tethAssetAddress string,\n+\ttxHash string,\n ) error {\n \tbf, err := bridgecontract.NewErc20BridgeLogicRestrictedFilterer(\n \t\te.clt.CollateralBridgeAddress(), e.clt)\n@@ -434,7 +445,8 @@ func (e *ERC20LogicView) FindAssetLimitsUpdated(\n \t\tif update.LifetimeLimits.EQ(eventLifetimeLimit) &&\n \t\t\tupdate.WithdrawThreshold.EQ(eventWithdrawThreshold) &&\n \t\t\titer.Event.Raw.BlockNumber == blockNumber &&\n-\t\t\tuint64(iter.Event.Raw.Index) == logIndex {\n+\t\t\tuint64(iter.Event.Raw.Index) == logIndex &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == txHash {\n \t\t\tevent = iter.Event\n \t\t\tbreak\n \t\t}"
        },
        {
          "filename": "core/integration/stubs/bridge_view_stub.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -22,22 +22,22 @@ func NewBridgeViewStub() *BridgeViewStub {\n \treturn &BridgeViewStub{}\n }\n \n-func (*BridgeViewStub) FindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64) error {\n+func (*BridgeViewStub) FindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64, txHash string) error {\n \treturn nil\n }\n \n-func (*BridgeViewStub) FindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64) error {\n+func (*BridgeViewStub) FindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64, txHash string) error {\n \treturn nil\n }\n \n-func (*BridgeViewStub) FindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64) error {\n+func (*BridgeViewStub) FindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64, txHash string) error {\n \treturn nil\n }\n \n-func (*BridgeViewStub) FindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string) error {\n+func (*BridgeViewStub) FindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error {\n \treturn nil\n }\n \n-func (*BridgeViewStub) FindAssetLimitsUpdated(w *types.ERC20AssetLimitsUpdated, blockNumber, logIndex uint64, ethAssetAddress string) error {\n+func (*BridgeViewStub) FindAssetLimitsUpdated(w *types.ERC20AssetLimitsUpdated, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error {\n \treturn nil\n }"
        },
        {
          "filename": "core/staking/on_chain_verifier.go",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -138,7 +138,8 @@ func (o *OnChainVerifier) CheckStakeDeposited(\n \t\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == vegaPubKey &&\n \t\t\t\titer.Event.Amount.Cmp(amountDeposited) == 0 &&\n \t\t\t\titer.Event.Raw.BlockNumber == event.BlockNumber &&\n-\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex {\n+\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n+\t\t\t\titer.Event.Raw.TxHash.Hex() == event.TxID {\n \t\t\t\t// now we know the event is OK,\n \t\t\t\t// just need to check for confirmations\n \t\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n@@ -216,7 +217,8 @@ func (o *OnChainVerifier) CheckStakeRemoved(event *types.StakeRemoved) error {\n \t\t\tif hex.EncodeToString(iter.Event.VegaPublicKey[:]) == vegaPubKey &&\n \t\t\t\titer.Event.Amount.Cmp(amountDeposited) == 0 &&\n \t\t\t\titer.Event.Raw.BlockNumber == event.BlockNumber &&\n-\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex {\n+\t\t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n+\t\t\t\titer.Event.Raw.TxHash.Hex() == event.TxID {\n \t\t\t\t// now we know the event is OK,\n \t\t\t\t// just need to check for confirmations\n \t\t\t\treturn o.ethConfirmations.Check(event.BlockNumber)"
        },
        {
          "filename": "core/validators/erc20multisig/on_chain_verifier.go",
          "status": "modified",
          "additions": 6,
          "deletions": 3,
          "patch": "@@ -165,7 +165,8 @@ func (o *OnChainVerifier) CheckThresholdSetEvent(\n \t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n \t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n \t\t\titer.Event.NewThreshold == uint16(event.Threshold) &&\n-\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 {\n+\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == event.TxHash {\n \t\t\t// now we know the event is OK,\n \t\t\t// just need to check for confirmations\n \t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n@@ -205,7 +206,8 @@ func (o *OnChainVerifier) filterSignerAdded(\n \t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n \t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n \t\t\titer.Event.NewSigner.Hex() == event.Address &&\n-\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 {\n+\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == event.TxHash {\n \t\t\t// now we know the event is OK,\n \t\t\t// just need to check for confirmations\n \t\t\treturn o.ethConfirmations.Check(event.BlockNumber)\n@@ -245,7 +247,8 @@ func (o *OnChainVerifier) filterSignerRemoved(\n \t\tif iter.Event.Raw.BlockNumber == event.BlockNumber &&\n \t\t\tuint64(iter.Event.Raw.Index) == event.LogIndex &&\n \t\t\titer.Event.OldSigner.Hex() == event.Address &&\n-\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 {\n+\t\t\tnonce.Cmp(iter.Event.Nonce) == 0 &&\n+\t\t\titer.Event.Raw.TxHash.Hex() == event.TxHash {\n \t\t\t// now we know the event is OK,\n \t\t\t// just need to check for confirmations\n \t\t\treturn o.ethConfirmations.Check(event.BlockNumber)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "29d7f5e667fb1ec9aff09d0600d597f78c33c8ad",
            "date": "2024-11-08T10:05:47Z",
            "author_login": "jeremyletang"
          },
          {
            "sha": "d4389ee766b7b1fea128e7432d31346773dbccf4",
            "date": "2024-11-07T16:01:19Z",
            "author_login": "edd"
          },
          {
            "sha": "2ffdb8e1b924ce11e6b8547ac8be2850066a791f",
            "date": "2024-11-06T13:54:45Z",
            "author_login": "jeremyletang"
          },
          {
            "sha": "9441602e6f32f1b10b1730ff063eb39ab71d14d3",
            "date": "2024-10-31T13:00:35Z",
            "author_login": "wwestgarth"
          },
          {
            "sha": "e2230d912a93ed6ee88bb0260a201104afa138b8",
            "date": "2024-10-25T10:59:33Z",
            "author_login": "jeremyletang"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.0,
    "cvss_vector": "CVSS:3.1/AV:P/AC:H/PR:H/UI:R/S:C/C:H/I:L/A:L",
    "cwe_id": "CWE-20",
    "description": "Vega is a decentralized trading platform that allows pseudo-anonymous trading of derivatives on a blockchain. Prior to version 0.71.6, a vulnerability exists that allows a malicious validator to trick the Vega network into re-processing past Ethereum events from Vega\u2019s Ethereum bridge. For example, a deposit to the collateral bridge for 100USDT that credits a party\u2019s general account on Vega, can be re-processed 50 times resulting in 5000USDT in that party\u2019s general account. This is without depositing any more than the original 100USDT on the bridge. Despite this exploit requiring access to a validator's Vega key, a validator key can be obtained at the small cost of 3000VEGA, the amount needed to announce a new node onto the network.\n\nA patch is available in version 0.71.6. No known workarounds are available, however there are mitigations in place should this vulnerability be exploited. There are monitoring alerts for `mainnet1` in place to identify any issues of this nature including this vulnerability being exploited. The validators have the ability to stop the bridge thus stopping any withdrawals should this vulnerability be exploited.",
    "attack_vector": "PHYSICAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-06-23T21:15:09.473",
    "last_modified": "2024-11-21T08:08:04.280",
    "fix_date": "2023-06-20T09:21:26Z"
  },
  "references": [
    {
      "url": "https://github.com/vegaprotocol/vega/commit/56b09bf57af8cd9eca5996252d86f469a3e34c68",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vegaprotocol/vega/releases/tag/v0.71.6",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/vegaprotocol/vega/security/advisories/GHSA-8rc9-vxjh-qjf2",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/vegaprotocol/vega/commit/56b09bf57af8cd9eca5996252d86f469a3e34c68",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vegaprotocol/vega/releases/tag/v0.71.6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/vegaprotocol/vega/security/advisories/GHSA-8rc9-vxjh-qjf2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:01.861914",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "vega",
    "owner": "vegaprotocol",
    "created_at": "2020-04-03T16:27:50Z",
    "updated_at": "2024-12-15T07:36:46Z",
    "pushed_at": "2024-12-11T23:52:53Z",
    "size": 238446,
    "stars": 41,
    "forks": 22,
    "open_issues": 216,
    "watchers": 41,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Go": 18809091,
      "Gherkin": 7539320,
      "C++": 723317,
      "PLpgSQL": 247191,
      "Shell": 2840,
      "Makefile": 2838,
      "Dockerfile": 1429
    },
    "commit_activity": {
      "total_commits_last_year": 2057,
      "avg_commits_per_week": 39.55769230769231,
      "days_active_last_year": 196
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-26T08:20:21.240402"
  }
}