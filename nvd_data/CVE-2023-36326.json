{
  "cve_id": "CVE-2023-36326",
  "github_data": {
    "repository": "relic-toolkit/relic",
    "fix_commit": "34580d840469361ba9b5f001361cad659687b9ab",
    "related_commits": [
      "34580d840469361ba9b5f001361cad659687b9ab",
      "34580d840469361ba9b5f001361cad659687b9ab"
    ],
    "patch_url": "https://github.com/relic-toolkit/relic/commit/34580d840469361ba9b5f001361cad659687b9ab.patch",
    "fix_commit_details": {
      "sha": "34580d840469361ba9b5f001361cad659687b9ab",
      "commit_date": "2022-11-14T20:47:12Z",
      "author": {
        "login": "dfaranha",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Huge commit improving the API to use size_t instead of int.",
        "length": 59,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 1427,
        "additions": 764,
        "deletions": 663
      },
      "files": [
        {
          "filename": "bench/bench_bn.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -284,7 +284,7 @@ static void arith(void) {\n \tbn_t a, b, c, d[3], e[3];\n \tcrt_t crt;\n \tdig_t f;\n-\tint len;\n+\tsize_t len;\n \n \tbn_null(a);\n \tbn_null(b);\n@@ -891,7 +891,7 @@ static void arith(void) {\n \n \tBENCH_RUN(\"bn_rec_naf\") {\n \t\tint8_t naf[RLC_BN_BITS + 1];\n-\t\tint len;\n+\t\tsize_t len;\n \t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n \t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_naf(naf, &len, a, 4)));\n \t}\n@@ -901,7 +901,7 @@ static void arith(void) {\n \tif (eb_param_set_any_kbltz() == RLC_OK) {\n \t\tBENCH_RUN(\"bn_rec_tnaf\") {\n \t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n-\t\t\tint len = RLC_BN_BITS + 1;\n+\t\t\tsize_t len = RLC_BN_BITS + 1;\n \t\t\teb_curve_get_ord(b);\n \t\t\tbn_rand_mod(a, b);\n \t\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n@@ -928,7 +928,7 @@ static void arith(void) {\n \n \tBENCH_RUN(\"bn_rec_reg\") {\n \t\tint8_t naf[RLC_BN_BITS + 1];\n-\t\tint len = RLC_BN_BITS + 1;\n+\t\tsize_t len = RLC_BN_BITS + 1;\n \t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n \t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_reg(naf, &len, a, RLC_BN_BITS, 4)));\n \t}"
        },
        {
          "filename": "bench/bench_cp.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -141,28 +141,28 @@ static void benaloh(void) {\n \tdig_t in, new;\n \tuint8_t out[RLC_BN_BITS / 8 + 1];\n \tsize_t out_len;\n+\tdig_t prime = 0xFB;\n \n \tbdpe_null(pub);\n \tbdpe_null(prv);\n \n \tbdpe_new(pub);\n \tbdpe_new(prv);\n \n-\tBENCH_ONE(\"cp_bdpe_gen\", cp_bdpe_gen(pub, prv, bn_get_prime(47),\n-\t\tRLC_BN_BITS), 1);\n+\tBENCH_ONE(\"cp_bdpe_gen\", cp_bdpe_gen(pub, prv, prime, RLC_BN_BITS), 1);\n \n \tBENCH_RUN(\"cp_bdpe_enc\") {\n \t\tout_len = RLC_BN_BITS / 8 + 1;\n \t\trand_bytes(out, 1);\n-\t\tin = out[0] % bn_get_prime(47);\n+\t\tin = out[0] % prime;\n \t\tBENCH_ADD(cp_bdpe_enc(out, &out_len, in, pub));\n \t\tcp_bdpe_dec(&new, out, out_len, prv);\n \t} BENCH_END;\n \n \tBENCH_RUN(\"cp_bdpe_dec\") {\n \t\tout_len = RLC_BN_BITS / 8 + 1;\n \t\trand_bytes(out, 1);\n-\t\tin = out[0] % bn_get_prime(47);\n+\t\tin = out[0] % prime;\n \t\tcp_bdpe_enc(out, &out_len, in, pub);\n \t\tBENCH_ADD(cp_bdpe_dec(&new, out, out_len, prv));\n \t} BENCH_END;"
        },
        {
          "filename": "bench/bench_epx.c",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -37,17 +37,17 @@\n static void memory2(void) {\n \tep2_t a[BENCH];\n \n-\tBENCH_FEW(\"ep2_null\", ep4_null(a[i]), 1);\n+\tBENCH_FEW(\"ep2_null\", ep2_null(a[i]), 1);\n \n-\tBENCH_FEW(\"ep2_new\", ep4_new(a[i]), 1);\n+\tBENCH_FEW(\"ep2_new\", ep2_new(a[i]), 1);\n \tfor (int i = 0; i < BENCH; i++) {\n \t\tep2_free(a[i]);\n \t}\n \n \tfor (int i = 0; i < BENCH; i++) {\n \t\tep2_new(a[i]);\n \t}\n-\tBENCH_FEW(\"ep2_free\", ep4_free(a[i]), 1);\n+\tBENCH_FEW(\"ep2_free\", ep2_free(a[i]), 1);\n \n \t(void)a;\n }"
        },
        {
          "filename": "include/relic_bn.h",
          "status": "modified",
          "additions": 42,
          "deletions": 39,
          "patch": "@@ -53,22 +53,22 @@\n  * multiple precision integer must grow. Otherwise, it represents the fixed\n  * fixed precision.\n  */\n-#define RLC_BN_BITS \t((int)BN_PRECI)\n+#define RLC_BN_BITS \t((size_t)BN_PRECI)\n \n /**\n  * Size in digits of a block sufficient to store the required precision.\n  */\n-#define RLC_BN_DIGS\t\t((int)RLC_CEIL(BN_PRECI, RLC_DIG))\n+#define RLC_BN_DIGS\t\t((size_t)RLC_CEIL(BN_PRECI, RLC_DIG))\n \n /**\n  * Size in digits of a block sufficient to store a multiple precision integer.\n  */\n #if BN_MAGNI == DOUBLE\n-#define RLC_BN_SIZE\t\t((int)(2 * RLC_BN_DIGS + 2))\n+#define RLC_BN_SIZE\t\t((size_t)(2 * RLC_BN_DIGS + 2))\n #elif BN_MAGNI == CARRY\n-#define RLC_BN_SIZE\t\t((int)(RLC_BN_DIGS + 1))\n+#define RLC_BN_SIZE\t\t((size_t)(RLC_BN_DIGS + 1))\n #elif BN_MAGNI == SINGLE\n-#define RLC_BN_SIZE\t\t((int)RLC_BN_DIGS)\n+#define RLC_BN_SIZE\t\t((size_t)RLC_BN_DIGS)\n #endif\n \n /**\n@@ -94,9 +94,9 @@\n  */\n typedef struct {\n \t/** The number of digits allocated to this multiple precision integer. */\n-\tint alloc;\n+\tsize_t alloc;\n \t/** The number of digits actually used. */\n-\tint used;\n+\tsize_t used;\n \t/** The sign of this multiple precision integer. */\n \tint sign;\n #if ALLOC == DYNAMIC\n@@ -457,7 +457,7 @@ typedef crt_st *crt_t;\n  * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n  * \t\t\t\t\t\t\tby the library.\n  */\n-void bn_make(bn_t a, int digits);\n+void bn_make(bn_t a, size_t digits);\n \n /**\n  * Cleans a multiple precision integer.\n@@ -476,7 +476,7 @@ void bn_clean(bn_t a);\n  * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n  * \t\t\t\t\t\t\tby the library.\n  */\n-void bn_grow(bn_t a, int digits);\n+void bn_grow(bn_t a, size_t digits);\n \n /**\n  * Adjust the number of valid digits of a multiple precision integer.\n@@ -546,7 +546,7 @@ int bn_is_even(const bn_t a);\n  * @param[in] a\t\t\t\t- the multiple precision integer.\n  * @return number of bits.\n  */\n-int bn_bits(const bn_t a);\n+size_t bn_bits(const bn_t a);\n \n /**\n  * Returns the bit stored in the given position on a multiple precision integer.\n@@ -555,7 +555,7 @@ int bn_bits(const bn_t a);\n  * @param[in] bit\t\t\t- the bit position to read.\n  * @return the bit value.\n  */\n-int bn_get_bit(const bn_t a, int bit);\n+int bn_get_bit(const bn_t a, size_t bit);\n \n /**\n  * Stores a bit in a given position on a multiple precision integer.\n@@ -564,15 +564,15 @@ int bn_get_bit(const bn_t a, int bit);\n  * @param[in] bit\t\t\t- the bit position to store.\n  * @param[in] value\t\t\t- the bit value.\n  */\n-void bn_set_bit(bn_t a, int bit, int value);\n+void bn_set_bit(bn_t a, size_t bit, int value);\n \n /**\n  * Returns the Hamming weight of a multiple precision integer.\n  *\n  * @param[in] a\t\t\t\t- the multiple precision integer.\n  * @return the number of non-zero bits.\n  */\n-int bn_ham(const bn_t a);\n+size_t bn_ham(const bn_t a);\n \n /**\n  * Reads the first digit in a multiple precision integer.\n@@ -599,7 +599,7 @@ void bn_set_dig(bn_t a, dig_t digit);\n  * @param[out] a\t\t\t- the result.\n  * @param[in] b\t\t\t\t- the power of 2 to assign.\n  */\n-void bn_set_2b(bn_t a, int b);\n+void bn_set_2b(bn_t a, size_t b);\n \n /**\n  * Assigns a random value to a multiple precision integer.\n@@ -608,7 +608,7 @@ void bn_set_2b(bn_t a, int b);\n  * @param[in] sign\t\t\t- the sign to be assigned (RLC_NEG or RLC_POS).\n  * @param[in] bits\t\t\t- the number of bits.\n  */\n-void bn_rand(bn_t a, int sign, int bits);\n+void bn_rand(bn_t a, int sign, size_t bits);\n \n /**\n  * Assigns a non-zero random value to a multiple precision integer with absolute\n@@ -635,7 +635,7 @@ void bn_print(const bn_t a);\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  * @return the number of digits in the given radix.\n  */\n-int bn_size_str(const bn_t a, int radix);\n+size_t bn_size_str(const bn_t a, unsigned int radix);\n \n /**\n  * Reads a multiple precision integer from a string in a given radix. The radix\n@@ -647,7 +647,7 @@ int bn_size_str(const bn_t a, int radix);\n  * @param[in] radix\t\t\t- the radix.\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  */\n-void bn_read_str(bn_t a, const char *str, int len, int radix);\n+void bn_read_str(bn_t a, const char *str, size_t len, unsigned int radix);\n \n /**\n  * Writes a multiple precision integer to a string in a given radix. The radix\n@@ -660,15 +660,15 @@ void bn_read_str(bn_t a, const char *str, int len, int radix);\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  */\n-void bn_write_str(char *str, int len, const bn_t a, int radix);\n+void bn_write_str(char *str, size_t len, const bn_t a, unsigned radix);\n \n /**\n  * Returns the number of bytes necessary to store a multiple precision integer.\n  *\n  * @param[in] a\t\t\t\t- the multiple precision integer.\n  * @return the number of bytes.\n  */\n-int bn_size_bin(const bn_t a);\n+size_t bn_size_bin(const bn_t a);\n \n /**\n  * Reads a positive multiple precision integer from a byte vector in big-endian\n@@ -678,7 +678,7 @@ int bn_size_bin(const bn_t a);\n  * @param[in] bin\t\t\t- the byte vector.\n  * @param[in] len\t\t\t- the buffer capacity.\n  */\n-void bn_read_bin(bn_t a, const uint8_t *bin, int len);\n+void bn_read_bin(bn_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a positive multiple precision integer to a byte vector in big-endian\n@@ -689,15 +689,15 @@ void bn_read_bin(bn_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the multiple integer to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_write_bin(uint8_t *bin, int len, const bn_t a);\n+void bn_write_bin(uint8_t *bin, size_t len, const bn_t a);\n \n /**\n  * Returns the number of digits necessary to store a multiple precision integer.\n  *\n  * @param[in] a\t\t\t\t- the multiple precision integer.\n  * @return the number of digits.\n  */\n-int bn_size_raw(const bn_t a);\n+size_t bn_size_raw(const bn_t a);\n \n /**\n  * Reads a positive multiple precision integer from a digit vector.\n@@ -706,7 +706,7 @@ int bn_size_raw(const bn_t a);\n  * @param[in] raw\t\t\t- the digit vector.\n  * @param[in] len\t\t\t- the size of the string.\n  */\n-void bn_read_raw(bn_t a, const dig_t *raw, int len);\n+void bn_read_raw(bn_t a, const dig_t *raw, size_t len);\n \n /**\n  * Writes a positive multiple precision integer to a byte vector.\n@@ -716,7 +716,7 @@ void bn_read_raw(bn_t a, const dig_t *raw, int len);\n  * @param[in] a\t\t\t\t- the multiple integer to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_write_raw(dig_t *raw, int len, const bn_t a);\n+void bn_write_raw(dig_t *raw, size_t len, const bn_t a);\n \n /**\n  * Returns the result of an unsigned comparison between two multiple precision\n@@ -870,7 +870,7 @@ void bn_hlv(bn_t c, const bn_t a);\n  * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n  * @param[in] bits\t\t\t- the number of bits to shift.\n  */\n-void bn_lsh(bn_t c, const bn_t a, int bits);\n+void bn_lsh(bn_t c, const bn_t a, unsigned int bits);\n \n /**\n  * Shifts a multiple precision number to the right. Computes\n@@ -880,7 +880,7 @@ void bn_lsh(bn_t c, const bn_t a, int bits);\n  * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n  * @param[in] bits\t\t\t- the number of bits to shift.\n  */\n-void bn_rsh(bn_t c, const bn_t a, int bits);\n+void bn_rsh(bn_t c, const bn_t a, unsigned int bits);\n \n /**\n  * Divides a multiple precision integer by another multiple precision integer\n@@ -1310,15 +1310,15 @@ int bn_is_prime_solov(const bn_t a);\n  * @param[out] a\t\t\t- the result.\n  * @param[in] bits\t\t\t- the length of the number in bits.\n  */\n-void bn_gen_prime_basic(bn_t a, int bits);\n+void bn_gen_prime_basic(bn_t a, size_t bits);\n \n /**\n  * Generates a probable prime number a with (a - 1)/2 also prime.\n  *\n  * @param[out] a\t\t\t- the result.\n  * @param[in] bits\t\t\t- the length of the number in bits.\n  */\n-void bn_gen_prime_safep(bn_t a, int bits);\n+void bn_gen_prime_safep(bn_t a, size_t bits);\n \n /**\n  * Generates a probable prime number with (a - 1)/2, (a + 1)/2 and\n@@ -1327,7 +1327,7 @@ void bn_gen_prime_safep(bn_t a, int bits);\n  * @param[out] a\t\t\t- the result.\n  * @param[in] bits\t\t\t- the length of the number in bits.\n  */\n-void bn_gen_prime_stron(bn_t a, int bits);\n+void bn_gen_prime_stron(bn_t a, size_t bits);\n \n /**\n  * Generates a probable prime number b, with (b-1) divisible by a probable large\n@@ -1338,7 +1338,7 @@ void bn_gen_prime_stron(bn_t a, int bits);\n  * @param[in] abits\t\t\t- the length of the factor a in bits.\n  * @param[in] bbits\t\t\t- the length of the result in bits.\n  */\n-int bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits);\n+int bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits);\n \n \n /**\n@@ -1370,7 +1370,7 @@ int bn_is_factor(bn_t c, const bn_t a);\n  * @param[in] w\t\t\t\t- the window size in bits.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);\n+void bn_rec_win(uint8_t *win, size_t *len, const bn_t k, size_t w);\n \n /**\n  * Recodes a positive integer in sliding window form. If a negative integer is\n@@ -1382,7 +1382,7 @@ void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);\n  * @param[in] w\t\t\t\t- the window size in bits.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);\n+void bn_rec_slw(uint8_t *win, size_t *len, const bn_t k, size_t w);\n \n /**\n  * Recodes a positive integer in width-w Non-Adjacent Form. If a negative\n@@ -1394,7 +1394,7 @@ void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);\n  * @param[in] w\t\t\t\t- the window size in bits.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);\n+void bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w);\n \n /**\n  * Recodes a positive integer in width-w \\tau-NAF. If a negative integer is\n@@ -1408,7 +1408,8 @@ void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);\n  * @param[in] w\t\t\t\t- the window size in bits.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n+void bn_rec_tnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n+\t\tsize_t w);\n \n /**\n  * Recodes a positive integer in regular fixed-length width-w \\tau-NAF.\n@@ -1422,7 +1423,8 @@ void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n  * @param[in] w\t\t\t\t- the window size in bits.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n+void bn_rec_rtnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n+\t\tsize_t w);\n \n /**\n  * Write the constants needed for \\tau-NAF recoding as a set of \\alpha_u =\n@@ -1434,7 +1436,8 @@ void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n  * @param[in] u \t\t- the u curve parameter.\n  * @param[in] w \t\t- the window size in bits.\n  */\n-void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);\n+void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u,\n+\t\tsize_t w);\n \n /**\n  * Computes the partial reduction k partmod d = r0 + r1 * t, where\n@@ -1446,7 +1449,7 @@ void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);\n  * @param[in] u\t\t\t- the u curve parameter.\n  * @param[in] m\t\t\t- the extension degree of the binary field.\n  */\n-void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);\n+void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, size_t m);\n \n /**\n  * Recodes a positive integer in regular fixed-length width-w NAF. If a negative\n@@ -1459,7 +1462,7 @@ void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);\n  * @param[in] w\t\t\t\t- the window size in bits.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);\n+void bn_rec_reg(int8_t *naf, size_t *len, const bn_t k, size_t n, size_t w);\n \n /**\n  * Recodes of a pair of positive integers in Joint Sparse Form. If negative\n@@ -1471,7 +1474,7 @@ void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);\n  * @param[in] l\t\t\t\t- the second integer to recode.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l);\n+void bn_rec_jsf(int8_t *jsf, size_t *len, const bn_t k, const bn_t l);\n \n /**\n  * Recodes a positive integer into two parts k0,k1 such that k = k0 + phi(k1),"
        },
        {
          "filename": "include/relic_cp.h",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -740,7 +740,7 @@ typedef etrs_st *etrs_t;\n  * @param[in] bits\t\t\t- the key length in bits.\n  * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n  */\n-int cp_rsa_gen(rsa_t pub, rsa_t prv, int bits);\n+int cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits);\n \n /**\n  * Encrypts using the RSA cryptosystem.\n@@ -1540,7 +1540,7 @@ int cp_bls_gen(bn_t d, g2_t q);\n  * @param[in] d\t\t\t\t- the private key.\n  * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n  */\n-int cp_bls_sig(g1_t s, const uint8_t *msg, int len, const bn_t d);\n+int cp_bls_sig(g1_t s, const uint8_t *msg, size_t len, const bn_t d);\n \n /**\n  * Verifies a message signed with BLS protocol."
        },
        {
          "filename": "include/relic_eb.h",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -560,7 +560,7 @@ int eb_size_bin(const eb_t a, int pack);\n  * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void eb_read_bin(eb_t a, const uint8_t *bin, int len);\n+void eb_read_bin(eb_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a binary field element to a byte vector in big-endian format with\n@@ -572,7 +572,7 @@ void eb_read_bin(eb_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate point compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void eb_write_bin(uint8_t *bin, int len, const eb_t a, int pack);\n+void eb_write_bin(uint8_t *bin, size_t len, const eb_t a, int pack);\n \n /**\n  * Negates a binary elliptic curve point represented by affine coordinates.\n@@ -928,7 +928,7 @@ void eb_norm_sim(eb_t *r, const eb_t *t, int n);\n  * @param[in] msg\t\t\t- the byte array to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void eb_map(eb_t p, const uint8_t *msg, int len);\n+void eb_map(eb_t p, const uint8_t *msg, size_t len);\n \n /**\n  * Compresses a point."
        },
        {
          "filename": "include/relic_ed.h",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -482,7 +482,7 @@ void ed_norm_sim(ed_t *r, const ed_t *t, int n);\n  * @param[in] msg\t\t\t- the byte array to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void ed_map(ed_t p, const uint8_t *msg, int len);\n+void ed_map(ed_t p, const uint8_t *msg, size_t len);\n \n /**\n  * Maps a byte array to a point in an Edwards elliptic curve using\n@@ -494,7 +494,8 @@ void ed_map(ed_t p, const uint8_t *msg, int len);\n  * @param[in] dst\t\t\t- the domain separation tag.\n  * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n  */\n-void ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);\n+void ed_map_dst(ed_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len);\n \n /**\n  * Multiplies an Edwards elliptic curve point by an integer. Computes R = [k]P.\n@@ -840,7 +841,7 @@ int ed_size_bin(const ed_t a, int pack);\n  * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ed_read_bin(ed_t a, const uint8_t *bin, int len);\n+void ed_read_bin(ed_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes an Edwards elliptic curve point to a byte vector in big-endian format\n@@ -852,7 +853,7 @@ void ed_read_bin(ed_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate point compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ed_write_bin(uint8_t *bin, int len, const ed_t a, int pack);\n+void ed_write_bin(uint8_t *bin, size_t len, const ed_t a, int pack);\n \n /**\n  * Multiplies an Edwards elliptic point by an integer using the binary method."
        },
        {
          "filename": "include/relic_ep.h",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -811,7 +811,7 @@ int ep_size_bin(const ep_t a, int pack);\n  * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ep_read_bin(ep_t a, const uint8_t *bin, int len);\n+void ep_read_bin(ep_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a prime elliptic curve point to a byte vector in big-endian format\n@@ -823,7 +823,7 @@ void ep_read_bin(ep_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate point compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ep_write_bin(uint8_t *bin, int len, const ep_t a, int pack);\n+void ep_write_bin(uint8_t *bin, size_t len, const ep_t a, int pack);\n \n /**\n  * Negates a prime elliptic curve point.\n@@ -1215,7 +1215,7 @@ void ep_norm_sim(ep_t *r, const ep_t *t, int n);\n  * @param[in] uniform_bytes\t\t- the array of uniform bytes to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len);\n+void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len);\n \n /**\n  * Maps a byte array to a point in a prime elliptic curve.\n@@ -1224,7 +1224,7 @@ void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len);\n  * @param[in] msg\t\t\t- the byte array to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void ep_map(ep_t p, const uint8_t *msg, int len);\n+void ep_map(ep_t p, const uint8_t *msg, size_t len);\n \n /**\n  * Maps a byte array to a point in a prime elliptic curve with specified\n@@ -1236,8 +1236,8 @@ void ep_map(ep_t p, const uint8_t *msg, int len);\n  * @param[in] dst\t\t\t- the domain separation tag.\n  * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n  */\n-void ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,\n-\t\tint dst_len);\n+void ep_map_dst(ep_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len);\n \n /**\n  * Compresses a point."
        },
        {
          "filename": "include/relic_epx.h",
          "status": "modified",
          "additions": 19,
          "deletions": 15,
          "patch": "@@ -745,7 +745,7 @@ int ep2_size_bin(const ep2_t a, int pack);\n  * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ep2_read_bin(ep2_t a, const uint8_t *bin, int len);\n+void ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a prime elliptic curve pointer over a quadratic extension to a byte\n@@ -757,7 +757,7 @@ void ep2_read_bin(ep2_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate point compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack);\n+void ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack);\n \n /**\n  * Negates a point represented in affine coordinates in an elliptic curve over\n@@ -1060,7 +1060,8 @@ void ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons\n  * @param[in] q\t\t\t\t- the second point to multiply.\n  * @param[in] m\t\t\t\t- the second integer,\n  */\n-void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n+void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n+\t\t\tconst bn_t m);\n \n /**\n  * Multiplies and adds two prime elliptic curve points simultaneously using\n@@ -1072,7 +1073,8 @@ void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons\n  * @param[in] q\t\t\t\t- the second point to multiply.\n  * @param[in] m\t\t\t\t- the second integer,\n  */\n-void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n+void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n+\t\t\tconst bn_t m);\n \n /**\n  * Multiplies simultaneously elements from a prime elliptic curve.\n@@ -1083,7 +1085,7 @@ void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, cons\n  * @param[out] k\t\t\t- the integer scalars.\n  * @param[out] n\t\t\t- the number of elements to multiply.\n  */\n-void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n);\n+void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n);\n \n /**\n  * Multiplies and adds the generator and a prime elliptic curve point\n@@ -1105,7 +1107,7 @@ void ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m);\n  * @param[in] k\t\t\t\t- the small scalars.\n  * @param[in] len\t\t\t- the number of points to multiply.\n  */\n-void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len);\n+void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len);\n \n /**\n  * Converts a point to affine coordinates.\n@@ -1134,7 +1136,7 @@ void ep2_norm_sim(ep2_t *r, const ep2_t *t, int n);\n  * @param[in] uniform_bytes\t\t- the array of uniform bytes to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);\n+void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len);\n \n /**\n  * Maps a byte array to a point in an elliptic curve over a quadratic extension.\n@@ -1143,7 +1145,7 @@ void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);\n  * @param[in] msg\t\t\t- the byte array to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void ep2_map(ep2_t p, const uint8_t *msg, int len);\n+void ep2_map(ep2_t p, const uint8_t *msg, size_t len);\n \n /**\n  * Maps a byte array to a point in an elliptic curve over a quadratic extension\n@@ -1155,7 +1157,8 @@ void ep2_map(ep2_t p, const uint8_t *msg, int len);\n  * @param[in] dst\t\t\t- the domain separatoin tag.\n  * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n  */\n-void ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);\n+void ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len);\n \n /**\n  * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point\n@@ -1385,7 +1388,7 @@ int ep4_size_bin(const ep4_t a, int pack);\n  * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ep4_read_bin(ep4_t a, const uint8_t *bin, int len);\n+void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a prime elliptic curve pointer over a quartic extension to a byte\n@@ -1397,7 +1400,7 @@ void ep4_read_bin(ep4_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n  */\n-void ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack);\n+void ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack);\n \n /**\n  * Negates a point represented in affine coordinates in an elliptic curve over\n@@ -1723,7 +1726,7 @@ void ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, cons\n  * @param[in] k\t\t\t- the integer scalars.\n  * @param[in] n\t\t\t- the number of elements to multiply.\n  */\n-void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n);\n+void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n);\n \n /**\n  * Multiplies and adds the generator and a prime elliptic curve point\n@@ -1745,7 +1748,7 @@ void ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m);\n  * @param[in] k\t\t\t\t- the small scalars.\n  * @param[in] len\t\t\t- the number of points to multiply.\n  */\n-void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len);\n+void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len);\n \n /**\n  * Converts a point to affine coordinates.\n@@ -1771,7 +1774,7 @@ void ep4_norm_sim(ep4_t *r, const ep4_t *t, int n);\n  * @param[in] msg\t\t\t- the byte array to map.\n  * @param[in] len\t\t\t- the array length in bytes.\n  */\n-void ep4_map(ep4_t p, const uint8_t *msg, int len);\n+void ep4_map(ep4_t p, const uint8_t *msg, size_t len);\n \n /**\n  * Maps a byte array to a point in an elliptic curve over a quartic extension\n@@ -1783,7 +1786,8 @@ void ep4_map(ep4_t p, const uint8_t *msg, int len);\n  * @param[in] dst\t\t\t- the domain separatoin tag.\n  * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n  */\n-void ep4_map_dst(ep4_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);\n+void ep4_map_dst(ep4_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len);\n \n /**\n  * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point"
        },
        {
          "filename": "include/relic_fb.h",
          "status": "modified",
          "additions": 12,
          "deletions": 12,
          "patch": "@@ -48,17 +48,17 @@\n /**\n  * Precision in bits of a binary field element.\n  */\n-#define RLC_FB_BITS \t((int)FB_POLYN)\n+#define RLC_FB_BITS \t((size_t)FB_POLYN)\n \n /**\n  * Size in digits of a block sufficient to store a binary field element.\n  */\n-#define RLC_FB_DIGS\t\t((int)RLC_CEIL(RLC_FB_BITS, RLC_DIG))\n+#define RLC_FB_DIGS\t\t((size_t)RLC_CEIL(RLC_FB_BITS, RLC_DIG))\n \n /**\n  * Size in bytes of a block sufficient to store a binary field element.\n  */\n-#define RLC_FB_BYTES \t((int)RLC_CEIL(RLC_FB_BITS, 8))\n+#define RLC_FB_BYTES \t((size_t)RLC_CEIL(RLC_FB_BITS, 8))\n \n /**\n  * Finite field identifiers.\n@@ -538,7 +538,7 @@ int fb_is_zero(const fb_t a);\n  * @param[in] bit\t\t\t- the bit position.\n  * @return the bit value.\n  */\n-int fb_get_bit(const fb_t a, int bit);\n+int fb_get_bit(const fb_t a, size_t bit);\n \n /**\n  * Stores a bit in a given position on a binary field element.\n@@ -547,7 +547,7 @@ int fb_get_bit(const fb_t a, int bit);\n  * @param[in] bit\t\t\t- the bit position.\n  * @param[in] value\t\t\t- the bit value.\n  */\n-void fb_set_bit(fb_t a, int bit, int value);\n+void fb_set_bit(fb_t a, size_t bit, int value);\n \n /**\n  * Assigns a small positive polynomial to a binary field element.\n@@ -565,7 +565,7 @@ void fb_set_dig(fb_t c, dig_t a);\n  * @param[in] a\t\t\t\t- the binary field element.\n  * @return the number of bits.\n  */\n-int fb_bits(const fb_t a);\n+size_t fb_bits(const fb_t a);\n \n /**\n  * Assigns a random value to a binary field element.\n@@ -590,7 +590,7 @@ void fb_print(const fb_t a);\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  * @return the number of digits in the given radix.\n  */\n-int fb_size_str(const fb_t a, int radix);\n+size_t fb_size_str(const fb_t a, unsigned int radix);\n \n /**\n  * Reads a binary field element from a string in a given radix. The radix must\n@@ -603,7 +603,7 @@ int fb_size_str(const fb_t a, int radix);\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the string is too long.\n  */\n-void fb_read_str(fb_t a, const char *str, int len, int radix);\n+void fb_read_str(fb_t a, const char *str, size_t len, unsigned int radix);\n \n /**\n  * Writes a binary field element to a string in a given radix. The radix must\n@@ -616,17 +616,17 @@ void fb_read_str(fb_t a, const char *str, int len, int radix);\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n  */\n-void fb_write_str(char *str, int len, const fb_t a, int radix);\n+void fb_write_str(char *str, size_t len, const fb_t a, unsigned int radix);\n \n /**\n  * Reads a binary field element from a byte vector in big-endian format.\n  *\n  * @param[out] a\t\t\t- the result.\n- * @param[in] bin\t\t\t- the byte vector.\n+ * @param[in] bin\t\t\t- the byte vector.,\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n  */\n-void fb_read_bin(fb_t a, const uint8_t *bin, int len);\n+void fb_read_bin(fb_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a binary field element to a byte vector in big-endian format.\n@@ -636,7 +636,7 @@ void fb_read_bin(fb_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the binary field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n  */\n-void fb_write_bin(uint8_t *bin, int len, const fb_t a);\n+void fb_write_bin(uint8_t *bin, size_t len, const fb_t a);\n \n /**\n  * Returns the result of a comparison between two binary field elements."
        },
        {
          "filename": "include/relic_fp.h",
          "status": "modified",
          "additions": 13,
          "deletions": 13,
          "patch": "@@ -48,17 +48,17 @@\n /**\n  * Precision in bits of a prime field element.\n  */\n-#define RLC_FP_BITS \t((int)FP_PRIME)\n+#define RLC_FP_BITS \t((size_t)FP_PRIME)\n \n /**\n  * Size in digits of a block sufficient to store a prime field element.\n  */\n-#define RLC_FP_DIGS \t((int)RLC_CEIL(RLC_FP_BITS, RLC_DIG))\n+#define RLC_FP_DIGS \t((size_t)RLC_CEIL(RLC_FP_BITS, RLC_DIG))\n \n /**\n  * Size in bytes of a block sufficient to store a binary field element.\n  */\n-#define RLC_FP_BYTES \t((int)RLC_CEIL(RLC_FP_BITS, 8))\n+#define RLC_FP_BYTES \t((size_t)RLC_CEIL(RLC_FP_BITS, 8))\n \n /*\n  * Finite field identifiers.\n@@ -501,10 +501,10 @@ void fp_prime_set_dense(const bn_t p);\n  * @param[in] spars\t\t- the list of powers of 2 describing the prime.\n  * @param[in] len\t\t- the number of powers.\n  */\n-void fp_prime_set_pmers(const int *spars, int len);\n+void fp_prime_set_pmers(const int *spars, size_t len);\n \n /**\n-* Assigns the prime field modulus to a parametrization from a family of\n+ * Assigns the prime field modulus to a parametrization from a family of\n  * pairing-friendly curves.\n  */\n void fp_prime_set_pairf(const bn_t x, int pairf);\n@@ -653,7 +653,7 @@ int fp_is_even(const fp_t a);\n  * @param[in] bit\t\t\t- the bit position.\n  * @return the bit value.\n  */\n-int fp_get_bit(const fp_t a, int bit);\n+int fp_get_bit(const fp_t a, size_t bit);\n \n /**\n  * Stores a bit in a given position on a prime field element.\n@@ -662,7 +662,7 @@ int fp_get_bit(const fp_t a, int bit);\n  * @param[in] bit\t\t\t- the bit position.\n  * @param[in] value\t\t\t- the bit value.\n  */\n-void fp_set_bit(fp_t a, int bit, int value);\n+void fp_set_bit(fp_t a, size_t bit, int value);\n \n /**\n  * Assigns a small positive constant to a prime field element.\n@@ -681,7 +681,7 @@ void fp_set_dig(fp_t c, dig_t a);\n  * @param[in] a\t\t\t\t- the prime field element.\n  * @return the number of bits.\n  */\n-int fp_bits(const fp_t a);\n+size_t fp_bits(const fp_t a);\n \n /**\n  * Assigns a random value to a prime field element.\n@@ -706,7 +706,7 @@ void fp_print(const fp_t a);\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  * @return the number of digits in the given radix.\n  */\n-int fp_size_str(const fp_t a, int radix);\n+size_t fp_size_str(const fp_t a, unsigned int radix);\n \n /**\n  * Reads a prime field element from a string in a given radix. The radix must\n@@ -718,7 +718,7 @@ int fp_size_str(const fp_t a, int radix);\n  * @param[in] radix\t\t\t- the radix.\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  */\n-void fp_read_str(fp_t a, const char *str, int len, int radix);\n+void fp_read_str(fp_t a, const char *str, size_t len, unsigned int radix);\n \n /**\n  * Writes a prime field element to a string in a given radix. The radix must\n@@ -731,7 +731,7 @@ void fp_read_str(fp_t a, const char *str, int len, int radix);\n  * @throw ERR_BUFFER\t\t- if the buffer capacity is insufficient.\n  * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n  */\n-void fp_write_str(char *str, int len, const fp_t a, int radix);\n+void fp_write_str(char *str, size_t len, const fp_t a, unsigned int radix);\n \n /**\n  * Reads a prime field element from a byte vector in big-endian format.\n@@ -741,7 +741,7 @@ void fp_write_str(char *str, int len, const fp_t a, int radix);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n  */\n-void fp_read_bin(fp_t a, const uint8_t *bin, int len);\n+void fp_read_bin(fp_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a prime field element to a byte vector in big-endian format.\n@@ -751,7 +751,7 @@ void fp_read_bin(fp_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the prime field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n  */\n-void fp_write_bin(uint8_t *bin, int len, const fp_t a);\n+void fp_write_bin(uint8_t *bin, size_t len, const fp_t a);\n \n /**\n  * Returns the result of a comparison between two prime field elements."
        },
        {
          "filename": "include/relic_fpx.h",
          "status": "modified",
          "additions": 30,
          "deletions": 28,
          "patch": "@@ -1332,7 +1332,7 @@ int fp2_size_bin(fp2_t a, int pack);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp2_read_bin(fp2_t a, const uint8_t *bin, int len);\n+void fp2_read_bin(fp2_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a quadratic extension field element to a byte vector in big-endian\n@@ -1344,7 +1344,7 @@ void fp2_read_bin(fp2_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack);\n+void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack);\n \n /**\n  * Returns the result of a comparison between two quadratic extension field\n@@ -1690,7 +1690,7 @@ int fp3_size_bin(fp3_t a);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp3_read_bin(fp3_t a, const uint8_t *bin, int len);\n+void fp3_read_bin(fp3_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a cubic extension field element to a byte vector in big-endian\n@@ -1701,7 +1701,7 @@ void fp3_read_bin(fp3_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the extension field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp3_write_bin(uint8_t *bin, int len, const fp3_t a);\n+void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a);\n \n /**\n  * Returns the result of a comparison between two cubic extension field\n@@ -1956,7 +1956,7 @@ int fp4_size_bin(fp4_t a);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp4_read_bin(fp4_t a, const uint8_t *bin, int len);\n+void fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a quartic extension field element to a byte vector in big-endian\n@@ -1967,7 +1967,7 @@ void fp4_read_bin(fp4_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the extension field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp4_write_bin(uint8_t *bin, int len, const fp4_t a);\n+void fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a);\n \n /**\n  * Returns the result of a comparison between two quartic extension field\n@@ -2226,7 +2226,7 @@ int fp6_size_bin(fp6_t a);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp6_read_bin(fp6_t a, const uint8_t *bin, int len);\n+void fp6_read_bin(fp6_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a sextic extension field element to a byte vector in big-endian\n@@ -2237,7 +2237,7 @@ void fp6_read_bin(fp6_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the extension field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp6_write_bin(uint8_t *bin, int len, const fp6_t a);\n+void fp6_write_bin(uint8_t *bin, size_t len, const fp6_t a);\n \n /**\n  * Returns the result of a comparison between two sextic extension field\n@@ -2456,7 +2456,7 @@ int fp8_size_bin(fp8_t a, int pack);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp8_read_bin(fp8_t a, const uint8_t *bin, int len);\n+void fp8_read_bin(fp8_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes an octic extension field element to a byte vector in big-endian\n@@ -2467,7 +2467,7 @@ void fp8_read_bin(fp8_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the extension field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp8_write_bin(uint8_t *bin, int len, const fp8_t a);\n+void fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a);\n \n /**\n  * Returns the result of a comparison between two octic extension field\n@@ -2739,7 +2739,7 @@ int fp9_size_bin(fp9_t a);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp9_read_bin(fp9_t a, const uint8_t *bin, int len);\n+void fp9_read_bin(fp9_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a nonic extension field element to a byte vector in big-endian\n@@ -2750,7 +2750,7 @@ void fp9_read_bin(fp9_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the extension field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp9_write_bin(uint8_t *bin, int len, const fp9_t a);\n+void fp9_write_bin(uint8_t *bin, size_t len, const fp9_t a);\n \n /**\n  * Returns the result of a comparison between two nonic extension field\n@@ -2978,7 +2978,7 @@ int fp12_size_bin(fp12_t a, int pack);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp12_read_bin(fp12_t a, const uint8_t *bin, int len);\n+void fp12_read_bin(fp12_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a dodecic extension field element to a byte vector in big-endian\n@@ -2990,7 +2990,7 @@ void fp12_read_bin(fp12_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp12_write_bin(uint8_t *bin, int len, const fp12_t a, int pack);\n+void fp12_write_bin(uint8_t *bin, size_t len, const fp12_t a, int pack);\n \n /**\n  * Returns the result of a comparison between two dodecic extension field\n@@ -3282,7 +3282,8 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b);\n  * @param[in] c\t\t\t\t- the second element to exponentiate.\n  * @param[in] d\t\t\t\t- the second exponent.\n  */\n-void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d);\n+void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c,\n+\t\tconst bn_t d);\n \n /**\n  * Computes a power of a cyclotomic dodecic extension field element.\n@@ -3293,7 +3294,8 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const\n  * @param[in] c\t\t\t\t- the second element to exponentiate.\n  * @param[in] d\t\t\t\t- the second exponent.\n  */\n-void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, const bn_t d);\n+void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c,\n+\t\tconst bn_t d);\n \n /**\n  * Computes a power of a cyclotomic dodecic extension field element.\n@@ -3304,7 +3306,7 @@ void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, co\n  * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n  * @param[in] s\t\t\t\t- the sign of the exponent.\n  */\n-void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, int l, int s);\n+void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, size_t l, int s);\n \n /**\n  * Compresses a dodecic extension field element.\n@@ -3395,7 +3397,7 @@ int fp18_size_bin(fp18_t a);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp18_read_bin(fp18_t a, const uint8_t *bin, int len);\n+void fp18_read_bin(fp18_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes an octdecic extension field element to a byte vector in big-endian\n@@ -3406,7 +3408,7 @@ void fp18_read_bin(fp18_t a, const uint8_t *bin, int len);\n  * @param[in] a\t\t\t\t- the extension field element to write.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp18_write_bin(uint8_t *bin, int len, const fp18_t a);\n+void fp18_write_bin(uint8_t *bin, size_t len, const fp18_t a);\n \n /**\n  * Returns the result of a comparison between two octdecic extension field\n@@ -3657,7 +3659,7 @@ int fp24_size_bin(fp24_t a, int pack);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp24_read_bin(fp24_t a, const uint8_t *bin, int len);\n+void fp24_read_bin(fp24_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a 24-degree extension field element to a byte vector in big-endian\n@@ -3669,7 +3671,7 @@ void fp24_read_bin(fp24_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp24_write_bin(uint8_t *bin, int len, const fp24_t a, int pack);\n+void fp24_write_bin(uint8_t *bin, size_t len, const fp24_t a, int pack);\n \n /**\n  * Returns the result of a comparison between two 24-degree extension field\n@@ -3961,7 +3963,7 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co\n  * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n  * @param[in] s\t\t\t\t- the sign of the exponent.\n  */\n-void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, int l, int s);\n+void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t l, int s);\n \n /**\n  * Compresses a 24-extension field element.\n@@ -4036,7 +4038,7 @@ int fp48_size_bin(fp48_t a, int pack);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp48_read_bin(fp48_t a, const uint8_t *bin, int len);\n+void fp48_read_bin(fp48_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a 48-extension field element to a byte vector in big-endian\n@@ -4048,7 +4050,7 @@ void fp48_read_bin(fp48_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp48_write_bin(uint8_t *bin, int len, const fp48_t a, int pack);\n+void fp48_write_bin(uint8_t *bin, size_t len, const fp48_t a, int pack);\n \n /**\n  * Returns the result of a comparison between two 48-extension field\n@@ -4312,7 +4314,7 @@ void fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b);\n  * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n  * @param[in] s\t\t\t\t- the sign of the exponent.\n  */\n-void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int l, int s);\n+void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t l, int s);\n \n /**\n  * Compresses a 48-extension field element.\n@@ -4387,7 +4389,7 @@ int fp54_size_bin(fp54_t a, int pack);\n  * @param[in] len\t\t\t- the buffer capacity.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp54_read_bin(fp54_t a, const uint8_t *bin, int len);\n+void fp54_read_bin(fp54_t a, const uint8_t *bin, size_t len);\n \n /**\n  * Writes a 54-extension field element to a byte vector in big-endian\n@@ -4399,7 +4401,7 @@ void fp54_read_bin(fp54_t a, const uint8_t *bin, int len);\n  * @param[in] pack\t\t\t- the flag to indicate compression.\n  * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n  */\n-void fp54_write_bin(uint8_t *bin, int len, const fp54_t a, int pack);\n+void fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack);\n \n /**\n  * Returns the result of a comparison between two 54-extension field\n@@ -4663,7 +4665,7 @@ void fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b);\n  * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n  * @param[in] s\t\t\t\t- the sign of the exponent.\n  */\n-void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int l, int s);\n+void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t l, int s);\n \n /**\n  * Compresses a 54-extension field element."
        },
        {
          "filename": "include/relic_md.h",
          "status": "modified",
          "additions": 18,
          "deletions": 18,
          "patch": "@@ -134,7 +134,7 @@ enum {\n  * @param[in] msg\t\t\t\t- the message to hash.\n  * @param[in] len\t\t\t\t- the message length in bytes.\n  */\n-void md_map_sh224(uint8_t *hash, const uint8_t *msg, int len);\n+void md_map_sh224(uint8_t *hash, const uint8_t *msg, size_t len);\n \n /**\n  * Computes the SHA-256 hash function.\n@@ -143,7 +143,7 @@ void md_map_sh224(uint8_t *hash, const uint8_t *msg, int len);\n  * @param[in] msg\t\t\t\t- the message to hash.\n  * @param[in] len\t\t\t\t- the message length in bytes.\n  */\n-void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len);\n+void md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len);\n \n /**\n  * Computes the SHA-384 hash function.\n@@ -152,7 +152,7 @@ void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len);\n  * @param[in] msg\t\t\t\t- the message to hash.\n  * @param[in] len\t\t\t\t- the message length in bytes.\n  */\n-void md_map_sh384(uint8_t *hash, const uint8_t *msg, int len);\n+void md_map_sh384(uint8_t *hash, const uint8_t *msg, size_t len);\n \n /**\n  * Computes the SHA-512 hash function.\n@@ -161,7 +161,7 @@ void md_map_sh384(uint8_t *hash, const uint8_t *msg, int len);\n  * @param[in] msg\t\t\t\t- the message to hash.\n  * @param[in] len\t\t\t\t- the message length in bytes.\n  */\n-void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len);\n+void md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len);\n \n /**\n  * Computes the BLAKE2s-160 hash function.\n@@ -170,7 +170,7 @@ void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len);\n  * @param[in] msg\t\t\t\t- the message to hash.\n  * @param[in] len\t\t\t\t- the message length in bytes.\n  */\n-void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len);\n+void md_map_b2s160(uint8_t *hash, const uint8_t *msg, size_t len);\n \n /**\n  * Computes the BLAKE2s-256 hash function.\n@@ -179,7 +179,7 @@ void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len);\n  * @param[in] msg\t\t\t\t- the message to hash.\n  * @param[in] len\t\t\t\t- the message length in bytes.\n  */\n-void md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len);\n+void md_map_b2s256(uint8_t *hash, const uint8_t *msg, size_t len);\n \n /**\n  * Derives a key from shared secret material through the standardized KDF2\n@@ -190,7 +190,7 @@ void md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len);\n  * @param[in] in\t\t\t\t- the shared secret.\n  * @param[in] in_len\t\t\t- the length of the shared secret in bytes.\n  */\n-void md_kdf(uint8_t *key, int key_len, const uint8_t *in, int in_len);\n+void md_kdf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len);\n \n /**\n  * Derives a mask from shared secret material through the PKCS#1 2.1 MGF1\n@@ -201,7 +201,7 @@ void md_kdf(uint8_t *key, int key_len, const uint8_t *in, int in_len);\n  * @param[in] in\t\t\t\t- the shared secret.\n  * @param[in] in_len\t\t\t- the length of the shared secret in bytes.\n  */\n-void md_mgf(uint8_t *mask, int mask_len, const uint8_t *in, int in_len);\n+void md_mgf(uint8_t *mask, size_t mask_len, const uint8_t *in, size_t in_len);\n \n /**\n  * Computes a Message Authentication Code through HMAC.\n@@ -212,8 +212,8 @@ void md_mgf(uint8_t *mask, int mask_len, const uint8_t *in, int in_len);\n  * @param[in] key\t\t\t\t- the cryptographic key.\n  * @param[in] key_len\t\t\t- the size of the key in bytes.\n  */\n-void md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,\n-\t\tint key_len);\n+void md_hmac(uint8_t *mac, const uint8_t *in, size_t in_len, const uint8_t *key,\n+\t\tsize_t key_len);\n \n /**\n  * Map a byte vector and optional domain separation tag to an arbitrary-length\n@@ -226,8 +226,8 @@ void md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,\n  * @param[in] dst\t\t\t\t\t- the domain separation tag.\n  * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n  */\n-void md_xmd_sh224(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n-\t\tconst uint8_t *dst, int dst_len);\n+void md_xmd_sh224(uint8_t *buf, size_t buf_len, const uint8_t *in,\n+\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n \n /**\n  * Map a byte vector and optional domain separation tag to an arbitrary-length\n@@ -240,8 +240,8 @@ void md_xmd_sh224(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n  * @param[in] dst\t\t\t\t\t- the domain separation tag.\n  * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n  */\n-void md_xmd_sh256(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n-\t\tconst uint8_t *dst, int dst_len);\n+void md_xmd_sh256(uint8_t *buf, size_t buf_len, const uint8_t *in,\n+\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n \n /**\n  * Map a byte vector and optional domain separation tag to an arbitrary-length\n@@ -254,8 +254,8 @@ void md_xmd_sh256(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n  * @param[in] dst\t\t\t\t\t- the domain separation tag.\n  * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n  */\n-void md_xmd_sh384(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n-\t\tconst uint8_t *dst, int dst_len);\n+void md_xmd_sh384(uint8_t *buf, size_t buf_len, const uint8_t *in,\n+\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n \n /**\n  * Map a byte vector and optional domain separation tag to an arbitrary-length\n@@ -268,7 +268,7 @@ void md_xmd_sh384(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n  * @param[in] dst\t\t\t\t\t- the domain separation tag.\n  * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n  */\n-void md_xmd_sh512(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n-\t\tconst uint8_t *dst, int dst_len);\n+void md_xmd_sh512(uint8_t *buf, size_t buf_len, const uint8_t *in,\n+\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n \n #endif /* !RLC_MD_H */"
        },
        {
          "filename": "include/relic_rand.h",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -89,7 +89,7 @@ void rand_clean(void);\n  * @param[in] size\t\t\t- the number of bytes.\n  * @throw ERR_NO_VALID\t\t- if the entropy length is too small or too large.\n  */\n-void rand_seed(uint8_t *buf, int size);\n+void rand_seed(uint8_t *buf, size_t size);\n \n #else\n \n@@ -100,7 +100,7 @@ void rand_seed(uint8_t *buf, int size);\n  * @param[in] callback\t\t- the callback to call.\n  * @param[in] arg\t\t\t- the argument for the callback.\n  */\n-void rand_seed(void (*callback)(uint8_t *, int, void *), void *arg);\n+void rand_seed(void (*callback)(uint8_t *, size_t, void *), void *arg);\n \n #endif\n \n@@ -112,7 +112,7 @@ void rand_seed(void (*callback)(uint8_t *, int, void *), void *arg);\n  * @param[in] size\t\t\t- the number of bytes to check.\n  * @throw ERR_NO_RAND       - if the pseudo-random number generator is stuck.\n  */\n-int rand_check(uint8_t *buf, int size);\n+int rand_check(uint8_t *buf, size_t size);\n \n /**\n  * Gathers pseudo-random bytes from the pseudo-random number generator.\n@@ -123,6 +123,6 @@ int rand_check(uint8_t *buf, int size);\n  * @throw ERR_NO_READ\t\t- it the pseudo-random number generator cannot\n  * \t\t\t\t\t\t\tgenerate the specified number of bytes.\n  */\n-void rand_bytes(uint8_t *buf, int size);\n+void rand_bytes(uint8_t *buf, size_t size);\n \n #endif /* !RLC_RAND_H */"
        },
        {
          "filename": "include/relic_util.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -285,7 +285,7 @@ char util_conv_char(dig_t i);\n  * @param[in] a\t\t\t\t- the digit.\n  * @return the position of the highest bit set.\n  */\n-int util_bits_dig(dig_t a);\n+size_t util_bits_dig(dig_t a);\n \n /**\n  * Compares two buffers in constant time."
        },
        {
          "filename": "src/bn/relic_bn_gcd.c",
          "status": "modified",
          "additions": 42,
          "deletions": 12,
          "patch": "@@ -202,9 +202,14 @@ void bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {\n \t\t\tbn_abs(y, a);\n \t\t}\n \t\twhile (y->used > 1) {\n-\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n+\t\t\tif (bn_bits(x) > RLC_DIG) {\n+\t\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n+\t\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n+\t\t\t} else {\n+\t\t\t\tbn_copy(u, x);\n+\t\t\t\tbn_copy(v, y);\n+\t\t\t}\n \t\t\t_x = u->dp[0];\n-\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n \t\t\t_y = v->dp[0];\n \t\t\t_a = _d = 1;\n \t\t\t_b = _c = 0;\n@@ -237,8 +242,13 @@ void bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {\n \t\t\t\tbn_copy(x, y);\n \t\t\t\tbn_copy(y, t0);\n \t\t\t} else {\n-\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n-\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n+\t\t\t\tif (bn_bits(x) > 2 * RLC_DIG) {\n+\t\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n+\t\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n+\t\t\t\t} else {\n+\t\t\t\t\tbn_copy(u, x);\n+\t\t\t\t\tbn_copy(v, y);\n+\t\t\t\t}\n \t\t\t\tif (_a < 0) {\n \t\t\t\t\tbn_mul_dig(t0, u, -_a);\n \t\t\t\t\tbn_neg(t0, t0);\n@@ -265,9 +275,14 @@ void bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {\n \t\t\t\t}\n \t\t\t\tbn_add(u, t0, t1);\n \t\t\t\tbn_add(v, t2, t3);\n-\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n+\t\t\t\tif (bn_bits(u) > RLC_DIG) {\n+\t\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n+\t\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n+\t\t\t\t} else {\n+\t\t\t\t\tbn_copy(t0, u);\n+\t\t\t\t\tbn_copy(t1, v);\n+\t\t\t\t}\n \t\t\t\t_x = t0->dp[0];\n-\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n \t\t\t\t_y = t1->dp[0];\n \t\t\t\tt = 0;\n \t\t\t\tif (_y != 0) {\n@@ -400,9 +415,14 @@ void bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n \t\tbn_set_dig(d, 1);\n \n \t\twhile (y->used > 1) {\n-\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n+\t\t\tif (bn_bits(x) > RLC_DIG) {\n+\t\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n+\t\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n+\t\t\t} else {\n+\t\t\t\tbn_copy(u, x);\n+\t\t\t\tbn_copy(v, y);\n+\t\t\t}\n \t\t\t_x = u->dp[0];\n-\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n \t\t\t_y = v->dp[0];\n \t\t\t_a = _d = 1;\n \t\t\t_b = _c = 0;\n@@ -439,8 +459,13 @@ void bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n \t\t\t\tbn_copy(t4, d);\n \t\t\t\tbn_copy(d, t1);\n \t\t\t} else {\n-\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n-\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n+\t\t\t\tif (bn_bits(x) > 2 * RLC_DIG) {\n+\t\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n+\t\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n+\t\t\t\t} else {\n+\t\t\t\t\tbn_copy(u, x);\n+\t\t\t\t\tbn_copy(v, y);\n+\t\t\t\t}\n \t\t\t\tif (_a < 0) {\n \t\t\t\t\tbn_mul_dig(t0, u, -_a);\n \t\t\t\t\tbn_neg(t0, t0);\n@@ -467,9 +492,14 @@ void bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n \t\t\t\t}\n \t\t\t\tbn_add(u, t0, t1);\n \t\t\t\tbn_add(v, t2, t3);\n-\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n+\t\t\t\tif (bn_bits(u) > RLC_DIG) {\n+\t\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n+\t\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n+\t\t\t\t} else {\n+\t\t\t\t\tbn_copy(t0, u);\n+\t\t\t\t\tbn_copy(t1, v);\n+\t\t\t\t}\n \t\t\t\t_x = t0->dp[0];\n-\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n \t\t\t\t_y = t1->dp[0];\n \t\t\t\tt = 0;\n \t\t\t\tif (_y != 0) {"
        },
        {
          "filename": "src/bn/relic_bn_mem.c",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -41,7 +41,7 @@\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void bn_make(bn_t a, int digits) {\n+void bn_make(bn_t a, size_t digits) {\n \tif (digits < 0) {\n \t\tRLC_THROW(ERR_NO_VALID);\n \t}\n@@ -112,7 +112,7 @@ void bn_clean(bn_t a) {\n \t}\n }\n \n-void bn_grow(bn_t a, int digits) {\n+void bn_grow(bn_t a, size_t digits) {\n #if ALLOC == DYNAMIC\n \tdig_t *t;\n \n@@ -143,7 +143,7 @@ void bn_trim(bn_t a) {\n \t\t\t--(a->used);\n \t\t}\n \t\t/* Zero can't be negative. */\n-\t\tif (a->used <= 0) {\n+\t\tif (a->used == 0) {\n \t\t\ta->used = 1;\n \t\t\ta->dp[0] = 0;\n \t\t\ta->sign = RLC_POS;"
        },
        {
          "filename": "src/bn/relic_bn_mxp.c",
          "status": "modified",
          "additions": 13,
          "deletions": 14,
          "patch": "@@ -116,7 +116,7 @@ void bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n \n void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n \tbn_t tab[RLC_TABLE_SIZE], t, u, r;\n-\tint i, j, l, w = 1;\n+\tsize_t l, w = 1;\n \tuint8_t *win = RLC_ALLOCA(uint8_t, bn_bits(b));\n \n \tif (win == NULL) {\n@@ -140,28 +140,28 @@ void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n \tbn_null(u);\n \tbn_null(r);\n \t/* Initialize table. */\n-\tfor (i = 0; i < RLC_TABLE_SIZE; i++) {\n+\tfor (size_t i = 0; i < RLC_TABLE_SIZE; i++) {\n \t\tbn_null(tab[i]);\n \t}\n \n \t/* Find window size. */\n-\ti = bn_bits(b);\n-\tif (i <= 21) {\n+\tl = bn_bits(b);\n+\tif (l <= 21) {\n \t\tw = 2;\n-\t} else if (i <= 32) {\n+\t} else if (l <= 32) {\n \t\tw = 3;\n-\t} else if (i <= 128) {\n+\t} else if (l <= 128) {\n \t\tw = 4;\n-\t} else if (i <= 256) {\n+\t} else if (l <= 256) {\n \t\tw = 5;\n-\t} else if (i <= 512) {\n+\t} else if (l <= 512) {\n \t\tw = 6;\n \t} else {\n \t\tw = 7;\n \t}\n \n \tRLC_TRY {\n-\t\tfor (i = 0; i < (1 << (w - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (w - 1)); i++) {\n \t\t\tbn_new(tab[i]);\n \t\t}\n \n@@ -183,19 +183,18 @@ void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n \t\tbn_sqr(t, tab[0]);\n \t\tbn_mod(t, t, m, u);\n \t\t/* Create table. */\n-\t\tfor (i = 1; i < 1 << (w - 1); i++) {\n+\t\tfor (size_t i = 1; i < 1 << (w - 1); i++) {\n \t\t\tbn_mul(tab[i], tab[i - 1], t);\n \t\t\tbn_mod(tab[i], tab[i], m, u);\n \t\t}\n \n-\t\tl = bn_bits(b);\n \t\tbn_rec_slw(win, &l, b, w);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\tbn_sqr(r, r);\n \t\t\t\tbn_mod(r, r, m, u);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\tbn_sqr(r, r);\n \t\t\t\t\tbn_mod(r, r, m, u);\n \t\t\t\t}\n@@ -218,7 +217,7 @@ void bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n \t\tRLC_THROW(ERR_CAUGHT);\n \t}\n \tRLC_FINALLY {\n-\t\tfor (i = 0; i < (1 << (w - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (w - 1)); i++) {\n \t\t\tbn_free(tab[i]);\n \t\t}\n \t\tbn_free(u);"
        },
        {
          "filename": "src/bn/relic_bn_prime.c",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -276,7 +276,7 @@ int bn_is_prime_rabin(const bn_t a) {\n \t\tbn_sub_dig(n1, a, 1);\n \t\tbn_copy(r, n1);\n \t\ts = 0;\n-\t\twhile (bn_is_even(r)) {\n+\t\twhile (!bn_is_zero(r) && bn_is_even(r)) {\n \t\t\ts++;\n \t\t\tbn_rsh(r, r, 1);\n \t\t}\n@@ -401,7 +401,7 @@ int bn_is_prime_solov(const bn_t a) {\n \n #if BN_GEN == BASIC || !defined(STRIP)\n \n-void bn_gen_prime_basic(bn_t a, int bits) {\n+void bn_gen_prime_basic(bn_t a, size_t bits) {\n \twhile (1) {\n \t\tdo {\n \t\t\tbn_rand(a, RLC_POS, bits);\n@@ -416,7 +416,7 @@ void bn_gen_prime_basic(bn_t a, int bits) {\n \n #if BN_GEN == SAFEP || !defined(STRIP)\n \n-void bn_gen_prime_safep(bn_t a, int bits) {\n+void bn_gen_prime_safep(bn_t a, size_t bits) {\n \twhile (1) {\n \t\tdo {\n \t\t\tbn_rand(a, RLC_POS, bits);\n@@ -440,7 +440,7 @@ void bn_gen_prime_safep(bn_t a, int bits) {\n \n #if BN_GEN == STRON || !defined(STRIP)\n \n-void bn_gen_prime_stron(bn_t a, int bits) {\n+void bn_gen_prime_stron(bn_t a, size_t bits) {\n \tdig_t i, j;\n \tint found, k;\n \tbn_t r, s, t;\n@@ -519,7 +519,7 @@ void bn_gen_prime_stron(bn_t a, int bits) {\n \n #endif\n \n-int bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {\n+int bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits) {\n \tbn_t t;\n \tint result = RLC_OK;\n "
        },
        {
          "filename": "src/bn/relic_bn_rec.c",
          "status": "modified",
          "additions": 15,
          "deletions": 11,
          "patch": "@@ -43,7 +43,7 @@\n  * @param[in] to\t\t\t- the last bit position, inclusive.\n  * @return the bits in the chosen positions.\n  */\n-static char get_bits(const bn_t a, int from, int to) {\n+static char get_bits(const bn_t a, size_t from, size_t to) {\n \tint f, t;\n \tdig_t mf, mt;\n \n@@ -91,7 +91,7 @@ static char get_bits(const bn_t a, int from, int to) {\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w) {\n+void bn_rec_win(uint8_t *win, size_t *len, const bn_t k, size_t w) {\n \tint i, j, l;\n \n \tl = bn_bits(k);\n@@ -112,7 +112,7 @@ void bn_rec_win(uint8_t *win, int *len, const bn_t k, int w) {\n \t*len = j;\n }\n \n-void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w) {\n+void bn_rec_slw(uint8_t *win, size_t *len, const bn_t k, size_t w) {\n \tint i, j, l, s;\n \n \tl = bn_bits(k);\n@@ -143,7 +143,7 @@ void bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w) {\n \t*len = j;\n }\n \n-void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {\n+void bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w) {\n \tint i, l;\n \tbn_t t;\n \tdig_t t0, mask;\n@@ -217,7 +217,8 @@ void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {\n \t}\n }\n \n-void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w) {\n+void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u,\n+\t\tsize_t w) {\n \tif (u == -1) {\n \t\tswitch (w) {\n \t\t\tcase 2:\n@@ -349,7 +350,7 @@ void bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w) {\n \t}\n }\n \n-void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m) {\n+void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, size_t m) {\n \tbn_t t, t0, t1, t2, t3;\n \n \tbn_null(t);\n@@ -421,7 +422,8 @@ void bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m) {\n \t}\n }\n \n-void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {\n+void bn_rec_tnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n+\t\tsize_t w) {\n \tint i, l;\n \tbn_t tmp, r0, r1;\n \tint8_t beta[64], gama[64];\n@@ -551,7 +553,8 @@ void bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {\n \t}\n }\n \n-void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {\n+void bn_rec_rtnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n+\t\tsize_t w) {\n \tint i, l;\n \tbn_t tmp, r0, r1;\n \tint8_t beta[64], gama[64];\n@@ -693,7 +696,7 @@ void bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w)\n \t}\n }\n \n-void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w) {\n+void bn_rec_reg(int8_t *naf, size_t *len, const bn_t k, size_t n, size_t w) {\n \tint i, l;\n \tbn_t t;\n \tdig_t t0, mask;\n@@ -746,7 +749,7 @@ void bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w) {\n \t}\n }\n \n-void bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l) {\n+void bn_rec_jsf(int8_t *jsf, size_t *len, const bn_t k, const bn_t l) {\n \tbn_t n0, n1;\n \tdig_t l0, l1;\n \tint8_t u0, u1, d0, d1;\n@@ -828,7 +831,8 @@ void bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l) {\n void bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t *v1,\n \t\tconst bn_t *v2) {\n \tbn_t t, b1, b2;\n-\tint r1, r2, bits;\n+\tint r1, r2;\n+\tsize_t bits;\n \n \tbn_null(b1);\n \tbn_null(b2);"
        },
        {
          "filename": "src/bn/relic_bn_shift.c",
          "status": "modified",
          "additions": 8,
          "deletions": 11,
          "patch": "@@ -63,16 +63,12 @@ void bn_hlv(bn_t c, const bn_t a) {\n \tbn_trim(c);\n }\n \n-void bn_lsh(bn_t c, const bn_t a, int bits) {\n+void bn_lsh(bn_t c, const bn_t a, unsigned int bits) {\n \tint digits;\n \tdig_t carry;\n \n \tbn_copy(c, a);\n \n-\tif (bits <= 0) {\n-\t\treturn;\n-\t}\n-\n \tRLC_RIP(bits, digits, bits);\n \n \tRLC_TRY {\n@@ -101,21 +97,22 @@ void bn_lsh(bn_t c, const bn_t a, int bits) {\n \t}\n }\n \n-void bn_rsh(bn_t c, const bn_t a, int bits) {\n+void bn_rsh(bn_t c, const bn_t a, unsigned int bits) {\n \tint digits = 0;\n \n \tbn_copy(c, a);\n \n-\tif (bits <= 0) {\n-\t\treturn;\n-\t}\n-\n \tRLC_RIP(bits, digits, bits);\n \n \tif (digits > 0) {\n \t\tdv_rshd(c->dp, a->dp, a->used, digits);\n \t}\n-\tc->used = a->used - digits;\n+\n+\tif (a->used > digits) {\n+\t\tc->used = a->used - digits;\n+\t} else {\n+\t\tc->used = 0;\n+\t}\n \tc->sign = a->sign;\n \n \tif (c->used > 0 && bits > 0) {"
        },
        {
          "filename": "src/bn/relic_bn_smb.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -121,7 +121,7 @@ int bn_smb_jac(const bn_t a, const bn_t b) {\n \t\t\t}\n \t\t\t/* Write t0 as 2^h * t0. */\n \t\t\th = 0;\n-\t\t\twhile (bn_is_even(t0)) {\n+\t\t\twhile (bn_is_even(t0) && !bn_is_zero(t0)) {\n \t\t\t\th++;\n \t\t\t\tbn_rsh(t0, t0, 1);\n \t\t\t}"
        },
        {
          "filename": "src/bn/relic_bn_srt.c",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -38,7 +38,8 @@\n \n void bn_srt(bn_t c, bn_t a) {\n \tbn_t h, l, m, t;\n-\tint bits, cmp;\n+\tsize_t bits;\n+\tint cmp;\n \n \tif (bn_sign(a) == RLC_NEG) {\n \t\tRLC_THROW(ERR_NO_VALID);\n@@ -58,8 +59,11 @@ void bn_srt(bn_t c, bn_t a) {\n \t\tbn_new(m);\n \t\tbn_new(t);\n \n+\t\tbn_zero(l);\n \t\tbn_set_2b(h, bits >> 1);\n-\t\tbn_set_2b(l, (bits >> 1) - 1);\n+\t\tif (bits >= 2) {\n+\t\t\tbn_set_2b(l, (bits >> 1) - 1);\n+\t\t}\n \n \t\t/* Trivial binary search approach. */\n \t\tdo {"
        },
        {
          "filename": "src/bn/relic_bn_util.c",
          "status": "modified",
          "additions": 17,
          "deletions": 17,
          "patch": "@@ -105,7 +105,7 @@ int bn_is_even(const bn_t a) {\n \treturn 0;\n }\n \n-int bn_bits(const bn_t a) {\n+size_t bn_bits(const bn_t a) {\n \tint bits;\n \n \tif (bn_is_zero(a)) {\n@@ -118,7 +118,7 @@ int bn_bits(const bn_t a) {\n \treturn bits + util_bits_dig(a->dp[a->used - 1]);\n }\n \n-int bn_get_bit(const bn_t a, int bit) {\n+int bn_get_bit(const bn_t a, size_t bit) {\n \tint d;\n \n \tif (bit < 0) {\n@@ -139,7 +139,7 @@ int bn_get_bit(const bn_t a, int bit) {\n \t}\n }\n \n-void bn_set_bit(bn_t a, int bit, int value) {\n+void bn_set_bit(bn_t a, size_t bit, int value) {\n \tint d;\n \n \tif (bit < 0) {\n@@ -162,7 +162,7 @@ void bn_set_bit(bn_t a, int bit, int value) {\n \t}\n }\n \n-int bn_ham(const bn_t a) {\n+size_t bn_ham(const bn_t a) {\n \tint c = 0;\n \n \tfor (int i = 0; i < bn_bits(a); i++) {\n@@ -183,11 +183,11 @@ void bn_set_dig(bn_t a, dig_t digit) {\n \ta->sign = RLC_POS;\n }\n \n-void bn_set_2b(bn_t a, int b) {\n+void bn_set_2b(bn_t a, size_t b) {\n \tint i, d;\n \n-\tif (b < 0) {\n-\t\tbn_zero(a);\n+\tif (b >= RLC_BN_SIZE * RLC_DIG) {\n+\t\tRLC_THROW(ERR_NO_VALID);\n \t} else {\n \t\tRLC_RIP(b, d, b);\n \n@@ -201,7 +201,7 @@ void bn_set_2b(bn_t a, int b) {\n \t}\n }\n \n-void bn_rand(bn_t a, int sign, int bits) {\n+void bn_rand(bn_t a, int sign, size_t bits) {\n \tint digits;\n \n \tRLC_RIP(bits, digits, bits);\n@@ -264,7 +264,7 @@ void bn_print(const bn_t a) {\n \t}\n }\n \n-int bn_size_str(const bn_t a, int radix) {\n+size_t bn_size_str(const bn_t a, unsigned int radix) {\n \tint digits = 0;\n \tbn_t t;\n \n@@ -308,7 +308,7 @@ int bn_size_str(const bn_t a, int radix) {\n \treturn digits + 1;\n }\n \n-void bn_read_str(bn_t a, const char *str, int len, int radix) {\n+void bn_read_str(bn_t a, const char *str, size_t len, unsigned int radix) {\n \tint sign, i, j;\n \tchar c;\n \n@@ -357,7 +357,7 @@ void bn_read_str(bn_t a, const char *str, int len, int radix) {\n \t}\n }\n \n-void bn_write_str(char *str, int len, const bn_t a, int radix) {\n+void bn_write_str(char *str, size_t len, const bn_t a, unsigned int radix) {\n \tbn_t t;\n \tdig_t d;\n \tint digits, l, i, j;\n@@ -426,7 +426,7 @@ void bn_write_str(char *str, int len, const bn_t a, int radix) {\n \t}\n }\n \n-int bn_size_bin(const bn_t a) {\n+size_t bn_size_bin(const bn_t a) {\n \tdig_t d;\n \tint digits;\n \n@@ -440,7 +440,7 @@ int bn_size_bin(const bn_t a) {\n \treturn digits;\n }\n \n-void bn_read_bin(bn_t a, const uint8_t *bin, int len) {\n+void bn_read_bin(bn_t a, const uint8_t *bin, size_t len) {\n \tint i, j;\n \tdig_t d = (RLC_DIG / 8);\n \tint digs = (len % d == 0 ? len / d : len / d + 1);\n@@ -470,7 +470,7 @@ void bn_read_bin(bn_t a, const uint8_t *bin, int len) {\n \tbn_trim(a);\n }\n \n-void bn_write_bin(uint8_t *bin, int len, const bn_t a) {\n+void bn_write_bin(uint8_t *bin, size_t len, const bn_t a) {\n \tint size, k;\n \tdig_t d;\n \n@@ -501,11 +501,11 @@ void bn_write_bin(uint8_t *bin, int len, const bn_t a) {\n \t}\n }\n \n-int bn_size_raw(const bn_t a) {\n+size_t bn_size_raw(const bn_t a) {\n \treturn a->used;\n }\n \n-void bn_read_raw(bn_t a, const dig_t *raw, int len) {\n+void bn_read_raw(bn_t a, const dig_t *raw, size_t len) {\n \tRLC_TRY {\n \t\tbn_grow(a, len);\n \t\ta->used = len;\n@@ -517,7 +517,7 @@ void bn_read_raw(bn_t a, const dig_t *raw, int len) {\n \t}\n }\n \n-void bn_write_raw(dig_t *raw, int len, const bn_t a) {\n+void bn_write_raw(dig_t *raw, size_t len, const bn_t a) {\n \tint i, size;\n \n \tsize = a->used;"
        },
        {
          "filename": "src/cp/relic_cp_bls.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -57,7 +57,7 @@ int cp_bls_gen(bn_t d, g2_t q) {\n \treturn result;\n }\n \n-int cp_bls_sig(g1_t s, const uint8_t *msg, int len, const bn_t d) {\n+int cp_bls_sig(g1_t s, const uint8_t *msg, size_t len, const bn_t d) {\n \tg1_t p;\n \tint result = RLC_OK;\n "
        },
        {
          "filename": "src/cp/relic_cp_cmlhs.c",
          "status": "modified",
          "additions": 19,
          "deletions": 12,
          "patch": "@@ -65,22 +65,26 @@ int cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,\n \t\tpc_map(gt, g1, g2);\n \n \t\trand_bytes(prf, plen);\n-\t\tif (bls) {\n-\t\t\tcp_bls_gen(sk, pk);\n-\t\t} else {\n-\t\t\tcp_ecdsa_gen(sk, g1);\n-\t\t\tfp_copy(pk->x[0], g1->x);\n-\t\t\tfp_copy(pk->y[0], g1->y);\n-\t\t}\n+\n+\t\tbn_rand_mod(d, n);\n+\t\tg2_mul_gen(y, d);\n \n \t\t/* Generate elements for n tags. */\n \t\tfor (int i = 0; i < len; i++) {\n \t\t\tbn_rand_mod(x[i], n);\n \t\t\tgt_exp(hs[i], gt, x[i]);\n \t\t}\n \n-\t\tbn_rand_mod(d, n);\n-\t\tg2_mul_gen(y, d);\n+\t\tif (bls) {\n+\t\t\tresult = cp_bls_gen(sk, pk);\n+\t\t} else {\n+\t\t\tif (cp_ecdsa_gen(sk, g1) == RLC_OK) {\n+\t\t\t\tfp_copy(pk->x[0], g1->x);\n+\t\t\t\tfp_copy(pk->y[0], g1->y);\n+\t\t\t} else {\n+\t\t\t\tresult = RLC_ERR;\n+\t\t\t}\n+\t\t}\n \t}\n \tRLC_CATCH_ANY {\n \t\tresult = RLC_ERR;\n@@ -101,8 +105,9 @@ int cp_cmlhs_sig(g1_t sig, g2_t z, g1_t a, g1_t c, g1_t r, g2_t s,\n \tbn_t k, m, n;\n \tg1_t t;\n \tuint8_t mac[RLC_MD_LEN];\n-\tint len, dlen = strlen(data), result = RLC_OK;\n+\tsize_t len, dlen = strlen(data);\n \tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);\n+\tint result = RLC_OK;\n \n \tbn_null(k);\n \tbn_null(m);\n@@ -211,8 +216,9 @@ int cp_cmlhs_ver(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n \tg2_t g2;\n \tgt_t e, u, v;\n \tbn_t k, n;\n-\tint len, dlen = strlen(data), result = 1;\n+\tsize_t len, dlen = strlen(data);\n \tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);\n+\tint result = 1;\n \n \tg1_null(g1);\n \tg2_null(g2);\n@@ -331,8 +337,9 @@ int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n \tg2_t g2;\n \tgt_t e, u, v;\n \tbn_t k, n;\n-\tint len, dlen = strlen(data), result = 1;\n+\tsize_t len, dlen = strlen(data);\n \tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n+\tint result = 1;\n \n \tg1_null(g1);\n \tg2_null(g2);"
        },
        {
          "filename": "src/cp/relic_cp_pbpsi.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -114,6 +114,7 @@ int cp_pbpsi_ask(g2_t d[], bn_t r, const bn_t x[], const g2_t s[], size_t m) {\n \t\t\tbn_free(_x[i]);\n \t\t}\n \t\tRLC_FREE(p);\n+\t\tRLC_FREE(_x);\n \t}\n \treturn result;\n }"
        },
        {
          "filename": "src/cp/relic_cp_rsa.c",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -244,17 +244,18 @@ static uint8_t *hash_id(int md, int *len) {\n  * @param[in] operation\t- flag to indicate the operation type.\n  * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n  */\n-static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n+static int pad_pkcs1(bn_t m, int *p_len, size_t m_len, size_t k_len, int op) {\n \tuint8_t *id, pad = 0;\n-\tint len, result = RLC_ERR;\n+\tsize_t len;\n+\tint result = RLC_ERR;\n \tbn_t t;\n \n \tbn_null(t);\n \n \tRLC_TRY {\n \t\tbn_new(t);\n \n-\t\tswitch (operation) {\n+\t\tswitch (op) {\n \t\t\tcase RSA_ENC:\n \t\t\t\t/* EB = 00 | 02 | PS | 00 | D. */\n \t\t\t\tbn_zero(m);\n@@ -419,7 +420,7 @@ static int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n  * @param[in] operation\t- flag to indicate the operation type.\n  * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n  */\n-static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n+static int pad_pkcs2(bn_t m, int *p_len, size_t m_len, size_t k_len, int op) {\n \tuint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n \tuint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n \tint result = RLC_ERR;\n@@ -430,7 +431,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n \tRLC_TRY {\n \t\tbn_new(t);\n \n-\t\tswitch (operation) {\n+\t\tswitch (op) {\n \t\t\tcase RSA_ENC:\n \t\t\t\t/* DB = lHash | PS | 01 | D. */\n \t\t\t\tmd_map(h1, NULL, 0);\n@@ -578,7 +579,7 @@ static int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-int cp_rsa_gen(rsa_t pub, rsa_t prv, int bits) {\n+int cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits) {\n \tbn_t t, r;\n \tint result = RLC_OK;\n "
        },
        {
          "filename": "src/cp/relic_cp_sokaka.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -72,8 +72,8 @@ int cp_sokaka_gen_prv(sokaka_t k, const char *id, bn_t master) {\n \n int cp_sokaka_key(uint8_t *key, size_t key_len, const char *id1,\n \t\tconst sokaka_t k, const char *id2) {\n-\tint len1 = strlen(id1), len2 = strlen(id2);\n-\tint size, first = 0, result = RLC_OK;\n+\tsize_t size, len1 = strlen(id1), len2 = strlen(id2);\n+\tint first = 0, result = RLC_OK;\n \tuint8_t *buf;\n \tg1_t p;\n \tg2_t q;"
        },
        {
          "filename": "src/cp/relic_cp_vbnn.c",
          "status": "modified",
          "additions": 7,
          "deletions": 5,
          "patch": "@@ -73,9 +73,10 @@ int cp_vbnn_gen(bn_t msk, ec_t mpk) {\n int cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,\n \t\tsize_t id_len) {\n \tuint8_t hash[RLC_MD_LEN];\n-\tint len, result = RLC_OK;\n+\tsize_t len;\n \tuint8_t *buf = NULL;\n \tbn_t n, r;\n+\tint result = RLC_OK;\n \n \t/* zero variables */\n \tbn_null(n);\n@@ -125,10 +126,11 @@ int cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,\n \n int cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,\n \t\tconst uint8_t *msg, int msg_len, const bn_t sk, const ec_t pk) {\n-\tint len, result = RLC_OK;\n+\tsize_t len;\n \tuint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];\n \tbn_t n, y;\n \tec_t t;\n+\tint result = RLC_OK;\n \n \t/* zero variables */\n \tbn_null(n);\n@@ -189,11 +191,11 @@ int cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,\n \n int cp_vbnn_ver(const ec_t r, const bn_t z, const bn_t h, const uint8_t *id,\n \t\tsize_t id_len, const uint8_t *msg, int msg_len, const ec_t mpk) {\n-\tint len, result = 0;\n+\tsize_t len;\n \tuint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];\n \tbn_t n, c, _h;\n-\tec_t Z;\n-\tec_t t;\n+\tec_t Z, t;\n+\tint result = 0;\n \n \t/* zero variables */\n \tbn_null(n);"
        },
        {
          "filename": "src/eb/relic_eb_map.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -37,7 +37,7 @@\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void eb_map(eb_t p, const uint8_t *msg, int len) {\n+void eb_map(eb_t p, const uint8_t *msg, size_t len) {\n \tbn_t k;\n \tfb_t t0, t1;\n \tint i;"
        },
        {
          "filename": "src/eb/relic_eb_mul.c",
          "status": "modified",
          "additions": 13,
          "deletions": 8,
          "patch": "@@ -49,9 +49,10 @@\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void eb_mul_ltnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n-\tint i, l, n;\n+\tint i, n;\n \tint8_t tnaf[RLC_FB_BITS + 8], u;\n \teb_t t[1 << (EB_WIDTH - 2)];\n+\tsize_t l;\n \n \tif (eb_curve_opt_a() == RLC_ZERO) {\n \t\tu = -1;\n@@ -120,9 +121,10 @@ static void eb_mul_ltnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void eb_mul_lnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n-\tint i, l, n;\n+\tint i, n;\n \tint8_t naf[RLC_FB_BITS + 1];\n \teb_t t[1 << (EB_WIDTH - 2)];\n+\tsize_t l;\n \n \tRLC_TRY {\n \t\t/* Prepare the precomputation table. */\n@@ -190,9 +192,10 @@ static void eb_mul_lnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void eb_mul_rtnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n-\tint i, l, n;\n+\tint i, n;\n \tint8_t tnaf[RLC_FB_BITS + 8], u;\n \teb_t t[1 << (EB_WIDTH - 2)];\n+\tsize_t l;\n \n \tif (eb_curve_opt_a() == RLC_ZERO) {\n \t\tu = -1;\n@@ -489,9 +492,10 @@ static void eb_mul_rtnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void eb_mul_rnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n-\tint i, l, n;\n+\tint i, n;\n \tint8_t naf[RLC_FB_BITS + 1];\n \teb_t t[1 << (EB_WIDTH - 2)];\n+\tsize_t l;\n \n \tRLC_TRY {\n \t\t/* Prepare the accumulator table. */\n@@ -650,10 +654,10 @@ void eb_mul_basic(eb_t r, const eb_t p, const bn_t k) {\n #if EB_MUL == LODAH || !defined(STRIP)\n \n void eb_mul_lodah(eb_t r, const eb_t p, const bn_t k) {\n-\tint bits, i, j;\n \tdv_t x1, z1, x2, z2, r1, r2, r3, r4, r5;\n \tconst dig_t *b;\n \tbn_t t, n;\n+\tsize_t bits;\n \n \tif (bn_is_zero(k)) {\n \t\teb_set_infty(r);\n@@ -721,8 +725,8 @@ void eb_mul_lodah(eb_t r, const eb_t p, const bn_t k) {\n \t\tfb_mul(z2, z2, r1);\n \t\tfb_mul(x2, x2, r1);\n \n-\t\tfor (i = bits - 1; i >= 0; i--) {\n-\t\t\tj = bn_get_bit(t, i);\n+\t\tfor (int i = bits - 1; i >= 0; i--) {\n+\t\t\tint j = bn_get_bit(t, i);\n \t\t\tfb_mul(r1, x1, z2);\n \t\t\tfb_mul(r2, x2, z1);\n \t\t\tfb_add(r3, r1, r2);\n@@ -889,11 +893,12 @@ void eb_mul_rwnaf(eb_t r, const eb_t p, const bn_t k) {\n #if EB_MUL == HALVE || !defined(STRIP)\n \n void eb_mul_halve(eb_t r, const eb_t p, const bn_t k) {\n-\tint i, j, l, trc, cof;\n+\tint i, j, trc, cof;\n \tint8_t naf[RLC_FB_BITS + 1], *_k;\n \teb_t q, s, t[1 << (EB_WIDTH - 2)];\n \tbn_t n, m;\n \tfb_t u, v, w, z;\n+\tsize_t l;\n \n \tif (bn_is_zero(k) || eb_is_infty(p)) {\n \t\teb_set_infty(r);"
        },
        {
          "filename": "src/eb/relic_eb_mul_sim.c",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -54,10 +54,11 @@\n  */\n static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n \t\tconst bn_t m, const eb_t *t) {\n-\tint i, l, l0, l1, n0, n1, w, g;\n+\tint i, n0, n1, w, g;\n \tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n \teb_t t0[1 << (EB_WIDTH - 2)];\n \teb_t t1[1 << (EB_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n \t\teb_null(t0[i]);\n@@ -183,10 +184,11 @@ static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n  */\n static void eb_mul_sim_plain(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n \t\tconst bn_t m, const eb_t *t) {\n-\tint i, l, l0, l1, n0, n1, w, g;\n+\tint i, n0, n1, w, g;\n \tint8_t naf0[RLC_FB_BITS + 1], naf1[RLC_FB_BITS + 1], *_k, *_m;\n \teb_t t0[1 << (EB_WIDTH - 2)];\n \teb_t t1[1 << (EB_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n \t\teb_null(t0[i]);\n@@ -310,7 +312,7 @@ void eb_mul_sim_basic(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n void eb_mul_sim_trick(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n \t\tconst bn_t m) {\n \teb_t t0[1 << (EB_WIDTH / 2)], t1[1 << (EB_WIDTH / 2)], t[1 << EB_WIDTH];\n-\tint l0, l1, w = EB_WIDTH / 2;\n+\tsize_t l0, l1, w = EB_WIDTH / 2;\n \tuint8_t w0[RLC_FB_BITS], w1[RLC_FB_BITS];\n \tbn_t n;\n \n@@ -436,8 +438,9 @@ void eb_mul_sim_inter(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n void eb_mul_sim_joint(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n \t\tconst bn_t m) {\n \teb_t t[5];\n-\tint i, u_i, len, offset;\n+\tint i, u_i, offset;\n \tint8_t jsf[2 * (RLC_FB_BITS + 1)];\n+\tsize_t len;\n \n \tif (bn_is_zero(k) || eb_is_infty(p)) {\n \t\teb_mul(r, q, m);"
        },
        {
          "filename": "src/eb/relic_eb_util.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -500,7 +500,7 @@ int eb_size_bin(const eb_t a, int pack) {\n \treturn size;\n }\n \n-void eb_read_bin(eb_t a, const uint8_t *bin, int len) {\n+void eb_read_bin(eb_t a, const uint8_t *bin, size_t len) {\n \tif (len == 1) {\n \t\tif (bin[0] == 0) {\n \t\t\teb_set_infty(a);\n@@ -550,7 +550,7 @@ void eb_read_bin(eb_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void eb_write_bin(uint8_t *bin, int len, const eb_t a, int pack) {\n+void eb_write_bin(uint8_t *bin, size_t len, const eb_t a, int pack) {\n \teb_t t;\n \n \teb_null(t);"
        },
        {
          "filename": "src/ed/relic_ed_map.c",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -187,7 +187,8 @@ void ed_map_ell2_5mod8(ed_t p, fp_t t) {\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len) {\n+void ed_map_dst(ed_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len) {\n \tbn_t k;\n \tfp_t t;\n \ted_t q;\n@@ -254,6 +255,6 @@ void ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst\n \t}\n }\n \n-void ed_map(ed_t p, const uint8_t *msg, int len) {\n+void ed_map(ed_t p, const uint8_t *msg, size_t len) {\n \ted_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n }"
        },
        {
          "filename": "src/ed/relic_ed_mul.c",
          "status": "modified",
          "additions": 11,
          "deletions": 9,
          "patch": "@@ -39,9 +39,10 @@\n #if ED_MUL == LWNAF || !defined(STRIP)\n \n static void ed_mul_naf_imp(ed_t r, const ed_t p, const bn_t k) {\n-\tint l, i, n;\n+\tint i, n;\n \tint8_t naf[RLC_FP_BITS + 1];\n \ted_t t[1 << (ED_WIDTH - 2)];\n+\tsize_t l;\n \n \tif (bn_is_zero(k)) {\n \t\ted_set_infty(r);\n@@ -110,9 +111,10 @@ static void ed_mul_naf_imp(ed_t r, const ed_t p, const bn_t k) {\n \n static void ed_mul_reg_imp(ed_t r, const ed_t p, const bn_t k) {\n \tbn_t _k;\n-\tint i, j, l, n;\n+\tint i, j, n;\n \tint8_t s, reg[RLC_CEIL(RLC_FP_BITS + 1, ED_WIDTH - 1)];\n \ted_t t[1 << (ED_WIDTH - 2)], u, v;\n+\tsize_t l;\n \n \tbn_null(_k);\n \tif (bn_is_zero(k)) {\n@@ -233,8 +235,8 @@ void ed_mul_basic(ed_t r, const ed_t p, const bn_t k) {\n \n void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n \ted_t t[1 << (EP_WIDTH - 1)], q;\n-\tint i, j, l;\n \tuint8_t win[RLC_FP_BITS + 1];\n+\tsize_t l;\n \n \ted_null(q);\n \n@@ -244,7 +246,7 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n \t}\n \n \tRLC_TRY {\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n \t\t\ted_null(t[i]);\n \t\t\ted_new(t[i]);\n \t\t}\n@@ -259,7 +261,7 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n #endif\n \n \t\t/* Create table. */\n-\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\ted_add(t[i], t[i - 1], q);\n \t\t}\n \n@@ -270,11 +272,11 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n \t\ted_set_infty(q);\n \t\tl = RLC_FP_BITS + 1;\n \t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\ted_dbl(q, q);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\ted_dbl(q, q);\n \t\t\t\t}\n \t\t\t\ted_add(q, q, t[win[i] >> 1]);\n@@ -290,7 +292,7 @@ void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n \t\tRLC_THROW(ERR_CAUGHT);\n \t}\n \tRLC_FINALLY {\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\ted_free(t[i]);\n \t\t}\n \t\ted_free(q);\n@@ -409,7 +411,7 @@ void ed_mul_dig(ed_t r, const ed_t p, dig_t k) {\n \ted_t t;\n \tbn_t _k;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \ted_null(t);\n \tbn_null(_k);"
        },
        {
          "filename": "src/ed/relic_ed_mul_fix.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -47,8 +47,9 @@\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void ed_mul_fix_plain(ed_t r, const ed_t * t, const bn_t k) {\n-\tint l, i, n;\n+\tint i, n;\n \tint8_t naf[RLC_FP_BITS + 1], *_k;\n+\tsize_t l;\n \n \t/* Compute the w-TNAF representation of k. */\n \tl = RLC_FP_BITS + 1;"
        },
        {
          "filename": "src/ed/relic_ed_mul_sim.c",
          "status": "modified",
          "additions": 8,
          "deletions": 5,
          "patch": "@@ -53,10 +53,11 @@\n  */\n static void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n \t\tconst bn_t m, const ed_t *t) {\n-\tint i, l, l0, l1, n0, n1, w, gen;\n+\tint i, n0, n1, w, gen;\n \tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n \ted_t t0[1 << (ED_WIDTH - 2)];\n \ted_t t1[1 << (ED_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tRLC_TRY {\n \t\tgen = (t == NULL ? 0 : 1);\n@@ -176,7 +177,7 @@ void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n \t\tconst bn_t m) {\n \ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n \tbn_t n;\n-\tint l0, l1, w = ED_WIDTH / 2;\n+\tsize_t l0, l1, w = ED_WIDTH / 2;\n \tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n \n \tbn_null(n);\n@@ -293,8 +294,9 @@ void ed_mul_sim_inter(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n void ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n \t\tconst bn_t m) {\n \ted_t t[5];\n-\tint i, l, u_i, offset;\n+\tint i, u_i, offset;\n \tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n+\tsize_t l;\n \n \tif (bn_is_zero(k) || ed_is_infty(p)) {\n \t\ted_mul(r, q, m);\n@@ -398,9 +400,10 @@ void ed_mul_sim_gen(ed_t r, const bn_t k, const ed_t q, const bn_t m) {\n }\n \n void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n-\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n-\ted_t *_p = RLC_ALLOCA(ed_t, n);\n+\tint i, j;\n \tint8_t *naf = NULL;\n+\ted_t *_p = RLC_ALLOCA(ed_t, n);\n+\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n \n \tRLC_TRY {\n \t\tl = 0;"
        },
        {
          "filename": "src/ed/relic_ed_util.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -242,7 +242,7 @@ int ed_size_bin(const ed_t a, int pack) {\n \treturn size;\n }\n \n-void ed_read_bin(ed_t a, const uint8_t *bin, int len) {\n+void ed_read_bin(ed_t a, const uint8_t *bin, size_t len) {\n \tif (len == 1) {\n \t\tif (bin[0] == 0) {\n \t\t\ted_set_infty(a);\n@@ -297,7 +297,7 @@ void ed_read_bin(ed_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void ed_write_bin(uint8_t *bin, int len, const ed_t a, int pack) {\n+void ed_write_bin(uint8_t *bin, size_t len, const ed_t a, int pack) {\n \ted_t t;\n \n \ted_null(t);"
        },
        {
          "filename": "src/ep/relic_ep_map.c",
          "status": "modified",
          "additions": 34,
          "deletions": 28,
          "patch": "@@ -48,25 +48,31 @@\n  * @param[in] coeffs\t- the vector of coefficients in the polynomial.\n  * @param[in] deg \t\t- the degree of the polynomial.\n  */\n-TMPL_MAP_HORNER(fp, fp_st)\n+TMPL_MAP_HORNER(fp, fp_st);\n+\n /**\n  * Generic isogeny map evaluation for use with SSWU map.\n  */\n-\t\tTMPL_MAP_ISOGENY_MAP(ep, fp, iso)\n+TMPL_MAP_ISOGENY_MAP(ep, fp, iso);\n+\n #endif /* EP_CTMAP */\n+\n+#define EP_MAP_COPY_COND(O, I, C) dv_copy_cond(O, I, RLC_FP_DIGS, C)\n /**\n  * Simplified SWU mapping from Section 4 of\n  * \"Fast and simple constant-time hashing to the BLS12-381 Elliptic Curve\"\n  */\n-#define EP_MAP_COPY_COND(O, I, C) dv_copy_cond(O, I, RLC_FP_DIGS, C)\n-\t\tTMPL_MAP_SSWU(ep, fp, dig_t, EP_MAP_COPY_COND)\n+TMPL_MAP_SSWU(ep, fp, dig_t, EP_MAP_COPY_COND);\n+\n /**\n  * Shallue--van de Woestijne map, based on the definition from\n  * draft-irtf-cfrg-hash-to-curve-06, Section 6.6.1\n  */\n-TMPL_MAP_SVDW(ep, fp, dig_t, EP_MAP_COPY_COND)\n+TMPL_MAP_SVDW(ep, fp, dig_t, EP_MAP_COPY_COND);\n+\n #undef EP_MAP_COPY_COND\n-/* caution: this function overwrites k, which it uses as an auxiliary variable */\n+\n+/* caution: this function overwrites k, which used as an auxiliary variable */\n static inline int fp_sgn0(const fp_t t, bn_t k) {\n \tfp_prime_back(k, t);\n \treturn bn_get_bit(k, 0);\n@@ -76,7 +82,7 @@ static inline int fp_sgn0(const fp_t t, bn_t k) {\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {\n+void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len) {\n \tbn_t k;\n \tfp_t t;\n \tep_t q;\n@@ -100,26 +106,26 @@ void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {\n \t\t/* figure out which hash function to use */\n \t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n \t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n-\t\tvoid (*const map_fn)(ep_t, fp_t) =(ep_curve_is_ctmap() ||\n+\t\tvoid (*const map_fn)(ep_t, fp_t) = (ep_curve_is_ctmap() ||\n \t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n \n-#define EP_MAP_CONVERT_BYTES(IDX)                                       \\\n-    do {                                                                \\\n-      bn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);   \\\n-      fp_prime_conv(t, k);                                              \\\n-    } while (0)\n-\n-#define EP_MAP_APPLY_MAP(PT)                                    \\\n-    do {                                                        \\\n-      /* check sign of t */                                     \\\n-      neg = fp_sgn0(t, k);                                      \\\n-      /* convert */                                             \\\n-      map_fn(PT, t);                                            \\\n-      /* compare sign of y and sign of t; fix if necessary */   \\\n-      neg = neg != fp_sgn0(PT->y, k);                             \\\n-      fp_neg(t, PT->y);                                          \\\n-      dv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);                  \\\n-    } while (0)\n+#define EP_MAP_CONVERT_BYTES(IDX)\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tbn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);\t\\\n+\t\t\tfp_prime_conv(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t} while (0)\n+\n+#define EP_MAP_APPLY_MAP(PT)\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t/* check sign of t */\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tneg = fp_sgn0(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t/* convert */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tmap_fn(PT, t);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\t/* compare sign of y and sign of t; fix if necessary */\t\t\t\\\n+\t\t\tneg = neg != fp_sgn0(PT->y, k);\t\t\t\t\t\t\t\t\t\\\n+\t\t\tfp_neg(t, PT->y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tdv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);\t\t\t\t\t\t\\\n+\t\t} while (0)\n \n \t\t/* first map invocation */\n \t\tEP_MAP_CONVERT_BYTES(0);\n@@ -179,8 +185,8 @@ void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {\n \t}\n }\n \n-void ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,\n-\t\tint dst_len) {\n+void ep_map_dst(ep_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len) {\n \n \t/* enough space for two field elements plus extra bytes for uniformity */\n \tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n@@ -202,6 +208,6 @@ void ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,\n \t}\n }\n \n-void ep_map(ep_t p, const uint8_t *msg, int len) {\n+void ep_map(ep_t p, const uint8_t *msg, size_t len) {\n \tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n }"
        },
        {
          "filename": "src/ep/relic_ep_mul.c",
          "status": "modified",
          "additions": 20,
          "deletions": 17,
          "patch": "@@ -40,10 +40,11 @@\n #if defined(EP_ENDOM)\n \n static void ep_mul_glv_imp(ep_t r, const ep_t p, const bn_t k) {\n-\tint l, l0, l1, i, n0, n1, s0, s1;\n+\tint i, n0, n1, s0, s1;\n \tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1;\n \tbn_t n, _k, k0, k1, v1[3], v2[3];\n \tep_t q, t[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tbn_null(n);\n \tbn_null(_k);\n@@ -153,11 +154,11 @@ static void ep_mul_glv_imp(ep_t r, const ep_t p, const bn_t k) {\n #if defined(EP_PLAIN) || defined(EP_SUPER)\n \n static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n-\tint i, l;\n \t/* Some of the supported prime curves have order > field. */\n \tint8_t u, naf[RLC_FP_BITS + 2];\n \tep_t t[1 << (EP_WIDTH - 2)];\n \tbn_t _k, n;\n+\tsize_t l;\n \n \tbn_null(n);\n \tbn_null(_k);\n@@ -166,7 +167,7 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n \t\tbn_new(n);\n \t\tbn_new(_k);\n \t\t/* Prepare the precomputation table. */\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n \t\t\tep_null(t[i]);\n \t\t\tep_new(t[i]);\n \t\t}\n@@ -182,7 +183,7 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n \t\tbn_rec_naf(naf, &l, _k, EP_WIDTH);\n \n \t\tep_set_infty(r);\n-\t\tfor (i = l - 1; i >= 0; i--) {\n+\t\tfor (int i = l - 1; i >= 0; i--) {\n \t\t\tep_dbl(r, r);\n \n \t\t\tu = naf[i];\n@@ -205,7 +206,7 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n \t\tbn_free(n);\n \t\tbn_free(_k);\n \t\t/* Free the precomputation table. */\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n \t\t\tep_free(t[i]);\n \t\t}\n \t}\n@@ -219,10 +220,11 @@ static void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n #if defined(EP_ENDOM)\n \n static void ep_mul_reg_glv(ep_t r, const ep_t p, const bn_t k) {\n-\tint i, j, l, n0, n1, s0, s1, b0, b1;\n+\tint i, j, n0, n1, s0, s1, b0, b1;\n \tint8_t _s0, _s1, reg0[RLC_FP_BITS + 1], reg1[RLC_FP_BITS + 1];\n \tbn_t n, _k, k0, k1, v1[3], v2[3];\n \tep_t q, t[1 << (EP_WIDTH - 2)], u, v, w;\n+\tsize_t l;\n \n \tbn_null(n);\n \tbn_null(_k);\n@@ -371,9 +373,10 @@ static void ep_mul_reg_glv(ep_t r, const ep_t p, const bn_t k) {\n \n static void ep_mul_reg_imp(ep_t r, const ep_t p, const bn_t k) {\n \tbn_t _k;\n-\tint i, j, l, n;\n+\tint i, j, n;\n \tint8_t s, reg[1 + RLC_CEIL(RLC_FP_BITS + 1, EP_WIDTH - 1)];\n \tep_t t[1 << (EP_WIDTH - 2)], u, v;\n+\tsize_t l;\n \n \tif (bn_is_zero(k)) {\n \t\tep_set_infty(r);\n@@ -502,8 +505,8 @@ void ep_mul_basic(ep_t r, const ep_t p, const bn_t k) {\n void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n \tbn_t _k, n;\n \tep_t t[1 << (EP_WIDTH - 1)], q;\n-\tint i, j, l;\n \tuint8_t win[RLC_FP_BITS + 1];\n+\tsize_t l;\n \n \tif (bn_is_zero(k) || ep_is_infty(p)) {\n \t\tep_set_infty(r);\n@@ -517,7 +520,7 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n \tRLC_TRY {\n \t\tbn_new(n);\n \t\tbn_new(_k);\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n \t\t\tep_null(t[i]);\n \t\t\tep_new(t[i]);\n \t\t}\n@@ -534,7 +537,7 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n \t\tbn_mod(_k, k, n);\n \n \t\t/* Create table. */\n-\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\tep_add(t[i], t[i - 1], q);\n \t\t}\n \n@@ -545,11 +548,11 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n \t\tep_set_infty(q);\n \t\tl = RLC_FP_BITS + 1;\n \t\tbn_rec_slw(win, &l, _k, EP_WIDTH);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\tep_dbl(q, q);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\tep_dbl(q, q);\n \t\t\t\t}\n \t\t\t\tep_add(q, q, t[win[i] >> 1]);\n@@ -567,7 +570,7 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n \tRLC_FINALLY {\n \t\tbn_free(n);\n \t\tbn_free(_k);\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\tep_free(t[i]);\n \t\t}\n \t\tep_free(q);\n@@ -579,9 +582,9 @@ void ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n #if EP_MUL == MONTY || !defined(STRIP)\n \n void ep_mul_monty(ep_t r, const ep_t p, const bn_t k) {\n-\tint i, j, bits;\n \tep_t t[2];\n \tbn_t n, l, _k;\n+\tsize_t bits;\n \n \tbn_null(n);\n \tbn_null(l);\n@@ -619,8 +622,8 @@ void ep_mul_monty(ep_t r, const ep_t p, const bn_t k) {\n \t\tep_blind(t[0], t[0]);\n \t\tep_blind(t[1], t[1]);\n \n-\t\tfor (i = bits - 1; i >= 0; i--) {\n-\t\t\tj = bn_get_bit(l, i);\n+\t\tfor (int i = bits - 1; i >= 0; i--) {\n+\t\t\tint j = bn_get_bit(l, i);\n \t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n \t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n \t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n@@ -723,7 +726,7 @@ void ep_mul_dig(ep_t r, const ep_t p, dig_t k) {\n \tep_t t;\n \tbn_t _k;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \tep_null(t);\n \tbn_null(_k);"
        },
        {
          "filename": "src/ep/relic_ep_mul_fix.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -46,8 +46,9 @@\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void ep_mul_fix_plain(ep_t r, const ep_t *t, const bn_t k) {\n-\tint l, i, n;\n+\tint i, n;\n \tint8_t naf[RLC_FP_BITS + 1];\n+\tsize_t l;\n \n \t/* Compute the w-TNAF representation of k. */\n \tl = RLC_FP_BITS + 1;"
        },
        {
          "filename": "src/ep/relic_ep_mul_sim.c",
          "status": "modified",
          "additions": 12,
          "deletions": 7,
          "patch": "@@ -54,14 +54,15 @@\n  */\n static void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n \t\tconst bn_t m, const ep_t *t) {\n-\tint i, l, l0, l1, l2, l3, sk0, sk1, sl0, sl1, w, g = 0;\n+\tint i, sk0, sk1, sl0, sl1, w, g = 0;\n \tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1, u;\n \tint8_t naf2[RLC_FP_BITS + 1], naf3[RLC_FP_BITS + 1], *t2, *t3;\n \tbn_t n, k0, k1, m0, m1;\n \tbn_t v1[3], v2[3];\n \tep_t v;\n \tep_t tab0[1 << (EP_WIDTH - 2)];\n \tep_t tab1[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1, l2, l3;\n \n \tbn_null(n);\n \tbn_null(k0);\n@@ -264,9 +265,10 @@ static void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n  */\n void ep_mul_sim_lot_endom(ep_t r, const ep_t p[], const bn_t k[], int n) {\n \tconst int len = RLC_FP_BITS + 1;\n-\tint i, j, m, l, _l[2], sk;\n+\tint i, j, m, sk;\n \tbn_t _k[2], q, v1[3], v2[3];\n \tint8_t ptr, *naf = RLC_ALLOCA(int8_t, 2 * n * len);\n+\tsize_t l, _l[2];\n \n \tbn_null(q);\n \n@@ -486,10 +488,11 @@ void ep_mul_sim_lot_endom(ep_t r, const ep_t p[], const bn_t k[], int n) {\n  */\n static void ep_mul_sim_plain(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n \t\tconst bn_t m, const ep_t *t) {\n-\tint i, l, l0, l1, w, gen;\n+\tint i, w, gen;\n \tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], n0, n1, *u, *v;\n \tep_t t0[1 << (EP_WIDTH - 2)];\n \tep_t t1[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tRLC_TRY {\n \t\tgen = (t == NULL ? 0 : 1);\n@@ -583,9 +586,10 @@ static void ep_mul_sim_plain(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n  * @param[out] n\t\t\t- the number of elements to multiply.\n  */\n void ep_mul_sim_lot_plain(ep_t r, const ep_t p[], const bn_t k[], int n) {\n-\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n-\tep_t *_p = RLC_ALLOCA(ep_t, n);\n+\tint i, j;\n \tint8_t *naf = NULL;\n+\tep_t *_p = RLC_ALLOCA(ep_t, n);\n+\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n \n \tRLC_TRY {\n \t\tl = 0;\n@@ -677,7 +681,7 @@ void ep_mul_sim_trick(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n \t\tconst bn_t m) {\n \tep_t t0[1 << (EP_WIDTH / 2)], t1[1 << (EP_WIDTH / 2)], t[1 << EP_WIDTH];\n \tbn_t n, _k, _m;\n-\tint l0, l1, w = EP_WIDTH / 2;\n+\tsize_t l0, l1, w = EP_WIDTH / 2;\n \tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n \n \tif (bn_is_zero(k) || ep_is_infty(p)) {\n@@ -838,8 +842,9 @@ void ep_mul_sim_joint(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n \t\tconst bn_t m) {\n \tbn_t n, _k, _m;\n \tep_t t[5];\n-\tint i, l, u_i, offset;\n+\tint i, u_i, offset;\n \tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n+\tsize_t l;\n \n \tif (bn_is_zero(k) || ep_is_infty(p)) {\n \t\tep_mul(r, q, m);"
        },
        {
          "filename": "src/ep/relic_ep_util.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -234,7 +234,7 @@ int ep_size_bin(const ep_t a, int pack) {\n \treturn size;\n }\n \n-void ep_read_bin(ep_t a, const uint8_t *bin, int len) {\n+void ep_read_bin(ep_t a, const uint8_t *bin, size_t len) {\n \tif (len == 1) {\n \t\tif (bin[0] == 0) {\n \t\t\tep_set_infty(a);\n@@ -284,7 +284,7 @@ void ep_read_bin(ep_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void ep_write_bin(uint8_t *bin, int len, const ep_t a, int pack) {\n+void ep_write_bin(uint8_t *bin, size_t len, const ep_t a, int pack) {\n \tep_t t;\n \n \tep_null(t);"
        },
        {
          "filename": "src/epx/relic_ep2_map.c",
          "status": "modified",
          "additions": 96,
          "deletions": 99,
          "patch": "@@ -48,29 +48,25 @@\n  * @param[in] len\t\t\t- the degree of the polynomial.\n  */\n TMPL_MAP_HORNER(fp2, fp2_t)\n-\n /**\n  * Generic isogeny map evaluation for use with SSWU map.\n  */\n TMPL_MAP_ISOGENY_MAP(ep2, fp2, iso2)\n #endif /* EP_CTMAP */\n-\n /**\n  * Simplified SWU mapping.\n  */\n-#define EP2_MAP_COPY_COND(O, I, C)                                                       \\\n-\tdo {                                                                                 \\\n-\t\tdv_copy_cond(O[0], I[0], RLC_FP_DIGS, C);                                        \\\n-\t\tdv_copy_cond(O[1], I[1], RLC_FP_DIGS, C);                                        \\\n+#define EP2_MAP_COPY_COND(O, I, C)\t\t\t\t\t\t\t\t\t\t\t\\\n+\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tdv_copy_cond(O[0], I[0], RLC_FP_DIGS, C);\t\t\t\t\t\t\t\\\n+\t\tdv_copy_cond(O[1], I[1], RLC_FP_DIGS, C);\t\t\t\t\t\t\t\\\n \t} while (0)\n TMPL_MAP_SSWU(ep2, fp2, fp_t, EP2_MAP_COPY_COND)\n-\n /**\n  * Shallue--van de Woestijne map.\n  */\n TMPL_MAP_SVDW(ep2, fp2, fp_t, EP2_MAP_COPY_COND)\n #undef EP2_MAP_COPY_COND\n-\n /* caution: this function overwrites k, which it uses as an auxiliary variable */\n static inline int fp2_sgn0(const fp2_t t, bn_t k) {\n \tconst int t_0_zero = fp_is_zero(t[0]);\n@@ -89,105 +85,106 @@ static inline int fp2_sgn0(const fp2_t t, bn_t k) {\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len) {\n-        bn_t k;\n-        fp2_t t;\n-        ep2_t q;\n-        int neg;\n-        /* enough space for two extension field elements plus extra bytes for uniformity */\n-        const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n-\n-        bn_null(k);\n-        fp2_null(t);\n-        ep2_null(q);\n-\n-        RLC_TRY {\n-                if (len != 2* len_per_elm) {\n-                  RLC_THROW(ERR_NO_VALID);\n-                }\n-\n-                bn_new(k);\n-                fp2_new(t);\n-                ep2_new(q);\n-\n-                /* which hash function should we use? */\n-                const int abNeq0 = (ep2_curve_opt_a() != RLC_ZERO) && (ep2_curve_opt_b() != RLC_ZERO);\n-                void (*const map_fn)(ep2_t, fp2_t) = (ep2_curve_is_ctmap() || abNeq0) ? ep2_map_sswu : ep2_map_svdw;\n-\n-#define EP2_MAP_CONVERT_BYTES(IDX)                                                       \\\n-        do {                                                                                 \\\n-                bn_read_bin(k, uniform_bytes + 2 * IDX * len_per_elm, len_per_elm);        \\\n-                fp_prime_conv(t[0], k);                                                          \\\n-                bn_read_bin(k, uniform_bytes + (2 * IDX + 1) * len_per_elm, len_per_elm);  \\\n-                fp_prime_conv(t[1], k);                                                          \\\n-        } while (0)\n-\n-#define EP2_MAP_APPLY_MAP(PT)                                                            \\\n-        do {                                                                                 \\\n-                /* sign of t */                                                                  \\\n-                neg = fp2_sgn0(t, k);                                                            \\\n-                /* convert */                                                                    \\\n-                map_fn(PT, t);                                                                   \\\n-                /* compare sign of y to sign of t; fix if necessary */                           \\\n-                neg = neg != fp2_sgn0(PT->y, k);                                                 \\\n-                fp2_neg(t, PT->y);                                                               \\\n-                dv_copy_cond(PT->y[0], t[0], RLC_FP_DIGS, neg);                                  \\\n-                dv_copy_cond(PT->y[1], t[1], RLC_FP_DIGS, neg);                                  \\\n-        } while (0)\n-\n-                /* first map invocation */\n-                EP2_MAP_CONVERT_BYTES(0);\n-                EP2_MAP_APPLY_MAP(p);\n-                TMPL_MAP_CALL_ISOMAP(ep2, p);\n-\n-                /* second map invocation */\n-                EP2_MAP_CONVERT_BYTES(1);\n-                EP2_MAP_APPLY_MAP(q);\n-                TMPL_MAP_CALL_ISOMAP(ep2, q);\n-\n-                /* XXX(rsw) could add p and q and then apply isomap,\n-                 * but need ep_add to support addition on isogeny curves */\n+void ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len) {\n+\tbn_t k;\n+\tfp2_t t;\n+\tep2_t q;\n+\tint neg;\n+\t/* enough space for two extension field elements plus extra bytes for uniformity */\n+\tconst int lpe = (FP_PRIME + ep_param_level() + 7) / 8;\n+\n+\tbn_null(k);\n+\tfp2_null(t);\n+\tep2_null(q);\n+\n+\tRLC_TRY {\n+\t\tif (len != 2 * lpe) {\n+\t\t\tRLC_THROW(ERR_NO_VALID);\n+\t\t}\n+\n+\t\tbn_new(k);\n+\t\tfp2_new(t);\n+\t\tep2_new(q);\n+\n+\t\t/* which hash function should we use? */\n+\t\tconst int abNeq0 = (ep2_curve_opt_a() != RLC_ZERO) &&\n+\t\t\t\t(ep2_curve_opt_b() != RLC_ZERO);\n+\t\tvoid (*const map_fn)(ep2_t, fp2_t) = (ep2_curve_is_ctmap() ||\n+\t\t\t\tabNeq0) ? ep2_map_sswu : ep2_map_svdw;\n+\n+#define EP2_MAP_CONVERT_BYTES(IDX)\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tbn_read_bin(k, uniform_bytes + 2 * IDX * lpe, lpe);\t\t\t\t\\\n+\t\t\tfp_prime_conv(t[0], k);\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\t\tbn_read_bin(k, uniform_bytes + (2 * IDX + 1) * lpe, lpe);\t\t\\\n+\t\t\tfp_prime_conv(t[1], k);\t\t\t\t\t\t\t\t\t\t\t\\\n+\t    } while (0)\n+\n+#define EP2_MAP_APPLY_MAP(PT)\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+            /* sign of t */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+            neg = fp2_sgn0(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n+            /* convert */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+            map_fn(PT, t);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+            /* compare sign of y to sign of t; fix if necessary */\t\t\t\\\n+            neg = neg != fp2_sgn0(PT->y, k);\t\t\t\t\t\t\t\t\\\n+            fp2_neg(t, PT->y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n+            dv_copy_cond(PT->y[0], t[0], RLC_FP_DIGS, neg);\t\t\t\t\t\\\n+            dv_copy_cond(PT->y[1], t[1], RLC_FP_DIGS, neg);\t\t\t\t\t\\\n+\t\t} while (0)\n+\n+\t\t/* first map invocation */\n+\t\tEP2_MAP_CONVERT_BYTES(0);\n+\t\tEP2_MAP_APPLY_MAP(p);\n+\t\tTMPL_MAP_CALL_ISOMAP(ep2, p);\n+\n+\t\t/* second map invocation */\n+\t\tEP2_MAP_CONVERT_BYTES(1);\n+\t\tEP2_MAP_APPLY_MAP(q);\n+\t\tTMPL_MAP_CALL_ISOMAP(ep2, q);\n+\n+\t\t/* XXX(rsw) could add p and q and then apply isomap,\n+\t\t * but need ep_add to support addition on isogeny curves */\n \n #undef EP2_MAP_CONVERT_BYTES\n #undef EP2_MAP_APPLY_MAP\n \n-                /* sum the result */\n-                ep2_add(p, p, q);\n-                ep2_norm(p, p);\n-                ep2_mul_cof(p, p);\n-        }\n-        RLC_CATCH_ANY {\n-                RLC_THROW(ERR_CAUGHT);\n-        }\n-        RLC_FINALLY {\n-                bn_free(k);\n-                fp2_free(t);\n-                ep2_free(q);\n-        }\n+\t\t/* sum the result */\n+\t\tep2_add(p, p, q);\n+\t\tep2_norm(p, p);\n+\t\tep2_mul_cof(p, p);\n+\t}\n+\tRLC_CATCH_ANY {\n+\t\tRLC_THROW(ERR_CAUGHT);\n+\t}\n+\tRLC_FINALLY {\n+\t\tbn_free(k);\n+\t\tfp2_free(t);\n+\t\tep2_free(q);\n+\t}\n }\n \n \n-void ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len) {\n-\n-        /* enough space for two field elements plus extra bytes for uniformity */\n-        const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n-        uint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 4 * len_per_elm);\n-\n-        RLC_TRY {\n-\n-                /* XXX(rsw) See note in ep/relic_ep_map.c about using MD_MAP. */\n-                /* hash to a pseudorandom string using md_xmd */\n-                md_xmd(pseudo_random_bytes, 4 * len_per_elm, msg, len, dst, dst_len);\n-                ep2_map_from_field(p, pseudo_random_bytes, 2 * len_per_elm);\n-        }\n-        RLC_CATCH_ANY {\n-                RLC_THROW(ERR_CAUGHT);\n-        }\n-        RLC_FINALLY {\n-                RLC_FREE(pseudo_random_bytes);\n-        }\n+void ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n+\t\tsize_t dst_len) {\n+\t/* enough space for two field elements plus extra bytes for uniformity */\n+\tconst int lpe = (FP_PRIME + ep_param_level() + 7) / 8;\n+\tuint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 4 * lpe);\n+\n+\tRLC_TRY {\n+\t\t/* XXX(rsw) See note in ep/relic_ep_map.c about using MD_MAP. */\n+\t\t/* hash to a pseudorandom string using md_xmd */\n+\t\tmd_xmd(pseudo_random_bytes, 4 * lpe, msg, len, dst, dst_len);\n+\t\tep2_map_from_field(p, pseudo_random_bytes, 2 * lpe);\n+\t}\n+\tRLC_CATCH_ANY {\n+\t\tRLC_THROW(ERR_CAUGHT);\n+\t}\n+\tRLC_FINALLY {\n+\t\tRLC_FREE(pseudo_random_bytes);\n+\t}\n }\n \n-void ep2_map(ep2_t p, const uint8_t *msg, int len) {\n+void ep2_map(ep2_t p, const uint8_t *msg, size_t len) {\n \tep2_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n }"
        },
        {
          "filename": "src/epx/relic_ep2_mul.c",
          "status": "modified",
          "additions": 19,
          "deletions": 19,
          "patch": "@@ -41,7 +41,7 @@\n #if defined(EP_ENDOM)\n \n static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n-\tint i, j, l, _l[4];\n+\tsize_t l, _l[4];\n \tbn_t n, _k[4], u;\n \tint8_t naf[4][RLC_FP_BITS + 1];\n \tep2_t q[4];\n@@ -52,7 +52,7 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n \tRLC_TRY {\n \t\tbn_new(n);\n \t\tbn_new(u);\n-\t\tfor (i = 0; i < 4; i++) {\n+\t\tfor (int i = 0; i < 4; i++) {\n \t\t\tbn_null(_k[i]);\n \t\t\tep2_null(q[i]);\n \t\t\tbn_new(_k[i]);\n@@ -70,7 +70,7 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n \t\tep2_frb(q[3], q[2], 1);\n \n \t\tl = 0;\n-\t\tfor (i = 0; i < 4; i++) {\n+\t\tfor (int i = 0; i < 4; i++) {\n \t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n \t\t\t\tep2_neg(q[i], q[i]);\n \t\t\t}\n@@ -80,10 +80,10 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n \t\t}\n \n \t\tep2_set_infty(r);\n-\t\tfor (j = l - 1; j >= 0; j--) {\n+\t\tfor (int j = l - 1; j >= 0; j--) {\n \t\t\tep2_dbl(r, r);\n \n-\t\t\tfor (i = 0; i < 4; i++) {\n+\t\t\tfor (int i = 0; i < 4; i++) {\n \t\t\t\tif (naf[i][j] > 0) {\n \t\t\t\t\tep2_add(r, r, q[i]);\n \t\t\t\t}\n@@ -102,7 +102,7 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n \tRLC_FINALLY {\n \t\tbn_free(n);\n \t\tbn_free(u);\n-\t\tfor (i = 0; i < 4; i++) {\n+\t\tfor (int i = 0; i < 4; i++) {\n \t\t\tbn_free(_k[i]);\n \t\t\tep2_free(q[i]);\n \t\t}\n@@ -113,13 +113,13 @@ static void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n #endif /* EP_ENDOM */\n \n static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n-\tint l, i, n;\n+\tsize_t l, n;\n \tint8_t naf[RLC_FP_BITS + 1];\n \tep2_t t[1 << (EP_WIDTH - 2)];\n \n \tRLC_TRY {\n \t\t/* Prepare the precomputation table. */\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n \t\t\tep2_null(t[i]);\n \t\t\tep2_new(t[i]);\n \t\t}\n@@ -131,7 +131,7 @@ static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n \t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n \n \t\tep2_set_infty(r);\n-\t\tfor (i = l - 1; i >= 0; i--) {\n+\t\tfor (int i = l - 1; i >= 0; i--) {\n \t\t\tep2_dbl(r, r);\n \n \t\t\tn = naf[i];\n@@ -153,7 +153,7 @@ static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n \t}\n \tRLC_FINALLY {\n \t\t/* Free the precomputation table. */\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n \t\t\tep2_free(t[i]);\n \t\t}\n \t}\n@@ -166,7 +166,7 @@ static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n /*============================================================================*/\n \n void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n-\tint i, l;\n+\tsize_t l;\n \tep2_t t;\n \n \tep2_null(t);\n@@ -186,7 +186,7 @@ void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n \t\t\tep2_set_infty(t);\n \t\t}\n \n-\t\tfor (i = l - 2; i >= 0; i--) {\n+\t\tfor (int i = l - 2; i >= 0; i--) {\n \t\t\tep2_dbl(t, t);\n \t\t\tif (bn_get_bit(k, i)) {\n \t\t\t\tep2_add(t, t, p);\n@@ -211,8 +211,8 @@ void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n \n void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n \tep2_t t[1 << (EP_WIDTH - 1)], q;\n-\tint i, j, l;\n \tuint8_t win[RLC_FP_BITS + 1];\n+\tsize_t l;\n \n \tep2_null(q);\n \n@@ -222,7 +222,7 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n \t}\n \n \tRLC_TRY {\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n+\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n \t\t\tep2_null(t[i]);\n \t\t\tep2_new(t[i]);\n \t\t}\n@@ -237,7 +237,7 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n #endif\n \n \t\t/* Create table. */\n-\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\tep2_add(t[i], t[i - 1], q);\n \t\t}\n \n@@ -248,11 +248,11 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n \t\tep2_set_infty(q);\n \t\tl = RLC_FP_BITS + 1;\n \t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\tep2_dbl(q, q);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\tep2_dbl(q, q);\n \t\t\t\t}\n \t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n@@ -268,7 +268,7 @@ void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n \t\tRLC_THROW(ERR_CAUGHT);\n \t}\n \tRLC_FINALLY {\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\tep2_free(t[i]);\n \t\t}\n \t\tep2_free(q);\n@@ -387,7 +387,7 @@ void ep2_mul_dig(ep2_t r, const ep2_t p, const dig_t k) {\n \tep2_t t;\n \tbn_t _k;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \tep2_null(t);\n \tbn_null(_k);"
        },
        {
          "filename": "src/epx/relic_ep2_mul_fix.c",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -47,8 +47,9 @@\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {\n-\tint len, i, n;\n \tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n+\tsize_t len;\n+\tint n;\n \n \tif (bn_is_zero(k)) {\n \t\tep2_set_infty(r);\n@@ -61,7 +62,7 @@ static void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {\n \n \tt = naf + len - 1;\n \tep2_set_infty(r);\n-\tfor (i = len - 1; i >= 0; i--, t--) {\n+\tfor (int i = len - 1; i >= 0; i--, t--) {\n \t\tep2_dbl(r, r);\n \n \t\tn = *t;"
        },
        {
          "filename": "src/epx/relic_ep2_mul_sim.c",
          "status": "modified",
          "additions": 16,
          "deletions": 13,
          "patch": "@@ -54,7 +54,7 @@\n  */\n static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n \t\tconst bn_t m) {\n-\tint i, j, l, _l[4];\n+\tsize_t l, _l[4];\n \tbn_t _k[4], _m[4], n, u;\n \tint8_t naf0[4][RLC_FP_BITS + 1];\n \tint8_t naf1[4][RLC_FP_BITS + 1];\n@@ -66,7 +66,7 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n \tRLC_TRY {\n \t\tbn_new(n);\n \t\tbn_new(u);\n-\t\tfor (i = 0; i < 4; i++) {\n+\t\tfor (int i = 0; i < 4; i++) {\n \t\t\tbn_null(_k[i]);\n \t\t\tbn_new(_k[i]);\n \t\t\tbn_null(_m[i]);\n@@ -94,7 +94,7 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n \t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n \n \t\tl = 0;\n-\t\tfor (i = 0; i < 4; i++) {\n+\t\tfor (int i = 0; i < 4; i++) {\n \t\t\t_l[i] = RLC_FP_BITS + 1;\n \t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n \t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n@@ -110,9 +110,9 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n \t\t}\n \n \t\tep2_set_infty(r);\n-\t\tfor (i = l - 1; i >= 0; i--) {\n+\t\tfor (int i = l - 1; i >= 0; i--) {\n \t\t\tep2_dbl(r, r);\n-\t\t\tfor (j = 0; j < 4; j++) {\n+\t\t\tfor (int j = 0; j < 4; j++) {\n \t\t\t\tif (naf0[j][i] > 0) {\n \t\t\t\t\tep2_add(r, r, _p[j]);\n \t\t\t\t}\n@@ -135,7 +135,7 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n \t} RLC_FINALLY {\n \t\tbn_free(n);\n \t\tbn_free(u);\n-\t\tfor (i = 0; i < 4; i++) {\n+\t\tfor (int i = 0; i < 4; i++) {\n \t\t\tbn_free(_k[i]);\n \t\t\tbn_free(_m[i]);\n \t\t\tep2_free(_p[i]);\n@@ -162,10 +162,11 @@ static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n  */\n static void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n \t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n-\tint i, l, l0, l1, n0, n1, w, gen;\n+\tint i, n0, n1, w, gen;\n \tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n \tep2_t t0[1 << (EP_WIDTH - 2)];\n \tep2_t t1[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tRLC_TRY {\n \t\tgen = (t == NULL ? 0 : 1);\n@@ -289,7 +290,7 @@ void ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n \tep2_t t1[1 << (EP_WIDTH / 2)];\n \tep2_t t[1 << EP_WIDTH];\n \tbn_t n, _k, _m;\n-\tint l0, l1, w = EP_WIDTH / 2;\n+\tsize_t l0, l1, w = EP_WIDTH / 2;\n \tuint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];\n \n \tbn_null(n);\n@@ -451,8 +452,9 @@ void ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n \t\tconst bn_t m) {\n \tbn_t n, _k, _m;\n \tep2_t t[5];\n-\tint i, l, u_i, offset;\n+\tint i, u_i, offset;\n \tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n+\tsize_t l;\n \n \tif (bn_is_zero(k) || ep2_is_infty(p)) {\n \t\tep2_mul(r, q, m);\n@@ -601,7 +603,7 @@ void ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m) {\n \t}\n }\n \n-void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len) {\n+void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len) {\n \tep2_t t;\n \tint max;\n \n@@ -635,11 +637,12 @@ void ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len) {\n \t}\n }\n \n-void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n) {\n-\tconst int len = RLC_FP_BITS + 1;\n-\tint i, j, m, l, _l[4];\n+void ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n) {\n+\tconst size_t len = RLC_FP_BITS + 1;\n+\tint i, j, m;\n \tbn_t _k[4], q, x;\n \tint8_t ptr, *naf = RLC_ALLOCA(int8_t, 4 * n * len);\n+\tsize_t l, _l[4];\n \n \tif (n == 0) {\n \t\tep2_set_infty(r);"
        },
        {
          "filename": "src/epx/relic_ep2_util.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -243,7 +243,7 @@ int ep2_size_bin(const ep2_t a, int pack) {\n \treturn size;\n }\n \n-void ep2_read_bin(ep2_t a, const uint8_t *bin, int len) {\n+void ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len) {\n \tif (len == 1) {\n \t\tif (bin[0] == 0) {\n \t\t\tep2_set_infty(a);\n@@ -293,7 +293,7 @@ void ep2_read_bin(ep2_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack) {\n+void ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack) {\n \tep2_t t;\n \n \tep2_null(t);"
        },
        {
          "filename": "src/epx/relic_ep4_map.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -37,7 +37,7 @@\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void ep4_map(ep4_t p, const uint8_t *msg, int len) {\n+void ep4_map(ep4_t p, const uint8_t *msg, size_t len) {\n \tbn_t x;\n \tfp4_t t0;\n \tuint8_t digest[RLC_MD_LEN];"
        },
        {
          "filename": "src/epx/relic_ep4_mul.c",
          "status": "modified",
          "additions": 10,
          "deletions": 8,
          "patch": "@@ -41,10 +41,11 @@\n #if defined(EP_ENDOM)\n \n static void ep4_mul_glv_imp(ep4_t r, const ep4_t p, const bn_t k) {\n-\tint sign, i, j, l, _l[8];\n+\tint sign, i, j;\n \tbn_t n, _k[8], u, v;\n \tint8_t naf[8][RLC_FP_BITS + 1];\n \tep4_t q[8];\n+\tsize_t l, _l[8];\n \n \tbn_null(n);\n \tbn_null(u);\n@@ -131,9 +132,10 @@ static void ep4_mul_glv_imp(ep4_t r, const ep4_t p, const bn_t k) {\n #endif /* EP_ENDOM */\n \n static void ep4_mul_naf_imp(ep4_t r, const ep4_t p, const bn_t k) {\n-\tint l, i, n;\n+\tint i, n;\n \tint8_t naf[RLC_FP_BITS + 1];\n \tep4_t t[1 << (EP_WIDTH - 2)];\n+\tsize_t l;\n \n \tRLC_TRY {\n \t\t/* Prepare the precomputation table. */\n@@ -229,8 +231,8 @@ void ep4_mul_basic(ep4_t r, const ep4_t p, const bn_t k) {\n \n void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n \tep4_t t[1 << (EP_WIDTH - 1)], q;\n-\tint i, j, l;\n \tuint8_t win[RLC_FP_BITS + 1];\n+\tsize_t l;\n \n \tep4_null(q);\n \n@@ -240,7 +242,7 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n \t}\n \n \tRLC_TRY {\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n \t\t\tep4_null(t[i]);\n \t\t\tep4_new(t[i]);\n \t\t}\n@@ -255,7 +257,7 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n #endif\n \n \t\t/* Create table. */\n-\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\tep4_add(t[i], t[i - 1], q);\n \t\t}\n \n@@ -266,11 +268,11 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n \t\tep4_set_infty(q);\n \t\tl = RLC_FP_BITS + 1;\n \t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\tep4_dbl(q, q);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\tep4_dbl(q, q);\n \t\t\t\t}\n \t\t\t\tep4_add(q, q, t[win[i] >> 1]);\n@@ -286,7 +288,7 @@ void ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n \t\tRLC_THROW(ERR_CAUGHT);\n \t}\n \tRLC_FINALLY {\n-\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n \t\t\tep4_free(t[i]);\n \t\t}\n \t\tep4_free(q);"
        },
        {
          "filename": "src/epx/relic_ep4_mul_fix.c",
          "status": "modified",
          "additions": 5,
          "deletions": 6,
          "patch": "@@ -45,21 +45,19 @@\n  * @param[in] p\t\t\t\t\t- the point to multiply.\n  */\n static void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {\n-\tint i;\n-\n \tep4_dbl(t[0], p);\n #if defined(EP_MIXED)\n \tep4_norm(t[0], t[0]);\n #endif\n \n #if EP_DEPTH > 2\n \tep4_add(t[1], t[0], p);\n-\tfor (i = 2; i < (1 << (EP_DEPTH - 2)); i++) {\n+\tfor (int i = 2; i < (1 << (EP_DEPTH - 2)); i++) {\n \t\tep4_add(t[i], t[i - 1], t[0]);\n \t}\n \n #if defined(EP_MIXED)\n-\tfor (i = 1; i < (1 << (EP_DEPTH - 2)); i++) {\n+\tfor (int i = 1; i < (1 << (EP_DEPTH - 2)); i++) {\n \t\tep4_norm(t[i], t[i]);\n \t}\n #endif\n@@ -77,8 +75,9 @@ static void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {\n  * @param[in] k\t\t\t\t\t- the integer.\n  */\n static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n-\tint len, i, n;\n \tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n+\tsize_t len;\n+\tint n;\n \n \tif (bn_is_zero(k)) {\n \t\tep4_set_infty(r);\n@@ -91,7 +90,7 @@ static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n \n \tt = naf + len - 1;\n \tep4_set_infty(r);\n-\tfor (i = len - 1; i >= 0; i--, t--) {\n+\tfor (int i = len - 1; i >= 0; i--, t--) {\n \t\tep4_dbl(r, r);\n \n \t\tn = *t;"
        },
        {
          "filename": "src/epx/relic_ep4_mul_sim.c",
          "status": "modified",
          "additions": 10,
          "deletions": 7,
          "patch": "@@ -52,10 +52,11 @@\n  */\n static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n \t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n-\tint i, l, l0, l1, n0, n1, w, gen;\n+\tint i, n0, n1, w, gen;\n \tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n \tep4_t t0[1 << (EP_WIDTH - 2)];\n \tep4_t t1[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tRLC_TRY {\n \t\tgen = (t == NULL ? 0 : 1);\n@@ -177,7 +178,7 @@ void ep4_mul_sim_trick(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n \tep4_t t1[1 << (EP_WIDTH / 2)];\n \tep4_t t[1 << EP_WIDTH];\n \tbn_t n;\n-\tint l0, l1, w = EP_WIDTH / 2;\n+\tsize_t l0, l1, w = EP_WIDTH / 2;\n \tuint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];\n \n \tbn_null(n);\n@@ -293,8 +294,9 @@ void ep4_mul_sim_inter(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n void ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n \t\tconst bn_t m) {\n \tep4_t t[5];\n-\tint i, l, u_i, offset;\n+\tint i, u_i, offset;\n \tint8_t jsf[4 * (RLC_FP_BITS + 1)];\n+\tsize_t l;\n \n \tif (bn_is_zero(k) || ep4_is_infty(p)) {\n \t\tep4_mul(r, q, m);\n@@ -396,7 +398,7 @@ void ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m) {\n \t}\n }\n \n-void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len) {\n+void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len) {\n \tep4_t t;\n \tint max;\n \n@@ -430,11 +432,12 @@ void ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len) {\n \t}\n }\n \n-void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n) {\n-\tconst int len = RLC_FP_BITS + 1;\n-\tint i, j, m, l, *_l = RLC_ALLOCA(int, 8 * n);\n+void ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n) {\n+\tconst size_t len = RLC_FP_BITS + 1;\n+\tint i, j, m;\n \tbn_t _k[8], q, x;\n \tint8_t *naf = RLC_ALLOCA(int8_t, 8 * n * len);\n+\tsize_t l, *_l = RLC_ALLOCA(size_t, 8 * n);\n \n \tbn_null(q);\n \tbn_null(x);"
        },
        {
          "filename": "src/epx/relic_ep4_util.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -254,7 +254,7 @@ int ep4_size_bin(const ep4_t a, int pack) {\n \treturn size;\n }\n \n-void ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {\n+void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len) {\n \tif (len == 1) {\n \t\tif (bin[0] == 0) {\n \t\t\tep4_set_infty(a);\n@@ -288,7 +288,7 @@ void ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack) {\n+void ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack) {\n \tep4_t t;\n \n \tep4_null(t);"
        },
        {
          "filename": "src/fb/relic_fb_exp.c",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -44,7 +44,7 @@\n #if FB_EXP == BASIC || !defined(STRIP)\n \n void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n-\tint i, l;\n+\tsize_t l;\n \tfb_t r;\n \n \tif (bn_is_zero(b)) {\n@@ -61,7 +61,7 @@ void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n \n \t\tfb_copy(r, a);\n \n-\t\tfor (i = l - 2; i >= 0; i--) {\n+\t\tfor (int i = l - 2; i >= 0; i--) {\n \t\t\tfb_sqr(r, r);\n \t\t\tif (bn_get_bit(b, i)) {\n \t\t\t\tfb_mul(r, r, a);\n@@ -88,8 +88,8 @@ void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n \n void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {\n \tfb_t t[1 << (FB_WIDTH - 1)], r;\n-\tint i, j, l;\n \tuint8_t win[RLC_FB_BITS + 1];\n+\tsize_t l;\n \n \tfb_null(r);\n \n@@ -100,12 +100,12 @@ void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {\n \n \n \t/* Initialize table. */\n-\tfor (i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n+\tfor (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n \t\tfb_null(t[i]);\n \t}\n \n \tRLC_TRY {\n-\t\tfor (i = 0; i < (1 << (FB_WIDTH - 1)); i ++) {\n+\t\tfor (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i ++) {\n \t\t\tfb_new(t[i]);\n \t\t}\n \t\tfb_new(r);\n@@ -114,18 +114,18 @@ void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {\n \t\tfb_sqr(r, a);\n \n \t\t/* Create table. */\n-\t\tfor (i = 1; i < 1 << (FB_WIDTH - 1); i++) {\n+\t\tfor (size_t i = 1; i < 1 << (FB_WIDTH - 1); i++) {\n \t\t\tfb_mul(t[i], t[i - 1], r);\n \t\t}\n \n \t\tfb_set_dig(r, 1);\n \t\tl = RLC_FB_BITS + 1;\n \t\tbn_rec_slw(win, &l, b, FB_WIDTH);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\tfb_sqr(r, r);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\tfb_sqr(r, r);\n \t\t\t\t}\n \t\t\t\tfb_mul(r, r, t[win[i] >> 1]);\n@@ -142,7 +142,7 @@ void fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {\n \t\tRLC_THROW(ERR_CAUGHT);\n \t}\n \tRLC_FINALLY {\n-\t\tfor (i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n \t\t\tfb_free(t[i]);\n \t\t}\n \t\tfb_free(r);"
        },
        {
          "filename": "src/fb/relic_fb_util.c",
          "status": "modified",
          "additions": 13,
          "deletions": 15,
          "patch": "@@ -45,7 +45,7 @@\n  * @param[in] radix\t\t\t\t- the radix to check.\n  * @return if radix is a valid radix.\n  */\n-static int valid_radix(int radix) {\n+static int valid_radix(unsigned int radix) {\n \twhile (radix > 0) {\n \t\tif (radix != 1 && radix % 2 == 1)\n \t\t\treturn 0;\n@@ -60,7 +60,7 @@ static int valid_radix(int radix) {\n  * @param[in] radix\t\t\t\t- the valid radix.\n  * @return the logarithm of the radix in basis two.\n  */\n-static int log_radix(int radix) {\n+static int log_radix(unsigned int radix) {\n \tint l = 0;\n \n \twhile (radix > 0) {\n@@ -93,15 +93,15 @@ int fb_is_zero(const fb_t a) {\n \treturn !t;\n }\n \n-int fb_get_bit(const fb_t a, int bit) {\n+int fb_get_bit(const fb_t a, size_t bit) {\n \tint d;\n \n \tRLC_RIP(bit, d, bit);\n \n \treturn (a[d] >> bit) & 1;\n }\n \n-void fb_set_bit(fb_t a, int bit, int value) {\n+void fb_set_bit(fb_t a, size_t bit, int value) {\n \tint d;\n \tdig_t mask;\n \n@@ -116,7 +116,7 @@ void fb_set_bit(fb_t a, int bit, int value) {\n \t}\n }\n \n-int fb_bits(const fb_t a) {\n+size_t fb_bits(const fb_t a) {\n \tint i = RLC_FB_DIGS - 1;\n \n \twhile (i >= 0 && a[i] == 0) {\n@@ -136,7 +136,7 @@ void fb_set_dig(fb_t c, dig_t a) {\n }\n \n void fb_rand(fb_t a) {\n-\tint bits, digits;\n+\tsize_t bits, digits;\n \n \trand_bytes((uint8_t *)a, RLC_FB_DIGS * sizeof(dig_t));\n \n@@ -148,21 +148,19 @@ void fb_rand(fb_t a) {\n }\n \n void fb_print(const fb_t a) {\n-\tint i;\n-\n \t/* Suppress possible unused parameter warning. */\n \t(void)a;\n-\tfor (i = RLC_FB_DIGS - 1; i > 0; i--) {\n+\tfor (int i = RLC_FB_DIGS - 1; i > 0; i--) {\n \t\tutil_print_dig(a[i], 1);\n \t\tutil_print(\" \");\n \t}\n \tutil_print_dig(a[0], 1);\n \tutil_print(\"\\n\");\n }\n \n-int fb_size_str(const fb_t a, int radix) {\n+size_t fb_size_str(const fb_t a, unsigned int radix) {\n \tbn_t t;\n-\tint digits = 0;\n+\tsize_t digits = 0;\n \n \tbn_null(t);\n \n@@ -188,7 +186,7 @@ int fb_size_str(const fb_t a, int radix) {\n \treturn digits;\n }\n \n-void fb_read_str(fb_t a, const char *str, int len, int radix) {\n+void fb_read_str(fb_t a, const char *str, size_t len, unsigned int radix) {\n \tbn_t t;\n \n \tbn_null(t);\n@@ -217,7 +215,7 @@ void fb_read_str(fb_t a, const char *str, int len, int radix) {\n \t}\n }\n \n-void fb_write_str(char *str, int len, const fb_t a, int radix) {\n+void fb_write_str(char *str, size_t len, const fb_t a, unsigned int radix) {\n \tfb_t t;\n \tint d, l, i, j;\n \tchar c;\n@@ -276,7 +274,7 @@ void fb_write_str(char *str, int len, const fb_t a, int radix) {\n \t}\n }\n \n-void fb_read_bin(fb_t a, const uint8_t *bin, int len) {\n+void fb_read_bin(fb_t a, const uint8_t *bin, size_t len) {\n \tbn_t t;\n \n \tbn_null(t);\n@@ -301,7 +299,7 @@ void fb_read_bin(fb_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fb_write_bin(uint8_t *bin, int len, const fb_t a) {\n+void fb_write_bin(uint8_t *bin, size_t len, const fb_t a) {\n \tbn_t t;\n \n \tbn_null(t);"
        },
        {
          "filename": "src/fp/relic_fp_exp.c",
          "status": "modified",
          "additions": 9,
          "deletions": 9,
          "patch": "@@ -39,7 +39,7 @@\n #if FP_EXP == BASIC || !defined(STRIP)\n \n void fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {\n-\tint i, l;\n+\tsize_t l;\n \tfp_t r;\n \n \tfp_null(r);\n@@ -56,7 +56,7 @@ void fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {\n \n \t\tfp_copy(r, a);\n \n-\t\tfor (i = l - 2; i >= 0; i--) {\n+\t\tfor (int i = l - 2; i >= 0; i--) {\n \t\t\tfp_sqr(r, r);\n \t\t\tif (bn_get_bit(b, i)) {\n \t\t\t\tfp_mul(r, r, a);\n@@ -83,8 +83,8 @@ void fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {\n \n void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {\n \tfp_t t[1 << (FP_WIDTH - 1)], r;\n-\tint i, j, l;\n \tuint8_t win[RLC_FP_BITS + 1];\n+\tsize_t l;\n \n \tfp_null(r);\n \n@@ -95,12 +95,12 @@ void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {\n \n \n \t/* Initialize table. */\n-\tfor (i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n+\tfor (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n \t\tfp_null(t[i]);\n \t}\n \n \tRLC_TRY {\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 1)); i ++) {\n+\t\tfor (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i ++) {\n \t\t\tfp_new(t[i]);\n \t\t}\n \t\tfp_new(r);\n@@ -109,18 +109,18 @@ void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {\n \t\tfp_sqr(r, a);\n \n \t\t/* Create table. */\n-\t\tfor (i = 1; i < 1 << (FP_WIDTH - 1); i++) {\n+\t\tfor (size_t i = 1; i < 1 << (FP_WIDTH - 1); i++) {\n \t\t\tfp_mul(t[i], t[i - 1], r);\n \t\t}\n \n \t\tfp_set_dig(r, 1);\n \t\tl = RLC_FP_BITS + 1;\n \t\tbn_rec_slw(win, &l, b, FP_WIDTH);\n-\t\tfor (i = 0; i < l; i++) {\n+\t\tfor (size_t i = 0; i < l; i++) {\n \t\t\tif (win[i] == 0) {\n \t\t\t\tfp_sqr(r, r);\n \t\t\t} else {\n-\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n+\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n \t\t\t\t\tfp_sqr(r, r);\n \t\t\t\t}\n \t\t\t\tfp_mul(r, r, t[win[i] >> 1]);\n@@ -137,7 +137,7 @@ void fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {\n \t\tRLC_THROW(ERR_CAUGHT);\n \t}\n \tRLC_FINALLY {\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n+\t\tfor (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n \t\t\tfp_free(t[i]);\n \t\t}\n \t\tfp_free(r);"
        },
        {
          "filename": "src/fp/relic_fp_prime.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -296,7 +296,7 @@ void fp_prime_set_dense(const bn_t p) {\n void fp_prime_set_pairf(const bn_t x, int pairf) {\n \tbn_t p, t0, t1;\n \tctx_t *ctx = core_get();\n-\tint len = bn_bits(x) + 1;\n+\tsize_t len = bn_bits(x) + 1;\n \tint8_t s[RLC_FP_BITS + 1];\n \n \tbn_null(p);\n@@ -459,7 +459,7 @@ void fp_prime_set_pairf(const bn_t x, int pairf) {\n \t}\n }\n \n-void fp_prime_set_pmers(const int *f, int len) {\n+void fp_prime_set_pmers(const int *f, size_t len) {\n \tbn_t p, t;\n \n \tbn_null(p);"
        },
        {
          "filename": "src/fp/relic_fp_util.c",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -62,15 +62,15 @@ int fp_is_even(const fp_t a) {\n \treturn 0;\n }\n \n-int fp_get_bit(const fp_t a, int bit) {\n+int fp_get_bit(const fp_t a, size_t bit) {\n \tint d;\n \n \tRLC_RIP(bit, d, bit);\n \n \treturn (a[d] >> bit) & 1;\n }\n \n-void fp_set_bit(fp_t a, int bit, int value) {\n+void fp_set_bit(fp_t a, size_t bit, int value) {\n \tint d;\n \tdig_t mask;\n \n@@ -85,7 +85,7 @@ void fp_set_bit(fp_t a, int bit, int value) {\n \t}\n }\n \n-int fp_bits(const fp_t a) {\n+size_t fp_bits(const fp_t a) {\n \tint i = RLC_FP_DIGS - 1;\n \n \twhile (i >= 0 && a[i] == 0) {\n@@ -157,9 +157,9 @@ void fp_print(const fp_t a) {\n \t}\n }\n \n-int fp_size_str(const fp_t a, int radix) {\n+size_t fp_size_str(const fp_t a, unsigned int radix) {\n \tbn_t t;\n-\tint digits = 0;\n+\tsize_t digits = 0;\n \n \tbn_null(t);\n \n@@ -179,7 +179,7 @@ int fp_size_str(const fp_t a, int radix) {\n \treturn digits;\n }\n \n-void fp_read_str(fp_t a, const char *str, int len, int radix) {\n+void fp_read_str(fp_t a, const char *str, size_t len, unsigned int radix) {\n \tbn_t t;\n \n \tbn_null(t);\n@@ -208,7 +208,7 @@ void fp_read_str(fp_t a, const char *str, int len, int radix) {\n \t}\n }\n \n-void fp_write_str(char *str, int len, const fp_t a, int radix) {\n+void fp_write_str(char *str, size_t len, const fp_t a, unsigned int radix) {\n \tbn_t t;\n \n \tbn_null(t);\n@@ -227,7 +227,7 @@ void fp_write_str(char *str, int len, const fp_t a, int radix) {\n \t}\n }\n \n-void fp_read_bin(fp_t a, const uint8_t *bin, int len) {\n+void fp_read_bin(fp_t a, const uint8_t *bin, size_t len) {\n \tbn_t t;\n \n \tbn_null(t);\n@@ -253,7 +253,7 @@ void fp_read_bin(fp_t a, const uint8_t *bin, int len) {\n \t\t\t\t} else {\n \t\t\t\t\tfp_prime_conv(a, t);\n \t\t\t\t}\n-\t\t\t}\t\n+\t\t\t}\n \t\t}\n \t}\n \tRLC_CATCH_ANY {\n@@ -264,7 +264,7 @@ void fp_read_bin(fp_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fp_write_bin(uint8_t *bin, int len, const fp_t a) {\n+void fp_write_bin(uint8_t *bin, size_t len, const fp_t a) {\n \tbn_t t;\n \n \tbn_null(t);"
        },
        {
          "filename": "src/fpx/relic_fpx_cyc.c",
          "status": "modified",
          "additions": 59,
          "deletions": 53,
          "patch": "@@ -83,8 +83,8 @@ int fp2_test_cyc(const fp2_t a) {\n \n void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {\n \tfp2_t r, s, t[1 << (FP_WIDTH - 2)];\n-\tint i, l;\n \tint8_t naf[RLC_FP_BITS + 1], *k;\n+\tsize_t l;\n \n \tif (bn_is_zero(b)) {\n \t\treturn fp2_set_dig(c, 1);\n@@ -96,7 +96,7 @@ void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {\n \tRLC_TRY {\n \t\tfp2_new(r);\n \t\tfp2_new(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n \t\t\tfp2_null(t[i]);\n \t\t\tfp2_new(t[i]);\n \t\t}\n@@ -116,7 +116,7 @@ void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {\n \n \t\tk = naf + l - 1;\n \n-\t\tfor (i = l - 1; i >= 0; i--, k--) {\n+\t\tfor (int i = l - 1; i >= 0; i--, k--) {\n \t\t\tfp2_sqr(r, r);\n \n \t\t\tif (*k > 0) {\n@@ -140,7 +140,7 @@ void fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {\n \tRLC_FINALLY {\n \t\tfp2_free(r);\n \t\tfp2_free(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n \t\t\tfp2_free(t[i]);\n \t\t}\n \t}\n@@ -193,8 +193,8 @@ int fp8_test_cyc(const fp8_t a) {\n \n void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {\n \tfp8_t r, s, t[1 << (FP_WIDTH - 2)];\n-\tint i, l;\n \tint8_t naf[RLC_FP_BITS + 1], *k;\n+\tsize_t l;\n \n \tif (bn_is_zero(b)) {\n \t\treturn fp8_set_dig(c, 1);\n@@ -206,7 +206,7 @@ void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {\n \tRLC_TRY {\n \t\tfp8_new(r);\n \t\tfp8_new(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n \t\t\tfp8_null(t[i]);\n \t\t\tfp8_new(t[i]);\n \t\t}\n@@ -226,7 +226,7 @@ void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {\n \n \t\tk = naf + l - 1;\n \n-\t\tfor (i = l - 1; i >= 0; i--, k--) {\n+\t\tfor (int i = l - 1; i >= 0; i--, k--) {\n \t\t\tfp8_sqr_cyc(r, r);\n \n \t\t\tif (*k > 0) {\n@@ -250,7 +250,7 @@ void fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {\n \tRLC_FINALLY {\n \t\tfp8_free(r);\n \t\tfp8_free(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n \t\t\tfp8_free(t[i]);\n \t\t}\n \t}\n@@ -470,14 +470,14 @@ void fp12_back_cyc_sim(fp12_t c[], const fp12_t a[], int n) {\n }\n \n void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n-\tint i, j, k, l, w = bn_ham(b);\n+\tsize_t j, k, l, w = bn_ham(b);\n \n \tif (bn_is_zero(b)) {\n \t\treturn fp12_set_dig(c, 1);\n \t}\n \n \tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n-\t\tint _l[4];\n+\t\tsize_t _l[4];\n \t\tint8_t naf[4][RLC_FP_BITS + 1];\n \t\tfp12_t t[4];\n \t\tbn_t _b[4], n, u;\n@@ -488,7 +488,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\tRLC_TRY {\n \t\t\tbn_new(n);\n \t\t\tbn_new(u);\n-\t\t\tfor (i = 0; i < 4; i++) {\n+\t\t\tfor (int i = 0; i < 4; i++) {\n \t\t\t\tbn_null(_b[i]);\n \t\t\t\tbn_new(_b[i]);\n \t\t\t\tfp12_null(t[i]);\n@@ -506,7 +506,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\t\t\tfp12_frb(t[3], t[2], 1);\n \n \t\t\t\tl = 0;\n-\t\t\t\tfor (i = 0; i < 4; i++) {\n+\t\t\t\tfor (int i = 0; i < 4; i++) {\n \t\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n \t\t\t\t\t\tfp12_inv_cyc(t[i], t[i]);\n \t\t\t\t\t}\n@@ -516,9 +516,9 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\t\t\t}\n \n \t\t\t\tfp12_set_dig(c, 1);\n-\t\t\t\tfor (i = l - 1; i >= 0; i--) {\n+\t\t\t\tfor (int i = l - 1; i >= 0; i--) {\n \t\t\t\t\tfp12_sqr_cyc(c, c);\n-\t\t\t\t\tfor (j = 0; j < 4; j++) {\n+\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n \t\t\t\t\t\tif (naf[j][i] > 0) {\n \t\t\t\t\t\t\tfp12_mul(c, c, t[j]);\n \t\t\t\t\t\t}\n@@ -532,7 +532,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\t\t} else {\n \t\t\t\tfp12_copy(t[0], a);\n \n-\t\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n+\t\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n \t\t\t\t\tfp12_sqr_cyc(t[0], t[0]);\n \t\t\t\t\tif (bn_get_bit(b, i)) {\n \t\t\t\t\t\tfp12_mul(t[0], t[0], a);\n@@ -551,7 +551,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\tRLC_FINALLY {\n \t\t\tbn_free(n);\n \t\t\tbn_free(u);\n-\t\t\tfor (i = 0; i < 4; i++) {\n+\t\t\tfor (int i = 0; i < 4; i++) {\n \t\t\t\tbn_free(_b[i]);\n \t\t\t\tfp12_free(t[i]);\n \t\t\t}\n@@ -565,15 +565,15 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\t\tif (u == NULL) {\n \t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n \t\t\t}\n-\t\t\tfor (i = 0; i < w; i++) {\n+\t\t\tfor (int i = 0; i < w; i++) {\n \t\t\t\tfp12_null(u[i]);\n \t\t\t\tfp12_new(u[i]);\n \t\t\t}\n \t\t\tfp12_new(t);\n \n \t\t\tj = 0;\n \t\t\tfp12_copy(t, a);\n-\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n+\t\t\tfor (size_t i = 1; i < bn_bits(b); i++) {\n \t\t\t\tfp12_sqr_pck(t, t);\n \t\t\t\tif (bn_get_bit(b, i)) {\n \t\t\t\t\tfp12_copy(u[j++], t);\n@@ -596,7 +596,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\t\t\tfp12_copy(c, u[0]);\n \t\t\t}\n \n-\t\t\tfor (i = j; i < k; i++) {\n+\t\t\tfor (size_t i = j; i < k; i++) {\n \t\t\t\tfp12_mul(c, c, u[i]);\n \t\t\t}\n \n@@ -608,7 +608,7 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n \t\t\tRLC_THROW(ERR_CAUGHT);\n \t\t}\n \t\tRLC_FINALLY {\n-\t\t\tfor (i = 0; i < w; i++) {\n+\t\t\tfor (size_t i = 0; i < w; i++) {\n \t\t\t\tfp12_free(u[i]);\n \t\t\t}\n \t\t\tfp12_free(t);\n@@ -618,10 +618,11 @@ void fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n }\n \n void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d) {\n-\tint i, l, n0, n1, l0, l1;\n+\tint n0, n1;\n \tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n \tfp2_t r, t0[1 << (EP_WIDTH - 2)];\n \tfp2_t s, t1[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tif (bn_is_zero(b)) {\n \t\treturn fp2_exp_cyc(e, c, d);\n@@ -637,7 +638,7 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const\n \tRLC_TRY {\n \t\tfp2_new(r);\n \t\tfp2_new(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n \t\t\tfp2_null(t0[i]);\n \t\t\tfp2_null(t1[i]);\n \t\t\tfp2_new(t0[i]);\n@@ -666,12 +667,12 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const\n \n \t\tl = RLC_MAX(l0, l1);\n \t\tif (bn_sign(b) == RLC_NEG) {\n-\t\t\tfor (i = 0; i < l0; i++) {\n+\t\t\tfor (size_t i = 0; i < l0; i++) {\n \t\t\t\tnaf0[i] = -naf0[i];\n \t\t\t}\n \t\t}\n \t\tif (bn_sign(d) == RLC_NEG) {\n-\t\t\tfor (i = 0; i < l1; i++) {\n+\t\t\tfor (size_t i = 0; i < l1; i++) {\n \t\t\t\tnaf1[i] = -naf1[i];\n \t\t\t}\n \t\t}\n@@ -680,7 +681,7 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const\n \t\t_m = naf1 + l - 1;\n \n \t\tfp2_set_dig(r, 1);\n-\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n+\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n \t\t\tfp2_sqr(r, r);\n \n \t\t\tn0 = *_k;\n@@ -710,7 +711,7 @@ void fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const\n \tRLC_FINALLY {\n \t\tfp2_free(r);\n \t\tfp2_free(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n \t\t\tfp2_free(t0[i]);\n \t\t\tfp2_free(t1[i]);\n \t\t}\n@@ -820,8 +821,9 @@ void fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, co\n \t}\n }\n \n-void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, int len, int sign) {\n-\tint i, j, k, w = len;\n+void fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, size_t len,\n+\t\tint sign) {\n+\tsize_t i, j, k, w = len;\n     fp12_t t, *u = RLC_ALLOCA(fp12_t, w);\n \n \tif (len == 0) {\n@@ -1097,15 +1099,15 @@ void fp24_back_cyc_sim(fp24_t c[], const fp24_t a[], int n) {\n }\n \n void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n-\tint i, j, k, w = bn_ham(b);\n+\tsize_t j, k, w = bn_ham(b);\n \n \tif (bn_is_zero(b)) {\n \t\tfp24_set_dig(c, 1);\n \t\treturn;\n \t}\n \n \tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n-\t\tint l, _l[8];\n+\t\tsize_t l, _l[8];\n \t\tint8_t naf[8][RLC_FP_BITS + 1];\n \t\tfp24_t t[8];\n \t\tbn_t _b[8], n, x;\n@@ -1116,7 +1118,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\tRLC_TRY {\n \t\t\tbn_new(n);\n \t\t\tbn_new(x);\n-\t\t\tfor (i = 0; i < 8; i++) {\n+\t\t\tfor (int i = 0; i < 8; i++) {\n \t\t\t\tbn_null(_b[i]);\n \t\t\t\tbn_new(_b[i]);\n \t\t\t\tfp24_null(t[i]);\n@@ -1131,7 +1133,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\t\t\tl = 0;\n \n \t\t\t\tfp24_copy(t[0], a);\n-\t\t\t\tfor (i = 0; i < 8; i++) {\n+\t\t\t\tfor (int i = 0; i < 8; i++) {\n \t\t\t\t\t_l[i] = RLC_FP_BITS + 1;\n \t\t\t\t\tbn_rec_naf(naf[i], &_l[i], _b[i], 2);\n \t\t\t\t\tl = RLC_MAX(l, _l[i]);\n@@ -1140,16 +1142,16 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tfor (i = 0; i < 8; i++) {\n+\t\t\t\tfor (int i = 0; i < 8; i++) {\n \t\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n \t\t\t\t\t\tfp24_inv_cyc(t[i], t[i]);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfp24_set_dig(c, 1);\n-\t\t\t\tfor (i = l - 1; i >= 0; i--) {\n+\t\t\t\tfor (int i = l - 1; i >= 0; i--) {\n \t\t\t\t\tfp24_sqr_cyc(c, c);\n-\t\t\t\t\tfor (j = 0; j < 8; j++) {\n+\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n \t\t\t\t\t\tif (naf[j][i] > 0) {\n \t\t\t\t\t\t\tfp24_mul(c, c, t[j]);\n \t\t\t\t\t\t}\n@@ -1163,7 +1165,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\t\t} else {\n \t\t\t\tfp24_copy(t[0], a);\n \n-\t\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n+\t\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n \t\t\t\t\tfp24_sqr_cyc(t[0], t[0]);\n \t\t\t\t\tif (bn_get_bit(b, i)) {\n \t\t\t\t\t\tfp24_mul(t[0], t[0], a);\n@@ -1182,7 +1184,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\tRLC_FINALLY {\n \t\t\tbn_free(n);\n \t\t\tbn_free(x);\n-\t\t\tfor (i = 0; i < 8; i++) {\n+\t\t\tfor (int i = 0; i < 8; i++) {\n \t\t\t\tbn_free(_b[i]);\n \t\t\t\tfp24_free(t[i]);\n \t\t\t}\n@@ -1196,15 +1198,15 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\t\tif (u == NULL) {\n \t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n \t\t\t}\n-\t\t\tfor (i = 0; i < w; i++) {\n+\t\t\tfor (size_t i = 0; i < w; i++) {\n \t\t\t\tfp24_null(u[i]);\n \t\t\t\tfp24_new(u[i]);\n \t\t\t}\n \t\t\tfp24_new(t);\n \n \t\t\tj = 0;\n \t\t\tfp24_copy(t, a);\n-\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n+\t\t\tfor (size_t i = 1; i < bn_bits(b); i++) {\n \t\t\t\tfp24_sqr_pck(t, t);\n \t\t\t\tif (bn_get_bit(b, i)) {\n \t\t\t\t\tfp24_copy(u[j++], t);\n@@ -1227,7 +1229,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\t\t\tfp24_copy(c, u[0]);\n \t\t\t}\n \n-\t\t\tfor (i = j; i < k; i++) {\n+\t\t\tfor (size_t i = j; i < k; i++) {\n \t\t\t\tfp24_mul(c, c, u[i]);\n \t\t\t}\n \n@@ -1239,7 +1241,7 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n \t\t\tRLC_THROW(ERR_CAUGHT);\n \t\t}\n \t\tRLC_FINALLY {\n-\t\t\tfor (i = 0; i < w; i++) {\n+\t\t\tfor (size_t i = 0; i < w; i++) {\n \t\t\t\tfp24_free(u[i]);\n \t\t\t}\n \t\t\tfp24_free(t);\n@@ -1249,10 +1251,11 @@ void fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n }\n \n void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n-\tint i, l, n0, n1, l0, l1;\n+\tint n0, n1;\n \tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n \tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n \tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n+\tsize_t l, l0, l1;\n \n \tif (bn_is_zero(b)) {\n \t\treturn fp24_exp_cyc(e, c, d);\n@@ -1268,7 +1271,7 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co\n \tRLC_TRY {\n \t\tfp24_new(r);\n \t\tfp24_new(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n \t\t\tfp24_null(t0[i]);\n \t\t\tfp24_null(t1[i]);\n \t\t\tfp24_new(t0[i]);\n@@ -1297,12 +1300,12 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co\n \n \t\tl = RLC_MAX(l0, l1);\n \t\tif (bn_sign(b) == RLC_NEG) {\n-\t\t\tfor (i = 0; i < l0; i++) {\n+\t\t\tfor (size_t i = 0; i < l0; i++) {\n \t\t\t\tnaf0[i] = -naf0[i];\n \t\t\t}\n \t\t}\n \t\tif (bn_sign(d) == RLC_NEG) {\n-\t\t\tfor (i = 0; i < l1; i++) {\n+\t\t\tfor (size_t i = 0; i < l1; i++) {\n \t\t\t\tnaf1[i] = -naf1[i];\n \t\t\t}\n \t\t}\n@@ -1311,7 +1314,7 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co\n \t\t_m = naf1 + l - 1;\n \n \t\tfp24_set_dig(r, 1);\n-\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n+\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n \t\t\tfp24_sqr(r, r);\n \n \t\t\tn0 = *_k;\n@@ -1341,15 +1344,16 @@ void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, co\n \tRLC_FINALLY {\n \t\tfp24_free(r);\n \t\tfp24_free(s);\n-\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n+\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n \t\t\tfp24_free(t0[i]);\n \t\t\tfp24_free(t1[i]);\n \t\t}\n \t}\n }\n \n-void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, int len, int sign) {\n-\tint i, j, k, w = len;\n+void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t len,\n+\t\tint sign) {\n+\tsize_t i, j, k, w = len;\n     fp24_t t, *u = RLC_ALLOCA(fp24_t, w);\n \n \tif (len == 0) {\n@@ -1719,8 +1723,9 @@ void fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b) {\n \t}\n }\n \n-void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int len, int sign) {\n-\tint i, j, k, w = len;\n+void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t len,\n+\t\tint sign) {\n+\tsize_t i, j, k, w = len;\n     fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n \n \tif (len == 0) {\n@@ -2090,8 +2095,9 @@ void fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b) {\n \t}\n }\n \n-void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int len, int sign) {\n-\tint i, j, k, w = len;\n+void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,\n+\t\tint sign) {\n+\tsize_t i, j, k, w = len;\n     fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n \n \tif (len == 0) {"
        },
        {
          "filename": "src/fpx/relic_fpx_exp.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -329,7 +329,7 @@ void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n \tbn_t _b;\n \tfp12_t t, v;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \tif (b == 0) {\n \t\tfp12_set_dig(c, 1);\n@@ -461,7 +461,7 @@ void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n \tbn_t _b;\n \tfp24_t t, v;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \tif (b == 0) {\n \t\tfp24_set_dig(c, 1);\n@@ -561,7 +561,7 @@ void fp48_exp_dig(fp48_t c, const fp48_t a, dig_t b) {\n \tbn_t _b;\n \tfp48_t t, v;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \tif (b == 0) {\n \t\tfp48_set_dig(c, 1);\n@@ -657,7 +657,7 @@ void fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b) {\n \tbn_t _b;\n \tfp54_t t, v;\n \tint8_t u, naf[RLC_DIG + 1];\n-\tint l;\n+\tsize_t l;\n \n \tif (b == 0) {\n \t\tfp54_set_dig(c, 1);"
        },
        {
          "filename": "src/fpx/relic_fpx_util.c",
          "status": "modified",
          "additions": 22,
          "deletions": 22,
          "patch": "@@ -72,7 +72,7 @@ int fp2_size_bin(fp2_t a, int pack) {\n \t}\n }\n \n-void fp2_read_bin(fp2_t a, const uint8_t *bin, int len) {\n+void fp2_read_bin(fp2_t a, const uint8_t *bin, size_t len) {\n \tif (len != RLC_FP_BYTES + 1 && len != 2 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -89,7 +89,7 @@ void fp2_read_bin(fp2_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack) {\n+void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack) {\n \tfp2_t t;\n \n \tfp2_null(t);\n@@ -160,7 +160,7 @@ int fp3_size_bin(fp3_t a) {\n \treturn 3 * RLC_FP_BYTES;\n }\n \n-void fp3_read_bin(fp3_t a, const uint8_t *bin, int len) {\n+void fp3_read_bin(fp3_t a, const uint8_t *bin, size_t len) {\n \tif (len != 3 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -170,7 +170,7 @@ void fp3_read_bin(fp3_t a, const uint8_t *bin, int len) {\n \tfp_read_bin(a[2], bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES);\n }\n \n-void fp3_write_bin(uint8_t *bin, int len, const fp3_t a) {\n+void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a) {\n \tif (len != 3 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -214,7 +214,7 @@ int fp4_size_bin(fp4_t a) {\n \treturn 4 * RLC_FP_BYTES;\n }\n \n-void fp4_read_bin(fp4_t a, const uint8_t *bin, int len) {\n+void fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len) {\n \tif (len != 4 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -223,7 +223,7 @@ void fp4_read_bin(fp4_t a, const uint8_t *bin, int len) {\n \tfp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n }\n \n-void fp4_write_bin(uint8_t *bin, int len, const fp4_t a) {\n+void fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a) {\n \tif (len != 4 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -269,7 +269,7 @@ int fp6_size_bin(fp6_t a) {\n \treturn 6 * RLC_FP_BYTES;\n }\n \n-void fp6_read_bin(fp6_t a, const uint8_t *bin, int len) {\n+void fp6_read_bin(fp6_t a, const uint8_t *bin, size_t len) {\n \tif (len != 6 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -279,7 +279,7 @@ void fp6_read_bin(fp6_t a, const uint8_t *bin, int len) {\n \tfp2_read_bin(a[2], bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n }\n \n-void fp6_write_bin(uint8_t *bin, int len, const fp6_t a) {\n+void fp6_write_bin(uint8_t *bin, size_t len, const fp6_t a) {\n \tif (len != 6 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -331,7 +331,7 @@ int fp8_size_bin(fp8_t a, int pack) {\n \t}\n }\n \n-void fp8_read_bin(fp8_t a, const uint8_t *bin, int len) {\n+void fp8_read_bin(fp8_t a, const uint8_t *bin, size_t len) {\n \tif (len != 8 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -340,7 +340,7 @@ void fp8_read_bin(fp8_t a, const uint8_t *bin, int len) {\n \tfp4_read_bin(a[1], bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n }\n \n-void fp8_write_bin(uint8_t *bin, int len, const fp8_t a) {\n+void fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a) {\n \tif (len != 8 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -386,7 +386,7 @@ int fp9_size_bin(fp9_t a) {\n \treturn 9 * RLC_FP_BYTES;\n }\n \n-void fp9_read_bin(fp9_t a, const uint8_t *bin, int len) {\n+void fp9_read_bin(fp9_t a, const uint8_t *bin, size_t len) {\n \tif (len != 9 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -396,7 +396,7 @@ void fp9_read_bin(fp9_t a, const uint8_t *bin, int len) {\n \tfp3_read_bin(a[2], bin + 6 * RLC_FP_BYTES, 3 * RLC_FP_BYTES);\n }\n \n-void fp9_write_bin(uint8_t *bin, int len, const fp9_t a) {\n+void fp9_write_bin(uint8_t *bin, size_t len, const fp9_t a) {\n \tif (len != 9 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -448,7 +448,7 @@ int fp12_size_bin(fp12_t a, int pack) {\n \t}\n }\n \n-void fp12_read_bin(fp12_t a, const uint8_t *bin, int len) {\n+void fp12_read_bin(fp12_t a, const uint8_t *bin, size_t len) {\n \tif (len != 8 * RLC_FP_BYTES && len != 12 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -468,7 +468,7 @@ void fp12_read_bin(fp12_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fp12_write_bin(uint8_t *bin, int len, const fp12_t a, int pack) {\n+void fp12_write_bin(uint8_t *bin, size_t len, const fp12_t a, int pack) {\n \tfp12_t t;\n \n \tfp12_null(t);\n@@ -532,7 +532,7 @@ int fp18_size_bin(fp18_t a) {\n \treturn 18 * RLC_FP_BYTES;\n }\n \n-void fp18_read_bin(fp18_t a, const uint8_t *bin, int len) {\n+void fp18_read_bin(fp18_t a, const uint8_t *bin, size_t len) {\n \tif (len != 18 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -541,7 +541,7 @@ void fp18_read_bin(fp18_t a, const uint8_t *bin, int len) {\n \tfp9_read_bin(a[1], bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n }\n \n-void fp18_write_bin(uint8_t *bin, int len, const fp18_t a) {\n+void fp18_write_bin(uint8_t *bin, size_t len, const fp18_t a) {\n \tif (len != 18 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -595,7 +595,7 @@ int fp24_size_bin(fp24_t a, int pack) {\n \t}\n }\n \n-void fp24_read_bin(fp24_t a, const uint8_t *bin, int len) {\n+void fp24_read_bin(fp24_t a, const uint8_t *bin, size_t len) {\n \tif (len != 16 * RLC_FP_BYTES && len != 24 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -616,7 +616,7 @@ void fp24_read_bin(fp24_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fp24_write_bin(uint8_t *bin, int len, const fp24_t a, int pack) {\n+void fp24_write_bin(uint8_t *bin, size_t len, const fp24_t a, int pack) {\n \tfp24_t t;\n \n \tfp24_null(t);\n@@ -690,7 +690,7 @@ int fp48_size_bin(fp48_t a, int pack) {\n \t}\n }\n \n-void fp48_read_bin(fp48_t a, const uint8_t *bin, int len) {\n+void fp48_read_bin(fp48_t a, const uint8_t *bin, size_t len) {\n \tif (len != 32 * RLC_FP_BYTES && len != 48 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -710,7 +710,7 @@ void fp48_read_bin(fp48_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fp48_write_bin(uint8_t *bin, int len, const fp48_t a, int pack) {\n+void fp48_write_bin(uint8_t *bin, size_t len, const fp48_t a, int pack) {\n \tfp48_t t;\n \n \tfp48_null(t);\n@@ -786,7 +786,7 @@ int fp54_size_bin(fp54_t a, int pack) {\n \t}\n }\n \n-void fp54_read_bin(fp54_t a, const uint8_t *bin, int len) {\n+void fp54_read_bin(fp54_t a, const uint8_t *bin, size_t len) {\n \tif (len != 36 * RLC_FP_BYTES && len != 54 * RLC_FP_BYTES) {\n \t\tRLC_THROW(ERR_NO_BUFFER);\n \t\treturn;\n@@ -807,7 +807,7 @@ void fp54_read_bin(fp54_t a, const uint8_t *bin, int len) {\n \t}\n }\n \n-void fp54_write_bin(uint8_t *bin, int len, const fp54_t a, int pack) {\n+void fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack) {\n \tfp54_t t;\n \n \tfp54_null(t);"
        },
        {
          "filename": "src/md/relic_md_blake2s.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -43,7 +43,7 @@\n \n #if MD_MAP == B2S160 || !defined(STRIP)\n \n-void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len) {\n+void md_map_b2s160(uint8_t *hash, const uint8_t *msg, size_t len) {\n \tmemset(hash, 0, RLC_MD_LEN_B2S160);\n \tblake2s(hash, RLC_MD_LEN_B2S160, msg, len, NULL, 0);\n }\n@@ -52,7 +52,7 @@ void md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len) {\n \n #if MD_MAP == B2S256 || !defined(STRIP)\n \n-void md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len) {\n+void md_map_b2s256(uint8_t *hash, const uint8_t *msg, size_t len) {\n \tmemset(hash, 0, RLC_MD_LEN_B2S256);\n \tblake2s(hash, RLC_MD_LEN_B2S256, msg, len, NULL, 0);\n }"
        },
        {
          "filename": "src/md/relic_md_hmac.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -40,8 +40,8 @@\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,\n-    int key_len) {\n+void md_hmac(uint8_t *mac, const uint8_t *in, size_t in_len, const uint8_t *key,\n+    size_t key_len) {\n #if MD_MAP == SH224 || MD_MAP == SH256 || MD_MAP == B2S160 || MD_MAP == B2S256\n   #define block_size 64\n #elif MD_MAP == SH384 || MD_MAP == SH512"
        },
        {
          "filename": "src/md/relic_md_kdf.c",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -40,8 +40,7 @@\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void md_kdf(uint8_t *key, int key_len, const uint8_t *in,\n-\t\tint in_len) {\n+void md_kdf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len) {\n \tuint32_t i, j, d;\n \tuint8_t* buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));\n \tuint8_t* t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);"
        },
        {
          "filename": "src/md/relic_md_mgf.c",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -40,8 +40,7 @@\n /* Public definitions                                                         */\n /*============================================================================*/\n \n-void md_mgf(uint8_t *key, int key_len, const uint8_t *in,\n-\t\tint in_len) {\n+void md_mgf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len) {\n \tuint32_t i, j, d;\n \tuint8_t *buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));\n \tuint8_t *t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);"
        },
        {
          "filename": "src/md/relic_md_sha224.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -40,7 +40,7 @@\n \n #if MD_MAP == SH224 || !defined(STRIP)\n \n-void md_map_sh224(uint8_t *hash, const uint8_t *msg, int len) {\n+void md_map_sh224(uint8_t *hash, const uint8_t *msg, size_t len) {\n \tSHA224Context ctx;\n \n \tif (SHA224Reset(&ctx) != shaSuccess) {"
        },
        {
          "filename": "src/md/relic_md_sha256.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -40,7 +40,7 @@\n \n #if MD_MAP == SH256 || !defined(STRIP)\n \n-void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len) {\n+void md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len) {\n \tSHA256Context ctx;\n \n \tif (SHA256Reset(&ctx) != shaSuccess) {"
        },
        {
          "filename": "src/md/relic_md_sha384.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -40,7 +40,7 @@\n \n #if MD_MAP == SH384 || !defined(STRIP)\n \n-void md_map_sh384(uint8_t *hash, const uint8_t *msg, int len) {\n+void md_map_sh384(uint8_t *hash, const uint8_t *msg, size_t len) {\n \tSHA384Context ctx;\n \n \tif (SHA384Reset(&ctx) != shaSuccess) {"
        },
        {
          "filename": "src/md/relic_md_sha512.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -40,7 +40,7 @@\n \n #if MD_MAP == SH512 || !defined(STRIP)\n \n-void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len) {\n+void md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len) {\n \tSHA512Context ctx;\n \n \tif (SHA512Reset(&ctx) != shaSuccess) {"
        },
        {
          "filename": "src/pp/relic_pp_map_k12.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -52,7 +52,8 @@ static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n \tfp12_t l;\n \tep_t *_p = RLC_ALLOCA(ep_t, m);\n \tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n-\tint i, j, len = bn_bits(a) + 1;\n+\tsize_t len = bn_bits(a) + 1;\n+\tint i, j;\n \tint8_t s[RLC_FP_BITS + 1];\n \n \tif (m == 0) {"
        },
        {
          "filename": "src/pp/relic_pp_map_k24.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -52,7 +52,8 @@ static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n \tfp24_t l;\n \tep_t *_p = RLC_ALLOCA(ep_t, m);\n \tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n-\tint i, j, len = bn_bits(a) + 1;\n+\tsize_t len = bn_bits(a) + 1;\n+\tint i, j;\n \tint8_t s[RLC_FP_BITS + 1];\n \n \tif (m == 0) {"
        },
        {
          "filename": "src/pp/relic_pp_map_k48.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -42,7 +42,8 @@ static void pp_mil_k48(fp48_t r, const fp8_t qx, const fp8_t qy, const ep_t p,\n \tfp48_t l;\n \tep_t _p;\n \tfp8_t rx, ry, rz, qn;\n-\tint i, len = bn_bits(a) + 1;\n+\tsize_t len = bn_bits(a) + 1;\n+\tint i;\n \tint8_t s[RLC_FP_BITS + 1];\n \n \tfp48_null(l);"
        },
        {
          "filename": "src/pp/relic_pp_map_k54.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -42,7 +42,8 @@ static void pp_mil_k54(fp54_t r, const fp9_t qx, const fp9_t qy, const ep_t p,\n \tfp54_t l;\n \tep_t _p;\n \tfp9_t rx, ry, rz, sx, sy, sz, qn;\n-\tint i, len = bn_bits(a) + 1;\n+\tsize_t len = bn_bits(a) + 1;\n+\tint i;\n \tint8_t s[RLC_FP_BITS + 1];\n \n \tfp54_null(l);"
        },
        {
          "filename": "src/pp/relic_pp_map_k8.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -53,7 +53,8 @@ static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n \tfp8_t l;\n \tep_t *_p = RLC_ALLOCA(ep_t, m);\n \tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n-\tint i, j, len = bn_bits(a) + 1;\n+\tsize_t len = bn_bits(a) + 1;\n+\tint i, j;\n \tint8_t s[RLC_FP_BITS + 1];\n \n \tif (m == 0) {"
        },
        {
          "filename": "src/rand/relic_rand_core.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -183,7 +183,7 @@ void rand_init(void) {\n #endif\n }\n \n-int rand_check(uint8_t *buf, int size) {\n+int rand_check(uint8_t *buf, size_t size) {\n \tint count = 0;\n \n \tfor (int i = 1; i < size; i++) {"
        },
        {
          "filename": "src/rand/relic_rand_hashd.c",
          "status": "modified",
          "additions": 9,
          "deletions": 8,
          "patch": "@@ -53,9 +53,10 @@\n  * param[in] in         - the input string.\n  * param[in] in_len     - the number of bytes in the input.\n  */\n-static void rand_hash(uint8_t *out, int out_len, uint8_t *in, int in_len) {\n+static void rand_hash(uint8_t *out, size_t out_len, uint8_t *in,\n+\t\tsize_t in_len) {\n \tuint32_t j = util_conv_big(8 * out_len);\n-\tint len = RLC_CEIL(out_len, RLC_MD_LEN);\n+\tsize_t len = RLC_CEIL(out_len, RLC_MD_LEN);\n \tuint8_t* buf = RLC_ALLOCA(uint8_t, 1 + sizeof(uint32_t) + in_len);\n \tuint8_t hash[RLC_MD_LEN];\n \n@@ -88,7 +89,7 @@ static void rand_hash(uint8_t *out, int out_len, uint8_t *in, int in_len) {\n  * @param[in,out] state\t\t- the internal state.\n  * @param[in] digit\t\t\t- the small integer.\n  */\n-static int rand_inc(uint8_t *data, int size, int digit) {\n+static int rand_inc(uint8_t *data, size_t size, int digit) {\n \tint carry = digit;\n \tfor (int i = size - 1; i >= 0; i--) {\n \t\tint16_t s;\n@@ -105,7 +106,7 @@ static int rand_inc(uint8_t *data, int size, int digit) {\n  * @param[in,out] state\t\t- the internal state.\n  * @param[in] hash\t\t\t- the hash value.\n  */\n-static int rand_add(uint8_t *state, uint8_t *hash, int size) {\n+static int rand_add(uint8_t *state, uint8_t *hash, size_t size) {\n \tint carry = 0;\n \tfor (int i = size - 1; i >= 0; i--) {\n \t\t/* Make sure carries are detected. */\n@@ -123,7 +124,7 @@ static int rand_add(uint8_t *state, uint8_t *hash, int size) {\n  * @param[out] out \t\t\t- the buffer to write.\n  * @param[in] out_len\t\t- the number of bytes to write.\n  */\n-static void rand_gen(uint8_t *out, int out_len) {\n+static void rand_gen(uint8_t *out, size_t out_len) {\n \tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n \tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n \tctx_t *ctx = core_get();\n@@ -150,7 +151,7 @@ static void rand_gen(uint8_t *out, int out_len) {\n \n #if RAND == HASHD\n \n-void rand_bytes(uint8_t *buf, int size) {\n+void rand_bytes(uint8_t *buf, size_t size) {\n \tuint8_t hash[RLC_MD_LEN];\n \tint carry, len  = (RLC_RAND_SIZE - 1)/2;\n \tctx_t *ctx = core_get();\n@@ -173,9 +174,9 @@ void rand_bytes(uint8_t *buf, int size) {\n \tctx->counter = ctx->counter + 1;\n }\n \n-void rand_seed(uint8_t *buf, int size) {\n+void rand_seed(uint8_t *buf, size_t size) {\n \tctx_t *ctx = core_get();\n-\tint len = (RLC_RAND_SIZE - 1) / 2;\n+\tsize_t len = (RLC_RAND_SIZE - 1) / 2;\n \n \tif (size <= 0) {\n \t\tRLC_THROW(ERR_NO_VALID);"
        },
        {
          "filename": "src/relic_util.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -134,7 +134,7 @@ char util_conv_char(dig_t i) {\n #endif\n }\n \n-int util_bits_dig(dig_t a) {\n+size_t util_bits_dig(dig_t a) {\n     return RLC_DIG - arch_lzcnt(a);\n }\n "
        },
        {
          "filename": "test/test_bn.c",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -234,7 +234,7 @@ static int util(void) {\n \t\t} TEST_END;\n \n \t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n-\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n+\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n \t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n \t\t\tfor (int j = 2; j <= 64; j++) {\n \t\t\t\tbits = bn_size_str(a, j);\n@@ -262,7 +262,7 @@ static int util(void) {\n \t\tTEST_END;\n \n \t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n-\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n+\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n \t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n \t\t\tfor (int j = 2; j <= 64; j++) {\n \t\t\t\tbits = bn_size_str(a, j);\n@@ -1139,8 +1139,9 @@ static int exponentiation(void) {\n }\n \n static int square_root(void) {\n-\tint bits, code = RLC_ERR;\n+\tsize_t bits;\n \tbn_t a, b, c;\n+\tint code = RLC_ERR;\n \n \tbn_null(a);\n \tbn_null(b);\n@@ -1938,9 +1939,10 @@ static int factor(void) {\n static int recoding(void) {\n \tint code = RLC_ERR;\n \tbn_t a, b, c, v1[3], v2[3];\n-\tint w, k, l;\n+\tint w, k;\n \tuint8_t d[RLC_BN_BITS + 1];\n \tint8_t e[2 * (RLC_BN_BITS + 1)];\n+\tsize_t l;\n \n \tbn_null(a);\n \tbn_null(b);"
        },
        {
          "filename": "test/test_core.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -123,6 +123,7 @@ int main(void) {\n \t\t}\n \t\tTEST_ASSERT(code == RLC_OK, end);\n \n+\t\tcore_clean();\n \t\tcore_init();\n #pragma omp parallel copyin(core_ctx) shared(code)\n \t\t{"
        },
        {
          "filename": "test/test_pc.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1245,7 +1245,7 @@ static int memory(void) {\n }\n \n int util(void) {\n-\tint l, code = RLC_ERR;\n+\tint code = RLC_ERR;\n \tgt_t a, b, c;\n \tuint8_t bin[24 * RLC_PC_BYTES];\n "
        },
        {
          "filename": "test/test_rand.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -363,7 +363,7 @@ static int test(void) {\n \n static int test(void) {\n \tuint8_t out[64];\n-\tint len = sizeof(out) / 2, code = RLC_ERR;\n+\tsize_t len = sizeof(out) / 2, code = RLC_ERR;\n \n \tTEST_ONCE(\"rdrand hardware generator is non-trivial\") {\n \t\tmemset(out, 0, 2 * len);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 16,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eef556aada450b16b84b85d08642d1cfc45c6e0c",
            "date": "2025-01-11T16:51:59Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "0612d807ebbc554d97b19fc6791a8dcd4264ed91",
            "date": "2025-01-10T13:50:48Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "216ca40e62af772f9333ed4df7894e41e47f42ca",
            "date": "2024-12-30T01:37:58Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "782be63ce7a40f83441a9715395018e39c860d21",
            "date": "2024-12-30T01:11:31Z",
            "author_login": "dfaranha"
          },
          {
            "sha": "c48ba4ffc9a36489fe7b21aef889ed8be45516d0",
            "date": "2024-12-30T00:22:49Z",
            "author_login": "dfaranha"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-190",
    "description": "Integer Overflow vulnerability in RELIC before commit 34580d840469361ba9b5f001361cad659687b9ab, allows attackers to execute arbitrary code, cause a denial of service, and escalate privileges when calling realloc function in bn_grow function.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-09-01T16:15:08.077",
    "last_modified": "2024-11-21T08:09:33.170",
    "fix_date": "2022-11-14T20:47:12Z"
  },
  "references": [
    {
      "url": "https://github.com/relic-toolkit/relic/commit/34580d840469361ba9b5f001361cad659687b9ab",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://groups.google.com/g/relic-discuss/c/A_J2-ArVIAo/m/qgFiXsUJBQAJ?utm_medium=email&utm_source=footer",
      "source": "cve@mitre.org",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://github.com/relic-toolkit/relic/commit/34580d840469361ba9b5f001361cad659687b9ab",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://groups.google.com/g/relic-discuss/c/A_J2-ArVIAo/m/qgFiXsUJBQAJ?utm_medium=email&utm_source=footer",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:06.501891",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "relic",
    "owner": "relic-toolkit",
    "created_at": "2014-08-18T21:34:41Z",
    "updated_at": "2025-01-14T13:21:01Z",
    "pushed_at": "2025-01-11T16:52:03Z",
    "size": 16538,
    "stars": 467,
    "forks": 180,
    "open_issues": 11,
    "watchers": 467,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C": 5269206,
      "Assembly": 960652,
      "CMake": 81455,
      "Shell": 33388,
      "C++": 29345
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:06:57.084712"
  }
}