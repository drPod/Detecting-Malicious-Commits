{
  "cve_id": "CVE-2023-36820",
  "github_data": {
    "repository": "micronaut-projects/micronaut-security",
    "fix_commit": "9728b925221a0d87798ccf250657a3c214b7e980",
    "related_commits": [
      "9728b925221a0d87798ccf250657a3c214b7e980",
      "9728b925221a0d87798ccf250657a3c214b7e980"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "9728b925221a0d87798ccf250657a3c214b7e980",
      "commit_date": "2023-06-23T10:36:56Z",
      "author": {
        "login": "sdelamo",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-qw22-8w9r-864h",
        "length": 1374,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 215,
        "additions": 214,
        "deletions": 1
      },
      "files": [
        {
          "filename": "security-oauth2/src/main/java/io/micronaut/security/oauth2/client/IdTokenClaimsValidator.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -199,7 +199,7 @@ protected boolean validateIssuerAudienceAndAzp(@NonNull JwtClaims claims,\n             Optional<URL> issuerOptional = openIdClientConfiguration.getIssuer();\n             if (issuerOptional.isPresent()) {\n                 String issuer = issuerOptional.get().toString();\n-                return issuer.equalsIgnoreCase(iss) ||\n+                return issuer.equalsIgnoreCase(iss) &&\n                         audiences.contains(clientId) &&\n                                 validateAzp(claims, clientId, audiences);\n             }"
        },
        {
          "filename": "security-oauth2/src/test/groovy/io/micronaut/security/oauth2/endpoint/token/response/validation/AudienceClaimMatchesClientIdSpec.groovy",
          "status": "added",
          "additions": 213,
          "deletions": 0,
          "patch": "@@ -0,0 +1,213 @@\n+package io.micronaut.security.oauth2.endpoint.token.response.validation\n+\n+import com.nimbusds.jose.JWSAlgorithm\n+import com.nimbusds.jose.jwk.JWK\n+import com.nimbusds.jose.jwk.KeyUse\n+import com.nimbusds.jose.jwk.RSAKey\n+import com.nimbusds.jose.jwk.gen.JWKGenerator\n+import com.nimbusds.jose.jwk.gen.RSAKeyGenerator\n+import com.nimbusds.jwt.JWT\n+import com.nimbusds.jwt.JWTParser\n+import com.nimbusds.jwt.SignedJWT\n+import io.micronaut.context.ApplicationContext\n+import io.micronaut.context.annotation.Requires\n+import io.micronaut.core.util.StringUtils\n+import io.micronaut.http.HttpRequest\n+import io.micronaut.http.HttpResponse\n+import io.micronaut.http.HttpStatus\n+import io.micronaut.http.MediaType\n+import io.micronaut.http.annotation.Controller\n+import io.micronaut.http.annotation.Get\n+import io.micronaut.http.annotation.Produces\n+import io.micronaut.http.client.BlockingHttpClient\n+import io.micronaut.http.client.HttpClient\n+import io.micronaut.http.client.exceptions.HttpClientResponseException\n+import io.micronaut.http.server.util.HttpHostResolver\n+import io.micronaut.runtime.server.EmbeddedServer\n+import io.micronaut.security.annotation.Secured\n+import io.micronaut.security.authentication.Authentication\n+import io.micronaut.security.rules.SecurityRule\n+import io.micronaut.security.token.Claims\n+import io.micronaut.security.token.generator.TokenGenerator\n+import io.micronaut.security.token.jwt.endpoints.JwkProvider\n+import io.micronaut.security.token.jwt.generator.AccessTokenConfiguration\n+import io.micronaut.security.token.jwt.generator.claims.ClaimsGenerator\n+import io.micronaut.security.token.jwt.signature.rsa.RSASignatureGeneratorConfiguration\n+import jakarta.inject.Named\n+import jakarta.inject.Singleton\n+import spock.lang.Specification\n+\n+import java.security.interfaces.RSAPrivateKey\n+import java.security.interfaces.RSAPublicKey\n+\n+class AudienceClaimMatchesClientIdSpec extends Specification {\n+\n+    void \"test same issuer two different client ids\"() {\n+        given:\n+        EmbeddedServer authServer = ApplicationContext.run(EmbeddedServer, [\n+                \"micronaut.security.reject-not-found\": StringUtils.FALSE,\n+                \"spec.name\": \"AudienceClaimMatchesClientIdSpecAuthServer\"\n+        ])\n+        Map<String, Object> configuration = [\n+                \"micronaut.security.authentication\": \"idtoken\",\n+                \"micronaut.security.reject-not-found\": StringUtils.FALSE,\n+                \"spec.name\": \"AudienceClaimMatchesClientIdSpec\",\n+                \"micronaut.security.oauth2.clients.auth.client-id\": \"AAA\",\n+                \"micronaut.security.oauth2.clients.auth.client-secret\": \"YYY\",\n+                'micronaut.security.oauth2.clients.auth.openid.issuer': \"http://localhost:${authServer.port}/oauth2/default\"]\n+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, configuration)\n+        HttpClient authServerHttpClient = server.applicationContext.createBean(HttpClient, authServer.URL)\n+        BlockingHttpClient authServerClient = authServerHttpClient.toBlocking()\n+\n+        when:\n+        String keys = authServerClient.retrieve(HttpRequest.GET(\"/keys\"))\n+\n+        then:\n+        noExceptionThrown()\n+        keys != '{\"keys\":[]}'\n+\n+        when:\n+        String clientAToken = authServerClient.retrieve(HttpRequest.GET(\"/token/clientA\").accept(MediaType.TEXT_PLAIN))\n+        JWT clientAJWT = JWTParser.parse(clientAToken)\n+\n+        then:\n+        clientAJWT instanceof SignedJWT\n+        clientAJWT.getJWTClaimsSet().getClaim(\"aud\") == [\"AAA\"]\n+        clientAJWT.getJWTClaimsSet().getClaim(\"iss\") == \"http://localhost:${authServer.port}/oauth2/default\"\n+\n+        when:\n+        HttpClient httpClient = server.applicationContext.createBean(HttpClient, server.URL)\n+        BlockingHttpClient client = httpClient.toBlocking()\n+        client.retrieve(HttpRequest.GET(\"/hello\").bearerAuth(clientAToken))\n+\n+        then:\n+        noExceptionThrown()\n+\n+        when:\n+        String clientBToken = authServerClient.retrieve(HttpRequest.GET(\"/token/clientB\").accept(MediaType.TEXT_PLAIN))\n+        JWT clientBJWT = JWTParser.parse(clientBToken)\n+\n+        then:\n+        clientBJWT instanceof SignedJWT\n+        clientBJWT.getJWTClaimsSet().getClaim(\"aud\") == [\"BBB\"]\n+        clientBJWT.getJWTClaimsSet().getClaim(\"iss\") == \"http://localhost:${authServer.port}/oauth2/default\"\n+\n+        when:\n+        client.retrieve(HttpRequest.GET(\"/hello\").bearerAuth(clientBToken))\n+\n+        then:\n+        HttpClientResponseException e = thrown()\n+        HttpStatus.UNAUTHORIZED == e.status\n+\n+        cleanup:\n+        authServerClient.close()\n+        authServerHttpClient.close()\n+        httpClient.close()\n+        client.close()\n+        server.close()\n+        authServer.close()\n+    }\n+\n+    @Requires(property = 'spec.name', value = 'AudienceClaimMatchesClientIdSpec')\n+    @Controller(\"/hello\")\n+    static class HelloWorldController {\n+        @Get\n+        @Secured(SecurityRule.IS_AUTHENTICATED)\n+        Map<String, String> index() {\n+            [message: 'Hello World']\n+        }\n+    }\n+\n+    @Requires(property = \"spec.name\", value=\"AudienceClaimMatchesClientIdSpecAuthServer\")\n+    @Secured(SecurityRule.IS_ANONYMOUS)\n+    @Controller\n+    static class AuthServerController {\n+\n+        private final HttpHostResolver httpHostResolver\n+        private final TokenGenerator tokenGenerator\n+        private final AccessTokenConfiguration accessTokenConfiguration\n+        private final ClaimsGenerator claimsGenerator\n+\n+        AuthServerController(HttpHostResolver httpHostResolver,\n+                             TokenGenerator tokenGenerator,\n+                             AccessTokenConfiguration accessTokenConfiguration,\n+                             ClaimsGenerator claimsGenerator) {\n+            this.httpHostResolver = httpHostResolver\n+            this.tokenGenerator = tokenGenerator\n+            this.accessTokenConfiguration = accessTokenConfiguration\n+            this.claimsGenerator = claimsGenerator\n+        }\n+\n+        @Produces(MediaType.TEXT_PLAIN)\n+        @Get(\"/token/clientA\")\n+        HttpResponse<Object> clientA(HttpRequest<?> request) {\n+            generateToken(request, \"AAA\")\n+        }\n+\n+        @Produces(MediaType.TEXT_PLAIN)\n+        @Get(\"/token/clientB\")\n+        HttpResponse<Object> clientB(HttpRequest<?> request) {\n+            generateToken(request, \"BBB\")\n+        }\n+\n+        private HttpResponse<Object> generateToken(HttpRequest<?> request, String clientId) {\n+            String host = httpHostResolver.resolve(request)\n+            Map<String, Object> claims = new HashMap<>(claimsGenerator.generateClaims(Authentication.build(\"sherlock\"), accessTokenConfiguration.expiration))\n+            claims[Claims.ISSUER] = \"${host}/oauth2/default\".toString()\n+            claims[Claims.AUDIENCE] = clientId\n+            tokenGenerator.generateToken(claims).map(HttpResponse::ok).orElseGet(() -> HttpResponse.serverError())\n+        }\n+\n+        @Get(\"/oauth2/default/.well-known/openid-configuration\")\n+        String openIdConfiguration(HttpRequest<?> request) {\n+            String host = httpHostResolver.resolve(request)\n+            '{\"issuer\":\"' + host + '/oauth2/default\",\"authorization_endpoint\":\"' + host + '/oauth2/default/v1/authorize\",\"token_endpoint\":\"' + host + '/oauth2/default/v1/token\",\"userinfo_endpoint\":\"' + host + '/oauth2/default/v1/userinfo\",\"registration_endpoint\":\"' + host + '/oauth2/v1/clients\",\"jwks_uri\":\"' + host + '/keys\",\"response_types_supported\":[\"code\",\"id_token\",\"code id_token\",\"code token\",\"id_token token\",\"code id_token token\"],\"response_modes_supported\":[\"query\",\"fragment\",\"form_post\",\"okta_post_message\"],\"grant_types_supported\":[\"authorization_code\",\"implicit\",\"refresh_token\",\"password\"],\"subject_types_supported\":[\"public\"],\"id_token_signing_alg_values_supported\":[\"RS256\"],\"scopes_supported\":[\"openid\",\"profile\",\"email\",\"address\",\"phone\",\"offline_access\"],\"token_endpoint_auth_methods_supported\":[\"client_secret_basic\",\"client_secret_post\",\"client_secret_jwt\",\"private_key_jwt\",\"none\"],\"claims_supported\":[\"iss\",\"ver\",\"sub\",\"aud\",\"iat\",\"exp\",\"jti\",\"auth_time\",\"amr\",\"idp\",\"nonce\",\"name\",\"nickname\",\"preferred_username\",\"given_name\",\"middle_name\",\"family_name\",\"email\",\"email_verified\",\"profile\",\"zoneinfo\",\"locale\",\"address\",\"phone_number\",\"picture\",\"website\",\"gender\",\"birthdate\",\"updated_at\",\"at_hash\",\"c_hash\"],\"code_challenge_methods_supported\":[\"S256\"],\"introspection_endpoint\":\"' + host + '/oauth2/default/v1/introspect\",\"introspection_endpoint_auth_methods_supported\":[\"client_secret_basic\",\"client_secret_post\",\"client_secret_jwt\",\"private_key_jwt\",\"none\"],\"revocation_endpoint\":\"' + host + '/oauth2/default/v1/revoke\",\"revocation_endpoint_auth_methods_supported\":[\"client_secret_basic\",\"client_secret_post\",\"client_secret_jwt\",\"private_key_jwt\",\"none\"],\"end_session_endpoint\":\"' + host + '/oauth2/default/v1/logout\",\"request_parameter_supported\":true,\"request_object_signing_alg_values_supported\":[\"HS256\",\"HS384\",\"HS512\",\"RS256\",\"RS384\",\"RS512\",\"ES256\",\"ES384\",\"ES512\"]}'\n+        }\n+    }\n+\n+    @Requires(property = 'spec.name', value = 'AudienceClaimMatchesClientIdSpecAuthServer')\n+    @Named(\"generator\")\n+    @Singleton\n+    static class AuthServerSignatureConfiguration implements RSASignatureGeneratorConfiguration, JwkProvider {\n+        private final static JWSAlgorithm ALG = JWSAlgorithm.RS256\n+        private List<JWK> jwks = null\n+        private RSAKey rsaKey = null\n+\n+        List<JWK> getJwks() {\n+            if (jwks == null) {\n+                this.jwks = Collections.singletonList(getRsaKey().toPublicJWK())\n+            }\n+            return jwks\n+        }\n+\n+        RSAKey getRsaKey() {\n+            if (rsaKey == null) {\n+                JWKGenerator jwkGenerator = new RSAKeyGenerator(2048)\n+                        .algorithm(ALG)\n+                        .keyUse(KeyUse.SIGNATURE)\n+                this.rsaKey = jwkGenerator.generate()\n+            }\n+            return rsaKey\n+        }\n+\n+        @Override\n+        RSAPublicKey getPublicKey() {\n+            getRsaKey().toRSAPublicKey()\n+        }\n+\n+        @Override\n+        RSAPrivateKey getPrivateKey() {\n+            getRsaKey().toRSAPrivateKey()\n+        }\n+\n+        @Override\n+        JWSAlgorithm getJwsAlgorithm() {\n+            ALG\n+        }\n+\n+        @Override\n+        List<JWK> retrieveJsonWebKeys() {\n+            getJwks()\n+        }\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 12
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4f6be85ae8287f65d80ff936b70f1741a318765f",
            "date": "2025-01-26T01:46:53Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "54f46cdba02b0056bfff686d68564f8f1929fb34",
            "date": "2025-01-25T02:26:57Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "91d6f94a444dba062e079fa48d24148cbbe2dbb0",
            "date": "2025-01-20T03:03:33Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "a2fa5c93c10b4749a7364ad238d3ec7774b0b340",
            "date": "2025-01-19T01:30:15Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "6832f9989355b7c5f99719146090cb8002516641",
            "date": "2025-01-18T01:56:29Z",
            "author_login": "renovate[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-284",
    "description": "Micronaut Security is a security solution for applications. Prior to versions 3.1.2, 3.2.4, 3.3.2, 3.4.3, 3.5.3, 3.6.6, 3.7.4, 3.8.4, 3.9.6, 3.10.2, and 3.11.1, IdTokenClaimsValidator skips `aud` claim validation if token is issued by same identity issuer/provider. Any OIDC setup using Micronaut where multiple OIDC applications exists for the same issuer but token auth are not meant to be shared. This issue has been patched in versions 3.1.2, 3.2.4, 3.3.2, 3.4.3, 3.5.3, 3.6.6, 3.7.4, 3.8.4, 3.9.6, 3.10.2, and 3.11.1.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-10-09T14:15:10.640",
    "last_modified": "2024-11-21T08:10:40.067",
    "fix_date": "2023-06-23T10:36:56Z"
  },
  "references": [
    {
      "url": "https://github.com/micronaut-projects/micronaut-security/commit/9728b925221a0d87798ccf250657a3c214b7e980",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-security/security/advisories/GHSA-qw22-8w9r-864h",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-security/commit/9728b925221a0d87798ccf250657a3c214b7e980",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/micronaut-projects/micronaut-security/security/advisories/GHSA-qw22-8w9r-864h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.583115",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "micronaut-security",
    "owner": "micronaut-projects",
    "created_at": "2019-04-17T13:42:39Z",
    "updated_at": "2025-01-26T01:46:57Z",
    "pushed_at": "2025-01-26T06:17:07Z",
    "size": 172582,
    "stars": 171,
    "forks": 128,
    "open_issues": 90,
    "watchers": 171,
    "has_security_policy": false,
    "default_branch": "4.12.x",
    "protected_branches": [
      "1.1.x",
      "1.2.x",
      "1.3.x",
      "1.4.x",
      "2.0.x",
      "2.1.x",
      "2.2.x",
      "2.3.x",
      "2.4.x",
      "2.5.x",
      "3.0.x",
      "3.1.x",
      "3.2.x",
      "3.3.x",
      "3.4.x",
      "3.5.x",
      "3.6.x",
      "3.7.x",
      "3.8.x",
      "3.9.x",
      "3.10.x",
      "3.11.x",
      "4.0.x",
      "4.1.x",
      "4.2.x",
      "4.4.x",
      "4.6.x",
      "4.7.x",
      "4.8.x",
      "4.9.x"
    ],
    "languages": {
      "Java": 1887893,
      "Groovy": 1169416,
      "Kotlin": 34132,
      "JavaScript": 2168,
      "CSS": 1559,
      "Shell": 1526
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:14:37.483745"
  }
}