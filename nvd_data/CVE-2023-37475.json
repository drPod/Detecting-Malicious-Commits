{
  "cve_id": "CVE-2023-37475",
  "github_data": {
    "repository": "hamba/avro",
    "fix_commit": "b4a402f41cf44b6094b5131286830ba9bb1eb290",
    "related_commits": [
      "b4a402f41cf44b6094b5131286830ba9bb1eb290",
      "b4a402f41cf44b6094b5131286830ba9bb1eb290"
    ],
    "patch_url": "https://github.com/hamba/avro/commit/b4a402f41cf44b6094b5131286830ba9bb1eb290.patch",
    "fix_commit_details": {
      "sha": "b4a402f41cf44b6094b5131286830ba9bb1eb290",
      "commit_date": "2023-07-16T17:22:09Z",
      "author": {
        "login": "nrwiersma",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "feat: add max byte slice size config (#273)",
        "length": 43,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 56,
        "additions": 55,
        "deletions": 1
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -125,11 +125,18 @@ encoding and decoding.\n Enums may also implement `TextMarshaler` and `TextUnmarshaler`, and must resolve to valid symbols in the given enum schema.\n \n ##### Identical Underlying Types\n+\n One type can be [ConvertibleTo](https://go.dev/ref/spec#Conversions) another type if they have identical underlying types. \n A non-native type is allowed be used if it can be convertible to *time.Time*, *big.Rat* or *avro.LogicalDuration* for the particular of *LogicalTypes*.\n \n Ex.: `type Timestamp time.Time`\n \n+##### Untrusted Input With Bytes and Strings\n+\n+For security reasons, the configuration `Config.MaxByteSliceSize` restricts the maximum size of `bytes` and `string` types created\n+by the `Reader`. The default maximum size is `1MiB` and is configurable. This is required to stop untrusted input from consuming all memory and\n+crashing the application. Should this not be need, setting a negative number will disable the behaviour.\n+\n ### Recursive Structs\n \n At this moment recursive structs are not supported. It is planned for the future."
        },
        {
          "filename": "config.go",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -8,6 +8,8 @@ import (\n \t\"github.com/modern-go/reflect2\"\n )\n \n+const maxByteSliceSize = 1024 * 1024\n+\n // DefaultConfig is the default API.\n var DefaultConfig = Config{}.Freeze()\n \n@@ -43,6 +45,10 @@ type Config struct {\n \t// Disable caching layer for encoders and decoders, forcing them to get rebuilt on every\n \t// call to Marshal() and Unmarshal()\n \tDisableCaching bool\n+\n+\t// MaxByteSliceSize is the maximum size of `bytes` or `string` types the Reader will create, defaulting to 1MiB.\n+\t// If this size is exceeded, the Reader returns an error. This can be disabled by setting a negative number.\n+\tMaxByteSliceSize int\n }\n \n // Freeze makes the configuration immutable.\n@@ -252,3 +258,11 @@ func (c *frozenConfig) getBlockLength() int {\n \t}\n \treturn blockSize\n }\n+\n+func (c *frozenConfig) getMaxByteSliceSize() int {\n+\tsize := c.config.MaxByteSliceSize\n+\tif size == 0 {\n+\t\treturn maxByteSliceSize\n+\t}\n+\treturn size\n+}"
        },
        {
          "filename": "reader.go",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -4,6 +4,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"strings\"\n \t\"unsafe\"\n )\n \n@@ -216,12 +217,18 @@ func (r *Reader) ReadString() string {\n func (r *Reader) readBytes(op string) []byte {\n \tsize := int(r.ReadLong())\n \tif size < 0 {\n-\t\tr.ReportError(\"ReadString\", \"invalid \"+op+\" length\")\n+\t\tfnName := \"Read\" + strings.ToTitle(op)\n+\t\tr.ReportError(fnName, \"invalid \"+op+\" length\")\n \t\treturn nil\n \t}\n \tif size == 0 {\n \t\treturn []byte{}\n \t}\n+\tif max := r.cfg.getMaxByteSliceSize(); max > 0 && size > max {\n+\t\tfnName := \"Read\" + strings.ToTitle(op)\n+\t\tr.ReportError(fnName, \"size is greater than `Config.MaxByteSliceSize`\")\n+\t\treturn nil\n+\t}\n \n \t// The bytes are entirely in the buffer and of a reasonable size.\n \t// Use the byte slab."
        },
        {
          "filename": "reader_test.go",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -507,6 +507,19 @@ func TestReader_ReadBytes(t *testing.T) {\n \t}\n }\n \n+func TestReader_ReadBytesLargerThanMaxByteSliceSize(t *testing.T) {\n+\tdata := []byte{\n+\t\t246, 255, 255, 255, 255, 10, 255, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+\t\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+\t\t32, 32, 32, 32, 32, 32, 32,\n+\t}\n+\tr := avro.NewReader(bytes.NewReader(data), 4)\n+\n+\t_ = r.ReadBytes()\n+\n+\tassert.Error(t, r.Error)\n+}\n+\n func TestReader_ReadString(t *testing.T) {\n \ttests := []struct {\n \t\tdata    []byte\n@@ -583,6 +596,19 @@ func TestReader_ReadString(t *testing.T) {\n \t}\n }\n \n+func TestReader_ReadStringLargerThanMaxByteSliceSize(t *testing.T) {\n+\tdata := []byte{\n+\t\t246, 255, 255, 255, 255, 10, 255, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+\t\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+\t\t32, 32, 32, 32, 32, 32, 32,\n+\t}\n+\tr := avro.NewReader(bytes.NewReader(data), 4)\n+\n+\t_ = r.ReadString()\n+\n+\tassert.Error(t, r.Error)\n+}\n+\n func TestReader_ReadStringFastPathIsntBoundToBuffer(t *testing.T) {\n \tdata := []byte{0x06, 0x66, 0x6F, 0x6F, 0x08, 0x61, 0x76, 0x72, 0x6F}\n \tr := avro.NewReader(bytes.NewReader(data), 4)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "68046a4308cb7a650d33f225efbbcab8d58ad52e",
            "date": "2025-01-13T18:00:07Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0ebcdff2ba1904f60e60f26cdf551d787dafe8de",
            "date": "2025-01-09T08:14:28Z",
            "author_login": "vpapp"
          },
          {
            "sha": "53e4ea95ef76e5a6c0a62822c6fcd8f189e1672e",
            "date": "2025-01-08T12:49:20Z",
            "author_login": "pavelpascari"
          },
          {
            "sha": "cb79c9fd34b31ed94aee91a787c40a3e28102e64",
            "date": "2024-12-13T15:05:42Z",
            "author_login": "mihaitodor"
          },
          {
            "sha": "45d131be1264313f1ddac28a365cc0cfc333557b",
            "date": "2024-12-09T18:31:56Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Hamba avro is a go lang encoder/decoder implementation of the avro codec specification. In affected versions a well-crafted string passed to avro's `github.com/hamba/avro/v2.Unmarshal()` can throw a `fatal error: runtime: out of memory` which is unrecoverable and can cause denial of service of the consumer of avro. The root cause of the issue is that avro uses part of the input to `Unmarshal()` to determine the size when creating a new slice and hence an attacker may consume arbitrary amounts of memory which in turn may cause the application to crash. This issue has been addressed in commit `b4a402f4` which has been included in release version `2.13.0`. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-07-17T17:15:10.127",
    "last_modified": "2024-11-21T08:11:47.353",
    "fix_date": "2023-07-16T17:22:09Z"
  },
  "references": [
    {
      "url": "https://github.com/hamba/avro/commit/b4a402f41cf44b6094b5131286830ba9bb1eb290",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/hamba/avro/security/advisories/GHSA-9x44-9pgq-cf45",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/hamba/avro/commit/b4a402f41cf44b6094b5131286830ba9bb1eb290",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/hamba/avro/security/advisories/GHSA-9x44-9pgq-cf45",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.248742",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "avro",
    "owner": "hamba",
    "created_at": "2019-02-27T16:40:50Z",
    "updated_at": "2025-01-13T22:59:40Z",
    "pushed_at": "2025-01-13T18:00:09Z",
    "size": 639,
    "stars": 403,
    "forks": 101,
    "open_issues": 17,
    "watchers": 403,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 667981,
      "Makefile": 435
    },
    "commit_activity": {
      "total_commits_last_year": 75,
      "avg_commits_per_week": 1.4423076923076923,
      "days_active_last_year": 62
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T14:38:25.656300"
  }
}