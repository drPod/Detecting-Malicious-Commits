{
  "cve_id": "CVE-2023-38684",
  "github_data": {
    "repository": "discourse/discourse",
    "fix_commit": "bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70",
    "related_commits": [
      "bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70",
      "bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70"
    ],
    "patch_url": "https://github.com/discourse/discourse/commit/bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70.patch",
    "fix_commit_details": {
      "sha": "bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70",
      "commit_date": "2023-07-28T11:53:46Z",
      "author": {
        "login": "tgxworld",
        "type": "User",
        "stats": {
          "total_commits": 4679,
          "average_weekly_commits": 6.7518037518037515,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 404
        }
      },
      "commit_message": {
        "title": "SECURITY: Impose a upper bound on limit params in various controllers",
        "length": 701,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 347,
        "additions": 232,
        "deletions": 115
      },
      "files": [
        {
          "filename": "app/controllers/admin/api_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -4,9 +4,11 @@ class Admin::ApiController < Admin::AdminController\n   # Note: in the REST API, ApiKeys are referred to simply as \"key\"\n   # If we used \"api_key\", then our user provider would try to use the value for authentication\n \n+  INDEX_LIMIT = 50\n+\n   def index\n     offset = (params[:offset] || 0).to_i\n-    limit = (params[:limit] || 50).to_i.clamp(1, 50)\n+    limit = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT)\n \n     keys =\n       ApiKey"
        },
        {
          "filename": "app/controllers/admin/reports_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -1,6 +1,8 @@\n # frozen_string_literal: true\n \n class Admin::ReportsController < Admin::StaffController\n+  REPORTS_LIMIT = 50\n+\n   def index\n     reports_methods =\n       [\"page_view_total_reqs\"] +\n@@ -108,10 +110,7 @@ def parse_params(report_params)\n     facets = nil\n     facets = report_params[:facets].map { |s| s.to_s.to_sym } if Array === report_params[:facets]\n \n-    limit = nil\n-    if report_params.has_key?(:limit) && report_params[:limit].to_i > 0\n-      limit = report_params[:limit].to_i\n-    end\n+    limit = fetch_limit_from_params(params: report_params, default: nil, max: REPORTS_LIMIT)\n \n     filters = nil\n     filters = report_params[:filters] if report_params.has_key?(:filters)"
        },
        {
          "filename": "app/controllers/admin/staff_action_logs_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,11 +1,13 @@\n # frozen_string_literal: true\n \n class Admin::StaffActionLogsController < Admin::StaffController\n+  INDEX_LIMIT = 200\n+\n   def index\n     filters = params.slice(*UserHistory.staff_filters + %i[page limit])\n \n     page = (params[:page] || 0).to_i\n-    page_size = (params[:limit] || 200).to_i.clamp(1, 200)\n+    page_size = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT)\n \n     staff_action_logs = UserHistory.staff_action_records(current_user, filters)\n     count = staff_action_logs.count"
        },
        {
          "filename": "app/controllers/application_controller.rb",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -1084,4 +1084,22 @@ def load_font_map\n         end\n       end\n   end\n+\n+  def fetch_limit_from_params(params: self.params, default:, max:)\n+    raise \"default limit cannot be greater than max limit\" if default.present? && default > max\n+\n+    if params.has_key?(:limit)\n+      limit =\n+        begin\n+          Integer(params[:limit])\n+        rescue ArgumentError\n+          raise Discourse::InvalidParameters.new(:limit)\n+        end\n+\n+      raise Discourse::InvalidParameters.new(:limit) if limit < 0 || limit > max\n+      limit\n+    else\n+      default\n+    end\n+  end\n end"
        },
        {
          "filename": "app/controllers/directory_items_controller.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -81,8 +81,7 @@ def index\n       end\n     end\n \n-    limit = [params[:limit].to_i, PAGE_SIZE].min if params[:limit].to_i > 0\n-    limit ||= PAGE_SIZE\n+    limit = fetch_limit_from_params(default: PAGE_SIZE, max: PAGE_SIZE)\n \n     result_count = result.count\n     result = result.limit(limit).offset(limit * page).to_a"
        },
        {
          "filename": "app/controllers/drafts_controller.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -5,11 +5,17 @@ class DraftsController < ApplicationController\n \n   skip_before_action :check_xhr, :preload_json\n \n+  INDEX_LIMIT = 50\n+\n   def index\n     params.permit(:offset)\n-    params.permit(:limit)\n \n-    stream = Draft.stream(user: current_user, offset: params[:offset], limit: params[:limit])\n+    stream =\n+      Draft.stream(\n+        user: current_user,\n+        offset: params[:offset],\n+        limit: fetch_limit_from_params(default: nil, max: INDEX_LIMIT),\n+      )\n \n     render json: { drafts: stream ? serialize_data(stream, DraftSerializer) : [] }\n   end"
        },
        {
          "filename": "app/controllers/groups_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -230,15 +230,16 @@ def mentions_feed\n     render \"posts/latest\", formats: [:rss]\n   end\n \n+  MEMBERS_LIMIT = 1_000\n+\n   def members\n     group = find_group(:group_id)\n \n     guardian.ensure_can_see_group_members!(group)\n \n-    limit = (params[:limit] || 50).to_i\n+    limit = fetch_limit_from_params(default: 50, max: MEMBERS_LIMIT)\n     offset = params[:offset].to_i\n \n-    raise Discourse::InvalidParameters.new(:limit) if limit < 0 || limit > 1000\n     raise Discourse::InvalidParameters.new(:offset) if offset < 0\n \n     dir = (params[:asc] && params[:asc].present?) ? \"ASC\" : \"DESC\""
        },
        {
          "filename": "app/controllers/notifications_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -5,6 +5,8 @@ class NotificationsController < ApplicationController\n   before_action :ensure_admin, only: %i[create update destroy]\n   before_action :set_notification, only: %i[update destroy]\n \n+  INDEX_LIMIT = 50\n+\n   def index\n     user =\n       if params[:username] && !params[:recent]\n@@ -25,8 +27,7 @@ def index\n     end\n \n     if params[:recent].present?\n-      limit = (params[:limit] || 15).to_i\n-      limit = 50 if limit > 50\n+      limit = fetch_limit_from_params(default: 15, max: INDEX_LIMIT)\n \n       include_reviewables = false\n "
        },
        {
          "filename": "app/controllers/post_action_users_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,13 +1,15 @@\n # frozen_string_literal: true\n \n class PostActionUsersController < ApplicationController\n+  INDEX_LIMIT = 200\n+\n   def index\n     params.require(:post_action_type_id)\n     params.require(:id)\n     post_action_type_id = params[:post_action_type_id].to_i\n \n     page = params[:page].to_i\n-    page_size = (params[:limit] || 200).to_i\n+    page_size = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT)\n \n     # Find the post, and then determine if they can see the post (if deleted)\n     post = Post.with_deleted.where(id: params[:id].to_i).first"
        },
        {
          "filename": "app/controllers/posts_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -662,13 +662,15 @@ def unhide\n     render body: nil\n   end\n \n+  DELETED_POSTS_MAX_LIMIT = 100\n+\n   def deleted_posts\n     params.permit(:offset, :limit)\n     guardian.ensure_can_see_deleted_posts!\n \n     user = fetch_user_from_params\n     offset = [params[:offset].to_i, 0].max\n-    limit = [(params[:limit] || 60).to_i, 100].min\n+    limit = fetch_limit_from_params(default: 60, max: DELETED_POSTS_MAX_LIMIT)\n \n     posts = user_posts(guardian, user.id, offset: offset, limit: limit).where.not(deleted_at: nil)\n "
        },
        {
          "filename": "app/controllers/tag_groups_controller.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -79,7 +79,10 @@ def search\n       matches = matches.where(\"lower(NAME) in (?)\", params[:names].map(&:downcase))\n     end\n \n-    matches = matches.order(\"name\").limit(params[:limit] || 5)\n+    matches =\n+      matches.order(\"name\").limit(\n+        fetch_limit_from_params(default: 5, max: SiteSetting.max_tag_search_results),\n+      )\n \n     render json: {\n              results:"
        },
        {
          "filename": "app/controllers/tags_controller.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -292,13 +292,8 @@ def search\n       exclude_has_synonyms: params[:excludeHasSynonyms],\n     }\n \n-    if params[:limit]\n-      begin\n-        filter_params[:limit] = Integer(params[:limit])\n-        raise Discourse::InvalidParameters.new(:limit) if !filter_params[:limit].positive?\n-      rescue ArgumentError\n-        raise Discourse::InvalidParameters.new(:limit)\n-      end\n+    if limit = fetch_limit_from_params(default: nil, max: SiteSetting.max_tag_search_results)\n+      filter_params[:limit] = limit\n     end\n \n     filter_params[:category] = Category.find_by_id(params[:categoryId]) if params[:categoryId]"
        },
        {
          "filename": "app/controllers/users_controller.rb",
          "status": "modified",
          "additions": 19,
          "deletions": 7,
          "patch": "@@ -1182,6 +1182,8 @@ def send_activation_email\n     end\n   end\n \n+  SEARCH_USERS_LIMIT = 50\n+\n   def search_users\n     term = params[:term].to_s.strip\n \n@@ -1204,10 +1206,11 @@ def search_users\n       params[:include_staged_users],\n     )\n     options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users])\n-    if params[:limit].present?\n-      options[:limit] = params[:limit].to_i\n-      raise Discourse::InvalidParameters.new(:limit) if options[:limit] <= 0\n+\n+    if limit = fetch_limit_from_params(default: nil, max: SEARCH_USERS_LIMIT)\n+      options[:limit] = limit\n     end\n+\n     options[:topic_id] = topic_id if topic_id\n     options[:category_id] = category_id if category_id\n \n@@ -1733,14 +1736,24 @@ def clear_featured_topic\n     render json: success_json\n   end\n \n+  BOOKMARKS_LIMIT = 20\n+\n   def bookmarks\n     user = fetch_user_from_params\n     guardian.ensure_can_edit!(user)\n     user_guardian = Guardian.new(user)\n \n     respond_to do |format|\n       format.json do\n-        bookmark_list = UserBookmarkList.new(user: user, guardian: guardian, params: params)\n+        bookmark_list =\n+          UserBookmarkList.new(\n+            user: user,\n+            guardian: guardian,\n+            search_term: params[:q],\n+            page: params[:page],\n+            per_page: fetch_limit_from_params(default: nil, max: BOOKMARKS_LIMIT),\n+          )\n+\n         bookmark_list.load\n \n         if bookmark_list.bookmarks.empty?\n@@ -1789,10 +1802,9 @@ def user_menu_bookmarks\n         UserBookmarkList.new(\n           user: current_user,\n           guardian: guardian,\n-          params: {\n-            per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,\n-          },\n+          per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,\n         )\n+\n       bookmark_list.load do |query|\n         if exclude_bookmark_ids.present?\n           query.where(\"bookmarks.id NOT IN (?)\", exclude_bookmark_ids)"
        },
        {
          "filename": "app/models/user_bookmark_list.rb",
          "status": "modified",
          "additions": 16,
          "deletions": 10,
          "patch": "@@ -8,26 +8,32 @@ class UserBookmarkList\n   attr_reader :bookmarks, :per_page, :has_more\n   attr_accessor :more_bookmarks_url, :bookmark_serializer_opts\n \n-  def initialize(user:, guardian:, params:)\n+  def initialize(user:, guardian:, search_term: nil, per_page: nil, page: 0)\n     @user = user\n     @guardian = guardian\n-    @params = params\n \n-    @params.merge!(per_page: PER_PAGE) if params[:per_page].blank?\n-    @params[:per_page] = PER_PAGE if @params[:per_page] > PER_PAGE\n+    @per_page = per_page || PER_PAGE\n+    @per_page = PER_PAGE if @per_page > PER_PAGE\n+\n+    @search_term = search_term\n+    @page = page.to_i\n \n     @bookmarks = []\n     @bookmark_serializer_opts = {}\n   end\n \n   def load(&blk)\n-    query = BookmarkQuery.new(user: @user, guardian: @guardian, params: @params)\n+    query =\n+      BookmarkQuery.new(\n+        user: @user,\n+        guardian: @guardian,\n+        search_term: @search_term,\n+        page: @page,\n+        per_page: @per_page,\n+      )\n+\n     @bookmarks = query.list_all(&blk)\n-    @has_more = (@params[:page].to_i + 1) * @params[:per_page] < query.count\n+    @has_more = (@page.to_i + 1) * @per_page < query.count\n     @bookmarks\n   end\n-\n-  def per_page\n-    @per_page ||= @params[:per_page]\n-  end\n end"
        },
        {
          "filename": "lib/bookmark_query.rb",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -26,19 +26,18 @@ def self.preload_polymorphic_associations(bookmarks, guardian)\n \n   attr_reader :guardian, :count\n \n-  def initialize(user:, guardian: nil, params: {})\n+  def initialize(user:, guardian: nil, search_term: nil, page: nil, per_page: nil)\n     @user = user\n-    @params = params\n+    @search_term = search_term\n     @guardian = guardian || Guardian.new(@user)\n-    @page = @params[:page].to_i\n-    @limit = @params[:limit].present? ? @params[:limit].to_i : @params[:per_page]\n+    @page = page ? page.to_i : 0\n+    @per_page = per_page ? per_page.to_i : 20\n     @count = 0\n   end\n \n   def list_all(&blk)\n-    search_term = @params[:q]\n-    ts_query = search_term.present? ? Search.ts_query(term: search_term) : nil\n-    search_term_wildcard = search_term.present? ? \"%#{search_term}%\" : nil\n+    ts_query = @search_term.present? ? Search.ts_query(term: @search_term) : nil\n+    search_term_wildcard = @search_term.present? ? \"%#{@search_term}%\" : nil\n \n     queries =\n       Bookmark\n@@ -51,7 +50,7 @@ def list_all(&blk)\n           # on a topic and that topic was moved into a private category\n           next if interim_results.blank?\n \n-          if search_term.present?\n+          if @search_term.present?\n             interim_results =\n               bookmarkable.perform_search_query(interim_results, search_term_wildcard, ts_query)\n           end\n@@ -78,13 +77,14 @@ def list_all(&blk)\n \n     @count = results.count\n \n-    results = results.offset(@page * @params[:per_page]) if @page.positive?\n+    results = results.offset(@page * @per_page) if @page.positive?\n \n     if updated_results = blk&.call(results)\n       results = updated_results\n     end\n \n-    results = results.limit(@limit).to_a\n+    results = results.limit(@per_page).to_a\n+\n     BookmarkQuery.preload(results, self)\n     results\n   end"
        },
        {
          "filename": "plugins/chat/app/controllers/chat/api/channels_memberships_controller.rb",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -1,11 +1,13 @@\n # frozen_string_literal: true\n \n class Chat::Api::ChannelsMembershipsController < Chat::Api::ChannelsController\n+  INDEX_LIMIT = 50\n+\n   def index\n     params.permit(:username, :offset, :limit)\n \n     offset = params[:offset].to_i\n-    limit = (params[:limit] || 50).to_i.clamp(1, 50)\n+    limit = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT)\n \n     memberships =\n       Chat::ChannelMembershipsQuery.call("
        },
        {
          "filename": "spec/lib/bookmark_query_spec.rb",
          "status": "modified",
          "additions": 9,
          "deletions": 11,
          "patch": "@@ -4,10 +4,9 @@\n   before { SearchIndexer.enable }\n \n   fab!(:user) { Fabricate(:user) }\n-  let(:params) { {} }\n \n-  def bookmark_query(user: nil, params: nil)\n-    BookmarkQuery.new(user: user || self.user, params: params || self.params)\n+  def bookmark_query(user: nil, search_term: nil, per_page: nil)\n+    BookmarkQuery.new(user: user || self.user, search_term:, per_page:)\n   end\n \n   describe \"#list_all\" do\n@@ -67,7 +66,7 @@ def bookmark_query(user: nil, params: nil)\n       expect(bookmarks.map(&:id)).to eq([])\n     end\n \n-    context \"when q param is provided\" do\n+    context \"when search_term is provided\" do\n       let!(:post) do\n         Fabricate(\n           :post,\n@@ -89,17 +88,17 @@ def bookmark_query(user: nil, params: nil)\n       end\n \n       it \"can search by bookmark name\" do\n-        bookmarks = bookmark_query(params: { q: \"check\" }).list_all\n+        bookmarks = bookmark_query(search_term: \"check\").list_all\n         expect(bookmarks.map(&:id)).to eq([bookmark3.id])\n       end\n \n       it \"can search by post content\" do\n-        bookmarks = bookmark_query(params: { q: \"content\" }).list_all\n+        bookmarks = bookmark_query(search_term: \"content\").list_all\n         expect(bookmarks.map(&:id)).to eq([bookmark4.id])\n       end\n \n       it \"can search by topic title\" do\n-        bookmarks = bookmark_query(params: { q: \"bugfix\" }).list_all\n+        bookmarks = bookmark_query(search_term: \"bugfix\").list_all\n         expect(bookmarks.map(&:id)).to eq([bookmark4.id])\n       end\n \n@@ -111,7 +110,7 @@ def bookmark_query(user: nil, params: nil)\n         end\n \n         it \"allows searching bookmarkables by fields in other tables\" do\n-          bookmarks = bookmark_query(params: { q: \"bookmarkk\" }).list_all\n+          bookmarks = bookmark_query(search_term: \"bookmarkk\").list_all\n           expect(bookmarks.map(&:id)).to eq([bookmark5.id])\n         end\n       end\n@@ -205,10 +204,9 @@ def bookmark_query(user: nil, params: nil)\n       end\n     end\n \n-    context \"when the limit param is provided\" do\n-      let(:params) { { limit: 1 } }\n+    context \"when the per_page is provided\" do\n       it \"is respected\" do\n-        expect(bookmark_query.list_all.count).to eq(1)\n+        expect(bookmark_query(per_page: 1).list_all.count).to eq(1)\n       end\n     end\n   end"
        },
        {
          "filename": "spec/models/user_bookmark_list_spec.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -1,9 +1,8 @@\n # frozen_string_literal: true\n \n RSpec.describe UserBookmarkList do\n-  let(:params) { {} }\n   fab!(:user) { Fabricate(:user) }\n-  let(:list) { UserBookmarkList.new(user: user, guardian: Guardian.new(user), params: params) }\n+  let(:list) { UserBookmarkList.new(user: user, guardian: Guardian.new(user)) }\n \n   before do\n     register_test_bookmarkable\n@@ -21,9 +20,11 @@\n \n   it \"returns all types of bookmarks\" do\n     list.load\n+\n     expect(list.bookmarks.map(&:id)).to match_array(\n       [post_bookmark.id, topic_bookmark.id, user_bookmark.id],\n     )\n+\n     expect(list.has_more).to eq(false)\n   end\n \n@@ -32,13 +33,14 @@\n   end\n \n   context \"when the per_page param is too high\" do\n-    let(:params) { { per_page: 1000 } }\n-\n     it \"does not allow more than X bookmarks to be requested per page\" do\n       22.times do\n         bookmark = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post))\n         Fabricate(:topic_user, topic: bookmark.bookmarkable.topic, user: user)\n       end\n+\n+      list = UserBookmarkList.new(user: user, guardian: Guardian.new(user), per_page: 1000)\n+\n       expect(list.load.count).to eq(20)\n     end\n   end"
        },
        {
          "filename": "spec/rails_helper.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -78,6 +78,7 @@ def call(env)\n # Requires supporting ruby files with custom matchers and macros, etc,\n # in spec/support/ and its subdirectories.\n Dir[Rails.root.join(\"spec/support/**/*.rb\")].each { |f| require f }\n+Dir[Rails.root.join(\"spec/requests/examples/*.rb\")].each { |f| require f }\n \n Dir[Rails.root.join(\"spec/system/helpers/**/*.rb\")].each { |f| require f }\n Dir[Rails.root.join(\"spec/system/page_objects/**/base.rb\")].each { |f| require f }"
        },
        {
          "filename": "spec/requests/admin/api_controller_spec.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -20,6 +20,12 @@\n         expect(response.parsed_body[\"keys\"].length).to eq(3)\n       end\n \n+      describe \"when limit params is invalid\" do\n+        include_examples \"invalid limit params\",\n+                         \"/admin/api/keys.json\",\n+                         described_class::INDEX_LIMIT\n+      end\n+\n       it \"can paginate results\" do\n         get \"/admin/api/keys.json?offset=0&limit=2\"\n "
        },
        {
          "filename": "spec/requests/admin/reports_controller_spec.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -30,6 +30,12 @@\n       end\n \n       context \"with invalid params\" do\n+        context \"when limit param is invalid\" do\n+          include_examples \"invalid limit params\",\n+                           \"/admin/reports/topics.json\",\n+                           described_class::REPORTS_LIMIT\n+        end\n+\n         context \"with nonexistent report\" do\n           it \"returns not found reports\" do\n             get \"/admin/reports/bulk.json\",\n@@ -154,6 +160,12 @@\n             expect(response.parsed_body[\"report\"][\"total\"]).to eq(1)\n           end\n         end\n+\n+        context \"when limit param is invalid\" do\n+          include_examples \"invalid limit params\",\n+                           \"/admin/reports/topics.json\",\n+                           described_class::REPORTS_LIMIT\n+        end\n       end\n \n       describe \"when report is scoped to a category\" do"
        },
        {
          "filename": "spec/requests/admin/staff_action_logs_controller_spec.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -27,6 +27,12 @@\n           \"action_id\" => UserHistory.actions[:delete_topic],\n         )\n       end\n+\n+      describe \"when limit params is invalid\" do\n+        include_examples \"invalid limit params\",\n+                         \"/admin/logs/staff_action_logs.json\",\n+                         described_class::INDEX_LIMIT\n+      end\n     end\n \n     context \"when logged in as an admin\" do"
        },
        {
          "filename": "spec/requests/directory_items_controller_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 16,
          "patch": "@@ -30,22 +30,7 @@\n       expect(json[\"directory_items\"].length).to eq(2)\n     end\n \n-    it \"does not exceed PAGE_SIZE if limit parameter is more than PAGE_SIZE\" do\n-      large_limit = DirectoryItemsController::PAGE_SIZE + 10\n-      get \"/directory_items.json\", params: { period: \"all\", limit: large_limit }\n-      expect(response.status).to eq(200)\n-      json = response.parsed_body\n-\n-      expect(json[\"directory_items\"].length).to eq(DirectoryItemsController::PAGE_SIZE)\n-    end\n-\n-    it \"handles invalid limit parameters gracefully\" do\n-      get \"/directory_items.json\", params: { period: \"all\", limit: \"invalid_limit\" }\n-      expect(response.status).to eq(200)\n-      json = response.parsed_body\n-\n-      expect(json[\"directory_items\"]).not_to be_empty\n-    end\n+    include_examples \"invalid limit params\", \"/directory_items.json\", described_class::PAGE_SIZE\n   end\n \n   context \"with exclude_groups parameter\" do"
        },
        {
          "filename": "spec/requests/drafts_controller_spec.rb",
          "status": "modified",
          "additions": 17,
          "deletions": 9,
          "patch": "@@ -1,14 +1,22 @@\n # frozen_string_literal: true\n \n RSpec.describe DraftsController do\n+  fab!(:user) { Fabricate(:user) }\n+\n   describe \"#index\" do\n     it \"requires you to be logged in\" do\n       get \"/drafts.json\"\n       expect(response.status).to eq(403)\n     end\n \n+    describe \"when limit params is invalid\" do\n+      before { sign_in(user) }\n+\n+      include_examples \"invalid limit params\", \"/drafts.json\", described_class::INDEX_LIMIT\n+    end\n+\n     it \"returns correct stream length after adding a draft\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n       Draft.set(user, \"xxx\", 0, \"{}\")\n       get \"/drafts.json\"\n       expect(response.status).to eq(200)\n@@ -17,7 +25,7 @@\n     end\n \n     it \"has empty stream after deleting last draft\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n       Draft.set(user, \"xxx\", 0, \"{}\")\n       Draft.clear(user, \"xxx\", 0)\n       get \"/drafts.json\"\n@@ -46,7 +54,7 @@\n \n   describe \"#show\" do\n     it \"returns a draft if requested\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n       Draft.set(user, \"hello\", 0, \"test\")\n \n       get \"/drafts/hello.json\"\n@@ -62,7 +70,7 @@\n     end\n \n     it \"saves a draft\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n \n       post \"/drafts.json\", params: { draft_key: \"xyz\", data: { my: \"data\" }.to_json, sequence: 0 }\n \n@@ -77,7 +85,7 @@\n     end\n \n     it \"checks for an conflict on update\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n       post = Fabricate(:post, user: user)\n \n       post \"/drafts.json\",\n@@ -103,7 +111,7 @@\n     end\n \n     it \"cant trivially resolve conflicts without interaction\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n \n       DraftSequence.next!(user, \"abc\")\n \n@@ -120,7 +128,7 @@\n     end\n \n     it \"has a clean protocol for ownership handover\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n \n       post \"/drafts.json\",\n            params: {\n@@ -170,7 +178,7 @@\n     end\n \n     it \"raises an error for out-of-sequence draft setting\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n       seq = DraftSequence.next!(user, \"abc\")\n       Draft.set(user, \"abc\", seq, { b: \"test\" }.to_json)\n \n@@ -230,7 +238,7 @@\n \n   describe \"#destroy\" do\n     it \"destroys drafts when required\" do\n-      user = sign_in(Fabricate(:user))\n+      sign_in(user)\n       Draft.set(user, \"xxx\", 0, \"hi\")\n       delete \"/drafts/xxx.json\", params: { sequence: 0 }\n "
        },
        {
          "filename": "spec/requests/examples/invalid_limit_params.rb",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+# frozen_string_literal: true\n+\n+RSpec.shared_examples \"invalid limit params\" do |endpoint, max_limit, extra_params|\n+  let(:params) { extra_params&.dig(:params) || {} }\n+\n+  it \"returns 400 response code when limit params is negative\" do\n+    get endpoint, params: { limit: -1 }.merge(params)\n+\n+    expect(response.status).to eq(400)\n+  end\n+\n+  it \"returns 400 response code when limit params is suspicious\" do\n+    get endpoint, params: { limit: \"1; DROP TABLE users\" }.merge(params)\n+\n+    expect(response.status).to eq(400)\n+  end\n+\n+  it \"returns 400 response code when limit params exceeds the max limit\" do\n+    get endpoint, params: { limit: max_limit + 1 }.merge(params)\n+\n+    expect(response.status).to eq(400)\n+  end\n+end"
        },
        {
          "filename": "spec/requests/notifications_controller_spec.rb",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -87,6 +87,15 @@ def delete_notification(resp_code, matcher)\n           Discourse.clear_redis_readonly!\n         end\n \n+        describe \"when limit params is invalid\" do\n+          include_examples \"invalid limit params\",\n+                           \"/notifications.json\",\n+                           described_class::INDEX_LIMIT,\n+                           params: {\n+                             recent: true,\n+                           }\n+        end\n+\n         it \"get notifications with all filters\" do\n           notification = Fabricate(:notification, user: user)\n           notification2 = Fabricate(:notification, user: user)"
        },
        {
          "filename": "spec/requests/post_action_users_controller_spec.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -4,6 +4,14 @@\n   fab!(:user) { Fabricate(:user) }\n   let(:post) { Fabricate(:post, user: sign_in(user)) }\n \n+  describe \"index\" do\n+    describe \"when limit params is invalid\" do\n+      include_examples \"invalid limit params\",\n+                       \"/post_action_users.json\",\n+                       described_class::INDEX_LIMIT\n+    end\n+  end\n+\n   context \"with render\" do\n     it \"always allows you to see your own actions\" do\n       notify_mod = PostActionType.types[:notify_moderators]"
        },
        {
          "filename": "spec/requests/posts_controller_spec.rb",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -2254,6 +2254,14 @@\n         expect(response).to be_forbidden\n       end\n \n+      describe \"when limit params is invalid\" do\n+        before { sign_in(moderator) }\n+\n+        include_examples \"invalid limit params\",\n+                         \"/posts/system/deleted.json\",\n+                         described_class::DELETED_POSTS_MAX_LIMIT\n+      end\n+\n       it \"can see the deleted posts when authorized\" do\n         sign_in(moderator)\n         get \"/posts/system/deleted.json\""
        },
        {
          "filename": "spec/requests/tag_groups_controller_spec.rb",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -48,6 +48,12 @@\n     let(:full) { TagGroupPermission.permission_types[:full] }\n     let(:readonly) { TagGroupPermission.permission_types[:readonly] }\n \n+    describe \"when limit params is invalid\" do\n+      include_examples \"invalid limit params\",\n+                       \"/tag_groups/filter/search.json\",\n+                       SiteSetting.max_tag_search_results\n+    end\n+\n     context \"for anons\" do\n       it \"returns the tag group with the associated tag names\" do\n         tag_group = tag_group_with_permission(everyone, readonly)"
        },
        {
          "filename": "spec/requests/tags_controller_spec.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 16,
          "patch": "@@ -1103,22 +1103,10 @@ def parse_topic_ids\n         )\n       end\n \n-      it \"returns error 400 for negative limit\" do\n-        get \"/tags/filter/search.json\", params: { q: \"\", limit: -1 }\n-\n-        expect(response.status).to eq(400)\n-        expect(response.parsed_body[\"errors\"].first).to eq(\n-          I18n.t(\"invalid_params\", message: \"limit\"),\n-        )\n-      end\n-\n-      it \"returns error 400 for suspicious limit\" do\n-        get \"/tags/filter/search.json\", params: { q: \"\", limit: \"1; SELECT 1\" }\n-\n-        expect(response.status).to eq(400)\n-        expect(response.parsed_body[\"errors\"].first).to eq(\n-          I18n.t(\"invalid_params\", message: \"limit\"),\n-        )\n+      describe \"when limit params is invalid\" do\n+        include_examples \"invalid limit params\",\n+                         \"/tags/filter/search.json\",\n+                         SiteSetting.max_tag_search_results\n       end\n \n       it \"includes required tag group information\" do"
        },
        {
          "filename": "spec/requests/users_controller_spec.rb",
          "status": "modified",
          "additions": 13,
          "deletions": 6,
          "patch": "@@ -4,7 +4,7 @@\n \n RSpec.describe UsersController do\n   fab!(:user) { Fabricate(:user) }\n-  fab!(:user1) { Fabricate(:user) }\n+  fab!(:user1) { Fabricate(:user, username: \"someusername\") }\n   fab!(:another_user) { Fabricate(:user) }\n   fab!(:invitee) { Fabricate(:user) }\n   fab!(:inviter) { Fabricate(:user) }\n@@ -4886,11 +4886,10 @@ def create_and_like_post(likee, liker)\n       expect(response.status).to eq(200)\n     end\n \n-    context \"with limit\" do\n-      it \"returns an error if value is invalid\" do\n-        get \"/u/search/users.json\", params: { limit: \"-1\" }\n-        expect(response.status).to eq(400)\n-      end\n+    describe \"when limit params is invalid\" do\n+      include_examples \"invalid limit params\",\n+                       \"/u/search/users.json\",\n+                       described_class::SEARCH_USERS_LIMIT\n     end\n \n     context \"when `enable_names` is true\" do\n@@ -6185,6 +6184,14 @@ def revoke(user, skip_remote: false)\n       expect(response.status).to eq(200)\n       expect(response.parsed_body[\"bookmarks\"]).to eq([])\n     end\n+\n+    describe \"when limit params is invalid\" do\n+      before { sign_in(user1) }\n+\n+      include_examples \"invalid limit params\",\n+                       \"/u/someusername/bookmarks.json\",\n+                       described_class::BOOKMARKS_LIMIT\n+    end\n   end\n \n   describe \"#bookmarks excerpts\" do"
        },
        {
          "filename": "spec/serializers/user_bookmark_list_serializer_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -18,7 +18,7 @@\n     let(:user_bookmark) { Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:user)) }\n \n     def run_serializer\n-      bookmark_list = UserBookmarkList.new(user: user, guardian: Guardian.new(user), params: {})\n+      bookmark_list = UserBookmarkList.new(user: user, guardian: Guardian.new(user))\n       bookmark_list.load\n       UserBookmarkListSerializer.new(bookmark_list)\n     end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 12,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "496a739788d58a7f1c6bd59643d062ae37e982a0",
            "date": "2025-01-14T15:19:49Z",
            "author_login": "discourse-translator-bot"
          },
          {
            "sha": "a89086f7996f95024827df61fb0d86a516b269f6",
            "date": "2025-01-14T15:19:19Z",
            "author_login": "markvanlan"
          },
          {
            "sha": "473e37e7b3dcb254548a04695fb5e5f56a6de33b",
            "date": "2025-01-14T14:32:50Z",
            "author_login": "CvX"
          },
          {
            "sha": "eb64db828e116edbacdf10266f8102ed7028a2f2",
            "date": "2025-01-14T13:28:46Z",
            "author_login": "renato"
          },
          {
            "sha": "7330cfa76a6e6ab7bf90702fb1db5e1a37a2eca1",
            "date": "2025-01-14T13:28:16Z",
            "author_login": "awesomerobot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-770",
    "description": "Discourse is an open source discussion platform. Prior to version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches, in multiple controller actions, Discourse accepts limit params but does not impose any upper bound on the values being accepted. Without an upper bound, the software may allow arbitrary users to generate DB queries which may end up exhausting the resources on the server. The issue is patched in version 3.0.6 of the `stable` branch and version 3.1.0.beta7 of the `beta` and `tests-passed` branches. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-07-28T16:15:12.290",
    "last_modified": "2024-11-21T08:14:02.853",
    "fix_date": "2023-07-28T11:53:46Z"
  },
  "references": [
    {
      "url": "https://github.com/discourse/discourse/commit/bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-ff7g-xv79-hgmf",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/commit/bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/discourse/discourse/security/advisories/GHSA-ff7g-xv79-hgmf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.282851",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "discourse",
    "owner": "discourse",
    "created_at": "2013-01-12T00:25:55Z",
    "updated_at": "2025-01-14T12:47:11Z",
    "pushed_at": "2025-01-14T12:47:07Z",
    "size": 692535,
    "stars": 42892,
    "forks": 8390,
    "open_issues": 67,
    "watchers": 42892,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 20275963,
      "JavaScript": 9399743,
      "HTML": 1461704,
      "Handlebars": 1070089,
      "SCSS": 988476,
      "Mustache": 32177,
      "Shell": 12314,
      "CSS": 2558
    },
    "commit_activity": {
      "total_commits_last_year": 5032,
      "avg_commits_per_week": 96.76923076923077,
      "days_active_last_year": 300
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:00:05.486140"
  }
}