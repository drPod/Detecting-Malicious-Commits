{
  "cve_id": "CVE-2023-38697",
  "github_data": {
    "repository": "socketry/protocol-http1",
    "fix_commit": "e11fc164fd2b36f7b7e785e69fa8859eb06bcedd",
    "related_commits": [
      "e11fc164fd2b36f7b7e785e69fa8859eb06bcedd",
      "e11fc164fd2b36f7b7e785e69fa8859eb06bcedd"
    ],
    "patch_url": "https://github.com/socketry/protocol-http1/commit/e11fc164fd2b36f7b7e785e69fa8859eb06bcedd.patch",
    "fix_commit_details": {
      "sha": "e11fc164fd2b36f7b7e785e69fa8859eb06bcedd",
      "commit_date": "2023-07-30T00:46:58Z",
      "author": {
        "login": "ioquatix",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Strict validation of content length and chunk length. (#20)",
        "length": 59,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 145,
        "additions": 140,
        "deletions": 5
      },
      "files": [
        {
          "filename": "lib/protocol/http1/body/chunked.rb",
          "status": "modified",
          "additions": 9,
          "deletions": 1,
          "patch": "@@ -35,12 +35,20 @@ def close(error = nil)\n \t\t\t\t\tsuper\n \t\t\t\tend\n \t\t\t\t\n+\t\t\t\tVALID_CHUNK_LENGTH = /\\A[0-9a-fA-F]+\\z/\n+\t\t\t\t\n \t\t\t\t# Follows the procedure outlined in https://tools.ietf.org/html/rfc7230#section-4.1.3\n \t\t\t\tdef read\n \t\t\t\t\treturn nil if @finished\n \t\t\t\t\t\n+\t\t\t\t\tlength, extensions = read_line.split(\";\", 2)\n+\t\t\t\t\t\n+\t\t\t\t\tunless length =~ VALID_CHUNK_LENGTH\n+\t\t\t\t\t\traise BadRequest, \"Invalid chunk length: #{length.dump}\"\n+\t\t\t\t\tend\n+\t\t\t\t\t\n \t\t\t\t\t# It is possible this line contains chunk extension, so we use `to_i` to only consider the initial integral part:\n-\t\t\t\t\tlength = read_line.to_i(16)\n+\t\t\t\t\tlength = Integer(length, 16)\n \t\t\t\t\t\n \t\t\t\t\tif length == 0\n \t\t\t\t\t\t@finished = true"
        },
        {
          "filename": "lib/protocol/http1/connection.rb",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -398,10 +398,12 @@ def read_tunnel_body\n \t\t\tHEAD = \"HEAD\"\n \t\t\tCONNECT = \"CONNECT\"\n \t\t\t\n+\t\t\tVALID_CONTENT_LENGTH = /\\A\\d+\\z/\n+\t\t\t\n \t\t\tdef extract_content_length(headers)\n \t\t\t\tif content_length = headers.delete(CONTENT_LENGTH)\n-\t\t\t\t\tif length = Integer(content_length, exception: false) and length >= 0\n-\t\t\t\t\t\tyield length\n+\t\t\t\t\tif content_length =~ VALID_CONTENT_LENGTH\n+\t\t\t\t\t\tyield Integer(content_length, 10)\n \t\t\t\t\telse\n \t\t\t\t\t\traise BadRequest, \"Invalid content length: #{content_length}\"\n \t\t\t\t\tend"
        },
        {
          "filename": "test/protocol/http1/connection.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -208,15 +208,15 @@\n \t\t\n \t\twith \"HEAD\" do\n \t\t\tit \"can read length of head response\" do\n-\t\t\t\tbody = client.read_response_body(\"HEAD\", 200, {'content-length' => 3773})\n+\t\t\t\tbody = client.read_response_body(\"HEAD\", 200, {'content-length' => '3773'})\n \t\t\t\t\n \t\t\t\texpect(body).to be_a ::Protocol::HTTP::Body::Head\n \t\t\t\texpect(body.length).to be == 3773\n \t\t\t\texpect(body.read).to be_nil\n \t\t\tend\n \t\t\t\n \t\t\tit \"ignores zero length body\" do\n-\t\t\t\tbody = client.read_response_body(\"HEAD\", 200, {'content-length' => 0})\n+\t\t\t\tbody = client.read_response_body(\"HEAD\", 200, {'content-length' => '0'})\n \t\t\t\t\n \t\t\t\texpect(body).to be_nil\n \t\t\tend"
        },
        {
          "filename": "test/protocol/http1/connection/bad.rb",
          "status": "added",
          "additions": 125,
          "deletions": 0,
          "patch": "@@ -0,0 +1,125 @@\n+# frozen_string_literal: true\n+\n+# Released under the MIT License.\n+# Copyright, 2019-2023, by Samuel Williams.\n+\n+require 'protocol/http1/connection'\n+require 'connection_context'\n+\n+describe Protocol::HTTP1::Connection do\n+\tinclude_context ConnectionContext\n+\t\n+\tdef before\n+\t\tsuper\n+\t\t\n+\t\tclient.stream.write(input)\n+\t\tclient.stream.close\n+\tend\n+\t\n+\twith \"invalid hexadecimal content-length\" do\n+\t\tdef input\n+\t\t\t<<~HTTP.gsub(\"\\n\", \"\\r\\n\")\n+\t\t\tPOST / HTTP/1.1\n+\t\t\tHost: a.com\n+\t\t\tContent-Length: 0x10\n+\t\t\tConnection: close\n+\t\t\t\n+\t\t\t0123456789abcdef\n+\t\t\tHTTP\n+\t\tend\n+\t\t\n+\t\tit \"should fail to parse the request body\" do\n+\t\t\texpect do\n+\t\t\t\tserver.read_request\n+\t\t\tend.to raise_exception(Protocol::HTTP1::BadRequest)\n+\t\tend\n+\tend\n+\t\n+\twith \"invalid +integer content-length\" do\n+\t\tdef input\n+\t\t\t<<~HTTP.gsub(\"\\n\", \"\\r\\n\")\n+\t\t\tPOST / HTTP/1.1\n+\t\t\tHost: a.com\n+\t\t\tContent-Length: +16\n+\t\t\tConnection: close\n+\t\t\t\n+\t\t\t0123456789abcdef\n+\t\t\tHTTP\n+\t\tend\n+\t\t\n+\t\tit \"should fail to parse the request body\" do\n+\t\t\texpect do\n+\t\t\t\tserver.read_request\n+\t\t\tend.to raise_exception(Protocol::HTTP1::BadRequest)\n+\t\tend\n+\tend\n+\t\n+\twith \"invalid -integer content-length\" do\n+\t\tdef input\n+\t\t\t<<~HTTP.gsub(\"\\n\", \"\\r\\n\")\n+\t\t\tPOST / HTTP/1.1\n+\t\t\tHost: a.com\n+\t\t\tContent-Length: -16\n+\t\t\tConnection: close\n+\t\t\t\n+\t\t\t0123456789abcdef\n+\t\t\tHTTP\n+\t\tend\n+\t\t\n+\t\tit \"should fail to parse the request body\" do\n+\t\t\texpect do\n+\t\t\t\tserver.read_request\n+\t\t\tend.to raise_exception(Protocol::HTTP1::BadRequest)\n+\t\tend\n+\tend\n+\t\n+\twith \"invalid hexidecimal chunk size\" do\n+\t\tdef input\n+\t\t\t<<~HTTP.gsub(\"\\n\", \"\\r\\n\")\n+\t\t\tPOST / HTTP/1.1\n+\t\t\tHost: a.com\n+\t\t\tTransfer-Encoding: chunked\n+\t\t\tConnection: close\n+\t\t\t\n+\t\t\t0x10\n+\t\t\t0123456789abcdef\n+\t\t\t0\n+\t\t\tHTTP\n+\t\tend\n+\t\t\n+\t\tit \"should fail to parse the request body\" do\n+\t\t\tauthority, method, target, version, headers, body = server.read_request\n+\t\t\t\n+\t\t\texpect(body).to be_a(Protocol::HTTP1::Body::Chunked)\n+\t\t\t\n+\t\t\texpect do\n+\t\t\t\tbody.read\n+\t\t\tend.to raise_exception(Protocol::HTTP1::BadRequest)\n+\t\tend\n+\tend\n+\t\n+\twith \"invalid +integer chunk size\" do\n+\t\tdef input\n+\t\t\t<<~HTTP.gsub(\"\\n\", \"\\r\\n\")\n+\t\t\tPOST / HTTP/1.1\n+\t\t\tHost: a.com\n+\t\t\tTransfer-Encoding: chunked\n+\t\t\tConnection: close\n+\t\t\t\n+\t\t\t+10\n+\t\t\t0123456789abcdef\n+\t\t\t0\n+\t\t\tHTTP\n+\t\tend\n+\t\t\n+\t\tit \"should fail to parse the request body\" do\n+\t\t\tauthority, method, target, version, headers, body = server.read_request\n+\t\t\t\n+\t\t\texpect(body).to be_a(Protocol::HTTP1::Body::Chunked)\n+\t\t\t\n+\t\t\texpect do\n+\t\t\t\tbody.read\n+\t\t\tend.to raise_exception(Protocol::HTTP1::BadRequest)\n+\t\tend\n+\tend\n+end"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "db96687509548e54f28ff3ebcb156bf4c70d4e4d",
            "date": "2024-10-15T12:11:19Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "406642e528f931b31a24a270b5be07f016ba0bc8",
            "date": "2024-10-15T12:11:05Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "53ae3247cbc73d6d7796553b8225bc296981ac07",
            "date": "2024-10-15T12:06:10Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "56460bc65dd682290501f199e70e88eade126437",
            "date": "2024-10-15T12:02:53Z",
            "author_login": "ioquatix"
          },
          {
            "sha": "60929d0d889e5ebb2ed4c75e84cb470943bb5cac",
            "date": "2024-10-15T11:51:19Z",
            "author_login": "ioquatix"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:N",
    "cwe_id": "CWE-444",
    "description": "protocol-http1 provides a low-level implementation of the HTTP/1 protocol. RFC 9112 Section 7.1 defined the format of chunk size, chunk data and chunk extension. The value of Content-Length header should be a string of 0-9 digits, the chunk size should be a string of hex digits and should split from chunk data using CRLF, and the chunk extension shouldn't contain any invisible character. However, Falcon has following behaviors while disobey the corresponding RFCs: accepting Content-Length header values that have `+` prefix, accepting Content-Length header values that written in hexadecimal with `0x` prefix, accepting `0x` and `+` prefixed chunk size, and accepting LF in chunk extension. This behavior can lead to desync when forwarding through multiple HTTP parsers, potentially results in HTTP request smuggling and firewall bypassing. This issue is fixed in `protocol-http1` v0.15.1. There are no known workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-08-04T18:15:15.010",
    "last_modified": "2024-11-21T08:14:04.553",
    "fix_date": "2023-07-30T00:46:58Z"
  },
  "references": [
    {
      "url": "https://github.com/socketry/protocol-http1/commit/e11fc164fd2b36f7b7e785e69fa8859eb06bcedd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/socketry/protocol-http1/pull/20",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/socketry/protocol-http1/security/advisories/GHSA-6jwc-qr2q-7xwj",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.rfc-editor.org/rfc/rfc9112#name-chunked-transfer-coding",
      "source": "security-advisories@github.com",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/socketry/protocol-http1/commit/e11fc164fd2b36f7b7e785e69fa8859eb06bcedd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/socketry/protocol-http1/pull/20",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/socketry/protocol-http1/security/advisories/GHSA-6jwc-qr2q-7xwj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.rfc-editor.org/rfc/rfc9112#name-chunked-transfer-coding",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Technical Description"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.297146",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "protocol-http1",
    "owner": "socketry",
    "created_at": "2019-05-07T09:53:10Z",
    "updated_at": "2024-10-15T12:11:48Z",
    "pushed_at": "2024-10-15T12:11:45Z",
    "size": 277,
    "stars": 6,
    "forks": 14,
    "open_issues": 3,
    "watchers": 6,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 68041
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T22:29:33.806471"
  }
}