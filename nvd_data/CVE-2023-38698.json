{
  "cve_id": "CVE-2023-38698",
  "github_data": {
    "repository": "ensdomains/ens-contracts",
    "fix_commit": "e6b136e979084de3761c125142620304173990ca",
    "related_commits": [
      "e6b136e979084de3761c125142620304173990ca",
      "e6b136e979084de3761c125142620304173990ca"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "e6b136e979084de3761c125142620304173990ca",
      "commit_date": "2023-08-01T11:31:49Z",
      "author": {
        "login": "Arachnid",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-rrxv-q8m4-wch3",
        "length": 84,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 692,
        "additions": 517,
        "deletions": 175
      },
      "files": [
        {
          "filename": "contracts/ethregistrar/ETHRegistrarAdmin.sol",
          "status": "added",
          "additions": 125,
          "deletions": 0,
          "patch": "@@ -0,0 +1,125 @@\n+//SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.17;\n+\n+import \"./IBaseRegistrar.sol\";\n+import {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n+import {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\n+import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n+\n+/**\n+ * @dev A proxy contract that wraps new registrar controllers to ensure they don't shorten the duration of registrations by causing an overflow.\n+ */\n+contract ETHRegistrarControllerProxy {\n+    address public immutable controller;\n+    IBaseRegistrar public immutable registrar;\n+\n+    constructor(address _controller, IBaseRegistrar _registrar) {\n+        controller = _controller;\n+        registrar = _registrar;\n+    }\n+\n+    function register(\n+        uint256 id,\n+        address owner,\n+        uint256 duration\n+    ) external returns (uint256) {\n+        require(msg.sender == controller);\n+        require(duration < 365000000 days);\n+        return registrar.register(id, owner, duration);\n+    }\n+\n+    function registerOnly(\n+        uint256 id,\n+        address owner,\n+        uint256 duration\n+    ) external returns (uint256) {\n+        require(msg.sender == controller);\n+        require(duration < 365000000 days);\n+        return registrar.registerOnly(id, owner, duration);\n+    }\n+\n+    function renew(uint256 id, uint256 duration) external returns (uint256) {\n+        require(msg.sender == controller);\n+        require(duration < 365000000 days);\n+        return registrar.renew(id, duration);\n+    }\n+}\n+\n+/**\n+ * @dev Contract to act as the owner of the ETHRegistrar, permitting its owner to make certain changes with additional checks.\n+ *      This was implemented in response to a vulnerability disclosure that would permit the DAO to appoint a malicious controller\n+ *      that shortens the registration period of affected ENS names. This contract exists to prevent that from happening.\n+ */\n+contract ETHRegistrarAdmin is Ownable {\n+    using Address for address;\n+\n+    IBaseRegistrar public immutable registrar;\n+\n+    constructor(address _registrar) {\n+        registrar = IBaseRegistrar(_registrar);\n+    }\n+\n+    /**\n+     * @dev Deploys a controller proxy for the given controller, if one does not already exist.\n+     *      Anyone can call this function, but the proxy will only function if added by an authorized\n+     *      caller using `addController`.\n+     * @param controller The controller contract to create a proxy for.\n+     * @return The address of the controller proxy.\n+     */\n+    function deployControllerProxy(\n+        address controller\n+    ) public returns (address) {\n+        address proxyAddress = getProxyAddress(controller);\n+        if (!proxyAddress.isContract()) {\n+            new ETHRegistrarControllerProxy{salt: bytes32(0)}(\n+                controller,\n+                registrar\n+            );\n+        }\n+        return proxyAddress;\n+    }\n+\n+    /**\n+     * @dev Authorizes a controller proxy to register and renew names on the registrar.\n+     * @param controller The controller contract to authorize.\n+     */\n+    function addController(address controller) external onlyOwner {\n+        deployControllerProxy(controller);\n+        registrar.addController(getProxyAddress(controller));\n+    }\n+\n+    /**\n+     * @dev Deauthorizes a controller proxy.\n+     * @param controller The controller contract to deauthorize.\n+     */\n+    function removeController(address controller) external onlyOwner {\n+        registrar.removeController(getProxyAddress(controller));\n+    }\n+\n+    /**\n+     * @dev Gets the address of the proxy contract for a given controller.\n+     * @param controller The controller contract to get the proxy address for.\n+     * @return The address of the proxy contract.\n+     */\n+    function getProxyAddress(address controller) public view returns (address) {\n+        return\n+            Create2.computeAddress(\n+                bytes32(0),\n+                keccak256(\n+                    abi.encodePacked(\n+                        type(ETHRegistrarControllerProxy).creationCode,\n+                        uint256(uint160(controller)),\n+                        uint256(uint160(address(registrar)))\n+                    )\n+                )\n+            );\n+    }\n+\n+    /**\n+     * @dev Sets the resolver for the TLD this registrar manages.\n+     * @param resolver The address of the resolver to set.\n+     */\n+    function setResolver(address resolver) external onlyOwner {\n+        registrar.setResolver(resolver);\n+    }\n+}"
        },
        {
          "filename": "contracts/ethregistrar/IBaseRegistrar.sol",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -41,6 +41,18 @@ interface IBaseRegistrar is IERC721 {\n         uint256 duration\n     ) external returns (uint256);\n \n+    /**\n+     * @dev Register a name, without modifying the registry.\n+     * @param id The token ID (keccak256 of the label).\n+     * @param owner The address that should own the registration.\n+     * @param duration Duration in seconds for the registration.\n+     */\n+    function registerOnly(\n+        uint256 id,\n+        address owner,\n+        uint256 duration\n+    ) external returns (uint256);\n+\n     function renew(uint256 id, uint256 duration) external returns (uint256);\n \n     /**"
        },
        {
          "filename": "contracts/wrapper/NameWrapperAdmin.sol",
          "status": "added",
          "additions": 213,
          "deletions": 0,
          "patch": "@@ -0,0 +1,213 @@\n+//SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.17;\n+\n+import \"./INameWrapper.sol\";\n+import \"./Controllable.sol\";\n+import {INameWrapperUpgrade} from \"./INameWrapperUpgrade.sol\";\n+import {BytesUtils} from \"./BytesUtils.sol\";\n+import {ENS} from \"../registry/ENS.sol\";\n+import {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n+import {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\n+import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n+\n+/**\n+ * @dev A proxy contract that wraps new name wrapper controllers to ensure they don't shorten the duration of registrations.\n+ */\n+contract NameWrapperControllerProxy {\n+    address public immutable controller;\n+    INameWrapper public immutable wrapper;\n+\n+    constructor(address _controller, INameWrapper _wrapper) {\n+        controller = _controller;\n+        wrapper = _wrapper;\n+    }\n+\n+    /**\n+     * @dev Registers a new .eth second-level domain and wraps it.\n+     *      Only callable by authorised controllers.\n+     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n+     * @param wrappedOwner The owner of the wrapped name.\n+     * @param duration The duration, in seconds, to register the name for.\n+     * @param resolver The resolver address to set on the ENS registry (optional).\n+     * @param ownerControlledFuses Initial owner-controlled fuses to set\n+     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n+     */\n+    function registerAndWrapETH2LD(\n+        string calldata label,\n+        address wrappedOwner,\n+        uint256 duration,\n+        address resolver,\n+        uint16 ownerControlledFuses\n+    ) external returns (uint256 registrarExpiry) {\n+        require(msg.sender == controller);\n+        require(duration < 365000000 days);\n+        return\n+            wrapper.registerAndWrapETH2LD(\n+                label,\n+                wrappedOwner,\n+                duration,\n+                resolver,\n+                ownerControlledFuses\n+            );\n+    }\n+\n+    /**\n+     * @notice Renews a .eth second-level domain.\n+     * @dev Only callable by authorised controllers.\n+     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n+     * @param duration The number of seconds to renew the name for.\n+     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n+     */\n+    function renew(\n+        uint256 tokenId,\n+        uint256 duration\n+    ) external returns (uint256 expires) {\n+        require(msg.sender == controller);\n+        require(duration < 365000000 days);\n+        return wrapper.renew(tokenId, duration);\n+    }\n+}\n+\n+/**\n+ * @dev Contract to act as the owner of the NameWrapper, permitting its owner to make certain changes with additional checks.\n+ *      This was implemented in response to a vulnerability disclosure that would permit the DAO to appoint a malicious controller\n+ *      that shortens the registration period of affected ENS names. This contract exists to prevent that from happening.\n+ */\n+contract NameWrapperAdmin is Ownable, INameWrapperUpgrade {\n+    bytes32 private constant ETH_NODE =\n+        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n+\n+    using BytesUtils for bytes;\n+    using Address for address;\n+\n+    INameWrapper public immutable wrapper;\n+    IBaseRegistrar public immutable registrar;\n+    ENS public immutable ens;\n+    INameWrapperUpgrade public upgradeContract;\n+\n+    constructor(address _wrapper) {\n+        wrapper = INameWrapper(_wrapper);\n+        registrar = wrapper.registrar();\n+        ens = wrapper.ens();\n+    }\n+\n+    /**\n+     * @dev Deploys a controller proxy for the given controller, if one does not already exist.\n+     *      Anyone can call this function, but the proxy will only function if added by an authorized\n+     *      caller using `addController`.\n+     * @param controller The controller contract to create a proxy for.\n+     * @return The address of the controller proxy.\n+     */\n+    function deployControllerProxy(\n+        address controller\n+    ) public returns (address) {\n+        address proxyAddress = getProxyAddress(controller);\n+        if (!proxyAddress.isContract()) {\n+            new NameWrapperControllerProxy{salt: bytes32(0)}(\n+                controller,\n+                wrapper\n+            );\n+        }\n+        return proxyAddress;\n+    }\n+\n+    /**\n+     * @dev Authorizes a controller proxy to register and renew names on the wrapper.\n+     * @param controller The controller contract to authorize.\n+     */\n+    function addController(address controller) external onlyOwner {\n+        deployControllerProxy(controller);\n+        Controllable(address(wrapper)).setController(\n+            getProxyAddress(controller),\n+            true\n+        );\n+    }\n+\n+    /**\n+     * @dev Deauthorizes a controller proxy.\n+     * @param controller The controller contract to deauthorize.\n+     */\n+    function removeController(address controller) external onlyOwner {\n+        Controllable(address(wrapper)).setController(\n+            getProxyAddress(controller),\n+            false\n+        );\n+    }\n+\n+    /**\n+     * @dev Gets the address of the proxy contract for a given controller.\n+     * @param controller The controller contract to get the proxy address for.\n+     * @return The address of the proxy contract.\n+     */\n+    function getProxyAddress(address controller) public view returns (address) {\n+        return\n+            Create2.computeAddress(\n+                bytes32(0),\n+                keccak256(\n+                    abi.encodePacked(\n+                        type(NameWrapperControllerProxy).creationCode,\n+                        uint256(uint160(controller)),\n+                        uint256(uint160(address(wrapper)))\n+                    )\n+                )\n+            );\n+    }\n+\n+    /**\n+     * @notice Set the metadata service. Only the owner can do this\n+     * @param _metadataService The new metadata service\n+     */\n+    function setMetadataService(\n+        IMetadataService _metadataService\n+    ) public onlyOwner {\n+        wrapper.setMetadataService(_metadataService);\n+    }\n+\n+    /**\n+     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n+     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n+     * to make the contract not upgradable.\n+     * @param _upgradeAddress address of an upgraded contract\n+     */\n+    function setUpgradeContract(\n+        INameWrapperUpgrade _upgradeAddress\n+    ) external onlyOwner {\n+        if (address(upgradeContract) == address(0)) {\n+            wrapper.setUpgradeContract(this);\n+        }\n+        upgradeContract = _upgradeAddress;\n+        if (address(upgradeContract) == address(0)) {\n+            wrapper.setUpgradeContract(INameWrapperUpgrade(address(0)));\n+        }\n+    }\n+\n+    function wrapFromUpgrade(\n+        bytes calldata name,\n+        address wrappedOwner,\n+        uint32 fuses,\n+        uint64 expiry,\n+        address approved,\n+        bytes calldata extraData\n+    ) external {\n+        require(msg.sender == address(wrapper));\n+        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n+        bytes32 parentNode = name.namehash(offset);\n+        bytes32 node = keccak256(abi.encodePacked(parentNode, labelhash));\n+        if (parentNode == ETH_NODE) {\n+            registrar.transferFrom(\n+                address(wrapper),\n+                address(upgradeContract),\n+                uint256(labelhash)\n+            );\n+        }\n+        ens.setOwner(node, address(upgradeContract));\n+        upgradeContract.wrapFromUpgrade(\n+            name,\n+            wrappedOwner,\n+            fuses,\n+            expiry,\n+            approved,\n+            extraData\n+        );\n+    }\n+}"
        },
        {
          "filename": "contracts/wrapper/mocks/UpgradedNameWrapperMock.sol",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -43,16 +43,14 @@ contract UpgradedNameWrapperMock is INameWrapperUpgrade {\n         if (parentNode == ETH_NODE) {\n             address registrant = registrar.ownerOf(uint256(labelhash));\n             require(\n-                msg.sender == registrant &&\n-                    registrar.isApprovedForAll(registrant, address(this)),\n-                \"No approval for registrar\"\n+                registrant == address(this),\n+                \"Upgrade contract does not own name in registrar\"\n             );\n         } else {\n             address owner = ens.owner(node);\n             require(\n-                msg.sender == owner &&\n-                    ens.isApprovedForAll(owner, address(this)),\n-                \"No approval for registry\"\n+                owner == address(this),\n+                \"Upgrade contract does not own name in registry\"\n             );\n         }\n         emit NameUpgraded("
        },
        {
          "filename": "test/ethregistrar/TestBaseRegistrar.js",
          "status": "modified",
          "additions": 44,
          "deletions": 15,
          "patch": "@@ -2,6 +2,11 @@ const ENS = artifacts.require('./registry/ENSRegistry')\n const BaseRegistrar = artifacts.require(\n   './registrar/BaseRegistrarImplementation',\n )\n+const ETHRegistrarAdmin = artifacts.require('./registrar/ETHRegistrarAdmin')\n+const ETHRegistrarControllerProxy = artifacts.require(\n+  './registrar/ETHRegistrarControllerProxy',\n+)\n+const { expect } = require('chai')\n \n const namehash = require('eth-ens-namehash')\n const sha3 = require('web3-utils').sha3\n@@ -21,19 +26,33 @@ contract('BaseRegistrar', function (accounts) {\n \n   let ens\n   let registrar\n+  let admin\n+  let controllerProxy\n \n   before(async () => {\n     ens = await ENS.new()\n \n+    // Deploy the registrar\n     registrar = await BaseRegistrar.new(ens.address, namehash.hash('eth'), {\n       from: ownerAccount,\n     })\n-    await registrar.addController(controllerAccount, { from: ownerAccount })\n+\n+    // Deploy the admin contract and transfer ownership to it\n+    admin = await ETHRegistrarAdmin.new(registrar.address)\n+    await registrar.transferOwnership(admin.address)\n+\n+    // Create a new proxy for the controller\n+    await admin.addController(controllerAccount, { from: ownerAccount })\n+    controllerProxy = await ETHRegistrarControllerProxy.at(\n+      await admin.getProxyAddress(controllerAccount),\n+    )\n+\n+    // Set the registrar as owner of .eth\n     await ens.setSubnodeOwner('0x0', sha3('eth'), registrar.address)\n   })\n \n   it('should allow new registrations', async () => {\n-    var tx = await registrar.register(\n+    var tx = await controllerProxy.register(\n       sha3('newname'),\n       registrantAccount,\n       86400,\n@@ -52,7 +71,7 @@ contract('BaseRegistrar', function (accounts) {\n   })\n \n   it('should allow registrations without updating the registry', async () => {\n-    var tx = await registrar.registerOnly(\n+    var tx = await controllerProxy.registerOnly(\n       sha3('silentname'),\n       registrantAccount,\n       86400,\n@@ -69,7 +88,9 @@ contract('BaseRegistrar', function (accounts) {\n \n   it('should allow renewals', async () => {\n     var oldExpires = await registrar.nameExpires(sha3('newname'))\n-    await registrar.renew(sha3('newname'), 86400, { from: controllerAccount })\n+    await controllerProxy.renew(sha3('newname'), 86400, {\n+      from: controllerAccount,\n+    })\n     assert.equal(\n       (await registrar.nameExpires(sha3('newname'))).toNumber(),\n       oldExpires.add(toBN(86400)).toNumber(),\n@@ -78,21 +99,21 @@ contract('BaseRegistrar', function (accounts) {\n \n   it('should only allow the controller to register', async () => {\n     await exceptions.expectFailure(\n-      registrar.register(sha3('foo'), otherAccount, 86400, {\n+      controllerProxy.register(sha3('foo'), otherAccount, 86400, {\n         from: otherAccount,\n       }),\n     )\n   })\n \n   it('should only allow the controller to renew', async () => {\n     await exceptions.expectFailure(\n-      registrar.renew(sha3('newname'), 86400, { from: otherAccount }),\n+      controllerProxy.renew(sha3('newname'), 86400, { from: otherAccount }),\n     )\n   })\n \n   it('should not permit registration of already registered names', async () => {\n     await exceptions.expectFailure(\n-      registrar.register(sha3('newname'), otherAccount, 86400, {\n+      controllerProxy.register(sha3('newname'), otherAccount, 86400, {\n         from: controllerAccount,\n       }),\n     )\n@@ -101,7 +122,7 @@ contract('BaseRegistrar', function (accounts) {\n \n   it('should not permit renewing a name that is not registered', async () => {\n     await exceptions.expectFailure(\n-      registrar.renew(sha3('name3'), 86400, { from: controllerAccount }),\n+      controllerProxy.renew(sha3('name3'), 86400, { from: controllerAccount }),\n     )\n   })\n \n@@ -180,28 +201,36 @@ contract('BaseRegistrar', function (accounts) {\n   })\n \n   it('should allow renewal during the grace period', async () => {\n-    await registrar.renew(sha3('newname'), 86400, { from: controllerAccount })\n+    await controllerProxy.renew(sha3('newname'), 86400, {\n+      from: controllerAccount,\n+    })\n   })\n \n   it('should allow registration of an expired domain', async () => {\n     var ts = (await web3.eth.getBlock('latest')).timestamp\n     var expires = await registrar.nameExpires(sha3('newname'))\n     var grace = await registrar.GRACE_PERIOD()\n     await evm.advanceTime(expires.toNumber() - ts + grace.toNumber() + 3600)\n+    await evm.mine()\n \n-    try {\n-      await registrar.ownerOf(sha3('newname'))\n-      assert.fail('should throw an exception')\n-    } catch (error) {}\n+    await expect(registrar.ownerOf(sha3('newname'))).to.be.reverted\n \n-    await registrar.register(sha3('newname'), otherAccount, 86400, {\n+    await controllerProxy.register(sha3('newname'), otherAccount, 86400, {\n       from: controllerAccount,\n     })\n     assert.equal(await registrar.ownerOf(sha3('newname')), otherAccount)\n   })\n \n   it('should allow the owner to set a resolver address', async () => {\n-    await registrar.setResolver(accounts[1], { from: ownerAccount })\n+    await admin.setResolver(accounts[1], { from: ownerAccount })\n     assert.equal(await ens.resolver(namehash.hash('eth')), accounts[1])\n   })\n+\n+  it('should not allow renewals of longer than 365000000 days', async () => {\n+    await expect(\n+      controllerProxy.renew(sha3('newname'), 365000000 * 86400 + 1, {\n+        from: controllerAccount,\n+      }),\n+    ).to.be.reverted\n+  })\n })"
        },
        {
          "filename": "test/wrapper/NameWrapper.js",
          "status": "modified",
          "additions": 119,
          "deletions": 154,
          "patch": "@@ -9,7 +9,6 @@ const { shouldRespectConstraints } = require('./Constraints.behaviour')\n const { ZERO_ADDRESS } = require('@openzeppelin/test-helpers/src/constants')\n const { deploy } = require('../test-utils/contracts')\n const { EMPTY_BYTES32, EMPTY_ADDRESS } = require('../test-utils/constants')\n-\n const abiCoder = new ethers.utils.AbiCoder()\n \n use(solidity)\n@@ -53,6 +52,8 @@ describe('Name Wrapper', () => {\n   let NameWrapper2\n   let NameWrapperH\n   let NameWrapperUpgraded\n+  let NameWrappperAdmin\n+  let NameWrapperControllerProxy\n   let MetaDataservice\n   let signers\n   let accounts\n@@ -140,6 +141,12 @@ describe('Name Wrapper', () => {\n     NameWrapperH = NameWrapper.connect(signers[2])\n     NameWrapper3 = NameWrapperH\n \n+    NameWrapperAdmin = await deploy('NameWrapperAdmin', NameWrapper.address)\n+    await NameWrapper.transferOwnership(NameWrapperAdmin.address)\n+    NameWrapperControllerProxy = await ethers.getContractFactory(\n+      'NameWrapperControllerProxy',\n+    )\n+\n     NameWrapperUpgraded = await deploy(\n       'UpgradedNameWrapperMock',\n       EnsRegistry.address,\n@@ -978,8 +985,11 @@ describe('Name Wrapper', () => {\n \n       // Register from another address with registerAndWrap()\n       await BaseRegistrar.addController(NameWrapper.address)\n-      await NameWrapper.setController(account, account)\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperAdmin.addController(account)\n+      const NameWrapperProxy = NameWrapperControllerProxy.attach(\n+        await NameWrapperAdmin.getProxyAddress(account),\n+      )\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account2,\n         DAY,\n@@ -1892,105 +1902,41 @@ describe('Name Wrapper', () => {\n     it('Reverts if called by someone that is not the owner', async () => {\n       // Attempt to attack the contract by setting the upgrade contract to themselves\n       await expect(\n-        NameWrapper2.setUpgradeContract(account2),\n+        NameWrapperAdmin.connect(signers[2]).setUpgradeContract(account2),\n       ).to.be.revertedWith('Ownable: caller is not the owner')\n     })\n-    it('Will setApprovalForAll for the upgradeContract addresses in the registrar and registry to true', async () => {\n-      expect(\n-        await BaseRegistrar.isApprovedForAll(\n-          NameWrapper.address,\n-          NameWrapperUpgraded.address,\n-        ),\n-      ).to.equal(false)\n-      expect(\n-        await EnsRegistry.isApprovedForAll(\n-          NameWrapper.address,\n-          NameWrapperUpgraded.address,\n-        ),\n-      ).to.equal(false)\n-\n-      //set the upgradeContract of the NameWrapper contract\n-      await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n-\n-      expect(\n-        await BaseRegistrar.isApprovedForAll(\n-          NameWrapper.address,\n-          NameWrapperUpgraded.address,\n-        ),\n-      ).to.equal(true)\n-      expect(\n-        await EnsRegistry.isApprovedForAll(\n-          NameWrapper.address,\n-          NameWrapperUpgraded.address,\n-        ),\n-      ).to.equal(true)\n-    })\n-    it('Will setApprovalForAll for the old upgradeContract addresses in the registrar and registry to false', async () => {\n+    it('Will set the admin as the upgrade contract when one is set', async () => {\n       //set the upgradeContract of the NameWrapper contract\n-      await NameWrapper.setUpgradeContract(DUMMY_ADDRESS)\n-\n-      expect(\n-        await BaseRegistrar.isApprovedForAll(\n-          NameWrapper.address,\n-          DUMMY_ADDRESS,\n-        ),\n-      ).to.equal(true)\n-      expect(\n-        await EnsRegistry.isApprovedForAll(NameWrapper.address, DUMMY_ADDRESS),\n-      ).to.equal(true)\n-\n-      //set the upgradeContract of the NameWrapper contract\n-      await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+      await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n+      expect(await NameWrapper.upgradeContract()).to.equal(\n+        NameWrapperAdmin.address,\n+      )\n+      expect(await NameWrapperAdmin.upgradeContract()).to.equal(\n+        NameWrapperUpgraded.address,\n+      )\n       expect(\n         await BaseRegistrar.isApprovedForAll(\n           NameWrapper.address,\n           NameWrapperUpgraded.address,\n         ),\n-      ).to.equal(true)\n+      ).to.equal(false)\n       expect(\n         await EnsRegistry.isApprovedForAll(\n           NameWrapper.address,\n           NameWrapperUpgraded.address,\n         ),\n-      ).to.equal(true)\n-\n-      expect(\n-        await BaseRegistrar.isApprovedForAll(\n-          NameWrapper.address,\n-          DUMMY_ADDRESS,\n-        ),\n-      ).to.equal(false)\n-      expect(\n-        await EnsRegistry.isApprovedForAll(NameWrapper.address, DUMMY_ADDRESS),\n       ).to.equal(false)\n     })\n-    it('Will not setApprovalForAll for the new upgrade address if it is the address(0)', async () => {\n+    it('Will unset the admin as the upgrade contract when the upgrade contract is removed', async () => {\n       //set the upgradeContract of the NameWrapper contract\n-      await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n-\n-      expect(\n-        await BaseRegistrar.isApprovedForAll(\n-          NameWrapper.address,\n-          NameWrapperUpgraded.address,\n-        ),\n-      ).to.equal(true)\n-      expect(\n-        await EnsRegistry.isApprovedForAll(\n-          NameWrapper.address,\n-          NameWrapperUpgraded.address,\n-        ),\n-      ).to.equal(true)\n+      await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n       //set the upgradeContract of the NameWrapper contract\n-      await NameWrapper.setUpgradeContract(ZERO_ADDRESS)\n+      await NameWrapperAdmin.setUpgradeContract(ZERO_ADDRESS)\n \n-      expect(\n-        await BaseRegistrar.isApprovedForAll(NameWrapper.address, ZERO_ADDRESS),\n-      ).to.equal(false)\n-      expect(\n-        await EnsRegistry.isApprovedForAll(NameWrapper.address, ZERO_ADDRESS),\n-      ).to.equal(false)\n+      expect(await NameWrapper.upgradeContract()).to.equal(ZERO_ADDRESS)\n+      expect(await NameWrapperAdmin.upgradeContract()).to.equal(ZERO_ADDRESS)\n     })\n   })\n \n@@ -2024,7 +1970,7 @@ describe('Name Wrapper', () => {\n         )\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n         await BaseRegistrar.isApprovedForAll(\n           NameWrapper.address,\n           NameWrapperUpgraded.address,\n@@ -2063,7 +2009,7 @@ describe('Name Wrapper', () => {\n           NameWrapper.address,\n         )\n \n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const tx = await NameWrapper2.upgrade(encodedName, 0)\n \n@@ -2106,13 +2052,16 @@ describe('Name Wrapper', () => {\n           CAN_DO_EVERYTHING,\n           EMPTY_ADDRESS,\n         )\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         expect(await NameWrapper.upgradeContract()).to.equal(\n+          NameWrapperAdmin.address,\n+        )\n+        expect(await NameWrapperAdmin.upgradeContract()).to.equal(\n           NameWrapperUpgraded.address,\n         )\n \n-        await NameWrapper.setUpgradeContract(EMPTY_ADDRESS)\n+        await NameWrapperAdmin.setUpgradeContract(EMPTY_ADDRESS)\n         await expect(NameWrapper.upgrade(encodedName, 0)).to.be.revertedWith(\n           `CannotUpgrade()`,\n         )\n@@ -2132,7 +2081,7 @@ describe('Name Wrapper', () => {\n         )\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const expectedExpiry = (await BaseRegistrar.nameExpires(labelHash)).add(\n           GRACE_PERIOD,\n@@ -2167,7 +2116,7 @@ describe('Name Wrapper', () => {\n           EMPTY_ADDRESS,\n         )\n \n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         await NameWrapper.upgrade(encodedName, 0)\n \n@@ -2192,7 +2141,7 @@ describe('Name Wrapper', () => {\n           EMPTY_ADDRESS,\n         )\n \n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         await NameWrapper.upgrade(encodedName, 0)\n \n@@ -2215,7 +2164,7 @@ describe('Name Wrapper', () => {\n           EMPTY_ADDRESS,\n         )\n \n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const expectedExpiry = (await BaseRegistrar.nameExpires(labelHash)).add(\n           GRACE_PERIOD,\n@@ -2250,7 +2199,7 @@ describe('Name Wrapper', () => {\n         )\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         await expect(NameWrapper2.upgrade(encodedName, 0)).to.be.revertedWith(\n           `Unauthorised(\"${nameHash}\", \"${account2}\")`,\n@@ -2288,7 +2237,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrapped).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const tx = await NameWrapper.upgrade(encodedName, 0)\n \n@@ -2315,7 +2264,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrappedXYZ).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const tx = await NameWrapper2.upgrade(encodeName('to-upgrade.xyz'), 0)\n \n@@ -2374,7 +2323,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrapped).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const tx = await NameWrapper.upgrade(encodeName(name), 0)\n \n@@ -2415,7 +2364,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrapped).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         await NameWrapper.upgrade(encodedName, 0)\n \n@@ -2448,7 +2397,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrapped).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         await NameWrapper.upgrade(encodedName, 0)\n \n@@ -2485,7 +2434,7 @@ describe('Name Wrapper', () => {\n         ).to.equal(account3)\n \n         // set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const tx = await NameWrapper.upgrade(encodeName('to-upgrade.xyz'), '0x')\n         expect(tx)\n@@ -2513,7 +2462,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrappedXYZ).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         const tx = await NameWrapper.upgrade(\n           encodeName('to-upgrade.xyz'),\n@@ -2551,7 +2500,7 @@ describe('Name Wrapper', () => {\n         expect(ownerOfWrappedXYZ).to.equal(account)\n \n         //set the upgradeContract of the NameWrapper contract\n-        await NameWrapper.setUpgradeContract(NameWrapperUpgraded.address)\n+        await NameWrapperAdmin.setUpgradeContract(NameWrapperUpgraded.address)\n \n         await expect(\n           NameWrapper2.upgrade(encodeName('to-upgrade.xyz'), 0),\n@@ -6066,14 +6015,18 @@ describe('Name Wrapper', () => {\n     const label = 'register'\n     const labelHash = labelhash(label)\n     const wrappedTokenId = namehash(label + '.eth')\n+    let NameWrapperProxy\n \n     before(async () => {\n       await BaseRegistrar.addController(NameWrapper.address)\n-      await NameWrapper.setController(account, true)\n+      await NameWrapperAdmin.addController(account)\n+      NameWrapperProxy = NameWrapperControllerProxy.attach(\n+        await NameWrapperAdmin.getProxyAddress(account),\n+      )\n     })\n \n     it('should register and wrap names', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6091,7 +6044,7 @@ describe('Name Wrapper', () => {\n     })\n \n     it('allows specifying a resolver address', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6103,20 +6056,19 @@ describe('Name Wrapper', () => {\n     })\n \n     it('does not allow non controllers to register names', async () => {\n-      await NameWrapper.setController(account, false)\n       await expect(\n-        NameWrapper.registerAndWrapETH2LD(\n+        NameWrapperProxy.connect(signers[2]).registerAndWrapETH2LD(\n           label,\n           account,\n           86400,\n           EMPTY_ADDRESS,\n           CAN_DO_EVERYTHING,\n         ),\n-      ).to.be.revertedWith('Controllable: Caller is not a controller')\n+      ).to.be.reverted\n     })\n \n     it('Transfers the wrapped token to the target address.', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account2,\n         86400,\n@@ -6128,7 +6080,7 @@ describe('Name Wrapper', () => {\n \n     it('Does not allow wrapping with a target address of 0x0', async () => {\n       await expect(\n-        NameWrapper.registerAndWrapETH2LD(\n+        NameWrapperProxy.registerAndWrapETH2LD(\n           label,\n           EMPTY_ADDRESS,\n           86400,\n@@ -6140,7 +6092,7 @@ describe('Name Wrapper', () => {\n \n     it('Does not allow wrapping with a target address of the wrapper contract address.', async () => {\n       await expect(\n-        NameWrapper.registerAndWrapETH2LD(\n+        NameWrapperProxy.registerAndWrapETH2LD(\n           label,\n           NameWrapper.address,\n           86400,\n@@ -6154,7 +6106,7 @@ describe('Name Wrapper', () => {\n \n     it('Does not allows fuse to be burned if CANNOT_UNWRAP has not been burned.', async () => {\n       await expect(\n-        NameWrapper.registerAndWrapETH2LD(\n+        NameWrapperProxy.registerAndWrapETH2LD(\n           label,\n           account,\n           86400,\n@@ -6166,7 +6118,7 @@ describe('Name Wrapper', () => {\n \n     it('Allows fuse to be burned if CANNOT_UNWRAP has been burned and expiry set', async () => {\n       const initialFuses = CANNOT_UNWRAP | CANNOT_SET_RESOLVER\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6178,7 +6130,7 @@ describe('Name Wrapper', () => {\n     })\n \n     it('automatically sets PARENT_CANNOT_CONTROL and IS_DOT_ETH', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6190,13 +6142,14 @@ describe('Name Wrapper', () => {\n     })\n \n     it('Errors when adding a number greater than uint16 for fuses', async () => {\n-      const tx = await NameWrapper.populateTransaction.registerAndWrapETH2LD(\n-        label,\n-        account,\n-        86400,\n-        EMPTY_ADDRESS,\n-        273,\n-      )\n+      const tx =\n+        await NameWrapperProxy.populateTransaction.registerAndWrapETH2LD(\n+          label,\n+          account,\n+          86400,\n+          EMPTY_ADDRESS,\n+          273,\n+        )\n \n       const rogueFuse = '40000' // 2 ** 18 in hex\n       tx.data = tx.data.replace('00111', rogueFuse)\n@@ -6227,7 +6180,7 @@ describe('Name Wrapper', () => {\n \n     it('Will not wrap a name with an empty label', async () => {\n       await expect(\n-        NameWrapper.registerAndWrapETH2LD(\n+        NameWrapperProxy.registerAndWrapETH2LD(\n           '',\n           account,\n           86400,\n@@ -6242,7 +6195,7 @@ describe('Name Wrapper', () => {\n         'yutaioxtcsbzrqhdjmltsdfkgomogohhcchjoslfhqgkuhduhxqsldnurwrrtoicvthwxytonpcidtnkbrhccaozdtoznedgkfkifsvjukxxpkcmgcjprankyzerzqpnuteuegtfhqgzcxqwttyfewbazhyilqhyffufxrookxrnjkmjniqpmntcbrowglgdpkslzechimsaonlcvjkhhvdvkvvuztihobmivifuqtvtwinljslusvhhbwhuhzty'\n       expect(longString.length).to.equal(256)\n       await expect(\n-        NameWrapper.registerAndWrapETH2LD(\n+        NameWrapperProxy.registerAndWrapETH2LD(\n           longString,\n           account,\n           86400,\n@@ -6253,7 +6206,7 @@ describe('Name Wrapper', () => {\n     })\n \n     it('emits Wrap event', async () => {\n-      const tx = await NameWrapper.registerAndWrapETH2LD(\n+      const tx = await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6274,7 +6227,7 @@ describe('Name Wrapper', () => {\n     })\n \n     it('Emits TransferSingle event', async () => {\n-      const tx = await NameWrapper.registerAndWrapETH2LD(\n+      const tx = await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6283,37 +6236,47 @@ describe('Name Wrapper', () => {\n       )\n       await expect(tx)\n         .to.emit(NameWrapper, 'TransferSingle')\n-        .withArgs(account, EMPTY_ADDRESS, account, wrappedTokenId, 1)\n+        .withArgs(\n+          NameWrapperProxy.address,\n+          EMPTY_ADDRESS,\n+          account,\n+          wrappedTokenId,\n+          1,\n+        )\n     })\n   })\n \n   describe('renew()', () => {\n     const label = 'register'\n     const labelHash = labelhash(label)\n     const wrappedTokenId = namehash(label + '.eth')\n+    let NameWrapperProxy\n \n     before(async () => {\n       await BaseRegistrar.addController(NameWrapper.address)\n-      await NameWrapper.setController(account, true)\n+      await NameWrapperAdmin.addController(account)\n+      NameWrapperProxy = NameWrapperControllerProxy.attach(\n+        await NameWrapperAdmin.getProxyAddress(account),\n+      )\n     })\n \n     it('Renews names', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n         EMPTY_ADDRESS,\n         CAN_DO_EVERYTHING,\n       )\n       const expires = await BaseRegistrar.nameExpires(labelHash)\n-      await NameWrapper.renew(labelHash, 86400)\n+      await NameWrapperProxy.renew(labelHash, 86400)\n       expect(await BaseRegistrar.nameExpires(labelHash)).to.equal(\n         expires.toNumber() + 86400,\n       )\n     })\n \n     it('Renews names and can extend wrapper expiry', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         86400,\n@@ -6322,7 +6285,7 @@ describe('Name Wrapper', () => {\n       )\n       const expires = await BaseRegistrar.nameExpires(labelHash)\n       const expectedExpiry = expires.toNumber() + 86400\n-      await NameWrapper.renew(labelHash, 86400)\n+      await NameWrapperProxy.renew(labelHash, 86400)\n       expect(await BaseRegistrar.nameExpires(labelHash)).to.equal(\n         expires.toNumber() + 86400,\n       )\n@@ -6333,7 +6296,7 @@ describe('Name Wrapper', () => {\n     })\n \n     it('Renewing name less than required to unexpire it still has original owner/fuses', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label,\n         account,\n         DAY,\n@@ -6351,7 +6314,7 @@ describe('Name Wrapper', () => {\n       expect(expiryBefore).to.be.at.most(block1.timestamp + GRACE_PERIOD)\n \n       //renew for less than the grace period\n-      await NameWrapper.renew(labelHash, 1 * DAY)\n+      await NameWrapperProxy.renew(labelHash, 1 * DAY)\n \n       const [ownerAfter, fusesAfter, expiryAfter] = await NameWrapper.getData(\n         wrappedTokenId,\n@@ -6367,26 +6330,18 @@ describe('Name Wrapper', () => {\n       // still expired\n       expect(expiryAfter).to.be.at.most(block1.timestamp + GRACE_PERIOD)\n     })\n-  })\n-\n-  describe('Controllable', () => {\n-    it('allows the owner to add and remove controllers', async () => {\n-      const tx = await NameWrapper.setController(account, true)\n-      expect(tx)\n-        .to.emit(NameWrapper, 'ControllerChanged')\n-        .withArgs(account, true)\n-\n-      const tx2 = await NameWrapper.setController(account, false)\n-      expect(tx2)\n-        .to.emit(NameWrapper, 'ControllerChanged')\n-        .withArgs(account, false)\n-    })\n \n-    it('does not allow non-owners to add or remove controllers', async () => {\n-      await NameWrapper.setController(account, true)\n-\n-      await expect(NameWrapper2.setController(account2, true)).to.be.reverted\n-      await expect(NameWrapper2.setController(account, false)).to.be.reverted\n+    it('should not allow renewals of longer than 365000000 days', async () => {\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n+        label,\n+        account,\n+        86400,\n+        EMPTY_ADDRESS,\n+        CAN_DO_EVERYTHING,\n+      )\n+      await expect(\n+        NameWrapperProxy.renew(wrappedTokenId, 365000000 * 86400 + 1),\n+      ).to.be.reverted\n     })\n   })\n \n@@ -6577,7 +6532,7 @@ describe('Name Wrapper', () => {\n     })\n \n     it('owner can set a new MetadataService', async () => {\n-      await NameWrapper.setMetadataService(account2)\n+      await NameWrapperAdmin.setMetadataService(account2)\n       expect(await NameWrapper.metadataService()).to.equal(account2)\n     })\n \n@@ -7065,12 +7020,17 @@ describe('Name Wrapper', () => {\n     const labelHash2 = labelhash('sub2')\n     const wrappedTokenId2 = namehash('sub2.sub1.eth')\n \n+    let NameWrapperProxy\n+\n     before(async () => {\n       await BaseRegistrar.addController(NameWrapper.address)\n-      await NameWrapper.setController(account, true)\n+      await NameWrapperAdmin.addController(account)\n+      NameWrapperProxy = NameWrapperControllerProxy.attach(\n+        await NameWrapperAdmin.getProxyAddress(account),\n+      )\n     })\n     it('Trying to burn child fuses when re-registering a name on the old controller reverts', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label1,\n         hacker,\n         1 * DAY,\n@@ -7123,7 +7083,7 @@ describe('Name Wrapper', () => {\n       ).to.be.revertedWith(`Unauthorised(\"${wrappedTokenId1}\", \"${hacker}\")`)\n     })\n     it('Renewing a wrapped, but expired name .eth in the wrapper, but unexpired on the registrar resyncs expiry', async () => {\n-      await NameWrapper.registerAndWrapETH2LD(\n+      await NameWrapperProxy.registerAndWrapETH2LD(\n         label1,\n         account,\n         1 * DAY,\n@@ -7150,7 +7110,7 @@ describe('Name Wrapper', () => {\n         NameWrapper.address,\n       )\n \n-      await NameWrapper.renew(labelHash1, 1)\n+      await NameWrapperProxy.renew(labelHash1, 1)\n \n       owner = await NameWrapper.ownerOf(wrappedTokenId1)\n       let [, , expiry] = await NameWrapper.getData(wrappedTokenId1)\n@@ -7166,6 +7126,11 @@ describe('Name Wrapper', () => {\n     it('Wraps a name which get stuck forever can be recovered by ROOT owner', async () => {\n       expect(await NameWrapper.ownerOf(namehash('xyz'))).to.equal(EMPTY_ADDRESS)\n \n+      await NameWrapperAdmin.addController(account)\n+      const NameWrapperProxy = NameWrapperControllerProxy.attach(\n+        await NameWrapperAdmin.getProxyAddress(account),\n+      )\n+\n       await EnsRegistry.setApprovalForAll(NameWrapper.address, true)\n       await NameWrapper.wrap(encodeName('xyz'), account, EMPTY_ADDRESS)\n       expect(await NameWrapper.ownerOf(namehash('xyz'))).to.equal(account)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "87d8cc5778d483e2b4094868eec0c0cfc9e36a90",
            "date": "2025-01-17T10:53:13Z",
            "author_login": "talentlessguy"
          },
          {
            "sha": "b1bba63690de6b18736e2c87ef004d26cc3c6293",
            "date": "2025-01-17T10:52:58Z",
            "author_login": "talentlessguy"
          },
          {
            "sha": "3e5752e9785fe0fb0ee24b4e8f9764899f56612a",
            "date": "2025-01-17T09:44:15Z",
            "author_login": "talentlessguy"
          },
          {
            "sha": "4d2a40a932a602d8baa6c7a0b5e375cf0d2c16c9",
            "date": "2025-01-17T09:43:05Z",
            "author_login": "talentlessguy"
          },
          {
            "sha": "dd74fb988d3595a48e24407722e6656c60c41e23",
            "date": "2025-01-17T09:39:00Z",
            "author_login": "talentlessguy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-190",
    "description": "Ethereum Name Service (ENS) is a distributed, open, and extensible naming system based on the Ethereum blockchain. According to the documentation, controllers are allowed to register new domains and extend the expiry of existing domains, but they cannot change the ownership or reduce the expiration time of existing domains. However, a preliminary analysis suggests that an attacker-controlled controller may be able to reduce the expiration time of existing domains due to an integer overflow in the renew function. The vulnerability resides `@ensdomains/ens-contracts` prior to version 0.0.22.\n\nIf successfully exploited, this vulnerability would enable attackers to force the expiration of any ENS record, ultimately allowing them to claim the affected domains for themselves. Currently, it would require a malicious DAO to exploit it. Nevertheless, any vulnerability present in the controllers could potentially render this issue exploitable in the future. An additional concern is the possibility of renewal discounts. Should ENS decide to implement a system that offers unlimited .eth domains for a fixed fee in the future, the vulnerability could become exploitable by any user due to the reduced attack cost.\n\nVersion 0.0.22 contains a patch for this issue. As long as registration cost remains linear or superlinear based on registration duration, or limited to a reasonable maximum (eg, 1 million years), this vulnerability could only be exploited by a malicious DAO. The interim workaround is thus to take no action.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-08-04T18:15:15.637",
    "last_modified": "2024-11-21T08:14:04.707",
    "fix_date": "2023-08-01T11:31:49Z"
  },
  "references": [
    {
      "url": "https://github.com/ensdomains/ens-contracts/blob/master/contracts/ethregistrar/BaseRegistrarImplementation.sol#L171",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/ensdomains/ens-contracts/commit/e6b136e979084de3761c125142620304173990ca",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ensdomains/ens-contracts/security/advisories/GHSA-rrxv-q8m4-wch3",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/ensdomains/ens-contracts/blob/master/contracts/ethregistrar/BaseRegistrarImplementation.sol#L171",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/ensdomains/ens-contracts/commit/e6b136e979084de3761c125142620304173990ca",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ensdomains/ens-contracts/security/advisories/GHSA-rrxv-q8m4-wch3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.297301",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "ens-contracts",
    "owner": "ensdomains",
    "created_at": "2021-05-13T11:25:41Z",
    "updated_at": "2025-01-23T18:29:39Z",
    "pushed_at": "2025-01-17T10:56:12Z",
    "size": 9221,
    "stars": 614,
    "forks": 419,
    "open_issues": 63,
    "watchers": 614,
    "has_security_policy": false,
    "default_branch": "staging",
    "protected_branches": [],
    "languages": {
      "TypeScript": 770772,
      "Solidity": 335069,
      "JavaScript": 2697,
      "Shell": 225
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:06:55.637381"
  }
}