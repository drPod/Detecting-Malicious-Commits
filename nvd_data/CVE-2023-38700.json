{
  "cve_id": "CVE-2023-38700",
  "github_data": {
    "repository": "matrix-org/matrix-appservice-irc",
    "fix_commit": "8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75",
    "related_commits": [
      "8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75",
      "8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75"
    ],
    "patch_url": "https://github.com/matrix-org/matrix-appservice-irc/commit/8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75.patch",
    "fix_commit_details": {
      "sha": "8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75",
      "commit_date": "2023-07-31T08:40:04Z",
      "author": {
        "login": "justinbot",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-c7hh-3v6c-fj4q",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 45,
        "additions": 26,
        "deletions": 19
      },
      "files": [
        {
          "filename": "src/bridge/MatrixHandler.ts",
          "status": "modified",
          "additions": 26,
          "deletions": 19,
          "patch": "@@ -119,16 +119,17 @@ interface CachedEvent {\n }\n \n export class MatrixHandler {\n-    private readonly processingInvitesForRooms: {\n-        [roomIdUserId: string]: Promise<unknown>;\n-    } = {};\n     // maintain a list of room IDs which are being processed invite-wise. This is\n     // required because invites are processed asyncly, so you could get invite->msg\n     // and the message is processed before the room is created.\n+    private readonly processingInvitesForRooms: {\n+        [roomIdUserId: string]: Promise<unknown>;\n+    } = {};\n+    // Map of `roomId-eventId` -> cached event\n     private readonly eventCache: Map<string, CachedEvent> = new Map();\n     private readonly metrics: {[domain: string]: {\n-        [metricName: string]: number;\n-    };} = {};\n+            [metricName: string]: number;\n+        };} = {};\n     private readonly mediaUrl: string;\n     private memberTracker?: StateLookup;\n     private adminHandler: AdminRoomHandler;\n@@ -1048,7 +1049,7 @@ export class MatrixHandler {\n         // special handling for edits\n         if (event.content[\"m.relates_to\"]?.rel_type === \"m.replace\") {\n             const originalEventId = event.content[\"m.relates_to\"].event_id;\n-            let originalBody = this.getCachedEvent(originalEventId)?.body;\n+            let originalBody = this.getCachedEvent(event.room_id, originalEventId)?.body;\n             if (!originalBody) {\n                 try {\n                     // FIXME: this will return the new event rather than the original one\n@@ -1087,11 +1088,15 @@ export class MatrixHandler {\n             body = body.substring(0, nextNewLine);\n         }\n         // Cache events in here so we can refer to them for replies.\n-        this.cacheEvent(event.event_id, {\n-            body: cacheBody,\n-            sender: event.sender,\n-            timestamp: event.origin_server_ts,\n-        });\n+        this.cacheEvent(\n+            event.room_id,\n+            event.event_id,\n+            {\n+                body: cacheBody,\n+                sender: event.sender,\n+                timestamp: event.origin_server_ts,\n+            },\n+        );\n \n         // The client might still be connected, for abundance of safety let's wait.\n         await ircClient.waitForConnected();\n@@ -1268,20 +1273,20 @@ export class MatrixHandler {\n         };\n \n         const REPLY_NAME_MAX_LENGTH = 12;\n-        const eventId = replyEventId;\n         if (!event.content.body) {\n             return null;\n         }\n \n         const rplText = replyText(event.content.body);\n         let rplName: string;\n         let rplSource: string;\n-        let cachedEvent = this.getCachedEvent(eventId);\n+        // Reply must be in the same room as the original event.\n+        let cachedEvent = this.getCachedEvent(event.room_id, replyEventId);\n         if (!cachedEvent) {\n             // Fallback to fetching from the homeserver.\n             try {\n                 const eventContent = await this.ircBridge.getAppServiceBridge().getIntent().getEvent(\n-                    event.room_id, eventId\n+                    event.room_id, replyEventId\n                 );\n                 rplName = eventContent.sender;\n                 if (typeof(eventContent.content.body) !== \"string\") {\n@@ -1296,7 +1301,7 @@ export class MatrixHandler {\n                     rplSource = eventContent.content.body;\n                 }\n                 cachedEvent = {sender: rplName, body: rplSource, timestamp: eventContent.origin_server_ts};\n-                this.cacheEvent(eventId, cachedEvent);\n+                this.cacheEvent(eventContent.room_id, eventContent.event_id, cachedEvent);\n             }\n             catch (err) {\n                 // If we couldn't find the event, then frankly we can't\n@@ -1375,17 +1380,19 @@ export class MatrixHandler {\n         this.metrics[serverDomain] = metricSet;\n     }\n \n-    private cacheEvent(id: string, event: CachedEvent) {\n-        this.eventCache.set(id, event);\n+    private cacheEvent(roomId: string, eventId: string, event: CachedEvent) {\n+        const cacheKey = `${roomId}-${eventId}`;\n+        this.eventCache.set(cacheKey, event);\n \n         if (this.eventCache.size > this.config.eventCacheSize) {\n             const delKey = this.eventCache.entries().next().value[0];\n             this.eventCache.delete(delKey);\n         }\n     }\n \n-    private getCachedEvent(id: string): CachedEvent|undefined {\n-        return this.eventCache.get(id);\n+    private getCachedEvent(roomId: string, eventId: string): CachedEvent|undefined {\n+        const cacheKey = `${roomId}-${eventId}`;\n+        return this.eventCache.get(cacheKey);\n     }\n \n     // EXPORTS"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "062f3ace8b08e86e9f63c004ffdb85942af1b94e",
            "date": "2024-11-14T12:39:22Z",
            "author_login": "tadzik"
          },
          {
            "sha": "b4377c3ebe408d6cbe6ec0308fdf0097f73f5dbf",
            "date": "2024-11-14T09:31:36Z",
            "author_login": "tadzik"
          },
          {
            "sha": "b91b4c88c0ec1c50ccd27fa18f553896e484bb0a",
            "date": "2024-11-12T11:58:31Z",
            "author_login": "tadzik"
          },
          {
            "sha": "dddca422fe2236491327452735cc42343b344dbf",
            "date": "2024-11-12T11:58:02Z",
            "author_login": "tadzik"
          },
          {
            "sha": "7f6c8ea75bea9e92ecc81e2b9b9e877979b0ff01",
            "date": "2024-11-12T09:45:56Z",
            "author_login": "tadzik"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "matrix-appservice-irc is a Node.js IRC bridge for Matrix. Prior to version 1.0.1, it was possible to craft an event such that it would leak part of a targeted message event from another bridged room. This required knowing an event ID to target. Version 1.0.1n fixes this issue. As a workaround, set the `matrixHandler.eventCacheSize` config value to `0`. This workaround may impact performance.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-08-04T19:15:09.697",
    "last_modified": "2024-11-21T08:14:05.010",
    "fix_date": "2023-07-31T08:40:04Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/matrix-appservice-irc/commit/8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-appservice-irc/releases/tag/1.0.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-appservice-irc/security/advisories/GHSA-c7hh-3v6c-fj4q",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-appservice-irc/commit/8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-appservice-irc/releases/tag/1.0.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/matrix-org/matrix-appservice-irc/security/advisories/GHSA-c7hh-3v6c-fj4q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.298114",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "matrix-appservice-irc",
    "owner": "matrix-org",
    "created_at": "2015-03-10T14:42:06Z",
    "updated_at": "2025-01-11T05:33:00Z",
    "pushed_at": "2025-01-08T15:47:53Z",
    "size": 10309,
    "stars": 468,
    "forks": 152,
    "open_issues": 497,
    "watchers": 468,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "TypeScript": 859555,
      "JavaScript": 312817,
      "CSS": 3243,
      "Shell": 2167,
      "Dockerfile": 1168,
      "HTML": 298
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:35:16.048239"
  }
}