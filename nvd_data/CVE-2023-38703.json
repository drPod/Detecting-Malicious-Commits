{
  "cve_id": "CVE-2023-38703",
  "github_data": {
    "repository": "pjsip/pjproject",
    "fix_commit": "6dc9b8c181aff39845f02b4626e0812820d4ef0d",
    "related_commits": [
      "6dc9b8c181aff39845f02b4626e0812820d4ef0d",
      "6dc9b8c181aff39845f02b4626e0812820d4ef0d"
    ],
    "patch_url": "https://github.com/pjsip/pjproject/commit/6dc9b8c181aff39845f02b4626e0812820d4ef0d.patch",
    "fix_commit_details": {
      "sha": "6dc9b8c181aff39845f02b4626e0812820d4ef0d",
      "commit_date": "2023-10-03T02:59:03Z",
      "author": {
        "login": "nanangizz",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-f76w-fh7c-pc66",
        "length": 198,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 285,
        "additions": 226,
        "deletions": 59
      },
      "files": [
        {
          "filename": "pjmedia/include/pjmedia/transport.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -513,6 +513,9 @@ struct pjmedia_transport\n \n     /** Application/user data */\n     void                    *user_data;\n+\n+    /** Group lock, for synchronization between destroy() & callbacks. */\n+    pj_grp_lock_t           *grp_lock;\n };\n \n /**"
        },
        {
          "filename": "pjmedia/src/pjmedia/transport_adapter_sample.c",
          "status": "modified",
          "additions": 25,
          "deletions": 2,
          "patch": "@@ -106,6 +106,9 @@ struct tp_adapter\n };\n \n \n+static void adapter_on_destroy(void *arg);\n+\n+\n /*\n  * Create the adapter.\n  */\n@@ -135,6 +138,15 @@ PJ_DEF(pj_status_t) pjmedia_tp_adapter_create( pjmedia_endpt *endpt,\n     adapter->slave_tp = transport;\n     adapter->del_base = del_base;\n \n+    /* Setup group lock handler for destroy and callback synchronization */\n+    if (transport && transport->grp_lock) {\n+        pj_grp_lock_t *grp_lock = transport->grp_lock;\n+\n+        adapter->base.grp_lock = grp_lock;\n+        pj_grp_lock_add_ref(grp_lock);\n+        pj_grp_lock_add_handler(grp_lock, pool, adapter, &adapter_on_destroy);\n+    }\n+\n     /* Done */\n     *p_tp = &adapter->base;\n     return PJ_SUCCESS;\n@@ -421,6 +433,14 @@ static pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n     return pjmedia_transport_simulate_lost(adapter->slave_tp, dir, pct_lost);\n }\n \n+\n+static void adapter_on_destroy(void *arg)\n+{\n+    struct tp_adapter *adapter = (struct tp_adapter*)arg;\n+\n+    pj_pool_release(adapter->pool);\n+}\n+\n /*\n  * destroy() is called when the transport is no longer needed.\n  */\n@@ -433,8 +453,11 @@ static pj_status_t transport_destroy  (pjmedia_transport *tp)\n         pjmedia_transport_close(adapter->slave_tp);\n     }\n \n-    /* Self destruct.. */\n-    pj_pool_release(adapter->pool);\n+    if (adapter->base.grp_lock) {\n+        pj_grp_lock_dec_ref(adapter->base.grp_lock);\n+    } else {\n+        adapter_on_destroy(tp);\n+    }\n \n     return PJ_SUCCESS;\n }"
        },
        {
          "filename": "pjmedia/src/pjmedia/transport_ice.c",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -338,6 +338,7 @@ PJ_DEF(pj_status_t) pjmedia_ice_create3(pjmedia_endpt *endpt,\n         pj_grp_lock_t *grp_lock = pj_ice_strans_get_grp_lock(tp_ice->ice_st);\n         pj_grp_lock_add_ref(grp_lock);\n         pj_grp_lock_add_handler(grp_lock, pool, tp_ice, &tp_ice_on_destroy);\n+        tp_ice->base.grp_lock = grp_lock;\n     }\n \n     /* Done */\n@@ -2736,6 +2737,8 @@ static pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n static void tp_ice_on_destroy(void *arg)\n {\n     struct transport_ice *tp_ice = (struct transport_ice*)arg;\n+\n+    PJ_LOG(4, (tp_ice->base.name, \"ICE transport destroyed\"));\n     pj_pool_safe_release(&tp_ice->pool);\n }\n \n@@ -2746,6 +2749,8 @@ static pj_status_t transport_destroy(pjmedia_transport *tp)\n {\n     struct transport_ice *tp_ice = (struct transport_ice*)tp;\n \n+    PJ_LOG(4, (tp_ice->base.name, \"Destroying ICE transport\"));\n+\n     /* Reset callback and user data */\n     pj_bzero(&tp_ice->cb, sizeof(tp_ice->cb));\n     tp_ice->base.user_data = NULL;"
        },
        {
          "filename": "pjmedia/src/pjmedia/transport_loop.c",
          "status": "modified",
          "additions": 30,
          "deletions": 3,
          "patch": "@@ -130,6 +130,7 @@ static pjmedia_transport_op transport_udp_op =\n     &transport_attach2\n };\n \n+static void tp_loop_on_destroy(void *arg);\n \n /**\n  * Initialize loopback media transport setting with its default values.\n@@ -164,6 +165,8 @@ pjmedia_transport_loop_create2(pjmedia_endpt *endpt,\n {\n     struct transport_loop *tp;\n     pj_pool_t *pool;\n+    pj_grp_lock_t *grp_lock;\n+    pj_status_t status;\n \n     /* Sanity check */\n     PJ_ASSERT_RETURN(endpt && p_tp, PJ_EINVAL);\n@@ -179,6 +182,14 @@ pjmedia_transport_loop_create2(pjmedia_endpt *endpt,\n     tp->base.op = &transport_udp_op;\n     tp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n \n+    /* Create group lock */\n+    status = pj_grp_lock_create(pool, NULL, &grp_lock);\n+    if (status != PJ_SUCCESS)\n+        return status;\n+\n+    pj_grp_lock_add_ref(grp_lock);\n+    pj_grp_lock_add_handler(grp_lock, pool, tp, &tp_loop_on_destroy);\n+\n     if (opt) {\n         tp->setting = *opt;\n     } else {\n@@ -222,17 +233,25 @@ PJ_DEF(pj_status_t) pjmedia_transport_loop_disable_rx( pjmedia_transport *tp,\n     return PJ_ENOTFOUND;\n }\n \n+\n+static void tp_loop_on_destroy(void *arg)\n+{\n+    struct transport_loop *loop = (struct transport_loop*) arg;\n+\n+    PJ_LOG(4, (loop->base.name, \"Loop transport destroyed\"));\n+    pj_pool_release(loop->pool);\n+}\n+\n+\n /**\n  * Close loopback transport.\n  */\n static pj_status_t transport_destroy(pjmedia_transport *tp)\n {\n-    struct transport_loop *loop = (struct transport_loop*) tp;\n-\n     /* Sanity check */\n     PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n \n-    pj_pool_release(loop->pool);\n+    pj_grp_lock_dec_ref(tp->grp_lock);\n \n     return PJ_SUCCESS;\n }\n@@ -378,6 +397,8 @@ static pj_status_t transport_send_rtp( pjmedia_transport *tp,\n         }\n     }\n \n+    pj_grp_lock_add_ref(tp->grp_lock);\n+\n     /* Distribute to users */\n     for (i=0; i<loop->user_cnt; ++i) {\n         if (loop->users[i].rx_disabled) continue;\n@@ -395,6 +416,8 @@ static pj_status_t transport_send_rtp( pjmedia_transport *tp,\n         }\n     }\n \n+    pj_grp_lock_dec_ref(tp->grp_lock);\n+\n     return PJ_SUCCESS;\n }\n \n@@ -420,13 +443,17 @@ static pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n     PJ_UNUSED_ARG(addr_len);\n     PJ_UNUSED_ARG(addr);\n \n+    pj_grp_lock_add_ref(tp->grp_lock);\n+\n     /* Distribute to users */\n     for (i=0; i<loop->user_cnt; ++i) {\n         if (!loop->users[i].rx_disabled && loop->users[i].rtcp_cb)\n             (*loop->users[i].rtcp_cb)(loop->users[i].user_data, (void*)pkt,\n                                       size);\n     }\n \n+    pj_grp_lock_dec_ref(tp->grp_lock);\n+\n     return PJ_SUCCESS;\n }\n "
        },
        {
          "filename": "pjmedia/src/pjmedia/transport_srtp.c",
          "status": "modified",
          "additions": 44,
          "deletions": 5,
          "patch": "@@ -434,6 +434,8 @@ static pj_status_t create_srtp_ctx(transport_srtp *srtp,\n /* Destroy SRTP context */\n static void destroy_srtp_ctx(transport_srtp *p_srtp, srtp_context *ctx);\n \n+/* SRTP destroy handler */\n+static void srtp_on_destroy(void *arg);\n \n /* This function may also be used by other module, e.g: pjmedia/errno.c,\n  * it should have C compatible declaration.\n@@ -805,6 +807,13 @@ PJ_DEF(pj_status_t) pjmedia_transport_srtp_create(\n     /* Set underlying transport */\n     srtp->member_tp = tp;\n \n+    /* Setup group lock handler for destroy and callback synchronization */\n+    if (tp && tp->grp_lock) {\n+        srtp->base.grp_lock = tp->grp_lock;\n+        pj_grp_lock_add_ref(tp->grp_lock);\n+        pj_grp_lock_add_handler(tp->grp_lock, pool, srtp, &srtp_on_destroy);\n+    }\n+\n     /* Initialize peer's SRTP usage mode. */\n     srtp->peer_use = srtp->setting.use;\n \n@@ -839,6 +848,8 @@ PJ_DEF(pj_status_t) pjmedia_transport_srtp_create(\n     /* Done */\n     *p_tp = &srtp->base;\n \n+    PJ_LOG(4, (srtp->pool->obj_name, \"SRTP transport created\"));\n+\n     return PJ_SUCCESS;\n }\n \n@@ -1459,6 +1470,19 @@ static pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n     return pjmedia_transport_simulate_lost(srtp->member_tp, dir, pct_lost);\n }\n \n+\n+/* SRTP real destroy */\n+static void srtp_on_destroy(void *arg)\n+{\n+    transport_srtp *srtp = (transport_srtp*)arg;\n+\n+    PJ_LOG(4, (srtp->pool->obj_name, \"SRTP transport destroyed\"));\n+\n+    pj_lock_destroy(srtp->mutex);\n+    pj_pool_safe_release(&srtp->pool);\n+}\n+\n+\n static pj_status_t transport_destroy  (pjmedia_transport *tp)\n {\n     transport_srtp *srtp = (transport_srtp *) tp;\n@@ -1467,6 +1491,8 @@ static pj_status_t transport_destroy  (pjmedia_transport *tp)\n \n     PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n \n+    PJ_LOG(4, (srtp->pool->obj_name, \"Destroying SRTP transport\"));\n+\n     /* Close all keying. Note that any keying should not be destroyed before\n      * SRTP transport is destroyed as re-INVITE may initiate new keying method\n      * without destroying SRTP transport.\n@@ -1481,12 +1507,25 @@ static pj_status_t transport_destroy  (pjmedia_transport *tp)\n \n     status = pjmedia_transport_srtp_stop(tp);\n \n-    /* In case mutex is being acquired by other thread */\n-    pj_lock_acquire(srtp->mutex);\n-    pj_lock_release(srtp->mutex);\n+    if (srtp->base.grp_lock) {\n+        pj_grp_lock_dec_ref(srtp->base.grp_lock);\n+    } else {\n+        /* Only get here when the underlying transport does not have\n+         * a group lock, race condition with callbacks may occur.\n+         * Currently UDP, ICE, and loop have a group lock already.\n+         */\n+        PJ_LOG(4,(srtp->pool->obj_name,\n+                  \"Warning: underlying transport does not have group lock\"));\n \n-    pj_lock_destroy(srtp->mutex);\n-    pj_pool_release(srtp->pool);\n+        /* In case mutex is being acquired by other thread.\n+         * An effort to synchronize destroy() & callbacks when the underlying\n+         * transport does not provide a group lock.\n+         */\n+        pj_lock_acquire(srtp->mutex);\n+        pj_lock_release(srtp->mutex);\n+\n+        srtp_on_destroy(srtp);\n+    }\n \n     return status;\n }"
        },
        {
          "filename": "pjmedia/src/pjmedia/transport_srtp_dtls.c",
          "status": "modified",
          "additions": 96,
          "deletions": 41,
          "patch": "@@ -80,6 +80,8 @@ static void on_ice_complete2(pjmedia_transport *tp,\n                              pj_status_t status,\n                              void *user_data);\n \n+static void dtls_on_destroy(void *arg);\n+\n \n static pjmedia_transport_op dtls_op =\n {\n@@ -134,6 +136,7 @@ typedef struct dtls_srtp\n     pj_bool_t            pending_start;     /* media_start() invoked but DTLS\n                                                nego not done yet, so start\n                                                the SRTP once the nego done  */\n+    pj_bool_t            is_destroying;     /* DTLS being destroyed?        */\n     pj_bool_t            got_keys;          /* DTLS nego done & keys ready  */\n     pjmedia_srtp_crypto  tx_crypto[NUM_CHANNEL];\n     pjmedia_srtp_crypto  rx_crypto[NUM_CHANNEL];\n@@ -269,7 +272,7 @@ static pj_status_t dtls_create(transport_srtp *srtp,\n {\n     dtls_srtp *ds;\n     pj_pool_t *pool;\n-\tpj_status_t status;\n+    pj_status_t status;\n \n     pool = pj_pool_create(srtp->pool->factory, \"dtls%p\",\n                           2000, 256, NULL);\n@@ -282,17 +285,44 @@ static pj_status_t dtls_create(transport_srtp *srtp,\n     ds->base.user_data = srtp;\n     ds->srtp = srtp;\n \n-    status = pj_lock_create_simple_mutex(ds->pool, \"dtls_ssl_lock%p\",\n-                                         &ds->ossl_lock);\n-    if (status != PJ_SUCCESS)\n-        return status;\n+    /* Setup group lock handler for destroy and callback synchronization */\n+    if (srtp->base.grp_lock) {\n+        pj_grp_lock_t *grp_lock = srtp->base.grp_lock;\n+\n+        ds->base.grp_lock = grp_lock;\n+        pj_grp_lock_add_ref(grp_lock);\n+        pj_grp_lock_add_handler(grp_lock, pool, ds, &dtls_on_destroy);\n+    } else {\n+        status = pj_lock_create_simple_mutex(ds->pool, \"dtls_ssl_lock%p\",\n+                                             &ds->ossl_lock);\n+        if (status != PJ_SUCCESS)\n+            return status;\n+    }\n \n     *p_keying = &ds->base;\n     PJ_LOG(5,(srtp->pool->obj_name, \"SRTP keying DTLS-SRTP created\"));\n     return PJ_SUCCESS;\n }\n \n \n+/* Lock/unlock for DTLS states access protection */\n+\n+static void DTLS_LOCK(dtls_srtp *ds) {\n+    if (ds->base.grp_lock)\n+        pj_grp_lock_acquire(ds->base.grp_lock);\n+    else\n+        pj_lock_acquire(ds->ossl_lock);\n+}\n+\n+\n+static void DTLS_UNLOCK(dtls_srtp *ds) {\n+    if (ds->base.grp_lock)\n+        pj_grp_lock_release(ds->base.grp_lock);\n+    else\n+        pj_lock_release(ds->ossl_lock);\n+}\n+\n+\n /**\n  * Mapping from OpenSSL error codes to pjlib error space.\n  */\n@@ -545,7 +575,7 @@ static pj_status_t ssl_create(dtls_srtp *ds, unsigned idx)\n /* Destroy SSL context and instance */\n static void ssl_destroy(dtls_srtp *ds, unsigned idx)\n {\n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n \n     /* Destroy SSL instance */\n     if (ds->ossl_ssl[idx]) {\n@@ -570,7 +600,7 @@ static void ssl_destroy(dtls_srtp *ds, unsigned idx)\n         ds->ossl_ctx[idx] = NULL;\n     }\n \n-    pj_lock_release(ds->ossl_lock);\n+    DTLS_UNLOCK(ds);\n }\n \n static pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n@@ -581,7 +611,7 @@ static pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n     pjmedia_srtp_crypto *tx, *rx;\n     pj_status_t status = PJ_SUCCESS;\n \n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n \n     if (!ds->ossl_ssl[idx]) {\n         status = PJ_EGONE;\n@@ -652,7 +682,7 @@ static pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n     }\n \n on_return:\n-    pj_lock_release(ds->ossl_lock);\n+    DTLS_UNLOCK(ds);\n     return status;\n }\n \n@@ -676,16 +706,16 @@ static pj_status_t ssl_match_fingerprint(dtls_srtp *ds, unsigned idx)\n         return PJ_ENOTSUP;\n     }\n \n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n     if (!ds->ossl_ssl[idx]) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_EGONE;\n     }\n \n     /* Get remote cert & calculate the hash */\n     rem_cert = SSL_get_peer_certificate(ds->ossl_ssl[idx]);\n \n-    pj_lock_release(ds->ossl_lock);\n+    DTLS_UNLOCK(ds);\n \n     if (!rem_cert)\n         return PJMEDIA_SRTP_DTLS_EPEERNOCERT;\n@@ -748,10 +778,10 @@ static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n     pj_size_t len;\n     pj_status_t status = PJ_SUCCESS;\n \n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n \n     if (!ds->ossl_wbio[idx]) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_EGONE;\n     }\n \n@@ -760,7 +790,7 @@ static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n         /* Yes, get and send it */\n         len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n         if (len > 0) {\n-            pj_lock_release(ds->ossl_lock);\n+            DTLS_UNLOCK(ds);\n \n             status = send_raw(ds, idx, ds->buf[idx], len);\n             if (status != PJ_SUCCESS) {\n@@ -771,20 +801,20 @@ static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n                  * its packet when not receiving from us.\n                  */\n             }\n-            pj_lock_acquire(ds->ossl_lock);\n+            DTLS_LOCK(ds);\n         }\n     }\n \n     if (!ds->ossl_ssl[idx]) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_EGONE;\n     }\n \n     /* Just return if handshake completion procedure (key parsing, fingerprint\n      * verification, etc) has been done or handshake is still in progress.\n      */\n     if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_SUCCESS;\n     }\n \n@@ -793,7 +823,7 @@ static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n     PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                              CHANNEL_TO_STRING(idx)));\n \n-    pj_lock_release(ds->ossl_lock);\n+    DTLS_UNLOCK(ds);\n \n     /* Stop the retransmission clock. Note that the clock may not be stopped\n      * if this function is called from clock thread context. We'll try again\n@@ -867,18 +897,18 @@ static void clock_cb(const pj_timestamp *ts, void *user_data)\n \n     PJ_UNUSED_ARG(ts);\n \n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n \n     if (!ds->ossl_ssl[idx]) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return;\n     }\n \n     if (DTLSv1_handle_timeout(ds->ossl_ssl[idx]) > 0) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         ssl_flush_wbio(ds, idx);\n     } else {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n     }\n }\n \n@@ -889,18 +919,18 @@ static pj_status_t ssl_handshake_channel(dtls_srtp *ds, unsigned idx)\n     pj_status_t status;\n     int err;\n \n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n \n     /* Init DTLS (if not yet) */\n     status = ssl_create(ds, idx);\n     if (status != PJ_SUCCESS) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return status;\n     }\n \n     /* Check if handshake has been initiated or even completed */\n     if (ds->nego_started[idx] || SSL_is_init_finished(ds->ossl_ssl[idx])) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_SUCCESS;\n     }\n \n@@ -914,7 +944,7 @@ static pj_status_t ssl_handshake_channel(dtls_srtp *ds, unsigned idx)\n     if (err < 0) {\n         err = SSL_get_error(ds->ossl_ssl[idx], err);\n \n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n \n         if (err == SSL_ERROR_WANT_READ) {\n             status = ssl_flush_wbio(ds, idx);\n@@ -927,7 +957,7 @@ static pj_status_t ssl_handshake_channel(dtls_srtp *ds, unsigned idx)\n             goto on_return;\n         }\n     } else {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n     }\n \n     /* Create and start clock @4Hz for retransmission */\n@@ -1135,10 +1165,10 @@ static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n     char tmp[128];\n     pj_size_t nwritten;\n \n-    pj_lock_acquire(ds->ossl_lock);\n+    DTLS_LOCK(ds);\n \n     if (!ds->ossl_rbio[idx]) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_EGONE;\n     }\n \n@@ -1150,12 +1180,12 @@ static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n #if DTLS_DEBUG\n         pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n #endif\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return status;\n     }\n \n     if (!ds->ossl_ssl[idx]) {\n-        pj_lock_release(ds->ossl_lock);\n+        DTLS_UNLOCK(ds);\n         return PJ_EGONE;\n     }\n \n@@ -1172,7 +1202,7 @@ static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n         }\n     }\n \n-    pj_lock_release(ds->ossl_lock);\n+    DTLS_UNLOCK(ds);\n \n     /* Flush anything pending in the write BIO */\n     return ssl_flush_wbio(ds, idx);\n@@ -1211,14 +1241,18 @@ static pj_status_t dtls_on_recv(pjmedia_transport *tp, unsigned idx,\n {\n     dtls_srtp *ds = (dtls_srtp*)tp;\n \n+    DTLS_LOCK(ds);\n+\n     /* Destroy the retransmission clock if handshake has been completed. */\n     if (ds->clock[idx] && ds->nego_completed[idx]) {\n         pjmedia_clock_destroy(ds->clock[idx]);\n         ds->clock[idx] = NULL;\n     }\n \n-    if (size < 1 || !IS_DTLS_PKT(pkt, size))\n+    if (size < 1 || !IS_DTLS_PKT(pkt, size) || ds->is_destroying) {\n+        DTLS_UNLOCK(ds);\n         return PJ_EIGNORED;\n+    }\n \n #if DTLS_DEBUG\n     PJ_LOG(2,(ds->base.name, \"DTLS-SRTP %s receiving %lu bytes\",\n@@ -1258,8 +1292,10 @@ static pj_status_t dtls_on_recv(pjmedia_transport *tp, unsigned idx,\n             }\n \n             status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n-            if (status != PJ_SUCCESS)\n+            if (status != PJ_SUCCESS) {\n+                DTLS_UNLOCK(ds);\n                 return status;\n+            }\n \n #if DTLS_DEBUG\n             {\n@@ -1283,12 +1319,17 @@ static pj_status_t dtls_on_recv(pjmedia_transport *tp, unsigned idx,\n         pj_status_t status;\n         ds->setup = DTLS_SETUP_PASSIVE;\n         status = ssl_handshake_channel(ds, idx);\n-        if (status != PJ_SUCCESS)\n+        if (status != PJ_SUCCESS) {\n+            DTLS_UNLOCK(ds);\n             return status;\n+        }\n     }\n \n     /* Send it to OpenSSL */\n     ssl_on_recv_packet(ds, idx, pkt, size);\n+\n+    DTLS_UNLOCK(ds);\n+\n     return PJ_SUCCESS;\n }\n \n@@ -1821,6 +1862,15 @@ static void dtls_destroy_channel(dtls_srtp *ds, unsigned idx)\n     ssl_destroy(ds, idx);\n }\n \n+static void dtls_on_destroy(void *arg) {\n+    dtls_srtp *ds = (dtls_srtp *)arg;\n+\n+    if (ds->ossl_lock)\n+        pj_lock_destroy(ds->ossl_lock);\n+\n+    pj_pool_safe_release(&ds->pool);\n+}\n+\n static pj_status_t dtls_destroy(pjmedia_transport *tp)\n {\n     dtls_srtp *ds = (dtls_srtp *)tp;\n@@ -1829,15 +1879,20 @@ static pj_status_t dtls_destroy(pjmedia_transport *tp)\n     PJ_LOG(2,(ds->base.name, \"dtls_destroy()\"));\n #endif\n \n+    ds->is_destroying = PJ_TRUE;\n+\n+    DTLS_LOCK(ds);\n+\n     dtls_destroy_channel(ds, RTP_CHANNEL);\n     dtls_destroy_channel(ds, RTCP_CHANNEL);\n \n-    if (ds->ossl_lock) {\n-        pj_lock_destroy(ds->ossl_lock);\n-        ds->ossl_lock = NULL;\n-    }\n+    DTLS_UNLOCK(ds);\n \n-    pj_pool_safe_release(&ds->pool);\n+    if (ds->base.grp_lock) {\n+        pj_grp_lock_dec_ref(ds->base.grp_lock);\n+    } else {\n+        dtls_on_destroy(tp);\n+    }\n \n     return PJ_SUCCESS;\n }"
        },
        {
          "filename": "pjmedia/src/pjmedia/transport_udp.c",
          "status": "modified",
          "additions": 23,
          "deletions": 8,
          "patch": "@@ -298,6 +298,7 @@ PJ_DEF(pj_status_t) pjmedia_transport_udp_attach( pjmedia_endpt *endpt,\n     pj_pool_t *pool;\n     pj_ioqueue_t *ioqueue;\n     pj_ioqueue_callback rtp_cb, rtcp_cb;\n+    pj_grp_lock_t *grp_lock;\n     pj_status_t status;\n \n \n@@ -348,18 +349,29 @@ PJ_DEF(pj_status_t) pjmedia_transport_udp_attach( pjmedia_endpt *endpt,\n                   pj_sockaddr_get_addr_len(&tp->rtp_addr_name));\n     }\n \n+    /* Create group lock */\n+    status = pj_grp_lock_create(pool, NULL, &grp_lock);\n+    if (status != PJ_SUCCESS)\n+        goto on_error;\n+\n+    pj_grp_lock_add_ref(grp_lock);\n+    tp->base.grp_lock = grp_lock;\n+\n     /* Setup RTP socket with the ioqueue */\n     pj_bzero(&rtp_cb, sizeof(rtp_cb));\n     rtp_cb.on_read_complete = &on_rx_rtp;\n     rtp_cb.on_write_complete = &on_rtp_data_sent;\n \n-    status = pj_ioqueue_register_sock(pool, ioqueue, tp->rtp_sock, tp,\n-                                      &rtp_cb, &tp->rtp_key);\n+    status = pj_ioqueue_register_sock2(pool, ioqueue, tp->rtp_sock, grp_lock,\n+                                       tp, &rtp_cb, &tp->rtp_key);\n     if (status != PJ_SUCCESS)\n         goto on_error;\n     \n     /* Disallow concurrency so that detach() and destroy() are\n      * synchronized with the callback.\n+     *\n+     * Note that we still need this even after group lock is added to\n+     * maintain the above behavior.\n      */\n     status = pj_ioqueue_set_concurrency(tp->rtp_key, PJ_FALSE);\n     if (status != PJ_SUCCESS)\n@@ -388,8 +400,8 @@ PJ_DEF(pj_status_t) pjmedia_transport_udp_attach( pjmedia_endpt *endpt,\n     pj_bzero(&rtcp_cb, sizeof(rtcp_cb));\n     rtcp_cb.on_read_complete = &on_rx_rtcp;\n \n-    status = pj_ioqueue_register_sock(pool, ioqueue, tp->rtcp_sock, tp,\n-                                      &rtcp_cb, &tp->rtcp_key);\n+    status = pj_ioqueue_register_sock2(pool, ioqueue, tp->rtcp_sock, grp_lock,\n+                                       tp, &rtcp_cb, &tp->rtcp_key);\n     if (status != PJ_SUCCESS)\n         goto on_error;\n \n@@ -436,12 +448,13 @@ static pj_status_t transport_destroy(pjmedia_transport *tp)\n \n     /* Must not close while application is using this */\n     //PJ_ASSERT_RETURN(!udp->attached, PJ_EINVALIDOP);\n-    \n+\n+    /* The following calls to pj_ioqueue_unregister() will block the execution\n+     * if callback is still being called because allow_concurrent is false.\n+     * So it is safe to release the pool immediately after.\n+     */\n \n     if (udp->rtp_key) {\n-        /* This will block the execution if callback is still\n-         * being called.\n-         */\n         pj_ioqueue_unregister(udp->rtp_key);\n         udp->rtp_key = NULL;\n         udp->rtp_sock = PJ_INVALID_SOCKET;\n@@ -459,6 +472,8 @@ static pj_status_t transport_destroy(pjmedia_transport *tp)\n         udp->rtcp_sock = PJ_INVALID_SOCKET;\n     }\n \n+    pj_grp_lock_dec_ref(tp->grp_lock);\n+\n     PJ_LOG(4,(udp->base.name, \"UDP media transport destroyed\"));\n     pj_pool_release(udp->pool);\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d8795bab62d6f99303b587f9d21d7e53cf2e5b10",
            "date": "2025-01-14T02:17:11Z",
            "author_login": "sauwming"
          },
          {
            "sha": "90293ccc52ea16c5d0e2f5c81768a59b4fc10481",
            "date": "2025-01-13T13:47:33Z",
            "author_login": "sauwming"
          },
          {
            "sha": "b955e8f925c3a932d07fe6d21b23ef33703b0ab8",
            "date": "2025-01-13T08:00:34Z",
            "author_login": "sauwming"
          },
          {
            "sha": "2d4b94a74e2738a174aa7c4cc2fe022620b67132",
            "date": "2025-01-10T09:49:42Z",
            "author_login": "bennylp"
          },
          {
            "sha": "6853491ade9b816b948c09ffe87c9e3aad5a5719",
            "date": "2025-01-10T03:58:44Z",
            "author_login": "nanangizz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-416",
    "description": "PJSIP is a free and open source multimedia communication library written in C with high level API in C, C++, Java, C#, and Python languages. SRTP is a higher level media transport which is stacked upon a lower level media transport such as UDP and ICE. Currently a higher level transport is not synchronized with its lower level transport that may introduce use-after-free issue. This vulnerability affects applications that have SRTP capability (`PJMEDIA_HAS_SRTP` is set) and use underlying media transport other than UDP. This vulnerability\u2019s impact may range from unexpected application termination to control flow hijack/memory corruption. The patch is available as a commit in the master branch.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-06T14:15:12.020",
    "last_modified": "2024-11-21T08:14:05.403",
    "fix_date": "2023-10-03T02:59:03Z"
  },
  "references": [
    {
      "url": "https://github.com/pjsip/pjproject/commit/6dc9b8c181aff39845f02b4626e0812820d4ef0d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-f76w-fh7c-pc66",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00019.html",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pjsip/pjproject/commit/6dc9b8c181aff39845f02b4626e0812820d4ef0d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-f76w-fh7c-pc66",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00019.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.580368",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "pjproject",
    "owner": "pjsip",
    "created_at": "2016-01-24T05:00:33Z",
    "updated_at": "2025-01-14T02:17:17Z",
    "pushed_at": "2025-01-14T02:17:16Z",
    "size": 45263,
    "stars": 2158,
    "forks": 806,
    "open_issues": 9,
    "watchers": 2158,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 15266807,
      "C++": 1658301,
      "Python": 553465,
      "Shell": 394887,
      "Objective-C": 326996,
      "C#": 141563,
      "Makefile": 115036,
      "Java": 114622,
      "Mathematica": 86105,
      "SWIG": 41289,
      "Swift": 38034,
      "CSS": 21213,
      "Kotlin": 17696,
      "Rust": 4860,
      "Objective-C++": 3801,
      "HTML": 3320,
      "QMake": 3180,
      "Batchfile": 1805,
      "QML": 1121,
      "Pan": 288,
      "Prolog": 25
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:52:01.488842"
  }
}