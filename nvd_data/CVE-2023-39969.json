{
  "cve_id": "CVE-2023-39969",
  "github_data": {
    "repository": "trailofbits/uthenticode",
    "fix_commit": "8670b7bb9154d79c276483dcb7c9e9fd5e66455b",
    "related_commits": [
      "8670b7bb9154d79c276483dcb7c9e9fd5e66455b",
      "8670b7bb9154d79c276483dcb7c9e9fd5e66455b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "8670b7bb9154d79c276483dcb7c9e9fd5e66455b",
      "commit_date": "2023-08-02T19:46:44Z",
      "author": {
        "login": "woodruffw",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix hashing (#84)",
        "length": 1009,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 204,
        "additions": 142,
        "deletions": 62
      },
      "files": [
        {
          "filename": "src/include/uthenticode.h",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -286,11 +286,14 @@ std::vector<Checksum> get_checksums(peparse::parsed_pe *pe);\n /**\n  * Calculates the requested message digest for the given `parsed_pe`.\n  *\n+ * `parsed_pe` must contain a security directory; calculating the checksum\n+ * of a \"bare\" PE is not supported.\n+ *\n  * @param  pe   the `peparse::parsed_pe` to hash\n  * @param  kind the kind of message digest to calculate\n- * @return      the resulting digest, or an empty string on failure\n+ * @return      the resulting digest, or `std::nullopt` on failure\n  */\n-std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind);\n+std::optional<std::string> calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind);\n \n /**\n  * Verifies the given `parsed_pe`."
        },
        {
          "filename": "src/svcli/svcli.cpp",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -53,7 +53,12 @@ int main(int argc, char const *argv[]) {\n   std::array<checksum_kind, 3> kinds = {\n       checksum_kind::MD5, checksum_kind::SHA1, checksum_kind::SHA256};\n   for (const auto &kind : kinds) {\n-    std::cout << std::setw(6) << kind << \": \" << uthenticode::calculate_checksum(pe, kind) << '\\n';\n+    auto cksum = uthenticode::calculate_checksum(pe, kind);\n+    if (cksum.has_value()) {\n+      std::cout << std::setw(6) << kind << \": \" << cksum.value() << '\\n';\n+    } else {\n+      std::cout << std::setw(6) << kind << \": NONE (not signed)\\n\";\n+    }\n   }\n   std::cout << '\\n';\n "
        },
        {
          "filename": "src/uthenticode.cpp",
          "status": "modified",
          "additions": 72,
          "deletions": 30,
          "patch": "@@ -470,12 +470,19 @@ std::vector<Checksum> get_checksums(peparse::parsed_pe *pe) {\n   return checksums;\n }\n \n-std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {\n+std::optional<std::string> calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {\n   auto nid = checksum_type_to_nid(kind);\n   if (nid == NID_undef) {\n     return {};\n   }\n \n+  /* We'll stash the bits of the PE that we need to hash in this buffer.\n+   * Reserve the original PE's size upfront, since we expect the hashed data\n+   * to be only slightly smaller.\n+   */\n+  std::vector<std::uint8_t> pe_bits;\n+  pe_bits.reserve(pe->fileBuffer->bufLen);\n+\n   /* In both PEs and PE32+s, the PE checksum is 64 bytes into the optional header,\n    * which itself is 24 bytes after the PE magic and COFF header from the offset\n    * specified in the DOS header.\n@@ -502,6 +509,14 @@ std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {\n     return {};\n   }\n \n+  /* We explicitly don't support hashing files that don't contain a security\n+   * directory; not because we *can't*, but because doing so isn't well defined\n+   * in the Authenticode specification.\n+   */\n+  if (security_dir.VirtualAddress == 0) {\n+    return {};\n+  }\n+\n   /* \"VirtualAddress\" here is really an offset; an invalid one indicates a tampered input.\n    * Similarly, a cert_table_offset beyond size_of_headers indicates a tampered input\n    * (we get the pe_checksum_offset check for free, since it's always smaller).\n@@ -519,11 +534,6 @@ std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {\n     return {};\n   }\n \n-  /* We'll stash the bits of the PE that we need to hash in this buffer.\n-   */\n-  std::vector<std::uint8_t> pe_bits;\n-  pe_bits.reserve(size_of_headers);\n-\n   pe_bits.insert(pe_bits.begin(), header_buf->buf, header_buf->buf + header_buf->bufLen);\n   delete header_buf;\n \n@@ -541,36 +551,68 @@ std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {\n   pe_bits.erase(pe_bits.begin() + cert_table_offset, pe_bits.begin() + cert_table_offset + 8);\n   pe_bits.erase(pe_bits.begin() + pe_checksum_offset, pe_bits.begin() + pe_checksum_offset + 4);\n \n-  /* Hash pe_bits, which contains the rest of the header.\n-   */\n-  const auto *md = EVP_get_digestbynid(nid);\n-  auto *md_ctx = EVP_MD_CTX_new();\n-  EVP_DigestInit(md_ctx, md);\n-  EVP_DigestUpdate(md_ctx, pe_bits.data(), pe_bits.size());\n+  struct iter_sec_ctx {\n+    impl::SectionList sections;\n+    uint32_t total_bytes_hashed;\n+  };\n \n-  if (security_dir.VirtualAddress > 0) {\n-    /* If a certificate table exists, hash everything before and after it.\n-     */\n-    EVP_DigestUpdate(md_ctx,\n-                     pe->fileBuffer->buf + size_of_headers,\n-                     security_dir.VirtualAddress - size_of_headers);\n+  impl::SectionList sections;\n+  uint32_t total_bytes_hashed = size_of_headers;\n+  iter_sec_ctx ctx = {sections, total_bytes_hashed};\n \n-    /* Most PEs won't have any trailing data but the Authenticode specification is explicit about\n-     * hashing any if it exists.\n-     */\n-    EVP_DigestUpdate(md_ctx,\n-                     pe->fileBuffer->buf + security_dir.VirtualAddress + security_dir.Size,\n-                     pe->fileBuffer->bufLen - (security_dir.VirtualAddress + security_dir.Size));\n-  } else {\n-    /* If there's no certificate table, just hash the rest of the file.\n-     */\n-    EVP_DigestUpdate(\n-        md_ctx, pe->fileBuffer->buf + size_of_headers, pe->fileBuffer->bufLen - size_of_headers);\n+  /* Build up the list of sections in the PE, in ascending order by PointerToRawData\n+   * (i.e., by file offset).\n+   *\n+   * NOTE(ww): Ideally we'd use a capture with the C++ lambda here, but C++ lambdas can't be\n+   * used within C callbacks unless they're captureless.\n+   */\n+  peparse::IterSec(\n+      pe,\n+      [](void *cbd,\n+         [[maybe_unused]] const peparse::VA &secBase,\n+         [[maybe_unused]] const std::string &sectionName,\n+         [[maybe_unused]] const peparse::image_section_header &sec,\n+         const peparse::bounded_buffer *b) -> int {\n+        auto &ctx = *static_cast<iter_sec_ctx *>(cbd);\n+        ctx.sections.emplace_back(b);\n+        ctx.total_bytes_hashed += sec.SizeOfRawData;\n+        return 0;\n+      },\n+      &ctx);\n+\n+  /* Copy each section's data into pe_bits, in ascending order.\n+   */\n+  for (const auto &section : sections) {\n+    pe_bits.insert(pe_bits.end(), section->buf, section->buf + section->bufLen);\n   }\n \n-  /* Finally, finish hashing the damn thing.\n+  /* Also copy any data that happens to be trailing the certificate table into pe_bits.\n+   * Most PEs won't have any trailing data but the Authenticode specification is explicit about\n+   * hashing any if it exists.\n+   */\n+  auto file_size = pe->fileBuffer->bufLen;\n+  auto extra_data_size = file_size - (security_dir.Size + total_bytes_hashed);\n+  auto *trailer_buf = peparse::splitBuffer(\n+      pe->fileBuffer, total_bytes_hashed, total_bytes_hashed + extra_data_size);\n+  if (trailer_buf == nullptr) {\n+    return {};\n+  }\n+  pe_bits.insert(pe_bits.end(), trailer_buf->buf, trailer_buf->buf + trailer_buf->bufLen);\n+  delete trailer_buf;\n+\n+  /* Finally, hash the damn thing.\n+   *\n+   * NOTE(ww): Instead of building up pe_bits and hashing it in one pass, we\n+   * could hash it incrementally with each section. This would also solve\n+   * the capture problem with the C++ callback above and would reduce\n+   * the number of needed allocations.\n    */\n   std::array<std::uint8_t, EVP_MAX_MD_SIZE> md_buf;\n+  const auto *md = EVP_get_digestbynid(nid);\n+  auto *md_ctx = EVP_MD_CTX_new();\n+\n+  EVP_DigestInit(md_ctx, md);\n+  EVP_DigestUpdate(md_ctx, pe_bits.data(), pe_bits.size());\n   EVP_DigestFinal(md_ctx, md_buf.data(), nullptr);\n   EVP_MD_CTX_free(md_ctx);\n "
        },
        {
          "filename": "test/assets/YourPhone.exe",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "test/helpers.h",
          "status": "modified",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -111,3 +111,19 @@ class MissingEKUTest : public ::testing::Test {\n \n   peparse::parsed_pe *pe{nullptr};\n };\n+\n+class StuffingTest : public ::testing::Test {\n+ protected:\n+  void SetUp() override {\n+    auto *file = UTHENTICODE_TEST_ASSETS \"/YourPhone.exe\";\n+\n+    pe = peparse::ParsePEFromFile(file);\n+    ASSERT_TRUE(pe != nullptr);\n+  }\n+\n+  void TearDown() override {\n+    peparse::DestructParsedPE(pe);\n+  }\n+\n+  peparse::parsed_pe *pe{nullptr};\n+};"
        },
        {
          "filename": "test/signeddata-test.cpp",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -123,3 +123,13 @@ TEST_F(MissingEKUTest, SignedData_missing_codesigning_EKU) {\n \n   ASSERT_FALSE(signed_data->verify_signature());\n }\n+\n+TEST_F(StuffingTest, SignedData_missing_codesigning_EKU) {\n+  auto certs = uthenticode::read_certs(pe);\n+  auto signed_data = certs[0].as_signed_data();\n+\n+  // The signature in this PE is valid, but it doesn't actually\n+  // match the PE's calculated checksum. See `StuffingTest.verify`\n+  // for the corresponding test.\n+  ASSERT_TRUE(signed_data->verify_signature());\n+}"
        },
        {
          "filename": "test/uthenticode-test.cpp",
          "status": "modified",
          "additions": 33,
          "deletions": 29,
          "patch": "@@ -75,73 +75,69 @@ TEST_F(Auth32PlusTest, get_checksums) {\n \n TEST_F(NoAuthTest, calculate_checksum) {\n   auto unk = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::UNKNOWN);\n-  EXPECT_TRUE(unk.empty());\n+  EXPECT_FALSE(unk.has_value());\n \n   auto md5 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::MD5);\n-  EXPECT_EQ(md5.size(), 32);\n-  EXPECT_STRCASEEQ(md5.c_str(), \"A31557B1E39554C88C69AAE1DFAAF314\");\n+  EXPECT_FALSE(md5.has_value());\n \n   auto sha1 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA1);\n-  EXPECT_EQ(sha1.size(), 40);\n-  EXPECT_STRCASEEQ(sha1.c_str(), \"2B316F0552972605D509321F31F4274533C93161\");\n+  EXPECT_FALSE(sha1.has_value());\n \n   auto sha256 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA256);\n-  EXPECT_EQ(sha256.size(), 64);\n-  EXPECT_STRCASEEQ(sha256.c_str(),\n-                   \"6B7FA3E8298F33BC47F4ABB9C845930B1EACC0DAD96503CFA52D4EA18DDC89F0\");\n+  EXPECT_FALSE(sha256.has_value());\n }\n \n TEST_F(Auth32Test, calculate_checksum) {\n   auto unk = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::UNKNOWN);\n-  EXPECT_TRUE(unk.empty());\n+  EXPECT_FALSE(unk.has_value());\n \n   auto md5 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::MD5);\n-  EXPECT_EQ(md5.size(), 32);\n-  EXPECT_STRCASEEQ(md5.c_str(), \"64c29391b57679b2973ac562cf64685d\");\n+  EXPECT_EQ(md5.value().size(), 32);\n+  EXPECT_STRCASEEQ(md5.value().c_str(), \"64c29391b57679b2973ac562cf64685d\");\n \n   auto sha1 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA1);\n-  EXPECT_EQ(sha1.size(), 40);\n-  EXPECT_STRCASEEQ(sha1.c_str(), \"6663dd7c24fa84fce7f16e0b02689952c06cfa22\");\n+  EXPECT_EQ(sha1.value().size(), 40);\n+  EXPECT_STRCASEEQ(sha1.value().c_str(), \"6663dd7c24fa84fce7f16e0b02689952c06cfa22\");\n \n   auto sha256 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA256);\n-  EXPECT_EQ(sha256.size(), 64);\n-  EXPECT_STRCASEEQ(sha256.c_str(),\n+  EXPECT_EQ(sha256.value().size(), 64);\n+  EXPECT_STRCASEEQ(sha256.value().c_str(),\n                    \"ea013992f99840f76dcac225dd1262edcec3254511b250a6d1e98d99fc48f815\");\n }\n \n TEST_F(Auth32DupeTest, calculate_checksum) {\n   auto unk = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::UNKNOWN);\n-  EXPECT_TRUE(unk.empty());\n+  EXPECT_FALSE(unk.has_value());\n \n   auto md5 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::MD5);\n-  EXPECT_EQ(md5.size(), 32);\n-  EXPECT_STRCASEEQ(md5.c_str(), \"64c29391b57679b2973ac562cf64685d\");\n+  EXPECT_EQ(md5.value().size(), 32);\n+  EXPECT_STRCASEEQ(md5.value().c_str(), \"64c29391b57679b2973ac562cf64685d\");\n \n   auto sha1 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA1);\n-  EXPECT_EQ(sha1.size(), 40);\n-  EXPECT_STRCASEEQ(sha1.c_str(), \"6663dd7c24fa84fce7f16e0b02689952c06cfa22\");\n+  EXPECT_EQ(sha1.value().size(), 40);\n+  EXPECT_STRCASEEQ(sha1.value().c_str(), \"6663dd7c24fa84fce7f16e0b02689952c06cfa22\");\n \n   auto sha256 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA256);\n-  EXPECT_EQ(sha256.size(), 64);\n-  EXPECT_STRCASEEQ(sha256.c_str(),\n+  EXPECT_EQ(sha256.value().size(), 64);\n+  EXPECT_STRCASEEQ(sha256.value().c_str(),\n                    \"ea013992f99840f76dcac225dd1262edcec3254511b250a6d1e98d99fc48f815\");\n }\n \n TEST_F(Auth32PlusTest, calculate_checksum) {\n   auto unk = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::UNKNOWN);\n-  EXPECT_TRUE(unk.empty());\n+  EXPECT_FALSE(unk.has_value());\n \n   auto md5 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::MD5);\n-  EXPECT_EQ(md5.size(), 32);\n-  EXPECT_STRCASEEQ(md5.c_str(), \"ea0235b77d552633c5a38974cef0e2b5\");\n+  EXPECT_EQ(md5.value().size(), 32);\n+  EXPECT_STRCASEEQ(md5.value().c_str(), \"ea0235b77d552633c5a38974cef0e2b5\");\n \n   auto sha1 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA1);\n-  EXPECT_EQ(sha1.size(), 40);\n-  EXPECT_STRCASEEQ(sha1.c_str(), \"2559e91a60953a5e16f9650f5f88953a2cca5425\");\n+  EXPECT_EQ(sha1.value().size(), 40);\n+  EXPECT_STRCASEEQ(sha1.value().c_str(), \"2559e91a60953a5e16f9650f5f88953a2cca5425\");\n \n   auto sha256 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA256);\n-  EXPECT_EQ(sha256.size(), 64);\n-  EXPECT_STRCASEEQ(sha256.c_str(),\n+  EXPECT_EQ(sha256.value().size(), 64);\n+  EXPECT_STRCASEEQ(sha256.value().c_str(),\n                    \"5c823491c5991914aec971d9456d93d6cf2b8ee7e0ed7abc0b77031d8ec073c0\");\n }\n \n@@ -167,3 +163,11 @@ TEST_F(Auth32DupeTest, verify) {\n TEST_F(Auth32PlusTest, verify) {\n   EXPECT_TRUE(uthenticode::verify(pe));\n }\n+\n+TEST_F(MissingEKUTest, verify) {\n+  EXPECT_FALSE(uthenticode::verify(pe));\n+}\n+\n+TEST_F(StuffingTest, verify) {\n+  EXPECT_FALSE(uthenticode::verify(pe));\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "19005f0af5c0d1669e4f21599e6da1b5ce72c37f",
            "date": "2024-10-28T15:01:50Z",
            "author_login": "hugmyndakassi"
          },
          {
            "sha": "f81d3a8ce1fd3a370f04b4af36b14a896c75de73",
            "date": "2024-09-30T15:04:56Z",
            "author_login": "hugmyndakassi"
          },
          {
            "sha": "cad1bfc713dd31a00de1c3fcdb887dfb812f70ad",
            "date": "2024-03-18T19:09:34Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "21cff4d2edfc0c5a7c5b24da92618c34f4406ecb",
            "date": "2024-03-11T19:29:02Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "46bb57d516a40b3f7788082570738f1e107a532c",
            "date": "2024-02-12T19:26:24Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-347",
    "description": "uthenticode is a small cross-platform library for partially verifying Authenticode digital signatures. Version 1.0.9 of uthenticode hashed the entire file rather than hashing sections by virtual address, in violation of the Authenticode specification. As a result, an attacker could modify code within a binary without changing its Authenticode hash, making it appear valid from uthenticode's perspective. Versions of uthenticode prior to 1.0.9 are not vulnerable to this attack, nor are versions in the 2.x series. By design, uthenticode does not perform full-chain validation. However, the malleability of signature verification introduced in 1.0.9 was an unintended oversight. The 2.x series addresses the vulnerability. Versions prior to 1.0.9 are also not vulnerable, but users are encouraged to upgrade rather than downgrade. There are no workarounds to this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-08-09T16:15:09.733",
    "last_modified": "2024-11-21T08:16:08.780",
    "fix_date": "2023-08-02T19:46:44Z"
  },
  "references": [
    {
      "url": "https://github.com/trailofbits/uthenticode/commit/8670b7bb9154d79c276483dcb7c9e9fd5e66455b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/trailofbits/uthenticode/pull/84",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/trailofbits/uthenticode/security/advisories/GHSA-rc7g-99x7-4p9g",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/trailofbits/uthenticode/commit/8670b7bb9154d79c276483dcb7c9e9fd5e66455b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/trailofbits/uthenticode/pull/84",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/trailofbits/uthenticode/security/advisories/GHSA-rc7g-99x7-4p9g",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:06.412800",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "uthenticode",
    "owner": "trailofbits",
    "created_at": "2020-04-11T02:36:25Z",
    "updated_at": "2025-01-17T11:24:01Z",
    "pushed_at": "2024-10-28T15:01:50Z",
    "size": 595,
    "stars": 142,
    "forks": 33,
    "open_issues": 10,
    "watchers": 142,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C++": 57835,
      "CMake": 5911,
      "Makefile": 929,
      "Shell": 892,
      "Dockerfile": 805
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:10:54.880371"
  }
}