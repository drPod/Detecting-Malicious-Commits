{
  "cve_id": "CVE-2023-40021",
  "github_data": {
    "repository": "oppia/oppia",
    "fix_commit": "b89bf808378c1236874b5797a7bda32c77b4af23",
    "related_commits": [
      "b89bf808378c1236874b5797a7bda32c77b4af23",
      "b89bf808378c1236874b5797a7bda32c77b4af23"
    ],
    "patch_url": "https://github.com/oppia/oppia/commit/b89bf808378c1236874b5797a7bda32c77b4af23.patch",
    "fix_commit_details": {
      "sha": "b89bf808378c1236874b5797a7bda32c77b4af23",
      "commit_date": "2023-08-13T01:18:25Z",
      "author": {
        "login": "U8NWXD",
        "type": "User",
        "stats": {
          "total_commits": 164,
          "average_weekly_commits": 0.25826771653543307,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 104
        }
      },
      "commit_message": {
        "title": "Fix GHSA-49jp-pjc3-2532: Strengthen CSRF Protections (#18769)",
        "length": 454,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 38,
        "additions": 30,
        "deletions": 8
      },
      "files": [
        {
          "filename": "core/controllers/base.py",
          "status": "modified",
          "additions": 29,
          "deletions": 7,
          "patch": "@@ -902,12 +902,18 @@ def init_csrf_secret(cls) -> None:\n             base64.urlsafe_b64encode(os.urandom(20)))\n \n     @classmethod\n-    def _create_token(cls, user_id: Optional[str], issued_on: float) -> str:\n+    def _create_token(\n+            cls, user_id: Optional[str], issued_on: float,\n+            nonce: Optional[str] = None) -> str:\n         \"\"\"Creates a new CSRF token.\n \n         Args:\n             user_id: str|None. The user_id for which the token is generated.\n             issued_on: float. The timestamp at which the token was issued.\n+            nonce: str|None. A token that is never reused to prevent reply\n+                attacks. This argument should only be provided when validating a\n+                received CSRF token, in which case the nonce in the received\n+                token should be provided here.\n \n         Returns:\n             str. The generated CSRF token.\n@@ -923,19 +929,31 @@ def _create_token(cls, user_id: Optional[str], issued_on: float) -> str:\n         # Round time to seconds.\n         issued_on_str = str(int(issued_on))\n \n+        # Generate a nonce (number used once) to ensure that even two\n+        # consecutive calls to the same endpoint in the same second generate\n+        # different tokens. Note that this nonce is just for anti-collision\n+        # purposes, so it's okay that the nonce is stored in the CSRF token and\n+        # therefore can be controlled by an attacker. See OWASP guidance here:\n+        # https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#signed-double-submit-cookie.\n+        if nonce is None:\n+            nonce = base64.urlsafe_b64encode(os.urandom(20)).decode('utf-8')\n+\n         digester = hmac.new(\n             key=CSRF_SECRET.value.encode('utf-8'),\n-            digestmod='md5'\n+            digestmod='sha256'\n         )\n         digester.update(user_id.encode('utf-8'))\n         digester.update(b':')\n         digester.update(issued_on_str.encode('utf-8'))\n+        digester.update(b':')\n+        digester.update(nonce.encode('utf-8'))\n \n         digest = digester.digest()\n         # The b64encode returns bytes, so we first need to decode the returned\n         # bytes to string.\n-        token = '%s/%s' % (\n-            issued_on_str, base64.urlsafe_b64encode(digest).decode('utf-8'))\n+        token = '%s/%s/%s' % (\n+            issued_on_str, nonce,\n+            base64.urlsafe_b64encode(digest).decode('utf-8'))\n \n         return token\n \n@@ -973,16 +991,20 @@ def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:\n         \"\"\"\n         try:\n             parts = token.split('/')\n-            if len(parts) != 2:\n+            if len(parts) != 3:\n                 return False\n \n             issued_on = int(parts[0])\n             age = cls._get_current_time() - issued_on\n             if age > cls._CSRF_TOKEN_AGE_SECS:\n                 return False\n \n-            authentic_token = cls._create_token(user_id, issued_on)\n-            if authentic_token == token:\n+            nonce = parts[1]\n+\n+            authentic_token = cls._create_token(user_id, issued_on, nonce)\n+            if hmac.compare_digest(\n+                authentic_token.encode('utf-8'), token.encode('utf-8')\n+            ):\n                 return True\n \n             return False"
        },
        {
          "filename": "core/controllers/base_test.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -743,7 +743,7 @@ def test_create_and_validate_token(self) -> None:\n         self.assertFalse(\n             base.CsrfTokenManager.is_csrf_token_valid(uid, 'new_token'))\n         self.assertFalse(\n-            base.CsrfTokenManager.is_csrf_token_valid(uid, 'new/token'))\n+            base.CsrfTokenManager.is_csrf_token_valid(uid, 'a/new/token'))\n \n     def test_non_default_csrf_secret_is_used(self) -> None:\n         base.CsrfTokenManager.create_csrf_token('uid')"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b0426ad50136d945958dfe2a0addba1840ff01dd",
            "date": "2025-01-13T09:00:25Z",
            "author_login": "Hemant2A2"
          },
          {
            "sha": "64feb6a7357d87e8f1670312f73b7848aff00e16",
            "date": "2025-01-13T07:10:30Z",
            "author_login": "kartik1809"
          },
          {
            "sha": "805e96f762c6e6beaa730f9168370890181bbeaa",
            "date": "2025-01-12T13:05:18Z",
            "author_login": "KartikSuryavanshi"
          },
          {
            "sha": "0a5c573b233f5f1a6cc8156f224b736217d5b7b5",
            "date": "2025-01-11T07:34:28Z",
            "author_login": "D-z-V"
          },
          {
            "sha": "52ea27f085417b12a326958cc9fb55141a3b46e4",
            "date": "2025-01-11T02:38:57Z",
            "author_login": "kevintab95"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-203",
    "description": "Oppia is an online learning platform. When comparing a received CSRF token against the expected token, Oppia uses the string equality operator (`==`), which is not safe against timing attacks. By repeatedly submitting invalid tokens, an attacker can brute-force the expected CSRF token character by character. Once they have recovered the token, they can then submit a forged request on behalf of a logged-in user and execute privileged actions on that user's behalf. In particular the function to validate received CSRF tokens is at `oppia.core.controllers.base.CsrfTokenManager.is_csrf_token_valid`. An attacker who can lure a logged-in Oppia user to a malicious website can perform any change on Oppia that the user is authorized to do, including changing profile information; creating, deleting, and changing explorations; etc. Note that the attacker cannot change a user's login credentials. An attack would need to complete within 1 second because every second, the time used in computing the token changes. This issue has been addressed in commit `b89bf80837` which has been included in release `3.3.2-hotfix-2`. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-08-16T21:15:09.880",
    "last_modified": "2024-11-21T08:18:31.750",
    "fix_date": "2023-08-13T01:18:25Z"
  },
  "references": [
    {
      "url": "https://github.com/oppia/oppia/blob/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py#L964-L990",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/commit/b89bf808378c1236874b5797a7bda32c77b4af23",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/pull/18769",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/security/advisories/GHSA-49jp-pjc3-2532",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/blob/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py#L964-L990",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/commit/b89bf808378c1236874b5797a7bda32c77b4af23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/pull/18769",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/oppia/oppia/security/advisories/GHSA-49jp-pjc3-2532",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:06.436957",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "oppia",
    "owner": "oppia",
    "created_at": "2015-08-14T00:16:14Z",
    "updated_at": "2025-01-14T15:41:20Z",
    "pushed_at": "2025-01-13T10:46:53Z",
    "size": 303890,
    "stars": 5904,
    "forks": 4293,
    "open_issues": 1470,
    "watchers": 5904,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "add_topic_migration_job",
      "add-diana",
      "add-es-port-check",
      "add-search-stub",
      "add-setup",
      "allow-image-click",
      "backend-notification",
      "backgroundbanner",
      "blog-e2e-fix",
      "bookworm",
      "change-travis-notifications",
      "check-for-flakes",
      "chris7716-patch-1",
      "ci-migration",
      "circleci-fbswitch",
      "circleci-test-migration",
      "cla-check-test",
      "contrib-dashboard-hotfix",
      "contributor-dashboard-testing",
      "csrf-errors",
      "ct-branch",
      "default-to-translations",
      "deprecate-python-utils",
      "develop",
      "draft-upgrades",
      "drop-dev-deps",
      "dynamic-feature-gating-feature-branch",
      "e2e-debugging",
      "e2e-ts",
      "es-prod"
    ],
    "languages": {
      "Python": 19576833,
      "TypeScript": 18344824,
      "HTML": 2450975,
      "JavaScript": 1197241,
      "CSS": 593371,
      "PEG.js": 71377,
      "Shell": 20386,
      "Makefile": 13374
    },
    "commit_activity": {
      "total_commits_last_year": 787,
      "avg_commits_per_week": 15.134615384615385,
      "days_active_last_year": 248
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T17:08:44.525477"
  }
}