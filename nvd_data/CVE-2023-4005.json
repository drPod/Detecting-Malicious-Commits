{
  "cve_id": "CVE-2023-4005",
  "github_data": {
    "repository": "fossbilling/fossbilling",
    "fix_commit": "20c23b051eb690cb4ae60a257f6bb46eb3aae2d1",
    "related_commits": [
      "20c23b051eb690cb4ae60a257f6bb46eb3aae2d1",
      "20c23b051eb690cb4ae60a257f6bb46eb3aae2d1"
    ],
    "patch_url": "https://github.com/fossbilling/fossbilling/commit/20c23b051eb690cb4ae60a257f6bb46eb3aae2d1.patch",
    "fix_commit_details": {
      "sha": "20c23b051eb690cb4ae60a257f6bb46eb3aae2d1",
      "commit_date": "2023-07-20T12:23:44Z",
      "author": {
        "login": "BelleNottelling",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Invalidate existing sessions during PW reset (#1435)",
        "length": 52,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 123,
        "additions": 120,
        "deletions": 3
      },
      "files": [
        {
          "filename": "src/modules/Client/Api/Admin.php",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -354,6 +354,9 @@ public function change_password($data)\n         $client->updated_at = date('Y-m-d H:i:s');\n         $this->di['db']->store($client);\n \n+        $profileService = $this->di['mod_service']('profile');\n+        $profileService->invalidateSessions('client', $data['id']);\n+\n         $this->di['events_manager']->fire(['event' => 'onAfterAdminClientPasswordChange', 'params' => ['id' => $client->id, 'password' => $data['password']]]);\n \n         $this->di['logger']->info('Changed client #%s password', $client->id);"
        },
        {
          "filename": "src/modules/Profile/Api/Admin.php",
          "status": "modified",
          "additions": 17,
          "deletions": 1,
          "patch": "@@ -116,10 +116,26 @@ public function change_password($data)\n \n         $staff = $this->getIdentity();\n \n-        if(!$this->di['password']->verify($data['current_password'], $staff->pass)) {\n+        if (!$this->di['password']->verify($data['current_password'], $staff->pass)) {\n             throw new \\Exception('Current password incorrect');\n         }\n \n+        $this->getService()->invalidateSessions();\n         return $this->getService()->changeAdminPassword($staff, $data['new_password']);\n     }\n+\n+    /**\n+     * Used to destroy / invalidate all existing sessions for a given user\n+     * @param array $data An array with the options.\n+     *                    The array can contain the following sub-keys:\n+     *                    - string|null $data['type'] The user type (admin or staff) (optional).\n+     *                    - id|null $data['id'] The session ID (optional).\n+     * @return bool \n+     */\n+    public function destroy_sessions(array $data): bool\n+    {\n+        $data['type'] ??= null;\n+        $data['id'] ??= null;\n+        return $this->getService()->invalidateSessions($data['type'], $data['id']);\n+    }\n }"
        },
        {
          "filename": "src/modules/Profile/Api/Client.php",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -120,10 +120,11 @@ public function change_password($data)\n \n         $client = $this->getIdentity();\n \n-        if(!$this->di['password']->verify($data['current_password'], $client->pass)) {\n+        if (!$this->di['password']->verify($data['current_password'], $client->pass)) {\n             throw new \\Exception('Current password incorrect');\n         }\n \n+        $this->getService()->invalidateSessions();\n         return $this->getService()->changeClientPassword($client, $data['new_password']);\n     }\n \n@@ -136,4 +137,13 @@ public function logout()\n     {\n         return $this->getService()->logoutClient();\n     }\n+\n+    /**\n+     * Used to destroy / invalidate all existing sessions for the current client\n+     * @return bool \n+     */\n+    public function destroy_sessions(array $data): bool\n+    {\n+        return $this->getService()->invalidateSessions();\n+    }\n }"
        },
        {
          "filename": "src/modules/Profile/Service.php",
          "status": "modified",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -222,4 +222,80 @@ public function logoutClient()\n \n         return true;\n     }\n+\n+    public function invalidateSessions(?string $type = null, ?int $id = null): bool\n+    {\n+        if (empty($type)) {\n+            $auth = new \\Box_Authorization($this->di);\n+            if ($auth->isAdminLoggedIn()) {\n+                $type = 'admin';\n+            } elseif ($auth->isClientLoggedIn()) {\n+                $type = 'client';\n+            } else {\n+                throw new \\Box_Exception(\"Unable to invalidate sessions, nobody is logged in\");\n+            }\n+        }\n+\n+        if (empty($id)) {\n+            switch ($type) {\n+                case 'admin':\n+                    $admin = $this->di['session']->get('admin');\n+                    $id = $admin['id'];\n+                    break;\n+                case 'client':\n+                    $id = $this->di['session']->get('client_id');\n+                    break;\n+            }\n+        }\n+\n+        if ($type !== 'admin' && $type !== 'client') {\n+            throw new \\Box_Exception(\"Unable to invalidate sessions, an invalid type was used\");\n+        }\n+\n+        $sessions = $this->getSessions();\n+        foreach ($sessions as $session) {\n+            $this->deleteSessionIfMatching($session, $type, $id);\n+        }\n+\n+        return true;\n+    }\n+\n+    private function getSessions(): array\n+    {\n+        $query = 'SELECT * FROM session WHERE content IS NOT NULL AND content <> \"\"';\n+        $sessions = $this->di['db']->getAll($query);\n+        return $sessions;\n+    }\n+\n+    private function deleteSessionIfMatching(array $session, string $type, int $id): void\n+    {\n+        // Decode the data for the current session and then verify it is for the selected type\n+        $data = base64_decode($session['content']);\n+        $stringStart = ($type === 'admin') ? 'admin|' : 'client_id|';\n+        if (!str_starts_with($data, $stringStart)) {\n+            return;\n+        }\n+\n+        // Now we strip off the starting portion so we can unserialize the data\n+        $data = str_replace($stringStart, '', $data);\n+\n+        // Finally, perform the check depending on what type of session we are looking for and trash it if it's a match\n+        if ($type === 'admin') {\n+            $dataArray = unserialize($data);\n+            if ($dataArray['id'] === $id) {\n+                $this->trashSessionByArray($session);\n+            }\n+        } else {\n+            if (unserialize($data) === $id) {\n+                $this->trashSessionByArray($session);\n+            }\n+        }\n+    }\n+\n+    private function trashSessionByArray(array $session): void\n+    {\n+        $bean = $this->di['db']->dispense('session');\n+        $bean->import($session);\n+        $this->di['db']->trash($bean);\n+    }\n }"
        },
        {
          "filename": "src/modules/Staff/Service.php",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -443,6 +443,9 @@ public function changePassword(\\Model_Admin $model, $password)\n         $model->updated_at = date('Y-m-d H:i:s');\n         $this->di['db']->store($model);\n \n+        $profileService = $this->di['mod_service']('profile');\n+        $profileService->invalidateSessions('admin', $model->id);\n+\n         $this->di['events_manager']->fire(['event' => 'onAfterAdminStaffPasswordChange', 'params' => ['id' => $model->id]]);\n \n         $this->di['logger']->info('Changed staff member %s password', $model->id);"
        },
        {
          "filename": "tests/modules/Client/Api/AdminTest.php",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -449,6 +449,8 @@ public function testchange_password()\n             ->method('hashIt')\n             ->with($data['password']);\n \n+        $profileService = $this->getMockBuilder('\\Box\\Mod\\Profile\\Service')->getMock();\n+\n         $di                   = new \\Pimple\\Container();\n         $di['db']             = $dbMock;\n         $di['events_manager'] = $eventMock;\n@@ -459,7 +461,9 @@ public function testchange_password()\n             ->method('checkRequiredParamsForArray')\n             ->will($this->returnValue(null));\n         $di['validator'] = $validatorMock;\n-\n+        $di['mod_service'] = $di->protect(function () use ($profileService) {\n+            return $profileService;\n+        });\n \n         $admin_Client = new \\Box\\Mod\\Client\\Api\\Admin();\n         $admin_Client->setDi($di);"
        },
        {
          "filename": "tests/modules/Staff/ServiceTest.php",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -1027,12 +1027,17 @@ public function testchangePassword()\n         $passwordMock->expects($this->atLeastOnce())\n             ->method('hashIt')\n             ->with($plainTextPassword);\n+        \n+        $profileService = $this->getMockBuilder('\\Box\\Mod\\Profile\\Service')->getMock();\n \n         $di                   = new \\Pimple\\Container();\n         $di['events_manager'] = $eventsMock;\n         $di['logger']         = $logMock;\n         $di['db']             = $dbMock;\n         $di['password']       = $passwordMock;\n+        $di['mod_service'] = $di->protect(function () use ($profileService) {\n+            return $profileService;\n+        });\n \n         $service = new \\Box\\Mod\\Staff\\Service();\n         $service->setDi($di);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d881a77d84fd1029400ff06fa45bfcb7e6785df4",
            "date": "2025-01-14T05:07:56Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "aabae0a37f30fb8d3072c8715ee3e93f54c88316",
            "date": "2025-01-14T01:18:09Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "a37f24fc10e69f0f933b370ab4c3643f5d2ba510",
            "date": "2025-01-13T00:43:31Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "3bc7b3f3f75b0aed98bc5f4bb82c2528a84d0703",
            "date": "2025-01-12T01:16:39Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "66b419662e37815937a21aeb9ddaee4ded0006db",
            "date": "2025-01-09T20:43:52Z",
            "author_login": "renovate[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-613",
    "description": "Insufficient Session Expiration in GitHub repository fossbilling/fossbilling prior to 0.5.5.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-07-31T01:15:09.840",
    "last_modified": "2024-11-21T08:34:12.683",
    "fix_date": "2023-07-20T12:23:44Z"
  },
  "references": [
    {
      "url": "https://github.com/fossbilling/fossbilling/commit/20c23b051eb690cb4ae60a257f6bb46eb3aae2d1",
      "source": "security@huntr.dev",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/f0aacce1-79bc-4765-95f1-7e824433b9e4",
      "source": "security@huntr.dev",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://github.com/fossbilling/fossbilling/commit/20c23b051eb690cb4ae60a257f6bb46eb3aae2d1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/f0aacce1-79bc-4765-95f1-7e824433b9e4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.283620",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "FOSSBilling",
    "owner": "fossbilling",
    "created_at": "2022-05-18T07:13:32Z",
    "updated_at": "2025-01-14T09:45:22Z",
    "pushed_at": "2025-01-14T09:47:32Z",
    "size": 115592,
    "stars": 914,
    "forks": 199,
    "open_issues": 201,
    "watchers": 914,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "PHP": 3692953,
      "Twig": 1520070,
      "JavaScript": 70601,
      "HTML": 14354,
      "SCSS": 5514,
      "CSS": 1801,
      "Dockerfile": 830,
      "Shell": 400
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T16:51:02.524915"
  }
}