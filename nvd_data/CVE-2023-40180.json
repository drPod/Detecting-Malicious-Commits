{
  "cve_id": "CVE-2023-40180",
  "github_data": {
    "repository": "silverstripe/silverstripe-graphql",
    "fix_commit": "f6d5976ec4608e51184b0db1ee5b9e9a99d2501c",
    "related_commits": [
      "f6d5976ec4608e51184b0db1ee5b9e9a99d2501c",
      "f6d5976ec4608e51184b0db1ee5b9e9a99d2501c"
    ],
    "patch_url": "https://github.com/silverstripe/silverstripe-graphql/commit/f6d5976ec4608e51184b0db1ee5b9e9a99d2501c.patch",
    "fix_commit_details": {
      "sha": "f6d5976ec4608e51184b0db1ee5b9e9a99d2501c",
      "commit_date": "2023-10-16T00:45:17Z",
      "author": {
        "login": "GuySartorelli",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[CVE-2023-40180] Add protection against recursive queries (#558)",
        "length": 64,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 376,
        "additions": 362,
        "deletions": 14
      },
      "files": [
        {
          "filename": "_config/schema-global.yml",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -10,6 +10,8 @@ SilverStripe\\GraphQL\\Schema\\Schema:\n           valueParser: 'SilverStripe\\GraphQL\\Schema\\Resolver\\JSONResolver::parseValue'\n           literalParser: 'SilverStripe\\GraphQL\\Schema\\Resolver\\JSONResolver::parseLiteral'\n       config:\n+        max_query_depth: 15\n+        max_query_nodes: 500\n         resolverStrategy: 'SilverStripe\\GraphQL\\Schema\\Resolver\\DefaultResolverStrategy::getResolverMethod'\n         defaultResolver: 'SilverStripe\\GraphQL\\Schema\\Resolver\\DefaultResolver::defaultFieldResolver'\n         modelCreators:"
        },
        {
          "filename": "src/Controller.php",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -30,6 +30,7 @@\n use SilverStripe\\Security\\Permission;\n use SilverStripe\\Versioned\\Versioned;\n use BadMethodCallException;\n+use SilverStripe\\Core\\ClassInfo;\n \n /**\n  * Top level controller for handling graphql requests.\n@@ -113,8 +114,11 @@ public function index(HTTPRequest $request): HTTPResponse\n             }\n             $handler = $this->getQueryHandler();\n             $this->applyContext($handler);\n-            $queryDocument = Parser::parse(new Source($query));\n             $ctx = $handler->getContext();\n+            if (ClassInfo::hasMethod($handler, 'validateQueryBeforeParsing')) {\n+                $handler->validateQueryBeforeParsing($query, $ctx);\n+            }\n+            $queryDocument = Parser::parse(new Source($query));\n             $result = $handler->query($graphqlSchema, $query, $variables);\n \n             // Fire an eventYou"
        },
        {
          "filename": "src/QueryHandler/QueryHandler.php",
          "status": "modified",
          "additions": 57,
          "deletions": 1,
          "patch": "@@ -5,14 +5,20 @@\n \n use GraphQL\\Error\\Error;\n use GraphQL\\Error\\SyntaxError;\n+use GraphQL\\Error\\UserError;\n use GraphQL\\Executor\\ExecutionResult;\n use GraphQL\\GraphQL;\n use GraphQL\\Language\\AST\\DocumentNode;\n use GraphQL\\Language\\AST\\NodeKind;\n+use GraphQL\\Language\\Lexer;\n use GraphQL\\Language\\Parser;\n use GraphQL\\Language\\Source;\n use GraphQL\\Language\\SourceLocation;\n+use GraphQL\\Language\\Token;\n use GraphQL\\Type\\Schema as GraphQLSchema;\n+use GraphQL\\Validator\\DocumentValidator;\n+use GraphQL\\Validator\\Rules\\QueryComplexity;\n+use GraphQL\\Validator\\Rules\\QueryDepth;\n use SilverStripe\\Control\\Director;\n use SilverStripe\\Core\\Config\\Configurable;\n use SilverStripe\\Core\\Extensible;\n@@ -24,6 +30,7 @@\n use SilverStripe\\GraphQL\\PersistedQuery\\PersistedQueryProvider;\n use SilverStripe\\GraphQL\\Schema\\Interfaces\\ContextProvider;\n use SilverStripe\\GraphQL\\Schema\\Schema;\n+use SilverStripe\\GraphQL\\Schema\\SchemaConfig;\n use SilverStripe\\ORM\\ValidationException;\n \n /**\n@@ -99,12 +106,61 @@ public function queryAndReturnResult(GraphQLSchema $schema, $query, ?array $vars\n         }\n         $context = $this->getContext();\n         $last = function ($schema, $query, $context, $vars) {\n-            return GraphQL::executeQuery($schema, $query, null, $context, $vars);\n+            if (is_string($query)) {\n+                $this->validateQueryBeforeParsing($query, $context);\n+            }\n+\n+            $validationRules = DocumentValidator::allRules();\n+            if (isset($context[SchemaConfigProvider::KEY])) {\n+                /** @var SchemaConfig $config */\n+                $config = $context[SchemaConfigProvider::KEY];\n+                $maxDepth = $config->get('max_query_depth');\n+                $maxComplexity = $config->get('max_query_complexity');\n+                if ($maxDepth) {\n+                    $validationRules[QueryDepth::class] = new QueryDepth($maxDepth);\n+                }\n+                if ($maxComplexity) {\n+                    $validationRules[QueryComplexity::class] = new QueryComplexity($maxComplexity);\n+                }\n+            }\n+            return GraphQL::executeQuery($schema, $query, null, $context, $vars, null, null, $validationRules);\n         };\n \n         return $this->callMiddleware($schema, $query, $context, $vars ?? [], $last);\n     }\n \n+    /**\n+     * Validate a query before parsing it in case there are issues we can catch early.\n+     */\n+    public function validateQueryBeforeParsing(string $query, array $context): void\n+    {\n+        if (!isset($context[SchemaConfigProvider::KEY])) {\n+            return;\n+        }\n+\n+        /** @var SchemaConfig $config */\n+        $config = $context[SchemaConfigProvider::KEY];\n+        $maxNodes = $config->get('max_query_nodes');\n+        if (!$maxNodes) {\n+            return;\n+        }\n+\n+        $lexer = new Lexer(new Source($query));\n+        $numNodes = 0;\n+\n+        // Check how many nodes there are in this query\n+        do {\n+            $next = $lexer->advance();\n+            if ($next->kind === Token::NAME) {\n+                $numNodes++;\n+            }\n+        } while ($next->kind !== Token::EOF && $numNodes <= $maxNodes);\n+\n+        // Throw a UserError if there are too many nodes\n+        if ($numNodes > $maxNodes) {\n+            throw new UserError(\"GraphQL query body must not be longer than $maxNodes nodes.\");\n+        }\n+    }\n \n     /**\n      * get query from persisted id, return null if not found"
        },
        {
          "filename": "tests/Fake/FakeSiteTree.php",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -15,6 +15,14 @@ class FakeSiteTree extends DataObject implements TestOnly\n         'Content' => 'HTMLText'\n     ];\n \n+    private static $has_one = [\n+        'Parent' => self::class,\n+    ];\n+\n+    private static $has_many = [\n+        'Children' => self::class,\n+    ];\n+\n     private static $extensions = [\n         Versioned::class,\n     ];"
        },
        {
          "filename": "tests/Schema/IntegrationTest.php",
          "status": "modified",
          "additions": 252,
          "deletions": 12,
          "patch": "@@ -36,10 +36,16 @@\n use Symfony\\Component\\Filesystem\\Filesystem;\n use GraphQL\\Type\\Schema as GraphQLSchema;\n use Exception;\n+use GraphQL\\Error\\Error as GraphQLError;\n+use GraphQL\\Validator\\DocumentValidator;\n+use GraphQL\\Validator\\Rules\\CustomValidationRule;\n+use GraphQL\\Validator\\Rules\\QueryComplexity;\n+use GraphQL\\Validator\\Rules\\QueryDepth;\n+use GraphQL\\Validator\\ValidationContext;\n+use ReflectionProperty;\n \n class IntegrationTest extends SapphireTest\n {\n-\n     protected static $extra_dataobjects = [\n         FakePage::class,\n         DataObjectFake::class,\n@@ -1197,6 +1203,220 @@ public function testHtaccess(): void\n         );\n     }\n \n+    /**\n+     * @dataProvider provideDefaultDepthLimit\n+     */\n+    public function testDefaultDepthLimit(int $queryDepth, int $limit)\n+    {\n+        // This global rule should be ignored.\n+        DocumentValidator::addRule(new QueryDepth(1));\n+\n+        try {\n+            $schema = $this->createSchema(new TestSchemaBuilder(['_' . __FUNCTION__]));\n+            $this->runDepthLimitTest($queryDepth, $limit, $schema);\n+        } finally {\n+            $this->removeDocumentValidatorRule(QueryDepth::class);\n+        }\n+    }\n+\n+    public function provideDefaultDepthLimit()\n+    {\n+        return $this->createProviderForComplexityOrDepth(15);\n+    }\n+\n+    /**\n+     * @dataProvider provideCustomDepthLimit\n+     */\n+    public function testCustomDepthLimit(int $queryDepth, int $limit)\n+    {\n+        // This global rule should be ignored.\n+        DocumentValidator::addRule(new QueryDepth(1));\n+\n+        try {\n+            $schema = $this->createSchema(new TestSchemaBuilder(['_' . __FUNCTION__]));\n+            $this->runDepthLimitTest($queryDepth, $limit, $schema);\n+        } finally {\n+            $this->removeDocumentValidatorRule(QueryDepth::class);\n+        }\n+    }\n+\n+    public function provideCustomDepthLimit()\n+    {\n+        return $this->createProviderForComplexityOrDepth(25);\n+    }\n+\n+    /**\n+     * @dataProvider provideCustomComplexityLimit\n+     */\n+    public function testCustomComplexityLimit(int $queryComplexity, int $limit)\n+    {\n+        // This global rule should be ignored.\n+        DocumentValidator::addRule(new QueryComplexity(1));\n+\n+        try {\n+            $schema = $this->createSchema(new TestSchemaBuilder(['_' . __FUNCTION__]));\n+            $this->runComplexityLimitTest($queryComplexity, $limit, $schema);\n+        } finally {\n+            $this->removeDocumentValidatorRule(QueryComplexity::class);\n+        }\n+    }\n+\n+    public function provideCustomComplexityLimit()\n+    {\n+        return $this->createProviderForComplexityOrDepth(10);\n+    }\n+\n+    /**\n+     * @dataProvider provideDefaultNodeLimit\n+     */\n+    public function testDefaultNodeLimit(int $numNodes, int $limit)\n+    {\n+        $schema = $this->createSchema(new TestSchemaBuilder(['_' . __FUNCTION__]));\n+        $this->runNodeLimitTest($numNodes, $limit, $schema);\n+    }\n+\n+    public function provideDefaultNodeLimit()\n+    {\n+        return $this->createProviderForComplexityOrDepth(500);\n+    }\n+\n+    /**\n+     * @dataProvider provideCustomNodeLimit\n+     */\n+    public function testCustomNodeLimit(int $numNodes, int $limit)\n+    {\n+        $schema = $this->createSchema(new TestSchemaBuilder(['_' . __FUNCTION__]));\n+        $this->runNodeLimitTest($numNodes, $limit, $schema);\n+    }\n+\n+    public function provideCustomNodeLimit()\n+    {\n+        return $this->createProviderForComplexityOrDepth(200);\n+    }\n+\n+    public function testGlobalRuleNotRemoved()\n+    {\n+        // This global rule should NOT be ignored.\n+        DocumentValidator::addRule(new CustomValidationRule('never-passes', function (ValidationContext $context) {\n+            $context->reportError(new GraphQLError('This is the custom rule'));\n+            return [];\n+        }));\n+\n+        try {\n+            $schema = $this->createSchema(new TestSchemaBuilder(['_' . __FUNCTION__]));\n+            $result = $this->querySchema($schema, $this->craftRecursiveQuery(15));\n+            $this->assertFailure($result);\n+            $this->assertErrorMatchingRegex($result, '/^This is the custom rule$/');\n+        } finally {\n+            $this->removeDocumentValidatorRule('never-passes');\n+        }\n+    }\n+\n+    private function removeDocumentValidatorRule(string $ruleName): void\n+    {\n+        $reflectionRules = new ReflectionProperty(DocumentValidator::class, 'rules');\n+        $reflectionRules->setAccessible(true);\n+        $rules = $reflectionRules->getValue();\n+        unset($rules[$ruleName]);\n+        $reflectionRules->setValue($rules);\n+    }\n+\n+    private function createProviderForComplexityOrDepth(int $limit): array\n+    {\n+        return [\n+            'far less than limit' => [1, $limit],\n+            'one less than limit' => [$limit - 1, $limit],\n+            'exactly at the limit' => [$limit, $limit],\n+            'one more than limit' => [$limit + 1, $limit],\n+            'far more than limit' => [$limit + 25, $limit],\n+        ];\n+    }\n+\n+    private function runDepthLimitTest(int $queryDepth, int $maxDepth, Schema $schema): void\n+    {\n+        $result = $this->querySchema($schema, $this->craftRecursiveQuery($queryDepth));\n+        if ($queryDepth > $maxDepth) {\n+            $this->assertFailure($result);\n+            $this->assertErrorMatchingRegex($result, '/^Max query depth should be ' . $maxDepth . ' but got ' . $queryDepth . '\\.$/');\n+        } else {\n+            // Note that the depth limit is based on the depth of the QUERY, not of the RESULTS, so all we really care about\n+            // is that the query was successful, not what the results were.\n+            $this->assertSuccess($result);\n+        }\n+    }\n+\n+    private function runComplexityLimitTest(int $queryComplexity, int $maxComplexity, Schema $schema): void\n+    {\n+        $result = $this->querySchema($schema, $this->craftComplexQuery($queryComplexity));\n+        if ($queryComplexity > $maxComplexity) {\n+            $this->assertFailure($result);\n+            $this->assertErrorMatchingRegex($result, '/^Max query complexity should be ' . $maxComplexity . ' but got ' . $queryComplexity . '\\.$/');\n+        } else {\n+            // Note that the complexity limit is based on the complexity of the QUERY, not of the RESULTS, so all we really care about\n+            // is that the query was successful, not what the results were.\n+            $this->assertSuccess($result);\n+        }\n+    }\n+\n+    private function runNodeLimitTest(int $queryNodeCount, int $maxNodes, Schema $schema): void\n+    {\n+        $result = $this->querySchema($schema, $this->craftComplexQuery($queryNodeCount - 1));\n+        if ($queryNodeCount > $maxNodes) {\n+            $this->assertFailure($result);\n+            $this->assertErrorMatchingRegex($result, '/^GraphQL query body must not be longer than ' . $maxNodes . ' nodes\\.$/');\n+        } else {\n+            // Note that the complexity limit is based on the complexity of the QUERY, not of the RESULTS, so all we really care about\n+            // is that the query was successful, not what the results were.\n+            $this->assertSuccess($result);\n+        }\n+    }\n+\n+    private function craftRecursiveQuery(int $queryDepth): string\n+    {\n+        $query = 'query{ readFakeSiteTrees { nodes {';\n+\n+        for ($i = 0; $i < $queryDepth; $i++) {\n+            if ($i % 3 === 0) {\n+                $query .= 'id title';\n+            } elseif ($i % 3 === 1) {\n+                $query .= ' parent {';\n+            } elseif ($i % 3 === 2) {\n+                if ($i === $queryDepth - 1) {\n+                    $query .= 'id title';\n+                } else {\n+                    $query .= 'id title children { nodes {';\n+                }\n+            }\n+        }\n+\n+        $endsWith = strrpos($query, 'id title') === strlen($query) - strlen('id title');\n+        $query .= $endsWith ? '' : 'id title';\n+        // Add all of the closing brackets\n+        $numChars = array_count_values(str_split($query));\n+        for ($i = 0; $i < $numChars['{']; $i++) {\n+            $query .= '}';\n+        }\n+\n+        return $query;\n+    }\n+\n+    private function craftComplexQuery(int $queryComplexity): string\n+    {\n+        $query = 'query{ readOneFakeSiteTree { id';\n+\n+        // skip the first two complexity, because those are taken up by \"readOneFakeSiteTree { id\" above\n+        for ($i = 0; $i < $queryComplexity - 2; $i++) {\n+            $query .= ' id';\n+        }\n+        // Add all of the closing brackets\n+        $numChars = array_count_values(str_split($query));\n+        for ($i = 0; $i < $numChars['{']; $i++) {\n+            $query .= '}';\n+        }\n+\n+        return $query;\n+    }\n+\n     /**\n      * @param TestSchemaBuilder $factory\n      * @return Schema\n@@ -1254,33 +1474,53 @@ private function clean()\n     private function assertSuccess(array $result)\n     {\n         $errors = $result['errors'] ?? [];\n-        if (!empty($errors)) {\n-            $this->fail('Failed to assert successful query. Got errors: ' . json_encode($errors, JSON_PRETTY_PRINT));\n-        }\n+        $this->assertEmpty($errors, 'Failed to assert successful query. Got errors: ' . json_encode($errors, JSON_PRETTY_PRINT));\n         $error = $result['error'] ?? null;\n-        if ($error) {\n-            $this->fail('Failed to assert successful query. Got error: ' . $error);\n-        }\n+        $this->assertFalse((bool) $error, 'Failed to assert successful query. Got error: ' . $error);\n     }\n \n     private function assertFailure(array $result)\n     {\n-        $errors = $result['errors'] ?? [];\n+        $errors = $result['errors'] ?? $result['error'] ?? [];\n         if (empty($errors)) {\n             $this->fail('Failed to assert that query was not successful');\n         }\n     }\n \n     private function assertMissingField(array $result, string $fieldName)\n     {\n+        $this->assertErrorMatchingRegex(\n+            $result,\n+            '/^Cannot query field \"' . $fieldName . '\"/',\n+            'Failed to assert that result was missing field \"' . $fieldName . '\"'\n+        );\n+    }\n+\n+    private function assertErrorMatchingRegex(\n+        array $result,\n+        string $errorRegex,\n+        string $message = 'Failed to assert that expected error was present.'\n+    ) {\n         $errors = $result['errors'] ?? [];\n+        if (isset($result['error'])) {\n+            $errors[] = ['message' => $result['error']];\n+        }\n+        $errorMessages = [];\n+        $foundError = false;\n         foreach ($errors as $error) {\n-            if (preg_match('/^Cannot query field \"' . $fieldName . '\"/', $error['message'] ?? '')) {\n-                return;\n+            if (!isset($error['message'])) {\n+                continue;\n             }\n+            if (preg_match($errorRegex, $error['message'])) {\n+                $foundError = true;\n+                break;\n+            }\n+            $errorMessages[] = '\"' . $error['message'] . '\"';\n         }\n-\n-        $this->fail('Failed to assert that result was missing field \"' . $fieldName . '\"');\n+        $this->assertTrue(\n+            $foundError,\n+            $message . ' Regex was: ' . $errorRegex . ', Errors were: ' . implode(', ', $errorMessages)\n+        );\n     }\n \n     private function assertResults(array $expected, array $actual)"
        },
        {
          "filename": "tests/Schema/_testCustomComplexityLimit/config.yml",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+max_query_complexity: 10"
        },
        {
          "filename": "tests/Schema/_testCustomComplexityLimit/models.yml",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+SilverStripe\\GraphQL\\Tests\\Fake\\FakeSiteTree:\n+  fields: '*'\n+  operations: '*'"
        },
        {
          "filename": "tests/Schema/_testCustomDepthLimit/config.yml",
          "status": "added",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -0,0 +1,7 @@\n+# this just makes it easier to craft the recursive query programatically\n+modelConfig:\n+  DataObject:\n+    nested_query_plugins:\n+      paginateList: true\n+\n+max_query_depth: 25"
        },
        {
          "filename": "tests/Schema/_testCustomDepthLimit/models.yml",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+SilverStripe\\GraphQL\\Tests\\Fake\\FakeSiteTree:\n+  fields: '*'\n+  operations: '*'"
        },
        {
          "filename": "tests/Schema/_testCustomNodeLimit/config.yml",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+max_query_nodes: 200"
        },
        {
          "filename": "tests/Schema/_testCustomNodeLimit/models.yml",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+SilverStripe\\GraphQL\\Tests\\Fake\\FakeSiteTree:\n+  fields: '*'\n+  operations: '*'"
        },
        {
          "filename": "tests/Schema/_testDefaultDepthLimit/config.yml",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+# this just makes it easier to craft the recursive query programatically\n+modelConfig:\n+  DataObject:\n+    nested_query_plugins:\n+      paginateList: true"
        },
        {
          "filename": "tests/Schema/_testDefaultDepthLimit/models.yml",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+SilverStripe\\GraphQL\\Tests\\Fake\\FakeSiteTree:\n+  fields: '*'\n+  operations: '*'"
        },
        {
          "filename": "tests/Schema/_testDefaultNodeLimit/models.yml",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+SilverStripe\\GraphQL\\Tests\\Fake\\FakeSiteTree:\n+  fields: '*'\n+  operations: '*'"
        },
        {
          "filename": "tests/Schema/_testGlobalRuleNotRemoved/config.yml",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+# this just makes it easier to craft the recursive query programatically\n+modelConfig:\n+  DataObject:\n+    nested_query_plugins:\n+      paginateList: true"
        },
        {
          "filename": "tests/Schema/_testGlobalRuleNotRemoved/models.yml",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+SilverStripe\\GraphQL\\Tests\\Fake\\FakeSiteTree:\n+  fields: '*'\n+  operations: '*'"
        },
        {
          "filename": "tests/Schema/fixtures.yml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@ SilverStripe\\Security\\Member:\n     FirstName: Author1\n   author2:\n     FirstName: Author2\n+\n SilverStripe\\GraphQL\\Tests\\Fake\\FakeProductPage:\n   productPage1:\n     Title: This is product page one"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 13,
        "dependency_files": 0,
        "test_files": 14,
        "unique_directories": 11,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b4a2889b33a2628017f9858b2bda0119459b3289",
            "date": "2025-01-06T23:59:44Z",
            "author_login": "emteknetnz"
          },
          {
            "sha": "2617d575346be0c3d5e92e275b491c55f72c6512",
            "date": "2024-12-19T22:32:36Z",
            "author_login": "GuySartorelli"
          },
          {
            "sha": "914177986bd88ac5070af84426eee500b267ab32",
            "date": "2024-12-19T02:11:23Z",
            "author_login": "emteknetnz"
          },
          {
            "sha": "cac855b934a7dbe0411b91a30bbacd9ade372043",
            "date": "2024-09-30T20:37:53Z",
            "author_login": "GuySartorelli"
          },
          {
            "sha": "f91a0a2ef91d6fd48670a585bfb0dfd4dc390794",
            "date": "2024-09-30T05:04:32Z",
            "author_login": "GuySartorelli"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": " silverstripe-graphql is a package which serves Silverstripe data in GraphQL representations. An attacker could use a recursive graphql query to execute a Distributed Denial of Service attack (DDOS attack) against a website. This mostly affects websites with publicly exposed graphql schemas. If your Silverstripe CMS project does not expose a public facing graphql schema, a user account is required to trigger the DDOS attack. If your site is hosted behind a content delivery network (CDN), such as Imperva or CloudFlare, this may further mitigate the risk. This issue has been addressed in versions 3.8.2, 4.1.3, 4.2.5, 4.3.4, and 5.0.3. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-16T19:15:10.567",
    "last_modified": "2024-11-21T08:18:56.620",
    "fix_date": "2023-10-16T00:45:17Z"
  },
  "references": [
    {
      "url": "https://docs.silverstripe.org/en/developer_guides/graphql/security_and_best_practices/recursive_or_complex_queries",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation"
      ]
    },
    {
      "url": "https://github.com/silverstripe/silverstripe-graphql/commit/f6d5976ec4608e51184b0db1ee5b9e9a99d2501c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/silverstripe/silverstripe-graphql/security/advisories/GHSA-v23w-pppm-jh66",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/silverstripe/silverstripe-graphql/tree/3.8#recursive-or-complex-queries",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.silverstripe.org/download/security-releases/CVE-2023-40180",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://docs.silverstripe.org/en/developer_guides/graphql/security_and_best_practices/recursive_or_complex_queries",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation"
      ]
    },
    {
      "url": "https://github.com/silverstripe/silverstripe-graphql/commit/f6d5976ec4608e51184b0db1ee5b9e9a99d2501c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/silverstripe/silverstripe-graphql/security/advisories/GHSA-v23w-pppm-jh66",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/silverstripe/silverstripe-graphql/tree/3.8#recursive-or-complex-queries",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://www.silverstripe.org/download/security-releases/CVE-2023-40180",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.605949",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "silverstripe-graphql",
    "owner": "silverstripe",
    "created_at": "2016-09-16T00:17:45Z",
    "updated_at": "2025-01-06T23:59:55Z",
    "pushed_at": "2025-01-08T00:11:49Z",
    "size": 2511,
    "stars": 52,
    "forks": 61,
    "open_issues": 80,
    "watchers": 52,
    "has_security_policy": false,
    "default_branch": "5",
    "protected_branches": [
      "1.1",
      "2",
      "2.0",
      "3",
      "3.0",
      "3.1",
      "3.2",
      "3.3",
      "3.4",
      "3.5",
      "3.6",
      "3.7",
      "3.8",
      "4",
      "4.0",
      "4.1",
      "4.2",
      "4.3",
      "5",
      "5.0",
      "5.1",
      "5.2",
      "6",
      "6.0"
    ],
    "languages": {
      "PHP": 690183
    },
    "commit_activity": {
      "total_commits_last_year": 15,
      "avg_commits_per_week": 0.28846153846153844,
      "days_active_last_year": 15
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T13:08:54.125724"
  }
}