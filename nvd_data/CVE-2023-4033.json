{
  "cve_id": "CVE-2023-4033",
  "github_data": {
    "repository": "mlflow/mlflow",
    "fix_commit": "6dde93758d42455cb90ef324407919ed67668b9b",
    "related_commits": [
      "6dde93758d42455cb90ef324407919ed67668b9b",
      "6dde93758d42455cb90ef324407919ed67668b9b"
    ],
    "patch_url": "https://github.com/mlflow/mlflow/commit/6dde93758d42455cb90ef324407919ed67668b9b.patch",
    "fix_commit_details": {
      "sha": "6dde93758d42455cb90ef324407919ed67668b9b",
      "commit_date": "2023-07-18T01:31:13Z",
      "author": {
        "login": "serena-ruan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix potential issues with PyFuncBackend in cli (#9053)",
        "length": 105,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 260,
        "additions": 241,
        "deletions": 19
      },
      "files": [
        {
          "filename": "mlflow/pyfunc/_mlflow_pyfunc_backend_predict.py",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+\"\"\"\n+This script should be executed in a fresh python interpreter process using `subprocess`.\n+\"\"\"\n+import argparse\n+\n+from mlflow.pyfunc.scoring_server import _predict\n+\n+\n+def parse_args():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"--model-uri\", required=True)\n+    parser.add_argument(\"--input-path\", required=False)\n+    parser.add_argument(\"--output-path\", required=False)\n+    parser.add_argument(\"--content-type\", required=True)\n+    return parser.parse_args()\n+\n+\n+def main():\n+    args = parse_args()\n+    _predict(\n+        model_uri=args.model_uri,\n+        input_path=args.input_path if args.input_path else None,\n+        output_path=args.output_path if args.output_path else None,\n+        content_type=args.content_type,\n+    )\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
        },
        {
          "filename": "mlflow/pyfunc/backend.py",
          "status": "modified",
          "additions": 15,
          "deletions": 14,
          "patch": "@@ -3,6 +3,7 @@\n import pathlib\n import subprocess\n import posixpath\n+import shlex\n import sys\n import warnings\n import ctypes\n@@ -24,6 +25,7 @@\n from mlflow.utils.conda import get_or_create_conda_env, get_conda_bin_executable\n from mlflow.tracking.artifact_utils import _download_artifact_from_uri\n from mlflow.utils import env_manager as _EnvManager\n+from mlflow.pyfunc import _mlflow_pyfunc_backend_predict\n from mlflow.utils.file_utils import (\n     path_to_local_file_uri,\n     get_or_create_tmp_dir,\n@@ -143,20 +145,19 @@ def predict(self, model_uri, input_path, output_path, content_type):\n         local_uri = path_to_local_file_uri(local_path)\n \n         if self._env_manager != _EnvManager.LOCAL:\n-            command = (\n-                'python -c \"from mlflow.pyfunc.scoring_server import _predict; _predict('\n-                \"model_uri={model_uri}, \"\n-                \"input_path={input_path}, \"\n-                \"output_path={output_path}, \"\n-                \"content_type={content_type})\"\n-                '\"'\n-            ).format(\n-                model_uri=repr(local_uri),\n-                input_path=repr(input_path),\n-                output_path=repr(output_path),\n-                content_type=repr(content_type),\n-            )\n-            return self.prepare_env(local_path).execute(command)\n+            predict_cmd = [\n+                \"python\",\n+                _mlflow_pyfunc_backend_predict.__file__,\n+                \"--model-uri\",\n+                str(local_uri),\n+                \"--content-type\",\n+                shlex.quote(str(content_type)),\n+            ]\n+            if input_path:\n+                predict_cmd += [\"--input-path\", shlex.quote(str(input_path))]\n+            if output_path:\n+                predict_cmd += [\"--output-path\", shlex.quote(str(output_path))]\n+            return self.prepare_env(local_path).execute(\" \".join(predict_cmd))\n         else:\n             scoring_server._predict(local_uri, input_path, output_path, content_type)\n "
        },
        {
          "filename": "mlflow/pyfunc/scoring_server/__init__.py",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -17,6 +17,7 @@\n import json\n import logging\n import os\n+import shlex\n import sys\n import traceback\n \n@@ -31,6 +32,7 @@\n from mlflow.types import Schema\n from mlflow.utils import reraise\n from mlflow.utils.file_utils import path_to_local_file_uri\n+from mlflow.utils.os import is_windows\n from mlflow.utils.proto_json_utils import (\n     NumpyEncoder,\n     dataframe_from_parsed_json,\n@@ -328,14 +330,16 @@ def get_cmd(\n ) -> Tuple[str, Dict[str, str]]:\n     local_uri = path_to_local_file_uri(model_uri)\n     timeout = timeout or MLFLOW_SCORING_SERVER_REQUEST_TIMEOUT.get()\n+\n     # NB: Absolute windows paths do not work with mlflow apis, use file uri to ensure\n     # platform compatibility.\n-    if os.name != \"nt\":\n+    if not is_windows():\n         args = [f\"--timeout={timeout}\"]\n         if port and host:\n-            args.append(f\"-b {host}:{port}\")\n+            address = shlex.quote(f\"{host}:{port}\")\n+            args.append(f\"-b {address}\")\n         elif host:\n-            args.append(f\"-b {host}\")\n+            args.append(f\"-b {shlex.quote(host)}\")\n \n         if nworkers:\n             args.append(f\"-w {nworkers}\")\n@@ -347,7 +351,7 @@ def get_cmd(\n     else:\n         args = []\n         if host:\n-            args.append(f\"--host={host}\")\n+            args.append(f\"--host={shlex.quote(host)}\")\n \n         if port:\n             args.append(f\"--port={port}\")"
        },
        {
          "filename": "tests/models/test_cli.py",
          "status": "modified",
          "additions": 189,
          "deletions": 1,
          "patch": "@@ -28,6 +28,7 @@\n from mlflow.environment_variables import MLFLOW_DISABLE_ENV_MANAGER_CONDA_WARNING\n from mlflow.exceptions import MlflowException\n from mlflow.protos.databricks_pb2 import ErrorCode, BAD_REQUEST\n+from mlflow.pyfunc.backend import PyFuncBackend\n from mlflow.pyfunc.scoring_server import (\n     CONTENT_TYPE_JSON,\n     CONTENT_TYPE_CSV,\n@@ -36,6 +37,7 @@\n from mlflow.utils.environment import _mlflow_conda_env\n from mlflow.utils import env_manager as _EnvManager\n from mlflow.utils import PYTHON_VERSION\n+from mlflow.utils.process import ShellCommandException\n from tests.helper_functions import (\n     pyfunc_build_image,\n     pyfunc_serve_from_docker_image,\n@@ -174,7 +176,7 @@ def test_predict(iris_data, sk_model):\n         with mlflow.start_run() as active_run:\n             mlflow.sklearn.log_model(sk_model, \"model\", registered_model_name=\"impredicting\")\n             model_uri = f\"runs:/{active_run.info.run_id}/model\"\n-        model_registry_uri = \"models:/{name}/{stage}\".format(name=\"impredicting\", stage=\"None\")\n+        model_registry_uri = \"models:/impredicting/None\"\n         input_json_path = tmp.path(\"input.json\")\n         input_csv_path = tmp.path(\"input.csv\")\n         output_json_path = tmp.path(\"output.json\")\n@@ -331,6 +333,173 @@ def test_predict(iris_data, sk_model):\n         assert all(expected == actual)\n \n \n+def test_predict_check_content_type(iris_data, sk_model, tmp_path):\n+    with mlflow.start_run():\n+        mlflow.sklearn.log_model(sk_model, \"model\", registered_model_name=\"impredicting\")\n+    model_registry_uri = \"models:/impredicting/None\"\n+    input_json_path = tmp_path / \"input.json\"\n+    input_csv_path = tmp_path / \"input.csv\"\n+    output_json_path = tmp_path / \"output.json\"\n+\n+    x, _ = iris_data\n+    with input_json_path.open(\"w\") as f:\n+        json.dump({\"dataframe_split\": pd.DataFrame(x).to_dict(orient=\"split\")}, f)\n+\n+    pd.DataFrame(x).to_csv(input_csv_path, index=False)\n+\n+    # Throw errors for invalid content_type\n+    prc = subprocess.run(\n+        [\n+            \"mlflow\",\n+            \"models\",\n+            \"predict\",\n+            \"-m\",\n+            model_registry_uri,\n+            \"-i\",\n+            input_json_path,\n+            \"-o\",\n+            output_json_path,\n+            \"-t\",\n+            \"invalid\",\n+            \"--env-manager\",\n+            \"local\",\n+        ],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        env=env_with_tracking_uri(),\n+        check=False,\n+    )\n+    assert prc.returncode != 0\n+    assert \"Unknown content type\" in prc.stderr.decode(\"utf-8\")\n+\n+\n+def test_predict_check_input_path(iris_data, sk_model, tmp_path):\n+    with mlflow.start_run():\n+        mlflow.sklearn.log_model(sk_model, \"model\", registered_model_name=\"impredicting\")\n+    model_registry_uri = \"models:/impredicting/None\"\n+    input_json_path = tmp_path / \"input with space.json\"\n+    input_csv_path = tmp_path / \"input.csv\"\n+    output_json_path = tmp_path / \"output.json\"\n+\n+    x, _ = iris_data\n+    with input_json_path.open(\"w\") as f:\n+        json.dump({\"dataframe_split\": pd.DataFrame(x).to_dict(orient=\"split\")}, f)\n+\n+    pd.DataFrame(x).to_csv(input_csv_path, index=False)\n+\n+    # Valid input path with space\n+    prc = subprocess.run(\n+        [\n+            \"mlflow\",\n+            \"models\",\n+            \"predict\",\n+            \"-m\",\n+            model_registry_uri,\n+            \"-i\",\n+            f\"{input_json_path}\",\n+            \"-o\",\n+            output_json_path,\n+            \"--env-manager\",\n+            \"local\",\n+        ],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        env=env_with_tracking_uri(),\n+        check=False,\n+        text=True,\n+    )\n+    assert prc.returncode == 0\n+\n+    # Throw errors for invalid input_path\n+    prc = subprocess.run(\n+        [\n+            \"mlflow\",\n+            \"models\",\n+            \"predict\",\n+            \"-m\",\n+            model_registry_uri,\n+            \"-i\",\n+            f'{input_json_path}\"; echo ThisIsABug! \"',\n+            \"-o\",\n+            output_json_path,\n+            \"--env-manager\",\n+            \"local\",\n+        ],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        env=env_with_tracking_uri(),\n+        check=False,\n+        text=True,\n+    )\n+    assert prc.returncode != 0\n+    assert \"ThisIsABug!\" not in prc.stdout\n+    assert \"FileNotFoundError\" in prc.stderr\n+\n+    prc = subprocess.run(\n+        [\n+            \"mlflow\",\n+            \"models\",\n+            \"predict\",\n+            \"-m\",\n+            model_registry_uri,\n+            \"-i\",\n+            f'{input_csv_path}\"; echo ThisIsABug! \"',\n+            \"-o\",\n+            output_json_path,\n+            \"-t\",\n+            \"csv\",\n+            \"--env-manager\",\n+            \"local\",\n+        ],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        env=env_with_tracking_uri(),\n+        check=False,\n+        text=True,\n+    )\n+    assert prc.returncode != 0\n+    assert \"ThisIsABug!\" not in prc.stdout\n+    assert \"FileNotFoundError\" in prc.stderr\n+\n+\n+def test_predict_check_output_path(iris_data, sk_model, tmp_path):\n+    with mlflow.start_run():\n+        mlflow.sklearn.log_model(sk_model, \"model\", registered_model_name=\"impredicting\")\n+    model_registry_uri = \"models:/impredicting/None\"\n+    input_json_path = tmp_path / \"input.json\"\n+    input_csv_path = tmp_path / \"input.csv\"\n+    output_json_path = tmp_path / \"output.json\"\n+\n+    x, _ = iris_data\n+    with input_json_path.open(\"w\") as f:\n+        json.dump({\"dataframe_split\": pd.DataFrame(x).to_dict(orient=\"split\")}, f)\n+\n+    pd.DataFrame(x).to_csv(input_csv_path, index=False)\n+\n+    prc = subprocess.run(\n+        [\n+            \"mlflow\",\n+            \"models\",\n+            \"predict\",\n+            \"-m\",\n+            model_registry_uri,\n+            \"-i\",\n+            input_json_path,\n+            \"-o\",\n+            f'{output_json_path}\"; echo ThisIsABug! \"',\n+            \"--env-manager\",\n+            \"local\",\n+        ],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE,\n+        env=env_with_tracking_uri(),\n+        check=False,\n+        text=True,\n+    )\n+    assert prc.returncode == 0\n+    assert \"ThisIsABug!\" not in prc.stdout\n+\n+\n def test_prepare_env_passes(sk_model):\n     if no_conda:\n         pytest.skip(\"This test requires conda.\")\n@@ -574,6 +743,25 @@ def test_env_manager_unsupported_value():\n         )\n \n \n+def test_host_invalid_value():\n+    class MyModel(mlflow.pyfunc.PythonModel):\n+        def predict(self, ctx, model_input):\n+            return model_input\n+\n+    with mlflow.start_run():\n+        model_info = mlflow.pyfunc.log_model(\n+            python_model=MyModel(), artifact_path=\"test_model\", registered_model_name=\"model\"\n+        )\n+\n+    with mock.patch(\"mlflow.models.cli.get_flavor_backend\", return_value=PyFuncBackend({})):\n+        with pytest.raises(ShellCommandException, match=r\"Non-zero exit code: 1\"):\n+            CliRunner().invoke(\n+                models_cli.serve,\n+                [\"--model-uri\", model_info.model_uri, \"--host\", \"localhost & echo BUG\"],\n+                catch_exceptions=False,\n+            )\n+\n+\n def test_change_conda_env_root_location(tmp_path, sk_model):\n     env_root1_path = tmp_path / \"root1\"\n     env_root1_path.mkdir()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ecbdd766af367b2f6a03a15eba937d13ea4f7c43",
            "date": "2025-01-14T11:54:46Z",
            "author_login": "dsuhinin"
          },
          {
            "sha": "49d28d67d9d25211d0b684ec9ad9c54670b3fee1",
            "date": "2025-01-14T10:10:09Z",
            "author_login": "mlflow-automation"
          },
          {
            "sha": "8778eedb11fbae7339c495634d65592a473118f8",
            "date": "2025-01-14T10:09:27Z",
            "author_login": "mlflow-automation"
          },
          {
            "sha": "8436d0b9db52152536930dee84bb5d1654964731",
            "date": "2025-01-14T09:29:15Z",
            "author_login": "B-Step62"
          },
          {
            "sha": "1ff5a0d5ba5e1f112513fb2edb0372387e5c407e",
            "date": "2025-01-14T08:32:07Z",
            "author_login": "TomeHirata"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-78",
    "description": "OS Command Injection in GitHub repository mlflow/mlflow prior to 2.6.0.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-08-01T01:15:10.913",
    "last_modified": "2024-11-21T08:34:15.977",
    "fix_date": "2023-07-18T01:31:13Z"
  },
  "references": [
    {
      "url": "https://github.com/mlflow/mlflow/commit/6dde93758d42455cb90ef324407919ed67668b9b",
      "source": "security@huntr.dev",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/5312d6f8-67a5-4607-bd47-5e19966fa321",
      "source": "security@huntr.dev",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://github.com/mlflow/mlflow/commit/6dde93758d42455cb90ef324407919ed67668b9b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/5312d6f8-67a5-4607-bd47-5e19966fa321",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Permissions Required"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:04.286489",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "mlflow",
    "owner": "mlflow",
    "created_at": "2018-06-05T16:05:58Z",
    "updated_at": "2025-01-14T14:06:06Z",
    "pushed_at": "2025-01-14T15:26:16Z",
    "size": 703840,
    "stars": 19235,
    "forks": 4317,
    "open_issues": 1689,
    "watchers": 19235,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "branch-0.5",
      "branch-0.7",
      "branch-0.8",
      "branch-0.9",
      "branch-0.9.1"
    ],
    "languages": {
      "Python": 12840682,
      "JavaScript": 9998107,
      "TypeScript": 3983905,
      "Java": 290984,
      "R": 211552,
      "Scala": 42315,
      "Shell": 28740,
      "HTML": 23632,
      "CSS": 18115,
      "Dockerfile": 1312,
      "Mako": 1004,
      "TSQL": 211
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:33:00.445625"
  }
}