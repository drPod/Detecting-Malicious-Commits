{
  "cve_id": "CVE-2023-41058",
  "github_data": {
    "repository": "parse-community/parse-server",
    "fix_commit": "be4c7e23c63a2fb690685665cebed0de26be05c5",
    "related_commits": [
      "be4c7e23c63a2fb690685665cebed0de26be05c5",
      "be4c7e23c63a2fb690685665cebed0de26be05c5"
    ],
    "patch_url": "https://github.com/parse-community/parse-server/commit/be4c7e23c63a2fb690685665cebed0de26be05c5.patch",
    "fix_commit_details": {
      "sha": "be4c7e23c63a2fb690685665cebed0de26be05c5",
      "commit_date": "2023-09-04T12:19:48Z",
      "author": {
        "login": "mtrezza",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: Parse Pointer allows to access internal Parse Server classes and circumvent `beforeFind` query trigger; fixes security vulnerability [GHSA-fcv6-fg5r-jm9q](https://github.com/parse-community/parse-server/security/advisories/GHSA-fcv6-fg5r-jm9q)",
        "length": 248,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 638,
        "additions": 414,
        "deletions": 224
      },
      "files": [
        {
          "filename": "spec/CloudCode.spec.js",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -2381,6 +2381,35 @@ describe('beforeFind hooks', () => {\n       })\n       .then(() => done());\n   });\n+\n+  it('should run beforeFind on pointers and array of pointers from an object', async () => {\n+    const obj1 = new Parse.Object('TestObject');\n+    const obj2 = new Parse.Object('TestObject2');\n+    const obj3 = new Parse.Object('TestObject');\n+    obj2.set('aField', 'aFieldValue');\n+    await obj2.save();\n+    obj1.set('pointerField', obj2);\n+    obj3.set('pointerFieldArray', [obj2]);\n+    await obj1.save();\n+    await obj3.save();\n+    const spy = jasmine.createSpy('beforeFindSpy');\n+    Parse.Cloud.beforeFind('TestObject2', spy);\n+    const query = new Parse.Query('TestObject');\n+    await query.get(obj1.id);\n+    // Pointer not included in query so we don't expect beforeFind to be called\n+    expect(spy).not.toHaveBeenCalled();\n+    const query2 = new Parse.Query('TestObject');\n+    query2.include('pointerField');\n+    const res = await query2.get(obj1.id);\n+    expect(res.get('pointerField').get('aField')).toBe('aFieldValue');\n+    // Pointer included in query so we expect beforeFind to be called\n+    expect(spy).toHaveBeenCalledTimes(1);\n+    const query3 = new Parse.Query('TestObject');\n+    query3.include('pointerFieldArray');\n+    const res2 = await query3.get(obj3.id);\n+    expect(res2.get('pointerFieldArray')[0].get('aField')).toBe('aFieldValue');\n+    expect(spy).toHaveBeenCalledTimes(2);\n+  });\n });\n \n describe('afterFind hooks', () => {"
        },
        {
          "filename": "spec/ParseGraphQLServer.spec.js",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -5275,7 +5275,6 @@ describe('ParseGraphQLServer', () => {\n \n           it('should only count', async () => {\n             await prepareData();\n-\n             await parseGraphQLServer.parseGraphQLSchema.schemaCache.clear();\n \n             const where = {"
        },
        {
          "filename": "spec/ParseRole.spec.js",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -142,7 +142,7 @@ describe('Parse Role testing', () => {\n       return Promise.all(promises);\n     };\n \n-    const restExecute = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n+    const restExecute = spyOn(RestQuery._UnsafeRestQuery.prototype, 'execute').and.callThrough();\n \n     let user, auth, getAllRolesSpy;\n     createTestUser()"
        },
        {
          "filename": "spec/RestQuery.spec.js",
          "status": "modified",
          "additions": 24,
          "deletions": 20,
          "patch": "@@ -399,15 +399,16 @@ describe('RestQuery.each', () => {\n     }\n     const config = Config.get('test');\n     await Parse.Object.saveAll(objects);\n-    const query = new RestQuery(\n+    const query = await RestQuery({\n+      method: RestQuery.Method.find,\n       config,\n-      auth.master(config),\n-      'Object',\n-      { value: { $gt: 2 } },\n-      { limit: 2 }\n-    );\n+      auth: auth.master(config),\n+      className: 'Object',\n+      restWhere: { value: { $gt: 2 } },\n+      restOptions: { limit: 2 },\n+    });\n     const spy = spyOn(query, 'execute').and.callThrough();\n-    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n+    const classSpy = spyOn(RestQuery._UnsafeRestQuery.prototype, 'execute').and.callThrough();\n     const results = [];\n     await query.each(result => {\n       expect(result.value).toBeGreaterThan(2);\n@@ -438,34 +439,37 @@ describe('RestQuery.each', () => {\n      * Two queries needed since objectId are sorted and we can't know which one\n      * going to be the first and then skip by the $gt added by each\n      */\n-    const queryOne = new RestQuery(\n+    const queryOne = await RestQuery({\n+      method: RestQuery.Method.get,\n       config,\n-      auth.master(config),\n-      'Letter',\n-      {\n+      auth: auth.master(config),\n+      className: 'Letter',\n+      restWhere: {\n         numbers: {\n           __type: 'Pointer',\n           className: 'Number',\n           objectId: object1.id,\n         },\n       },\n-      { limit: 1 }\n-    );\n-    const queryTwo = new RestQuery(\n+      restOptions: { limit: 1 },\n+    });\n+\n+    const queryTwo = await RestQuery({\n+      method: RestQuery.Method.get,\n       config,\n-      auth.master(config),\n-      'Letter',\n-      {\n+      auth: auth.master(config),\n+      className: 'Letter',\n+      restWhere: {\n         numbers: {\n           __type: 'Pointer',\n           className: 'Number',\n           objectId: object2.id,\n         },\n       },\n-      { limit: 1 }\n-    );\n+      restOptions: { limit: 1 },\n+    });\n \n-    const classSpy = spyOn(RestQuery.prototype, 'execute').and.callThrough();\n+    const classSpy = spyOn(RestQuery._UnsafeRestQuery.prototype, 'execute').and.callThrough();\n     const resultsOne = [];\n     const resultsTwo = [];\n     await queryOne.each(result => {"
        },
        {
          "filename": "spec/rest.spec.js",
          "status": "modified",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -660,6 +660,38 @@ describe('rest create', () => {\n       });\n   });\n \n+  it('cannot get object in volatileClasses if not masterKey through pointer', async () => {\n+    const masterKeyOnlyClassObject = new Parse.Object('_PushStatus');\n+    await masterKeyOnlyClassObject.save(null, { useMasterKey: true });\n+    const obj2 = new Parse.Object('TestObject');\n+    // Anyone is can basically create a pointer to any object\n+    // or some developers can use master key in some hook to link\n+    // private objects to standard objects\n+    obj2.set('pointer', masterKeyOnlyClassObject);\n+    await obj2.save();\n+    const query = new Parse.Query('TestObject');\n+    query.include('pointer');\n+    await expectAsync(query.get(obj2.id)).toBeRejectedWithError(\n+      \"Clients aren't allowed to perform the get operation on the _PushStatus collection.\"\n+    );\n+  });\n+\n+  it('cannot get object in _GlobalConfig if not masterKey through pointer', async () => {\n+    await Parse.Config.save({ privateData: 'secret' }, { privateData: true });\n+    const obj2 = new Parse.Object('TestObject');\n+    obj2.set('globalConfigPointer', {\n+      __type: 'Pointer',\n+      className: '_GlobalConfig',\n+      objectId: 1,\n+    });\n+    await obj2.save();\n+    const query = new Parse.Query('TestObject');\n+    query.include('globalConfigPointer');\n+    await expectAsync(query.get(obj2.id)).toBeRejectedWithError(\n+      \"Clients aren't allowed to perform the get operation on the _GlobalConfig collection.\"\n+    );\n+  });\n+\n   it('locks down session', done => {\n     let currentUser;\n     Parse.User.signUp('foo', 'bar')"
        },
        {
          "filename": "src/Auth.js",
          "status": "modified",
          "additions": 37,
          "deletions": 9,
          "patch": "@@ -97,7 +97,15 @@ const getAuthForSessionToken = async function ({\n       include: 'user',\n     };\n     const RestQuery = require('./RestQuery');\n-    const query = new RestQuery(config, master(config), '_Session', { sessionToken }, restOptions);\n+    const query = await RestQuery({\n+      method: RestQuery.Method.get,\n+      config,\n+      runBeforeFind: false,\n+      auth: master(config),\n+      className: '_Session',\n+      restWhere: { sessionToken },\n+      restOptions,\n+    });\n     results = (await query.execute()).results;\n   } else {\n     results = (\n@@ -134,12 +142,20 @@ const getAuthForSessionToken = async function ({\n   });\n };\n \n-var getAuthForLegacySessionToken = function ({ config, sessionToken, installationId }) {\n+var getAuthForLegacySessionToken = async function ({ config, sessionToken, installationId }) {\n   var restOptions = {\n     limit: 1,\n   };\n   const RestQuery = require('./RestQuery');\n-  var query = new RestQuery(config, master(config), '_User', { sessionToken }, restOptions);\n+  var query = await RestQuery({\n+    method: RestQuery.Method.get,\n+    config,\n+    runBeforeFind: false,\n+    auth: master(config),\n+    className: '_User',\n+    restWhere: { _session_token: sessionToken },\n+    restOptions,\n+  });\n   return query.execute().then(response => {\n     var results = response.results;\n     if (results.length !== 1) {\n@@ -184,9 +200,15 @@ Auth.prototype.getRolesForUser = async function () {\n       },\n     };\n     const RestQuery = require('./RestQuery');\n-    await new RestQuery(this.config, master(this.config), '_Role', restWhere, {}).each(result =>\n-      results.push(result)\n-    );\n+    const query = await RestQuery({\n+      method: RestQuery.Method.find,\n+      runBeforeFind: false,\n+      config: this.config,\n+      auth: master(this.config),\n+      className: '_Role',\n+      restWhere,\n+    });\n+    await query.each(result => results.push(result));\n   } else {\n     await new Parse.Query(Parse.Role)\n       .equalTo('users', this.user)\n@@ -278,9 +300,15 @@ Auth.prototype.getRolesByIds = async function (ins) {\n     });\n     const restWhere = { roles: { $in: roles } };\n     const RestQuery = require('./RestQuery');\n-    await new RestQuery(this.config, master(this.config), '_Role', restWhere, {}).each(result =>\n-      results.push(result)\n-    );\n+    const query = await RestQuery({\n+      method: RestQuery.Method.find,\n+      config: this.config,\n+      runBeforeFind: false,\n+      auth: master(this.config),\n+      className: '_Role',\n+      restWhere,\n+    });\n+    await query.each(result => results.push(result));\n   }\n   return results;\n };"
        },
        {
          "filename": "src/Controllers/PushController.js",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -58,9 +58,16 @@ export class PushController {\n \n       // Force filtering on only valid device tokens\n       const updateWhere = applyDeviceTokenExists(where);\n-      badgeUpdate = () => {\n+      badgeUpdate = async () => {\n         // Build a real RestQuery so we can use it in RestWrite\n-        const restQuery = new RestQuery(config, master(config), '_Installation', updateWhere);\n+        const restQuery = await RestQuery({\n+          method: RestQuery.Method.find,\n+          config,\n+          runBeforeFind: false,\n+          auth: master(config),\n+          className: '_Installation',\n+          restWhere: updateWhere,\n+        });\n         return restQuery.buildRestWhere().then(() => {\n           const write = new RestWrite(\n             config,"
        },
        {
          "filename": "src/Controllers/UserController.js",
          "status": "modified",
          "additions": 18,
          "deletions": 5,
          "patch": "@@ -48,7 +48,7 @@ export class UserController extends AdaptableController {\n     }\n   }\n \n-  verifyEmail(username, token) {\n+  async verifyEmail(username, token) {\n     if (!this.shouldVerifyEmails) {\n       // Trying to verify email when not enabled\n       // TODO: Better error here.\n@@ -70,8 +70,14 @@ export class UserController extends AdaptableController {\n       updateFields._email_verify_token_expires_at = { __op: 'Delete' };\n     }\n     const maintenanceAuth = Auth.maintenance(this.config);\n-    var findUserForEmailVerification = new RestQuery(this.config, maintenanceAuth, '_User', {\n-      username,\n+    var findUserForEmailVerification = await RestQuery({\n+      method: RestQuery.Method.get,\n+      config: this.config,\n+      auth: maintenanceAuth,\n+      className: '_User',\n+      restWhere: {\n+        username,\n+      },\n     });\n     return findUserForEmailVerification.execute().then(result => {\n       if (result.results.length && result.results[0].emailVerified) {\n@@ -110,7 +116,7 @@ export class UserController extends AdaptableController {\n       });\n   }\n \n-  getUserIfNeeded(user) {\n+  async getUserIfNeeded(user) {\n     if (user.username && user.email) {\n       return Promise.resolve(user);\n     }\n@@ -122,7 +128,14 @@ export class UserController extends AdaptableController {\n       where.email = user.email;\n     }\n \n-    var query = new RestQuery(this.config, Auth.master(this.config), '_User', where);\n+    var query = await RestQuery({\n+      method: RestQuery.Method.get,\n+      config: this.config,\n+      runBeforeFind: false,\n+      auth: Auth.master(this.config),\n+      className: '_User',\n+      restWhere: where,\n+    });\n     return query.execute().then(function (result) {\n       if (result.results.length != 1) {\n         throw undefined;"
        },
        {
          "filename": "src/RestQuery.js",
          "status": "modified",
          "additions": 145,
          "deletions": 52,
          "patch": "@@ -6,6 +6,8 @@ var Parse = require('parse/node').Parse;\n const triggers = require('./triggers');\n const { continueWhile } = require('parse/lib/node/promiseUtils');\n const AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n+const { enforceRoleSecurity } = require('./SharedRest');\n+\n // restOptions can include:\n //   skip\n //   limit\n@@ -18,7 +20,80 @@ const AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];\n //   readPreference\n //   includeReadPreference\n //   subqueryReadPreference\n-function RestQuery(\n+/**\n+ * Use to perform a query on a class. It will run security checks and triggers.\n+ * @param options\n+ * @param options.method {RestQuery.Method} The type of query to perform\n+ * @param options.config {ParseServerConfiguration} The server configuration\n+ * @param options.auth {Auth} The auth object for the request\n+ * @param options.className {string} The name of the class to query\n+ * @param options.restWhere {object} The where object for the query\n+ * @param options.restOptions {object} The options object for the query\n+ * @param options.clientSDK {string} The client SDK that is performing the query\n+ * @param options.runAfterFind {boolean} Whether to run the afterFind trigger\n+ * @param options.runBeforeFind {boolean} Whether to run the beforeFind trigger\n+ * @param options.context {object} The context object for the query\n+ * @returns {Promise<_UnsafeRestQuery>} A promise that is resolved with the _UnsafeRestQuery object\n+ */\n+async function RestQuery({\n+  method,\n+  config,\n+  auth,\n+  className,\n+  restWhere = {},\n+  restOptions = {},\n+  clientSDK,\n+  runAfterFind = true,\n+  runBeforeFind = true,\n+  context,\n+}) {\n+  if (![RestQuery.Method.find, RestQuery.Method.get].includes(method)) {\n+    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'bad query type');\n+  }\n+  enforceRoleSecurity(method, className, auth);\n+  const result = runBeforeFind\n+    ? await triggers.maybeRunQueryTrigger(\n+      triggers.Types.beforeFind,\n+      className,\n+      restWhere,\n+      restOptions,\n+      config,\n+      auth,\n+      context,\n+      method === RestQuery.Method.get\n+    )\n+    : Promise.resolve({ restWhere, restOptions });\n+\n+  return new _UnsafeRestQuery(\n+    config,\n+    auth,\n+    className,\n+    result.restWhere || restWhere,\n+    result.restOptions || restOptions,\n+    clientSDK,\n+    runAfterFind,\n+    context\n+  );\n+}\n+\n+RestQuery.Method = Object.freeze({\n+  get: 'get',\n+  find: 'find',\n+});\n+\n+/**\n+ * _UnsafeRestQuery is meant for specific internal usage only. When you need to skip security checks or some triggers.\n+ * Don't use it if you don't know what you are doing.\n+ * @param config\n+ * @param auth\n+ * @param className\n+ * @param restWhere\n+ * @param restOptions\n+ * @param clientSDK\n+ * @param runAfterFind\n+ * @param context\n+ */\n+function _UnsafeRestQuery(\n   config,\n   auth,\n   className,\n@@ -197,7 +272,7 @@ function RestQuery(\n // Returns a promise for the response - an object with optional keys\n // 'results' and 'count'.\n // TODO: consolidate the replaceX functions\n-RestQuery.prototype.execute = function (executeOptions) {\n+_UnsafeRestQuery.prototype.execute = function (executeOptions) {\n   return Promise.resolve()\n     .then(() => {\n       return this.buildRestWhere();\n@@ -231,7 +306,7 @@ RestQuery.prototype.execute = function (executeOptions) {\n     });\n };\n \n-RestQuery.prototype.each = function (callback) {\n+_UnsafeRestQuery.prototype.each = function (callback) {\n   const { config, auth, className, restWhere, restOptions, clientSDK } = this;\n   // if the limit is set, use it\n   restOptions.limit = restOptions.limit || 100;\n@@ -243,7 +318,9 @@ RestQuery.prototype.each = function (callback) {\n       return !finished;\n     },\n     async () => {\n-      const query = new RestQuery(\n+      // Safe here to use _UnsafeRestQuery because the security was already\n+      // checked during \"await RestQuery()\"\n+      const query = new _UnsafeRestQuery(\n         config,\n         auth,\n         className,\n@@ -265,7 +342,7 @@ RestQuery.prototype.each = function (callback) {\n   );\n };\n \n-RestQuery.prototype.buildRestWhere = function () {\n+_UnsafeRestQuery.prototype.buildRestWhere = function () {\n   return Promise.resolve()\n     .then(() => {\n       return this.getUserAndRoleACL();\n@@ -294,7 +371,7 @@ RestQuery.prototype.buildRestWhere = function () {\n };\n \n // Uses the Auth object to get the list of roles, adds the user id\n-RestQuery.prototype.getUserAndRoleACL = function () {\n+_UnsafeRestQuery.prototype.getUserAndRoleACL = function () {\n   if (this.auth.isMaster) {\n     return Promise.resolve();\n   }\n@@ -313,7 +390,7 @@ RestQuery.prototype.getUserAndRoleACL = function () {\n \n // Changes the className if redirectClassNameForKey is set.\n // Returns a promise.\n-RestQuery.prototype.redirectClassNameForKey = function () {\n+_UnsafeRestQuery.prototype.redirectClassNameForKey = function () {\n   if (!this.redirectKey) {\n     return Promise.resolve();\n   }\n@@ -328,7 +405,7 @@ RestQuery.prototype.redirectClassNameForKey = function () {\n };\n \n // Validates this operation against the allowClientClassCreation config.\n-RestQuery.prototype.validateClientClassCreation = function () {\n+_UnsafeRestQuery.prototype.validateClientClassCreation = function () {\n   if (\n     this.config.allowClientClassCreation === false &&\n     !this.auth.isMaster &&\n@@ -371,7 +448,7 @@ function transformInQuery(inQueryObject, className, results) {\n // $inQuery clause.\n // The $inQuery clause turns into an $in with values that are just\n // pointers to the objects returned in the subquery.\n-RestQuery.prototype.replaceInQuery = function () {\n+_UnsafeRestQuery.prototype.replaceInQuery = async function () {\n   var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');\n   if (!inQueryObject) {\n     return;\n@@ -394,13 +471,14 @@ RestQuery.prototype.replaceInQuery = function () {\n     additionalOptions.readPreference = this.restOptions.readPreference;\n   }\n \n-  var subquery = new RestQuery(\n-    this.config,\n-    this.auth,\n-    inQueryValue.className,\n-    inQueryValue.where,\n-    additionalOptions\n-  );\n+  const subquery = await RestQuery({\n+    method: RestQuery.Method.find,\n+    config: this.config,\n+    auth: this.auth,\n+    className: inQueryValue.className,\n+    restWhere: inQueryValue.where,\n+    restOptions: additionalOptions,\n+  });\n   return subquery.execute().then(response => {\n     transformInQuery(inQueryObject, subquery.className, response.results);\n     // Recurse to repeat\n@@ -429,7 +507,7 @@ function transformNotInQuery(notInQueryObject, className, results) {\n // $notInQuery clause.\n // The $notInQuery clause turns into a $nin with values that are just\n // pointers to the objects returned in the subquery.\n-RestQuery.prototype.replaceNotInQuery = function () {\n+_UnsafeRestQuery.prototype.replaceNotInQuery = async function () {\n   var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');\n   if (!notInQueryObject) {\n     return;\n@@ -452,13 +530,15 @@ RestQuery.prototype.replaceNotInQuery = function () {\n     additionalOptions.readPreference = this.restOptions.readPreference;\n   }\n \n-  var subquery = new RestQuery(\n-    this.config,\n-    this.auth,\n-    notInQueryValue.className,\n-    notInQueryValue.where,\n-    additionalOptions\n-  );\n+  const subquery = await RestQuery({\n+    method: RestQuery.Method.find,\n+    config: this.config,\n+    auth: this.auth,\n+    className: notInQueryValue.className,\n+    restWhere: notInQueryValue.where,\n+    restOptions: additionalOptions,\n+  });\n+\n   return subquery.execute().then(response => {\n     transformNotInQuery(notInQueryObject, subquery.className, response.results);\n     // Recurse to repeat\n@@ -492,7 +572,7 @@ const transformSelect = (selectObject, key, objects) => {\n // The $select clause turns into an $in with values selected out of\n // the subquery.\n // Returns a possible-promise.\n-RestQuery.prototype.replaceSelect = function () {\n+_UnsafeRestQuery.prototype.replaceSelect = async function () {\n   var selectObject = findObjectWithKey(this.restWhere, '$select');\n   if (!selectObject) {\n     return;\n@@ -522,13 +602,15 @@ RestQuery.prototype.replaceSelect = function () {\n     additionalOptions.readPreference = this.restOptions.readPreference;\n   }\n \n-  var subquery = new RestQuery(\n-    this.config,\n-    this.auth,\n-    selectValue.query.className,\n-    selectValue.query.where,\n-    additionalOptions\n-  );\n+  const subquery = await RestQuery({\n+    method: RestQuery.Method.find,\n+    config: this.config,\n+    auth: this.auth,\n+    className: selectValue.query.className,\n+    restWhere: selectValue.query.where,\n+    restOptions: additionalOptions,\n+  });\n+\n   return subquery.execute().then(response => {\n     transformSelect(selectObject, selectValue.key, response.results);\n     // Keep replacing $select clauses\n@@ -554,7 +636,7 @@ const transformDontSelect = (dontSelectObject, key, objects) => {\n // The $dontSelect clause turns into an $nin with values selected out of\n // the subquery.\n // Returns a possible-promise.\n-RestQuery.prototype.replaceDontSelect = function () {\n+_UnsafeRestQuery.prototype.replaceDontSelect = async function () {\n   var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');\n   if (!dontSelectObject) {\n     return;\n@@ -582,21 +664,23 @@ RestQuery.prototype.replaceDontSelect = function () {\n     additionalOptions.readPreference = this.restOptions.readPreference;\n   }\n \n-  var subquery = new RestQuery(\n-    this.config,\n-    this.auth,\n-    dontSelectValue.query.className,\n-    dontSelectValue.query.where,\n-    additionalOptions\n-  );\n+  const subquery = await RestQuery({\n+    method: RestQuery.Method.find,\n+    config: this.config,\n+    auth: this.auth,\n+    className: dontSelectValue.query.className,\n+    restWhere: dontSelectValue.query.where,\n+    restOptions: additionalOptions,\n+  });\n+\n   return subquery.execute().then(response => {\n     transformDontSelect(dontSelectObject, dontSelectValue.key, response.results);\n     // Keep replacing $dontSelect clauses\n     return this.replaceDontSelect();\n   });\n };\n \n-RestQuery.prototype.cleanResultAuthData = function (result) {\n+_UnsafeRestQuery.prototype.cleanResultAuthData = function (result) {\n   delete result.password;\n   if (result.authData) {\n     Object.keys(result.authData).forEach(provider => {\n@@ -635,7 +719,7 @@ const replaceEqualityConstraint = constraint => {\n   return constraint;\n };\n \n-RestQuery.prototype.replaceEquality = function () {\n+_UnsafeRestQuery.prototype.replaceEquality = function () {\n   if (typeof this.restWhere !== 'object') {\n     return;\n   }\n@@ -646,7 +730,7 @@ RestQuery.prototype.replaceEquality = function () {\n \n // Returns a promise for whether it was successful.\n // Populates this.response with an object that only has 'results'.\n-RestQuery.prototype.runFind = function (options = {}) {\n+_UnsafeRestQuery.prototype.runFind = function (options = {}) {\n   if (this.findOptions.limit === 0) {\n     this.response = { results: [] };\n     return Promise.resolve();\n@@ -682,7 +766,7 @@ RestQuery.prototype.runFind = function (options = {}) {\n \n // Returns a promise for whether it was successful.\n // Populates this.response.count with the count\n-RestQuery.prototype.runCount = function () {\n+_UnsafeRestQuery.prototype.runCount = function () {\n   if (!this.doCount) {\n     return;\n   }\n@@ -694,7 +778,7 @@ RestQuery.prototype.runCount = function () {\n   });\n };\n \n-RestQuery.prototype.denyProtectedFields = async function () {\n+_UnsafeRestQuery.prototype.denyProtectedFields = async function () {\n   if (this.auth.isMaster) {\n     return;\n   }\n@@ -719,7 +803,7 @@ RestQuery.prototype.denyProtectedFields = async function () {\n };\n \n // Augments this.response with all pointers on an object\n-RestQuery.prototype.handleIncludeAll = function () {\n+_UnsafeRestQuery.prototype.handleIncludeAll = function () {\n   if (!this.includeAll) {\n     return;\n   }\n@@ -748,7 +832,7 @@ RestQuery.prototype.handleIncludeAll = function () {\n };\n \n // Updates property `this.keys` to contain all keys but the ones unselected.\n-RestQuery.prototype.handleExcludeKeys = function () {\n+_UnsafeRestQuery.prototype.handleExcludeKeys = function () {\n   if (!this.excludeKeys) {\n     return;\n   }\n@@ -766,7 +850,7 @@ RestQuery.prototype.handleExcludeKeys = function () {\n };\n \n // Augments this.response with data at the paths provided in this.include.\n-RestQuery.prototype.handleInclude = function () {\n+_UnsafeRestQuery.prototype.handleInclude = function () {\n   if (this.include.length == 0) {\n     return;\n   }\n@@ -793,7 +877,7 @@ RestQuery.prototype.handleInclude = function () {\n };\n \n //Returns a promise of a processed set of results\n-RestQuery.prototype.runAfterFindTrigger = function () {\n+_UnsafeRestQuery.prototype.runAfterFindTrigger = function () {\n   if (!this.response) {\n     return;\n   }\n@@ -845,7 +929,7 @@ RestQuery.prototype.runAfterFindTrigger = function () {\n     });\n };\n \n-RestQuery.prototype.handleAuthAdapters = async function () {\n+_UnsafeRestQuery.prototype.handleAuthAdapters = async function () {\n   if (this.className !== '_User' || this.findOptions.explain) {\n     return;\n   }\n@@ -927,15 +1011,22 @@ function includePath(config, auth, response, path, restOptions = {}) {\n     includeRestOptions.readPreference = restOptions.readPreference;\n   }\n \n-  const queryPromises = Object.keys(pointersHash).map(className => {\n+  const queryPromises = Object.keys(pointersHash).map(async className => {\n     const objectIds = Array.from(pointersHash[className]);\n     let where;\n     if (objectIds.length === 1) {\n       where = { objectId: objectIds[0] };\n     } else {\n       where = { objectId: { $in: objectIds } };\n     }\n-    var query = new RestQuery(config, auth, className, where, includeRestOptions);\n+    const query = await RestQuery({\n+      method: objectIds.length === 1 ? RestQuery.Method.get : RestQuery.Method.find,\n+      config,\n+      auth,\n+      className,\n+      restWhere: where,\n+      restOptions: includeRestOptions,\n+    });\n     return query.execute({ op: 'get' }).then(results => {\n       results.className = className;\n       return Promise.resolve(results);\n@@ -1066,3 +1157,5 @@ function findObjectWithKey(root, key) {\n }\n \n module.exports = RestQuery;\n+// For tests\n+module.exports._UnsafeRestQuery = _UnsafeRestQuery;"
        },
        {
          "filename": "src/RestWrite.js",
          "status": "modified",
          "additions": 19,
          "deletions": 13,
          "patch": "@@ -603,7 +603,7 @@ RestWrite.prototype.handleAuthData = async function (authData) {\n };\n \n // The non-third-party parts of User transformation\n-RestWrite.prototype.transformUser = function () {\n+RestWrite.prototype.transformUser = async function () {\n   var promise = Promise.resolve();\n   if (this.className !== '_User') {\n     return promise;\n@@ -618,19 +618,25 @@ RestWrite.prototype.transformUser = function () {\n   if (this.query && this.objectId()) {\n     // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n     // session tokens, and remove them from the cache.\n-    promise = new RestQuery(this.config, Auth.master(this.config), '_Session', {\n-      user: {\n-        __type: 'Pointer',\n-        className: '_User',\n-        objectId: this.objectId(),\n+    const query = await RestQuery({\n+      method: RestQuery.Method.find,\n+      config: this.config,\n+      auth: Auth.master(this.config),\n+      className: '_Session',\n+      runBeforeFind: false,\n+      restWhere: {\n+        user: {\n+          __type: 'Pointer',\n+          className: '_User',\n+          objectId: this.objectId(),\n+        },\n       },\n-    })\n-      .execute()\n-      .then(results => {\n-        results.results.forEach(session =>\n-          this.config.cacheController.user.del(session.sessionToken)\n-        );\n-      });\n+    });\n+    promise = query.execute().then(results => {\n+      results.results.forEach(session =>\n+        this.config.cacheController.user.del(session.sessionToken)\n+      );\n+    });\n   }\n \n   return promise"
        },
        {
          "filename": "src/SharedRest.js",
          "status": "added",
          "additions": 37,
          "deletions": 0,
          "patch": "@@ -0,0 +1,37 @@\n+const classesWithMasterOnlyAccess = [\n+  '_JobStatus',\n+  '_PushStatus',\n+  '_Hooks',\n+  '_GlobalConfig',\n+  '_JobSchedule',\n+  '_Idempotency',\n+];\n+// Disallowing access to the _Role collection except by master key\n+function enforceRoleSecurity(method, className, auth) {\n+  if (className === '_Installation' && !auth.isMaster && !auth.isMaintenance) {\n+    if (method === 'delete' || method === 'find') {\n+      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`;\n+      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n+    }\n+  }\n+\n+  //all volatileClasses are masterKey only\n+  if (\n+    classesWithMasterOnlyAccess.indexOf(className) >= 0 &&\n+    !auth.isMaster &&\n+    !auth.isMaintenance\n+  ) {\n+    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`;\n+    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n+  }\n+\n+  // readOnly masterKey is not allowed\n+  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {\n+    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`;\n+    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n+  }\n+}\n+\n+module.exports = {\n+  enforceRoleSecurity,\n+};"
        },
        {
          "filename": "src/rest.js",
          "status": "modified",
          "additions": 63,
          "deletions": 121,
          "patch": "@@ -12,6 +12,7 @@ var Parse = require('parse/node').Parse;\n var RestQuery = require('./RestQuery');\n var RestWrite = require('./RestWrite');\n var triggers = require('./triggers');\n+const { enforceRoleSecurity } = require('./SharedRest');\n \n function checkTriggers(className, config, types) {\n   return types.some(triggerType => {\n@@ -24,65 +25,34 @@ function checkLiveQuery(className, config) {\n }\n \n // Returns a promise for an object with optional keys 'results' and 'count'.\n-function find(config, auth, className, restWhere, restOptions, clientSDK, context) {\n-  enforceRoleSecurity('find', className, auth);\n-  return triggers\n-    .maybeRunQueryTrigger(\n-      triggers.Types.beforeFind,\n-      className,\n-      restWhere,\n-      restOptions,\n-      config,\n-      auth,\n-      context\n-    )\n-    .then(result => {\n-      restWhere = result.restWhere || restWhere;\n-      restOptions = result.restOptions || restOptions;\n-      const query = new RestQuery(\n-        config,\n-        auth,\n-        className,\n-        restWhere,\n-        restOptions,\n-        clientSDK,\n-        true,\n-        context\n-      );\n-      return query.execute();\n-    });\n-}\n+const find = async (config, auth, className, restWhere, restOptions, clientSDK, context) => {\n+  const query = await RestQuery({\n+    method: RestQuery.Method.find,\n+    config,\n+    auth,\n+    className,\n+    restWhere,\n+    restOptions,\n+    clientSDK,\n+    context,\n+  });\n+  return query.execute();\n+};\n \n // get is just like find but only queries an objectId.\n-const get = (config, auth, className, objectId, restOptions, clientSDK, context) => {\n+const get = async (config, auth, className, objectId, restOptions, clientSDK, context) => {\n   var restWhere = { objectId };\n-  enforceRoleSecurity('get', className, auth);\n-  return triggers\n-    .maybeRunQueryTrigger(\n-      triggers.Types.beforeFind,\n-      className,\n-      restWhere,\n-      restOptions,\n-      config,\n-      auth,\n-      context,\n-      true\n-    )\n-    .then(result => {\n-      restWhere = result.restWhere || restWhere;\n-      restOptions = result.restOptions || restOptions;\n-      const query = new RestQuery(\n-        config,\n-        auth,\n-        className,\n-        restWhere,\n-        restOptions,\n-        clientSDK,\n-        true,\n-        context\n-      );\n-      return query.execute();\n-    });\n+  const query = await RestQuery({\n+    method: RestQuery.Method.get,\n+    config,\n+    auth,\n+    className,\n+    restWhere,\n+    restOptions,\n+    clientSDK,\n+    context,\n+  });\n+  return query.execute();\n };\n \n // Returns a promise that doesn't resolve to any useful value.\n@@ -101,35 +71,40 @@ function del(config, auth, className, objectId, context) {\n   let schemaController;\n \n   return Promise.resolve()\n-    .then(() => {\n+    .then(async () => {\n       const hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);\n       const hasLiveQuery = checkLiveQuery(className, config);\n       if (hasTriggers || hasLiveQuery || className == '_Session') {\n-        return new RestQuery(config, auth, className, { objectId })\n-          .execute({ op: 'delete' })\n-          .then(response => {\n-            if (response && response.results && response.results.length) {\n-              const firstResult = response.results[0];\n-              firstResult.className = className;\n-              if (className === '_Session' && !auth.isMaster && !auth.isMaintenance) {\n-                if (!auth.user || firstResult.user.objectId !== auth.user.id) {\n-                  throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n-                }\n+        const query = await RestQuery({\n+          method: RestQuery.Method.get,\n+          config,\n+          auth,\n+          className,\n+          restWhere: { objectId },\n+        });\n+        return query.execute({ op: 'delete' }).then(response => {\n+          if (response && response.results && response.results.length) {\n+            const firstResult = response.results[0];\n+            firstResult.className = className;\n+            if (className === '_Session' && !auth.isMaster && !auth.isMaintenance) {\n+              if (!auth.user || firstResult.user.objectId !== auth.user.id) {\n+                throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n               }\n-              var cacheAdapter = config.cacheController;\n-              cacheAdapter.user.del(firstResult.sessionToken);\n-              inflatedObject = Parse.Object.fromJSON(firstResult);\n-              return triggers.maybeRunTrigger(\n-                triggers.Types.beforeDelete,\n-                auth,\n-                inflatedObject,\n-                null,\n-                config,\n-                context\n-              );\n             }\n-            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');\n-          });\n+            var cacheAdapter = config.cacheController;\n+            cacheAdapter.user.del(firstResult.sessionToken);\n+            inflatedObject = Parse.Object.fromJSON(firstResult);\n+            return triggers.maybeRunTrigger(\n+              triggers.Types.beforeDelete,\n+              auth,\n+              inflatedObject,\n+              null,\n+              config,\n+              context\n+            );\n+          }\n+          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');\n+        });\n       }\n       return Promise.resolve({});\n     })\n@@ -193,21 +168,22 @@ function update(config, auth, className, restWhere, restObject, clientSDK, conte\n   enforceRoleSecurity('update', className, auth);\n \n   return Promise.resolve()\n-    .then(() => {\n+    .then(async () => {\n       const hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);\n       const hasLiveQuery = checkLiveQuery(className, config);\n       if (hasTriggers || hasLiveQuery) {\n         // Do not use find, as it runs the before finds\n-        return new RestQuery(\n+        const query = await RestQuery({\n+          method: RestQuery.Method.get,\n           config,\n           auth,\n           className,\n           restWhere,\n-          undefined,\n-          undefined,\n-          false,\n-          context\n-        ).execute({\n+          runAfterFind: false,\n+          runBeforeFind: false,\n+          context,\n+        });\n+        return query.execute({\n           op: 'update',\n         });\n       }\n@@ -248,40 +224,6 @@ function handleSessionMissingError(error, className, auth) {\n   throw error;\n }\n \n-const classesWithMasterOnlyAccess = [\n-  '_JobStatus',\n-  '_PushStatus',\n-  '_Hooks',\n-  '_GlobalConfig',\n-  '_JobSchedule',\n-  '_Idempotency',\n-];\n-// Disallowing access to the _Role collection except by master key\n-function enforceRoleSecurity(method, className, auth) {\n-  if (className === '_Installation' && !auth.isMaster && !auth.isMaintenance) {\n-    if (method === 'delete' || method === 'find') {\n-      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`;\n-      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n-    }\n-  }\n-\n-  //all volatileClasses are masterKey only\n-  if (\n-    classesWithMasterOnlyAccess.indexOf(className) >= 0 &&\n-    !auth.isMaster &&\n-    !auth.isMaintenance\n-  ) {\n-    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`;\n-    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n-  }\n-\n-  // readOnly masterKey is not allowed\n-  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {\n-    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`;\n-    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n-  }\n-}\n-\n module.exports = {\n   create,\n   del,"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "28b3edee4e76679dedee9fe115283110fd952678",
            "date": "2025-01-13T15:19:51Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1b61cab81c4206ce135f1239f17a53dabbc698d7",
            "date": "2025-01-13T14:47:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a0efad88d2177f027ee3709beba13282a6ca9d35",
            "date": "2025-01-12T20:55:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "bb1daafef0f5f0b6a9c9b33c9d7e0529fd49afbf",
            "date": "2025-01-12T18:53:43Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3f0f29b4dfaf6038cb0f0dd205cfa8e1cf92c0c4",
            "date": "2025-01-12T14:04:34Z",
            "author_login": "semantic-release-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-670",
    "description": "Parse Server is an open source backend server. In affected versions the Parse Cloud trigger `beforeFind` is not invoked in certain conditions of `Parse.Query`. This can pose a vulnerability for deployments where the `beforeFind` trigger is used as a security layer to modify the incoming query. The vulnerability has been fixed by refactoring the internal query pipeline for a more concise code structure and implementing a patch to ensure the `beforeFind` trigger is invoked. This fix was introduced in commit `be4c7e23c6` and has been included in releases 6.2.2 and 5.5.5. Users are advised to upgrade. Users unable to upgrade should make use of parse server's security layers to manage access levels with Class-Level Permissions and Object-Level Access Control that should be used instead of custom security layers in Cloud Code triggers.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-09-04T23:15:47.513",
    "last_modified": "2024-11-21T08:20:28.660",
    "fix_date": "2023-09-04T12:19:48Z"
  },
  "references": [
    {
      "url": "https://docs.parseplatform.org/parse-server/guide/#security",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/commit/be4c7e23c63a2fb690685665cebed0de26be05c5",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/releases/tag/5.5.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/releases/tag/6.2.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-fcv6-fg5r-jm9q",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://docs.parseplatform.org/parse-server/guide/#security",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/commit/be4c7e23c63a2fb690685665cebed0de26be05c5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/releases/tag/5.5.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/releases/tag/6.2.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-fcv6-fg5r-jm9q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:08.380827",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "parse-server",
    "owner": "parse-community",
    "created_at": "2016-01-28T18:29:14Z",
    "updated_at": "2025-01-13T16:51:06Z",
    "pushed_at": "2025-01-14T11:16:34Z",
    "size": 73208,
    "stars": 20994,
    "forks": 4781,
    "open_issues": 474,
    "watchers": 20994,
    "has_security_policy": false,
    "default_branch": "alpha",
    "protected_branches": [
      "alpha",
      "beta",
      "release",
      "release-4.x.x",
      "release-5.x.x",
      "release-6.x.x",
      "release-7.x.x"
    ],
    "languages": {
      "JavaScript": 4248231,
      "HTML": 25876,
      "Shell": 7825,
      "Handlebars": 2113,
      "Dockerfile": 1211
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:26:59.166995"
  }
}