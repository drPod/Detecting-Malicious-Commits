{
  "cve_id": "CVE-2023-42450",
  "github_data": {
    "repository": "mastodon/mastodon",
    "fix_commit": "94893cf24fc95b32cc7a756262acbe008c20a9d2",
    "related_commits": [
      "94893cf24fc95b32cc7a756262acbe008c20a9d2",
      "94893cf24fc95b32cc7a756262acbe008c20a9d2"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "94893cf24fc95b32cc7a756262acbe008c20a9d2",
      "commit_date": "2023-09-19T14:52:52Z",
      "author": {
        "login": "ClearlyClaire",
        "type": "User",
        "stats": {
          "total_commits": 2275,
          "average_weekly_commits": 4.861111111111111,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 356
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-hcqf-fw2r-52g4",
        "length": 318,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 206,
        "additions": 4,
        "deletions": 202
      },
      "files": [
        {
          "filename": "app/lib/request.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 21,
          "patch": "@@ -68,26 +68,13 @@ class Request\n   # about 15s in total\n   TIMEOUT = { connect_timeout: 5, read_timeout: 10, write_timeout: 10, read_deadline: 30 }.freeze\n \n-  # Workaround for overly-eager decoding of percent-encoded characters in Addressable::URI#normalized_path\n-  # https://github.com/sporkmonger/addressable/issues/366\n-  URI_NORMALIZER = lambda do |uri|\n-    uri = HTTP::URI.parse(uri)\n-\n-    HTTP::URI.new(\n-      scheme: uri.normalized_scheme,\n-      authority: uri.normalized_authority,\n-      path: Addressable::URI.normalize_path(encode_non_ascii(uri.path)).presence || '/',\n-      query: encode_non_ascii(uri.query)\n-    )\n-  end\n-\n   include RoutingHelper\n \n   def initialize(verb, url, **options)\n     raise ArgumentError if url.blank?\n \n     @verb        = verb\n-    @url         = URI_NORMALIZER.call(url)\n+    @url         = Addressable::URI.parse(url).normalize\n     @http_client = options.delete(:http_client)\n     @allow_local = options.delete(:allow_local)\n     @options     = options.merge(socket_class: use_proxy? || @allow_local ? ProxySocket : Socket)\n@@ -151,14 +138,8 @@ def valid_url?(url)\n       %w(http https).include?(parsed_url.scheme) && parsed_url.host.present?\n     end\n \n-    NON_ASCII_PATTERN = /[^\\x00-\\x7F]+/\n-\n-    def encode_non_ascii(str)\n-      str&.gsub(NON_ASCII_PATTERN) { |substr| CGI.escape(substr.encode(Encoding::UTF_8)) }\n-    end\n-\n     def http_client\n-      HTTP.use(:auto_inflate).use(normalize_uri: { normalizer: URI_NORMALIZER }).follow(max_hops: 3)\n+      HTTP.use(:auto_inflate).follow(max_hops: 3)\n     end\n   end\n "
        },
        {
          "filename": "spec/controllers/concerns/signature_verification_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 32,
          "patch": "@@ -129,37 +129,6 @@ def signature_required\n       end\n     end\n \n-    context 'with non-normalized URL' do\n-      before do\n-        get :success\n-\n-        fake_request = Request.new(:get, 'http://test.host/subdir/../success')\n-        fake_request.on_behalf_of(author)\n-\n-        request.headers.merge!(fake_request.headers)\n-\n-        allow(controller).to receive(:actor_refresh_key!).and_return(author)\n-      end\n-\n-      describe '#build_signed_string' do\n-        it 'includes the normalized request path' do\n-          expect(controller.send(:build_signed_string)).to start_with \"(request-target): get /success\\n\"\n-        end\n-      end\n-\n-      describe '#signed_request?' do\n-        it 'returns true' do\n-          expect(controller.signed_request?).to be true\n-        end\n-      end\n-\n-      describe '#signed_request_actor' do\n-        it 'returns an account' do\n-          expect(controller.signed_request_account).to eq author\n-        end\n-      end\n-    end\n-\n     context 'with request with unparsable Date header' do\n       before do\n         get :success\n@@ -233,7 +202,7 @@ def signature_required\n \n         request.headers.merge!(fake_request.headers)\n \n-        stub_request(:get, 'http://localhost:5000/actor').to_raise(Mastodon::HostValidationError)\n+        stub_request(:get, 'http://localhost:5000/actor#main-key').to_raise(Mastodon::HostValidationError)\n       end\n \n       describe '#signed_request?' do"
        },
        {
          "filename": "spec/lib/request_spec.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 149,
          "patch": "@@ -4,9 +4,7 @@\n require 'securerandom'\n \n describe Request do\n-  subject { described_class.new(:get, url) }\n-\n-  let(:url) { 'http://example.com' }\n+  subject { described_class.new(:get, 'http://example.com') }\n \n   describe '#headers' do\n     it 'returns user agent' do\n@@ -94,152 +92,6 @@\n         expect { subject.perform }.to raise_error Mastodon::ValidationError\n       end\n     end\n-\n-    context 'with bare domain URL' do\n-      let(:url) { 'http://example.com' }\n-\n-      before do\n-        stub_request(:get, 'http://example.com')\n-      end\n-\n-      it 'normalizes path' do\n-        subject.perform do |response|\n-          expect(response.request.uri.path).to eq '/'\n-        end\n-      end\n-\n-      it 'normalizes path used for request signing' do\n-        subject.perform\n-\n-        headers = subject.instance_variable_get(:@headers)\n-        expect(headers[Request::REQUEST_TARGET]).to eq 'get /'\n-      end\n-\n-      it 'normalizes path used in request line' do\n-        subject.perform do |response|\n-          expect(response.request.headline).to eq 'GET / HTTP/1.1'\n-        end\n-      end\n-    end\n-\n-    context 'with unnormalized URL' do\n-      let(:url) { 'HTTP://EXAMPLE.com:80/foo%41%3A?bar=%41%3A#baz' }\n-\n-      before do\n-        stub_request(:get, 'http://example.com/foo%41%3A?bar=%41%3A')\n-      end\n-\n-      it 'normalizes scheme' do\n-        subject.perform do |response|\n-          expect(response.request.uri.scheme).to eq 'http'\n-        end\n-      end\n-\n-      it 'normalizes host' do\n-        subject.perform do |response|\n-          expect(response.request.uri.authority).to eq 'example.com'\n-        end\n-      end\n-\n-      it 'does not modify path' do\n-        subject.perform do |response|\n-          expect(response.request.uri.path).to eq '/foo%41%3A'\n-        end\n-      end\n-\n-      it 'does not modify query string' do\n-        subject.perform do |response|\n-          expect(response.request.uri.query).to eq 'bar=%41%3A'\n-        end\n-      end\n-\n-      it 'does not modify path used for request signing' do\n-        subject.perform\n-\n-        headers = subject.instance_variable_get(:@headers)\n-        expect(headers[Request::REQUEST_TARGET]).to eq 'get /foo%41%3A'\n-      end\n-\n-      it 'does not modify path used in request line' do\n-        subject.perform do |response|\n-          expect(response.request.headline).to eq 'GET /foo%41%3A?bar=%41%3A HTTP/1.1'\n-        end\n-      end\n-\n-      it 'strips fragment' do\n-        subject.perform do |response|\n-          expect(response.request.uri.fragment).to be_nil\n-        end\n-      end\n-    end\n-\n-    context 'with non-ASCII URL' do\n-      let(:url) { 'http://\u00e9xample.com:81/f\u00f6o?b\u00e4r=1' }\n-\n-      before do\n-        stub_request(:get, 'http://xn--xample-9ua.com:81/f%C3%B6o?b%C3%A4r=1')\n-      end\n-\n-      it 'IDN-encodes host' do\n-        subject.perform do |response|\n-          expect(response.request.uri.authority).to eq 'xn--xample-9ua.com:81'\n-        end\n-      end\n-\n-      it 'IDN-encodes host in Host header' do\n-        subject.perform do |response|\n-          expect(response.request.headers['Host']).to eq 'xn--xample-9ua.com'\n-        end\n-      end\n-\n-      it 'percent-escapes path used for request signing' do\n-        subject.perform\n-\n-        headers = subject.instance_variable_get(:@headers)\n-        expect(headers[Request::REQUEST_TARGET]).to eq 'get /f%C3%B6o'\n-      end\n-\n-      it 'normalizes path used in request line' do\n-        subject.perform do |response|\n-          expect(response.request.headline).to eq 'GET /f%C3%B6o?b%C3%A4r=1 HTTP/1.1'\n-        end\n-      end\n-    end\n-\n-    context 'with redirecting URL' do\n-      let(:url) { 'http://example.com/foo' }\n-\n-      before do\n-        stub_request(:get, 'http://example.com/foo').to_return(status: 302, headers: { 'Location' => 'HTTPS://EXAMPLE.net/Bar' })\n-        stub_request(:get, 'https://example.net/Bar').to_return(body: 'Lorem ipsum')\n-      end\n-\n-      it 'resolves redirect' do\n-        subject.perform do |response|\n-          expect(response.body.to_s).to eq 'Lorem ipsum'\n-        end\n-\n-        expect(a_request(:get, 'https://example.net/Bar')).to have_been_made\n-      end\n-\n-      it 'normalizes destination scheme' do\n-        subject.perform do |response|\n-          expect(response.request.uri.scheme).to eq 'https'\n-        end\n-      end\n-\n-      it 'normalizes destination host' do\n-        subject.perform do |response|\n-          expect(response.request.uri.authority).to eq 'example.net'\n-        end\n-      end\n-\n-      it 'does modify path' do\n-        subject.perform do |response|\n-          expect(response.request.uri.path).to eq '/Bar'\n-        end\n-      end\n-    end\n   end\n \n   describe \"response's body_with_limit method\" do"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2df86d6413d14c269d630ac39f5f9da1e7f07417",
            "date": "2025-01-24T22:20:05Z",
            "author_login": "Gargron"
          },
          {
            "sha": "79cbb6160d9e374c6274da7d44de0e663a978a37",
            "date": "2025-01-24T17:16:22Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "f73df1f2b058e782cb3ff3e4c4a08d2768db7c90",
            "date": "2025-01-24T16:57:55Z",
            "author_login": "mjankowski"
          },
          {
            "sha": "469c8f8db16cc5fe48c1831364551129d53c9d0c",
            "date": "2025-01-24T16:49:48Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "9a0166c3f30fdc0fa60d4be5e88ebc03ec69f4ed",
            "date": "2025-01-24T16:11:23Z",
            "author_login": "ClearlyClaire"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-113",
    "description": "Mastodon is a free, open-source social network server based on ActivityPub. Starting in version 4.2.0-beta1 and prior to version 4.2.0-rc2, by crafting specific input, attackers can inject arbitrary data into HTTP requests issued by Mastodon. This can be used to perform confused deputy attacks if the server configuration includes `ALLOWED_PRIVATE_ADDRESSES` to allow access to local exploitable services. Version 4.2.0-rc2 has a patch for the issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-09-19T16:15:12.897",
    "last_modified": "2024-11-21T08:22:33.413",
    "fix_date": "2023-09-19T14:52:52Z"
  },
  "references": [
    {
      "url": "https://github.com/mastodon/mastodon/commit/94893cf24fc95b32cc7a756262acbe008c20a9d2",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/mastodon/mastodon/security/advisories/GHSA-hcqf-fw2r-52g4",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/mastodon/mastodon/commit/94893cf24fc95b32cc7a756262acbe008c20a9d2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/mastodon/mastodon/security/advisories/GHSA-hcqf-fw2r-52g4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:08.426048",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "mastodon",
    "owner": "mastodon",
    "created_at": "2016-02-22T15:01:25Z",
    "updated_at": "2025-01-26T06:33:16Z",
    "pushed_at": "2025-01-26T04:26:40Z",
    "size": 277664,
    "stars": 47604,
    "forks": 7074,
    "open_issues": 4022,
    "watchers": 47604,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 4661421,
      "JavaScript": 1241760,
      "TypeScript": 654337,
      "SCSS": 341279,
      "Haml": 320601,
      "Dockerfile": 18732,
      "HTML": 13453,
      "Shell": 2288,
      "Procfile": 911,
      "CSS": 51
    },
    "commit_activity": {
      "total_commits_last_year": 2991,
      "avg_commits_per_week": 57.51923076923077,
      "days_active_last_year": 267
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-26T07:34:39.823447"
  }
}