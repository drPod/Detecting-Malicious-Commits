{
  "cve_id": "CVE-2023-42456",
  "github_data": {
    "repository": "memorysafety/sudo-rs",
    "fix_commit": "bfdbda22968e3de43fa8246cab1681cfd5d5493d",
    "related_commits": [
      "bfdbda22968e3de43fa8246cab1681cfd5d5493d",
      "bfdbda22968e3de43fa8246cab1681cfd5d5493d"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "bfdbda22968e3de43fa8246cab1681cfd5d5493d",
      "commit_date": "2023-09-21T14:23:07Z",
      "author": {
        "login": "rnijveld",
        "type": "User",
        "stats": {
          "total_commits": 132,
          "average_weekly_commits": 1.1785714285714286,
          "total_additions": 41630,
          "total_deletions": 36079,
          "weeks_active": 30
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2r3c-m6v7-9354",
        "length": 98,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 41,
        "additions": 22,
        "deletions": 19
      },
      "files": [
        {
          "filename": "src/sudo/mod.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -92,15 +92,15 @@ fn sudo_process() -> Result<(), Error> {\n             SudoAction::RemoveTimestamp => {\n                 let user = resolve_current_user()?;\n                 let mut record_file =\n-                    SessionRecordFile::open_for_user(&user.name, Duration::seconds(0))?;\n+                    SessionRecordFile::open_for_user(user.uid, Duration::seconds(0))?;\n                 record_file.reset()?;\n                 Ok(())\n             }\n             SudoAction::ResetTimestamp => {\n                 if let Some(scope) = RecordScope::for_process(&Process::new()) {\n                     let user = resolve_current_user()?;\n                     let mut record_file =\n-                        SessionRecordFile::open_for_user(&user.name, Duration::seconds(0))?;\n+                        SessionRecordFile::open_for_user(user.uid, Duration::seconds(0))?;\n                     record_file.disable(scope, None)?;\n                 }\n                 Ok(())"
        },
        {
          "filename": "src/sudo/pipeline.rs",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -133,7 +133,7 @@ impl<Policy: PolicyPlugin, Auth: AuthPlugin> Pipeline<Policy, Auth> {\n             context.use_session_records,\n             scope,\n             context.current_user.uid,\n-            &context.current_user.name,\n+            context.current_user.uid,\n             prior_validity,\n         );\n         self.authenticator.init(context)?;\n@@ -201,7 +201,7 @@ fn determine_auth_status(\n     use_session_records: bool,\n     record_for: Option<RecordScope>,\n     auth_uid: UserId,\n-    current_user: &str,\n+    current_user: UserId,\n     prior_validity: Duration,\n ) -> AuthStatus {\n     if !must_policy_authenticate {\n@@ -232,13 +232,13 @@ fn determine_auth_status(\n     }\n }\n \n-struct AuthStatus<'a> {\n+struct AuthStatus {\n     must_authenticate: bool,\n-    record_file: Option<SessionRecordFile<'a>>,\n+    record_file: Option<SessionRecordFile>,\n }\n \n-impl<'a> AuthStatus<'a> {\n-    fn new(must_authenticate: bool, record_file: Option<SessionRecordFile<'a>>) -> AuthStatus<'a> {\n+impl AuthStatus {\n+    fn new(must_authenticate: bool, record_file: Option<SessionRecordFile>) -> AuthStatus {\n         AuthStatus {\n             must_authenticate,\n             record_file,"
        },
        {
          "filename": "src/system/timestamp.rs",
          "status": "modified",
          "additions": 14,
          "deletions": 11,
          "patch": "@@ -35,18 +35,18 @@ const SIZE_OF_BOOL: i64 = std::mem::size_of::<BoolStorage>() as i64;\n const MOD_OFFSET: i64 = SIZE_OF_TS + SIZE_OF_BOOL;\n \n #[derive(Debug)]\n-pub struct SessionRecordFile<'u> {\n+pub struct SessionRecordFile {\n     file: File,\n     timeout: Duration,\n-    for_user: &'u str,\n+    for_user: UserId,\n }\n \n-impl<'u> SessionRecordFile<'u> {\n+impl SessionRecordFile {\n     const BASE_PATH: &'static str = \"/var/run/sudo-rs/ts\";\n \n-    pub fn open_for_user(user: &'u str, timeout: Duration) -> io::Result<Self> {\n+    pub fn open_for_user(user: UserId, timeout: Duration) -> io::Result<Self> {\n         let mut path = PathBuf::from(Self::BASE_PATH);\n-        path.push(user);\n+        path.push(user.to_string());\n         SessionRecordFile::new(user, secure_open_cookie_file(&path)?, timeout)\n     }\n \n@@ -59,7 +59,7 @@ impl<'u> SessionRecordFile<'u> {\n     /// Create a new SessionRecordFile from the given i/o stream.\n     /// Timestamps in this file are considered valid if they were created or\n     /// updated at most `timeout` time ago.\n-    pub fn new(for_user: &'u str, io: File, timeout: Duration) -> io::Result<Self> {\n+    pub fn new(for_user: UserId, io: File, timeout: Duration) -> io::Result<Self> {\n         let mut session_records = SessionRecordFile {\n             file: io,\n             timeout,\n@@ -578,6 +578,8 @@ mod tests {\n \n     use crate::system::tests::tempfile;\n \n+    const TEST_USER_ID: UserId = 1000;\n+\n     impl SetLength for Cursor<Vec<u8>> {\n         fn set_len(&mut self, new_len: usize) -> io::Result<()> {\n             self.get_mut().truncate(new_len);\n@@ -714,25 +716,25 @@ mod tests {\n         // valid header should remain valid\n         let c = tempfile_with_data(&[0xD0, 0x50, 0x01, 0x00]).unwrap();\n         let timeout = Duration::seconds(30);\n-        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n+        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n         let v = data_from_tempfile(c).unwrap();\n         assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n \n         // invalid headers should be corrected\n         let c = tempfile_with_data(&[0xAB, 0xBA]).unwrap();\n-        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n+        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n         let v = data_from_tempfile(c).unwrap();\n         assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n \n         // empty header should be filled in\n         let c = tempfile_with_data(&[]).unwrap();\n-        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n+        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n         let v = data_from_tempfile(c).unwrap();\n         assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n \n         // invalid version should reset file\n         let c = tempfile_with_data(&[0xD0, 0x50, 0xAB, 0xBA, 0x0, 0x0]).unwrap();\n-        assert!(SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).is_ok());\n+        assert!(SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).is_ok());\n         let v = data_from_tempfile(c).unwrap();\n         assert_eq!(&v[..], &[0xD0, 0x50, 0x01, 0x00]);\n     }\n@@ -741,7 +743,8 @@ mod tests {\n     fn can_create_and_update_valid_file() {\n         let timeout = Duration::seconds(30);\n         let c = tempfile_with_data(&[]).unwrap();\n-        let mut srf = SessionRecordFile::new(\"test\", c.try_clone().unwrap(), timeout).unwrap();\n+        let mut srf =\n+            SessionRecordFile::new(TEST_USER_ID, c.try_clone().unwrap(), timeout).unwrap();\n         let tty_scope = RecordScope::Tty {\n             tty_device: 0,\n             session_pid: 0,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f0cb82fb092c817503d575002ad62c964dafd752",
            "date": "2025-01-21T14:14:11Z",
            "author_login": "squell"
          },
          {
            "sha": "93daf6731aeccb1c28b8bad5a1ec8b602f646107",
            "date": "2025-01-21T12:59:40Z",
            "author_login": "bjorn3"
          },
          {
            "sha": "85e22ee82518cf382058e7dd647cf0e43fdae8a6",
            "date": "2025-01-17T16:06:24Z",
            "author_login": "bjorn3"
          },
          {
            "sha": "4eb641f1e5f7503436c0f548a54d79235b1ec304",
            "date": "2025-01-17T14:27:16Z",
            "author_login": "bjorn3"
          },
          {
            "sha": "4b644d8ac38ff87e687f068e3ccb41b0d7d4f929",
            "date": "2025-01-21T13:57:16Z",
            "author_login": "squell"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.1,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:N/I:L/A:L",
    "cwe_id": "CWE-22",
    "description": "Sudo-rs, a memory safe implementation of sudo and su, allows users to not have to enter authentication at every sudo attempt, but instead only requiring authentication every once in a while in every terminal or process group. Only once a configurable timeout has passed will the user have to re-authenticate themselves. Supporting this functionality is a set of session files (timestamps) for each user, stored in `/var/run/sudo-rs/ts`. These files are named according to the username from which the sudo attempt is made (the origin user).\n\nAn issue was discovered in versions prior to 0.2.1 where usernames containing the `.` and `/` characters could result in the corruption of specific files on the filesystem. As usernames are generally not limited by the characters they can contain, a username appearing to be a relative path can be constructed. For example we could add a user to the system containing the username `../../../../bin/cp`. When logged in as a user with that name, that user could run `sudo -K` to clear their session record file. The session code then constructs the path to the session file by concatenating the username to the session file storage directory, resulting in a resolved path of `/bin/cp`. The code then clears that file, resulting in the `cp` binary effectively being removed from the system.\n\nAn attacker needs to be able to login as a user with a constructed username. Given that such a username is unlikely to exist on an existing system, they will also need to be able to create the users with the constructed usernames.\n\nThe issue is patched in version 0.2.1 of sudo-rs. Sudo-rs now uses the uid for the user instead of their username for determining the filename. Note that an upgrade to this version will result in existing session files being ignored and users will be forced to re-authenticate. It also fully eliminates any possibility of path traversal, given that uids are always integer values.\n\nThe `sudo -K` and `sudo -k` commands can run, even if a user has no sudo access. As a workaround, make sure that one's system does not contain any users with a specially crafted username. While this is the case and while untrusted users do not have the ability to create arbitrary users on the system, one should not be able to exploit this issue.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-09-21T16:15:09.980",
    "last_modified": "2024-11-21T08:22:34.333",
    "fix_date": "2023-09-21T14:23:07Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2023/11/02/1",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://ferrous-systems.com/blog/sudo-rs-audit/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/memorysafety/sudo-rs/commit/bfdbda22968e3de43fa8246cab1681cfd5d5493d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/memorysafety/sudo-rs/security/advisories/GHSA-2r3c-m6v7-9354",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2023/11/02/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://ferrous-systems.com/blog/sudo-rs-audit/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/memorysafety/sudo-rs/commit/bfdbda22968e3de43fa8246cab1681cfd5d5493d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/memorysafety/sudo-rs/security/advisories/GHSA-2r3c-m6v7-9354",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:08.436830",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "sudo-rs",
    "owner": "memorysafety",
    "created_at": "2022-12-12T16:40:01Z",
    "updated_at": "2025-01-23T00:40:28Z",
    "pushed_at": "2025-01-22T10:35:05Z",
    "size": 3522,
    "stars": 2973,
    "forks": 81,
    "open_issues": 67,
    "watchers": 2973,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 1092742,
      "Shell": 10161,
      "Dockerfile": 2440,
      "Makefile": 1186,
      "C": 31
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:37:59.772538"
  }
}