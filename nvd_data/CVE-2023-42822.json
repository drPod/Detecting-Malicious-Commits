{
  "cve_id": "CVE-2023-42822",
  "github_data": {
    "repository": "neutrinolabs/xrdp",
    "fix_commit": "73acbe1f7957c65122b00de4d6f57a8d0d257c40",
    "related_commits": [
      "73acbe1f7957c65122b00de4d6f57a8d0d257c40",
      "73acbe1f7957c65122b00de4d6f57a8d0d257c40"
    ],
    "patch_url": "https://github.com/neutrinolabs/xrdp/commit/73acbe1f7957c65122b00de4d6f57a8d0d257c40.patch",
    "fix_commit_details": {
      "sha": "73acbe1f7957c65122b00de4d6f57a8d0d257c40",
      "commit_date": "2023-09-27T08:37:24Z",
      "author": {
        "login": "metalefty",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2hjx-rm4f-r9hw",
        "length": 59,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 155,
        "additions": 127,
        "deletions": 28
      },
      "files": [
        {
          "filename": "xrdp/xrdp.h",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -381,6 +381,15 @@ xrdp_font_delete(struct xrdp_font *self);\n int\n xrdp_font_item_compare(struct xrdp_font_char *font1,\n                        struct xrdp_font_char *font2);\n+/**\n+ * Gets a checked xrdp_font_char from a font\n+ * @param f Font\n+ * @param c32 Unicode codepoint\n+ */\n+#define XRDP_FONT_GET_CHAR(f, c32) \\\n+    (((unsigned int)(c32) >= ' ') && ((unsigned int)(c32) < (f)->char_count) \\\n+     ? ((f)->chars + (unsigned int)(c32)) \\\n+     : (f)->default_char)\n \n /* funcs.c */\n int"
        },
        {
          "filename": "xrdp/xrdp_font.c",
          "status": "modified",
          "additions": 108,
          "deletions": 22,
          "patch": "@@ -52,6 +52,12 @@ static char w_char[] =\n };\n #endif\n \n+// Unicode definitions\n+#define UNICODE_WHITE_SQUARE 0x25a1\n+\n+// First character allocated in the 'struct xrdp_font.chars' array\n+#define FIRST_CHAR ' '\n+\n /*****************************************************************************/\n /**\n  * Parses the fv1_select configuration value to get the font to use,\n@@ -145,8 +151,8 @@ xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n     int fd;\n     int b;\n     int i;\n-    int index;\n-    int datasize;\n+    unsigned int char_count;\n+    unsigned int datasize; // Size of glyph data on disk\n     int file_size;\n     struct xrdp_font_char *f;\n     const char *file_path;\n@@ -207,17 +213,39 @@ xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n     }\n \n     self = (struct xrdp_font *)g_malloc(sizeof(struct xrdp_font), 1);\n+    if (self == NULL)\n+    {\n+        LOG(LOG_LEVEL_ERROR, \"xrdp_font_create: \"\n+            \"Can't allocate memory for font\");\n+        return self;\n+    }\n     self->wm = wm;\n     make_stream(s);\n     init_stream(s, file_size + 1024);\n     fd = g_file_open_ro(file_path);\n \n-    if (fd != -1)\n+    if (fd < 0)\n+    {\n+        LOG(LOG_LEVEL_ERROR,\n+            \"xrdp_font_create: Can't open %s - %s\", file_path,\n+            g_get_strerror());\n+        g_free(self);\n+        self = NULL;\n+    }\n+    else\n     {\n         b = g_file_read(fd, s->data, file_size + 1024);\n         g_file_close(fd);\n \n-        if (b > 0)\n+        // Got at least a header?\n+        if (b < (4 + 32 + 2 + 2 + 2 + 2 + 4))\n+        {\n+            LOG(LOG_LEVEL_ERROR,\n+                \"xrdp_font_create: Font %s is truncated\", file_path);\n+            g_free(self);\n+            self = NULL;\n+        }\n+        else\n         {\n             s->end = s->data + b;\n             in_uint8s(s, 4);\n@@ -227,11 +255,27 @@ xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n             in_uint16_le(s, self->body_height);\n             in_sint16_le(s, min_descender);\n             in_uint8s(s, 4);\n-            index = 32;\n+            char_count = FIRST_CHAR;\n \n-            while (s_check_rem(s, 16))\n+            while (!s_check_end(s))\n             {\n-                f = self->font_items + index;\n+                if (!s_check_rem(s, 16))\n+                {\n+                    LOG(LOG_LEVEL_WARNING,\n+                        \"xrdp_font_create: \"\n+                        \"Can't parse header for character U+%X\", char_count);\n+                    break;\n+                }\n+\n+                if (char_count >= MAX_FONT_CHARS)\n+                {\n+                    LOG(LOG_LEVEL_WARNING,\n+                        \"xrdp_font_create: \"\n+                        \"Ignoring characters >= U+%x\", MAX_FONT_CHARS);\n+                    break;\n+                }\n+\n+                f = self->chars + char_count;\n                 in_sint16_le(s, i);\n                 f->width = i;\n                 in_sint16_le(s, i);\n@@ -249,9 +293,19 @@ xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n                 if (datasize < 0 || datasize > 512)\n                 {\n                     /* shouldn't happen */\n-                    LOG(LOG_LEVEL_ERROR, \"error in xrdp_font_create, datasize wrong \"\n-                        \"width %d, height %d, datasize %d, index %d\",\n-                        f->width, f->height, datasize, index);\n+                    LOG(LOG_LEVEL_ERROR,\n+                        \"xrdp_font_create: \"\n+                        \"datasize for U+%x wrong \"\n+                        \"width %d, height %d, datasize %d\",\n+                        char_count, f->width, f->height, datasize);\n+                    break;\n+                }\n+\n+                if (!s_check_rem(s, datasize))\n+                {\n+                    LOG(LOG_LEVEL_ERROR,\n+                        \"xrdp_font_create: \"\n+                        \"Not enough data for character U+%X\", char_count);\n                     break;\n                 }\n \n@@ -261,25 +315,57 @@ xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n                      * that it can be added to the glyph cache if required */\n                     f->width = 1;\n                     f->height = 1;\n+\n+                    /* GOTCHA - we need to allocate more than one byte in\n+                     * memory for this glyph */\n                     f->data = (char *)g_malloc(FONT_DATASIZE(f), 1);\n                 }\n-                else if (s_check_rem(s, datasize))\n+                else\n                 {\n                     f->data = (char *)g_malloc(datasize, 0);\n-                    in_uint8a(s, f->data, datasize);\n                 }\n-                else\n+\n+                if (f->data == NULL)\n                 {\n-                    LOG(LOG_LEVEL_ERROR, \"error in xrdp_font_create\");\n+                    LOG(LOG_LEVEL_ERROR,\n+                        \"xrdp_font_create: \"\n+                        \"Allocation error for character U+%X\", char_count);\n+                    break;\n                 }\n-                index++;\n+                in_uint8a(s, f->data, datasize);\n+\n+                ++char_count;\n             }\n \n-            if (self->body_height == 0 && index > 32)\n+            self->char_count = char_count;\n+            if (char_count <= FIRST_CHAR)\n+            {\n+                /* We read no characters from the font */\n+                xrdp_font_delete(self);\n+                self = NULL;\n+            }\n+            else\n             {\n-                /* Older font made for xrdp v0.9.x. Synthesise this\n-                 * value from the first glyph */\n-                self->body_height = -self->font_items[32].baseline + 1;\n+                if (self->body_height == 0)\n+                {\n+                    /* Older font made for xrdp v0.9.x. Synthesise this\n+                     * value from the first glyph */\n+                    self->body_height = -self->chars[FIRST_CHAR].baseline + 1;\n+                }\n+\n+                // Find a default glyph\n+                if (char_count > UNICODE_WHITE_SQUARE)\n+                {\n+                    self->default_char = &self->chars[UNICODE_WHITE_SQUARE];\n+                }\n+                else if (char_count > '?')\n+                {\n+                    self->default_char = &self->chars['?'];\n+                }\n+                else\n+                {\n+                    self->default_char = &self->chars[FIRST_CHAR];\n+                }\n             }\n         }\n     }\n@@ -302,16 +388,16 @@ xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)\n void\n xrdp_font_delete(struct xrdp_font *self)\n {\n-    int i;\n+    unsigned int i;\n \n     if (self == 0)\n     {\n         return;\n     }\n \n-    for (i = 0; i < NUM_FONTS; i++)\n+    for (i = FIRST_CHAR; i < self->char_count; i++)\n     {\n-        g_free(self->font_items[i].data);\n+        g_free(self->chars[i].data);\n     }\n \n     g_free(self);"
        },
        {
          "filename": "xrdp/xrdp_painter.c",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -454,7 +454,7 @@ xrdp_painter_text_width(struct xrdp_painter *self, const char *text)\n \n     for (index = 0; index < len; index++)\n     {\n-        font_item = self->font->font_items + wstr[index];\n+        font_item = XRDP_FONT_GET_CHAR(self->font, wstr[index]);\n         rv = rv + font_item->incby;\n     }\n \n@@ -837,7 +837,7 @@ xrdp_painter_draw_text(struct xrdp_painter *self,\n             total_height = 0;\n             for (index = 0; index < len; index++)\n             {\n-                font_item = font->font_items + wstr[index];\n+                font_item = XRDP_FONT_GET_CHAR(font, wstr[index]);\n                 k = font_item->incby;\n                 total_width += k;\n                 /* Use the nominal height of the font to work out the\n@@ -875,7 +875,7 @@ xrdp_painter_draw_text(struct xrdp_painter *self,\n                                      draw_rect.bottom - draw_rect.top);\n                     for (index = 0; index < len; index++)\n                     {\n-                        font_item = font->font_items + wstr[index];\n+                        font_item = XRDP_FONT_GET_CHAR(font, wstr[index]);\n                         g_memset(&pat, 0, sizeof(pat));\n                         pat.format = PT_FORMAT_c1;\n                         pat.width = font_item->width;\n@@ -917,7 +917,7 @@ xrdp_painter_draw_text(struct xrdp_painter *self,\n \n     for (index = 0; index < len; index++)\n     {\n-        font_item = font->font_items + wstr[index];\n+        font_item = XRDP_FONT_GET_CHAR(font, wstr[index]);\n         i = xrdp_cache_add_char(self->wm->cache, font_item);\n         f = HIWORD(i);\n         c = LOWORD(i);"
        },
        {
          "filename": "xrdp/xrdp_types.h",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -648,7 +648,7 @@ struct xrdp_bitmap\n     int crc16;\n };\n \n-#define NUM_FONTS 0x4e00\n+#define MAX_FONT_CHARS 0x4e00\n #define DEFAULT_FONT_NAME \"sans-10.fv1\"\n #define DEFAULT_FONT_PIXEL_SIZE 16\n #define DEFAULT_FV1_SELECT \"130:sans-18.fv1,0:\" DEFAULT_FONT_NAME\n@@ -669,7 +669,11 @@ struct xrdp_bitmap\n struct xrdp_font\n {\n     struct xrdp_wm *wm;\n-    struct xrdp_font_char font_items[NUM_FONTS];\n+    // Font characters, accessed by Unicode codepoint. The first 32\n+    // entries are unused.\n+    struct xrdp_font_char chars[MAX_FONT_CHARS];\n+    unsigned int char_count; // # elements in above array\n+    struct xrdp_font_char *default_char; // Pointer into above array\n     char name[32];\n     int size;\n     /** Body height in pixels */"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a0f1b65aee5343bc6d8a9520cefd96948a1b9102",
            "date": "2025-01-13T11:48:30Z",
            "author_login": "matt335672"
          },
          {
            "sha": "b04743066d1edc18eeb6d9984bc4a302e5a3eb85",
            "date": "2025-01-13T10:11:51Z",
            "author_login": "matt335672"
          },
          {
            "sha": "d98c883dfb57b3b05516b7adbd4ee237259fa7ee",
            "date": "2025-01-09T11:34:41Z",
            "author_login": "matt335672"
          },
          {
            "sha": "99b6aaff6ce12687da0d998a27f67d9b384eac53",
            "date": "2025-01-09T10:37:40Z",
            "author_login": "matt335672"
          },
          {
            "sha": "35179f0fc54dfae36fcb0eab92a16b67fe6402c0",
            "date": "2025-01-09T10:17:00Z",
            "author_login": "matt335672"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-125",
    "description": " xrdp is an open source remote desktop protocol server. Access to the font glyphs in xrdp_painter.c is not bounds-checked . Since some of this data is controllable by the user, this can result in an out-of-bounds read within the xrdp executable. The vulnerability allows an out-of-bounds read within a potentially privileged process. On non-Debian platforms, xrdp tends to run as root. Potentially an out-of-bounds write can follow the out-of-bounds read. There is no denial-of-service impact, providing xrdp is running in forking mode. This issue has been addressed in release 0.9.23.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-09-27T18:15:11.903",
    "last_modified": "2024-11-21T08:23:17.400",
    "fix_date": "2023-09-27T08:37:24Z"
  },
  "references": [
    {
      "url": "https://github.com/neutrinolabs/xrdp/commit/73acbe1f7957c65122b00de4d6f57a8d0d257c40",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-2hjx-rm4f-r9hw",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5FPGA4M7IYCP7OILDF2ZJEVSXUOFEFQ6/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PFGL22QQF65OIZRMCKUZCVJQCKGUBRYE/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Release Notes"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RTXODUR4ILM7ZPA6ZGY6VSK4BBSBMKGY/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List",
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/neutrinolabs/xrdp/commit/73acbe1f7957c65122b00de4d6f57a8d0d257c40",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-2hjx-rm4f-r9hw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5FPGA4M7IYCP7OILDF2ZJEVSXUOFEFQ6/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PFGL22QQF65OIZRMCKUZCVJQCKGUBRYE/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Release Notes"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RTXODUR4ILM7ZPA6ZGY6VSK4BBSBMKGY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List",
        "Release Notes"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.497977",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "xrdp",
    "owner": "neutrinolabs",
    "created_at": "2011-04-25T14:31:17Z",
    "updated_at": "2025-01-13T11:48:35Z",
    "pushed_at": "2025-01-13T11:48:30Z",
    "size": 16515,
    "stars": 5870,
    "forks": 1738,
    "open_issues": 268,
    "watchers": 5870,
    "has_security_policy": false,
    "default_branch": "devel",
    "protected_branches": [
      "devel"
    ],
    "languages": {
      "C": 4054760,
      "M4": 62000,
      "Shell": 47300,
      "C++": 41259,
      "Makefile": 29077,
      "ActionScript": 1532,
      "QMake": 821
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:37:05.964520"
  }
}