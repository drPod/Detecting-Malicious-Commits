{
  "cve_id": "CVE-2023-44386",
  "github_data": {
    "repository": "vapor/vapor",
    "fix_commit": "090464a654b03148b139a81f8f5ac63b0856f6f3",
    "related_commits": [
      "090464a654b03148b139a81f8f5ac63b0856f6f3",
      "090464a654b03148b139a81f8f5ac63b0856f6f3"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "090464a654b03148b139a81f8f5ac63b0856f6f3",
      "commit_date": "2023-10-05T11:20:16Z",
      "author": {
        "login": "gwynne",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-3mwq-h3g6-ffhm",
        "length": 414,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 79,
        "additions": 6,
        "deletions": 73
      },
      "files": [
        {
          "filename": "Sources/Vapor/HTTP/Server/HTTPServer.swift",
          "status": "modified",
          "additions": 0,
          "deletions": 70,
          "patch": "@@ -452,73 +452,6 @@ private final class HTTPServerConnection: Sendable {\n     }\n }\n \n-/// A simple channel handler that catches errors emitted by parsing HTTP requests\n-/// and sends 400 Bad Request responses.\n-///\n-/// This channel handler provides the basic behaviour that the majority of simple HTTP\n-/// servers want. This handler does not suppress the parser errors: it allows them to\n-/// continue to pass through the pipeline so that other handlers (e.g. logging ones) can\n-/// deal with the error.\n-/// \n-/// adapted from: https://github.com/apple/swift-nio/blob/00341c92770e0a7bebdc5fda783f08765eb3ff56/Sources/NIOHTTP1/HTTPServerProtocolErrorHandler.swift\n-final class HTTP1ServerErrorHandler: ChannelDuplexHandler, RemovableChannelHandler {\n-    typealias InboundIn = Never\n-    typealias InboundOut = Never\n-    typealias OutboundIn = HTTPServerResponsePart\n-    typealias OutboundOut = HTTPServerResponsePart\n-    let logger: Logger\n-    private var hasUnterminatedResponse: Bool = false\n-    \n-    init(logger: Logger) {\n-        self.logger = logger\n-    }\n-    \n-    func errorCaught(context: ChannelHandlerContext, error: Error) {\n-        if let error = error as? HTTPParserError {\n-            self.makeHTTPParserErrorResponse(context: context, error: error)\n-        }\n-\n-        // Now pass the error on in case someone else wants to see it.\n-        // In the Vapor ChannelPipeline the connection will eventually \n-        // be closed by the NIOCloseOnErrorHandler\n-        context.fireErrorCaught(error)\n-    }\n-\n-    private func makeHTTPParserErrorResponse(context: ChannelHandlerContext, error: HTTPParserError) {\n-        // Any HTTPParserError is automatically fatal, and we don't actually need (or want) to\n-        // provide that error to the client: we just want to inform them something went wrong\n-        // and then close off the pipeline. However, we can only send an\n-        // HTTP error response if another response hasn't started yet.\n-        //\n-        // A side note here: we cannot block or do any delayed work. \n-        // The channel might be closed right after we return from this function.\n-        if !self.hasUnterminatedResponse {\n-            self.logger.debug(\"Bad Request - Invalid HTTP: \\(error)\")\n-            let headers = HTTPHeaders([(\"Connection\", \"close\"), (\"Content-Length\", \"0\")])\n-            let head = HTTPResponseHead(version: .http1_1, status: .badRequest, headers: headers)\n-            context.write(self.wrapOutboundOut(.head(head)), promise: nil)\n-            context.writeAndFlush(self.wrapOutboundOut(.end(nil)), promise: nil)\n-        }\n-    }\n-\n-    public func write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {\n-        let res = self.unwrapOutboundIn(data)\n-        switch res {\n-        case .head(let head) where head.isInformational:\n-            precondition(!self.hasUnterminatedResponse)\n-        case .head:\n-            precondition(!self.hasUnterminatedResponse)\n-            self.hasUnterminatedResponse = true\n-        case .body:\n-            precondition(self.hasUnterminatedResponse)\n-        case .end:\n-            precondition(self.hasUnterminatedResponse)\n-            self.hasUnterminatedResponse = false\n-        }\n-        context.write(data, promise: promise)\n-    }\n-}\n-\n extension HTTPResponseHead {\n     /// Determines if the head is purely informational. If a head is informational another head will follow this\n     /// head eventually.\n@@ -608,9 +541,6 @@ extension ChannelPipeline {\n             break\n         }\n \n-        let errorHandler = HTTP1ServerErrorHandler(logger: configuration.logger)\n-        handlers.append(errorHandler)\n-\n         // add NIO -> HTTP response encoder\n         let serverResEncoder = HTTPServerResponseEncoder(\n             serverHeader: configuration.serverName,"
        },
        {
          "filename": "Sources/Vapor/HTTP/Server/HTTPServerHandler.swift",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -71,7 +71,7 @@ final class HTTPServerHandler: ChannelInboundHandler, RemovableChannelHandler {\n             self.logger.trace(\"HTTP handler will no longer respect keep-alive\")\n             self.isShuttingDown = true\n         default:\n-            self.logger.trace(\"Unhandled user event: \\(event)\")\n+            context.fireUserInboundEventTriggered(event)\n         }\n     }\n }"
        },
        {
          "filename": "Sources/Vapor/HTTP/Server/HTTPServerRequestDecoder.swift",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -133,6 +133,10 @@ final class HTTPServerRequestDecoder: ChannelDuplexHandler, RemovableChannelHand\n         default:\n             break\n         }\n+\n+        if error is HTTPParserError {\n+            self.logger.debug(\"Invalid HTTP request, will close connection: \\(String(reflecting: error))\")\n+        }\n         context.fireErrorCaught(error)\n     }\n \n@@ -218,7 +222,7 @@ final class HTTPServerRequestDecoder: ChannelDuplexHandler, RemovableChannelHand\n                 context.fireUserInboundEventTriggered(event)\n             }\n         default:\n-            self.logger.trace(\"Unhandled user event: \\(event)\")\n+            context.fireUserInboundEventTriggered(event)\n         }\n     }\n }"
        },
        {
          "filename": "Tests/VaporTests/PipelineTests.swift",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -138,7 +138,6 @@ final class PipelineTests: XCTestCase {\n             }\n         }\n         XCTAssertEqual(channel.isActive, false)\n-        try XCTAssertContains(channel.readOutbound(as: ByteBuffer.self)?.string, \"HTTP/1.1 400 Bad Request\")\n         try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n     }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8589cb562feab069f2563bdcdeb8f9608a07a2c7",
            "date": "2025-01-22T15:39:59Z",
            "author_login": "NeedleInAJayStack"
          },
          {
            "sha": "eafbca78d0ced81a127c94f3703fc3fc76827963",
            "date": "2025-01-14T13:15:43Z",
            "author_login": "weissi"
          },
          {
            "sha": "4d7456c0d4b33ef82783a90ecfeae33a52a3972a",
            "date": "2024-12-30T18:52:00Z",
            "author_login": "WilliamFernsV3"
          },
          {
            "sha": "73dfe634f04945285054b261369cd93f5100b44c",
            "date": "2024-12-28T12:23:23Z",
            "author_login": "gwynne"
          },
          {
            "sha": "4c5d467a96fc4c64f6279327d8fd1e1600e85bc5",
            "date": "2024-12-26T15:37:40Z",
            "author_login": "MahdiBM"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-231",
    "description": "Vapor is an HTTP web framework for Swift. There is a denial of service vulnerability impacting all users of affected versions of Vapor. The HTTP1 error handler closed connections when HTTP parse errors occur instead of passing them on. The issue is fixed as of Vapor release 4.84.2.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-05T18:15:12.667",
    "last_modified": "2024-11-21T08:25:47.600",
    "fix_date": "2023-10-05T11:20:16Z"
  },
  "references": [
    {
      "url": "https://github.com/vapor/vapor/commit/090464a654b03148b139a81f8f5ac63b0856f6f3",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/releases/tag/4.84.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/security/advisories/GHSA-3mwq-h3g6-ffhm",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/commit/090464a654b03148b139a81f8f5ac63b0856f6f3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/releases/tag/4.84.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/vapor/vapor/security/advisories/GHSA-3mwq-h3g6-ffhm",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.577530",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "vapor",
    "owner": "vapor",
    "created_at": "2016-01-18T22:37:52Z",
    "updated_at": "2025-01-26T01:06:08Z",
    "pushed_at": "2025-01-22T15:40:06Z",
    "size": 17162,
    "stars": 24763,
    "forks": 1455,
    "open_issues": 98,
    "watchers": 24763,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3",
      "main"
    ],
    "languages": {
      "Swift": 1448974,
      "C": 38624,
      "HTML": 67
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:38:31.990010"
  }
}