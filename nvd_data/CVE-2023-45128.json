{
  "cve_id": "CVE-2023-45128",
  "github_data": {
    "repository": "gofiber/fiber",
    "fix_commit": "8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a",
    "related_commits": [
      "8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a",
      "8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a"
    ],
    "patch_url": "https://github.com/gofiber/fiber/commit/8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a.patch",
    "fix_commit_details": {
      "sha": "8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a",
      "commit_date": "2023-10-16T07:06:30Z",
      "author": {
        "login": "sixcolors",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-94w9-97p3-p368",
        "length": 1273,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 292,
        "additions": 266,
        "deletions": 26
      },
      "files": [
        {
          "filename": "docs/api/middleware/csrf.md",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -42,10 +42,20 @@ When using this method, pre-sessions are required and will be created if a sessi\n \n When using this middleware, it is recommended that you serve your pages over HTTPS, that the `CookieSecure` option is set to `true`, and that the `CookieSameSite` option is set to `Lax` or `Strict`. This will ensure that the cookie is only sent over HTTPS and that it is not sent on requests from external sites.\n \n+:::note\n+Cookie prefixes __Host- and __Secure- can be used to further secure the cookie. However, these prefixes are not supported by all browsers and there are some other limitations. See [MDN#Set-Cookie#cookie_prefixes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes) for more information.\n+\n+To use these prefixes, set the `CookieName` option to `__Host-csrf_` or `__Secure-csrf_`.\n+:::\n+\n ### Referer Checking\n \n For HTTPS requests, this middleware performs strict referer checking. This means that even if a subdomain can set or modify cookies on your domain, it can\u2019t force a user to post to your application since that request won\u2019t come from your own exact domain.\n \n+:::warning\n+Referer checking is required for https requests protected by CSRF. All modern browsers will automatically include the Referer header in requests, including those made with the JS Fetch API. However, if you are using this middleware with a custom client you must ensure that the client sends a valid Referer header.\n+:::\n+\n ### Token Lifecycle\n \n Tokens are valid until they expire, or until they are deleted. By default, tokens are valid for 1 hour and each subsequent request will extend the expiration by 1 hour. This means that if a user makes a request every hour, the token will never expire. If a user makes a request after the token has expired, then a new token will be generated and the `csrf_` cookie will be set again. This means that the token will only expire if the user does not make a request for the duration of the expiration time."
        },
        {
          "filename": "middleware/csrf/csrf.go",
          "status": "modified",
          "additions": 18,
          "deletions": 10,
          "patch": "@@ -2,6 +2,7 @@ package csrf\n \n import (\n \t\"errors\"\n+\t\"net/url\"\n \t\"reflect\"\n \t\"time\"\n \n@@ -63,10 +64,10 @@ func New(config ...Config) fiber.Handler {\n \t\t\tcookieToken := c.Cookies(cfg.CookieName)\n \n \t\t\tif cookieToken != \"\" {\n-\t\t\t\trawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)\n+\t\t\t\traw := getRawFromStorage(c, cookieToken, cfg, sessionManager, storageManager)\n \n-\t\t\t\tif rawToken != nil {\n-\t\t\t\t\ttoken = string(rawToken)\n+\t\t\t\tif raw != nil {\n+\t\t\t\t\ttoken = cookieToken // Token is valid, safe to set it\n \t\t\t\t}\n \t\t\t}\n \t\tdefault:\n@@ -92,13 +93,13 @@ func New(config ...Config) fiber.Handler {\n \t\t\t// If not using CsrfFromCookie extractor, check that the token matches the cookie\n \t\t\t// This is to prevent CSRF attacks by using a Double Submit Cookie method\n \t\t\t// Useful when we do not have access to the users Session\n-\t\t\tif !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {\n+\t\t\tif !isCsrfFromCookie(cfg.Extractor) && !compareStrings(extractedToken, c.Cookies(cfg.CookieName)) {\n \t\t\t\treturn cfg.ErrorHandler(c, ErrTokenInvalid)\n \t\t\t}\n \n-\t\t\trawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n+\t\t\traw := getRawFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n \n-\t\t\tif rawToken == nil {\n+\t\t\tif raw == nil {\n \t\t\t\t// If token is not in storage, expire the cookie\n \t\t\t\texpireCSRFCookie(c, cfg)\n \t\t\t\t// and return an error\n@@ -108,7 +109,7 @@ func New(config ...Config) fiber.Handler {\n \t\t\t\t// If token is single use, delete it from storage\n \t\t\t\tdeleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)\n \t\t\t} else {\n-\t\t\t\ttoken = string(rawToken)\n+\t\t\t\ttoken = extractedToken // Token is valid, safe to set it\n \t\t\t}\n \t\t}\n \n@@ -137,9 +138,9 @@ func New(config ...Config) fiber.Handler {\n \t}\n }\n \n-// getTokenFromStorage returns the raw token from the storage\n+// getRawFromStorage returns the raw value from the storage for the given token\n // returns nil if the token does not exist, is expired or is invalid\n-func getTokenFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) []byte {\n+func getRawFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) []byte {\n \tif cfg.Session != nil {\n \t\treturn sessionManager.getRaw(c, token, dummyValue)\n \t}\n@@ -223,8 +224,15 @@ func refererMatchesHost(c *fiber.Ctx) error {\n \tif referer == \"\" {\n \t\treturn ErrNoReferer\n \t}\n-\tif referer != c.Protocol()+\"://\"+c.Hostname() {\n+\n+\trefererURL, err := url.Parse(referer)\n+\tif err != nil {\n \t\treturn ErrBadReferer\n \t}\n+\n+\tif refererURL.Scheme+\"://\"+refererURL.Host != c.Protocol()+\"://\"+c.Hostname() {\n+\t\treturn ErrBadReferer\n+\t}\n+\n \treturn nil\n }"
        },
        {
          "filename": "middleware/csrf/csrf_test.go",
          "status": "modified",
          "additions": 224,
          "deletions": 6,
          "patch": "@@ -4,6 +4,7 @@ import (\n \t\"net/http/httptest\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"github.com/gofiber/fiber/v2\"\n \t\"github.com/gofiber/fiber/v2/middleware/session\"\n@@ -153,6 +154,170 @@ func Test_CSRF_WithSession(t *testing.T) {\n \t}\n }\n \n+// go test -run Test_CSRF_ExpiredToken\n+func Test_CSRF_ExpiredToken(t *testing.T) {\n+\tt.Parallel()\n+\tapp := fiber.New()\n+\n+\tapp.Use(New(Config{\n+\t\tExpiration: 1 * time.Second,\n+\t}))\n+\n+\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n+\t\treturn c.SendStatus(fiber.StatusOK)\n+\t})\n+\n+\th := app.Handler()\n+\tctx := &fasthttp.RequestCtx{}\n+\n+\t// Generate CSRF token\n+\tctx.Request.Header.SetMethod(fiber.MethodGet)\n+\th(ctx)\n+\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n+\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n+\n+\t// Use the CSRF token\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n+\n+\t// Wait for the token to expire\n+\ttime.Sleep(1 * time.Second)\n+\n+\t// Expired CSRF token\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n+}\n+\n+// go test -run Test_CSRF_ExpiredToken_WithSession\n+func Test_CSRF_ExpiredToken_WithSession(t *testing.T) {\n+\tt.Parallel()\n+\n+\t// session store\n+\tstore := session.New(session.Config{\n+\t\tKeyLookup: \"cookie:_session\",\n+\t})\n+\n+\t// fiber instance\n+\tapp := fiber.New()\n+\n+\t// fiber context\n+\tctx := &fasthttp.RequestCtx{}\n+\tdefer app.ReleaseCtx(app.AcquireCtx(ctx))\n+\n+\t// get session\n+\tsess, err := store.Get(app.AcquireCtx(ctx))\n+\tutils.AssertEqual(t, nil, err)\n+\tutils.AssertEqual(t, true, sess.Fresh())\n+\n+\t// get session id\n+\tnewSessionIDString := sess.ID()\n+\tapp.AcquireCtx(ctx).Request().Header.SetCookie(\"_session\", newSessionIDString)\n+\n+\t// middleware config\n+\tconfig := Config{\n+\t\tSession:    store,\n+\t\tExpiration: 1 * time.Second,\n+\t}\n+\n+\t// middleware\n+\tapp.Use(New(config))\n+\n+\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n+\t\treturn c.SendStatus(fiber.StatusOK)\n+\t})\n+\n+\th := app.Handler()\n+\n+\t// Generate CSRF token\n+\tctx.Request.Header.SetMethod(fiber.MethodGet)\n+\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n+\th(ctx)\n+\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n+\tfor _, header := range strings.Split(token, \";\") {\n+\t\tif strings.Split(strings.TrimSpace(header), \"=\")[0] == ConfigDefault.CookieName {\n+\t\t\ttoken = strings.Split(header, \"=\")[1]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// Use the CSRF token\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n+\n+\t// Wait for the token to expire\n+\ttime.Sleep(1 * time.Second)\n+\n+\t// Expired CSRF token\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(\"_session\", newSessionIDString)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n+}\n+\n+// go test -run Test_CSRF_MultiUseToken\n+func Test_CSRF_MultiUseToken(t *testing.T) {\n+\tt.Parallel()\n+\tapp := fiber.New()\n+\n+\tapp.Use(New(Config{\n+\t\tKeyLookup: \"header:X-CSRF-Token\",\n+\t}))\n+\n+\tapp.Post(\"/\", func(c *fiber.Ctx) error {\n+\t\treturn c.SendStatus(fiber.StatusOK)\n+\t})\n+\n+\th := app.Handler()\n+\tctx := &fasthttp.RequestCtx{}\n+\n+\t// Invalid CSRF token\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(\"X-CSRF-Token\", \"johndoe\")\n+\th(ctx)\n+\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n+\n+\t// Generate CSRF token\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodGet)\n+\th(ctx)\n+\ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n+\ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n+\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(\"X-CSRF-Token\", token)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tnewToken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n+\tnewToken = strings.Split(strings.Split(newToken, \";\")[0], \"=\")[1]\n+\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n+\n+\t// Check if the token is not a dummy value\n+\tutils.AssertEqual(t, token, newToken)\n+}\n+\n // go test -run Test_CSRF_SingleUseToken\n func Test_CSRF_SingleUseToken(t *testing.T) {\n \tt.Parallel()\n@@ -260,6 +425,8 @@ func Test_CSRF_From_Form(t *testing.T) {\n \ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n \ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n \n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n \tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMEApplicationForm)\n \tctx.Request.SetBodyString(\"_csrf=\" + token)\n@@ -393,7 +560,7 @@ func Test_CSRF_From_Custom(t *testing.T) {\n \t\tselectors := strings.Split(body, \"=\")\n \n \t\tif len(selectors) != 2 || selectors[1] == \"\" {\n-\t\t\treturn \"\", errMissingParam\n+\t\t\treturn \"\", ErrMissingParam\n \t\t}\n \t\treturn selectors[1], nil\n \t}\n@@ -421,6 +588,8 @@ func Test_CSRF_From_Custom(t *testing.T) {\n \ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n \ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n \n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n \tctx.Request.Header.Set(fiber.HeaderContentType, fiber.MIMETextPlain)\n \tctx.Request.SetBodyString(\"_csrf=\" + token)\n@@ -447,17 +616,67 @@ func Test_CSRF_Referer(t *testing.T) {\n \ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n \ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n \n-\t// Test Correct Referer\n+\t// Test Correct Referer with port\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.URI().SetScheme(\"https\")\n+\tctx.Request.URI().SetHost(\"example.com:8443\")\n+\tctx.Request.Header.SetProtocol(\"https\")\n+\tctx.Request.Header.SetHost(\"example.com:8443\")\n+\tctx.Request.Header.Set(fiber.HeaderReferer, ctx.Request.URI().String())\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n+\n+\t// Test Correct Referer with ReverseProxy\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.URI().SetScheme(\"https\")\n+\tctx.Request.URI().SetHost(\"10.0.1.42.com:8443\")\n+\tctx.Request.Header.SetProtocol(\"https\")\n+\tctx.Request.Header.SetHost(\"10.0.1.42:8443\")\n \tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n \tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n+\tctx.Request.Header.Set(fiber.HeaderXForwardedFor, `192.0.2.43, \"[2001:db8:cafe::17]\"`)\n+\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com\")\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n+\tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n+\n+\t// Test Correct Referer with ReverseProxy Missing X-Forwarded-* Headers\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.URI().SetScheme(\"https\")\n+\tctx.Request.URI().SetHost(\"10.0.1.42:8443\")\n+\tctx.Request.Header.SetProtocol(\"https\")\n+\tctx.Request.Header.SetHost(\"10.0.1.42:8443\")\n+\tctx.Request.Header.Set(fiber.HeaderXUrlScheme, \"https\") // We need to set this header to make sure c.Protocol() returns https\n \tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com\")\n \tctx.Request.Header.Set(HeaderName, token)\n \tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n \th(ctx)\n+\tutils.AssertEqual(t, 403, ctx.Response.StatusCode())\n+\n+\t// Test Correct Referer with path\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n+\tctx.Request.Header.SetMethod(fiber.MethodPost)\n+\tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n+\tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n+\tctx.Request.Header.Set(fiber.HeaderReferer, \"https://example.com/action/items?gogogo=true\")\n+\tctx.Request.Header.Set(HeaderName, token)\n+\tctx.Request.Header.SetCookie(ConfigDefault.CookieName, token)\n+\th(ctx)\n \tutils.AssertEqual(t, 200, ctx.Response.StatusCode())\n \n \t// Test Wrong Referer\n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n \tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n \tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")\n@@ -490,7 +709,6 @@ func Test_CSRF_DeleteToken(t *testing.T) {\n \ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n \n \t// Delete the CSRF token\n-\tctx.Request.Header.SetMethod(fiber.MethodGet)\n \tctx.Request.Reset()\n \tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n@@ -503,7 +721,6 @@ func Test_CSRF_DeleteToken(t *testing.T) {\n \t}\n \th(ctx)\n \n-\tctx.Request.Header.SetMethod(fiber.MethodGet)\n \tctx.Request.Reset()\n \tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n@@ -559,7 +776,6 @@ func Test_CSRF_DeleteToken_WithSession(t *testing.T) {\n \ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n \n \t// Delete the CSRF token\n-\tctx.Request.Header.SetMethod(fiber.MethodGet)\n \tctx.Request.Reset()\n \tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n@@ -619,7 +835,7 @@ func Test_CSRF_ErrorHandler_EmptyToken(t *testing.T) {\n \tapp := fiber.New()\n \n \terrHandler := func(ctx *fiber.Ctx, err error) error {\n-\t\tutils.AssertEqual(t, errMissingHeader, err)\n+\t\tutils.AssertEqual(t, ErrMissingHeader, err)\n \t\treturn ctx.Status(419).Send([]byte(\"empty CSRF token\"))\n \t}\n \n@@ -671,6 +887,8 @@ func Test_CSRF_ErrorHandler_MissingReferer(t *testing.T) {\n \ttoken := string(ctx.Response.Header.Peek(fiber.HeaderSetCookie))\n \ttoken = strings.Split(strings.Split(token, \";\")[0], \"=\")[1]\n \n+\tctx.Request.Reset()\n+\tctx.Response.Reset()\n \tctx.Request.Header.SetMethod(fiber.MethodPost)\n \tctx.Request.Header.Set(fiber.HeaderXForwardedProto, \"https\")\n \tctx.Request.Header.Set(fiber.HeaderXForwardedHost, \"example.com\")"
        },
        {
          "filename": "middleware/csrf/extractors.go",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -7,19 +7,19 @@ import (\n )\n \n var (\n-\terrMissingHeader = errors.New(\"missing csrf token in header\")\n-\terrMissingQuery  = errors.New(\"missing csrf token in query\")\n-\terrMissingParam  = errors.New(\"missing csrf token in param\")\n-\terrMissingForm   = errors.New(\"missing csrf token in form\")\n-\terrMissingCookie = errors.New(\"missing csrf token in cookie\")\n+\tErrMissingHeader = errors.New(\"missing csrf token in header\")\n+\tErrMissingQuery  = errors.New(\"missing csrf token in query\")\n+\tErrMissingParam  = errors.New(\"missing csrf token in param\")\n+\tErrMissingForm   = errors.New(\"missing csrf token in form\")\n+\tErrMissingCookie = errors.New(\"missing csrf token in cookie\")\n )\n \n // csrfFromParam returns a function that extracts token from the url param string.\n func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {\n \treturn func(c *fiber.Ctx) (string, error) {\n \t\ttoken := c.Params(param)\n \t\tif token == \"\" {\n-\t\t\treturn \"\", errMissingParam\n+\t\t\treturn \"\", ErrMissingParam\n \t\t}\n \t\treturn token, nil\n \t}\n@@ -30,7 +30,7 @@ func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {\n \treturn func(c *fiber.Ctx) (string, error) {\n \t\ttoken := c.FormValue(param)\n \t\tif token == \"\" {\n-\t\t\treturn \"\", errMissingForm\n+\t\t\treturn \"\", ErrMissingForm\n \t\t}\n \t\treturn token, nil\n \t}\n@@ -41,7 +41,7 @@ func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {\n \treturn func(c *fiber.Ctx) (string, error) {\n \t\ttoken := c.Cookies(param)\n \t\tif token == \"\" {\n-\t\t\treturn \"\", errMissingCookie\n+\t\t\treturn \"\", ErrMissingCookie\n \t\t}\n \t\treturn token, nil\n \t}\n@@ -52,7 +52,7 @@ func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {\n \treturn func(c *fiber.Ctx) (string, error) {\n \t\ttoken := c.Get(param)\n \t\tif token == \"\" {\n-\t\t\treturn \"\", errMissingHeader\n+\t\t\treturn \"\", ErrMissingHeader\n \t\t}\n \t\treturn token, nil\n \t}\n@@ -63,7 +63,7 @@ func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {\n \treturn func(c *fiber.Ctx) (string, error) {\n \t\ttoken := c.Query(param)\n \t\tif token == \"\" {\n-\t\t\treturn \"\", errMissingQuery\n+\t\t\treturn \"\", ErrMissingQuery\n \t\t}\n \t\treturn token, nil\n \t}"
        },
        {
          "filename": "middleware/csrf/helpers.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -7,3 +7,7 @@ import (\n func compareTokens(a, b []byte) bool {\n \treturn subtle.ConstantTimeCompare(a, b) == 1\n }\n+\n+func compareStrings(a, b string) bool {\n+\treturn subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "44b971ace579437b8792025ec14e972630386b90",
            "date": "2025-01-14T02:37:29Z",
            "author_login": "gaby"
          },
          {
            "sha": "4e5fea1d7a830a52cbe736d2da88660a2e959549",
            "date": "2025-01-13T13:18:03Z",
            "author_login": "grivera64"
          },
          {
            "sha": "6c7473b842148a0a59bc2c0d511f330373fa3fde",
            "date": "2025-01-10T12:46:21Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "bc37f209bfef66d8ff84dc7d13dc066107eb3d9c",
            "date": "2025-01-08T07:19:20Z",
            "author_login": "ReneWerner87"
          },
          {
            "sha": "86d72bbba8b5998bb4583f3bff110ede1391d795",
            "date": "2025-01-07T18:20:53Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 10.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:L",
    "cwe_id": "CWE-20",
    "description": "Fiber is an express inspired web framework written in Go. A Cross-Site Request Forgery (CSRF) vulnerability has been identified in the application, which allows an attacker to inject arbitrary values and forge malicious requests on behalf of a user. This vulnerability can allow an attacker to inject arbitrary values without any authentication, or perform various malicious actions on behalf of an authenticated user, potentially compromising the security and integrity of the application. The vulnerability is caused by improper validation and enforcement of CSRF tokens within the application. This issue has been addressed in version 2.50.0 and users are advised to upgrade. Users should take additional security measures like captchas or Two-Factor Authentication (2FA) and set Session cookies with SameSite=Lax or SameSite=Secure, and the Secure and HttpOnly attributes as defense in depth measures. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-16T21:15:11.137",
    "last_modified": "2024-11-21T08:26:23.870",
    "fix_date": "2023-10-16T07:06:30Z"
  },
  "references": [
    {
      "url": "https://github.com/gofiber/fiber/commit/8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/gofiber/fiber/security/advisories/GHSA-94w9-97p3-p368",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/gofiber/fiber/commit/8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/gofiber/fiber/security/advisories/GHSA-94w9-97p3-p368",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.607476",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fiber",
    "owner": "gofiber",
    "created_at": "2020-01-16T03:59:20Z",
    "updated_at": "2025-01-14T12:32:36Z",
    "pushed_at": "2025-01-14T02:37:36Z",
    "size": 229934,
    "stars": 34637,
    "forks": 1696,
    "open_issues": 100,
    "watchers": 34637,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v2"
    ],
    "languages": {
      "Go": 1562365,
      "Makefile": 1868
    },
    "commit_activity": {
      "total_commits_last_year": 253,
      "avg_commits_per_week": 4.865384615384615,
      "days_active_last_year": 141
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:42:58.049694"
  }
}