{
  "cve_id": "CVE-2023-46131",
  "github_data": {
    "repository": "grails/grails-core",
    "fix_commit": "74326bdd2cf7dcb594092165e9464520f8366c60",
    "related_commits": [
      "74326bdd2cf7dcb594092165e9464520f8366c60",
      "c401faaa6c24c021c758b95f72304a0e855a8db3",
      "74326bdd2cf7dcb594092165e9464520f8366c60",
      "c401faaa6c24c021c758b95f72304a0e855a8db3"
    ],
    "patch_url": "https://github.com/grails/grails-core/commit/74326bdd2cf7dcb594092165e9464520f8366c60.patch",
    "fix_commit_details": {
      "sha": "74326bdd2cf7dcb594092165e9464520f8366c60",
      "commit_date": "2023-12-06T13:22:43Z",
      "author": {
        "login": "puneetbehl",
        "type": "User",
        "stats": {
          "total_commits": 1406,
          "average_weekly_commits": 1.4722513089005236,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 163
        }
      },
      "commit_message": {
        "title": "Update SimpleDataBinder to prevent binding to specific types (#13269)",
        "length": 313,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 91,
        "additions": 43,
        "deletions": 48
      },
      "files": [
        {
          "filename": "grails-databinding/src/main/groovy/grails/databinding/BindInitializer.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -36,7 +36,7 @@ class Contact{\n } \n class User {\n     &#064;BindInitializer({\n-        obj -> new Contact(account:obj.account)\n+        obj -&gt; new Contact(account:obj.account)\n     })\n     Contact contact\n     Account account"
        },
        {
          "filename": "grails-databinding/src/main/groovy/grails/databinding/BindUsing.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -28,15 +28,15 @@\n  * When the annotation is applied to a field, the value assigned to the\n  * annotation should be a Closure which accepts 2 parameters.  The first\n  * parameter is the object that data binding is being applied to.  The second\n- * parameter is a {@link org.grails.databinding.DataBindingSource} containing the values being bound to the object.\n+ * parameter is a {@link grails.databinding.DataBindingSource} containing the values being bound to the object.\n  * The value returned by the Closure will be bound to the field.  The\n  * following code demonstrates using this technique to bind an upper\n  * case version of the value in the DataBindingSource to the field.\n  *\n <pre>\n class SomeClass {\n     &#064;BindUsing({\n-        obj, source -> source['name']?.toUpperCase()\n+        obj, source -&gt; source['name']?.toUpperCase()\n     })\n     String name\n }"
        },
        {
          "filename": "grails-databinding/src/main/groovy/grails/databinding/SimpleDataBinder.groovy",
          "status": "modified",
          "additions": 17,
          "deletions": 20,
          "patch": "@@ -22,6 +22,7 @@ import grails.databinding.initializers.ValueInitializer\n import groovy.transform.CompileStatic\n import groovy.transform.TypeCheckingMode\n import groovy.util.slurpersupport.GPathResult\n+import org.codehaus.groovy.reflection.CachedMethod\n import org.grails.databinding.ClosureValueConverter\n import org.grails.databinding.ClosureValueInitializer\n import org.grails.databinding.IndexedPropertyReferenceDescriptor\n@@ -81,7 +82,7 @@ class SimpleDataBinder implements DataBinder {\n         Float,\n         Double,\n         Character\n-    ]\n+    ] as List<Class>\n \n     static final INDEXED_PROPERTY_REGEX = /(.*)\\[\\s*([^\\s]*)\\s*\\]\\s*$/\n \n@@ -260,14 +261,14 @@ class SimpleDataBinder implements DataBinder {\n     }\n \n     protected boolean isOkToBind(String propName, List whiteList, List blackList) {\n-        'class' != propName && 'classLoader' != propName && 'protectionDomain' != propName && 'metaClass' != propName && !blackList?.contains(propName) && (!whiteList || whiteList.contains(propName) || whiteList.find { it -> it?.toString()?.startsWith(propName + '.')})\n+        'class' != propName && 'classLoader' != propName && 'protectionDomain' != propName && 'metaClass' != propName && 'metaPropertyValues' != propName && 'properties' != propName && !blackList?.contains(propName) && (!whiteList || whiteList.contains(propName) || whiteList.find { it -> it?.toString()?.startsWith(propName + '.')})\n     }\n \n     protected boolean isOkToBind(MetaProperty property, List whitelist, List blacklist) {\n         isOkToBind(property.name, whitelist, blacklist) &&\n                 (property.type != null) &&\n                 !Modifier.isStatic(property.modifiers) &&\n-                !(ClassLoader.class.isAssignableFrom(property.type) || ProtectionDomain.class.isAssignableFrom(property.type))\n+                !(ClassLoader.class.isAssignableFrom(property.type) || ProtectionDomain.class.isAssignableFrom(property.type) || MetaProperty.class.isAssignableFrom(property.type) || CachedMethod.class.isAssignableFrom(property.type))\n     }\n \n     protected IndexedPropertyReferenceDescriptor getIndexedPropertyReferenceDescriptor(propName) {\n@@ -498,7 +499,7 @@ class SimpleDataBinder implements DataBinder {\n      * @see BindingFormat\n      */\n     protected ValueConverter getFormattedConverter(Field field, String formattingValue) {\n-        def converter\n+        ValueConverter converter\n         def formattedConverter = formattedValueConversionHelpers[field.type]\n         if (formattedConverter) {\n             converter = { SimpleMapDataBindingSource source ->\n@@ -517,7 +518,7 @@ class SimpleDataBinder implements DataBinder {\n         Field field = null\n         try {\n             field = clazz.getDeclaredField(fieldName)\n-        } catch (NoSuchFieldException nsfe) {\n+        } catch (NoSuchFieldException ignored) {\n             def superClass = clazz.getSuperclass()\n             if(superClass != Object) {\n                 field = getField(superClass, fieldName)\n@@ -527,7 +528,7 @@ class SimpleDataBinder implements DataBinder {\n     }\n \n     protected ValueConverter getValueConverterForField(obj, String propName) {\n-        def converter\n+        ValueConverter converter\n         try {\n             def field = getField(obj.getClass(), propName)\n             if (field) {\n@@ -545,9 +546,9 @@ class SimpleDataBinder implements DataBinder {\n                     }\n                 }\n             }\n-        } catch (Exception e) {\n+            return converter\n+        } catch (Exception ignored) {\n         }\n-        converter\n     }\n     \n     /**\n@@ -556,11 +557,9 @@ class SimpleDataBinder implements DataBinder {\n      */\n     protected Class getValueOfBindUsing(Annotation annotation) {\n         assert annotation instanceof BindUsing\n-        def value\n-        if(annotation instanceof BindUsing) {\n-            value = ((BindUsing)annotation).value()\n+        if (annotation instanceof BindUsing) {\n+            return ((BindUsing) annotation).value()\n         }\n-        value\n     }\n     \n     /**\n@@ -569,21 +568,19 @@ class SimpleDataBinder implements DataBinder {\n      */\n     protected String getFormatString(Annotation annotation) {\n         assert annotation instanceof BindingFormat\n-        String formatString\n-        if(annotation instanceof BindingFormat) {\n-            formatString = ((BindingFormat)annotation).value()\n+        if (annotation instanceof BindingFormat) {\n+            return ((BindingFormat) annotation).value()\n         }\n-        formatString\n     }\n \n     protected ValueConverter getValueConverterForClass(obj, String propName) {\n-        def converter\n+        ValueConverter converter\n         def objClass = obj.getClass()\n         def annotation = objClass.getAnnotation(BindUsing)\n         if (annotation) {\n             def valueClass = getValueOfBindUsing(annotation)\n             if (BindingHelper.isAssignableFrom(valueClass)) {\n-                BindingHelper dataConverter = (BindingHelper)valueClass.newInstance()\n+                BindingHelper dataConverter = (BindingHelper) valueClass.getDeclaredConstructor().newInstance()\n                 converter = new ClosureValueConverter(converterClosure: { DataBindingSource it -> dataConverter.getPropertyValue(obj, propName, it) })\n             }\n         }\n@@ -762,7 +759,7 @@ class SimpleDataBinder implements DataBinder {\n     }\n \n     protected ValueInitializer getValueInitializerForField(obj, String propName) {\n-        def initializer\n+        ValueInitializer initializer\n         try {\n             def field = getField(obj.getClass(), propName)\n             if (field) {\n@@ -819,7 +816,7 @@ class SimpleDataBinder implements DataBinder {\n             bind obj, new SimpleMapDataBindingSource(value)\n             return obj\n         } else if (Enum.isAssignableFrom(typeToConvertTo) && value instanceof String) {\n-            return convertStringToEnum(typeToConvertTo, value)\n+            return convertStringToEnum((Class<? extends Enum>) typeToConvertTo, value)\n         }\n         typeToConvertTo.newInstance value\n     }"
        },
        {
          "filename": "grails-databinding/src/main/groovy/grails/databinding/StructuredBindingEditor.java",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -21,14 +21,14 @@\n  * into an object.  Typically a structured editor will pull\n  * several values out of the Map that are necessary to initialize\n  * the state of the object.\n-<pre>\n+<code>\n class Address {\n     String state\n     String city\n }\n class StructuredAddressBindingEditor implements StructuredBindingEditor {\n \n-    public Object getPropertyValue(Object obj, String propertyName, Map<String, Object> source) {\n+    public Object getPropertyValue(Object obj, String propertyName, Map&lt;String, Object&gt; source) {\n         def address = new Address()\n \n         address.state = source[propertyName + '_someState']\n@@ -58,7 +58,7 @@ binder.registerStructuredEditor Address, new StructuredAddressBindingEditor()\n assert resident.workAddress\n assert resident.workAddress.state == \"Scott's Work State\"\n assert resident.workAddress.city == null\n-</pre>\n+</code>\n  *\n  * @author Jeff Brown\n  * @since 3.0"
        },
        {
          "filename": "grails-databinding/src/main/groovy/grails/databinding/converters/FormattedValueConverter.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -41,8 +41,8 @@ Class getTargetType() {\n  * @author Jeff Brown\n  * @since 3.0\n  * @see grails.databinding.BindingFormat\n- * @see org.grails.databinding.SimpleDataBinder\n- * @see org.grails.databinding.SimpleDataBinder#registerFormattedValueConverter(FormattedValueConverter)\n+ * @see grails.databinding.SimpleDataBinder\n+ * @see grails.databinding.SimpleDataBinder#registerFormattedValueConverter(FormattedValueConverter)\n  */\n public interface FormattedValueConverter {\n     /**"
        },
        {
          "filename": "grails-encoder/src/main/groovy/org/grails/buffer/GrailsPrintWriter.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -93,7 +93,7 @@ protected Writer unwrapWriter(Writer writer) {\n     }\n \n     /**\n-     * Provides Groovy << left shift operator, but intercepts call to make sure\n+     * Provides Groovy &lt;&lt; left shift operator, but intercepts call to make sure\n      * nulls are converted to \"\" strings\n      *\n      * @param obj The value"
        },
        {
          "filename": "grails-encoder/src/main/groovy/org/grails/buffer/StreamCharBuffer.java",
          "status": "modified",
          "additions": 10,
          "deletions": 12,
          "patch": "@@ -81,12 +81,12 @@\n  *\n  * <p>\n  * StreamCharBuffer keeps the buffer in a linked list of \"chunks\". The main\n- * difference compared to JDK in-memory buffers (StringBuffer, StringBuilder &\n+ * difference compared to JDK in-memory buffers (StringBuffer, StringBuilder and\n  * StringWriter) is that the buffer can be held in several smaller buffers\n  * (\"chunks\" here). In JDK in-memory buffers, the buffer has to be expanded\n  * whenever it gets filled up. The old buffer's data is copied to the new one\n  * and the old one is discarded. In StreamCharBuffer, there are several ways to\n- * prevent unnecessary allocation & copy operations. The StreamCharBuffer\n+ * prevent unnecessary allocation and copy operations. The StreamCharBuffer\n  * contains a linked list of different type of chunks: char arrays,\n  * java.lang.String chunks and other StreamCharBuffers as sub chunks. A\n  * StringChunk is appended to the linked list whenever a java.lang.String of a\n@@ -101,13 +101,11 @@\n  *\n  * for example this line of code in a taglib would just append the buffer\n  * returned from the body closure evaluation to the buffer of the taglib:<br>\n- * <code>\n- * out << body()\n- * </code><br>\n+ * <code>out &lt;&lt; body()</code>\n+ * <br>\n  * other example:<br>\n- * <code>\n- * out << g.render(template: '/some/template', model:[somebean: somebean])\n- * </code><br>\n+ * <code>out &lt;&lt; g.render(template: '/some/template', model:[somebean: somebean])</code>\n+ * <br>\n  * There's no extra java.lang.String generation overhead.\n  *\n  * </p>\n@@ -128,8 +126,8 @@\n  *\n  * <p>\n  * There's also several other options for reading data:<br>\n- * {@link #readAsCharArray()} reads the buffer to a char[] array<br>\n- * {@link #readAsString()} reads the buffer and wraps the char[] data as a\n+ * readAsCharArray()reads the buffer to a char[] array<br>\n+ * readAsString() reads the buffer and wraps the char[] data as a\n  * String<br>\n  * {@link #writeTo(Writer)} writes the buffer to a java.io.Writer<br>\n  * {@link #toCharArray()} returns the buffer as a char[] array, caches the\n@@ -156,13 +154,13 @@\n  * <p>\n  * StreamCharBuffer keeps the buffer in a linked link of \"chunks\".<br>\n  * The main difference compared to JDK in-memory buffers (StringBuffer,\n- * StringBuilder & StringWriter) is that the buffer can be held in several\n+ * StringBuilder and StringWriter) is that the buffer can be held in several\n  * smaller buffers (\"chunks\" here).<br>\n  * In JDK in-memory buffers, the buffer has to be expanded whenever it gets\n  * filled up. The old buffer's data is copied to the new one and the old one is\n  * discarded.<br>\n  * In StreamCharBuffer, there are several ways to prevent unnecessary allocation\n- * & copy operations.\n+ * and copy operations.\n  * </p>\n  * <p>\n  * There can be several different type of chunks: char arrays ("
        },
        {
          "filename": "grails-web-common/src/main/groovy/org/grails/databinding/bindingsource/DataBindingSourceCreationException.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -21,7 +21,7 @@\n  * Thrown if an unrecoverable problem occurs creating a DataBindingSource.\n  *\n  * @since 2.3\n- * @see org.grails.databinding.DataBindingSource\n+ * @see grails.databinding.DataBindingSource\n  * @see DataBindingSourceCreator\n  */\n public class DataBindingSourceCreationException extends RuntimeException {"
        },
        {
          "filename": "grails-web-common/src/main/groovy/org/grails/web/json/JSONObject.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -75,7 +75,7 @@ of this software and associated documentation files (the \"Software\"), to deal\n  * <code>{ } [ ] / \\ : , = ; #</code> and if they do not look like numbers\n  * and if they are not the reserved words <code>true</code>,\n  * <code>false</code>, or <code>null</code>.</li>\n- * <li>Keys can be followed by <code>=</code> or <code>=></code> as well as\n+ * <li>Keys can be followed by <code>=</code> or <code>=$gt;</code> as well as\n  * by <code>:</code>.</li>\n  * <li>Values can be followed by <code>;</code> <small>(semicolon)</small> as\n  * well as by <code>,</code> <small>(comma)</small>.</li>\n@@ -796,7 +796,7 @@ public JSONObject putOpt(String key, Object value) throws JSONException {\n \n     /**\n      * Produce a string in double quotes with backslash sequences in all the\n-     * right places. A backslash will be inserted within </, allowing JSON\n+     * right places. A backslash will be inserted within &lt;/, allowing JSON\n      * text to be delivered in HTML. In JSON text, a string cannot contain a\n      * control character or an unescaped quote or backslash.\n      *"
        },
        {
          "filename": "grails-web-common/src/main/groovy/org/grails/web/servlet/mvc/GrailsWebRequest.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -257,7 +257,7 @@ public GrailsParameterMap getOriginalParams() {\n     }\n \n     /**\n-     * Reset params by re-reading & initializing parameters from request\n+     * Reset params by re-reading and initializing parameters from request\n      */\n     public void resetParams() {\n         params = (GrailsParameterMap)getOriginalParams().clone();"
        },
        {
          "filename": "grails-web-common/src/main/groovy/org/grails/web/servlet/view/AbstractGrailsView.java",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -80,9 +80,9 @@ private void renderWithinGrailsWebRequest(Map<String, Object> model, HttpServlet\n     /**\n      * Renders a page with the specified TemplateEngine, mode and response.\n      * @param model The model to use\n-     * @param request The HttpServletRequest\n-     * @param response The HttpServletResponse instance\n-     * @param engine The TemplateEngine to use\n+     * @param webRequest The {@link org.grails.web.servlet.mvc.GrailsWebRequest}\n+     * @param request The {@link javax.servlet.http.HttpServletRequest}\n+     * @param response The {@link javax.servlet.http.HttpServletResponse} instance\n      *\n      * @throws java.io.IOException Thrown when an error occurs writing the response\n      */"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 7,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "16b60ab83cc9d7d0a6d6b50102a99032e254a9cb",
            "date": "2025-01-14T17:04:23Z",
            "author_login": "codeconsole"
          },
          {
            "sha": "67d4cfc56aa9ca8772a527216df0f2ed0e6d466d",
            "date": "2025-01-14T16:44:38Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "808b60254837d186a7012a5c01c5f32da6b8bac6",
            "date": "2025-01-12T19:19:05Z",
            "author_login": "codeconsole"
          },
          {
            "sha": "13862a4505898d3d554575925c06aa6a2b1aa5b3",
            "date": "2025-01-11T02:50:53Z",
            "author_login": "jdaugherty"
          },
          {
            "sha": "7f362e6bbbe7a5a19f75eecafdb304dd468c7af4",
            "date": "2025-01-11T02:49:15Z",
            "author_login": "jdaugherty"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Grails is a framework used to build web applications with the Groovy programming language. A specially crafted web request can lead to a JVM crash or denial of service. Any Grails framework application using Grails data binding is vulnerable. This issue has been patched in version 3.3.17, 4.1.3, 5.3.4, 6.1.0.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-12-21T00:15:25.813",
    "last_modified": "2024-11-21T08:27:56.730",
    "fix_date": "2023-12-06T13:22:43Z"
  },
  "references": [
    {
      "url": "https://github.com/grails/grails-core/commit/74326bdd2cf7dcb594092165e9464520f8366c60",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/commit/c401faaa6c24c021c758b95f72304a0e855a8db3",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/issues/13302",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/security/advisories/GHSA-3pjv-r7w4-2cf5",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://grails.org/blog/2023-12-20-cve-data-binding-dos.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/commit/74326bdd2cf7dcb594092165e9464520f8366c60",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/commit/c401faaa6c24c021c758b95f72304a0e855a8db3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/issues/13302",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/grails/grails-core/security/advisories/GHSA-3pjv-r7w4-2cf5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://grails.org/blog/2023-12-20-cve-data-binding-dos.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:41.590743",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "grails-core",
    "owner": "grails",
    "created_at": "2010-02-10T23:57:57Z",
    "updated_at": "2025-01-12T19:19:15Z",
    "pushed_at": "2025-01-12T19:19:10Z",
    "size": 356496,
    "stars": 2790,
    "forks": 952,
    "open_issues": 331,
    "watchers": 2790,
    "has_security_policy": false,
    "default_branch": "7.0.x",
    "protected_branches": [
      "3.0.x",
      "3.1.x",
      "3.2.x",
      "3.3.x",
      "4.0.x",
      "4.1.x",
      "5.0.x",
      "5.1.x",
      "5.2.x",
      "5.3.x",
      "5.4.x",
      "6.0.x",
      "6.1.x",
      "6.2.x",
      "7.0.x"
    ],
    "languages": {
      "HTML": 38185035,
      "Groovy": 3409043,
      "Java": 3345627,
      "CSS": 116082,
      "Shell": 5744,
      "JavaScript": 3472
    },
    "commit_activity": {
      "total_commits_last_year": 899,
      "avg_commits_per_week": 17.28846153846154,
      "days_active_last_year": 157
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:37:28.128101"
  }
}