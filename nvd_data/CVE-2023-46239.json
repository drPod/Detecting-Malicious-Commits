{
  "cve_id": "CVE-2023-46239",
  "github_data": {
    "repository": "quic-go/quic-go",
    "fix_commit": "b6a4725b60f1fe04e8f1ddcc3114e290fcea1617",
    "related_commits": [
      "b6a4725b60f1fe04e8f1ddcc3114e290fcea1617",
      "b6a4725b60f1fe04e8f1ddcc3114e290fcea1617"
    ],
    "patch_url": "https://github.com/quic-go/quic-go/commit/b6a4725b60f1fe04e8f1ddcc3114e290fcea1617.patch",
    "fix_commit_details": {
      "sha": "b6a4725b60f1fe04e8f1ddcc3114e290fcea1617",
      "commit_date": "2023-08-05T22:25:04Z",
      "author": {
        "login": "marten-seemann",
        "type": "User",
        "stats": {
          "total_commits": 4033,
          "average_weekly_commits": 8.786492374727668,
          "total_additions": 428636,
          "total_deletions": 349187,
          "weeks_active": 389
        }
      },
      "commit_message": {
        "title": "fix handling of ACK frames serialized after CRYPTO frames (#4018)",
        "length": 65,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 88,
        "additions": 37,
        "deletions": 51
      },
      "files": [
        {
          "filename": "connection.go",
          "status": "modified",
          "additions": 25,
          "deletions": 6,
          "patch": "@@ -718,20 +718,22 @@ func (s *connection) idleTimeoutStartTime() time.Time {\n }\n \n func (s *connection) handleHandshakeComplete() error {\n-\ts.handshakeComplete = true\n \tdefer s.handshakeCtxCancel()\n \t// Once the handshake completes, we have derived 1-RTT keys.\n-\t// There's no point in queueing undecryptable packets for later decryption any more.\n+\t// There's no point in queueing undecryptable packets for later decryption anymore.\n \ts.undecryptablePackets = nil\n \n \ts.connIDManager.SetHandshakeComplete()\n \ts.connIDGenerator.SetHandshakeComplete()\n \n+\t// The server applies transport parameters right away, but the client side has to wait for handshake completion.\n+\t// During a 0-RTT connection, the client is only allowed to use the new transport parameters for 1-RTT packets.\n \tif s.perspective == protocol.PerspectiveClient {\n \t\ts.applyTransportParameters()\n \t\treturn nil\n \t}\n \n+\t// All these only apply to the server side.\n \tif err := s.handleHandshakeConfirmed(); err != nil {\n \t\treturn err\n \t}\n@@ -1229,6 +1231,7 @@ func (s *connection) handleFrames(\n \tif log != nil {\n \t\tframes = make([]logging.Frame, 0, 4)\n \t}\n+\thandshakeWasComplete := s.handshakeComplete\n \tvar handleErr error\n \tfor len(data) > 0 {\n \t\tl, frame, err := s.frameParser.ParseNext(data, encLevel, s.version)\n@@ -1265,6 +1268,17 @@ func (s *connection) handleFrames(\n \t\t\treturn false, handleErr\n \t\t}\n \t}\n+\n+\t// Handle completion of the handshake after processing all the frames.\n+\t// This ensures that we correctly handle the following case on the server side:\n+\t// We receive a Handshake packet that contains the CRYPTO frame that allows us to complete the handshake,\n+\t// and an ACK serialized after that CRYPTO frame. In this case, we still want to process the ACK frame.\n+\tif !handshakeWasComplete && s.handshakeComplete {\n+\t\tif err := s.handleHandshakeComplete(); err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n+\n \treturn\n }\n \n@@ -1360,7 +1374,9 @@ func (s *connection) handleHandshakeEvents() error {\n \t\tcase handshake.EventNoEvent:\n \t\t\treturn nil\n \t\tcase handshake.EventHandshakeComplete:\n-\t\t\terr = s.handleHandshakeComplete()\n+\t\t\t// Don't call handleHandshakeComplete yet.\n+\t\t\t// It's advantageous to process ACK frames that might be serialized after the CRYPTO frame first.\n+\t\t\ts.handshakeComplete = true\n \t\tcase handshake.EventReceivedTransportParameters:\n \t\t\terr = s.handleTransportParameters(ev.TransportParameters)\n \t\tcase handshake.EventRestoredTransportParameters:\n@@ -1488,6 +1504,9 @@ func (s *connection) handleAckFrame(frame *wire.AckFrame, encLevel protocol.Encr\n \tif !acked1RTTPacket {\n \t\treturn nil\n \t}\n+\t// On the client side: If the packet acknowledged a 1-RTT packet, this confirms the handshake.\n+\t// This is only possible if the ACK was sent in a 1-RTT packet.\n+\t// This is an optimization over simply waiting for a HANDSHAKE_DONE frame, see section 4.1.2 of RFC 9001.\n \tif s.perspective == protocol.PerspectiveClient && !s.handshakeConfirmed {\n \t\tif err := s.handleHandshakeConfirmed(); err != nil {\n \t\t\treturn err\n@@ -1659,6 +1678,9 @@ func (s *connection) restoreTransportParameters(params *wire.TransportParameters\n }\n \n func (s *connection) handleTransportParameters(params *wire.TransportParameters) error {\n+\tif s.tracer != nil {\n+\t\ts.tracer.ReceivedTransportParameters(params)\n+\t}\n \tif err := s.checkTransportParameters(params); err != nil {\n \t\treturn &qerr.TransportError{\n \t\t\tErrorCode:    qerr.TransportParameterError,\n@@ -1685,9 +1707,6 @@ func (s *connection) checkTransportParameters(params *wire.TransportParameters)\n \tif s.logger.Debug() {\n \t\ts.logger.Debugf(\"Processed Transport Parameters: %s\", params)\n \t}\n-\tif s.tracer != nil {\n-\t\ts.tracer.ReceivedTransportParameters(params)\n-\t}\n \n \t// check the initial_source_connection_id\n \tif params.InitialSourceConnectionID != s.handshakeDestConnID {"
        },
        {
          "filename": "connection_test.go",
          "status": "modified",
          "additions": 12,
          "deletions": 45,
          "patch": "@@ -1891,7 +1891,6 @@ var _ = Describe(\"Connection\", func() {\n \n \tIt(\"cancels the HandshakeComplete context when the handshake completes\", func() {\n \t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n-\t\tfinishHandshake := make(chan struct{})\n \t\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n \t\tconn.sentPacketHandler = sph\n \t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n@@ -1901,53 +1900,26 @@ var _ = Describe(\"Connection\", func() {\n \t\tsph.EXPECT().DropPackets(protocol.EncryptionHandshake)\n \t\tsph.EXPECT().SetHandshakeConfirmed()\n \t\tconnRunner.EXPECT().Retire(clientDestConnID)\n-\t\tgo func() {\n-\t\t\tdefer GinkgoRecover()\n-\t\t\t<-finishHandshake\n-\t\t\tcryptoSetup.EXPECT().StartHandshake()\n-\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n-\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n-\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n-\t\t\tcryptoSetup.EXPECT().GetSessionTicket()\n-\t\t\tconn.run()\n-\t\t}()\n+\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n+\t\tcryptoSetup.EXPECT().GetSessionTicket()\n \t\thandshakeCtx := conn.HandshakeComplete()\n \t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n-\t\tclose(finishHandshake)\n+\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n \t\tEventually(handshakeCtx).Should(BeClosed())\n-\t\t// make sure the go routine returns\n-\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n-\t\texpectReplaceWithClosed()\n-\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n-\t\tcryptoSetup.EXPECT().Close()\n-\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n-\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n-\t\ttracer.EXPECT().Close()\n-\t\tconn.shutdown()\n-\t\tEventually(conn.Context().Done()).Should(BeClosed())\n \t})\n \n \tIt(\"sends a session ticket when the handshake completes\", func() {\n \t\tconst size = protocol.MaxPostHandshakeCryptoFrameSize * 3 / 2\n \t\tpacker.EXPECT().PackCoalescedPacket(false, gomock.Any(), conn.version).AnyTimes()\n-\t\tfinishHandshake := make(chan struct{})\n \t\tconnRunner.EXPECT().Retire(clientDestConnID)\n \t\tconn.sentPacketHandler.DropPackets(protocol.EncryptionInitial)\n \t\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionHandshake)\n-\t\tgo func() {\n-\t\t\tdefer GinkgoRecover()\n-\t\t\t<-finishHandshake\n-\t\t\tcryptoSetup.EXPECT().StartHandshake()\n-\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete})\n-\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n-\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n-\t\t\tcryptoSetup.EXPECT().GetSessionTicket().Return(make([]byte, size), nil)\n-\t\t\tconn.run()\n-\t\t}()\n+\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n+\t\tcryptoSetup.EXPECT().GetSessionTicket().Return(make([]byte, size), nil)\n \n \t\thandshakeCtx := conn.HandshakeComplete()\n \t\tConsistently(handshakeCtx).ShouldNot(BeClosed())\n-\t\tclose(finishHandshake)\n+\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n \t\tvar frames []ackhandler.Frame\n \t\tEventually(func() []ackhandler.Frame {\n \t\t\tframes, _ = conn.framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n@@ -1963,16 +1935,6 @@ var _ = Describe(\"Connection\", func() {\n \t\t\t}\n \t\t}\n \t\tExpect(size).To(BeEquivalentTo(s))\n-\t\t// make sure the go routine returns\n-\t\tstreamManager.EXPECT().CloseWithError(gomock.Any())\n-\t\texpectReplaceWithClosed()\n-\t\tpacker.EXPECT().PackApplicationClose(gomock.Any(), gomock.Any(), conn.version).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n-\t\tcryptoSetup.EXPECT().Close()\n-\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n-\t\ttracer.EXPECT().ClosedConnection(gomock.Any())\n-\t\ttracer.EXPECT().Close()\n-\t\tconn.shutdown()\n-\t\tEventually(conn.Context().Done()).Should(BeClosed())\n \t})\n \n \tIt(\"doesn't cancel the HandshakeComplete context when the handshake fails\", func() {\n@@ -2027,6 +1989,7 @@ var _ = Describe(\"Connection\", func() {\n \t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed()\n \t\t\tcryptoSetup.EXPECT().GetSessionTicket()\n \t\t\tmconn.EXPECT().Write(gomock.Any(), gomock.Any())\n+\t\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n \t\t\tconn.run()\n \t\t}()\n \t\tEventually(done).Should(BeClosed())\n@@ -2350,6 +2313,7 @@ var _ = Describe(\"Connection\", func() {\n \t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n \t\t\t\tcryptoSetup.EXPECT().GetSessionTicket().MaxTimes(1)\n \t\t\t\tcryptoSetup.EXPECT().SetHandshakeConfirmed().MaxTimes(1)\n+\t\t\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n \t\t\t\terr := conn.run()\n \t\t\t\tnerr, ok := err.(net.Error)\n \t\t\t\tExpect(ok).To(BeTrue())\n@@ -2867,7 +2831,10 @@ var _ = Describe(\"Client Connection\", func() {\n \t\t\t\t\tTransportParameters: params,\n \t\t\t\t})\n \t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete}).MaxTimes(1)\n-\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}).MaxTimes(1)\n+\t\t\t\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}).MaxTimes(1).Do(func() {\n+\t\t\t\t\tdefer GinkgoRecover()\n+\t\t\t\t\tExpect(conn.handleHandshakeComplete()).To(Succeed())\n+\t\t\t\t})\n \t\t\t\terrChan <- conn.run()\n \t\t\t\tclose(errChan)\n \t\t\t}()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "62a94758e6725ea285443090c802157df86331b9",
            "date": "2025-01-14T08:40:20Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "fbbc3c9e3017064bc003a36079bd1470c7f18a09",
            "date": "2025-01-14T08:01:57Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "96ce54e83f2c8daba07bab99f086215b0b2dc74b",
            "date": "2025-01-14T04:50:16Z",
            "author_login": "lRoccoon"
          },
          {
            "sha": "516220b0c5cc21fd4c4cfc2079cbf46e09846276",
            "date": "2025-01-13T02:27:12Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "61adb85052c1c9e350bbbfb7ad7e7767aa2ea8bb",
            "date": "2025-01-13T02:02:13Z",
            "author_login": "marten-seemann"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-248",
    "description": "quic-go is an implementation of the QUIC protocol in Go. Starting in version 0.37.0 and prior to version 0.37.3, by serializing an ACK frame after the CRYTPO that allows a node to complete the handshake, a remote node could trigger a nil pointer dereference (leading to a panic) when the node attempted to drop the Handshake packet number space. An attacker can bring down a quic-go node with very minimal effort. Completing the QUIC handshake only requires sending and receiving a few packets. Version 0.37.3 contains a patch. Versions before 0.37.0 are not affected.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-31T16:15:09.543",
    "last_modified": "2024-11-21T08:28:08.667",
    "fix_date": "2023-08-05T22:25:04Z"
  },
  "references": [
    {
      "url": "https://github.com/quic-go/quic-go/commit/b6a4725b60f1fe04e8f1ddcc3114e290fcea1617",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/releases/tag/v0.37.3",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/security/advisories/GHSA-3q6m-v84f-6p9h",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/b6a4725b60f1fe04e8f1ddcc3114e290fcea1617",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/releases/tag/v0.37.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/security/advisories/GHSA-3q6m-v84f-6p9h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:36.972007",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "quic-go",
    "owner": "quic-go",
    "created_at": "2016-04-06T20:16:27Z",
    "updated_at": "2025-01-14T18:27:53Z",
    "pushed_at": "2025-01-14T09:43:06Z",
    "size": 16771,
    "stars": 10331,
    "forks": 1339,
    "open_issues": 197,
    "watchers": 10331,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 2479488,
      "Shell": 3386,
      "Dockerfile": 1884
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:11:44.846055"
  }
}