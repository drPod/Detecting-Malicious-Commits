{
  "cve_id": "CVE-2023-46852",
  "github_data": {
    "repository": "memcached/memcached",
    "fix_commit": "76a6c363c18cfe7b6a1524ae64202ac9db330767",
    "related_commits": [
      "76a6c363c18cfe7b6a1524ae64202ac9db330767",
      "76a6c363c18cfe7b6a1524ae64202ac9db330767"
    ],
    "patch_url": "https://github.com/memcached/memcached/commit/76a6c363c18cfe7b6a1524ae64202ac9db330767.patch",
    "fix_commit_details": {
      "sha": "76a6c363c18cfe7b6a1524ae64202ac9db330767",
      "commit_date": "2023-07-28T17:32:16Z",
      "author": {
        "login": "dormando",
        "type": "User",
        "stats": {
          "total_commits": 1055,
          "average_weekly_commits": 0.9336283185840708,
          "total_additions": 88203,
          "total_deletions": 31314,
          "weeks_active": 296
        }
      },
      "commit_message": {
        "title": "proxy: fix buffer overflow with multiget syntax",
        "length": 785,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 22,
        "additions": 20,
        "deletions": 2
      },
      "files": [
        {
          "filename": "proto_proxy.c",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -721,6 +721,12 @@ int proxy_run_coroutine(lua_State *Lc, mc_resp *resp, io_pending_proxy_t *p, con\n     return 0;\n }\n \n+// basically any data before the first key.\n+// max is like 15ish plus spaces. we can be more strict about how many spaces\n+// to expect because any client spamming space is being deliberately stupid\n+// anyway.\n+#define MAX_CMD_PREFIX 20\n+\n static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget) {\n     assert(c != NULL);\n     LIBEVENT_THREAD *thr = c->thread;\n@@ -793,12 +799,18 @@ static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool mu\n     if (!multiget && pr.cmd_type == CMD_TYPE_GET && pr.has_space) {\n         uint32_t keyoff = pr.tokens[pr.keytoken];\n         while (pr.klen != 0) {\n-            char temp[KEY_MAX_LENGTH + 30];\n+            char temp[KEY_MAX_LENGTH + MAX_CMD_PREFIX + 30];\n             char *cur = temp;\n             // Core daemon can abort the entire command if one key is bad, but\n             // we cannot from the proxy. Instead we have to inject errors into\n             // the stream. This should, thankfully, be rare at least.\n-            if (pr.klen > KEY_MAX_LENGTH) {\n+            if (pr.tokens[pr.keytoken] > MAX_CMD_PREFIX) {\n+                if (!resp_start(c)) {\n+                    conn_set_state(c, conn_closing);\n+                    return;\n+                }\n+                proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"malformed request\");\n+            } else if (pr.klen > KEY_MAX_LENGTH) {\n                 if (!resp_start(c)) {\n                     conn_set_state(c, conn_closing);\n                     return;"
        },
        {
          "filename": "t/proxyunits.t",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -151,6 +151,12 @@ sub proxy_test {\n         print $ps \"$_\\r\\n\";\n         is(scalar <$ps>, \"CLIENT_ERROR parsing request\\r\\n\", \"$_ got CLIENT_ERROR for too few tokens\");\n     }\n+\n+    my $space = ' ' x 200;\n+    print $ps \"get$space key key\\r\\n\";\n+    is(scalar <$ps>, \"CLIENT_ERROR malformed request\\r\\n\");\n+    is(scalar <$ps>, \"CLIENT_ERROR malformed request\\r\\n\");\n+    is(scalar <$ps>, \"END\\r\\n\"); # god damn multiget syntax.\n }\n \n # Basic test with a backend; write a request to the client socket, read it"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7d6bc7b09e3c6bb8eaff8b2b3d78d01e0bf17f6f",
            "date": "2024-12-23T00:57:30Z",
            "author_login": "dormando"
          },
          {
            "sha": "dc68c54c84b8302995ef33facd6ffdfe2865ed08",
            "date": "2024-12-22T23:40:51Z",
            "author_login": "dormando"
          },
          {
            "sha": "550b0fa0bdbca40ceca8a40d7c423a207ed7875c",
            "date": "2024-12-22T23:33:32Z",
            "author_login": "dormando"
          },
          {
            "sha": "f392de251b5974fb3e6b80956b289984b99c4c63",
            "date": "2024-12-22T23:24:49Z",
            "author_login": "dormando"
          },
          {
            "sha": "c360ce8693a610f4e37a23fd8091ce0d08ba4119",
            "date": "2024-12-20T19:37:26Z",
            "author_login": "dormando"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-120",
    "description": "In Memcached before 1.6.22, a buffer overflow exists when processing multiget requests in proxy mode, if there are many spaces after the \"get\" substring.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-27T20:15:09.133",
    "last_modified": "2024-11-21T08:29:25.717",
    "fix_date": "2023-07-28T17:32:16Z"
  },
  "references": [
    {
      "url": "https://github.com/memcached/memcached/commit/76a6c363c18cfe7b6a1524ae64202ac9db330767",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/memcached/memcached/compare/1.6.21...1.6.22",
      "source": "cve@mitre.org",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/memcached/memcached/commit/76a6c363c18cfe7b6a1524ae64202ac9db330767",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/memcached/memcached/compare/1.6.21...1.6.22",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:36.959786",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "memcached",
    "owner": "memcached",
    "created_at": "2009-04-24T23:34:25Z",
    "updated_at": "2025-01-14T05:51:40Z",
    "pushed_at": "2025-01-13T22:43:51Z",
    "size": 6228,
    "stars": 13649,
    "forks": 3295,
    "open_issues": 75,
    "watchers": 13649,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1727725,
      "Perl": 476083,
      "Lua": 78034,
      "C++": 34629,
      "M4": 32313,
      "Python": 22347,
      "DTrace": 10604,
      "Makefile": 6758,
      "Shell": 6233,
      "Roff": 1894,
      "Starlark": 726
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T13:00:59.490793"
  }
}