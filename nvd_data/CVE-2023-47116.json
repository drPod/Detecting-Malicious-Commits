{
  "cve_id": "CVE-2023-47116",
  "github_data": {
    "repository": "HumanSignal/label-studio",
    "fix_commit": "55dd6af4716b92f2bb213fe461d1ffbc380c6a64",
    "related_commits": [
      "55dd6af4716b92f2bb213fe461d1ffbc380c6a64",
      "55dd6af4716b92f2bb213fe461d1ffbc380c6a64"
    ],
    "patch_url": "https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64.patch",
    "fix_commit_details": {
      "sha": "55dd6af4716b92f2bb213fe461d1ffbc380c6a64",
      "commit_date": "2024-01-22T21:44:30Z",
      "author": {
        "login": "jombooth",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: LEAP-396: More exhaustative IP validation for SSRF defenses, plus user configurability (#5316)",
        "length": 274,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 108,
        "additions": 97,
        "deletions": 11
      },
      "files": [
        {
          "filename": "label_studio/core/settings/base.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -403,6 +403,8 @@\n MAX_TIME_BETWEEN_ACTIVITY = int(get_env('MAX_TIME_BETWEEN_ACTIVITY', timedelta(days=5).total_seconds()))\n \n SSRF_PROTECTION_ENABLED = get_bool_env('SSRF_PROTECTION_ENABLED', False)\n+USE_DEFAULT_BANNED_SUBNETS = get_bool_env('USE_DEFAULT_BANNED_SUBNETS', True)\n+USER_ADDITIONAL_BANNED_SUBNETS = get_env_list('USER_ADDITIONAL_BANNED_SUBNETS', default=[])\n \n # user media files\n MEDIA_ROOT = os.path.join(BASE_DATA_DIR, 'media')"
        },
        {
          "filename": "label_studio/core/utils/io.py",
          "status": "modified",
          "additions": 47,
          "deletions": 10,
          "patch": "@@ -197,24 +197,61 @@ def validate_upload_url(url, block_local_urls=True):\n \n \n def validate_ip(ip: str) -> None:\n-    \"\"\"Checks if an IP is local/private.\n+    \"\"\"If settings.USE_DEFAULT_BANNED_SUBNETS is True, this function checks\n+    if an IP is reserved for any of the reasons in\n+    https://en.wikipedia.org/wiki/Reserved_IP_addresses\n+    and raises an exception if so. Additionally, if settings.USER_ADDITIONAL_BANNED_SUBNETS\n+    is set, it will also check against those subnets.\n+\n+    If settings.USE_DEFAULT_BANNED_SUBNETS is False, this function will only check\n+    the IP against settings.USER_ADDITIONAL_BANNED_SUBNETS. Turning off the default\n+    subnets is **risky** and should only be done if you know what you're doing.\n \n     :param ip: IP address to be checked.\n     \"\"\"\n \n-    if ip == '0.0.0.0':  # nosec\n-        raise InvalidUploadUrlError\n+    default_banned_subnets = [\n+        '0.0.0.0/8',  # current network\n+        '10.0.0.0/8',  # private network\n+        '100.64.0.0/10',  # shared address space\n+        '127.0.0.0/8',  # loopback\n+        '169.254.0.0/16',  # link-local\n+        '172.16.0.0/12',  # private network\n+        '192.0.0.0/24',  # IETF protocol assignments\n+        '192.0.2.0/24',  # TEST-NET-1\n+        '192.88.99.0/24',  # Reserved, formerly ipv6 to ipv4 relay\n+        '192.168.0.0/16',  # private network\n+        '198.18.0.0/15',  # network interconnect device benchmark testing\n+        '198.51.100.0/24',  # TEST-NET-2\n+        '203.0.113.0/24',  # TEST-NET-3\n+        '224.0.0.0/4',  # multicast\n+        '233.252.0.0/24',  # MCAST-TEST-NET\n+        '240.0.0.0/4',  # reserved for future use\n+        '255.255.255.255/32',  # limited broadcast\n+        '::/128',  # unspecified address\n+        '::1/128',  # loopback\n+        '::ffff:0:0/96',  # IPv4-mapped address\n+        '::ffff:0:0:0/96',  # IPv4-translated address\n+        '64:ff9b::/96',  # IPv4/IPv6 translation\n+        '64:ff9b:1::/48',  # IPv4/IPv6 translation\n+        '100::/64',  # discard prefix\n+        '2001:0000::/32',  # Teredo tunneling\n+        '2001:20::/28',  # ORCHIDv2\n+        '2001:db8::/32',  # documentation\n+        '2002::/16',  # 6to4\n+        'fc00::/7',  # unique local\n+        'fe80::/10',  # link-local\n+        'ff00::/8',  # multicast\n+    ]\n \n-    local_subnets = [\n-        '127.0.0.0/8',\n-        '10.0.0.0/8',\n-        '172.16.0.0/12',\n-        '192.168.0.0/16',\n+    banned_subnets = [\n+        *(default_banned_subnets if settings.USE_DEFAULT_BANNED_SUBNETS else []),\n+        *(settings.USER_ADDITIONAL_BANNED_SUBNETS or []),\n     ]\n \n-    for subnet in local_subnets:\n+    for subnet in banned_subnets:\n         if ipaddress.ip_address(ip) in ipaddress.ip_network(subnet):\n-            raise InvalidUploadUrlError\n+            raise InvalidUploadUrlError(f'URL resolves to a reserved network address (block: {subnet})')\n \n \n def ssrf_safe_get(url, *args, **kwargs):"
        },
        {
          "filename": "label_studio/tests/data_import/test_uploader.py",
          "status": "modified",
          "additions": 48,
          "deletions": 1,
          "patch": "@@ -70,7 +70,54 @@ def test_local_url_after_redirect(self, project, settings):\n                 ValidationError\n             ) as e:\n                 load_tasks(request, project)\n-            assert 'The provided URL was not valid.' in str(e.value)\n+            assert 'URL resolves to a reserved network address (block: 127.0.0.0/8)' in str(e.value)\n+\n+        def test_user_specified_block(self, project, settings):\n+            settings.SSRF_PROTECTION_ENABLED = True\n+            settings.USER_ADDITIONAL_BANNED_SUBNETS = ['1.2.3.4']\n+            request = MockedRequest(url='http://validurl.com')\n+\n+            # Mock the necessary parts of the response object\n+            mock_response = Mock()\n+            mock_response.raw._connection.sock.getpeername.return_value = ('1.2.3.4', 8080)\n+\n+            # Patch the requests.get call in the data_import.uploader module\n+            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n+                ValidationError\n+            ) as e:\n+                load_tasks(request, project)\n+            assert 'URL resolves to a reserved network address (block: 1.2.3.4)' in str(e.value)\n+\n+            mock_response.raw._connection.sock.getpeername.return_value = ('198.51.100.0', 8080)\n+            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n+                ValidationError\n+            ) as e:\n+                load_tasks(request, project)\n+            assert 'URL resolves to a reserved network address (block: 198.51.100.0/24)' in str(e.value)\n+\n+        def test_user_specified_block_without_default(self, project, settings):\n+            settings.SSRF_PROTECTION_ENABLED = True\n+            settings.USER_ADDITIONAL_BANNED_SUBNETS = ['1.2.3.4']\n+            settings.USE_DEFAULT_BANNED_SUBNETS = False\n+            request = MockedRequest(url='http://validurl.com')\n+\n+            # Mock the necessary parts of the response object\n+            mock_response = Mock()\n+            mock_response.raw._connection.sock.getpeername.return_value = ('1.2.3.4', 8080)\n+\n+            # Patch the requests.get call in the data_import.uploader module\n+            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n+                ValidationError\n+            ) as e:\n+                load_tasks(request, project)\n+            assert 'URL resolves to a reserved network address (block: 1.2.3.4)' in str(e.value)\n+\n+            mock_response.raw._connection.sock.getpeername.return_value = ('198.51.100.0', 8080)\n+            with mock.patch('core.utils.io.requests.get', return_value=mock_response), pytest.raises(\n+                ValidationError\n+            ) as e:\n+                load_tasks(request, project)\n+            assert \"'Mock' object is not subscriptable\" in str(e.value)  # validate ip did not raise exception\n \n \n class TestTasksFileChecks:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d7f69d9a18d961d3e3d11cef5b8c49f77fd6b0f6",
            "date": "2025-01-14T16:38:59Z",
            "author_login": "huguestennier"
          },
          {
            "sha": "1e767efabccae4834939c0133e1c51deb103b857",
            "date": "2025-01-14T15:23:36Z",
            "author_login": "nikitabelonogov"
          },
          {
            "sha": "b4a0a9e4cee45dc98d3058f89e256dc12b522a63",
            "date": "2025-01-14T14:02:13Z",
            "author_login": "nikitabelonogov"
          },
          {
            "sha": "813100e9c0058cc9cf9ad3ebb7d9afac5784c8ce",
            "date": "2025-01-14T14:00:30Z",
            "author_login": "robot-ci-heartex"
          },
          {
            "sha": "62e08b0f79eb7ff27712b4031e09e1c2a796b3b4",
            "date": "2025-01-14T13:56:44Z",
            "author_login": "yyassi-heartex"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "Label Studio is a popular open source data labeling tool. The vulnerability affects all versions of Label Studio prior to 1.11.0 and was tested on version 1.8.2. Label Studio's SSRF protections that can be enabled by setting the `SSRF_PROTECTION_ENABLED` environment variable can be bypassed to access internal web servers. This is because the current SSRF validation is done by executing a single DNS lookup to verify that the IP address is not in an excluded subnet range. This protection can be bypassed by either using HTTP redirection or performing a DNS rebinding attack.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-31T17:15:13.370",
    "last_modified": "2024-11-21T08:29:48.630",
    "fix_date": "2024-01-22T21:44:30Z"
  },
  "references": [
    {
      "url": "https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/HumanSignal/label-studio/releases/tag/1.11.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/HumanSignal/label-studio/security/advisories/GHSA-p59w-9gqw-wj8r",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/HumanSignal/label-studio/releases/tag/1.11.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/HumanSignal/label-studio/security/advisories/GHSA-p59w-9gqw-wj8r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.552664",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "label-studio",
    "owner": "HumanSignal",
    "created_at": "2019-06-19T02:00:44Z",
    "updated_at": "2025-01-14T14:19:04Z",
    "pushed_at": "2025-01-14T14:25:03Z",
    "size": 2431427,
    "stars": 20221,
    "forks": 2485,
    "open_issues": 922,
    "watchers": 20221,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "JavaScript": 3094087,
      "Python": 1915934,
      "TypeScript": 1337502,
      "SCSS": 350593,
      "HTML": 71425,
      "CSS": 47465,
      "Shell": 15910,
      "Dockerfile": 7094,
      "Makefile": 3603
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:37:43.325618"
  }
}