{
  "cve_id": "CVE-2023-47163",
  "github_data": {
    "repository": "remarshal-project/remarshal",
    "fix_commit": "fd6ac799a02f533c3fc243b49cdd6d21aa7ee494",
    "related_commits": [
      "fd6ac799a02f533c3fc243b49cdd6d21aa7ee494",
      "fd6ac799a02f533c3fc243b49cdd6d21aa7ee494"
    ],
    "patch_url": "https://github.com/remarshal-project/remarshal/commit/fd6ac799a02f533c3fc243b49cdd6d21aa7ee494.patch",
    "fix_commit_details": {
      "sha": "fd6ac799a02f533c3fc243b49cdd6d21aa7ee494",
      "commit_date": "2023-09-05T12:10:06Z",
      "author": {
        "login": "dbohdan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix(yaml): limit maximum nodes",
        "length": 216,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 60,
        "additions": 55,
        "deletions": 5
      },
      "files": [
        {
          "filename": "pyproject.toml",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -1,6 +1,6 @@\n [tool.poetry]\n name = \"Remarshal\"\n-version = \"0.17.0\"\n+version = \"0.17.1\"\n description = \"Convert between CBOR, JSON, MessagePack, TOML, and YAML\"\n authors = [\"D. Bohdan <dbohdan@dbohdan.com>\"]\n license = \"MIT\"\n@@ -136,8 +136,9 @@ max-complexity = 14\n \n [tool.ruff.pylint]\n allow-magic-value-types = [\"int\", \"str\"]\n-max-args = 11\n-max-branches = 19\n+max-args = 12\n+max-branches = 20\n+max-statements = 100\n \n [tool.ruff.per-file-ignores]\n \"remarshal.py\" = [\"ARG001\", \"B904\", \"EM103\", \"RET506\", \"S506\", \"SIM115\"]"
        },
        {
          "filename": "remarshal.py",
          "status": "modified",
          "additions": 37,
          "deletions": 2,
          "patch": "@@ -24,8 +24,9 @@\n import yaml.parser\n import yaml.scanner\n \n-__version__ = \"0.17.0\"\n+__version__ = \"0.17.1\"\n \n+DEFAULT_MAX_NODES = 100000\n FORMATS = [\"cbor\", \"json\", \"msgpack\", \"toml\", \"yaml\"]\n \n \n@@ -142,6 +143,15 @@ def parse_command_line(argv: List[str]) -> argparse.Namespace:  # noqa: C901.\n             ),\n         )\n \n+    parser.add_argument(\n+        \"--max-nodes\",\n+        dest=\"max_nodes\",\n+        metavar=\"n\",\n+        type=int,\n+        default=DEFAULT_MAX_NODES,\n+        help=\"maximum number of nodes in input data (default %(default)s)\",\n+    )\n+\n     output_group = parser.add_mutually_exclusive_group()\n     output_group.add_argument(\"output\", nargs=\"?\", default=\"-\", help=\"output file\")\n     output_group.add_argument(\n@@ -431,6 +441,27 @@ def decode(input_format: str, input_data: bytes) -> Document:\n     return decoder[input_format](input_data)\n \n \n+class TooManyNodesError(BaseException):\n+    def __init__(self, msg: str = \"document has too many nodes\", *args, **kwargs):\n+        super().__init__(msg, *args, **kwargs)\n+\n+\n+def validate_node_count(doc: Document, *, limit: int) -> None:\n+    count = 0\n+\n+    def count_callback(x: Any) -> Any:\n+        nonlocal count\n+        nonlocal limit\n+\n+        count += 1\n+        if count > limit:\n+            raise TooManyNodesError\n+\n+        return x\n+\n+    traverse(doc, instance_callbacks={(object, count_callback)})\n+\n+\n def reject_special_keys(key: Any) -> Any:\n     if isinstance(key, bool):\n         msg = \"boolean key\"\n@@ -627,6 +658,7 @@ def run(argv: List[str]) -> None:\n         args.input_format,\n         args.output_format,\n         json_indent=args.json_indent,\n+        max_nodes=args.max_nodes,\n         ordered=args.ordered,\n         stringify=args.stringify,\n         unwrap=args.unwrap,\n@@ -642,6 +674,7 @@ def remarshal(\n     output_format: str,\n     *,\n     json_indent: Union[int, None] = None,\n+    max_nodes: int = DEFAULT_MAX_NODES,\n     ordered: bool = True,\n     stringify: bool = False,\n     transform: Union[Callable[[Document], Document], None] = None,\n@@ -663,6 +696,8 @@ def remarshal(\n \n         parsed = decode(input_format, input_data)\n \n+        validate_node_count(parsed, limit=max_nodes)\n+\n         if unwrap is not None:\n             if not isinstance(parsed, Mapping):\n                 msg = (\n@@ -701,7 +736,7 @@ def main() -> None:\n         run(sys.argv)\n     except KeyboardInterrupt:\n         pass\n-    except (OSError, TypeError, ValueError) as e:\n+    except (OSError, TooManyNodesError, TypeError, ValueError) as e:\n         print(f\"Error: {e}\", file=sys.stderr)  # noqa: T201\n         sys.exit(1)\n "
        },
        {
          "filename": "tests/lol.yml",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+lol1: &lol1 \"lol\" \n+lol2: &lol2 [*lol1,*lol1,*lol1,*lol1,*lol1,*lol1,*lol1,*lol1,*lol1] \n+lol3: &lol3 [*lol2,*lol2,*lol2,*lol2,*lol2,*lol2,*lol2,*lol2,*lol2]\n+lol4: &lol4 [*lol3,*lol3,*lol3,*lol3,*lol3,*lol3,*lol3,*lol3,*lol3]\n+lol5: &lol5 [*lol4,*lol4,*lol4,*lol4,*lol4,*lol4,*lol4,*lol4,*lol4]\n+lol6: &lol6 [*lol5,*lol5,*lol5,*lol5,*lol5,*lol5,*lol5,*lol5,*lol5]\n+lol7: &lol7 [*lol6,*lol6,*lol6,*lol6,*lol6,*lol6,*lol6,*lol6,*lol6]\n+lol8: &lol8 [*lol7,*lol7,*lol7,*lol7,*lol7,*lol7,*lol7,*lol7,*lol7]\n+lol9: &lol9 [*lol8,*lol8,*lol8,*lol8,*lol8,*lol8,*lol8,*lol8,*lol8]\n+lol10: &lol10 [*lol9,*lol9,*lol9,*lol9,*lol9,*lol9,*lol9,*lol9,*lol9]"
        },
        {
          "filename": "tests/test_remarshal.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -601,3 +601,7 @@ def test_yaml2toml_numeric_key_null_value_stringify(self) -> None:\n         )\n         reference = read_file(\"numeric-key-null-value.toml\")\n         assert output == reference\n+\n+    def test_yaml_billion_laughs(self) -> None:\n+        with pytest.raises(remarshal.TooManyNodesError):\n+            self.convert_and_read(\"lol.yml\", \"yaml\", \"json\")"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4c21d78db568cfa95eb6da2c3905ba7b6065a2ed",
            "date": "2025-01-12T21:33:06Z",
            "author_login": "dbohdan"
          },
          {
            "sha": "c68a6ae290852642b046f8ee9a6261f626995235",
            "date": "2025-01-10T10:41:50Z",
            "author_login": "dbohdan"
          },
          {
            "sha": "d7b0ba5b276f2cefec3d53cf2957f465936e3773",
            "date": "2025-01-10T08:00:19Z",
            "author_login": "dbohdan"
          },
          {
            "sha": "396141abf8235225c6762a318a2dbbc4f6bdf564",
            "date": "2025-01-10T07:57:54Z",
            "author_login": "dbohdan"
          },
          {
            "sha": "d67f157575d2e6991d2817d036e4285df8c4b32e",
            "date": "2025-01-10T07:57:06Z",
            "author_login": "dbohdan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-674",
    "description": "Remarshal prior to v0.17.1 expands YAML alias nodes unlimitedly, hence Remarshal is vulnerable to Billion Laughs Attack. Processing untrusted YAML files may cause a denial-of-service (DoS) condition.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-11-13T03:15:09.743",
    "last_modified": "2024-11-21T08:29:52.983",
    "fix_date": "2023-09-05T12:10:06Z"
  },
  "references": [
    {
      "url": "https://github.com/remarshal-project/remarshal/commit/fd6ac799a02f533c3fc243b49cdd6d21aa7ee494",
      "source": "vultures@jpcert.or.jp",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/remarshal-project/remarshal/releases/tag/v0.17.1",
      "source": "vultures@jpcert.or.jp",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://jvn.jp/en/jp/JVN86156389/",
      "source": "vultures@jpcert.or.jp",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/remarshal-project/remarshal/commit/fd6ac799a02f533c3fc243b49cdd6d21aa7ee494",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/remarshal-project/remarshal/releases/tag/v0.17.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://jvn.jp/en/jp/JVN86156389/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:39.250769",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "remarshal",
    "owner": "remarshal-project",
    "created_at": "2014-10-04T20:42:34Z",
    "updated_at": "2025-01-12T21:50:06Z",
    "pushed_at": "2025-01-12T21:50:02Z",
    "size": 365,
    "stars": 528,
    "forks": 36,
    "open_issues": 7,
    "watchers": 528,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 54963,
      "Shell": 2570
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T22:22:36.608514"
  }
}