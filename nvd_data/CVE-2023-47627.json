{
  "cve_id": "CVE-2023-47627",
  "github_data": {
    "repository": "aio-libs/aiohttp",
    "fix_commit": "d5c12ba890557a575c313bb3017910d7616fce3d",
    "related_commits": [
      "d5c12ba890557a575c313bb3017910d7616fce3d",
      "d5c12ba890557a575c313bb3017910d7616fce3d"
    ],
    "patch_url": "https://github.com/aio-libs/aiohttp/commit/d5c12ba890557a575c313bb3017910d7616fce3d.patch",
    "fix_commit_details": {
      "sha": "d5c12ba890557a575c313bb3017910d7616fce3d",
      "commit_date": "2023-10-06T16:11:40Z",
      "author": {
        "login": "patchback[bot]",
        "type": "Bot",
        "stats": {
          "total_commits": 703,
          "average_weekly_commits": 1.1915254237288135,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 123
        }
      },
      "commit_message": {
        "title": "[PR #7661/85713a48 backport][3.8] Update Python parser for RFCs 9110/9112 (#7662)",
        "length": 235,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 171,
        "additions": 131,
        "deletions": 40
      },
      "files": [
        {
          "filename": "aiohttp/http_parser.py",
          "status": "modified",
          "additions": 49,
          "deletions": 35,
          "patch": "@@ -60,16 +60,16 @@\n \n ASCIISET: Final[Set[str]] = set(string.printable)\n \n-# See https://tools.ietf.org/html/rfc7230#section-3.1.1\n-# and https://tools.ietf.org/html/rfc7230#appendix-B\n+# See https://www.rfc-editor.org/rfc/rfc9110.html#name-overview\n+# and https://www.rfc-editor.org/rfc/rfc9110.html#name-tokens\n #\n #     method = token\n #     tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n #             \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n #     token = 1*tchar\n METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")\n-VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d+).(\\d+)\")\n-HDRRE: Final[Pattern[bytes]] = re.compile(rb\"[\\x00-\\x1F\\x7F()<>@,;:\\[\\]={} \\t\\\\\\\\\\\"]\")\n+VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")\n+HDRRE: Final[Pattern[bytes]] = re.compile(rb\"[\\x00-\\x1F\\x7F()<>@,;:\\[\\]={} \\t\\\"\\\\]\")\n \n \n class RawRequestMessage(NamedTuple):\n@@ -148,8 +148,11 @@ def parse_headers(\n             except ValueError:\n                 raise InvalidHeader(line) from None\n \n-            bname = bname.strip(b\" \\t\")\n-            bvalue = bvalue.lstrip()\n+            # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2\n+            if {bname[0], bname[-1]} & {32, 9}:  # {\" \", \"\\t\"}\n+                raise InvalidHeader(line)\n+\n+            bvalue = bvalue.lstrip(b\" \\t\")\n             if HDRRE.search(bname):\n                 raise InvalidHeader(bname)\n             if len(bname) > self.max_field_size:\n@@ -170,6 +173,7 @@ def parse_headers(\n             # consume continuation lines\n             continuation = line and line[0] in (32, 9)  # (' ', '\\t')\n \n+            # Deprecated: https://www.rfc-editor.org/rfc/rfc9112.html#name-obsolete-line-folding\n             if continuation:\n                 bvalue_lst = [bvalue]\n                 while continuation:\n@@ -204,10 +208,14 @@ def parse_headers(\n                         str(header_length),\n                     )\n \n-            bvalue = bvalue.strip()\n+            bvalue = bvalue.strip(b\" \\t\")\n             name = bname.decode(\"utf-8\", \"surrogateescape\")\n             value = bvalue.decode(\"utf-8\", \"surrogateescape\")\n \n+            # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5\n+            if \"\\n\" in value or \"\\r\" in value or \"\\x00\" in value:\n+                raise InvalidHeader(bvalue)\n+\n             headers.add(name, value)\n             raw_headers.append((bname, bvalue))\n \n@@ -322,15 +330,12 @@ def get_content_length() -> Optional[int]:\n                             if length_hdr is None:\n                                 return None\n \n-                            try:\n-                                length = int(length_hdr)\n-                            except ValueError:\n+                            # Shouldn't allow +/- or other number formats.\n+                            # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2\n+                            if not length_hdr.strip(\" \\t\").isdigit():\n                                 raise InvalidHeader(CONTENT_LENGTH)\n \n-                            if length < 0:\n-                                raise InvalidHeader(CONTENT_LENGTH)\n-\n-                            return length\n+                            return int(length_hdr)\n \n                         length = get_content_length()\n                         # do not support old websocket spec\n@@ -470,6 +475,24 @@ def parse_headers(\n         upgrade = False\n         chunked = False\n \n+        # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-6\n+        # https://www.rfc-editor.org/rfc/rfc9110.html#name-collected-abnf\n+        singletons = (\n+            hdrs.CONTENT_LENGTH,\n+            hdrs.CONTENT_LOCATION,\n+            hdrs.CONTENT_RANGE,\n+            hdrs.CONTENT_TYPE,\n+            hdrs.ETAG,\n+            hdrs.HOST,\n+            hdrs.MAX_FORWARDS,\n+            hdrs.SERVER,\n+            hdrs.TRANSFER_ENCODING,\n+            hdrs.USER_AGENT,\n+        )\n+        bad_hdr = next((h for h in singletons if len(headers.getall(h, ())) > 1), None)\n+        if bad_hdr is not None:\n+            raise BadHttpMessage(f\"Duplicate '{bad_hdr}' header found.\")\n+\n         # keep-alive\n         conn = headers.get(hdrs.CONNECTION)\n         if conn:\n@@ -523,7 +546,7 @@ def parse_message(self, lines: List[bytes]) -> RawRequestMessage:\n         # request line\n         line = lines[0].decode(\"utf-8\", \"surrogateescape\")\n         try:\n-            method, path, version = line.split(None, 2)\n+            method, path, version = line.split(maxsplit=2)\n         except ValueError:\n             raise BadStatusLine(line) from None\n \n@@ -537,14 +560,10 @@ def parse_message(self, lines: List[bytes]) -> RawRequestMessage:\n             raise BadStatusLine(method)\n \n         # version\n-        try:\n-            if version.startswith(\"HTTP/\"):\n-                n1, n2 = version[5:].split(\".\", 1)\n-                version_o = HttpVersion(int(n1), int(n2))\n-            else:\n-                raise BadStatusLine(version)\n-        except Exception:\n-            raise BadStatusLine(version)\n+        match = VERSRE.match(version)\n+        if match is None:\n+            raise BadStatusLine(line)\n+        version_o = HttpVersion(int(match.group(1)), int(match.group(2)))\n \n         if method == \"CONNECT\":\n             # authority-form,\n@@ -611,12 +630,12 @@ class HttpResponseParser(HttpParser[RawResponseMessage]):\n     def parse_message(self, lines: List[bytes]) -> RawResponseMessage:\n         line = lines[0].decode(\"utf-8\", \"surrogateescape\")\n         try:\n-            version, status = line.split(None, 1)\n+            version, status = line.split(maxsplit=1)\n         except ValueError:\n             raise BadStatusLine(line) from None\n \n         try:\n-            status, reason = status.split(None, 1)\n+            status, reason = status.split(maxsplit=1)\n         except ValueError:\n             reason = \"\"\n \n@@ -632,13 +651,9 @@ def parse_message(self, lines: List[bytes]) -> RawResponseMessage:\n         version_o = HttpVersion(int(match.group(1)), int(match.group(2)))\n \n         # The status code is a three-digit number\n-        try:\n-            status_i = int(status)\n-        except ValueError:\n-            raise BadStatusLine(line) from None\n-\n-        if status_i > 999:\n+        if len(status) != 3 or not status.isdigit():\n             raise BadStatusLine(line)\n+        status_i = int(status)\n \n         # read headers\n         (\n@@ -773,14 +788,13 @@ def feed_data(\n                         else:\n                             size_b = chunk[:pos]\n \n-                        try:\n-                            size = int(bytes(size_b), 16)\n-                        except ValueError:\n+                        if not size_b.isdigit():\n                             exc = TransferEncodingError(\n                                 chunk[:pos].decode(\"ascii\", \"surrogateescape\")\n                             )\n                             self.payload.set_exception(exc)\n-                            raise exc from None\n+                            raise exc\n+                        size = int(bytes(size_b), 16)\n \n                         chunk = chunk[pos + 2 :]\n                         if size == 0:  # eof marker"
        },
        {
          "filename": "tests/test_http_parser.py",
          "status": "modified",
          "additions": 82,
          "deletions": 5,
          "patch": "@@ -465,6 +465,74 @@ def test_invalid_name(parser) -> None:\n         parser.feed_data(text)\n \n \n+def test_cve_2023_37276(parser: Any) -> None:\n+    text = b\"\"\"POST / HTTP/1.1\\r\\nHost: localhost:8080\\r\\nX-Abc: \\rxTransfer-Encoding: chunked\\r\\n\\r\\n\"\"\"\n+    with pytest.raises(http_exceptions.BadHttpMessage):\n+        parser.feed_data(text)\n+\n+\n+@pytest.mark.parametrize(\n+    \"hdr\",\n+    (\n+        \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length\n+        \"Content-Length: +256\",\n+        \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5\n+        \"Bar: abc\\ndef\",\n+        \"Baz: abc\\x00def\",\n+        \"Foo : bar\",  # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2\n+        \"Foo\\t: bar\",\n+    ),\n+)\n+def test_bad_headers(parser: Any, hdr: str) -> None:\n+    text = f\"POST / HTTP/1.1\\r\\n{hdr}\\r\\n\\r\\n\".encode()\n+    with pytest.raises(http_exceptions.InvalidHeader):\n+        parser.feed_data(text)\n+\n+\n+def test_bad_chunked_py(loop: Any, protocol: Any) -> None:\n+    \"\"\"Test that invalid chunked encoding doesn't allow content-length to be used.\"\"\"\n+    parser = HttpRequestParserPy(\n+        protocol,\n+        loop,\n+        2**16,\n+        max_line_size=8190,\n+        max_field_size=8190,\n+    )\n+    text = (\n+        b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"\n+        + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\"\n+    )\n+    messages, upgrade, tail = parser.feed_data(text)\n+    assert isinstance(messages[0][1].exception(), http_exceptions.TransferEncodingError)\n+\n+\n+@pytest.mark.skipif(\n+    \"HttpRequestParserC\" not in dir(aiohttp.http_parser),\n+    reason=\"C based HTTP parser not available\",\n+)\n+def test_bad_chunked_c(loop: Any, protocol: Any) -> None:\n+    \"\"\"C parser behaves differently. Maybe we should align them later.\"\"\"\n+    parser = HttpRequestParserC(\n+        protocol,\n+        loop,\n+        2**16,\n+        max_line_size=8190,\n+        max_field_size=8190,\n+    )\n+    text = (\n+        b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"\n+        + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\"\n+    )\n+    with pytest.raises(http_exceptions.BadHttpMessage):\n+        parser.feed_data(text)\n+\n+\n+def test_whitespace_before_header(parser: Any) -> None:\n+    text = b\"GET / HTTP/1.1\\r\\n\\tContent-Length: 1\\r\\n\\r\\nX\"\n+    with pytest.raises(http_exceptions.BadHttpMessage):\n+        parser.feed_data(text)\n+\n+\n @pytest.mark.parametrize(\"size\", [40960, 8191])\n def test_max_header_field_size(parser, size) -> None:\n     name = b\"t\" * size\n@@ -646,6 +714,11 @@ def test_http_request_parser_bad_version(parser) -> None:\n         parser.feed_data(b\"GET //get HT/11\\r\\n\\r\\n\")\n \n \n+def test_http_request_parser_bad_version_number(parser: Any) -> None:\n+    with pytest.raises(http_exceptions.BadHttpMessage):\n+        parser.feed_data(b\"GET /test HTTP/12.3\\r\\n\\r\\n\")\n+\n+\n @pytest.mark.parametrize(\"size\", [40965, 8191])\n def test_http_request_max_status_line(parser, size) -> None:\n     path = b\"t\" * (size - 5)\n@@ -713,6 +786,11 @@ def test_http_response_parser_bad_version(response) -> None:\n         response.feed_data(b\"HT/11 200 Ok\\r\\n\\r\\n\")\n \n \n+def test_http_response_parser_bad_version_number(response) -> None:\n+    with pytest.raises(http_exceptions.BadHttpMessage):\n+        response.feed_data(b\"HTTP/12.3 200 Ok\\r\\n\\r\\n\")\n+\n+\n def test_http_response_parser_no_reason(response) -> None:\n     msg = response.feed_data(b\"HTTP/1.1 200\\r\\n\\r\\n\")[0][0][0]\n \n@@ -743,19 +821,18 @@ def test_http_response_parser_bad(response) -> None:\n         response.feed_data(b\"HTT/1\\r\\n\\r\\n\")\n \n \n-@pytest.mark.skipif(not NO_EXTENSIONS, reason=\"Behaviour has changed in C parser\")\n def test_http_response_parser_code_under_100(response) -> None:\n-    msg = response.feed_data(b\"HTTP/1.1 99 test\\r\\n\\r\\n\")[0][0][0]\n-    assert msg.code == 99\n+    with pytest.raises(http_exceptions.BadStatusLine):\n+        response.feed_data(b\"HTTP/1.1 99 test\\r\\n\\r\\n\")\n \n \n def test_http_response_parser_code_above_999(response) -> None:\n-    with pytest.raises(http_exceptions.BadHttpMessage):\n+    with pytest.raises(http_exceptions.BadStatusLine):\n         response.feed_data(b\"HTTP/1.1 9999 test\\r\\n\\r\\n\")\n \n \n def test_http_response_parser_code_not_int(response) -> None:\n-    with pytest.raises(http_exceptions.BadHttpMessage):\n+    with pytest.raises(http_exceptions.BadStatusLine):\n         response.feed_data(b\"HTTP/1.1 ttt test\\r\\n\\r\\n\")\n \n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9482755b40ce69814eea6f65bfbd4c12d1878174",
            "date": "2025-01-10T10:46:29Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "76f4309a6cbfc12d918c65b5bffdcf0d4bb691c6",
            "date": "2025-01-10T10:39:38Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c5c204f8b661bb1c9d183e17b37013ee222b2cbd",
            "date": "2025-01-10T10:37:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a91dc8f78e97f9be30e13c39e457e8e2a2651702",
            "date": "2025-01-08T10:27:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "237d46722a0e56363c4a07dcf31e73fe4c2ea392",
            "date": "2025-01-07T11:14:58Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-444",
    "description": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. The HTTP parser in AIOHTTP has numerous problems with header parsing, which could lead to request smuggling. This parser is only used when AIOHTTP_NO_EXTENSIONS is enabled (or not using a prebuilt wheel). These bugs have been addressed in commit `d5c12ba89` which has been included in release version 3.8.6. Users are advised to upgrade. There are no known workarounds for these issues.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-11-14T21:15:12.820",
    "last_modified": "2024-11-21T08:30:33.583",
    "fix_date": "2023-10-06T16:11:40Z"
  },
  "references": [
    {
      "url": "https://github.com/aio-libs/aiohttp/commit/d5c12ba890557a575c313bb3017910d7616fce3d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/security/advisories/GHSA-gfw2-4jvh-wgfg",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FUSJVQ7OQ55RWL4XAX2F5EZ73N4ZSH6U/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VDKQ6HM3KNDU4OQI476ZWT4O7DMSIT35/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQYQL6WV535EEKSNH7KRARLLMOW5WXDM/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/commit/d5c12ba890557a575c313bb3017910d7616fce3d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/security/advisories/GHSA-gfw2-4jvh-wgfg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FUSJVQ7OQ55RWL4XAX2F5EZ73N4ZSH6U/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VDKQ6HM3KNDU4OQI476ZWT4O7DMSIT35/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQYQL6WV535EEKSNH7KRARLLMOW5WXDM/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:39.258042",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "aiohttp",
    "owner": "aio-libs",
    "created_at": "2013-10-01T23:04:01Z",
    "updated_at": "2025-01-14T07:45:00Z",
    "pushed_at": "2025-01-13T11:21:32Z",
    "size": 31707,
    "stars": 15317,
    "forks": 2050,
    "open_issues": 250,
    "watchers": 15317,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "3.8",
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "master"
    ],
    "languages": {
      "Python": 2241563,
      "Cython": 41302,
      "Makefile": 5839,
      "Gherkin": 1248,
      "Dockerfile": 298,
      "C": 170,
      "Shell": 148
    },
    "commit_activity": {
      "total_commits_last_year": 2401,
      "avg_commits_per_week": 46.17307692307692,
      "days_active_last_year": 226
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:12:57.567310"
  }
}