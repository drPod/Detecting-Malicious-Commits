{
  "cve_id": "CVE-2023-47642",
  "github_data": {
    "repository": "zulip/zulip",
    "fix_commit": "6336322d2f9bbccaacfc80cba83a3c62eefd5737",
    "related_commits": [
      "6336322d2f9bbccaacfc80cba83a3c62eefd5737",
      "6336322d2f9bbccaacfc80cba83a3c62eefd5737"
    ],
    "patch_url": "https://github.com/zulip/zulip/commit/6336322d2f9bbccaacfc80cba83a3c62eefd5737.patch",
    "fix_commit_details": {
      "sha": "6336322d2f9bbccaacfc80cba83a3c62eefd5737",
      "commit_date": "2023-09-29T18:04:27Z",
      "author": {
        "login": "sahil839",
        "type": "User",
        "stats": {
          "total_commits": 1966,
          "average_weekly_commits": 3.038639876352396,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 234
        }
      },
      "commit_message": {
        "title": "CVE-2023-47642: Invalid metadata access for formerly subscribed streams.",
        "length": 754,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 160,
        "additions": 136,
        "deletions": 24
      },
      "files": [
        {
          "filename": "zerver/actions/streams.py",
          "status": "modified",
          "additions": 4,
          "deletions": 11,
          "patch": "@@ -1028,21 +1028,14 @@ def do_change_stream_permission(\n     if old_invite_only_value and not stream.invite_only:\n         # We need to send stream creation event to users who can access the\n         # stream now but were not able to do so previously. So, we can exclude\n-        # subscribers, users who were previously subscribed to the stream and\n-        # realm admins from the non-guest user list.\n-        assert stream.recipient_id is not None\n-        previously_subscribed_user_ids = Subscription.objects.filter(\n-            recipient_id=stream.recipient_id, active=False, is_user_active=True\n-        ).values_list(\"user_profile_id\", flat=True)\n+        # subscribers and realm admins from the non-guest user list.\n         stream_subscriber_user_ids = get_active_subscriptions_for_stream_id(\n             stream.id, include_deactivated_users=False\n         ).values_list(\"user_profile_id\", flat=True)\n \n-        old_can_access_stream_user_ids = (\n-            set(stream_subscriber_user_ids)\n-            | set(previously_subscribed_user_ids)\n-            | {user.id for user in stream.realm.get_admin_users_and_bots()}\n-        )\n+        old_can_access_stream_user_ids = set(stream_subscriber_user_ids) | {\n+            user.id for user in stream.realm.get_admin_users_and_bots()\n+        }\n         non_guest_user_ids = set(active_non_guest_user_ids(stream.realm_id))\n         notify_stream_creation_ids = non_guest_user_ids - old_can_access_stream_user_ids\n         send_stream_creation_event(stream, list(notify_stream_creation_ids))"
        },
        {
          "filename": "zerver/lib/events.py",
          "status": "modified",
          "additions": 42,
          "deletions": 8,
          "patch": "@@ -45,7 +45,11 @@\n from zerver.lib.sounds import get_available_notification_sounds\n from zerver.lib.stream_subscription import handle_stream_notifications_compatibility\n from zerver.lib.streams import do_get_streams, get_web_public_streams\n-from zerver.lib.subscription_info import gather_subscriptions_helper, get_web_public_subs\n+from zerver.lib.subscription_info import (\n+    build_unsubscribed_sub_from_stream_dict,\n+    gather_subscriptions_helper,\n+    get_web_public_subs,\n+)\n from zerver.lib.timestamp import datetime_to_timestamp\n from zerver.lib.timezone import canonicalize_timezone\n from zerver.lib.topic import TOPIC_NAME\n@@ -61,7 +65,9 @@\n     Message,\n     Realm,\n     RealmUserDefault,\n+    Recipient,\n     Stream,\n+    Subscription,\n     UserMessage,\n     UserProfile,\n     UserStatus,\n@@ -1001,17 +1007,45 @@ def _draft_update_action(i: int) -> None:\n                 if include_subscribers:\n                     stream_data[\"subscribers\"] = []\n \n-                # We know the stream has no traffic, and this\n-                # field is not present in the event.\n-                #\n-                # TODO: Probably this should just be added to the event.\n-                stream_data[\"stream_weekly_traffic\"] = None\n+                # Here we need to query the database to check whether the\n+                # user was previously subscribed. If they were, we need to\n+                # include the stream in the unsubscribed list after adding\n+                # personal subscription metadata (such as configured stream\n+                # color; most of the other personal setting have no effect\n+                # when not subscribed).\n+                unsubscribed_stream_sub = Subscription.objects.filter(\n+                    user_profile=user_profile,\n+                    recipient__type_id=stream[\"stream_id\"],\n+                    recipient__type=Recipient.STREAM,\n+                ).values(\n+                    *Subscription.API_FIELDS,\n+                    \"recipient_id\",\n+                    \"active\",\n+                )\n+\n+                if len(unsubscribed_stream_sub) == 1:\n+                    unsubscribed_stream_dict = build_unsubscribed_sub_from_stream_dict(\n+                        user_profile, unsubscribed_stream_sub[0], stream_data\n+                    )\n+                    if include_subscribers:\n+                        unsubscribed_stream_dict[\"subscribers\"] = []\n+\n+                    # The stream might have traffic, but we do not have the\n+                    # data to compute it in the event, so we just set to\n+                    # \"None\" here like we would do for newly created streams.\n+                    #\n+                    # TODO: Probably this should just be added to the event.\n+                    unsubscribed_stream_dict[\"stream_weekly_traffic\"] = None\n+                    state[\"unsubscribed\"].append(unsubscribed_stream_dict)\n+                else:\n+                    assert len(unsubscribed_stream_sub) == 0\n+                    stream_data[\"stream_weekly_traffic\"] = None\n+                    state[\"never_subscribed\"].append(stream_data)\n \n-                # Add stream to never_subscribed (if not invite_only)\n-                state[\"never_subscribed\"].append(stream_data)\n                 if \"streams\" in state:\n                     state[\"streams\"].append(stream)\n \n+            state[\"unsubscribed\"].sort(key=lambda elt: elt[\"name\"])\n             state[\"never_subscribed\"].sort(key=lambda elt: elt[\"name\"])\n             if \"streams\" in state:\n                 state[\"streams\"].sort(key=lambda elt: elt[\"name\"])"
        },
        {
          "filename": "zerver/lib/subscription_info.py",
          "status": "modified",
          "additions": 54,
          "deletions": 2,
          "patch": "@@ -16,8 +16,9 @@\n )\n from zerver.lib.stream_traffic import get_average_weekly_stream_traffic, get_streams_traffic\n from zerver.lib.streams import get_web_public_streams_queryset, subscribed_to_stream\n-from zerver.lib.timestamp import datetime_to_timestamp\n+from zerver.lib.timestamp import datetime_to_timestamp, timestamp_to_datetime\n from zerver.lib.types import (\n+    APIStreamDict,\n     NeverSubscribedStreamDict,\n     RawStreamDict,\n     RawSubscriptionDict,\n@@ -102,6 +103,34 @@ def get_next_color() -> str:\n     )\n \n \n+def build_unsubscribed_sub_from_stream_dict(\n+    user: UserProfile, sub_dict: RawSubscriptionDict, stream_dict: APIStreamDict\n+) -> SubscriptionStreamDict:\n+    # This function is only called from `apply_event` code.\n+    raw_stream_dict = RawStreamDict(\n+        can_remove_subscribers_group_id=stream_dict[\"can_remove_subscribers_group_id\"],\n+        date_created=timestamp_to_datetime(stream_dict[\"date_created\"]),\n+        description=stream_dict[\"description\"],\n+        first_message_id=stream_dict[\"first_message_id\"],\n+        history_public_to_subscribers=stream_dict[\"history_public_to_subscribers\"],\n+        invite_only=stream_dict[\"invite_only\"],\n+        is_web_public=stream_dict[\"is_web_public\"],\n+        message_retention_days=stream_dict[\"message_retention_days\"],\n+        name=stream_dict[\"name\"],\n+        rendered_description=stream_dict[\"rendered_description\"],\n+        id=stream_dict[\"stream_id\"],\n+        stream_post_policy=stream_dict[\"stream_post_policy\"],\n+    )\n+\n+    # We pass recent_traffic as an empty objecy and avoid extra database\n+    # query since we would just set it to None later.\n+    subscription_stream_dict = build_stream_dict_for_sub(\n+        user, sub_dict, raw_stream_dict, recent_traffic={}\n+    )\n+\n+    return subscription_stream_dict\n+\n+\n def build_stream_dict_for_sub(\n     user: UserProfile,\n     sub_dict: RawSubscriptionDict,\n@@ -378,6 +407,21 @@ def get_subscribers_query(\n     return get_active_subscriptions_for_stream_id(stream.id, include_deactivated_users=False)\n \n \n+def has_metadata_access_to_previously_subscribed_stream(\n+    user_profile: UserProfile, stream_dict: SubscriptionStreamDict\n+) -> bool:\n+    if stream_dict[\"is_web_public\"]:\n+        return True\n+\n+    if not user_profile.can_access_public_streams():\n+        return False\n+\n+    if stream_dict[\"invite_only\"]:\n+        return user_profile.is_realm_admin\n+\n+    return True\n+\n+\n # In general, it's better to avoid using .values() because it makes\n # the code pretty ugly, but in this case, it has significant\n # performance impact for loading / for users with large numbers of\n@@ -445,7 +489,15 @@ def get_stream_id(sub_dict: RawSubscriptionDict) -> int:\n         if is_active:\n             subscribed.append(stream_dict)\n         else:\n-            unsubscribed.append(stream_dict)\n+            if has_metadata_access_to_previously_subscribed_stream(user_profile, stream_dict):\n+                \"\"\"\n+                User who are no longer subscribed to a stream that they don't have\n+                metadata access to will not receive metadata related to this stream\n+                and their clients will see it as an unkown stream if referenced\n+                somewhere (e.g. a markdown stream link), just like they would see\n+                a reference to a private stream they had never been subscribed to.\n+                \"\"\"\n+                unsubscribed.append(stream_dict)\n \n     if user_profile.can_access_public_streams():\n         never_subscribed_stream_ids = set(all_streams_map) - sub_unsub_stream_ids"
        },
        {
          "filename": "zerver/tests/test_subs.py",
          "status": "modified",
          "additions": 36,
          "deletions": 3,
          "patch": "@@ -6135,14 +6135,47 @@ def test_previously_subscribed_private_streams(self) -> None:\n         sub_data = gather_subscriptions_helper(non_admin_user)\n         self.verify_sub_fields(sub_data)\n         unsubscribed_streams = sub_data.unsubscribed\n-        self.assert_length(unsubscribed_streams, 1)\n-        self.assertEqual(unsubscribed_streams[0][\"subscribers\"], [])\n+        self.assert_length(unsubscribed_streams, 0)\n \n+        sub_data = gather_subscriptions_helper(guest_user)\n+        self.verify_sub_fields(sub_data)\n+        unsubscribed_streams = sub_data.unsubscribed\n+        self.assert_length(unsubscribed_streams, 0)\n+\n+    def test_previously_subscribed_public_streams(self) -> None:\n+        public_stream_name = \"public_stream\"\n+        web_public_stream_name = \"web_public_stream\"\n+        guest_user = self.example_user(\"polonius\")\n+        member_user = self.example_user(\"hamlet\")\n+\n+        self.make_stream(public_stream_name, realm=get_realm(\"zulip\"))\n+        self.make_stream(web_public_stream_name, realm=get_realm(\"zulip\"), is_web_public=True)\n+\n+        for stream_name in [public_stream_name, web_public_stream_name]:\n+            self.subscribe(guest_user, stream_name)\n+            self.subscribe(member_user, stream_name)\n+            self.subscribe(self.example_user(\"othello\"), stream_name)\n+\n+        for stream_name in [public_stream_name, web_public_stream_name]:\n+            self.unsubscribe(guest_user, stream_name)\n+            self.unsubscribe(member_user, stream_name)\n+\n+        # Test member user gets previously subscribed public stream and its subscribers.\n+        sub_data = gather_subscriptions_helper(member_user)\n+        self.verify_sub_fields(sub_data)\n+        unsubscribed_streams = sub_data.unsubscribed\n+        self.assert_length(unsubscribed_streams, 2)\n+        self.assert_length(unsubscribed_streams[0][\"subscribers\"], 1)\n+        self.assert_length(unsubscribed_streams[1][\"subscribers\"], 1)\n+\n+        # Test guest users cannot get previously subscribed public stream but can get\n+        # web-public stream and its subscribers.\n         sub_data = gather_subscriptions_helper(guest_user)\n         self.verify_sub_fields(sub_data)\n         unsubscribed_streams = sub_data.unsubscribed\n         self.assert_length(unsubscribed_streams, 1)\n-        self.assertEqual(unsubscribed_streams[0][\"subscribers\"], [])\n+        self.assertEqual(unsubscribed_streams[0][\"is_web_public\"], True)\n+        self.assert_length(unsubscribed_streams[0][\"subscribers\"], 1)\n \n     def test_gather_subscriptions_mit(self) -> None:\n         \"\"\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "99ea0255da6d835e98f12adb7100af0f6d9ccb85",
            "date": "2025-01-09T06:57:21Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "4196859cd65d373537a0a6092ffe8dc2a6b09ada",
            "date": "2025-01-09T05:56:09Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "67887324ed74f9196aff2c26c40f5937ff811819",
            "date": "2024-11-19T21:51:08Z",
            "author_login": "mateuszmandera"
          },
          {
            "sha": "8b09190bcd129ea5e46509343049e595b92f06d9",
            "date": "2025-01-13T13:33:06Z",
            "author_login": "amanagr"
          },
          {
            "sha": "a05cbfa0c9e41e2fa2930b28653076279ae7bda0",
            "date": "2025-01-13T13:24:09Z",
            "author_login": "amanagr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "Zulip is an open-source team collaboration tool. It was discovered by the Zulip development team that active users who had previously been subscribed to a stream incorrectly continued being able to use the Zulip API to access metadata for that stream. As a result, users who had been removed from a stream, but still had an account in the organization, could still view metadata for that stream (including the stream name, description, settings, and an email address used to send emails into the stream via the incoming email integration). This potentially allowed users to see changes to a stream\u2019s metadata after they had lost access to the stream. This vulnerability has been addressed in version 7.5 and all users are advised to upgrade. There are no known workarounds for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-11-16T22:15:28.353",
    "last_modified": "2024-11-21T08:30:35.283",
    "fix_date": "2023-09-29T18:04:27Z"
  },
  "references": [
    {
      "url": "https://github.com/zulip/zulip/commit/6336322d2f9bbccaacfc80cba83a3c62eefd5737",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/security/advisories/GHSA-c9wc-65fh-9x8p",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/commit/6336322d2f9bbccaacfc80cba83a3c62eefd5737",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zulip/zulip/security/advisories/GHSA-c9wc-65fh-9x8p",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:39.265242",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zulip",
    "owner": "zulip",
    "created_at": "2015-09-25T16:37:25Z",
    "updated_at": "2025-01-14T13:31:30Z",
    "pushed_at": "2025-01-14T02:34:21Z",
    "size": 495185,
    "stars": 21946,
    "forks": 8107,
    "open_issues": 2487,
    "watchers": 21946,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.4.x",
      "1.5.x",
      "1.8.x",
      "1.9.x",
      "2.0.x",
      "2.1.x",
      "3.x",
      "3.1-with-bmemcached",
      "4.x",
      "4.0-rc1-branch",
      "5.x",
      "5.x-user-sharding",
      "5.0-rc1-branch",
      "5.0-rc2-branch",
      "6.x",
      "6.0-beta1-branch",
      "6.0-rc1-branch",
      "7.x",
      "7.0-beta1-branch",
      "7.0-beta2-branch",
      "8.x",
      "9.x",
      "buddy-list-prep",
      "chat.zulip.org",
      "dockertest",
      "main",
      "s3-compatible-uploads",
      "zulip-cloud-current"
    ],
    "languages": {
      "Python": 14193798,
      "TypeScript": 4055572,
      "JavaScript": 2278673,
      "HTML": 957053,
      "CSS": 942085,
      "Handlebars": 597145,
      "Shell": 161466,
      "Puppet": 137563,
      "Perl": 10353,
      "Dockerfile": 4219,
      "Ruby": 3794,
      "Emacs Lisp": 157
    },
    "commit_activity": {
      "total_commits_last_year": 6397,
      "avg_commits_per_week": 123.01923076923077,
      "days_active_last_year": 356
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:44:17.890508"
  }
}