{
  "cve_id": "CVE-2023-48228",
  "github_data": {
    "repository": "goauthentik/authentik",
    "fix_commit": "3af77ab3821fe9c7df8055ba5eade3d1ecea03a6",
    "related_commits": [
      "3af77ab3821fe9c7df8055ba5eade3d1ecea03a6",
      "6b9afed21f7c39f171a4a445654cfe415bba37d5",
      "b88e39411c12e3f9e04125a7887f12354f760a14",
      "3af77ab3821fe9c7df8055ba5eade3d1ecea03a6",
      "6b9afed21f7c39f171a4a445654cfe415bba37d5",
      "b88e39411c12e3f9e04125a7887f12354f760a14"
    ],
    "patch_url": "https://github.com/goauthentik/authentik/commit/3af77ab3821fe9c7df8055ba5eade3d1ecea03a6.patch",
    "fix_commit_details": {
      "sha": "3af77ab3821fe9c7df8055ba5eade3d1ecea03a6",
      "commit_date": "2023-11-21T17:13:50Z",
      "author": {
        "login": "gcp-cherry-pick-bot[bot]",
        "type": "Bot",
        "stats": {
          "total_commits": 22,
          "average_weekly_commits": 0.06811145510835913,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 4
        }
      },
      "commit_message": {
        "title": "security: fix CVE-2023-48228 (cherry-pick #7666) (#7669)",
        "length": 196,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 254,
        "additions": 253,
        "deletions": 1
      },
      "files": [
        {
          "filename": "authentik/providers/oauth2/tests/test_token_pkce.py",
          "status": "added",
          "additions": 187,
          "deletions": 0,
          "patch": "@@ -0,0 +1,187 @@\n+\"\"\"Test token view\"\"\"\n+from base64 import b64encode, urlsafe_b64encode\n+from hashlib import sha256\n+\n+from django.test import RequestFactory\n+from django.urls import reverse\n+\n+from authentik.core.models import Application\n+from authentik.core.tests.utils import create_test_admin_user, create_test_flow\n+from authentik.flows.challenge import ChallengeTypes\n+from authentik.lib.generators import generate_id\n+from authentik.providers.oauth2.constants import GRANT_TYPE_AUTHORIZATION_CODE\n+from authentik.providers.oauth2.models import AuthorizationCode, OAuth2Provider\n+from authentik.providers.oauth2.tests.utils import OAuthTestCase\n+\n+\n+class TestTokenPKCE(OAuthTestCase):\n+    \"\"\"Test token view\"\"\"\n+\n+    def setUp(self) -> None:\n+        super().setUp()\n+        self.factory = RequestFactory()\n+        self.app = Application.objects.create(name=generate_id(), slug=\"test\")\n+\n+    def test_pkce_missing_in_token(self):\n+        \"\"\"Test full with pkce\"\"\"\n+        flow = create_test_flow()\n+        provider = OAuth2Provider.objects.create(\n+            name=generate_id(),\n+            client_id=\"test\",\n+            authorization_flow=flow,\n+            redirect_uris=\"foo://localhost\",\n+            access_code_validity=\"seconds=100\",\n+        )\n+        Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n+        state = generate_id()\n+        user = create_test_admin_user()\n+        self.client.force_login(user)\n+        challenge = generate_id()\n+        header = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()\n+        # Step 1, initiate params and get redirect to flow\n+        self.client.get(\n+            reverse(\"authentik_providers_oauth2:authorize\"),\n+            data={\n+                \"response_type\": \"code\",\n+                \"client_id\": \"test\",\n+                \"state\": state,\n+                \"redirect_uri\": \"foo://localhost\",\n+                \"code_challenge\": challenge,\n+                \"code_challenge_method\": \"S256\",\n+            },\n+        )\n+        response = self.client.get(\n+            reverse(\"authentik_api:flow-executor\", kwargs={\"flow_slug\": flow.slug}),\n+        )\n+        code: AuthorizationCode = AuthorizationCode.objects.filter(user=user).first()\n+        self.assertJSONEqual(\n+            response.content.decode(),\n+            {\n+                \"component\": \"xak-flow-redirect\",\n+                \"type\": ChallengeTypes.REDIRECT.value,\n+                \"to\": f\"foo://localhost?code={code.code}&state={state}\",\n+            },\n+        )\n+        response = self.client.post(\n+            reverse(\"authentik_providers_oauth2:token\"),\n+            data={\n+                \"grant_type\": GRANT_TYPE_AUTHORIZATION_CODE,\n+                \"code\": code.code,\n+                # Missing the code_verifier here\n+                \"redirect_uri\": \"foo://localhost\",\n+            },\n+            HTTP_AUTHORIZATION=f\"Basic {header}\",\n+        )\n+        self.assertJSONEqual(\n+            response.content,\n+            {\"error\": \"invalid_request\", \"error_description\": \"The request is otherwise malformed\"},\n+        )\n+        self.assertEqual(response.status_code, 400)\n+\n+    def test_pkce_correct_s256(self):\n+        \"\"\"Test full with pkce\"\"\"\n+        flow = create_test_flow()\n+        provider = OAuth2Provider.objects.create(\n+            name=generate_id(),\n+            client_id=\"test\",\n+            authorization_flow=flow,\n+            redirect_uris=\"foo://localhost\",\n+            access_code_validity=\"seconds=100\",\n+        )\n+        Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n+        state = generate_id()\n+        user = create_test_admin_user()\n+        self.client.force_login(user)\n+        verifier = generate_id()\n+        challenge = (\n+            urlsafe_b64encode(sha256(verifier.encode(\"ascii\")).digest())\n+            .decode(\"utf-8\")\n+            .replace(\"=\", \"\")\n+        )\n+        header = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()\n+        # Step 1, initiate params and get redirect to flow\n+        self.client.get(\n+            reverse(\"authentik_providers_oauth2:authorize\"),\n+            data={\n+                \"response_type\": \"code\",\n+                \"client_id\": \"test\",\n+                \"state\": state,\n+                \"redirect_uri\": \"foo://localhost\",\n+                \"code_challenge\": challenge,\n+                \"code_challenge_method\": \"S256\",\n+            },\n+        )\n+        response = self.client.get(\n+            reverse(\"authentik_api:flow-executor\", kwargs={\"flow_slug\": flow.slug}),\n+        )\n+        code: AuthorizationCode = AuthorizationCode.objects.filter(user=user).first()\n+        self.assertJSONEqual(\n+            response.content.decode(),\n+            {\n+                \"component\": \"xak-flow-redirect\",\n+                \"type\": ChallengeTypes.REDIRECT.value,\n+                \"to\": f\"foo://localhost?code={code.code}&state={state}\",\n+            },\n+        )\n+        response = self.client.post(\n+            reverse(\"authentik_providers_oauth2:token\"),\n+            data={\n+                \"grant_type\": GRANT_TYPE_AUTHORIZATION_CODE,\n+                \"code\": code.code,\n+                \"code_verifier\": verifier,\n+                \"redirect_uri\": \"foo://localhost\",\n+            },\n+            HTTP_AUTHORIZATION=f\"Basic {header}\",\n+        )\n+        self.assertEqual(response.status_code, 200)\n+\n+    def test_pkce_correct_plain(self):\n+        \"\"\"Test full with pkce\"\"\"\n+        flow = create_test_flow()\n+        provider = OAuth2Provider.objects.create(\n+            name=generate_id(),\n+            client_id=\"test\",\n+            authorization_flow=flow,\n+            redirect_uris=\"foo://localhost\",\n+            access_code_validity=\"seconds=100\",\n+        )\n+        Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n+        state = generate_id()\n+        user = create_test_admin_user()\n+        self.client.force_login(user)\n+        verifier = generate_id()\n+        header = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()\n+        # Step 1, initiate params and get redirect to flow\n+        self.client.get(\n+            reverse(\"authentik_providers_oauth2:authorize\"),\n+            data={\n+                \"response_type\": \"code\",\n+                \"client_id\": \"test\",\n+                \"state\": state,\n+                \"redirect_uri\": \"foo://localhost\",\n+                \"code_challenge\": verifier,\n+            },\n+        )\n+        response = self.client.get(\n+            reverse(\"authentik_api:flow-executor\", kwargs={\"flow_slug\": flow.slug}),\n+        )\n+        code: AuthorizationCode = AuthorizationCode.objects.filter(user=user).first()\n+        self.assertJSONEqual(\n+            response.content.decode(),\n+            {\n+                \"component\": \"xak-flow-redirect\",\n+                \"type\": ChallengeTypes.REDIRECT.value,\n+                \"to\": f\"foo://localhost?code={code.code}&state={state}\",\n+            },\n+        )\n+        response = self.client.post(\n+            reverse(\"authentik_providers_oauth2:token\"),\n+            data={\n+                \"grant_type\": GRANT_TYPE_AUTHORIZATION_CODE,\n+                \"code\": code.code,\n+                \"code_verifier\": verifier,\n+                \"redirect_uri\": \"foo://localhost\",\n+            },\n+            HTTP_AUTHORIZATION=f\"Basic {header}\",\n+        )\n+        self.assertEqual(response.status_code, 200)"
        },
        {
          "filename": "authentik/providers/oauth2/views/token.py",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -221,7 +221,10 @@ def __post_init_code(self, raw_code: str, request: HttpRequest):\n             raise TokenError(\"invalid_grant\")\n \n         # Validate PKCE parameters.\n-        if self.code_verifier:\n+        if self.authorization_code.code_challenge:\n+            # Authorization code had PKCE but we didn't get one\n+            if not self.code_verifier:\n+                raise TokenError(\"invalid_request\")\n             if self.authorization_code.code_challenge_method == PKCE_METHOD_S256:\n                 new_code_challenge = (\n                     urlsafe_b64encode(sha256(self.code_verifier.encode(\"ascii\")).digest())"
        },
        {
          "filename": "website/docs/security/CVE-2023-48228.md",
          "status": "added",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -0,0 +1,61 @@\n+# CVE-2023-48228\n+\n+_Reported by [@Sapd](https://github.com/Sapd)_\n+\n+## OAuth2: Insufficient PKCE check\n+\n+### Summary\n+\n+When initialising a OAuth2 flow with a `code_challenge` and `code_method` (thus requesting PKCE), the SSO provider (authentik) **must** check if there is a matching **and** existing `code_verifier` during the token step.\n+\n+authentik checks if the contents of code*verifier is matching \\*\\*\\_ONLY*\\*\\* when it is provided. When it is left out completely, authentik simply accepts the token request with out it; even when the flow was started with a `code_challenge`.\n+\n+### Patches\n+\n+authentik 2023.8.5 and 2023.10.4 fix this issue.\n+\n+### Details\n+\n+The `code_verifier` is only checked when the user provides it. Note that in line 209 there is a check if the code_parameter is left out. But there is no check if the PKCE parameter simply was omitted WHEN the request was started with a `code_challenge_method`.\n+\n+This oversight likely did not stem from a coding error but from a misinterpretation of the RFC, where the backward compatibility section may be somewhat confusing.\n+https://datatracker.ietf.org/doc/html/rfc7636#section-4.5\n+RFC7636 explicitly says in Section 4.5:\n+\n+> The \"code_challenge_method\" is bound to the Authorization Code when\n+> the Authorization Code is issued. That is the method that the token\n+> endpoint MUST use to verify the \"code_verifier\".\n+\n+Section 5, Compatibility\n+\n+> Server implementations of this specification MAY accept OAuth2.0\n+> clients that do not implement this extension. If the \"code_verifier\"\n+> is not received from the client in the Authorization Request, servers\n+> supporting backwards compatibility revert to the OAuth 2.0 [[RFC6749](https://datatracker.ietf.org/doc/html/rfc6749)]\n+> protocol without this extension.\n+\n+Section 5, Compatibility, allows server implementations of this specification to accept OAuth 2.0 clients that do not implement this extension. However, if a `code_verifier` is not received from the client in the Authorization Request, servers that support backward compatibility should revert to the standard OAuth 2.0 protocol sans this extension (including all steps).\n+\n+It should be noted that this does not mean that the `code_verifier` check can be disregarded at any point if the initial request included `code_challenge` or `code_challenge_method`. Since Authentik supports PKCE, it **MUST** verify the code_verifier as described in Section 4.5 **AND** fail if it was not provided.\n+\n+Ofc verification can be skipped if the original authorization request did not invoke PKCE (no `code_challenge_method` and no `code_challenge`).\n+\n+Failure to check the `code_verifier` renders the PKCE flow ineffective. This vulnerability particularly endangers public or hybrid clients, as their `code` is deemed non-confidential.\n+\n+While not explicitly stated in the standard, it is generally recommended that OAuth2 flows accepting public clients should enforce PKCE - at least when redirecting to a non HTTPS URL (like http or an app link).\n+\n+### Impact\n+\n+The vulnerability poses a high risk to both public and hybrid clients.\n+When for example a mobile app implements oauth2, a malicious app can simply also register the same in-app-link (e.g. `mycoolapp://oauth2`) for the redirect callback URL, possibly receiving `code` during callback. With PKCE working, a malicious app would still receive a `code` but the `code` would not work without the correct unhashed code-challenge.\n+This is especially problematic, because authentik claims to support PKCE, and a developer can expect that the proper checks are in place. Note that app-links cannot be protected by HTTPS or similar mechanisms.\n+\n+Note also that this vulnerability poses a threat to confidential clients. Many confidential clients act as a proxy for OAuth2 API requests, typically from mobile apps or single-page applications. These proxies relay `code_challenge`, `code_challenge_method` (in auth request, which most libraries force and provide on default settings) and `code_verifier` in the token request unchanged and supplement the CLIENT_SECRET which only the relay knows. The relay can but does not have to check for an existing `code_verifier` as the standard does not define that PKCE can be ignored on confidential clients during the token request when the client requested PKCE during the authorization request.\n+\n+An attacker could potentially gain full access to the application. If the code grants access to an admin account, the confidentiality, integrity, and availability of that application are compromised.\n+\n+### For more information\n+\n+If you have any questions or comments about this advisory:\n+\n+-   Email us at [security@goauthentik.io](mailto:security@goauthentik.io)"
        },
        {
          "filename": "website/sidebars.js",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -362,6 +362,7 @@ const docsSidebar = {\n             },\n             items: [\n                 \"security/policy\",\n+                \"security/CVE-2023-48228\",\n                 \"security/GHSA-rjvp-29xq-f62w\",\n                 \"security/CVE-2023-39522\",\n                 \"security/CVE-2023-36456\","
        }
      ],
      "file_patterns": {
        "security_files": 3,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7a4293bf178ac7c6a2222593feef560053e16cbc",
            "date": "2025-01-14T12:40:25Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "6e569acd845bbcc79c50f40542bd729dd2243840",
            "date": "2025-01-14T12:40:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "02c69d767f02a9d887a9892128aa8e2e30011c38",
            "date": "2025-01-14T12:39:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1863a9a12bf61d8649918f52354808ab0b2fe246",
            "date": "2025-01-14T05:05:58Z",
            "author_login": "SeeJayEmm"
          },
          {
            "sha": "b981bc5ba1f6d048150e1199b41a506daa890516",
            "date": "2025-01-14T04:34:38Z",
            "author_login": "4d62"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-287",
    "description": "authentik is an open-source identity provider. When initialising a oauth2 flow with a `code_challenge` and `code_method` (thus requesting PKCE), the single sign-on provider (authentik) must check if there is a matching and existing `code_verifier` during the token step. Prior to versions 2023.10.4 and 2023.8.5, authentik checks if the contents of `code_verifier` is matching only when it is provided. When it is left out completely, authentik simply accepts the token request with out it; even when the flow was started with a `code_challenge`. authentik 2023.8.5 and 2023.10.4 fix this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-11-21T21:15:08.477",
    "last_modified": "2024-11-21T08:31:15.303",
    "fix_date": "2023-11-21T17:13:50Z"
  },
  "references": [
    {
      "url": "https://github.com/goauthentik/authentik/blob/dd4e9030b4e667d3720be2feda24c08972602274/authentik/providers/oauth2/views/token.py#L225",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/commit/3af77ab3821fe9c7df8055ba5eade3d1ecea03a6",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/commit/6b9afed21f7c39f171a4a445654cfe415bba37d5",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/commit/b88e39411c12e3f9e04125a7887f12354f760a14",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/pull/7666",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/pull/7668",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/pull/7669",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/releases/tag/version%2F2023.10.4",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/releases/tag/version%2F2023.8.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/security/advisories/GHSA-fm34-v8xq-f2c3",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/blob/dd4e9030b4e667d3720be2feda24c08972602274/authentik/providers/oauth2/views/token.py#L225",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/commit/3af77ab3821fe9c7df8055ba5eade3d1ecea03a6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/commit/6b9afed21f7c39f171a4a445654cfe415bba37d5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/commit/b88e39411c12e3f9e04125a7887f12354f760a14",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/pull/7666",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/pull/7668",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/pull/7669",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/releases/tag/version%2F2023.10.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/releases/tag/version%2F2023.8.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/goauthentik/authentik/security/advisories/GHSA-fm34-v8xq-f2c3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:39.277329",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "authentik",
    "owner": "goauthentik",
    "created_at": "2019-12-30T09:19:48Z",
    "updated_at": "2025-01-14T12:40:29Z",
    "pushed_at": "2025-01-14T13:17:29Z",
    "size": 348330,
    "stars": 14458,
    "forks": 984,
    "open_issues": 728,
    "watchers": 14458,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 3995415,
      "TypeScript": 2892221,
      "Go": 308962,
      "MDX": 124483,
      "JavaScript": 69953,
      "HTML": 24617,
      "Rust": 22748,
      "CSS": 19762,
      "Dockerfile": 15501,
      "Makefile": 9222,
      "Shell": 7042,
      "PHP": 1149
    },
    "commit_activity": {
      "total_commits_last_year": 3169,
      "avg_commits_per_week": 60.94230769230769,
      "days_active_last_year": 295
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:32:32.687051"
  }
}