{
  "cve_id": "CVE-2023-48707",
  "github_data": {
    "repository": "codeigniter4/shield",
    "fix_commit": "f77c6ae20275ac1245330a2b9a523bf7e6f6202f",
    "related_commits": [
      "f77c6ae20275ac1245330a2b9a523bf7e6f6202f",
      "f77c6ae20275ac1245330a2b9a523bf7e6f6202f"
    ],
    "patch_url": "https://github.com/codeigniter4/shield/commit/f77c6ae20275ac1245330a2b9a523bf7e6f6202f.patch",
    "fix_commit_details": {
      "sha": "f77c6ae20275ac1245330a2b9a523bf7e6f6202f",
      "commit_date": "2023-11-22T23:22:00Z",
      "author": {
        "login": "kenjis",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-v427-c49j-8w6x",
        "length": 122,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 858,
        "additions": 818,
        "deletions": 40
      },
      "files": [
        {
          "filename": "UPGRADING.md",
          "status": "modified",
          "additions": 20,
          "deletions": 1,
          "patch": "@@ -45,9 +45,28 @@ protected function redirectToDeniedUrl(): RedirectResponse\n {\n     return redirect()->to(config('Auth')->groupDeniedRedirect())\n         ->with('error', lang('Auth.notEnoughPrivilege'));\n-} \n+}\n ```\n \n+### Fix to HMAC Secret Key Encryption\n+\n+#### Config\\AuthToken\n+\n+If you are using the HMAC authentication you need to update the encryption settings in **app/Config/AuthToken.php**.\n+You will need to update and set the encryption key in `$hmacEncryptionKeys`. This should be set using **.env** and/or\n+system environment variables. Instructions on how to do that can be found in the\n+[Setting Your Encryption Key](https://codeigniter.com/user_guide/libraries/encryption.html#setting-your-encryption-key)\n+section of the CodeIgniter 4 documentation and in [HMAC SHA256 Token Authenticator](./docs/references/authentication/hmac.md#hmac-secret-key-encryption).\n+\n+You also may wish to adjust the default Driver `$hmacEncryptionDefaultDriver` and the default Digest\n+`$hmacEncryptionDefaultDigest`, these currently default to `'OpenSSL'` and `'SHA512'` respectively.\n+\n+#### Encrypt Existing Keys\n+\n+After updating the key in `$hmacEncryptionKeys` value, you will need to run `php spark shield:hmac encrypt` in order\n+to encrypt any existing HMAC tokens. This only needs to be run if you have existing unencrypted HMAC secretKeys in\n+stored in the database.\n+\n ## Version 1.0.0-beta.6 to 1.0.0-beta.7\n \n ### The minimum CodeIgniter version"
        },
        {
          "filename": "docs/guides/api_hmac_keys.md",
          "status": "modified",
          "additions": 26,
          "deletions": 6,
          "patch": "@@ -15,10 +15,11 @@ API. When making requests using HMAC keys, the token should be included in the `\n     setting the `$authenticatorHeader['hmac']` value in the **app/Config/AuthToken.php** config file.\n \n Tokens are issued with the `generateHmacToken()` method on the user. This returns a\n-`CodeIgniter\\Shield\\Entities\\AccessToken` instance. These shared keys are saved to the database in plain text. The\n-`AccessToken` object returned when you generate it will include a `secret` field which will be the `key` and a `secret2`\n-field that will be the `secretKey`. You should display the `secretKey` to your user once, so they have a chance to copy\n-it somewhere safe, as this is the only time you should reveal this key.\n+`CodeIgniter\\Shield\\Entities\\AccessToken` instance. The `AccessToken` object returned will include a `secret` field\n+which will be the '**key**' and a `rawSecretKey` field that will be the '**secretKey**'. You should display the\n+'**secretKey**' to your user immediately, so they have a chance to copy it somewhere safe, as this is the only time\n+you can reveal this key. The '**key**' and '**secretKey**' are saved to the database. The '**secretKey**' is stored\n+encrypted.\n \n The `generateHmacToken()` method requires a name for the token. These are free strings and are often used to identify\n the user/device the token was generated from/for, like 'Johns MacBook Air'.\n@@ -27,7 +28,7 @@ the user/device the token was generated from/for, like 'Johns MacBook Air'.\n $routes->get('hmac/token', static function () {\n     $token = auth()->user()->generateHmacToken(service('request')->getVar('token_name'));\n \n-    return json_encode(['key' => $token->secret, 'secretKey' => $token->secret2]);\n+    return json_encode(['key' => $token->secret, 'secretKey' => $token->rawSecretKey]);\n });\n ```\n \n@@ -62,7 +63,7 @@ token is granted all access to all scopes. This might be enough for a smaller AP\n \n ```php\n $token = $user->generateHmacToken('token-name', ['users-read']);\n-return json_encode(['key' => $token->secret, 'secretKey' => $token->secret2]);\n+return json_encode(['key' => $token->secret, 'secretKey' => $token->rawSecretKey]);\n ```\n \n !!! note\n@@ -87,6 +88,25 @@ $user->revokeHmacToken($key);\n $user->revokeAllHmacTokens();\n ```\n \n+## HMAC Secret Key Encryption\n+\n+The HMAC Secret Key is stored encrypted. Before you start using HMAC, you will need to set/override the encryption key\n+in `$hmacEncryptionKeys` in **app/Config/AuthToken.php**. This should be set using **.env** and/or system\n+environment variables. Instructions on how to do that can be found in the\n+[Setting Your Encryption Key](https://codeigniter.com/user_guide/libraries/encryption.html#setting-your-encryption-key)\n+section of the CodeIgniter 4 documentation.\n+\n+You will also be able to adjust the default Driver `$hmacEncryptionDefaultDriver` and the default Digest\n+`$hmacEncryptionDefaultDigest`, these default to `'OpenSSL'` and `'SHA512'` respectively.\n+\n+See [HMAC SHA256 Token Authenticator](../references/authentication/hmac.md#hmac-secret-key-encryption) for additional\n+details on setting these values.\n+\n+### Encryption Key Rotation\n+\n+See [HMAC SHA256 Token Authenticator](../references/authentication/hmac.md#hmac-secret-key-encryption) for information on\n+how to set, rotate encryption keys and re-encrypt existing HMAC `'secretKey'` values.\n+\n ## Protecting Routes\n \n The first way to specify which routes are protected is to use the `hmac` controller filter."
        },
        {
          "filename": "docs/references/authentication/hmac.md",
          "status": "modified",
          "additions": 70,
          "deletions": 7,
          "patch": "@@ -7,7 +7,7 @@ access to your API. These keys typically have a very long expiration time, often\n \n These are also suitable for use with mobile applications. In this case, the user would register/sign-in\n with their email/password. The application would create a new access token for them, with a recognizable\n-name, like John's iPhone 12, and return it to the mobile application, where it is stored and used\n+name, like \"John's iPhone 12\", and return it to the mobile application, where it is stored and used\n in all future requests.\n \n !!! note\n@@ -67,19 +67,19 @@ $token = $user->generateHmacToken('Work Laptop');\n ```\n \n This creates the keys/tokens using a cryptographically secure random string. The keys operate as shared keys.\n-This means they are stored as-is in the database. The method returns an instance of\n-`CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken`. The field `secret` is the 'key' the field `secret2` is\n-the shared 'secretKey'. Both are required to when using this authentication method.\n+The '**key**' is stored as plain text in the database, the '**secretKey**' is stored encrypted. The method returns an\n+instance of `CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken`. The field `secret` is the '**key**' the field\n+`rawSecretKey` is the shared '**secretKey**'. Both are required to when using this authentication method.\n \n **The plain text version of these keys should be displayed to the user immediately, so they can copy it for\n-their use.** It is recommended that after that only the 'key' field is displayed to a user.  If a user loses the\n-'secretKey', they should be required to generate a new set of keys to use.\n+their use.** It is recommended that after that only the '**key**' field is displayed to a user. If a user loses the\n+'**secretKey**', they should be required to generate a new set of keys to use.\n \n ```php\n $token = $user->generateHmacToken('Work Laptop');\n \n echo 'Key: ' . $token->secret;\n-echo 'SecretKey: ' . $token->secret2;\n+echo 'SecretKey: ' . $token->rawSecretKey;\n ```\n \n ## Revoking HMAC Keys\n@@ -156,3 +156,66 @@ if ($user->hmacTokenCant('forums.manage')) {\n     // do something....\n }\n ```\n+\n+## HMAC Secret Key Encryption\n+\n+The HMAC Secret Key is stored encrypted. Before you start using HMAC, you will need to set/override the encryption key\n+in `$hmacEncryptionKeys` in **app/Config/AuthToken.php**. This should be set using **.env** and/or system\n+environment variables. Instructions on how to do that can be found in the\n+[Setting Your Encryption Key](https://codeigniter.com/user_guide/libraries/encryption.html#setting-your-encryption-key)\n+section of the CodeIgniter 4 documentation.\n+\n+You will also be able to adjust the default Driver `$hmacEncryptionDefaultDriver` and the default Digest\n+`$hmacEncryptionDefaultDigest`, these default to `'OpenSSL'` and `'SHA512'` respectively. These can also be\n+overridden for an individual key by including them in the keys array.\n+\n+```php\n+public $hmacEncryptionKeys = [\n+    'k1' => [\n+        'key' => 'hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7',\n+    ],\n+];\n+\n+public string $hmacEncryptionCurrentKey    = 'k1';\n+public string $hmacEncryptionDefaultDriver = 'OpenSSL';\n+public string $hmacEncryptionDefaultDigest = 'SHA512';\n+```\n+\n+When it is time to update your encryption keys you will need to add an additional key to the above\n+`$hmacEncryptionKeys` array. Then adjust the `$hmacEncryptionCurrentKey` to point at the new key.  After the new\n+encryption key is in place, run `php spark shield:hmac reencrypt` to re-encrypt all existing keys with the new\n+encryption key.  You will need to leave the old key in the array as it will be used read the existing 'Secret Keys'\n+during re-encryption.\n+\n+```php\n+public $hmacEncryptionKeys = [\n+    'k1' => [\n+        'key' => 'hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7',\n+    ],\n+    'k2' => [\n+        'key'    => 'hex2bin:451df599363b19be1434605fff8556a0bbfc50bede1bb33793dcde4d97fce4b0',\n+        'digest' => 'SHA256',\n+    ],\n+];\n+\n+public string $hmacEncryptionCurrentKey    = 'k2';\n+public string $hmacEncryptionDefaultDriver = 'OpenSSL';\n+public string $hmacEncryptionDefaultDigest = 'SHA512';\n+\n+```\n+\n+```console\n+php spark shield:hmac reencrypt\n+```\n+\n+You can (and should) set these values using environment variable and/or the **.env** file. To do this you will need to set\n+the values as JSON strings:\n+\n+```text\n+authtoken.hmacEncryptionKeys = '{\"k1\":{\"key\":\"hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7\"},\"k2\":{\"key\":\"hex2bin:451df599363b19be1434605fff8556a0bbfc50bede1bb33793dcde4d97fce4b0\"}}'\n+authtoken.hmacEncryptionCurrentKey = k2\n+```\n+\n+Depending on the set length of the Secret Key and the type of encryption used, it is possible for the encrypted value to\n+exceed the database column character limit of 255 characters. If this happens, creation of a new HMAC identity will\n+throw a `RuntimeException`."
        },
        {
          "filename": "phpunit.xml.dist",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -93,7 +93,10 @@\n \t\t<!-- https://getcomposer.org/xdebug -->\n \t\t<env name=\"COMPOSER_DISABLE_XDEBUG_WARN\" value=\"1\"/>\n \n-\t\t<!-- Database configuration -->\n+        <!-- Default HMAC encryption key -->\n+        <env name=\"authtoken.hmacEncryptionKeys\" value=\"{&quot;k1&quot;:{&quot;key&quot;:&quot;hex2bin:178ed94fd0b6d57dd31dd6b22fc601fab8ad191efac165a5f3f30a8ac09d813d&quot;},&quot;k2&quot;:{&quot;key&quot;:&quot;hex2bin:b0ab85bd0320824c496db2f40eb47c8712a6dfcfdf99b805988e22bdea6b9203&quot;}}\"/>\n+\n+        <!-- Database configuration -->\n \t\t<env name=\"database.tests.strictOn\" value=\"true\"/>\n \t\t<!-- Uncomment to use alternate testing database configuration\n \t\t<env name=\"database.tests.hostname\" value=\"localhost\"/>"
        },
        {
          "filename": "src/Authentication/Authenticators/HmacSha256.php",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -17,6 +17,7 @@\n use CodeIgniter\\I18n\\Time;\n use CodeIgniter\\Shield\\Authentication\\AuthenticationException;\n use CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\n+use CodeIgniter\\Shield\\Authentication\\HMAC\\HmacEncrypter;\n use CodeIgniter\\Shield\\Config\\Auth;\n use CodeIgniter\\Shield\\Entities\\User;\n use CodeIgniter\\Shield\\Exceptions\\InvalidArgumentException;\n@@ -159,8 +160,11 @@ public function check(array $credentials): Result\n             ]);\n         }\n \n+        $encrypter = new HmacEncrypter();\n+        $secretKey = $encrypter->decrypt($token->secret2);\n+\n         // Check signature...\n-        $hash = hash_hmac('sha256', $credentials['body'], $token->secret2);\n+        $hash = hash_hmac('sha256', $credentials['body'], $secretKey);\n         if ($hash !== $signature) {\n             return new Result([\n                 'success' => false,"
        },
        {
          "filename": "src/Authentication/HMAC/HmacEncrypter.php",
          "status": "added",
          "additions": 153,
          "deletions": 0,
          "patch": "@@ -0,0 +1,153 @@\n+<?php\n+\n+declare(strict_types=1);\n+\n+/**\n+ * This file is part of CodeIgniter Shield.\n+ *\n+ * (c) CodeIgniter Foundation <admin@codeigniter.com>\n+ *\n+ * For the full copyright and license information, please view\n+ * the LICENSE file that was distributed with this source code.\n+ */\n+\n+namespace CodeIgniter\\Shield\\Authentication\\HMAC;\n+\n+use CodeIgniter\\Encryption\\EncrypterInterface;\n+use CodeIgniter\\Encryption\\Exceptions\\EncryptionException;\n+use CodeIgniter\\Shield\\Auth;\n+use CodeIgniter\\Shield\\Config\\AuthToken;\n+use CodeIgniter\\Shield\\Exceptions\\RuntimeException;\n+use Config\\Encryption;\n+use Config\\Services;\n+use Exception;\n+\n+/**\n+ * HMAC Encrypter class\n+ *\n+ * This class handles the setup and configuration of the HMAC Encryption\n+ */\n+class HmacEncrypter\n+{\n+    /**\n+     * Codeigniter Encrypter\n+     *\n+     * @var array<string, EncrypterInterface>\n+     */\n+    private array $encrypter;\n+\n+    /**\n+     * Auth Token config\n+     */\n+    private AuthToken $authConfig;\n+\n+    /**\n+     * Constructor\n+     * Setup encryption configuration\n+     */\n+    public function __construct()\n+    {\n+        $this->authConfig = config('AuthToken');\n+\n+        $this->getEncrypter($this->authConfig->hmacEncryptionCurrentKey);\n+    }\n+\n+    /**\n+     * Decrypt\n+     *\n+     * @param string $encString Encrypted string\n+     *\n+     * @return string Raw decrypted string\n+     *\n+     * @throws EncryptionException\n+     */\n+    public function decrypt(string $encString): string\n+    {\n+        $matches = [];\n+        // check for a match\n+        if (preg_match('/^\\$b6\\$(\\w+?)\\$(.+)\\z/', $encString, $matches) !== 1) {\n+            throw new EncryptionException('Unable to decrypt string');\n+        }\n+\n+        $encrypter = $this->getEncrypter($matches[1]);\n+\n+        return $encrypter->decrypt(base64_decode($matches[2], true));\n+    }\n+\n+    /**\n+     * Encrypt\n+     *\n+     * @param string $rawString Raw string to encrypt\n+     *\n+     * @return string Encrypted string\n+     *\n+     * @throws EncryptionException\n+     * @throws RuntimeException\n+     */\n+    public function encrypt(string $rawString): string\n+    {\n+        $currentKey = $this->authConfig->hmacEncryptionCurrentKey;\n+\n+        $encryptedString = '$b6$' . $currentKey . '$' . base64_encode($this->encrypter[$currentKey]->encrypt($rawString));\n+\n+        if (strlen($encryptedString) > $this->authConfig->secret2StorageLimit) {\n+            throw new RuntimeException('Encrypted key too long. Unable to store value.');\n+        }\n+\n+        return $encryptedString;\n+    }\n+\n+    /**\n+     * Check if the string already encrypted\n+     */\n+    public function isEncrypted(string $string): bool\n+    {\n+        return preg_match('/^\\$b6\\$/', $string) === 1;\n+    }\n+\n+    /**\n+     * Check if the string already encrypted with the Current Set Key\n+     */\n+    public function isEncryptedWithCurrentKey(string $string): bool\n+    {\n+        $currentKey = $this->authConfig->hmacEncryptionCurrentKey;\n+\n+        return preg_match('/^\\$b6\\$' . $currentKey . '\\$/', $string) === 1;\n+    }\n+\n+    /**\n+     * Generate Key\n+     *\n+     * @return string Secret Key in base64 format\n+     *\n+     * @throws Exception\n+     */\n+    public function generateSecretKey(): string\n+    {\n+        return base64_encode(random_bytes($this->authConfig->hmacSecretKeyByteSize));\n+    }\n+\n+    /**\n+     * Retrieve encrypter for selected key\n+     *\n+     * @param string $encrypterKey Index Key for selected Encrypter\n+     */\n+    private function getEncrypter(string $encrypterKey): EncrypterInterface\n+    {\n+        if (! isset($this->encrypter[$encrypterKey])) {\n+            if (! isset($this->authConfig->hmacEncryptionKeys[$encrypterKey]['key'])) {\n+                throw new RuntimeException('Encryption key does not exist.');\n+            }\n+\n+            $config = new Encryption();\n+\n+            $config->key    = $this->authConfig->hmacEncryptionKeys[$encrypterKey]['key'];\n+            $config->driver = $this->authConfig->hmacEncryptionKeys[$encrypterKey]['driver'] ?? $this->authConfig->hmacEncryptionDefaultDriver;\n+            $config->digest = $this->authConfig->hmacEncryptionKeys[$encrypterKey]['digest'] ?? $this->authConfig->hmacEncryptionDefaultDigest;\n+\n+            $this->encrypter[$encrypterKey] = Services::encrypter($config);\n+        }\n+\n+        return $this->encrypter[$encrypterKey];\n+    }\n+}"
        },
        {
          "filename": "src/Commands/Hmac.php",
          "status": "added",
          "additions": 209,
          "deletions": 0,
          "patch": "@@ -0,0 +1,209 @@\n+<?php\n+\n+declare(strict_types=1);\n+\n+/**\n+ * This file is part of CodeIgniter Shield.\n+ *\n+ * (c) CodeIgniter Foundation <admin@codeigniter.com>\n+ *\n+ * For the full copyright and license information, please view\n+ * the LICENSE file that was distributed with this source code.\n+ */\n+\n+namespace CodeIgniter\\Shield\\Commands;\n+\n+use CodeIgniter\\Shield\\Authentication\\HMAC\\HmacEncrypter;\n+use CodeIgniter\\Shield\\Commands\\Exceptions\\BadInputException;\n+use CodeIgniter\\Shield\\Exceptions\\RuntimeException;\n+use CodeIgniter\\Shield\\Models\\UserIdentityModel;\n+use Exception;\n+use ReflectionException;\n+\n+class Hmac extends BaseCommand\n+{\n+    /**\n+     * The Command's name\n+     *\n+     * @var string\n+     */\n+    protected $name = 'shield:hmac';\n+\n+    /**\n+     * the Command's short description\n+     *\n+     * @var string\n+     */\n+    protected $description = 'Encrypt/Decrypt secretKey for HMAC tokens.';\n+\n+    /**\n+     * the Command's usage\n+     *\n+     * @var string\n+     */\n+    protected $usage = <<<'EOL'\n+        shield:hmac <action>\n+            shield:hmac reencrypt\n+            shield:hmac encrypt\n+            shield:hmac decrypt\n+\n+            The reencrypt command should be used when rotating the encryption keys.\n+            The encrypt command should only be run on existing raw secret keys (extremely rare).\n+        EOL;\n+\n+    /**\n+     * the Command's Arguments\n+     *\n+     * @var array\n+     */\n+    protected $arguments = [\n+        'action' => <<<'EOL'\n+                reencrypt: Re-encrypts all HMAC Secret Keys on encryption key rotation\n+                encrypt: Encrypt all raw HMAC Secret Keys\n+                decrypt: Decrypt all encrypted HMAC Secret Keys\n+            EOL,\n+    ];\n+\n+    /**\n+     * HMAC Encrypter Object\n+     */\n+    private HmacEncrypter $encrypter;\n+\n+    /**\n+     * the Command's Options\n+     *\n+     * @var array\n+     */\n+    protected $options = [];\n+\n+    /**\n+     * Run Encryption Methods\n+     */\n+    public function run(array $params): int\n+    {\n+        $action = $params[0] ?? null;\n+\n+        $this->encrypter = new HmacEncrypter();\n+\n+        try {\n+            switch ($action) {\n+                case 'encrypt':\n+                    $this->encrypt();\n+                    break;\n+\n+                case 'decrypt':\n+                    $this->decrypt();\n+                    break;\n+\n+                case 'reencrypt':\n+                    $this->reEncrypt();\n+                    break;\n+\n+                default:\n+                    throw new BadInputException('Unrecognized Command');\n+            }\n+        } catch (Exception $e) {\n+            $this->write($e->getMessage(), 'red');\n+\n+            return EXIT_ERROR;\n+        }\n+\n+        return EXIT_SUCCESS;\n+    }\n+\n+    /**\n+     * Encrypt all Raw HMAC Secret Keys\n+     *\n+     * @throws ReflectionException\n+     */\n+    public function encrypt(): void\n+    {\n+        $uIdModel    = new UserIdentityModel();\n+        $uIdModelSub = new UserIdentityModel(); // For saving.\n+        $encrypter   = $this->encrypter;\n+\n+        $that = $this;\n+\n+        $uIdModel->where('type', 'hmac_sha256')->orderBy('id')->chunk(\n+            100,\n+            static function ($identity) use ($uIdModelSub, $encrypter, $that): void {\n+                if ($encrypter->isEncrypted($identity->secret2)) {\n+                    $that->write('id: ' . $identity->id . ', already encrypted, skipped.');\n+\n+                    return;\n+                }\n+\n+                try {\n+                    $identity->secret2 = $encrypter->encrypt($identity->secret2);\n+                    $uIdModelSub->save($identity);\n+\n+                    $that->write('id: ' . $identity->id . ', encrypted.');\n+                } catch (RuntimeException $e) {\n+                    $that->error('id: ' . $identity->id . ', ' . $e->getMessage());\n+                }\n+            }\n+        );\n+    }\n+\n+    /**\n+     * Decrypt all encrypted HMAC Secret Keys\n+     *\n+     * @throws ReflectionException\n+     */\n+    public function decrypt(): void\n+    {\n+        $uIdModel    = new UserIdentityModel();\n+        $uIdModelSub = new UserIdentityModel(); // For saving.\n+        $encrypter   = $this->encrypter;\n+\n+        $that = $this;\n+\n+        $uIdModel->where('type', 'hmac_sha256')->orderBy('id')->chunk(\n+            100,\n+            static function ($identity) use ($uIdModelSub, $encrypter, $that): void {\n+                if (! $encrypter->isEncrypted($identity->secret2)) {\n+                    $that->write('id: ' . $identity->id . ', not encrypted, skipped.');\n+\n+                    return;\n+                }\n+\n+                $identity->secret2 = $encrypter->decrypt($identity->secret2);\n+                $uIdModelSub->save($identity);\n+\n+                $that->write('id: ' . $identity->id . ', decrypted.');\n+            }\n+        );\n+    }\n+\n+    /**\n+     * Re-encrypt all encrypted HMAC Secret Keys from existing/deprecated\n+     * encryption key to new encryption key.\n+     *\n+     * @throws ReflectionException\n+     */\n+    public function reEncrypt(): void\n+    {\n+        $uIdModel    = new UserIdentityModel();\n+        $uIdModelSub = new UserIdentityModel(); // For saving.\n+        $encrypter   = $this->encrypter;\n+\n+        $that = $this;\n+\n+        $uIdModel->where('type', 'hmac_sha256')->orderBy('id')->chunk(\n+            100,\n+            static function ($identity) use ($uIdModelSub, $encrypter, $that): void {\n+                if ($encrypter->isEncryptedWithCurrentKey($identity->secret2)) {\n+                    $that->write('id: ' . $identity->id . ', already encrypted with current key, skipped.');\n+\n+                    return;\n+                }\n+\n+                $identity->secret2 = $encrypter->decrypt($identity->secret2);\n+                $identity->secret2 = $encrypter->encrypt($identity->secret2);\n+                $uIdModelSub->save($identity);\n+\n+                $that->write('id: ' . $identity->id . ', Re-encrypted.');\n+            }\n+        );\n+    }\n+}"
        },
        {
          "filename": "src/Commands/Setup.php",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -140,9 +140,8 @@ private function publishConfigAuthToken(): void\n     {\n         $file     = 'Config/AuthToken.php';\n         $replaces = [\n-            'namespace CodeIgniter\\Shield\\Config'  => 'namespace Config',\n-            'use CodeIgniter\\\\Config\\\\BaseConfig;' => 'use CodeIgniter\\\\Shield\\\\Config\\\\AuthToken as ShieldAuthToken;',\n-            'extends BaseConfig'                   => 'extends ShieldAuthToken',\n+            'namespace CodeIgniter\\Shield\\Config;' => \"namespace Config;\\n\\nuse CodeIgniter\\\\Shield\\\\Config\\\\AuthToken as ShieldAuthToken;\",\n+            'extends BaseAuthToken'                => 'extends ShieldAuthToken',\n         ];\n \n         $this->copyAndReplace($file, $replaces);"
        },
        {
          "filename": "src/Config/AuthToken.php",
          "status": "modified",
          "additions": 73,
          "deletions": 3,
          "patch": "@@ -13,12 +13,10 @@\n \n namespace CodeIgniter\\Shield\\Config;\n \n-use CodeIgniter\\Config\\BaseConfig;\n-\n /**\n  * Configuration for Token Auth and HMAC Auth\n  */\n-class AuthToken extends BaseConfig\n+class AuthToken extends BaseAuthToken\n {\n     /**\n      * --------------------------------------------------------------------\n@@ -55,6 +53,14 @@ class AuthToken extends BaseConfig\n      */\n     public int $unusedTokenLifetime = YEAR;\n \n+    /**\n+     * --------------------------------------------------------------------\n+     * Secret2 storage character limit\n+     * --------------------------------------------------------------------\n+     * Database size limit for the identities 'secret2' field.\n+     */\n+    public int $secret2StorageLimit = 255;\n+\n     /**\n      * --------------------------------------------------------------------\n      * HMAC secret key byte size\n@@ -63,4 +69,68 @@ class AuthToken extends BaseConfig\n      * HMAC SHA256 byte size\n      */\n     public int $hmacSecretKeyByteSize = 32;\n+\n+    /**\n+     * --------------------------------------------------------------------\n+     * HMAC encryption Keys\n+     * --------------------------------------------------------------------\n+     * This sets the key to be used when encrypting a user's HMAC Secret Key.\n+     *\n+     * 'keys' is an array of keys which will facilitate key rotation. Valid\n+     *  keyTitles must include only [a-zA-Z0-9_] and should be kept to a\n+     *  max of 8 characters.\n+     *\n+     * Each keyTitle is an associative array containing the required 'key'\n+     *  value, and the optional 'driver' and 'digest' values. If the\n+     *  'driver' and 'digest' values are not specified, the default 'driver'\n+     *  and 'digest' values will be used.\n+     *\n+     * Old keys will are used to decrypt existing Secret Keys. It is encouraged\n+     *  to run 'php spark shield:hmac reencrypt' to update existing Secret\n+     *  Key encryptions.\n+     *\n+     * @see https://codeigniter.com/user_guide/libraries/encryption.html\n+     *\n+     * @var array<string, array{key: string, driver?: string, digest?: string}>|string\n+     *\n+     * NOTE: The value becomes temporarily a string when setting value as JSON\n+     *       from environment variable.\n+     *\n+     * [key_name => ['key' => key_value]]\n+     * or [key_name => ['key' => key_value, 'driver' => driver, 'digest' => digest]]\n+     */\n+    public $hmacEncryptionKeys = [\n+        'k1' => [\n+            'key' => '',\n+        ],\n+    ];\n+\n+    /**\n+     * --------------------------------------------------------------------\n+     * HMAC Current Encryption Key Selector\n+     * --------------------------------------------------------------------\n+     * This specifies which of the encryption keys should be used.\n+     */\n+    public string $hmacEncryptionCurrentKey = 'k1';\n+\n+    /**\n+     * --------------------------------------------------------------------\n+     * HMAC Encryption Key Driver\n+     * --------------------------------------------------------------------\n+     * This specifies which of the encryption drivers should be used.\n+     *\n+     * Available drivers:\n+     *     - OpenSSL\n+     *     - Sodium\n+     */\n+    public string $hmacEncryptionDefaultDriver = 'OpenSSL';\n+\n+    /**\n+     * --------------------------------------------------------------------\n+     * HMAC Encryption Key Driver\n+     * --------------------------------------------------------------------\n+     * THis specifies the type of encryption to be used.\n+     *     e.g. 'SHA512' or 'SHA256'.\n+     */\n+    public string $hmacEncryptionDefaultDigest = 'SHA512';\n }"
        },
        {
          "filename": "src/Config/BaseAuthToken.php",
          "status": "added",
          "additions": 58,
          "deletions": 0,
          "patch": "@@ -0,0 +1,58 @@\n+<?php\n+\n+declare(strict_types=1);\n+\n+/**\n+ * This file is part of CodeIgniter Shield.\n+ *\n+ * (c) CodeIgniter Foundation <admin@codeigniter.com>\n+ *\n+ * For the full copyright and license information, please view\n+ * the LICENSE file that was distributed with this source code.\n+ */\n+\n+namespace CodeIgniter\\Shield\\Config;\n+\n+use CodeIgniter\\Config\\BaseConfig;\n+\n+class BaseAuthToken extends BaseConfig\n+{\n+    /**\n+     * List of HMAC Encryption Keys\n+     *\n+     * @var array<string, array{key: string, driver?: string, digest?: string}>|string\n+     */\n+    public $hmacEncryptionKeys;\n+\n+    /**\n+     * AuthToken Config Constructor\n+     */\n+    public function __construct()\n+    {\n+        parent::__construct();\n+\n+        if (is_string($this->hmacEncryptionKeys)) {\n+            $array = json_decode($this->hmacEncryptionKeys, true);\n+            if (is_array($array)) {\n+                $this->hmacEncryptionKeys = $array;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Override parent initEnvValue() to allow for direct setting to array properties values from ENV\n+     *\n+     * In order to set array properties via ENV vars we need to set the property to a string value first.\n+     *\n+     * @param mixed $property\n+     */\n+    protected function initEnvValue(&$property, string $name, string $prefix, string $shortPrefix): void\n+    {\n+        // if attempting to set property from ENV, first set to empty string\n+        if ($name === 'hmacEncryptionKeys' && $this->getEnvValue($name, $prefix, $shortPrefix) !== null) {\n+            $property = '';\n+        }\n+\n+        parent::initEnvValue($property, $name, $prefix, $shortPrefix);\n+    }\n+}"
        },
        {
          "filename": "src/Models/UserIdentityModel.php",
          "status": "modified",
          "additions": 12,
          "deletions": 2,
          "patch": "@@ -17,6 +17,7 @@\n use CodeIgniter\\Shield\\Authentication\\Authenticators\\AccessTokens;\n use CodeIgniter\\Shield\\Authentication\\Authenticators\\HmacSha256;\n use CodeIgniter\\Shield\\Authentication\\Authenticators\\Session;\n+use CodeIgniter\\Shield\\Authentication\\HMAC\\HmacEncrypter;\n use CodeIgniter\\Shield\\Authentication\\Passwords;\n use CodeIgniter\\Shield\\Entities\\AccessToken;\n use CodeIgniter\\Shield\\Entities\\User;\n@@ -251,20 +252,29 @@ public function generateHmacToken(User $user, string $name, array $scopes = ['*'\n     {\n         $this->checkUserId($user);\n \n+        $encrypter    = new HmacEncrypter();\n+        $rawSecretKey = $encrypter->generateSecretKey();\n+        $secretKey    = $encrypter->encrypt($rawSecretKey);\n+\n         $return = $this->insert([\n             'type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n             'user_id' => $user->id,\n             'name'    => $name,\n             'secret'  => bin2hex(random_bytes(16)), // Key\n-            'secret2' => bin2hex(random_bytes(config('AuthToken')->hmacSecretKeyByteSize)), // Secret Key\n+            'secret2' => $secretKey,\n             'extra'   => serialize($scopes),\n         ]);\n \n         $this->checkQueryReturn($return);\n \n-        return $this\n+        /** @var AccessToken $token */\n+        $token = $this\n             ->asObject(AccessToken::class)\n             ->find($this->getInsertID());\n+\n+        $token->rawSecretKey = $rawSecretKey;\n+\n+        return $token;\n     }\n \n     /**"
        },
        {
          "filename": "tests/Authentication/Authenticators/HmacAuthenticatorTest.php",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -109,7 +109,7 @@ public function testLoginByIdWithToken(): void\n         $user  = fake(UserModel::class);\n         $token = $user->generateHmacToken('foo');\n \n-        $rawToken = $this->generateRawHeaderToken($token->secret, $token->secret2, 'bar');\n+        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n         $this->setRequestHeader($rawToken);\n \n         $this->auth->loginById($user->id);\n@@ -126,7 +126,7 @@ public function testLoginByIdWithMultipleTokens(): void\n         $token1 = $user->generateHmacToken('foo');\n         $user->generateHmacToken('bar');\n \n-        $this->setRequestHeader($this->generateRawHeaderToken($token1->secret, $token1->secret2, 'bar'));\n+        $this->setRequestHeader($this->generateRawHeaderToken($token1->secret, $token1->rawSecretKey, 'bar'));\n \n         $this->auth->loginById($user->id);\n \n@@ -170,7 +170,7 @@ public function testCheckOldToken(): void\n         $identities->save($token);\n \n         $result = $this->auth->check([\n-            'token' => $this->generateRawHeaderToken($token->secret, $token->secret2, 'bar'),\n+            'token' => $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar'),\n             'body'  => 'bar',\n         ]);\n \n@@ -190,7 +190,7 @@ public function testCheckSuccess(): void\n             'last_used_at' => null,\n         ]);\n \n-        $rawToken = $this->generateRawHeaderToken($token->secret, $token->secret2, 'bar');\n+        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n \n         $result = $this->auth->check([\n             'token' => $rawToken,\n@@ -220,7 +220,7 @@ public function testCheckBadToken(): void\n             'last_used_at' => null,\n         ]);\n \n-        $rawToken = $this->generateRawHeaderToken($token->secret, $token->secret2, 'foobar');\n+        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'foobar');\n \n         $result = $this->auth->check([\n             'token' => $rawToken,\n@@ -254,7 +254,7 @@ public function testAttemptSuccess(): void\n         /** @var User $user */\n         $user     = fake(UserModel::class);\n         $token    = $user->generateHmacToken('foo');\n-        $rawToken = $this->generateRawHeaderToken($token->secret, $token->secret2, 'bar');\n+        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n         $this->setRequestHeader($rawToken);\n \n         $result = $this->auth->attempt([\n@@ -294,7 +294,7 @@ public function testAttemptBanned(): void\n         $user->ban('Test ban.');\n \n         $token    = $user->generateHmacToken('foo');\n-        $rawToken = $this->generateRawHeaderToken($token->secret, $token->secret2, 'bar');\n+        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n         $this->setRequestHeader($rawToken);\n \n         $result = $this->auth->attempt(["
        },
        {
          "filename": "tests/Authentication/Filters/HmacFilterTest.php",
          "status": "modified",
          "additions": 7,
          "deletions": 7,
          "patch": "@@ -47,7 +47,7 @@ public function testFilterSuccess(): void\n         $user  = fake(UserModel::class);\n         $token = $user->generateHmacToken('foo');\n \n-        $rawToken = $this->generateRawHeaderToken($token->secret, $token->secret2, '');\n+        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, '');\n         $result   = $this->withHeaders(['Authorization' => 'HMAC-SHA256  ' . $rawToken])\n             ->get('protected-route');\n \n@@ -68,7 +68,7 @@ public function testFilterInvalidSignature(): void\n         $user  = fake(UserModel::class);\n         $token = $user->generateHmacToken('foo');\n \n-        $result = $this->withHeaders(['Authorization' => 'HMAC-SHA256  ' . $this->generateRawHeaderToken($token->secret, $token->secret2, 'bar')])\n+        $result = $this->withHeaders(['Authorization' => 'HMAC-SHA256  ' . $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar')])\n             ->get('protected-route');\n \n         $result->assertStatus(401);\n@@ -80,7 +80,7 @@ public function testRecordActiveDate(): void\n         $user  = fake(UserModel::class);\n         $token = $user->generateHmacToken('foo');\n \n-        $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token->secret, $token->secret2, '')])\n+        $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, '')])\n             ->get('protected-route');\n \n         // Last Active should be greater than 'updated_at' column\n@@ -97,15 +97,15 @@ public function testFiltersProtectsWithScopes(): void\n         $token2 = $user2->generateHmacToken('foo', ['users-write']);\n \n         // User 1 should be able to access the route\n-        $result1 = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token1->secret, $token1->secret2, '')])\n+        $result1 = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token1->secret, $token1->rawSecretKey, '')])\n             ->get('protected-user-route');\n \n         $result1->assertStatus(200);\n         // Last Active should be greater than 'updated_at' column\n         $this->assertGreaterThan(auth('hmac')->user()->updated_at, auth('hmac')->user()->last_active);\n \n         // User 2 should NOT be able to access the route\n-        $result2 = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token2->secret, $token2->secret2, '')])\n+        $result2 = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token2->secret, $token2->rawSecretKey, '')])\n             ->get('protected-user-route');\n \n         $result2->assertStatus(401);\n@@ -120,7 +120,7 @@ public function testBlocksInactiveUsers(): void\n         // Activation only required with email activation\n         setting('Auth.actions', ['register' => null]);\n \n-        $result = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token->secret, $token->secret2, '')])\n+        $result = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, '')])\n             ->get('protected-route');\n \n         $result->assertStatus(200);\n@@ -129,7 +129,7 @@ public function testBlocksInactiveUsers(): void\n         // Now require user activation and try again\n         setting('Auth.actions', ['register' => '\\CodeIgniter\\Shield\\Authentication\\Actions\\EmailActivator']);\n \n-        $result = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token->secret, $token->secret2, '')])\n+        $result = $this->withHeaders(['Authorization' => 'HMAC-SHA256 ' . $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, '')])\n             ->get('protected-route');\n \n         $result->assertStatus(403);"
        },
        {
          "filename": "tests/Authentication/HasHmacTokensTest.php",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -43,6 +43,7 @@ public function testGenerateHmacToken(): void\n \n         $this->assertIsString($token->secret);\n         $this->assertIsString($token->secret2);\n+        $this->assertIsString($token->rawSecretKey);\n \n         // All scopes are assigned by default via wildcard\n         $this->assertSame(['*'], $token->scopes);\n@@ -56,12 +57,12 @@ public function testHmacTokens(): void\n         // Give the user a couple of access tokens\n         $token1 = fake(\n             UserIdentityModel::class,\n-            ['user_id' => $this->user->id, 'type' => 'hmac_sha256', 'secret' => 'key1', 'secret2' => 'secretKey1']\n+            ['user_id' => $this->user->id, 'type' => 'hmac_sha256', 'secret' => 'key1', 'secret2' => 'd862cd9ddc23e960ca6d45a3e0b64c7509f0c0ef0e5f7b64be8910a6a714c89b83fab95251bbf17f6c84b42c26cf460a28ea969591dc64b1f5c4b323f47615d2e8cbe4c62118001d3274e0f25850b0ac2617bc43119af22c99a1a83072002267177da01f9f37225435e1914be004f4d35a49869b737ed10ab232c1ed1048bb96ef6fb70979dc9c981e17134f4356a938']\n         );\n \n         $token2 = fake(\n             UserIdentityModel::class,\n-            ['user_id' => $this->user->id, 'type' => 'hmac_sha256', 'secret' => 'key2', 'secret2' => 'secretKey2']\n+            ['user_id' => $this->user->id, 'type' => 'hmac_sha256', 'secret' => 'key2', 'secret2' => 'd862cd9ddc23e960ca6d45a3e0b64c7509f0c0ef0e5f7b64be8910a6a714c89b83fab95251bbf17f6c84b42c26cf460a28ea969591dc64b1f5c4b323f47615d2e8cbe4c62118001d3274e0f25850b0ac2617bc43119af22c99a1a83072002267177da01f9f37225435e1914be004f4d35a49869b737ed10ab232c1ed1048bb96ef6fb70979dc9c981e17134f4356a938']\n         );\n \n         $tokens = $this->user->hmacTokens();"
        },
        {
          "filename": "tests/Commands/HmacTest.php",
          "status": "added",
          "additions": 169,
          "deletions": 0,
          "patch": "@@ -0,0 +1,169 @@\n+<?php\n+\n+declare(strict_types=1);\n+\n+/**\n+ * This file is part of CodeIgniter Shield.\n+ *\n+ * (c) CodeIgniter Foundation <admin@codeigniter.com>\n+ *\n+ * For the full copyright and license information, please view\n+ * the LICENSE file that was distributed with this source code.\n+ */\n+\n+namespace Tests\\Commands;\n+\n+use CodeIgniter\\Shield\\Authentication\\HMAC\\HmacEncrypter;\n+use CodeIgniter\\Shield\\Commands\\Hmac;\n+use CodeIgniter\\Shield\\Config\\AuthToken;\n+use CodeIgniter\\Shield\\Entities\\User;\n+use CodeIgniter\\Shield\\Models\\UserIdentityModel;\n+use CodeIgniter\\Shield\\Models\\UserModel;\n+use CodeIgniter\\Shield\\Test\\MockInputOutput;\n+use Tests\\Support\\DatabaseTestCase;\n+\n+/**\n+ * @internal\n+ */\n+final class HmacTest extends DatabaseTestCase\n+{\n+    private ?MockInputOutput $io = null;\n+\n+    public function testEncrypt(): void\n+    {\n+        $idModel = new UserIdentityModel();\n+\n+        /** @var User $user */\n+        $user  = fake(UserModel::class);\n+        $token = $user->generateHmacToken('foo');\n+\n+        $rawSecretKey   = $token->rawSecretKey;\n+        $token->secret2 = $rawSecretKey;\n+\n+        $idModel->save($token);\n+        $tokenCheck = $idModel->find($token->id);\n+\n+        $this->assertSame($rawSecretKey, $tokenCheck->secret2);\n+\n+        $this->setMockIo([]);\n+        $this->assertNotFalse(command('shield:hmac encrypt'));\n+\n+        $tokenCheck = $idModel->find($token->id);\n+\n+        $encrypter    = new HmacEncrypter();\n+        $decryptedKey = $encrypter->decrypt($tokenCheck->secret2);\n+\n+        $this->assertSame($rawSecretKey, $decryptedKey);\n+\n+        // verify that encryption can only happen once\n+        $this->setMockIo([]);\n+        $this->assertNotFalse(command('shield:hmac encrypt'));\n+\n+        $resultsString = trim($this->io->getOutputs());\n+        $this->assertSame('id: 1, already encrypted, skipped.', $resultsString);\n+    }\n+\n+    public function testDecrypt(): void\n+    {\n+        $idModel = new UserIdentityModel();\n+\n+        /** @var User $user */\n+        $user  = fake(UserModel::class);\n+        $token = $user->generateHmacToken('foo');\n+\n+        $rawSecretKey = $token->rawSecretKey;\n+\n+        $this->setMockIo([]);\n+        $this->assertNotFalse(command('shield:hmac decrypt'));\n+\n+        $token->secret2 = $rawSecretKey;\n+\n+        $idModel->save($token);\n+        $tokenCheck = $idModel->find($token->id);\n+\n+        $this->assertSame($rawSecretKey, $tokenCheck->secret2);\n+\n+        // verify that decryption does not run on fields already decrypted\n+        $this->setMockIo([]);\n+        $this->assertNotFalse(command('shield:hmac decrypt'));\n+\n+        $resultsString = trim($this->io->getOutputs());\n+        $this->assertSame('id: 1, not encrypted, skipped.', $resultsString);\n+    }\n+\n+    public function testReEncrypt(): void\n+    {\n+        $idModel = new UserIdentityModel();\n+\n+        // generate first token\n+        /** @var User $user */\n+        $user   = fake(UserModel::class);\n+        $token1 = $user->generateHmacToken('foo');\n+\n+        // update config, rotate keys\n+        /** @var AuthToken $config */\n+        $config = config('AuthToken');\n+\n+        $config->hmacEncryptionCurrentKey = 'k2';\n+\n+        // new key generated with updated encryption\n+        $token2 = $user->generateHmacToken('bar');\n+\n+        $this->setMockIo([]);\n+        $this->assertNotFalse(command('shield:hmac reencrypt'));\n+\n+        $resultsString = $this->io->getOutputs();\n+        $results       = explode(\"\\n\", trim($resultsString));\n+\n+        // verify that only 1 key needed to be re-encrypted\n+        $this->assertCount(2, $results);\n+        $this->assertSame('id: 1, Re-encrypted.', trim($results[0]));\n+        $this->assertSame('id: 2, already encrypted with current key, skipped.', trim($results[1]));\n+\n+        $encrypter = new HmacEncrypter();\n+\n+        $tokenCheck1        = $idModel->find($token1->id);\n+        $descryptSecretKey1 = $encrypter->decrypt($tokenCheck1->secret2);\n+        $this->assertSame($token1->rawSecretKey, $descryptSecretKey1);\n+\n+        $tokenCheck2        = $idModel->find($token2->id);\n+        $descryptSecretKey2 = $encrypter->decrypt($tokenCheck2->secret2);\n+        $this->assertSame($token2->rawSecretKey, $descryptSecretKey2);\n+    }\n+\n+    public function testBadCommand(): void\n+    {\n+        $this->setMockIo([]);\n+        $this->assertNotFalse(command('shield:hmac badcommand'));\n+\n+        $resultsString = $this->stripRedColorCode(trim($this->io->getOutputs()));\n+\n+        $this->assertSame('Unrecognized Command', $resultsString);\n+    }\n+\n+    /**\n+     * Set MockInputOutput and user inputs.\n+     *\n+     * @param list<string> $inputs User inputs\n+     */\n+    private function setMockIo(array $inputs): void\n+    {\n+        $this->io = new MockInputOutput();\n+        $this->io->setInputs($inputs);\n+        Hmac::setInputOutput($this->io);\n+    }\n+\n+    /**\n+     * Strip color from output code\n+     */\n+    private function stripRedColorCode(string $output): string\n+    {\n+        $output = str_replace([\"\\033[0;31m\", \"\\033[0m\"], '', $output);\n+\n+        if (is_windows()) {\n+            $output = str_replace(\"\\r\\n\", \"\\n\", $output);\n+        }\n+\n+        return $output;\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 9,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 12,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b2ddb70df8072591c4c158a2192e3759286f3610",
            "date": "2024-11-18T15:55:57Z",
            "author_login": "datamweb"
          },
          {
            "sha": "9fd9ca3939e7e62e29dff58a0da87edbe25ecc69",
            "date": "2024-11-16T17:39:58Z",
            "author_login": "christianberkman"
          },
          {
            "sha": "031b63759054892a93244492860dc0a85c9757a8",
            "date": "2024-11-08T14:23:00Z",
            "author_login": "samsonasik"
          },
          {
            "sha": "6b43fa9845b02146e91cd2f739ac91c732824858",
            "date": "2024-11-08T14:15:17Z",
            "author_login": "samsonasik"
          },
          {
            "sha": "17d1a498fdb62adacda94a4a791879d2ff0871e6",
            "date": "2024-11-08T14:09:08Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-312",
    "description": "CodeIgniter Shield is an authentication and authorization provider for CodeIgniter 4. The `secretKey` value is an important key for HMAC SHA256 authentication and in affected versions was stored in the database in cleartext form. If a malicious person somehow had access to the data in the database, they could use the key and secretKey for HMAC SHA256 authentication to send requests impersonating that corresponding user. This issue has been addressed in version 1.0.0-beta.8. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-11-24T18:15:07.327",
    "last_modified": "2024-11-21T08:32:18.130",
    "fix_date": "2023-11-22T23:22:00Z"
  },
  "references": [
    {
      "url": "https://github.com/codeigniter4/shield/commit/f77c6ae20275ac1245330a2b9a523bf7e6f6202f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/security/advisories/GHSA-v427-c49j-8w6x",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/commit/f77c6ae20275ac1245330a2b9a523bf7e6f6202f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/codeigniter4/shield/security/advisories/GHSA-v427-c49j-8w6x",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:39.284165",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "shield",
    "owner": "codeigniter4",
    "created_at": "2020-12-30T06:55:29Z",
    "updated_at": "2025-01-13T08:00:48Z",
    "pushed_at": "2024-11-18T15:56:26Z",
    "size": 9749,
    "stars": 372,
    "forks": 132,
    "open_issues": 17,
    "watchers": 372,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "PHP": 865072,
      "Shell": 1111
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:50:28.047582"
  }
}