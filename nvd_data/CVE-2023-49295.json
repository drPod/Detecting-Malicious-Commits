{
  "cve_id": "CVE-2023-49295",
  "github_data": {
    "repository": "quic-go/quic-go",
    "fix_commit": "17fc98c2d81dbe685c19702dc694a9d606ac56dc",
    "related_commits": [
      "17fc98c2d81dbe685c19702dc694a9d606ac56dc",
      "21609ddfeff93668c7625a85eb09f1541fdad965",
      "3a9c18bcd27a01c551ac9bf8bd2b4bded77c189a",
      "554d543b50b917369fb1394cc5396d928166cf49",
      "6cc3d58935426191296171a6c0d1ee965e10534e",
      "9aaefe19fc3dc8c8917cc87e6128bb56d9e9e6cc",
      "a0ffa757499913f7be69aa78f573a6aee3430ae4",
      "d7aa627ebde91cf799ada2a07443faa9b1e5abb8",
      "17fc98c2d81dbe685c19702dc694a9d606ac56dc",
      "21609ddfeff93668c7625a85eb09f1541fdad965",
      "3a9c18bcd27a01c551ac9bf8bd2b4bded77c189a",
      "554d543b50b917369fb1394cc5396d928166cf49",
      "6cc3d58935426191296171a6c0d1ee965e10534e",
      "9aaefe19fc3dc8c8917cc87e6128bb56d9e9e6cc",
      "a0ffa757499913f7be69aa78f573a6aee3430ae4",
      "d7aa627ebde91cf799ada2a07443faa9b1e5abb8"
    ],
    "patch_url": "https://github.com/quic-go/quic-go/commit/17fc98c2d81dbe685c19702dc694a9d606ac56dc.patch",
    "fix_commit_details": {
      "sha": "17fc98c2d81dbe685c19702dc694a9d606ac56dc",
      "commit_date": "2023-12-13T04:17:09Z",
      "author": {
        "login": "marten-seemann",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "limit the number of queued PATH_RESPONSE frames to 256 (#4199)",
        "length": 62,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 89,
        "additions": 82,
        "deletions": 7
      },
      "files": [
        {
          "filename": "framer.go",
          "status": "modified",
          "additions": 31,
          "deletions": 6,
          "patch": "@@ -23,6 +23,8 @@ type framer interface {\n \tHandle0RTTRejection() error\n }\n \n+const maxPathResponses = 256\n+\n type framerI struct {\n \tmutex sync.Mutex\n \n@@ -33,6 +35,7 @@ type framerI struct {\n \n \tcontrolFrameMutex sync.Mutex\n \tcontrolFrames     []wire.Frame\n+\tpathResponses     []*wire.PathResponseFrame\n }\n \n var _ framer = &framerI{}\n@@ -52,20 +55,43 @@ func (f *framerI) HasData() bool {\n \t\treturn true\n \t}\n \tf.controlFrameMutex.Lock()\n-\thasData = len(f.controlFrames) > 0\n-\tf.controlFrameMutex.Unlock()\n-\treturn hasData\n+\tdefer f.controlFrameMutex.Unlock()\n+\treturn len(f.controlFrames) > 0 || len(f.pathResponses) > 0\n }\n \n func (f *framerI) QueueControlFrame(frame wire.Frame) {\n \tf.controlFrameMutex.Lock()\n+\tdefer f.controlFrameMutex.Unlock()\n+\n+\tif pr, ok := frame.(*wire.PathResponseFrame); ok {\n+\t\t// Only queue up to maxPathResponses PATH_RESPONSE frames.\n+\t\t// This limit should be high enough to never be hit in practice,\n+\t\t// unless the peer is doing something malicious.\n+\t\tif len(f.pathResponses) >= maxPathResponses {\n+\t\t\treturn\n+\t\t}\n+\t\tf.pathResponses = append(f.pathResponses, pr)\n+\t\treturn\n+\t}\n \tf.controlFrames = append(f.controlFrames, frame)\n-\tf.controlFrameMutex.Unlock()\n }\n \n func (f *framerI) AppendControlFrames(frames []ackhandler.Frame, maxLen protocol.ByteCount, v protocol.VersionNumber) ([]ackhandler.Frame, protocol.ByteCount) {\n-\tvar length protocol.ByteCount\n \tf.controlFrameMutex.Lock()\n+\tdefer f.controlFrameMutex.Unlock()\n+\n+\tvar length protocol.ByteCount\n+\t// add a PATH_RESPONSE first, but only pack a single PATH_RESPONSE per packet\n+\tif len(f.pathResponses) > 0 {\n+\t\tframe := f.pathResponses[0]\n+\t\tframeLen := frame.Length(v)\n+\t\tif frameLen <= maxLen {\n+\t\t\tframes = append(frames, ackhandler.Frame{Frame: frame})\n+\t\t\tlength += frameLen\n+\t\t\tf.pathResponses = f.pathResponses[1:]\n+\t\t}\n+\t}\n+\n \tfor len(f.controlFrames) > 0 {\n \t\tframe := f.controlFrames[len(f.controlFrames)-1]\n \t\tframeLen := frame.Length(v)\n@@ -76,7 +102,6 @@ func (f *framerI) AppendControlFrames(frames []ackhandler.Frame, maxLen protocol\n \t\tlength += frameLen\n \t\tf.controlFrames = f.controlFrames[:len(f.controlFrames)-1]\n \t}\n-\tf.controlFrameMutex.Unlock()\n \treturn frames, length\n }\n "
        },
        {
          "filename": "framer_test.go",
          "status": "modified",
          "additions": 51,
          "deletions": 1,
          "patch": "@@ -2,7 +2,8 @@ package quic\n \n import (\n \t\"bytes\"\n-\t\"math/rand\"\n+\n+\t\"golang.org/x/exp/rand\"\n \n \t\"github.com/quic-go/quic-go/internal/ackhandler\"\n \t\"github.com/quic-go/quic-go/internal/protocol\"\n@@ -111,6 +112,55 @@ var _ = Describe(\"Framer\", func() {\n \t\t})\n \t})\n \n+\tContext(\"handling PATH_RESPONSE frames\", func() {\n+\t\tIt(\"packs a single PATH_RESPONSE per packet\", func() {\n+\t\t\tf1 := &wire.PathResponseFrame{Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8}}\n+\t\t\tf2 := &wire.PathResponseFrame{Data: [8]byte{2, 3, 4, 5, 6, 7, 8, 9}}\n+\t\t\tcf1 := &wire.DataBlockedFrame{MaximumData: 1337}\n+\t\t\tcf2 := &wire.HandshakeDoneFrame{}\n+\t\t\tframer.QueueControlFrame(f1)\n+\t\t\tframer.QueueControlFrame(f2)\n+\t\t\tframer.QueueControlFrame(cf1)\n+\t\t\tframer.QueueControlFrame(cf2)\n+\t\t\t// the first packet should contain a single PATH_RESPONSE frame, but all the other control frames\n+\t\t\tExpect(framer.HasData()).To(BeTrue())\n+\t\t\tframes, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n+\t\t\tExpect(frames).To(HaveLen(3))\n+\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n+\t\t\tExpect([]wire.Frame{frames[1].Frame, frames[2].Frame}).To(ContainElement(cf1))\n+\t\t\tExpect([]wire.Frame{frames[1].Frame, frames[2].Frame}).To(ContainElement(cf2))\n+\t\t\tExpect(length).To(Equal(f1.Length(protocol.Version1) + cf1.Length(protocol.Version1) + cf2.Length(protocol.Version1)))\n+\t\t\t// the second packet should contain the other PATH_RESPONSE frame\n+\t\t\tExpect(framer.HasData()).To(BeTrue())\n+\t\t\tframes, length = framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n+\t\t\tExpect(frames).To(HaveLen(1))\n+\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n+\t\t\tExpect(length).To(Equal(f2.Length(protocol.Version1)))\n+\t\t\tExpect(framer.HasData()).To(BeFalse())\n+\t\t})\n+\n+\t\tIt(\"limits the number of queued PATH_RESPONSE frames\", func() {\n+\t\t\tvar pathResponses []*wire.PathResponseFrame\n+\t\t\tfor i := 0; i < 2*maxPathResponses; i++ {\n+\t\t\t\tvar f wire.PathResponseFrame\n+\t\t\t\trand.Read(f.Data[:])\n+\t\t\t\tpathResponses = append(pathResponses, &f)\n+\t\t\t\tframer.QueueControlFrame(&f)\n+\t\t\t}\n+\t\t\tfor i := 0; i < maxPathResponses; i++ {\n+\t\t\t\tExpect(framer.HasData()).To(BeTrue())\n+\t\t\t\tframes, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n+\t\t\t\tExpect(frames).To(HaveLen(1))\n+\t\t\t\tExpect(frames[0].Frame).To(Equal(pathResponses[i]))\n+\t\t\t\tExpect(length).To(Equal(pathResponses[i].Length(protocol.Version1)))\n+\t\t\t}\n+\t\t\tExpect(framer.HasData()).To(BeFalse())\n+\t\t\tframes, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n+\t\t\tExpect(frames).To(BeEmpty())\n+\t\t\tExpect(length).To(BeZero())\n+\t\t})\n+\t})\n+\n \tContext(\"popping STREAM frames\", func() {\n \t\tIt(\"returns nil when popping an empty framer\", func() {\n \t\t\tExpect(framer.AppendStreamFrames(nil, 1000, protocol.Version1)).To(BeEmpty())"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "62a94758e6725ea285443090c802157df86331b9",
            "date": "2025-01-14T08:40:20Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "fbbc3c9e3017064bc003a36079bd1470c7f18a09",
            "date": "2025-01-14T08:01:57Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "96ce54e83f2c8daba07bab99f086215b0b2dc74b",
            "date": "2025-01-14T04:50:16Z",
            "author_login": "lRoccoon"
          },
          {
            "sha": "516220b0c5cc21fd4c4cfc2079cbf46e09846276",
            "date": "2025-01-13T02:27:12Z",
            "author_login": "marten-seemann"
          },
          {
            "sha": "61adb85052c1c9e350bbbfb7ad7e7767aa2ea8bb",
            "date": "2025-01-13T02:02:13Z",
            "author_login": "marten-seemann"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H",
    "cwe_id": "CWE-400",
    "description": "quic-go is an implementation of the QUIC protocol (RFC 9000, RFC 9001, RFC 9002) in Go. An attacker can cause its peer to run out of memory sending a large number of PATH_CHALLENGE frames. The receiver is supposed to respond to each PATH_CHALLENGE frame with a PATH_RESPONSE frame. The attacker can prevent the receiver from sending out (the vast majority of) these PATH_RESPONSE frames by collapsing the peers congestion window (by selectively acknowledging received packets) and by manipulating the peer's RTT estimate. This vulnerability has been patched in versions 0.37.7, 0.38.2 and 0.39.4.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-01-10T22:15:50.610",
    "last_modified": "2024-11-21T08:33:12.607",
    "fix_date": "2023-12-13T04:17:09Z"
  },
  "references": [
    {
      "url": "https://github.com/quic-go/quic-go/commit/17fc98c2d81dbe685c19702dc694a9d606ac56dc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/21609ddfeff93668c7625a85eb09f1541fdad965",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/3a9c18bcd27a01c551ac9bf8bd2b4bded77c189a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/554d543b50b917369fb1394cc5396d928166cf49",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/6cc3d58935426191296171a6c0d1ee965e10534e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/9aaefe19fc3dc8c8917cc87e6128bb56d9e9e6cc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/a0ffa757499913f7be69aa78f573a6aee3430ae4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/d7aa627ebde91cf799ada2a07443faa9b1e5abb8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/security/advisories/GHSA-ppxx-5m9h-6vxf",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G5RSHDTVMYAIGYVVFGKTMFHAZJMA3EVV/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZE7IOKXX5AATU2WR3V76X5Y3A44QAATG/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/17fc98c2d81dbe685c19702dc694a9d606ac56dc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/21609ddfeff93668c7625a85eb09f1541fdad965",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/3a9c18bcd27a01c551ac9bf8bd2b4bded77c189a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/554d543b50b917369fb1394cc5396d928166cf49",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/6cc3d58935426191296171a6c0d1ee965e10534e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/9aaefe19fc3dc8c8917cc87e6128bb56d9e9e6cc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/a0ffa757499913f7be69aa78f573a6aee3430ae4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/commit/d7aa627ebde91cf799ada2a07443faa9b1e5abb8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quic-go/quic-go/security/advisories/GHSA-ppxx-5m9h-6vxf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G5RSHDTVMYAIGYVVFGKTMFHAZJMA3EVV/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZE7IOKXX5AATU2WR3V76X5Y3A44QAATG/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:44.157558",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "quic-go",
    "owner": "quic-go",
    "created_at": "2016-04-06T20:16:27Z",
    "updated_at": "2025-01-14T18:27:53Z",
    "pushed_at": "2025-01-14T09:43:06Z",
    "size": 16771,
    "stars": 10331,
    "forks": 1339,
    "open_issues": 197,
    "watchers": 10331,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 2479488,
      "Shell": 3386,
      "Dockerfile": 1884
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:11:44.846055"
  }
}