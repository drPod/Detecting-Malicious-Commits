{
  "cve_id": "CVE-2023-50245",
  "github_data": {
    "repository": "afichet/openexr-viewer",
    "fix_commit": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
    "related_commits": [
      "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
      "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
      "commit_date": "2023-12-09T13:13:36Z",
      "author": {
        "login": "afichet",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Early catch potential overflow issue #43",
        "length": 577,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 68,
        "additions": 43,
        "deletions": 25
      },
      "files": [
        {
          "filename": "src/model/framebuffer/FramebufferModel.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -39,7 +39,6 @@\n \n FramebufferModel::FramebufferModel(QObject* parent)\n   : QObject(parent)\n-  , m_pixelBuffer(nullptr)\n   , m_width(0)\n   , m_height(0)\n   , m_isImageLoaded(false)\n@@ -59,7 +58,4 @@ QRect FramebufferModel::getDataWindow() const\n     return m_dataWindow;\n }\n \n-FramebufferModel::~FramebufferModel()\n-{\n-    delete[] m_pixelBuffer;\n-}\n+FramebufferModel::~FramebufferModel() {}"
        },
        {
          "filename": "src/model/framebuffer/FramebufferModel.h",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -37,7 +37,7 @@\n #include <QObject>\n #include <QRect>\n #include <QVector>\n-#include <array>\n+#include <vector>\n \n class FramebufferModel: public QObject\n {\n@@ -67,8 +67,8 @@ class FramebufferModel: public QObject\n     void loadFailed(QString message);\n \n   protected:\n-    float* m_pixelBuffer;\n-    QImage m_image;\n+    std::vector<float> m_pixelBuffer;\n+    QImage             m_image;\n \n     // Right now, the width and height are defined as Vec2i in OpenEXR\n     // i.e. int type."
        },
        {
          "filename": "src/model/framebuffer/RGBFramebufferModel.cpp",
          "status": "modified",
          "additions": 22,
          "deletions": 13,
          "patch": "@@ -81,6 +81,23 @@ void RGBFramebufferModel::load(\n             m_displayWindow\n               = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n \n+            // Check to avoid type overflow, width and height are 32bits int\n+            // representing a 2 dimentional image. Can overflow the type when\n+            // multiplied together.\n+            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max\n+            // representable int since we need 4 channels.\n+            // TODO: Use larger type when manipulating framebuffer\n+            const uint64_t partial_size\n+              = (uint64_t)m_width * (uint64_t)m_height;\n+\n+            if (partial_size > 0x1FFFFFFF) {\n+                throw std::runtime_error(\n+                  \"The total image size is too large. May be supported in a \"\n+                  \"future revision.\");\n+            }\n+\n+            m_pixelBuffer.resize(4 * m_width * m_height);\n+\n             // Check if there is specific chromaticities tied to the color\n             // representation in this part.\n             const Imf::ChromaticitiesAttribute* c\n@@ -93,8 +110,6 @@ void RGBFramebufferModel::load(\n                 chromaticities = c->value();\n             }\n \n-            m_pixelBuffer = new float[4 * m_width * m_height];\n-\n             // Check if there is alpha channel\n             if (hasAlpha) {\n                 std::string      aLayer = m_parentLayer + \"A\";\n@@ -190,12 +205,12 @@ void RGBFramebufferModel::load(\n \n                     Imf::FrameBuffer framebuffer;\n \n-                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];\n-                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];\n+                    std::vector<Imf::Rgba> buff1(m_width * m_height);\n+                    std::vector<Imf::Rgba> buff2(m_width * m_height);\n \n-                    float* yBuffer  = new float[m_width * m_height];\n-                    float* ryBuffer = new float[m_width / 2 * m_height / 2];\n-                    float* byBuffer = new float[m_width / 2 * m_height / 2];\n+                    std::vector<float> yBuffer(m_width * m_height);\n+                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);\n+                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);\n \n                     Imf::Slice ySlice = Imf::Slice::Make(\n                       Imf::PixelType::FLOAT,\n@@ -335,12 +350,6 @@ void RGBFramebufferModel::load(\n                             m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                         }\n                     }\n-\n-                    delete[] yBuffer;\n-                    delete[] ryBuffer;\n-                    delete[] byBuffer;\n-                    delete[] buff1;\n-                    delete[] buff2;\n                 }\n \n                 break;"
        },
        {
          "filename": "src/model/framebuffer/YFramebufferModel.cpp",
          "status": "modified",
          "additions": 17,
          "deletions": 4,
          "patch": "@@ -90,12 +90,25 @@ void YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)\n                   dispW_width / 2,\n                   dispW_height / 2);\n \n-                m_pixelBuffer = new float[m_width * m_height];\n+                // Check to avoid type overflow, width and height are 32bits int\n+                // representing a 2 dimentional image. Can overflow the type when\n+                // multiplied together\n+                // TODO: Use larger type when manipulating framebuffer\n+                const uint64_t partial_size\n+                  = (uint64_t)m_width * (uint64_t)m_height;\n+\n+                if (partial_size > 0x7FFFFFFF) {\n+                    throw std::runtime_error(\n+                      \"The total image size is too large. May be supported in \"\n+                      \"a future revision.\");\n+                }\n+\n+                m_pixelBuffer.resize(m_width * m_height);\n \n                 // Luminance Chroma channels\n                 graySlice = Imf::Slice::Make(\n                   Imf::PixelType::FLOAT,\n-                  m_pixelBuffer,\n+                  m_pixelBuffer.data(),\n                   datW,\n                   sizeof(float),\n                   m_width * sizeof(float),\n@@ -112,11 +125,11 @@ void YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)\n                 m_displayWindow\n                   = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n \n-                m_pixelBuffer = new float[m_width * m_height];\n+                m_pixelBuffer.resize(m_width * m_height);\n \n                 graySlice = Imf::Slice::Make(\n                   Imf::PixelType::FLOAT,\n-                  m_pixelBuffer,\n+                  m_pixelBuffer.data(),\n                   datW);\n             }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4f3b278ce4591e0cfbbee5f0fac5774b69a1df96",
            "date": "2023-12-09T13:49:25Z",
            "author_login": "afichet"
          },
          {
            "sha": "fb9a0eb21f30ad3ba90207ea7bb6f8b82399f242",
            "date": "2023-12-09T13:43:50Z",
            "author_login": "afichet"
          },
          {
            "sha": "99f4b690575a201be732dab4f9e79cdaa7a376e6",
            "date": "2023-12-09T13:42:26Z",
            "author_login": "afichet"
          },
          {
            "sha": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
            "date": "2023-12-09T13:13:36Z",
            "author_login": "afichet"
          },
          {
            "sha": "70cc9412ef3c713f74dbd78761971e2a09bcb580",
            "date": "2023-12-09T12:33:01Z",
            "author_login": "afichet"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-120",
    "description": "OpenEXR-viewer is a viewer for OpenEXR files with detailed metadata probing. Versions prior to 0.6.1 have a memory overflow vulnerability. This issue is fixed in version 0.6.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-12-11T23:15:08.280",
    "last_modified": "2024-11-21T08:36:44.243",
    "fix_date": "2023-12-09T13:13:36Z"
  },
  "references": [
    {
      "url": "https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/afichet/openexr-viewer/security/advisories/GHSA-99jg-r3f4-rpxj",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/afichet/openexr-viewer/security/advisories/GHSA-99jg-r3f4-rpxj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:41.557128",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "openexr-viewer",
    "owner": "afichet",
    "created_at": "2021-05-01T12:34:53Z",
    "updated_at": "2025-01-17T07:52:19Z",
    "pushed_at": "2023-12-11T13:18:47Z",
    "size": 4739,
    "stars": 102,
    "forks": 6,
    "open_issues": 15,
    "watchers": 102,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C++": 258375,
      "CMake": 18915,
      "CSS": 8578,
      "PowerShell": 1235,
      "Shell": 322
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-26T07:39:56.750750"
  }
}