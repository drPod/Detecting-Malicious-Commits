{
  "cve_id": "CVE-2023-50247",
  "github_data": {
    "repository": "h2o/h2o",
    "fix_commit": "d67e81d03be12a9d53dc8271af6530f40164cd35",
    "related_commits": [
      "d67e81d03be12a9d53dc8271af6530f40164cd35",
      "d67e81d03be12a9d53dc8271af6530f40164cd35"
    ],
    "patch_url": "https://github.com/h2o/h2o/commit/d67e81d03be12a9d53dc8271af6530f40164cd35.patch",
    "fix_commit_details": {
      "sha": "d67e81d03be12a9d53dc8271af6530f40164cd35",
      "commit_date": "2023-12-12T13:03:08Z",
      "author": {
        "login": "kazuho",
        "type": "User",
        "stats": {
          "total_commits": 7854,
          "average_weekly_commits": 14.228260869565217,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 465
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2ch5-p59c-7mv6",
        "length": 70,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 84,
        "additions": 33,
        "deletions": 51
      },
      "files": [
        {
          "filename": "deps/quicly/lib/quicly.c",
          "status": "modified",
          "additions": 33,
          "deletions": 51,
          "patch": "@@ -108,12 +108,6 @@ struct st_quicly_cipher_context_t {\n     ptls_cipher_context_t *header_protection;\n };\n \n-struct st_quicly_pending_path_challenge_t {\n-    struct st_quicly_pending_path_challenge_t *next;\n-    uint8_t is_response;\n-    uint8_t data[QUICLY_PATH_CHALLENGE_DATA_LEN];\n-};\n-\n struct st_quicly_pn_space_t {\n     /**\n      * acks to be sent to remote peer\n@@ -278,8 +272,9 @@ struct st_quicly_conn_t {\n          *\n          */\n         struct {\n-            struct st_quicly_pending_path_challenge_t *head, **tail_ref;\n-        } path_challenge;\n+            uint8_t send_;\n+            uint8_t data[QUICLY_PATH_CHALLENGE_DATA_LEN];\n+        } path_response;\n         /**\n          *\n          */\n@@ -935,25 +930,6 @@ void quicly_stream_sync_recvbuf(quicly_stream_t *stream, size_t shift_amount)\n     }\n }\n \n-static int schedule_path_challenge_frame(quicly_conn_t *conn, int is_response, const uint8_t *data)\n-{\n-    struct st_quicly_pending_path_challenge_t *pending;\n-\n-    if ((pending = malloc(sizeof(struct st_quicly_pending_path_challenge_t))) == NULL)\n-        return PTLS_ERROR_NO_MEMORY;\n-\n-    pending->next = NULL;\n-    pending->is_response = is_response;\n-    memcpy(pending->data, data, QUICLY_PATH_CHALLENGE_DATA_LEN);\n-\n-    *conn->egress.path_challenge.tail_ref = pending;\n-    conn->egress.path_challenge.tail_ref = &pending->next;\n-\n-    conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n-\n-    return 0;\n-}\n-\n /**\n  * calculate how many CIDs we provide to the remote peer\n  */\n@@ -1698,11 +1674,6 @@ void quicly_free(quicly_conn_t *conn)\n     quicly_maxsender_dispose(&conn->ingress.max_data.sender);\n     quicly_maxsender_dispose(&conn->ingress.max_streams.uni);\n     quicly_maxsender_dispose(&conn->ingress.max_streams.bidi);\n-    while (conn->egress.path_challenge.head != NULL) {\n-        struct st_quicly_pending_path_challenge_t *pending = conn->egress.path_challenge.head;\n-        conn->egress.path_challenge.head = pending->next;\n-        free(pending);\n-    }\n     quicly_loss_dispose(&conn->egress.loss);\n \n     kh_destroy(quicly_stream_t, conn->streams);\n@@ -2247,7 +2218,6 @@ static quicly_conn_t *create_connection(quicly_context_t *ctx, uint32_t protocol\n     conn->egress.max_udp_payload_size = conn->super.ctx->initial_egress_max_udp_payload_size;\n     init_max_streams(&conn->egress.max_streams.uni);\n     init_max_streams(&conn->egress.max_streams.bidi);\n-    conn->egress.path_challenge.tail_ref = &conn->egress.path_challenge.head;\n     conn->egress.ack_frequency.update_at = INT64_MAX;\n     conn->egress.send_ack_at = INT64_MAX;\n     conn->super.ctx->init_cc->cb(conn->super.ctx->init_cc, &conn->egress.cc, initcwnd, conn->stash.now);\n@@ -4486,6 +4456,25 @@ static int send_retire_connection_id(quicly_conn_t *conn, quicly_send_context_t\n     return 0;\n }\n \n+static int send_path_challenge(quicly_conn_t *conn, quicly_send_context_t *s, int is_response, const uint8_t *data)\n+{\n+    int ret;\n+\n+    if ((ret = do_allocate_frame(conn, s, QUICLY_PATH_CHALLENGE_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC)) != 0)\n+        return ret;\n+\n+    s->dst = quicly_encode_path_challenge_frame(s->dst, is_response, data);\n+    s->target.full_size = 1; /* ensure that the path can transfer full-size packets */\n+\n+    if (!is_response) {\n+        ++conn->super.stats.num_frames_sent.path_challenge;\n+    } else {\n+        ++conn->super.stats.num_frames_sent.path_response;\n+    }\n+\n+    return 0;\n+}\n+\n static int update_traffic_key_cb(ptls_update_traffic_key_t *self, ptls_t *tls, int is_enc, size_t epoch, const void *secret)\n {\n     quicly_conn_t *conn = *ptls_get_data_ptr(tls);\n@@ -4591,23 +4580,10 @@ static int send_other_control_frames(quicly_conn_t *conn, quicly_send_context_t\n     int ret;\n \n     /* respond to all pending received PATH_CHALLENGE frames */\n-    if (conn->egress.path_challenge.head != NULL) {\n-        do {\n-            struct st_quicly_pending_path_challenge_t *c = conn->egress.path_challenge.head;\n-            if ((ret = do_allocate_frame(conn, s, QUICLY_PATH_CHALLENGE_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) !=\n-                0)\n-                return ret;\n-            s->dst = quicly_encode_path_challenge_frame(s->dst, c->is_response, c->data);\n-            if (c->is_response) {\n-                ++conn->super.stats.num_frames_sent.path_response;\n-            } else {\n-                ++conn->super.stats.num_frames_sent.path_challenge;\n-            }\n-            conn->egress.path_challenge.head = c->next;\n-            free(c);\n-        } while (conn->egress.path_challenge.head != NULL);\n-        conn->egress.path_challenge.tail_ref = &conn->egress.path_challenge.head;\n-        s->target.full_size = 1; /* datagrams carrying PATH_CHALLENGE / PATH_RESPONSE have to be full-sized */\n+    if (conn->egress.path_response.send_) {\n+        if ((ret = send_path_challenge(conn, s, 1, conn->egress.path_response.data)) != 0)\n+            return ret;\n+        conn->egress.path_response.send_ = 0;\n     }\n \n     /* MAX_STREAMS */\n@@ -5550,7 +5526,13 @@ static int handle_path_challenge_frame(quicly_conn_t *conn, struct st_quicly_han\n \n     if ((ret = quicly_decode_path_challenge_frame(&state->src, state->end, &frame)) != 0)\n         return ret;\n-    return schedule_path_challenge_frame(conn, 1, frame.data);\n+\n+    /* schedule the emission of PATH_RESPONSE frame */\n+    memcpy(conn->egress.path_response.data, frame.data, QUICLY_PATH_CHALLENGE_DATA_LEN);\n+    conn->egress.path_response.send_ = 1;\n+    conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;\n+\n+    return 0;\n }\n \n static int handle_path_response_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "af505adb8f80a849a977ff083d95a528bda7600a",
            "date": "2025-01-12T08:09:42Z",
            "author_login": "kazuho"
          },
          {
            "sha": "a439e8b428f5fe4df77cec3c50b0e7bb497baf8e",
            "date": "2025-01-12T07:22:34Z",
            "author_login": "kazuho"
          },
          {
            "sha": "fe14ac460954434da8342b57c0c6d124860c75ef",
            "date": "2025-01-12T06:22:56Z",
            "author_login": "kazuho"
          },
          {
            "sha": "acab0beacebc7559c0da0f3925d8f4105c29ed13",
            "date": "2025-01-12T05:15:47Z",
            "author_login": "kazuho"
          },
          {
            "sha": "f59d8509da2fc9b5cdbcec5118317a847e6d29db",
            "date": "2025-01-12T05:16:22Z",
            "author_login": "kazuho"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-770",
    "description": "h2o is an HTTP server with support for HTTP/1.x, HTTP/2 and HTTP/3. The QUIC stack (quicly), as used by H2O up to commit 43f86e5 (in version 2.3.0-beta and prior), is susceptible to a state exhaustion attack. When H2O is serving HTTP/3, a remote attacker can exploit this vulnerability to progressively increase the memory retained by the QUIC stack. This can eventually cause H2O to abort due to memory exhaustion. The vulnerability has been resolved in commit d67e81d03be12a9d53dc8271af6530f40164cd35. HTTP/1 and HTTP/2 are not affected by this vulnerability as they do not use QUIC. Administrators looking to mitigate this issue without upgrading can disable HTTP/3 support.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2023-12-12T20:15:08.580",
    "last_modified": "2024-11-21T08:36:44.530",
    "fix_date": "2023-12-12T13:03:08Z"
  },
  "references": [
    {
      "url": "https://github.com/h2o/h2o/commit/d67e81d03be12a9d53dc8271af6530f40164cd35",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/h2o/h2o/security/advisories/GHSA-2ch5-p59c-7mv6",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/h2o/h2o/commit/d67e81d03be12a9d53dc8271af6530f40164cd35",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/h2o/h2o/security/advisories/GHSA-2ch5-p59c-7mv6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:41.562685",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "h2o",
    "owner": "h2o",
    "created_at": "2014-08-16T23:59:03Z",
    "updated_at": "2025-01-14T02:47:54Z",
    "pushed_at": "2025-01-12T08:09:42Z",
    "size": 121723,
    "stars": 10968,
    "forks": 849,
    "open_issues": 691,
    "watchers": 10968,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 3167175,
      "Perl": 852069,
      "Mathematica": 212238,
      "Ruby": 66838,
      "Shell": 61760,
      "CMake": 43218,
      "Python": 27144,
      "C++": 24060,
      "PHP": 10137,
      "Makefile": 9686,
      "DTrace": 7182,
      "HTML": 6430,
      "Vim Script": 73,
      "JavaScript": 16
    },
    "commit_activity": {
      "total_commits_last_year": 421,
      "avg_commits_per_week": 8.096153846153847,
      "days_active_last_year": 102
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:02:53.733286"
  }
}