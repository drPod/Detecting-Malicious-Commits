{
  "cve_id": "CVE-2023-50249",
  "github_data": {
    "repository": "getsentry/sentry-javascript",
    "fix_commit": "fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb",
    "related_commits": [
      "fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb",
      "fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb"
    ],
    "patch_url": "https://github.com/getsentry/sentry-javascript/commit/fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb.patch",
    "fix_commit_details": {
      "sha": "fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb",
      "commit_date": "2023-12-13T12:18:14Z",
      "author": {
        "login": "Lms24",
        "type": "User",
        "stats": {
          "total_commits": 784,
          "average_weekly_commits": 1.1428571428571428,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 129
        }
      },
      "commit_message": {
        "title": "fix(astro): Avoid RegExp creation during route interpolation (#9815)",
        "length": 346,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 154,
        "additions": 140,
        "deletions": 14
      },
      "files": [
        {
          "filename": "packages/astro/src/server/middleware.ts",
          "status": "modified",
          "additions": 80,
          "deletions": 14,
          "patch": "@@ -7,12 +7,7 @@ import {\n   startSpan,\n } from '@sentry/node';\n import type { Hub, Span } from '@sentry/types';\n-import {\n-  addNonEnumerableProperty,\n-  objectify,\n-  stripUrlQueryAndFragment,\n-  tracingContextFromHeaders,\n-} from '@sentry/utils';\n+import { addNonEnumerableProperty, objectify, stripUrlQueryAndFragment } from '@sentry/utils';\n import type { APIContext, MiddlewareResponseHandler } from 'astro';\n \n import { getTracingMetaTags } from './meta';\n@@ -64,7 +59,11 @@ type AstroLocalsWithSentry = Record<string, unknown> & {\n };\n \n export const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {\n-  const handlerOptions = { trackClientIp: false, trackHeaders: false, ...options };\n+  const handlerOptions = {\n+    trackClientIp: false,\n+    trackHeaders: false,\n+    ...options,\n+  };\n \n   return async (ctx, next) => {\n     // if there is an active span, we know that this handle call is nested and hence\n@@ -113,18 +112,19 @@ async function instrumentRequest(\n   }\n \n   try {\n+    const interpolatedRoute = interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params);\n     // storing res in a variable instead of directly returning is necessary to\n     // invoke the catch block if next() throws\n     const res = await startSpan(\n       {\n         ...traceCtx,\n-        name: `${method} ${interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params)}`,\n+        name: `${method} ${interpolatedRoute || ctx.url.pathname}`,\n         op: 'http.server',\n         origin: 'auto.http.astro',\n         status: 'ok',\n         metadata: {\n           ...traceCtx?.metadata,\n-          source: 'route',\n+          source: interpolatedRoute ? 'route' : 'url',\n         },\n         data: {\n           method,\n@@ -202,10 +202,76 @@ function addMetaTagToHead(htmlChunk: string, hub: Hub, span?: Span): string {\n  * Best we can do to get a route name instead of a raw URL.\n  *\n  * exported for testing\n+ *\n+ * @param rawUrlPathname - The raw URL pathname, e.g. '/users/123/details'\n+ * @param params - The params object, e.g. `{ userId: '123' }`\n+ *\n+ * @returns The interpolated route, e.g. '/users/[userId]/details'\n  */\n-export function interpolateRouteFromUrlAndParams(rawUrl: string, params: APIContext['params']): string {\n-  return Object.entries(params).reduce((interpolateRoute, value) => {\n-    const [paramId, paramValue] = value;\n-    return interpolateRoute.replace(new RegExp(`(/|-)${paramValue}(/|-|$)`), `$1[${paramId}]$2`);\n-  }, rawUrl);\n+export function interpolateRouteFromUrlAndParams(\n+  rawUrlPathname: string,\n+  params: APIContext['params'],\n+): string | undefined {\n+  const decodedUrlPathname = tryDecodeUrl(rawUrlPathname);\n+  if (!decodedUrlPathname) {\n+    return undefined;\n+  }\n+\n+  // Invert params map so that the param values are the keys\n+  // differentiate between rest params spanning multiple url segments\n+  // and normal, single-segment params.\n+  const valuesToMultiSegmentParams: Record<string, string> = {};\n+  const valuesToParams: Record<string, string> = {};\n+  Object.entries(params).forEach(([key, value]) => {\n+    if (!value) {\n+      return;\n+    }\n+    if (value.includes('/')) {\n+      valuesToMultiSegmentParams[value] = key;\n+      return;\n+    }\n+    valuesToParams[value] = key;\n+  });\n+\n+  function replaceWithParamName(segment: string): string {\n+    const param = valuesToParams[segment];\n+    if (param) {\n+      return `[${param}]`;\n+    }\n+    return segment;\n+  }\n+\n+  // before we match single-segment params, we first replace multi-segment params\n+  const urlWithReplacedMultiSegmentParams = Object.keys(valuesToMultiSegmentParams).reduce((acc, key) => {\n+    return acc.replace(key, `[${valuesToMultiSegmentParams[key]}]`);\n+  }, decodedUrlPathname);\n+\n+  return urlWithReplacedMultiSegmentParams\n+    .split('/')\n+    .map(segment => {\n+      if (!segment) {\n+        return '';\n+      }\n+\n+      if (valuesToParams[segment]) {\n+        return replaceWithParamName(segment);\n+      }\n+\n+      // astro permits multiple params in a single path segment, e.g. /[foo]-[bar]/\n+      const segmentParts = segment.split('-');\n+      if (segmentParts.length > 1) {\n+        return segmentParts.map(part => replaceWithParamName(part)).join('-');\n+      }\n+\n+      return segment;\n+    })\n+    .join('/');\n+}\n+\n+function tryDecodeUrl(url: string): string | undefined {\n+  try {\n+    return decodeURI(url);\n+  } catch {\n+    return undefined;\n+  }\n }"
        },
        {
          "filename": "packages/astro/test/server/middleware.test.ts",
          "status": "modified",
          "additions": 60,
          "deletions": 0,
          "patch": "@@ -69,6 +69,43 @@ describe('sentryMiddleware', () => {\n     expect(resultFromNext).toStrictEqual(nextResult);\n   });\n \n+  it(\"sets source route if the url couldn't be decoded correctly\", async () => {\n+    const middleware = handleRequest();\n+    const ctx = {\n+      request: {\n+        method: 'GET',\n+        url: '/a%xx',\n+        headers: new Headers(),\n+      },\n+      url: { pathname: 'a%xx', href: 'http://localhost:1234/a%xx' },\n+      params: {},\n+    };\n+    const next = vi.fn(() => nextResult);\n+\n+    // @ts-expect-error, a partial ctx object is fine here\n+    const resultFromNext = middleware(ctx, next);\n+\n+    expect(startSpanSpy).toHaveBeenCalledWith(\n+      {\n+        data: {\n+          method: 'GET',\n+          url: 'http://localhost:1234/a%xx',\n+        },\n+        metadata: {\n+          source: 'url',\n+        },\n+        name: 'GET a%xx',\n+        op: 'http.server',\n+        origin: 'auto.http.astro',\n+        status: 'ok',\n+      },\n+      expect.any(Function), // the `next` function\n+    );\n+\n+    expect(next).toHaveBeenCalled();\n+    expect(resultFromNext).toStrictEqual(nextResult);\n+  });\n+\n   it('throws and sends an error to sentry if `next()` throws', async () => {\n     const captureExceptionSpy = vi.spyOn(SentryNode, 'captureException');\n \n@@ -299,15 +336,31 @@ describe('sentryMiddleware', () => {\n \n describe('interpolateRouteFromUrlAndParams', () => {\n   it.each([\n+    ['/', {}, '/'],\n     ['/foo/bar', {}, '/foo/bar'],\n     ['/users/123', { id: '123' }, '/users/[id]'],\n     ['/users/123', { id: '123', foo: 'bar' }, '/users/[id]'],\n     ['/lang/en-US', { lang: 'en', region: 'US' }, '/lang/[lang]-[region]'],\n     ['/lang/en-US/posts', { lang: 'en', region: 'US' }, '/lang/[lang]-[region]/posts'],\n+    // edge cases that astro doesn't support\n+    ['/lang/-US', { region: 'US' }, '/lang/-[region]'],\n+    ['/lang/en-', { lang: 'en' }, '/lang/[lang]-'],\n   ])('interpolates route from URL and params %s', (rawUrl, params, expectedRoute) => {\n     expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n   });\n \n+  it.each([\n+    ['/(a+)+/aaaaaaaaa!', { id: '(a+)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n+    ['/([a-zA-Z]+)*/aaaaaaaaa!', { id: '([a-zA-Z]+)*', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n+    ['/(a|aa)+/aaaaaaaaa!', { id: '(a|aa)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n+    ['/(a|a?)+/aaaaaaaaa!', { id: '(a|a?)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n+    // with URL encoding\n+    ['/(a%7Caa)+/aaaaaaaaa!', { id: '(a|aa)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n+    ['/(a%7Ca?)+/aaaaaaaaa!', { id: '(a|a?)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n+  ])('handles regex characters in param values correctly %s', (rawUrl, params, expectedRoute) => {\n+    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n+  });\n+\n   it('handles params across multiple URL segments in catchall routes', () => {\n     // Ideally, Astro would let us know that this is a catchall route so we can make the param [...catchall] but it doesn't\n     expect(\n@@ -324,4 +377,11 @@ describe('interpolateRouteFromUrlAndParams', () => {\n     const expectedRoute = '/usernames/[name]';\n     expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n   });\n+\n+  it('handles set but undefined params', () => {\n+    const rawUrl = '/usernames/user';\n+    const params = { name: undefined, name2: '' };\n+    const expectedRoute = '/usernames/user';\n+    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n+  });\n });"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2f302d7c5a2f5f27de17bf6eb67ed9b0ce25d08b",
            "date": "2025-01-14T17:44:12Z",
            "author_login": "s1gr1d"
          },
          {
            "sha": "1f5edf629403f1636026162c35826179a53cc781",
            "date": "2025-01-14T15:26:49Z",
            "author_login": "mydea"
          },
          {
            "sha": "463e8da3d181ee271d4b3a4000883575feabef91",
            "date": "2025-01-14T15:24:51Z",
            "author_login": "AbhiPrasad"
          },
          {
            "sha": "64e9fb620351d5a171cea0501badecd0ed08fdec",
            "date": "2025-01-14T14:57:05Z",
            "author_login": "mydea"
          },
          {
            "sha": "f24ee2865326af9199402b6727c474c48097bcf5",
            "date": "2025-01-14T12:38:29Z",
            "author_login": "mydea"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Sentry-Javascript is official Sentry SDKs for JavaScript. A ReDoS (Regular expression Denial of Service) vulnerability has been identified in Sentry's Astro SDK 7.78.0-7.86.0. Under certain conditions, this vulnerability allows an attacker to cause excessive computation times on the server, leading to denial of service (DoS). This vulnerability has been patched in sentry/astro version 7.87.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-12-20T14:15:21.350",
    "last_modified": "2024-11-21T08:36:44.813",
    "fix_date": "2023-12-13T12:18:14Z"
  },
  "references": [
    {
      "url": "https://github.com/getsentry/sentry-javascript/commit/fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/getsentry/sentry-javascript/pull/9815",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/getsentry/sentry-javascript/security/advisories/GHSA-x3v3-8xg8-8v72",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/getsentry/sentry-javascript/commit/fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/getsentry/sentry-javascript/pull/9815",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/getsentry/sentry-javascript/security/advisories/GHSA-x3v3-8xg8-8v72",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:41.588501",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sentry-javascript",
    "owner": "getsentry",
    "created_at": "2012-02-01T20:16:25Z",
    "updated_at": "2025-01-14T19:45:58Z",
    "pushed_at": "2025-01-14T18:48:01Z",
    "size": 146127,
    "stars": 8066,
    "forks": 1608,
    "open_issues": 397,
    "watchers": 8066,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "TypeScript": 7292140,
      "JavaScript": 488784,
      "HTML": 54721,
      "C++": 38771,
      "Astro": 16577,
      "Vue": 15952,
      "CSS": 14945,
      "Svelte": 14230,
      "Shell": 10918,
      "Handlebars": 6865,
      "Python": 560
    },
    "commit_activity": {
      "total_commits_last_year": 2778,
      "avg_commits_per_week": 53.42307692307692,
      "days_active_last_year": 244
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T19:51:20.124543"
  }
}