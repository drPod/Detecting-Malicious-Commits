{
  "cve_id": "CVE-2023-50257",
  "github_data": {
    "repository": "eProsima/Fast-DDS",
    "fix_commit": "072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4",
    "related_commits": [
      "072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4",
      "e1869863c06db7fbb366ae53760fbe6e754be026",
      "f07a0213e655202188840b864be4438ae1067a13",
      "f2e5ceae8fbea0a6c9445a366faaca0b98a8ef86",
      "072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4",
      "e1869863c06db7fbb366ae53760fbe6e754be026",
      "f07a0213e655202188840b864be4438ae1067a13",
      "f2e5ceae8fbea0a6c9445a366faaca0b98a8ef86"
    ],
    "patch_url": "https://github.com/eProsima/Fast-DDS/commit/072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4.patch",
    "fix_commit_details": {
      "sha": "072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4",
      "commit_date": "2016-11-16T09:19:59Z",
      "author": {
        "login": "richiprosima",
        "type": "User",
        "stats": {
          "total_commits": 453,
          "average_weekly_commits": 0.7947368421052632,
          "total_additions": 72181,
          "total_deletions": 66022,
          "weeks_active": 83
        }
      },
      "commit_message": {
        "title": "Refs #1811. WIP SecurityManager.",
        "length": 32,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 2105,
        "additions": 2021,
        "deletions": 84
      },
      "files": [
        {
          "filename": "include/fastrtps/config.h.in",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -63,4 +63,9 @@\n #endif\n #endif\n \n+// Security\n+#ifndef SECURITY\n+#define SECURITY @HAVE_SECURITY@\n+#endif\n+\n #endif // _FASTRTPS_CONFIG_H_"
        },
        {
          "filename": "include/fastrtps/rtps/common/Token.h",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -132,6 +132,14 @@ class DataHolderHelper\n         static BinaryProperty* find_binary_property(DataHolder& data_holder, const std::string& name);\n \n         static const BinaryProperty* find_binary_property(const DataHolder& data_holder, const std::string& name);\n+\n+        static size_t serialized_size(const DataHolder& data_holder, size_t current_alignment = 0);\n+\n+        static size_t serialized_size(const DataHolderSeq& data_holders, size_t current_alignment = 0);\n+\n+    private:\n+\n+        inline static size_t alignment(size_t current_alignment, size_t dataSize) { return (dataSize - (current_alignment % dataSize)) & (dataSize-1);}\n };\n \n } //namespace rtps"
        },
        {
          "filename": "include/fastrtps/rtps/messages/CDRMessage.h",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -26,6 +26,10 @@\n #include \"../common/Property.h\"\n #include \"../common/BinaryProperty.h\"\n \n+#ifdef SECURITY\n+#include \"../security/common/ParticipantGenericMessage.h\"\n+#endif\n+\n using namespace eprosima::fastrtps;\n \n namespace eprosima {\n@@ -53,6 +57,7 @@ namespace CDRMessage{\n \t  inline bool readDataReversed(CDRMessage_t* msg, octet* o, uint32_t length);\n \t  inline bool readInt32(CDRMessage_t* msg,int32_t* lo);\n \t  inline bool readUInt32(CDRMessage_t* msg, uint32_t* ulo);\n+\t  inline bool readInt64(CDRMessage_t* msg, int64_t* lolo);\n \t  inline bool readSequenceNumber(CDRMessage_t* msg, SequenceNumber_t* sn);\n \t  inline bool readInt16(CDRMessage_t* msg,int16_t* i16);\n \t  inline bool readUInt16(CDRMessage_t* msg,uint16_t* i16);\n@@ -63,6 +68,15 @@ namespace CDRMessage{\n \t  inline bool readTimestamp(CDRMessage_t*msg,Time_t* ts);\n \t  inline bool readString(CDRMessage_t*msg,std::string* p_str);\n \t  inline bool readOctetVector(CDRMessage_t*msg,std::vector<octet>* ocvec);\n+\n+      inline bool readProperty(CDRMessage_t* msg, Property& property);\n+      inline bool readBinaryProperty(CDRMessage_t* msg, BinaryProperty& binary_property);\n+      inline bool readPropertySeq(CDRMessage_t* msg, PropertySeq& properties);\n+      inline bool readBinaryPropertySeq(CDRMessage_t* msg, BinaryPropertySeq& binary_properties);\n+      inline bool readDataHolder(CDRMessage_t* msg, DataHolder& data_holder);\n+      inline bool readDataHolderSeq(CDRMessage_t* msg, DataHolderSeq& data_holders);\n+      inline bool readMessageIdentity(CDRMessage_t* msg, ::security::MessageIdentity& message_identity);\n+      inline bool readParticipantGenericMessage(CDRMessage_t* msg, ::security::ParticipantGenericMessage& message);\n \t///@}\n \n \n@@ -121,6 +135,10 @@ namespace CDRMessage{\n       inline bool addPropertySeq(CDRMessage_t* msg, const PropertySeq& properties);\n       inline bool addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties);\n       inline bool addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties, const std::string& property_limit);\n+      inline bool addDataHolder(CDRMessage_t* msg, const DataHolder& data_holder);\n+      inline bool addDataHolderSeq(CDRMessage_t* msg, const DataHolderSeq& data_holders);\n+      inline bool addMessageIdentity(CDRMessage_t* msg, const ::security::MessageIdentity& message_identity);\n+      inline bool addParticipantGenericMessage(CDRMessage_t* msg, const ::security::ParticipantGenericMessage& message);\n }\n \n }"
        },
        {
          "filename": "include/fastrtps/rtps/messages/CDRMessage.hpp",
          "status": "modified",
          "additions": 259,
          "deletions": 10,
          "patch": "@@ -121,6 +121,27 @@ inline bool CDRMessage::readUInt32(CDRMessage_t* msg,uint32_t* ulo) {\n     return true;\n }\n \n+inline bool CDRMessage::readInt64(CDRMessage_t* msg, int64_t* lolo)\n+{\n+    if(msg->pos+8 > msg->length)\n+        return false;\n+\n+    octet* dest = (octet*)lolo;\n+    if(msg->msg_endian == DEFAULT_ENDIAN)\n+    {\n+        for(uint8_t i = 0; i < 8; ++i)\n+            dest[i] = msg->buffer[msg->pos+i];\n+\n+        msg->pos+=8;\n+    }\n+    else\n+    {\n+        readDataReversed(msg, dest, 8);\n+    }\n+\n+    return true;\n+}\n+\n inline bool CDRMessage::readSequenceNumber(CDRMessage_t* msg,SequenceNumber_t* sn) {\n     if(msg->pos+8>msg->length)\n         return false;\n@@ -651,7 +672,7 @@ inline bool CDRMessage::addString(CDRMessage_t*msg, const std::string& in_str)\n \n inline bool CDRMessage::addParameterSampleIdentity(CDRMessage_t *msg, const SampleIdentity &sample_id)\n {\n-    if(msg->pos + 28 >= msg->max_size)\n+    if(msg->pos + 28 > msg->max_size)\n     {\n         return false;\n     }\n@@ -667,45 +688,107 @@ inline bool CDRMessage::addParameterSampleIdentity(CDRMessage_t *msg, const Samp\n \n inline bool CDRMessage::addProperty(CDRMessage_t* msg, const Property& property)\n {\n+    assert(msg);\n+\n     if(property.propagate())\n     {\n-        return CDRMessage::addString(msg, property.name()) &&\n-            CDRMessage::addString(msg, property.value());\n+        if(!CDRMessage::addString(msg, property.name()))\n+            return false;\n+        if(!CDRMessage::addString(msg, property.value()))\n+            return false;\n     }\n \n     return true;\n }\n \n+inline bool CDRMessage::readProperty(CDRMessage_t* msg, Property& property)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::readString(msg, &property.name()))\n+        return false;\n+    if(!CDRMessage::readString(msg, &property.value()))\n+        return false;\n+\n+    return true;\n+}\n+\n inline bool CDRMessage::addBinaryProperty(CDRMessage_t* msg, const BinaryProperty& binary_property)\n {\n+    assert(msg);\n+\n     if(binary_property.propagate())\n-        return CDRMessage::addString(msg, binary_property.name()) &&\n-            CDRMessage::addOctetVector(msg, &binary_property.value());\n+    {\n+        if(!CDRMessage::addString(msg, binary_property.name()))\n+            return false;\n+        if(!CDRMessage::addOctetVector(msg, &binary_property.value()))\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+inline bool CDRMessage::readBinaryProperty(CDRMessage_t* msg, BinaryProperty& binary_property)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::readString(msg, &binary_property.name()))\n+        return false;\n+    if(!CDRMessage::readOctetVector(msg, &binary_property.value()))\n+        return false;\n \n     return true;\n }\n \n inline bool CDRMessage::addPropertySeq(CDRMessage_t* msg, const PropertySeq& properties)\n {\n+    assert(msg);\n+\n     bool returnedValue = false;\n \n-    if(msg->pos + 4 <  msg->max_size)\n+    if(msg->pos + 4 <=  msg->max_size)\n     {\n-        if(CDRMessage::addUInt32(msg, (uint32_t)properties.size()))\n+        uint32_t number_to_serialize = 0;\n+        for(auto it = properties.begin(); it != properties.end(); ++it)\n+            if(it->propagate())\n+                ++number_to_serialize;\n+\n+        if(CDRMessage::addUInt32(msg, number_to_serialize))\n         {\n+            returnedValue = true;\n             for(auto it = properties.begin(); returnedValue && it != properties.end(); ++it)\n-                returnedValue = CDRMessage::addProperty(msg, *it);\n+                if(it->propagate())\n+                    returnedValue = CDRMessage::addProperty(msg, *it);\n         }\n     }\n \n     return returnedValue;\n }\n \n+inline bool CDRMessage::readPropertySeq(CDRMessage_t* msg, PropertySeq& properties)\n+{\n+    assert(msg);\n+\n+    uint32_t length = 0;\n+    if(!CDRMessage::readUInt32(msg, &length))\n+        return false;\n+\n+    properties.resize(length);\n+    bool returnedValue = true;\n+    for(uint32_t i = 0; returnedValue && i < length; ++i)\n+        returnedValue = CDRMessage::readProperty(msg, properties.at(i));\n+\n+    return returnedValue;\n+\n+}\n+\n inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties)\n {\n+    assert(msg);\n+\n     bool returnedValue = false;\n \n-    if(msg->pos + 4 <  msg->max_size)\n+    if(msg->pos + 4 <=  msg->max_size)\n     {\n         uint32_t number_to_serialize = 0;\n         for(auto it = binary_properties.begin(); it != binary_properties.end(); ++it)\n@@ -726,9 +809,11 @@ inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryProp\n \n inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties, const std::string& property_limit)\n {\n+    assert(msg);\n+\n     bool returnedValue = false;\n \n-    if(msg->pos + 4 <  msg->max_size)\n+    if(msg->pos + 4 <=  msg->max_size)\n     {\n         uint32_t position = 0;\n         uint32_t number_to_serialize = 0;\n@@ -752,6 +837,170 @@ inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryProp\n     return returnedValue;\n }\n \n+inline bool CDRMessage::readBinaryPropertySeq(CDRMessage_t* msg, BinaryPropertySeq& binary_properties)\n+{\n+    assert(msg);\n+\n+    uint32_t length = 0;\n+    if(!CDRMessage::readUInt32(msg, &length))\n+        return false;\n+\n+    binary_properties.resize(length);\n+    bool returnedValue = true;\n+    for(uint32_t i = 0; returnedValue && i < length; ++i)\n+        returnedValue = CDRMessage::readBinaryProperty(msg, binary_properties.at(i));\n+\n+    return returnedValue;\n+}\n+\n+inline bool CDRMessage::addDataHolder(CDRMessage_t* msg, const DataHolder& data_holder)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::addString(msg, data_holder.class_id()))\n+        return false;\n+    if(!CDRMessage::addPropertySeq(msg, data_holder.properties()))\n+        return false;\n+    if(!CDRMessage::addBinaryPropertySeq(msg, data_holder.binary_properties()))\n+        return false;\n+\n+    return true;\n+}\n+\n+inline bool CDRMessage::readDataHolder(CDRMessage_t* msg, DataHolder& data_holder)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::readString(msg, &data_holder.class_id()))\n+        return false;\n+    if(!CDRMessage::readPropertySeq(msg, data_holder.properties()))\n+        return false;\n+    if(!CDRMessage::readBinaryPropertySeq(msg, data_holder.binary_properties()))\n+        return false;\n+\n+    return true;\n+\n+}\n+\n+inline bool CDRMessage::addDataHolderSeq(CDRMessage_t* msg, const DataHolderSeq& data_holders)\n+{\n+    assert(msg);\n+\n+    bool returnedValue = false;\n+\n+    if(msg->pos + 4 <=  msg->max_size)\n+    {\n+        if(CDRMessage::addUInt32(msg, data_holders.size()))\n+        {\n+            returnedValue = true;\n+            for(auto data_holder = data_holders.begin(); returnedValue && data_holder != data_holders.end(); ++data_holder)\n+                returnedValue = CDRMessage::addDataHolder(msg, *data_holder);\n+        }\n+    }\n+\n+    return returnedValue;\n+}\n+\n+inline bool CDRMessage::readDataHolderSeq(CDRMessage_t* msg, DataHolderSeq& data_holders)\n+{\n+    assert(msg);\n+\n+    uint32_t length = 0;\n+    if(!CDRMessage::readUInt32(msg, &length))\n+        return false;\n+\n+    data_holders.resize(length);\n+    bool returnedValue = true;\n+    for(uint32_t i = 0; returnedValue && i < length; ++i)\n+        returnedValue = CDRMessage::readDataHolder(msg, data_holders.at(i));\n+\n+    return returnedValue;\n+}\n+\n+inline bool CDRMessage::addMessageIdentity(CDRMessage_t* msg, const ::security::MessageIdentity& message_identity)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::addData(msg, message_identity.source_guid().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::addData(msg, message_identity.source_guid().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::addInt64(msg, message_identity.sequence_number()))\n+        return false;\n+\n+    return true;\n+}\n+\n+inline bool CDRMessage::readMessageIdentity(CDRMessage_t* msg, ::security::MessageIdentity& message_identity)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::readData(msg, message_identity.source_guid().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::readData(msg, message_identity.source_guid().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::readInt64(msg, &message_identity.sequence_number()))\n+        return false;\n+\n+    return true;\n+}\n+\n+inline bool CDRMessage::addParticipantGenericMessage(CDRMessage_t* msg, const ::security::ParticipantGenericMessage& message)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::addMessageIdentity(msg, message.message_identity()))\n+        return false;\n+    if(!CDRMessage::addMessageIdentity(msg, message.related_message_identity()))\n+        return false;\n+    if(!CDRMessage::addData(msg, message.destination_participant_key().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::addData(msg, message.destination_participant_key().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::addData(msg, message.destination_endpoint_key().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::addData(msg, message.destination_endpoint_key().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::addData(msg, message.source_endpoint_key().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::addData(msg, message.source_endpoint_key().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::addString(msg, message.message_class_id()))\n+        return false;\n+    if(!CDRMessage::addDataHolderSeq(msg, message.message_data()))\n+        return false;\n+\n+    return true;\n+}\n+\n+inline bool CDRMessage::readParticipantGenericMessage(CDRMessage_t* msg, ::security::ParticipantGenericMessage& message)\n+{\n+    assert(msg);\n+\n+    if(!CDRMessage::readMessageIdentity(msg, message.message_identity()))\n+        return false;\n+    if(!CDRMessage::readMessageIdentity(msg, message.related_message_identity()))\n+        return false;\n+    if(!CDRMessage::readData(msg, message.destination_participant_key().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::readData(msg, message.destination_participant_key().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::readData(msg, message.destination_endpoint_key().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::readData(msg, message.destination_endpoint_key().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::readData(msg, message.source_endpoint_key().guidPrefix.value, GuidPrefix_t::size))\n+        return false;\n+    if(!CDRMessage::readData(msg, message.source_endpoint_key().entityId.value, EntityId_t::size))\n+        return false;\n+    if(!CDRMessage::readString(msg, &message.message_class_id()))\n+        return false;\n+    if(!CDRMessage::readDataHolderSeq(msg, message.message_data()))\n+        return false;\n+\n+    return true;\n+}\n+\n }\n } /* namespace rtps */\n } /* namespace eprosima */"
        },
        {
          "filename": "include/fastrtps/rtps/security/common/ParticipantGenericMessage.h",
          "status": "added",
          "additions": 346,
          "deletions": 0,
          "patch": "@@ -0,0 +1,346 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#ifndef _RTPS_SECURITY_COMMON_PARTICIPANTGENERICMESSAGE_H_\n+#define _RTPS_SECURITY_COMMON_PARTICIPANTGENERICMESSAGE_H_\n+\n+#include \"../../common/Guid.h\"\n+#include \"../../common/Token.h\"\n+\n+namespace eprosima {\n+namespace fastrtps {\n+namespace rtps {\n+namespace security {\n+\n+class MessageIdentity\n+{\n+    public:\n+\n+        MessageIdentity() : sequence_number_(0) {}\n+\n+        MessageIdentity(const MessageIdentity& mi) :\n+            source_guid_(mi.source_guid_),\n+            sequence_number_(mi.sequence_number_)\n+        {\n+        }\n+\n+        MessageIdentity(MessageIdentity&& mi) :\n+            source_guid_(std::move(mi.source_guid_)),\n+            sequence_number_(mi.sequence_number_)\n+        {\n+        }\n+\n+        MessageIdentity& operator=(const MessageIdentity& mi)\n+        {\n+            source_guid_ = mi.source_guid_;\n+            sequence_number_ = mi.sequence_number_;\n+            return *this;\n+        }\n+\n+        MessageIdentity& operator=(MessageIdentity&& mi)\n+        {\n+            source_guid_ = std::move(mi.source_guid_);\n+            sequence_number_ = mi.sequence_number_;\n+            return *this;\n+        }\n+\n+        void source_guid(const GUID_t& source_guid)\n+        {\n+            source_guid_ = source_guid;\n+        }\n+\n+        void source_guid(GUID_t&& source_guid)\n+        {\n+            source_guid_ = std::move(source_guid);\n+        }\n+\n+        const GUID_t& source_guid() const\n+        {\n+            return source_guid_;\n+        }\n+\n+        GUID_t& source_guid()\n+        {\n+            return source_guid_;\n+        }\n+\n+        void sequence_number(int64_t sequence_number)\n+        {\n+            sequence_number_ = sequence_number;\n+        }\n+\n+        int64_t sequence_number() const\n+        {\n+            return sequence_number_;\n+        }\n+\n+        int64_t& sequence_number()\n+        {\n+            return sequence_number_;\n+        }\n+\n+    private:\n+\n+        GUID_t source_guid_;\n+        int64_t sequence_number_;\n+};\n+\n+class MessageIdentityHelper\n+{\n+    public:\n+\n+        static size_t serialized_size(const MessageIdentity& /*message*/, size_t current_alignment = 0)\n+        {\n+            size_t initial_alignment = current_alignment;\n+\n+            current_alignment += 16;\n+            current_alignment +=  alignment(current_alignment, 8) + 8;\n+\n+            return current_alignment - initial_alignment;\n+        }\n+\n+    private:\n+\n+        inline static size_t alignment(size_t current_alignment, size_t dataSize) { return (dataSize - (current_alignment % dataSize)) & (dataSize-1);}\n+};\n+\n+class ParticipantGenericMessage\n+{\n+    public:\n+\n+        ParticipantGenericMessage() {}\n+\n+        ParticipantGenericMessage(const ParticipantGenericMessage& message) :\n+            message_identity_(message.message_identity_),\n+            related_message_identity_(message.related_message_identity_),\n+            destination_participant_key_(message.destination_participant_key_),\n+            destination_endpoint_key_(message.destination_endpoint_key_),\n+            source_endpoint_key_(message.source_endpoint_key_),\n+            message_class_id_(message.message_class_id_),\n+            message_data_(message.message_data_)\n+        {}\n+\n+        ParticipantGenericMessage(ParticipantGenericMessage&& message) :\n+            message_identity_(std::move(message.message_identity_)),\n+            related_message_identity_(std::move(message.related_message_identity_)),\n+            destination_participant_key_(std::move(message.destination_participant_key_)),\n+            destination_endpoint_key_(std::move(message.destination_endpoint_key_)),\n+            source_endpoint_key_(std::move(message.source_endpoint_key_)),\n+            message_class_id_(std::move(message.message_class_id_)),\n+            message_data_(std::move(message.message_data_))\n+        {}\n+\n+        ParticipantGenericMessage& operator=(const ParticipantGenericMessage& message)\n+        {\n+            message_identity_ = message.message_identity_;\n+            related_message_identity_ = message.related_message_identity_;\n+            destination_participant_key_ = message.destination_participant_key_;\n+            destination_endpoint_key_ = message.destination_endpoint_key_;\n+            source_endpoint_key_ = message.source_endpoint_key_;\n+            message_class_id_ = message.message_class_id_;\n+            message_data_ = message.message_data_;\n+            return *this;\n+        }\n+\n+        ParticipantGenericMessage& operator=(ParticipantGenericMessage&& message)\n+        {\n+            message_identity_ = std::move(message.message_identity_);\n+            related_message_identity_ = std::move(message.related_message_identity_);\n+            destination_participant_key_ = std::move(message.destination_participant_key_);\n+            destination_endpoint_key_ = std::move(message.destination_endpoint_key_);\n+            source_endpoint_key_ = std::move(message.source_endpoint_key_);\n+            message_class_id_ = std::move(message.message_class_id_);\n+            message_data_ = std::move(message.message_data_);\n+            return *this;\n+        }\n+\n+        void message_identity(const MessageIdentity& message_identity)\n+        {\n+            message_identity_ = message_identity;\n+        }\n+\n+        void message_identity(MessageIdentity&& message_identity)\n+        {\n+            message_identity_ = std::move(message_identity);\n+        }\n+\n+        const MessageIdentity& message_identity() const\n+        {\n+            return message_identity_;\n+        }\n+\n+        MessageIdentity& message_identity()\n+        {\n+            return message_identity_;\n+        }\n+\n+        void related_message_identity(const MessageIdentity& related_message_identity)\n+        {\n+            related_message_identity_ = related_message_identity;\n+        }\n+\n+        void related_message_identity(MessageIdentity&& related_message_identity)\n+        {\n+            related_message_identity_ = std::move(related_message_identity);\n+        }\n+\n+        const MessageIdentity& related_message_identity() const\n+        {\n+            return related_message_identity_;\n+        }\n+\n+        MessageIdentity& related_message_identity()\n+        {\n+            return related_message_identity_;\n+        }\n+\n+        void destination_participant_key(const GUID_t& destination_participant_key)\n+        {\n+            destination_participant_key_ = destination_participant_key;\n+        }\n+\n+        void destination_participant_key(GUID_t&& destination_participant_key)\n+        {\n+            destination_participant_key_ = std::move(destination_participant_key);\n+        }\n+\n+        const GUID_t& destination_participant_key() const\n+        {\n+            return destination_participant_key_;\n+        }\n+\n+        GUID_t& destination_participant_key()\n+        {\n+            return destination_participant_key_;\n+        }\n+\n+        void destination_endpoint_key(const GUID_t& destination_endpoint_key)\n+        {\n+            destination_endpoint_key_ = destination_endpoint_key;\n+        }\n+\n+        void destination_endpoint_key(GUID_t&& destination_endpoint_key)\n+        {\n+            destination_endpoint_key_ = std::move(destination_endpoint_key);\n+        }\n+\n+        const GUID_t& destination_endpoint_key() const\n+        {\n+            return destination_endpoint_key_;\n+        }\n+\n+        GUID_t& destination_endpoint_key()\n+        {\n+            return destination_endpoint_key_;\n+        }\n+\n+        void source_endpoint_key(const GUID_t& source_endpoint_key)\n+        {\n+            source_endpoint_key_ = source_endpoint_key;\n+        }\n+\n+        void source_endpoint_key(GUID_t&& source_endpoint_key)\n+        {\n+            source_endpoint_key_ = std::move(source_endpoint_key);\n+        }\n+\n+        const GUID_t& source_endpoint_key() const\n+        {\n+            return source_endpoint_key_;\n+        }\n+\n+        GUID_t& source_endpoint_key()\n+        {\n+            return source_endpoint_key_;\n+        }\n+\n+        void message_class_id(const std::string& message_class_id)\n+        {\n+            message_class_id_ = message_class_id;\n+        }\n+\n+        void message_class_id(std::string&& message_class_id)\n+        {\n+            message_class_id_ = std::move(message_class_id);\n+        }\n+\n+        const std::string& message_class_id() const\n+        {\n+            return message_class_id_;\n+        }\n+\n+        std::string& message_class_id()\n+        {\n+            return message_class_id_;\n+        }\n+\n+        void message_data(const DataHolderSeq& message_data)\n+        {\n+            message_data_ = message_data;\n+        }\n+\n+        void message_data(DataHolderSeq&& message_data)\n+        {\n+            message_data_ = std::move(message_data);\n+        }\n+\n+        const DataHolderSeq& message_data() const\n+        {\n+            return message_data_;\n+        }\n+\n+        DataHolderSeq& message_data()\n+        {\n+            return message_data_;\n+        }\n+\n+    private:\n+\n+        MessageIdentity message_identity_;\n+        MessageIdentity related_message_identity_;\n+        GUID_t destination_participant_key_;\n+        GUID_t destination_endpoint_key_;\n+        GUID_t source_endpoint_key_;\n+        std::string message_class_id_;\n+        DataHolderSeq message_data_;\n+};\n+\n+class ParticipantGenericMessageHelper\n+{\n+    public:\n+\n+        static size_t serialized_size(const ParticipantGenericMessage& message, size_t current_alignment = 0)\n+        {\n+            size_t initial_alignment = current_alignment;\n+\n+            current_alignment += MessageIdentityHelper::serialized_size(message.message_identity(), current_alignment);\n+            current_alignment += MessageIdentityHelper::serialized_size(message.related_message_identity(), current_alignment);\n+            current_alignment += 16 * 3;\n+            current_alignment += 4 + alignment(current_alignment, 4) + message.message_class_id().size() + 1;\n+            current_alignment += DataHolderHelper::serialized_size(message.message_data(), current_alignment);\n+\n+            return current_alignment - initial_alignment;\n+        }\n+\n+    private:\n+\n+        inline static size_t alignment(size_t current_alignment, size_t dataSize) { return (dataSize - (current_alignment % dataSize)) & (dataSize-1);}\n+};\n+\n+} //namespace security\n+} //namespace rtps\n+} //namespace fastrtps\n+} //namespace eprosima\n+\n+#endif // _RTPS_SECURITY_COMMON_PARTICIPANTGENERICMESSAGE_H_"
        },
        {
          "filename": "src/cpp/CMakeLists.txt",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -121,6 +121,10 @@ if(SECURITY)\n \n     include_directories(${OPENSSL_INCLUDE_DIR})\n     set(EXTRA_LIBRARIES ${EXTRA_LIBRARIES} ${OPENSSL_LIBRARIES})\n+\n+    set(HAVE_SECURITY 1)\n+else()\n+    set(HAVE_SECURITY 0)\n endif()\n \n # Set version"
        },
        {
          "filename": "src/cpp/rtps/common/Token.cpp",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -147,3 +147,25 @@ const BinaryProperty* DataHolderHelper::find_binary_property(const DataHolder& d\n \n     return returnedValue;\n }\n+\n+size_t DataHolderHelper::serialized_size(const DataHolder& data_holder, size_t current_alignment)\n+{\n+    size_t initial_alignment = current_alignment;\n+\n+    current_alignment += 4 + alignment(current_alignment, 4) + data_holder.class_id().size() + 1;\n+    current_alignment += PropertyHelper::serialized_size(data_holder.properties(), current_alignment);\n+    current_alignment += BinaryPropertyHelper::serialized_size(data_holder.binary_properties(), current_alignment);\n+\n+    return current_alignment - initial_alignment;\n+}\n+\n+size_t DataHolderHelper::serialized_size(const DataHolderSeq& data_holders, size_t current_alignment)\n+{\n+    size_t initial_alignment = current_alignment;\n+\n+    current_alignment += 4 + alignment(current_alignment, 4);\n+    for(auto data_holder = data_holders.begin(); data_holder != data_holders.end(); ++data_holder)\n+        current_alignment += serialized_size(*data_holder, current_alignment);\n+\n+    return current_alignment - initial_alignment;\n+}"
        },
        {
          "filename": "src/cpp/rtps/security/SecurityManager.cpp",
          "status": "modified",
          "additions": 361,
          "deletions": 48,
          "patch": "@@ -16,6 +16,11 @@\n #define ENTITYID_P2P_BUILTIN_PARTICIPANT_STATELESS_WRITER  0x000201C2\n #define ENTITYID_P2P_BUILTIN_PARTICIPANT_STATELESS_READER  0x000201C7\n \n+#define AUTHENTICATION_PARTICIPANT_STATELESS_MESSAGE \"dds.sec.auth\"\n+\n+// TODO(Ricardo) Add event because stateless messages can be not received.\n+// TODO(Ricardo) Add following of sequence in stateless messages.\n+\n const EntityId_t participant_stateless_message_writer_entity_id = ENTITYID_P2P_BUILTIN_PARTICIPANT_STATELESS_WRITER;\n const EntityId_t participant_stateless_message_reader_entity_id = ENTITYID_P2P_BUILTIN_PARTICIPANT_STATELESS_READER;\n \n@@ -29,7 +34,9 @@ bool usleep_bool()\n     return true;\n }\n \n-SecurityManager::SecurityManager(RTPSParticipantImpl *participant) : participant_(participant),\n+SecurityManager::SecurityManager(RTPSParticipantImpl *participant) : \n+    participant_stateless_message_listener_(*this),\n+    participant_(participant),\n     participant_stateless_message_writer_(nullptr),\n     participant_stateless_message_writer_history_(nullptr),\n     participant_stateless_message_reader_(nullptr),\n@@ -42,7 +49,31 @@ SecurityManager::SecurityManager(RTPSParticipantImpl *participant) : participant\n SecurityManager::~SecurityManager()\n {\n     if(authentication_plugin_ != nullptr)\n+    {\n+        SecurityException exception;\n+\n+        for(auto& dp_it : discovered_participants_)\n+        {\n+            if(!dp_it.second.is_handshake_handle_null())\n+            {\n+                HandshakeHandle* handle = dp_it.second.get_handshake_handle();\n+                authentication_plugin_->return_handshake_handle(handle, exception);\n+            }\n+\n+            if(!dp_it.second.is_identity_handle_null())\n+            {\n+                IdentityHandle* handle = dp_it.second.get_identity_handle();\n+                authentication_plugin_->return_identity_handle(handle, exception);\n+            }\n+        }\n+\n+        if(local_identity_handle_ != nullptr)\n+            authentication_plugin_->return_identity_handle(local_identity_handle_, exception);\n+\n+        delete_entities();\n+\n         delete authentication_plugin_;\n+    }\n }\n \n bool SecurityManager::init()\n@@ -109,7 +140,8 @@ void SecurityManager::remove_discovered_participant_info(const GUID_t remote_par\n }\n \n void SecurityManager::restore_remote_identity_handle(const GUID_t& remote_participant_key,\n-        IdentityHandle* remote_identity_handle)\n+        IdentityHandle* remote_identity_handle,\n+        HandshakeHandle* handshake_handle)\n {\n     SecurityException exception;\n \n@@ -120,14 +152,24 @@ void SecurityManager::restore_remote_identity_handle(const GUID_t& remote_partic\n     {\n         assert(dp_it->second.is_identity_handle_null());\n         dp_it->second.set_identity_handle(remote_identity_handle);\n+        assert(dp_it->second.is_handshake_handle_null());\n+        dp_it->second.set_handshake_handle(handshake_handle);\n     }\n     else\n+    {\n         authentication_plugin_->return_identity_handle(remote_identity_handle, exception);\n+\n+        if(handshake_handle)\n+            authentication_plugin_->return_handshake_handle(handshake_handle, exception);\n+    }\n }\n \n bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n         const GUID_t& remote_participant_key)\n {\n+    if(authentication_plugin_ == nullptr)\n+        return true;\n+\n     IdentityHandle* remote_identity_handle = nullptr;\n     SecurityException exception;\n     AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n@@ -193,10 +235,14 @@ bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_tok\n             return false;\n     }\n \n+    int64_t last_sequence_number = 0;\n+\n     if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n     {\n         remote_identity_handle = dp_it->second.get_identity_handle();\n         assert(remote_identity_handle);\n+        last_sequence_number = dp_it->second.get_last_sequence_number();\n+\n     }\n     mutex_.unlock();\n \n@@ -205,82 +251,188 @@ bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_tok\n     // Maybe send request.\n     if(remote_identity_handle != nullptr)\n     {\n-        returnedValue = on_request_not_send(remote_participant_key, remote_identity_handle);\n+        returnedValue = on_process_handshake(remote_participant_key, AUTHENTICATION_REQUEST_NOT_SEND,\n+                MessageIdentity(), HandshakeMessageToken(),\n+                remote_identity_handle, nullptr, last_sequence_number);\n     }\n \n     return returnedValue;\n }\n \n-bool SecurityManager::on_request_not_send(const GUID_t& remote_participant_key,\n-        IdentityHandle* remote_identity_handle)\n+bool SecurityManager::on_process_handshake(const GUID_t& remote_participant_key,\n+        AuthenticationStatus pre_auth_status,\n+        MessageIdentity&& message_identity,\n+        HandshakeMessageToken&& message_in,\n+        IdentityHandle* remote_identity_handle,\n+        HandshakeHandle* handshake_handle, int64_t last_sequence_number)\n {\n     assert(remote_identity_handle);\n \n-    HandshakeHandle* handshake_handle = nullptr;\n     HandshakeMessageToken* handshake_message = nullptr;\n     SecurityException exception;\n     \n-    ValidationResult_t ret = authentication_plugin_->begin_handshake_request(&handshake_handle,\n+    ValidationResult_t ret = VALIDATION_FAILED;\n+    \n+    if(pre_auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n+    {\n+        ret = authentication_plugin_->begin_handshake_request(&handshake_handle,\n                 &handshake_message,\n                 *local_identity_handle_,\n                 *remote_identity_handle,\n                 exception);\n+    }\n+    else if(pre_auth_status == AUTHENTICATION_WAITING_REQUEST)\n+    {\n+        assert(!handshake_handle);\n+        ret = authentication_plugin_->begin_handshake_reply(&handshake_handle,\n+                &handshake_message,\n+                std::move(message_in),\n+                *remote_identity_handle,\n+                *local_identity_handle_,\n+                exception);\n+    }\n+    else if(pre_auth_status == AUTHENTICATION_WAITING_REPLY ||\n+            pre_auth_status == AUTHENTICATION_WAITING_FINAL)\n+    {\n+        assert(handshake_handle);\n+        ret = authentication_plugin_->process_handshake(&handshake_message,\n+                std::move(message_in),\n+                *handshake_handle, \n+                exception);\n+    }\n \n     if(ret == VALIDATION_FAILED)\n     {\n-        restore_remote_identity_handle(remote_participant_key, remote_identity_handle);\n+        restore_remote_identity_handle(remote_participant_key, remote_identity_handle, handshake_handle);\n         return false;\n     }\n \n     assert(handshake_handle);\n-    assert(handshake_message);\n \n-    // Send hanshake message\n-    // \n-    delete handshake_message;\n+    bool handshake_message_send = true;\n \n-    AuthenticationStatus auth_status = AUTHENTICATION_FAILED;\n-\n-    switch(ret)\n+    if(ret == VALIDATION_PENDING_HANDSHAKE_MESSAGE ||\n+            ret == VALIDATION_OK_WITH_FINAL_MESSAGE)\n     {\n-        case VALIDATION_OK:\n-            auth_status = AUTHENTICATION_OK;\n-            break;\n-        case VALIDATION_PENDING_HANDSHAKE_MESSAGE:\n-            auth_status = AUTHENTICATION_WAITING_REPLY;\n-            break;\n-        case VALIDATION_OK_WITH_FINAL_MESSAGE:\n-            auth_status = AUTHENTICATION_OK;\n-            break;\n-        case VALIDATION_PENDING_RETRY:\n-            // TODO(Ricardo) Send event.\n-        default:\n-            restore_remote_identity_handle(remote_participant_key, remote_identity_handle);\n-            return false;\n-    };\n+        handshake_message_send = false;\n \n-    // Store status\n-    std::unique_lock<std::mutex> lock(mutex_);\n+        assert(handshake_message);\n \n-    auto dp_it = discovered_participants_.find(remote_participant_key);\n+        // Send hanshake message\n \n-    if(dp_it != discovered_participants_.end())\n+        // Create message\n+        ParticipantGenericMessage message = generate_authentication_message(last_sequence_number,\n+                std::move(message_identity), remote_participant_key, std::move(*handshake_message));\n+\n+        CacheChange_t* change = participant_stateless_message_writer_->new_change([&message]() -> uint32_t\n+                {\n+                return ParticipantGenericMessageHelper::serialized_size(message);\n+                }\n+                , ALIVE, c_InstanceHandle_Unknown);\n+\n+        if(change != nullptr)\n+        {\n+            // Serialize message\n+            CDRMessage_t aux_msg(0);\n+            aux_msg.wraps = true;\n+            aux_msg.buffer = change->serializedPayload.data;\n+            aux_msg.length = change->serializedPayload.length;\n+            aux_msg.max_size = change->serializedPayload.max_size;\n+            aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+\n+            if(CDRMessage::addParticipantGenericMessage(&aux_msg, message))\n+            {\n+                // Send\n+                if(participant_stateless_message_writer_history_->add_change(change))\n+                {\n+                    handshake_message_send = true;\n+                }\n+                else\n+                {\n+                    logError(SECURITY, \"WriterHistory cannot add the CacheChange_t\");\n+                }\n+            }\n+            else\n+            {\n+                logError(SECURITY, \"Cannot serialize ParticipantGenericMessage\");\n+            }\n+        }\n+        else\n+        {\n+            logError(SECURITY, \"WriterHistory cannot retrieve a CacheChange_t\");\n+        }\n+    }\n+\n+    bool returnedValue = false;\n+\n+    if(handshake_message_send)\n     {\n-        assert(dp_it->second.get_auth_status() == AUTHENTICATION_REQUEST_NOT_SEND);\n-        dp_it->second.set_auth_status(auth_status);\n-        assert(dp_it->second.is_identity_handle_null());\n-        dp_it->second.set_identity_handle(remote_identity_handle);\n-        assert(dp_it->second.is_handshake_handle_null());\n-        dp_it->second.set_handshake_handle(handshake_handle);\n+        AuthenticationStatus auth_status = AUTHENTICATION_FAILED;\n+\n+        switch(ret)\n+        {\n+            case VALIDATION_OK:\n+            case VALIDATION_PENDING_HANDSHAKE_MESSAGE:\n+            case VALIDATION_OK_WITH_FINAL_MESSAGE:\n+                {\n+                    auth_status = AUTHENTICATION_OK;\n+                    if(ret == VALIDATION_PENDING_HANDSHAKE_MESSAGE)\n+                    {\n+                        if(pre_auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n+                            auth_status = AUTHENTICATION_WAITING_REPLY;\n+                        else if(pre_auth_status == AUTHENTICATION_WAITING_REQUEST)\n+                            auth_status = AUTHENTICATION_WAITING_FINAL;\n+                    }\n+\n+                    // Store status\n+                    std::unique_lock<std::mutex> lock(mutex_);\n+\n+                    auto dp_it = discovered_participants_.find(remote_participant_key);\n+\n+                    if(dp_it != discovered_participants_.end())\n+                    {\n+                        assert(dp_it->second.get_auth_status() == pre_auth_status);\n+                        dp_it->second.set_auth_status(auth_status);\n+                        assert(dp_it->second.is_identity_handle_null());\n+                        dp_it->second.set_identity_handle(remote_identity_handle);\n+                        remote_identity_handle = nullptr;\n+                        assert(dp_it->second.is_handshake_handle_null());\n+                        dp_it->second.set_handshake_handle(handshake_handle);\n+                        handshake_handle = nullptr;\n+                        if(ret == VALIDATION_PENDING_HANDSHAKE_MESSAGE ||\n+                                ret == VALIDATION_OK_WITH_FINAL_MESSAGE)\n+                            dp_it->second.set_last_sequence_number(++last_sequence_number);\n+\n+                        returnedValue = true;\n+                    }\n+                    else\n+                    {\n+                        authentication_plugin_->return_handshake_handle(handshake_handle, exception);\n+                        handshake_handle = nullptr;\n+                        authentication_plugin_->return_identity_handle(remote_identity_handle, exception);\n+                        remote_identity_handle = nullptr;\n+                    }\n+                }\n+                break;\n+            case VALIDATION_PENDING_RETRY:\n+                // TODO(Ricardo) Send event.\n+            default:\n+                break;\n+        };\n     }\n-    else\n+\n+    if(handshake_handle != nullptr && (pre_auth_status == AUTHENTICATION_REQUEST_NOT_SEND ||\n+                pre_auth_status == AUTHENTICATION_WAITING_REQUEST))\n     {\n         authentication_plugin_->return_handshake_handle(handshake_handle, exception);\n-        authentication_plugin_->return_identity_handle(remote_identity_handle, exception);\n-        return false;\n+        handshake_handle = nullptr;\n     }\n+    if(remote_identity_handle != nullptr)\n+        restore_remote_identity_handle(remote_participant_key, remote_identity_handle, handshake_handle);\n \n-    return true;\n+    delete handshake_message;\n+\n+    return returnedValue;\n }\n \n bool SecurityManager::create_entities()\n@@ -293,6 +445,11 @@ bool SecurityManager::create_entities()\n     return false; \n }\n \n+void SecurityManager::delete_entities()\n+{\n+    delete_participant_stateless_message_entities();\n+}\n+\n bool SecurityManager::create_participant_stateless_message_entities()\n {\n     if(create_participant_stateless_message_writer())\n@@ -334,6 +491,7 @@ bool SecurityManager::create_participant_stateless_message_writer()\n     if(participant_->createWriter(&wout, watt, participant_stateless_message_writer_history_, nullptr, participant_stateless_message_writer_entity_id, true))\n     {\n         participant_stateless_message_writer_ = dynamic_cast<StatelessWriter*>(wout);\n+        auth_source_guid = participant_stateless_message_writer_->getGuid();\n \n         return true;\n     }\n@@ -348,10 +506,16 @@ bool SecurityManager::create_participant_stateless_message_writer()\n void SecurityManager::delete_participant_stateless_message_writer()\n {\n     if(participant_stateless_message_writer_ != nullptr)\n+    {\n         delete participant_stateless_message_writer_;\n+        participant_stateless_message_writer_ = nullptr;\n+    }\n \n     if(participant_stateless_message_writer_history_ != nullptr)\n+    {\n         delete participant_stateless_message_writer_history_;\n+        participant_stateless_message_writer_history_ = nullptr;\n+    }\n }\n \n bool SecurityManager::create_participant_stateless_message_reader()\n@@ -364,10 +528,10 @@ bool SecurityManager::create_participant_stateless_message_reader()\n     ReaderAttributes ratt;\n     ratt.endpoint.topicKind = NO_KEY;\n     ratt.endpoint.reliabilityKind = BEST_EFFORT;\n-    //mp_listener = new PDPSimpleListener(this);\n \n     RTPSReader* rout = nullptr;\n-    if(participant_->createReader(&rout, ratt, participant_stateless_message_reader_history_, nullptr, participant_stateless_message_reader_entity_id, true, false))\n+    if(participant_->createReader(&rout, ratt, participant_stateless_message_reader_history_, &participant_stateless_message_listener_,\n+                participant_stateless_message_reader_entity_id, true, false))\n     {\n         participant_stateless_message_reader_ = dynamic_cast<StatelessReader*>(rout);\n \n@@ -377,16 +541,165 @@ bool SecurityManager::create_participant_stateless_message_reader()\n     logError(SECURITY,\"Participant Stateless Message Reader creation failed\");\n     delete(participant_stateless_message_reader_history_);\n     participant_stateless_message_reader_history_ = nullptr;\n-    //delete(mp_listener);\n-    //mp_listener = nullptr;\n     return false;\n }\n \n void SecurityManager::delete_participant_stateless_message_reader()\n {\n     if(participant_stateless_message_reader_ != nullptr)\n+    {\n         delete participant_stateless_message_reader_;\n+        participant_stateless_message_reader_ = nullptr;\n+    }\n \n     if(participant_stateless_message_reader_history_ != nullptr)\n+    {\n         delete participant_stateless_message_reader_history_;\n+        participant_stateless_message_reader_history_ = nullptr;\n+    }\n+}\n+\n+ParticipantGenericMessage SecurityManager::generate_authentication_message(int64_t sequence_number,\n+        const MessageIdentity& related_message_identity,\n+        const GUID_t& destination_participant_key,\n+        HandshakeMessageToken&& handshake_message)\n+{\n+    ParticipantGenericMessage message;\n+\n+    message.message_identity().source_guid(auth_source_guid);\n+    message.message_identity().sequence_number(sequence_number);\n+    message.related_message_identity(related_message_identity);\n+    message.destination_participant_key(destination_participant_key);\n+    message.message_class_id(AUTHENTICATION_PARTICIPANT_STATELESS_MESSAGE);\n+    message.message_data().push_back(std::move(handshake_message));\n+\n+    return message;\n+}\n+\n+void SecurityManager::process_participant_stateless_message(const CacheChange_t* const change)\n+{\n+    assert(change);\n+\n+    // Deserialize message\n+    ParticipantGenericMessage message;\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.length = change->serializedPayload.length;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+\n+    CDRMessage::readParticipantGenericMessage(&aux_msg, message);\n+\n+    if(message.message_class_id().compare(AUTHENTICATION_PARTICIPANT_STATELESS_MESSAGE) == 0)\n+    {\n+        if(message.destination_endpoint_key() != GUID_t::unknown())\n+        {\n+            logInfo(SECURITY, \"Bad ParticipantGenericMessage. destination_endpoint_key is not GUID_t::unknown()\");\n+            return;\n+        }\n+        if(message.source_endpoint_key() != GUID_t::unknown())\n+        {\n+            logInfo(SECURITY, \"Bad ParticipantGenericMessage. source_endpoint_key is not GUID_t::unknown()\");\n+            return;\n+        }\n+\n+        const GUID_t& remote_participant_key = message.destination_participant_key();\n+        AuthenticationStatus auth_status;\n+        IdentityHandle* remote_identity_handle = nullptr;\n+        HandshakeHandle* handshake_handle = nullptr;\n+        int64_t last_sequence_number = 0;\n+\n+        mutex_.lock();\n+        auto dp_it = discovered_participants_.find(remote_participant_key);\n+\n+        if(dp_it != discovered_participants_.end())\n+        {\n+            auth_status = dp_it->second.get_auth_status();\n+            remote_identity_handle = dp_it->second.get_identity_handle();\n+            handshake_handle = dp_it->second.get_handshake_handle();\n+            last_sequence_number = dp_it->second.get_last_sequence_number();\n+        }\n+        else\n+        {\n+            logInfo(SECURITY, \"Received Authentication message but not found related remote_participant_key\");\n+        }\n+        mutex_.unlock();\n+\n+        if(remote_identity_handle != nullptr)\n+        {\n+            if(auth_status == AUTHENTICATION_WAITING_REQUEST)\n+            {\n+                assert(!handshake_handle);\n+\n+                // Preconditions\n+                if(message.message_identity().source_guid() == GUID_t::unknown())\n+                {\n+                    logInfo(SECURITY, \"Bad ParticipantGenericMessage. message_identity.source_guid is GUID_t::unknown()\");\n+                    restore_remote_identity_handle(remote_participant_key, remote_identity_handle);\n+                    return;\n+                }\n+                if(message.related_message_identity().source_guid() != GUID_t::unknown())\n+                {\n+                    logInfo(SECURITY, \"Bad ParticipantGenericMessage. related_message_identity.source_guid is not GUID_t::unknown()\");\n+                    restore_remote_identity_handle(remote_participant_key, remote_identity_handle);\n+                    return;\n+                }\n+                if(message.message_data().size() != 1)\n+                {\n+                    logInfo(SECURITY, \"Bad ParticipantGenericMessage. message_data size is not 1\");\n+                    restore_remote_identity_handle(remote_participant_key, remote_identity_handle);\n+                    return;\n+                }\n+            }\n+            else if(auth_status == AUTHENTICATION_WAITING_REPLY ||\n+                    auth_status == AUTHENTICATION_WAITING_FINAL)\n+            {\n+                assert(handshake_handle);\n+\n+                // Preconditions\n+                if(message.message_identity().source_guid() == GUID_t::unknown())\n+                {\n+                    logInfo(SECURITY, \"Bad ParticipantGenericMessage. message_identity.source_guid is GUID_t::unknown()\");\n+                    restore_remote_identity_handle(remote_participant_key, remote_identity_handle, handshake_handle);\n+                    return;\n+                }\n+                if(message.related_message_identity().source_guid() == GUID_t::unknown())\n+                {\n+                    logInfo(SECURITY, \"Bad ParticipantGenericMessage. related_message_identity.source_guid is GUID_t::unknown()\");\n+                    restore_remote_identity_handle(remote_participant_key, remote_identity_handle, handshake_handle);\n+                    return;\n+                }\n+                if(message.message_data().size() != 1)\n+                {\n+                    logInfo(SECURITY, \"Bad ParticipantGenericMessage. message_data size is not 1\");\n+                    restore_remote_identity_handle(remote_participant_key, remote_identity_handle, handshake_handle);\n+                    return;\n+                }\n+            }\n+            else\n+            {\n+                restore_remote_identity_handle(remote_participant_key, remote_identity_handle, handshake_handle);\n+                return;\n+            }\n+\n+            on_process_handshake(remote_participant_key, auth_status, std::move(message.related_message_identity()),\n+                    std::move(message.message_data().at(0)), remote_identity_handle,\n+                    handshake_handle, last_sequence_number);\n+        }\n+    }\n+    else\n+    {\n+        logInfo(SECURITY, \"Discarted ParticipantGenericMessage with class id \" << message.message_class_id());\n+    }\n+}\n+\n+void SecurityManager::ParticipantStatelessMessageListener::onNewCacheChangeAdded(RTPSReader* reader,\n+        const CacheChange_t* const change)\n+{\n+    manager_.process_participant_stateless_message(change);\n+\n+    ReaderHistory *history = reader->getHistory();\n+    assert(history);\n+    history->remove_change((CacheChange_t*)change);\n }"
        },
        {
          "filename": "src/cpp/rtps/security/SecurityManager.h",
          "status": "modified",
          "additions": 50,
          "deletions": 3,
          "patch": "@@ -21,6 +21,8 @@\n #include \"SecurityPluginFactory.h\"\n \n #include <fastrtps/rtps/security/authentication/Handshake.h>\n+#include <fastrtps/rtps/security/common/ParticipantGenericMessage.h>\n+#include <fastrtps/rtps/reader/ReaderListener.h>\n \n #include <map>\n #include <mutex>\n@@ -71,7 +73,8 @@ class SecurityManager\n \n                 DiscoveredParticipantInfo(AuthenticationStatus auth_status) :\n                     identity_handle_(nullptr), handshake_handle_(nullptr),\n-                    auth_status_(auth_status){}\n+                    auth_status_(auth_status), last_sequence_number_(1)\n+                {}\n \n                 bool is_identity_handle_null()\n                 {\n@@ -129,6 +132,16 @@ class SecurityManager\n                     auth_status_ = auth_status;\n                 }\n \n+                void set_last_sequence_number(int64_t sequence_number)\n+                {\n+                    last_sequence_number_ = sequence_number;\n+                }\n+\n+                int64_t get_last_sequence_number()\n+                {\n+                    return last_sequence_number_;\n+                }\n+\n             private:\n \n                 DiscoveredParticipantInfo(const DiscoveredParticipantInfo& info) = delete;\n@@ -138,11 +151,30 @@ class SecurityManager\n                 HandshakeHandle* handshake_handle_;\n \n                 AuthenticationStatus auth_status_;\n+\n+                int64_t last_sequence_number_;\n         };\n \n+        class ParticipantStatelessMessageListener: public eprosima::fastrtps::rtps::ReaderListener\n+        {\n+            public:\n+                ParticipantStatelessMessageListener(SecurityManager &manager) : manager_(manager) {};\n+\n+                ~ParticipantStatelessMessageListener(){};\n+\n+                void onNewCacheChangeAdded(RTPSReader* reader, const CacheChange_t* const change);\n+\n+            private:\n+\n+                ParticipantStatelessMessageListener& operator=(const ParticipantStatelessMessageListener&) NON_COPYABLE_CXX11;\n+\n+                SecurityManager &manager_;\n+        } participant_stateless_message_listener_;\n+\n         void remove_discovered_participant_info(const GUID_t remote_participant_key);\n         void restore_remote_identity_handle(const GUID_t& remote_participant_key,\n-                IdentityHandle* remote_identity_handle);\n+                IdentityHandle* remote_identity_handle,\n+                HandshakeHandle* handshake_handle = nullptr);\n \n         bool create_entities();\n         void delete_entities();\n@@ -153,7 +185,20 @@ class SecurityManager\n         bool create_participant_stateless_message_reader();\n         void delete_participant_stateless_message_reader();\n \n-        bool on_request_not_send(const GUID_t& remote_participant_key, IdentityHandle* remote_identity_handle);\n+        void process_participant_stateless_message(const CacheChange_t* const change);\n+\n+        bool on_process_handshake(const GUID_t& remote_participant_key,\n+                AuthenticationStatus pre_auth_status,\n+                MessageIdentity&& message_identity,\n+                HandshakeMessageToken&& message,\n+                IdentityHandle* remote_identity_handle,\n+                HandshakeHandle* handshake_handle,\n+                int64_t last_sequence_number);\n+\n+        ParticipantGenericMessage generate_authentication_message(int64_t sequence_number,\n+                const MessageIdentity& related_message_identity,\n+                const GUID_t& destination_participant_key,\n+                HandshakeMessageToken&& handshake_message);\n \n         RTPSParticipantImpl* participant_;\n         StatelessWriter* participant_stateless_message_writer_;\n@@ -168,6 +213,8 @@ class SecurityManager\n \n         std::map<GUID_t, DiscoveredParticipantInfo> discovered_participants_;\n \n+        GUID_t auth_source_guid;\n+\n         std::mutex mutex_;\n };\n "
        },
        {
          "filename": "test/mock/rtps/RTPSParticipantImpl/rtps/participant/RTPSParticipantImpl.h",
          "status": "modified",
          "additions": 25,
          "deletions": 4,
          "patch": "@@ -21,15 +21,15 @@\n \n #include <fastrtps/rtps/attributes/WriterAttributes.h>\n #include <fastrtps/rtps/attributes/ReaderAttributes.h>\n+#include <fastrtps/rtps/writer/RTPSWriter.h>\n+#include <fastrtps/rtps/reader/RTPSReader.h>\n \n #include <gmock/gmock.h>\n \n namespace eprosima {\n namespace fastrtps {\n namespace rtps {\n \n-class RTPSWriter;\n-class RTPSReader;\n class WriterHistory;\n class ReaderHistory;\n class WriterListener;\n@@ -44,11 +44,32 @@ class RTPSParticipantImpl\n \n         MOCK_CONST_METHOD0(getGuid, const GUID_t&());\n \n-        MOCK_METHOD6(createWriter, bool (RTPSWriter** Writer, WriterAttributes& param, WriterHistory* hist,WriterListener* listen,\n+        MOCK_METHOD6(createWriter_mock, bool (RTPSWriter** writer, WriterAttributes& param, WriterHistory* hist,WriterListener* listen,\n                 const EntityId_t& entityId, bool isBuiltin));\n \n-        MOCK_METHOD7(createReader, bool (RTPSReader** Reader, ReaderAttributes& param, ReaderHistory* hist,ReaderListener* listen,\n+        MOCK_METHOD7(createReader_mock, bool (RTPSReader** reader, ReaderAttributes& param, ReaderHistory* hist,ReaderListener* listen,\n                 const EntityId_t& entityId, bool isBuiltin, bool enable));\n+\n+        bool createWriter(RTPSWriter** writer, WriterAttributes& param, WriterHistory* hist, WriterListener* listen,\n+                const EntityId_t& entityId, bool isBuiltin)\n+        {\n+            bool ret = createWriter_mock(writer, param , hist, listen, entityId, isBuiltin);\n+            if(*writer != nullptr)\n+                (*writer)->history_ = hist;\n+            return ret;\n+        }\n+\n+        bool createReader(RTPSReader** reader, ReaderAttributes& param, ReaderHistory* hist,ReaderListener* listen,\n+                const EntityId_t& entityId, bool isBuiltin, bool enable)\n+        {\n+            bool ret = createReader_mock(reader, param, hist, listen, entityId, isBuiltin, enable);\n+            if(*reader != nullptr)\n+            {\n+                (*reader)->history_ = hist;\n+                (*reader)->listener_ = listen;\n+            }\n+            return ret;\n+        }\n };\n \n } // namespace rtps"
        },
        {
          "filename": "test/mock/rtps/RTPSReader/fastrtps/rtps/reader/RTPSReader.h",
          "status": "modified",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -19,6 +19,11 @@\n #ifndef _RTPS_READER_RTPSREADER_H_\n #define _RTPS_READER_RTPSREADER_H_\n \n+#include <fastrtps/rtps/history/ReaderHistory.h>\n+#include <fastrtps/rtps/reader/ReaderListener.h>\n+\n+#include <gmock/gmock.h>\n+\n namespace eprosima {\n namespace fastrtps {\n namespace rtps {\n@@ -30,6 +35,18 @@ class RTPSReader\n         virtual bool matched_writer_add(RemoteWriterAttributes& wdata) = 0;\n \n         virtual bool matched_writer_remove(RemoteWriterAttributes& wdata) = 0;\n+\n+        MOCK_METHOD0(getHistory_mock, ReaderHistory*());\n+\n+        ReaderHistory* getHistory()\n+        {\n+            getHistory_mock();\n+            return history_;\n+        }\n+\n+        ReaderHistory* history_;\n+\n+        ReaderListener* listener_;\n };\n \n } // namespace rtps"
        },
        {
          "filename": "test/mock/rtps/RTPSWriter/fastrtps/rtps/writer/RTPSWriter.h",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -19,17 +19,26 @@\n #ifndef _RTPS_WRITER_RTPSWRITER_H_\n #define _RTPS_WRITER_RTPSWRITER_H_\n \n+#include <gmock/gmock.h>\n+\n namespace eprosima {\n namespace fastrtps {\n namespace rtps {\n \n+class WriterHistory;\n+\n class RTPSWriter\n {\n     public:\n \n         virtual bool matched_reader_add(RemoteReaderAttributes& ratt) = 0;\n \n         virtual bool matched_reader_remove(RemoteReaderAttributes& ratt) = 0;\n+\n+        MOCK_METHOD3(new_change, CacheChange_t*(const std::function<uint32_t()>&,\n+            ChangeKind_t, InstanceHandle_t));\n+\n+        WriterHistory* history_;\n };\n \n } // namespace rtps"
        },
        {
          "filename": "test/mock/rtps/ReaderHistory/fastrtps/rtps/history/ReaderHistory.h",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -21,6 +21,8 @@\n \n #include <fastrtps/rtps/attributes/HistoryAttributes.h>\n \n+#include <gmock/gmock.h>\n+\n namespace eprosima {\n namespace fastrtps {\n namespace rtps {\n@@ -30,6 +32,8 @@ class ReaderHistory\n     public:\n \n         ReaderHistory(const HistoryAttributes& /*att*/){}\n+\n+        MOCK_METHOD1(remove_change, bool(CacheChange_t*));\n };\n \n } // namespace rtps"
        },
        {
          "filename": "test/mock/rtps/SecurityPluginFactory/SecurityPluginFactory.cpp",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -25,7 +25,9 @@ Authentication* SecurityPluginFactory::auth_plugin_ = nullptr;\n \n Authentication* SecurityPluginFactory::create_authentication_plugin(const PropertyPolicy& /*property_policy*/)\n {\n-    return auth_plugin_;\n+    Authentication* ret =  auth_plugin_;\n+    auth_plugin_ = nullptr;\n+    return ret;\n }\n \n void SecurityPluginFactory::set_auth_plugin(Authentication* plugin)\n@@ -35,5 +37,9 @@ void SecurityPluginFactory::set_auth_plugin(Authentication* plugin)\n \n void SecurityPluginFactory::release_auth_plugin()\n {\n-    auth_plugin_ = nullptr;\n+    if(auth_plugin_ != nullptr)\n+    {\n+        delete auth_plugin_;\n+        auth_plugin_ = nullptr;\n+    }\n }"
        },
        {
          "filename": "test/mock/rtps/StatelessWriter/fastrtps/rtps/writer/StatelessWriter.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -32,6 +32,8 @@ class StatelessWriter : public RTPSWriter\n         MOCK_METHOD1(matched_reader_add, bool(RemoteReaderAttributes&));\n \n         MOCK_METHOD1(matched_reader_remove, bool(RemoteReaderAttributes&));\n+\n+        MOCK_METHOD0(getGuid, const GUID_t&());\n };\n \n } // namespace rtps"
        },
        {
          "filename": "test/mock/rtps/WriterHistory/fastrtps/rtps/history/WriterHistory.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -31,6 +31,8 @@ class WriterHistory\n \n \n         WriterHistory(const HistoryAttributes& /*att*/){}\n+\n+        MOCK_METHOD1(add_change, bool(CacheChange_t*));\n };\n \n } // namespace rtps"
        },
        {
          "filename": "test/unittest/rtps/security/CMakeLists.txt",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -26,10 +26,11 @@ if(NOT ((MSVC OR MSVC_IDE) AND EPROSIMA_INSTALLER))\n             ${PROJECT_SOURCE_DIR}/src/cpp/log/Log.cpp\n             ${PROJECT_SOURCE_DIR}/src/cpp/log/StdoutConsumer.cpp\n             ${PROJECT_SOURCE_DIR}/src/cpp/rtps/attributes/PropertyPolicy.cpp\n-            ${PROJECT_SOURCE_DIR}/test/mock/rtps/SecurityPluginFactory/SecurityPluginFactory.cpp\n-            ${PROJECT_SOURCE_DIR}/src/cpp/rtps/security/SecurityManager.cpp\n+            ${PROJECT_SOURCE_DIR}/src/cpp/rtps/common/Token.cpp\n             ${PROJECT_SOURCE_DIR}/src/cpp/rtps/exceptions/Exception.cpp\n+            ${PROJECT_SOURCE_DIR}/src/cpp/rtps/security/SecurityManager.cpp\n             ${PROJECT_SOURCE_DIR}/src/cpp/rtps/security/exceptions/SecurityException.cpp\n+            ${PROJECT_SOURCE_DIR}/test/mock/rtps/SecurityPluginFactory/SecurityPluginFactory.cpp\n             )\n \n         add_executable(SecurityAuthentication ${SOURCES_SECURITY_TEST_SOURCE}"
        },
        {
          "filename": "test/unittest/rtps/security/SecurityAuthenticationTests.cpp",
          "status": "modified",
          "additions": 878,
          "deletions": 15,
          "patch": "@@ -15,6 +15,10 @@\n #include <fastrtps/rtps/security/common/Handle.h>\n #include <MockAuthenticationPlugin.h>\n #include <rtps/participant/RTPSParticipantImpl.h>\n+#include <fastrtps/rtps/writer/StatelessWriter.h>\n+#include <fastrtps/rtps/history/WriterHistory.h>\n+#include <fastrtps/rtps/reader/StatelessReader.h>\n+#include <fastrtps/rtps/history/ReaderHistory.h>\n #include <SecurityPluginFactory.h>\n #include <SecurityManager.h>\n \n@@ -52,13 +56,34 @@ typedef HandleImpl<MockHandshake> MockHandshakeHandle;\n RTPSParticipantAttributes pattr;\n GUID_t guid;\n \n+void fill_participant_key(GUID_t& participant_key)\n+{\n+    participant_key.guidPrefix.value[0] = 1;\n+    participant_key.guidPrefix.value[1] = 2;\n+    participant_key.guidPrefix.value[2] = 3;\n+    participant_key.guidPrefix.value[3] = 4;\n+    participant_key.guidPrefix.value[4] = 5;\n+    participant_key.guidPrefix.value[5] = 6;\n+    participant_key.guidPrefix.value[6] = 7;\n+    participant_key.guidPrefix.value[7] = 8;\n+    participant_key.guidPrefix.value[8] = 9;\n+    participant_key.guidPrefix.value[9] = 10;\n+    participant_key.guidPrefix.value[10] = 11;\n+    participant_key.guidPrefix.value[11] = 12;\n+    participant_key.entityId.value[0] = 13;\n+    participant_key.entityId.value[1] = 14;\n+    participant_key.entityId.value[2] = 15;\n+    participant_key.entityId.value[3] = 16;\n+}\n+\n class SecurityAuthenticationTest : public ::testing::Test\n {\n     protected:\n \n         virtual void SetUp()\n         {\n             SecurityPluginFactory::set_auth_plugin(auth_plugin_);\n+            fill_participant_key(guid);\n         }\n \n         virtual void TearDown()\n@@ -70,25 +95,111 @@ class SecurityAuthenticationTest : public ::testing::Test\n         {\n             DefaultValue<const RTPSParticipantAttributes&>::Set(pattr);\n             DefaultValue<const GUID_t&>::Set(guid);\n+            stateless_writer_ = new NiceMock<StatelessWriter>();\n+            stateless_reader_ = new NiceMock<StatelessReader>();\n             MockIdentityHandle identity_handle;\n             MockIdentityHandle* p_identity_handle = &identity_handle;\n \n             EXPECT_CALL(*auth_plugin_, validate_local_identity(_,_,_,_,_,_)).Times(1).\n                 WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_OK)));\n-            EXPECT_CALL(participant_, createWriter(_,_,_,_,_,_)).Times(1).\n-                WillOnce(Return(true));\n-            EXPECT_CALL(participant_, createReader(_,_,_,_,_,_,_)).Times(1).\n-                WillOnce(Return(true));\n+            EXPECT_CALL(participant_, createWriter_mock(_,_,_,_,_,_)).Times(1).\n+                WillOnce(DoAll(SetArgPointee<0>(stateless_writer_), Return(true)));\n+            EXPECT_CALL(participant_, createReader_mock(_,_,_,_,_,_,_)).Times(1).\n+                WillOnce(DoAll(SetArgPointee<0>(stateless_reader_), Return(true)));\n \n             ASSERT_TRUE(manager_.init());\n         }\n \n+        void request_process_ok()\n+        {\n+            initialization_ok();\n+\n+            MockIdentityHandle identity_handle;\n+            MockIdentityHandle* p_identity_handle = &identity_handle;\n+            MockHandshakeHandle handshake_handle;\n+            MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+            HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+            CacheChange_t* change = new CacheChange_t(200);\n+\n+            EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+                WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n+            EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n+                WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                            SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+            EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+                WillOnce(Return(change));\n+            EXPECT_CALL(*stateless_writer_->history_, add_change(change)).Times(1).\n+                WillOnce(Return(true));\n+\n+            GUID_t remote_participant_key;\n+            fill_participant_key(remote_participant_key);\n+            ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+            delete change;\n+        }\n+\n+        void reply_process_ok()\n+        {\n+            initialization_ok();\n+\n+            MockIdentityHandle identity_handle;\n+            MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+            EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+                WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+            GUID_t remote_participant_key;\n+            fill_participant_key(remote_participant_key);\n+            ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+            ParticipantGenericMessage message;\n+            message.message_identity().source_guid(remote_participant_key);\n+            message.destination_participant_key(remote_participant_key);\n+            message.message_class_id(\"dds.sec.auth\");\n+            HandshakeMessageToken token;\n+            message.message_data().push_back(token);\n+            CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+            CDRMessage_t aux_msg(0);\n+            aux_msg.wraps = true;\n+            aux_msg.buffer = change->serializedPayload.data;\n+            aux_msg.max_size = change->serializedPayload.max_size;\n+            aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+            ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+            change->serializedPayload.length = aux_msg.length;\n+\n+            MockHandshakeHandle handshake_handle;\n+            MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+            HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+            CacheChange_t* change2 = new CacheChange_t(200);\n+\n+            EXPECT_CALL(*auth_plugin_, begin_handshake_reply_rvr(_,_,_,_,_,_)).Times(1).\n+                WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                            SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+            EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+                WillOnce(Return(change2));\n+            EXPECT_CALL(*stateless_writer_->history_, add_change(change2)).Times(1).\n+                WillOnce(Return(true));\n+            EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+                WillOnce(Return(true));\n+\n+            stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+            delete change2;\n+        }\n \n     public:\n \n-        SecurityAuthenticationTest() : auth_plugin_(new MockAuthenticationPlugin()), manager_(&participant_) {}\n+        SecurityAuthenticationTest() : auth_plugin_(new MockAuthenticationPlugin()),\n+        stateless_writer_(nullptr), stateless_reader_(nullptr), manager_(&participant_) {}\n+\n+        ~SecurityAuthenticationTest()\n+        {\n+        }\n+\n         MockAuthenticationPlugin* auth_plugin_;\n         NiceMock<RTPSParticipantImpl> participant_;\n+        NiceMock<StatelessWriter>* stateless_writer_;\n+        NiceMock<StatelessReader>* stateless_reader_;\n         SecurityManager manager_;\n };\n \n@@ -121,7 +232,7 @@ TEST_F(SecurityAuthenticationTest, initialization_fail_participant_stateless_mes\n \n     EXPECT_CALL(*auth_plugin_, validate_local_identity(_,_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_OK)));\n-    EXPECT_CALL(participant_, createWriter(_,_,_,_,_,_)).Times(1).\n+    EXPECT_CALL(participant_, createWriter_mock(_,_,_,_,_,_)).Times(1).\n         WillOnce(Return(false));\n \n     ASSERT_FALSE(manager_.init());\n@@ -131,14 +242,15 @@ TEST_F(SecurityAuthenticationTest, initialization_fail_participant_stateless_mes\n {\n     DefaultValue<const RTPSParticipantAttributes&>::Set(pattr);\n     DefaultValue<const GUID_t&>::Set(guid);\n+    NiceMock<StatelessWriter>* stateless_writer = new NiceMock<StatelessWriter>();\n     MockIdentityHandle identity_handle;\n     MockIdentityHandle* p_identity_handle = &identity_handle;\n \n     EXPECT_CALL(*auth_plugin_, validate_local_identity(_,_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_OK)));\n-    EXPECT_CALL(participant_, createWriter(_,_,_,_,_,_)).Times(1).\n-        WillOnce(Return(true));\n-    EXPECT_CALL(participant_, createReader(_,_,_,_,_,_,_)).Times(1).\n+    EXPECT_CALL(participant_, createWriter_mock(_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(stateless_writer), Return(true)));\n+    EXPECT_CALL(participant_, createReader_mock(_,_,_,_,_,_,_)).Times(1).\n         WillOnce(Return(false));\n \n     ASSERT_FALSE(manager_.init());\n@@ -148,23 +260,30 @@ TEST_F(SecurityAuthenticationTest, initialization_auth_retry)\n {\n     DefaultValue<const RTPSParticipantAttributes&>::Set(pattr);\n     DefaultValue<const GUID_t&>::Set(guid);\n+    NiceMock<StatelessWriter>* stateless_writer = new NiceMock<StatelessWriter>();\n+    NiceMock<StatelessReader>* stateless_reader = new NiceMock<StatelessReader>();\n     MockIdentityHandle identity_handle;\n     MockIdentityHandle* p_identity_handle = &identity_handle;\n \n     EXPECT_CALL(*auth_plugin_, validate_local_identity(_,_,_,_,_,_)).Times(2).\n         WillOnce(Return(ValidationResult_t::VALIDATION_PENDING_RETRY)).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_OK)));\n-    EXPECT_CALL(participant_, createWriter(_,_,_,_,_,_)).Times(1).\n-        WillOnce(Return(true));\n-    EXPECT_CALL(participant_, createReader(_,_,_,_,_,_,_)).Times(1).\n-        WillOnce(Return(true));\n+    EXPECT_CALL(participant_, createWriter_mock(_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(stateless_writer), Return(true)));\n+    EXPECT_CALL(participant_, createReader_mock(_,_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(stateless_reader), Return(true)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n \n     ASSERT_TRUE(manager_.init());\n }\n \n \n TEST_F(SecurityAuthenticationTest, initialization_ok)\n {\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+\n     initialization_ok();\n }\n \n@@ -174,8 +293,11 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_iden\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_FALSE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n }\n \n@@ -188,8 +310,11 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_iden\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_OK)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n }\n \n@@ -202,8 +327,11 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_iden\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n }\n \n@@ -218,8 +346,11 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_iden\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_FALSE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n }\n \n@@ -231,18 +362,91 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_iden\n     MockIdentityHandle* p_identity_handle = &identity_handle;\n     MockHandshakeHandle handshake_handle;\n     MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n-    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n-                    SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_OK)));\n+                    Return(ValidationResult_t::VALIDATION_OK)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n }\n \n+TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_identity_new_change_fail)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+    MockHandshakeHandle handshake_handle;\n+    MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                    SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(nullptr));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_FALSE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_identity_add_change_fail)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+    MockHandshakeHandle handshake_handle;\n+    MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change = new CacheChange_t(200);\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                    SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change)).Times(1).\n+        WillOnce(Return(false));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_FALSE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    delete change;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_identity_pending_handshake_request_pending_message)\n+{\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+\n+    request_process_ok();\n+}\n+\n TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_identity_pending_handshake_request_ok_with_final_message)\n {\n     initialization_ok();\n@@ -252,15 +456,27 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validation_remote_iden\n     MockHandshakeHandle handshake_handle;\n     MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n     HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change = new CacheChange_t(200);\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n                     SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_OK_WITH_FINAL_MESSAGE)));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change)).Times(1).\n+        WillOnce(Return(true));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    delete change;\n }\n \n TEST_F(SecurityAuthenticationTest, discovered_participant_ok)\n@@ -272,15 +488,27 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_ok)\n     MockHandshakeHandle handshake_handle;\n     MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n     HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change = new CacheChange_t(200);\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n                     SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change)).Times(1).\n+        WillOnce(Return(true));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    delete change;\n }\n \n TEST_F(SecurityAuthenticationTest, discovered_participant_validate_remote_fail_and_then_ok)\n@@ -292,20 +520,32 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_validate_remote_fail_a\n     MockHandshakeHandle handshake_handle;\n     MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n     HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change = new CacheChange_t(200);\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_FALSE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n                     SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change)).Times(1).\n+        WillOnce(Return(true));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n \n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    delete change;\n }\n \n TEST_F(SecurityAuthenticationTest, discovered_participant_begin_handshake_request_fail_and_then_ok)\n@@ -317,21 +557,644 @@ TEST_F(SecurityAuthenticationTest, discovered_participant_begin_handshake_reques\n     MockHandshakeHandle handshake_handle;\n     MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n     HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change = new CacheChange_t(200);\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_REQUEST)));\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n \n     GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_FALSE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n \n     EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(0);\n     EXPECT_CALL(*auth_plugin_, begin_handshake_request(_,_,_,_,_)).Times(1).\n         WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n                     SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change)).Times(1).\n+        WillOnce(Return(true));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    delete change;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_not_remote_participant_key)\n+{\n+    initialization_ok();\n+\n+    ParticipantGenericMessage message;\n+    message.message_class_id(\"dds.sec.auth\");\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(1).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_bad_message_class_id)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_not_expecting_request)\n+{\n+    initialization_ok();\n \n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_OK)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_fail_begin_handshake_reply)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n     ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_reply_rvr(_,_,_,_,_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_ok_begin_handshake_reply)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    MockHandshakeHandle handshake_handle;\n+    MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_reply_rvr(_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                    Return(ValidationResult_t::VALIDATION_OK)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_new_change_fail)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    MockHandshakeHandle handshake_handle;\n+    MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_reply_rvr(_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                    SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(nullptr));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_add_change_fail)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    MockHandshakeHandle handshake_handle;\n+    MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change2 = new CacheChange_t(200);\n+\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_reply_rvr(_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                    SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change2));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change2)).Times(1).\n+        WillOnce(Return(false));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+    delete change2;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_pending_handshake_reply_pending_message)\n+{\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+\n+    reply_process_ok();\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_pending_handshake_reply_ok_with_final_message)\n+{\n+    initialization_ok();\n+\n+    MockIdentityHandle identity_handle;\n+    MockIdentityHandle* p_identity_handle = &identity_handle;\n+\n+    EXPECT_CALL(*auth_plugin_, validate_remote_identity_rvr(_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_identity_handle), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+    ASSERT_TRUE(manager_.discovered_participant(IdentityToken(), remote_participant_key));\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    MockHandshakeHandle handshake_handle;\n+    MockHandshakeHandle* p_handshake_handle = &handshake_handle;\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change2 = new CacheChange_t(200);\n+\n+    EXPECT_CALL(*auth_plugin_, begin_handshake_reply_rvr(_,_,_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_handle), \n+                    SetArgPointee<1>(p_handshake_message), Return(ValidationResult_t::VALIDATION_OK_WITH_FINAL_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change2));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change2)).Times(1).\n+        WillOnce(Return(true));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+    delete change2;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_fail_process_handshake_reply)\n+{\n+    request_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+    delete change;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_ok_process_handshake_reply)\n+{\n+    request_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_process_handshake_reply_new_change_fail)\n+{\n+    request_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(nullptr));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_process_handshake_reply_add_change_fail)\n+{\n+    request_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change2 = new CacheChange_t(200);\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_message), Return(ValidationResult_t::VALIDATION_PENDING_HANDSHAKE_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change2));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change2)).Times(1).\n+        WillOnce(Return(false));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+    delete change2;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_process_handshake_reply_ok_with_final_message)\n+{\n+    request_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    HandshakeMessageToken* p_handshake_message = new HandshakeMessageToken();\n+    CacheChange_t* change2 = new CacheChange_t(200);\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(DoAll(SetArgPointee<0>(p_handshake_message), Return(ValidationResult_t::VALIDATION_OK_WITH_FINAL_MESSAGE)));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_writer_, new_change(_,_,_)).Times(1).\n+        WillOnce(Return(change2));\n+    EXPECT_CALL(*stateless_writer_->history_, add_change(change2)).Times(1).\n+        WillOnce(Return(true));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+    delete change2;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_fail_process_handshake_final)\n+{\n+    reply_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_FAILED));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n+\n+    delete change;\n+}\n+\n+TEST_F(SecurityAuthenticationTest, discovered_participant_process_message_ok_process_handshake_final)\n+{\n+    reply_process_ok();\n+\n+    GUID_t remote_participant_key;\n+    fill_participant_key(remote_participant_key);\n+\n+    ParticipantGenericMessage message;\n+    message.message_identity().source_guid(remote_participant_key);\n+    message.related_message_identity().source_guid(remote_participant_key);\n+    message.destination_participant_key(remote_participant_key);\n+    message.message_class_id(\"dds.sec.auth\");\n+    HandshakeMessageToken token;\n+    message.message_data().push_back(token);\n+    CacheChange_t* change = new CacheChange_t(ParticipantGenericMessageHelper::serialized_size(message));\n+    CDRMessage_t aux_msg(0);\n+    aux_msg.wraps = true;\n+    aux_msg.buffer = change->serializedPayload.data;\n+    aux_msg.max_size = change->serializedPayload.max_size;\n+    aux_msg.msg_endian = change->serializedPayload.encapsulation == PL_CDR_BE ? BIGEND : LITTLEEND;\n+    ASSERT_TRUE(CDRMessage::addParticipantGenericMessage(&aux_msg, message));\n+    change->serializedPayload.length = aux_msg.length;\n+\n+    EXPECT_CALL(*auth_plugin_, process_handshake_rvr(_,_,_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_identity_handle(_,_)).Times(2).\n+        WillRepeatedly(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*auth_plugin_, return_handshake_handle(_,_)).Times(1).\n+        WillOnce(Return(ValidationResult_t::VALIDATION_OK));\n+    EXPECT_CALL(*stateless_reader_->history_, remove_change(change)).Times(1).\n+        WillOnce(Return(true));\n+\n+    stateless_reader_->listener_->onNewCacheChangeAdded(stateless_reader_, change);\n }\n \n int main(int argc, char **argv)"
        }
      ],
      "file_patterns": {
        "security_files": 6,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 9,
        "unique_directories": 15,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "74d8e279a4b18b5b525e64116aad112860dffcb9",
            "date": "2025-01-13T12:01:42Z",
            "author_login": "MiguelCompany"
          },
          {
            "sha": "490e80b0725e9e354726dadf5e5cdd855535f32c",
            "date": "2025-01-13T11:53:00Z",
            "author_login": "MiguelCompany"
          },
          {
            "sha": "25b117fcf5feaea8d4a0529e1a2d6bdded255cfd",
            "date": "2025-01-13T06:30:07Z",
            "author_login": "EugenioCollado"
          },
          {
            "sha": "5fc77861df383a7e94691295f7b07fdaa50f9402",
            "date": "2025-01-10T09:17:41Z",
            "author_login": "EugenioCollado"
          },
          {
            "sha": "b53a3899e035dcb3bc8c39d392a66a3a236bc4bb",
            "date": "2025-01-09T15:14:43Z",
            "author_login": "fujitatomoya"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.6,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-284",
    "description": "eProsima Fast DDS (formerly Fast RTPS) is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected. Moreover, if this disconnection packet is sent continuously, the Subscribers (Listeners) trying to connect will not be able to do so. Since the initial commit of the `SecurityManager.cpp` code (`init`, `on_process_handshake`) on Nov 8, 2016, the Disconnect Vulnerability in RTPS Packets Used by SROS2 has been present prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-19T20:15:45.310",
    "last_modified": "2024-11-21T08:36:45.900",
    "fix_date": "2016-11-16T09:19:59Z"
  },
  "references": [
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/e1869863c06db7fbb366ae53760fbe6e754be026",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/f07a0213e655202188840b864be4438ae1067a13",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/f2e5ceae8fbea0a6c9445a366faaca0b98a8ef86",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/security/advisories/GHSA-v5r6-8mvh-cp98",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/072cbc9d6a71d869a5cbed1873c0cdd6cf67cda4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/e1869863c06db7fbb366ae53760fbe6e754be026",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/f07a0213e655202188840b864be4438ae1067a13",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/f2e5ceae8fbea0a6c9445a366faaca0b98a8ef86",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/security/advisories/GHSA-v5r6-8mvh-cp98",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.133592",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Fast-DDS",
    "owner": "eProsima",
    "created_at": "2014-05-29T14:36:15Z",
    "updated_at": "2025-01-14T10:05:06Z",
    "pushed_at": "2025-01-14T11:56:33Z",
    "size": 136008,
    "stars": 2273,
    "forks": 790,
    "open_issues": 127,
    "watchers": 2273,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "2.6.x"
    ],
    "languages": {
      "C++": 46757167,
      "C": 9849654,
      "CMake": 579263,
      "Python": 224282,
      "CSS": 28054,
      "Shell": 13873,
      "Makefile": 5345,
      "HTML": 2698,
      "Dockerfile": 1683,
      "Batchfile": 1395,
      "PowerShell": 954
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:10:57.643175"
  }
}