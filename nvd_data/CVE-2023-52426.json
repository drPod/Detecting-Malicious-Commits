{
  "cve_id": "CVE-2023-52426",
  "github_data": {
    "repository": "libexpat/libexpat",
    "fix_commit": "0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
    "related_commits": [
      "0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
      "0f075ec8ecb5e43f8fdca5182f8cca4703da0404"
    ],
    "patch_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404.patch",
    "fix_commit_details": {
      "sha": "0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
      "commit_date": "2023-10-25T22:43:22Z",
      "author": {
        "login": "hartwork",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "length": 129,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 111,
        "additions": 62,
        "deletions": 49
      },
      "files": [
        {
          "filename": "expat/CMakeLists.txt",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -403,7 +403,13 @@ if(EXPAT_SHARED_LIBS)\n             endif()\n         endmacro()\n \n-        _expat_def_file_toggle(EXPAT_DTD _EXPAT_COMMENT_DTD)\n+        if(EXPAT_DTD OR EXPAT_GE)\n+            set(_EXPAT_DTD_OR_GE TRUE)\n+        else()\n+            set(_EXPAT_DTD_OR_GE FALSE)\n+        endif()\n+\n+        _expat_def_file_toggle(_EXPAT_DTD_OR_GE _EXPAT_COMMENT_DTD_OR_GE)\n         _expat_def_file_toggle(EXPAT_ATTR_INFO _EXPAT_COMMENT_ATTR_INFO)\n \n         configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/lib/libexpat.def.cmake\" \"${CMAKE_CURRENT_BINARY_DIR}/lib/libexpat.def\")"
        },
        {
          "filename": "expat/lib/expat.h",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -1038,13 +1038,15 @@ typedef struct {\n XMLPARSEAPI(const XML_Feature *)\n XML_GetFeatureList(void);\n \n-#ifdef XML_DTD\n-/* Added in Expat 2.4.0. */\n+#if defined(XML_DTD) || XML_GE == 1\n+/* Added in Expat 2.4.0 for XML_DTD defined and\n+ * added in Expat 2.6.0 for XML_GE == 1. */\n XMLPARSEAPI(XML_Bool)\n XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n     XML_Parser parser, float maximumAmplificationFactor);\n \n-/* Added in Expat 2.4.0. */\n+/* Added in Expat 2.4.0 for XML_DTD defined and\n+ * added in Expat 2.6.0 for XML_GE == 1. */\n XMLPARSEAPI(XML_Bool)\n XML_SetBillionLaughsAttackProtectionActivationThreshold(\n     XML_Parser parser, unsigned long long activationThresholdBytes);"
        },
        {
          "filename": "expat/lib/internal.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -154,7 +154,7 @@ extern \"C\" {\n void _INTERNAL_trim_to_complete_utf8_characters(const char *from,\n                                                 const char **fromLimRef);\n \n-#if defined(XML_DTD)\n+#if defined(XML_DTD) || XML_GE == 1\n unsigned long long testingAccountingGetCountBytesDirect(XML_Parser parser);\n unsigned long long testingAccountingGetCountBytesIndirect(XML_Parser parser);\n const char *unsignedCharToPrintable(unsigned char c);"
        },
        {
          "filename": "expat/lib/libexpat.def.cmake",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -75,5 +75,5 @@ EXPORTS\n   XML_SetHashSalt @67\n ; internal @68 removed with version 2.3.1\n ; added with version 2.4.0\n-@_EXPAT_COMMENT_DTD@ XML_SetBillionLaughsAttackProtectionActivationThreshold @69\n-@_EXPAT_COMMENT_DTD@ XML_SetBillionLaughsAttackProtectionMaximumAmplification @70\n+@_EXPAT_COMMENT_DTD_OR_GE@ XML_SetBillionLaughsAttackProtectionActivationThreshold @69\n+@_EXPAT_COMMENT_DTD_OR_GE@ XML_SetBillionLaughsAttackProtectionMaximumAmplification @70"
        },
        {
          "filename": "expat/lib/xmlparse.c",
          "status": "modified",
          "additions": 37,
          "deletions": 34,
          "patch": "@@ -416,7 +416,7 @@ enum XML_Account {\n   XML_ACCOUNT_NONE              /* i.e. do not account, was accounted already */\n };\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n typedef unsigned long long XmlBigCount;\n typedef struct accounting {\n   XmlBigCount countBytesDirect;\n@@ -432,7 +432,7 @@ typedef struct entity_stats {\n   unsigned int maximumDepthSeen;\n   unsigned long debugLevel;\n } ENTITY_STATS;\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n typedef enum XML_Error PTRCALL Processor(XML_Parser parser, const char *start,\n                                          const char *end, const char **endPtr);\n@@ -570,7 +570,7 @@ static XML_Parser parserCreate(const XML_Char *encodingName,\n \n static void parserInit(XML_Parser parser, const XML_Char *encodingName);\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n static float accountingGetCurrentAmplification(XML_Parser rootParser);\n static void accountingReportStats(XML_Parser originParser, const char *epilog);\n static void accountingOnAbort(XML_Parser originParser);\n@@ -593,7 +593,7 @@ static void entityTrackingOnClose(XML_Parser parser, ENTITY *entity,\n \n static XML_Parser getRootParserOf(XML_Parser parser,\n                                   unsigned int *outLevelDiff);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n static unsigned long getDebugLevel(const char *variableName,\n                                    unsigned long defaultDebugLevel);\n@@ -718,7 +718,7 @@ struct XML_ParserStruct {\n   enum XML_ParamEntityParsing m_paramEntityParsing;\n #endif\n   unsigned long m_hash_secret_salt;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   ACCOUNTING m_accounting;\n   ENTITY_STATS m_entity_stats;\n #endif\n@@ -1178,7 +1178,7 @@ parserInit(XML_Parser parser, const XML_Char *encodingName) {\n #endif\n   parser->m_hash_secret_salt = 0;\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n   parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n   parser->m_accounting.maximumAmplificationFactor\n@@ -2534,8 +2534,9 @@ XML_GetFeatureList(void) {\n #ifdef XML_ATTR_INFO\n     {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n #endif\n-#ifdef XML_DTD\n-    /* Added in Expat 2.4.0. */\n+#if defined(XML_DTD) || XML_GE == 1\n+    /* Added in Expat 2.4.0 for XML_DTD defined and\n+     * added in Expat 2.6.0 for XML_GE == 1. */\n     {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n      XML_L(\"XML_BLAP_MAX_AMP\"),\n      (long int)\n@@ -2550,7 +2551,7 @@ XML_GetFeatureList(void) {\n   return features;\n }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n XML_Bool XMLCALL\n XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n     XML_Parser parser, float maximumAmplificationFactor) {\n@@ -2572,7 +2573,7 @@ XML_SetBillionLaughsAttackProtectionActivationThreshold(\n   parser->m_accounting.activationThresholdBytes = activationThresholdBytes;\n   return XML_TRUE;\n }\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n /* Initially tag->rawName always points into the parse buffer;\n    for those TAG instances opened while the current parse buffer was\n@@ -2658,13 +2659,13 @@ externalEntityInitProcessor2(XML_Parser parser, const char *start,\n   int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n   switch (tok) {\n   case XML_TOK_BOM:\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                   XML_ACCOUNT_DIRECT)) {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n     }\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n     /* If we are at the end of the buffer, this would cause the next stage,\n        i.e. externalEntityInitProcessor3, to pass control directly to\n@@ -2778,7 +2779,7 @@ doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n   for (;;) {\n     const char *next = s; /* XmlContentTok doesn't always set the last arg */\n     int tok = XmlContentTok(enc, s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     const char *accountAfter\n         = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n               ? (haveMore ? s /* i.e. 0 bytes */ : end)\n@@ -2844,14 +2845,14 @@ doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n       XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n           enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n       if (ch) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         /* NOTE: We are replacing 4-6 characters original input for 1 character\n          *       so there is no amplification and hence recording without\n          *       protection. */\n         accountingDiffTolerated(parser, tok, (char *)&ch,\n                                 ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                 XML_ACCOUNT_ENTITY_EXPANSION);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n         if (parser->m_characterDataHandler)\n           parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n         else if (parser->m_defaultHandler)\n@@ -4053,7 +4054,7 @@ doCdataSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n   for (;;) {\n     const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n     int tok = XmlCdataSectionTok(enc, s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n@@ -4205,7 +4206,7 @@ doIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n   *eventPP = s;\n   *startPtr = NULL;\n   tok = XmlIgnoreSectionTok(enc, s, end, &next);\n-#  ifdef XML_DTD\n+#  if defined(XML_DTD) || XML_GE == 1\n   if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                 XML_ACCOUNT_DIRECT)) {\n     accountingOnAbort(parser);\n@@ -4297,7 +4298,7 @@ processXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *s,\n   const XML_Char *storedversion = NULL;\n   int standalone = -1;\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,\n                                 XML_ACCOUNT_DIRECT)) {\n     accountingOnAbort(parser);\n@@ -4504,7 +4505,7 @@ entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n        is not valid to have multiple BOMs.\n     */\n     else if (tok == XML_TOK_BOM) {\n-#  ifdef XML_DTD\n+#  if defined(XML_DTD) || XML_GE == 1\n       if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                     XML_ACCOUNT_DIRECT)) {\n         accountingOnAbort(parser);\n@@ -4720,11 +4721,13 @@ doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n       }\n     }\n     role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     switch (role) {\n     case XML_ROLE_INSTANCE_START: // bytes accounted in contentProcessor\n     case XML_ROLE_XML_DECL:       // bytes accounted in processXmlDecl\n-    case XML_ROLE_TEXT_DECL:      // bytes accounted in processXmlDecl\n+#  ifdef XML_DTD\n+    case XML_ROLE_TEXT_DECL: // bytes accounted in processXmlDecl\n+#  endif\n       break;\n     default:\n       if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n@@ -5661,7 +5664,7 @@ epilogProcessor(XML_Parser parser, const char *s, const char *end,\n   for (;;) {\n     const char *next = NULL;\n     int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                   XML_ACCOUNT_DIRECT)) {\n       accountingOnAbort(parser);\n@@ -5741,7 +5744,7 @@ processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n       return XML_ERROR_NO_MEMORY;\n   }\n   entity->open = XML_TRUE;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   entityTrackingOnOpen(parser, entity, __LINE__);\n #endif\n   entity->processed = 0;\n@@ -5775,9 +5778,9 @@ processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n       entity->processed = (int)(next - textStart);\n       parser->m_processor = internalEntityProcessor;\n     } else {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       entityTrackingOnClose(parser, entity, __LINE__);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n       entity->open = XML_FALSE;\n       parser->m_openInternalEntities = openEntity->next;\n       /* put openEntity back in list of free instances */\n@@ -5826,7 +5829,7 @@ internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n     return result;\n   }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   entityTrackingOnClose(parser, entity, __LINE__);\n #endif\n   entity->open = XML_FALSE;\n@@ -5905,7 +5908,7 @@ appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n     const char *next\n         = ptr; /* XmlAttributeValueTok doesn't always set the last arg */\n     int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n@@ -5970,14 +5973,14 @@ appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n       XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n           enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n       if (ch) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         /* NOTE: We are replacing 4-6 characters original input for 1 character\n          *       so there is no amplification and hence recording without\n          *       protection. */\n         accountingDiffTolerated(parser, tok, (char *)&ch,\n                                 ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                 XML_ACCOUNT_ENTITY_EXPANSION);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n         if (! poolAppendChar(pool, ch))\n           return XML_ERROR_NO_MEMORY;\n         break;\n@@ -6055,14 +6058,14 @@ appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n         enum XML_Error result;\n         const XML_Char *textEnd = entity->textPtr + entity->textLen;\n         entity->open = XML_TRUE;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         entityTrackingOnOpen(parser, entity, __LINE__);\n #endif\n         result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                       isCdata, (const char *)entity->textPtr,\n                                       (const char *)textEnd, pool,\n                                       XML_ACCOUNT_ENTITY_EXPANSION);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         entityTrackingOnClose(parser, entity, __LINE__);\n #endif\n         entity->open = XML_FALSE;\n@@ -6118,7 +6121,7 @@ storeEntityValue(XML_Parser parser, const ENCODING *enc,\n         = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n     int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                   account)) {\n       accountingOnAbort(parser);\n@@ -7669,7 +7672,7 @@ copyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n   return result;\n }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n \n static float\n accountingGetCurrentAmplification(XML_Parser rootParser) {\n@@ -8400,7 +8403,7 @@ unsignedCharToPrintable(unsigned char c) {\n   assert(0); /* never gets here */\n }\n \n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n static unsigned long\n getDebugLevel(const char *variableName, unsigned long defaultDebugLevel) {"
        },
        {
          "filename": "expat/xmlwf/xmlwf.c",
          "status": "modified",
          "additions": 10,
          "deletions": 8,
          "patch": "@@ -1096,9 +1096,10 @@ tmain(int argc, XML_Char **argv) {\n             \" (needs a floating point number greater or equal than 1.0)\"));\n         exit(XMLWF_EXIT_USAGE_ERROR);\n       }\n-#ifndef XML_DTD\n-      ftprintf(stderr, T(\"Warning: Given amplification limit ignored\") T(\n-                           \", xmlwf has been compiled without DTD support.\\n\"));\n+#if ! defined(XML_DTD) && XML_GE == 0\n+      ftprintf(stderr,\n+               T(\"Warning: Given amplification limit ignored\")\n+                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n #endif\n       break;\n     }\n@@ -1117,9 +1118,10 @@ tmain(int argc, XML_Char **argv) {\n         exit(XMLWF_EXIT_USAGE_ERROR);\n       }\n       attackThresholdGiven = XML_TRUE;\n-#ifndef XML_DTD\n-      ftprintf(stderr, T(\"Warning: Given attack threshold ignored\") T(\n-                           \", xmlwf has been compiled without DTD support.\\n\"));\n+#if ! defined(XML_DTD) && XML_GE == 0\n+      ftprintf(stderr,\n+               T(\"Warning: Given attack threshold ignored\")\n+                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n #endif\n       break;\n     }\n@@ -1155,13 +1157,13 @@ tmain(int argc, XML_Char **argv) {\n     }\n \n     if (attackMaximumAmplification != -1.0f) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n           parser, attackMaximumAmplification);\n #endif\n     }\n     if (attackThresholdGiven) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       XML_SetBillionLaughsAttackProtectionActivationThreshold(\n           parser, attackThresholdBytes);\n #else"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fd1a3bc9fedb070d9c98b03424f8f286206a1245",
            "date": "2025-01-13T14:31:39Z",
            "author_login": "hartwork"
          },
          {
            "sha": "8d2cc5955ab39e65d184ed9e6e1838088b7b328b",
            "date": "2025-01-13T12:52:36Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "aac7eae6606e935775d92406bb214d23cae4ed1f",
            "date": "2025-01-05T22:41:03Z",
            "author_login": "hartwork"
          },
          {
            "sha": "bf9caf7ac4cd66fe1ca7f13cbef13629ffb20926",
            "date": "2025-01-05T20:41:17Z",
            "author_login": "hartwork"
          },
          {
            "sha": "09f6faa99661a9146e112de7ee664c1f8bb8c152",
            "date": "2025-01-04T21:22:01Z",
            "author_login": "hartwork"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-776",
    "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-04T20:15:46.120",
    "last_modified": "2024-11-21T08:39:43.640",
    "fix_date": "2023-10-25T22:43:22Z"
  },
  "references": [
    {
      "url": "https://cwe.mitre.org/data/definitions/776.html",
      "source": "cve@mitre.org",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
      "source": "cve@mitre.org",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/libexpat/libexpat/pull/777",
      "source": "cve@mitre.org",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PNRIHC7DVVRAIWFRGV23Y6UZXFBXSQDB/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WNUBSGZFEZOBHJFTAD42SAN4ATW2VEMV/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240307-0005/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://cwe.mitre.org/data/definitions/776.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Technical Description"
      ]
    },
    {
      "url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/libexpat/libexpat/pull/777",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PNRIHC7DVVRAIWFRGV23Y6UZXFBXSQDB/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WNUBSGZFEZOBHJFTAD42SAN4ATW2VEMV/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240307-0005/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.583003",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libexpat",
    "owner": "libexpat",
    "created_at": "2017-01-28T22:11:05Z",
    "updated_at": "2025-01-13T14:31:47Z",
    "pushed_at": "2025-01-13T14:31:48Z",
    "size": 16015,
    "stars": 1121,
    "forks": 447,
    "open_issues": 18,
    "watchers": 1121,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1286785,
      "HTML": 109171,
      "C++": 72754,
      "CMake": 61661,
      "M4": 57256,
      "Shell": 47174,
      "Makefile": 19758,
      "Python": 8063,
      "Inno Setup": 6431,
      "Batchfile": 4141,
      "CSS": 1952,
      "Ruby": 158
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T14:54:12.688675"
  }
}