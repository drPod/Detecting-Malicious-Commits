{
  "cve_id": "CVE-2023-5595",
  "github_data": {
    "repository": "gpac/gpac",
    "fix_commit": "7a6f636db3360bb16d18078d51e8c596f31302a1",
    "related_commits": [
      "7a6f636db3360bb16d18078d51e8c596f31302a1",
      "7a6f636db3360bb16d18078d51e8c596f31302a1"
    ],
    "patch_url": "https://github.com/gpac/gpac/commit/7a6f636db3360bb16d18078d51e8c596f31302a1.patch",
    "fix_commit_details": {
      "sha": "7a6f636db3360bb16d18078d51e8c596f31302a1",
      "commit_date": "2023-10-13T10:21:25Z",
      "author": {
        "login": "aureliendavid",
        "type": "User",
        "stats": {
          "total_commits": 799,
          "average_weekly_commits": 0.7841020608439647,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 213
        }
      },
      "commit_message": {
        "title": "fixes #2633 - 3 segv + memleak",
        "length": 30,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 55,
        "additions": 29,
        "deletions": 26
      },
      "files": [
        {
          "filename": "src/filters/isoffin_load.c",
          "status": "modified",
          "additions": 4,
          "deletions": 7,
          "patch": "@@ -89,7 +89,7 @@ static void isor_get_chapters(GF_ISOFile *file, GF_FilterPid *opid)\n \t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n \t\tif (txt) {\n \t\t\ttimes.vals[i] = (u32) s->DTS;\n-\t\t\tnames.vals[i] = gf_strdup(txt->text);\n+\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n \t\t\tgf_isom_delete_text_sample(txt);\n \t\t}\n \t\tgf_bs_del(bs);\n@@ -1105,7 +1105,7 @@ static void isor_declare_track(ISOMReader *read, ISOMChannel *ch, u32 track, u32\n \t\tgf_odf_desc_del((GF_Descriptor *)lang_desc);\n \t\tlang_desc = NULL;\n \t}\n-\t\n+\n \tif (read->smode != MP4DMX_SINGLE) {\n \t\tif ((codec_id==GF_CODECID_LHVC) || (codec_id==GF_CODECID_HEVC)) {\n \t\t\tBool signal_lhv = (read->smode==MP4DMX_SPLIT) ? GF_TRUE : GF_FALSE;\n@@ -1750,7 +1750,7 @@ GF_Err isor_declare_objects(ISOMReader *read)\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] No suitable tracks in file\\n\"));\n \t\treturn GF_NOT_SUPPORTED;\n \t}\n-\t\n+\n \t/*if cover art, declare a video pid*/\n \tif (gf_isom_apple_get_tag(read->mov, GF_ISOM_ITUNE_COVER_ART, &tag, &tlen)==GF_OK) {\n \n@@ -1853,7 +1853,7 @@ Bool isor_declare_item_properties(ISOMReader *read, ISOMChannel *ch, u32 item_id\n \n \tif (read->itemid)\n \t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n-\t\t\n+\n \tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n \t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n \t}\n@@ -1948,6 +1948,3 @@ Bool isor_declare_item_properties(ISOMReader *read, ISOMChannel *ch, u32 item_id\n }\n \n #endif // !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n-\n-\n-"
        },
        {
          "filename": "src/filters/mux_isom.c",
          "status": "modified",
          "additions": 9,
          "deletions": 10,
          "patch": "@@ -1027,7 +1027,7 @@ static GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_tr\n \t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n \n \t\tmux_assign_mime_file_ext(pid, ctx->opid, ISOM_FILE_EXT, ISOM_FILE_MIME, NULL);\n-\t\t\n+\n \t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DASH_MODE, NULL);\n \t\t//we dispatch timing in milliseconds\n \t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n@@ -1080,7 +1080,7 @@ static GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_tr\n \t\tGF_FilterEvent evt;\n \t\tGF_SAFEALLOC(tkw, TrackWriter);\n \t\tif (!tkw) return GF_OUT_OF_MEM;\n-\t\t\n+\n \t\tgf_list_add(ctx->tracks, tkw);\n \t\ttkw->ipid = pid;\n \t\ttkw->fake_track = !is_true_pid;\n@@ -2615,7 +2615,7 @@ static GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_tr\n \t\t\t\treturn e;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tif (xps_inband) {\n \t\t\t//this will cleanup all PS in avcC / svcC\n \t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n@@ -3213,7 +3213,7 @@ static GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_tr\n \t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing unknown codec ID %s, using generic sample entry with 4CC \\\"%s\\\"\\n\", gf_codecid_name(codec_id), gf_4cc_to_str(m_subtype) ));\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\te = gf_isom_new_generic_sample_description(ctx->file, tkw->track_num, (char *)src_url, NULL, &udesc, &tkw->stsd_idx);\n \t\tif (gpac_meta_dsi) gf_free(gpac_meta_dsi);\n \n@@ -3762,7 +3762,7 @@ static GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_tr\n \t\t\t\t\tif (add_chap) {\n \t\t\t\t\t\tgf_isom_add_chapter(ctx->file, 0, start_time, p2->value.string_list.vals[j]);\n \t\t\t\t\t}\n-\t\t\t\t\tif (add_tk) {\n+\t\t\t\t\tif (add_tk && p2->value.string_list.vals[j]) {\n \t\t\t\t\t\tGF_TextSample tx;\n \t\t\t\t\t\tmemset(&tx, 0, sizeof(tx));\n \t\t\t\t\t\ttx.text = p2->value.string_list.vals[j];\n@@ -4363,7 +4363,7 @@ static GF_Err mp4_mux_cenc_update(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_Filter\n \t\t\ttkw->has_seig = GF_TRUE;\n \t\t}\n \t} else {\n-\t\n+\n \t\te = GF_OK;\n \t\t//multikey ALWAYS uses seig\n \t\tif (tkw->cenc_ki->value.data.ptr[0])\n@@ -5014,7 +5014,7 @@ static GF_Err mp4_mux_process_sample(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_Fil\n \t\t\t\ttkw->gdr_type = sap_type;\n \t\t}\n \t}\n-\t\n+\n \tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);\n \tif (subs) {\n \t\t//if no AUDelim nal and inband header injection, push new subsample\n@@ -7107,7 +7107,7 @@ static void mp4_mux_config_timing(GF_MP4MuxCtx *ctx)\n \t\tif (blocking_refs && has_ready) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Blocking input packets present, aborting initial timing sync\\n\"));\n \t\t}\n-\t\t//this may be quite long until we have a packet in case input pid is video encoding \n+\t\t//this may be quite long until we have a packet in case input pid is video encoding\n \t\telse if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No input packets present on one or more inputs for more than 10s, aborting initial timing sync\\n\"));\n \t\t} else {\n@@ -7908,7 +7908,7 @@ static GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final)\n \t\t}\n \n \t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n-\t\t\n+\n \t\tif (ctx->importer && ctx->dur.num && ctx->dur.den) {\n \t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n \t\t\tu64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num);\n@@ -8392,4 +8392,3 @@ const GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n \treturn NULL;\n }\n #endif // GPAC_DISABLE_ISOM_WRITE\n-"
        },
        {
          "filename": "src/isomedia/media.c",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -392,6 +392,8 @@ GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bo\n \t\t\treturn GF_ISOM_INVALID_MEDIA;\n \t\t} else {\n \t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n+\t\t\tif (!ptr || !ptr->lsr_config || !ptr->lsr_config->hdr_size)\n+\t\t\t\treturn GF_ISOM_INVALID_MEDIA;\n \t\t\tesd =  gf_odf_desc_esd_new(2);\n \t\t\t*out_esd = esd;\n \t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n@@ -1071,7 +1073,7 @@ GF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *s\n \t\te = stbl_AddChunkOffset(mdia, sampleNumber, StreamDescIndex, data_offset, sample->nb_pack);\n \t\tif (e) return e;\n \t}\n-\t\n+\n \tif (!syncShadowNumber) return GF_OK;\n \tif (!stbl->ShadowSync) {\n \t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);"
        },
        {
          "filename": "src/isomedia/tx3g.c",
          "status": "modified",
          "additions": 13,
          "deletions": 8,
          "patch": "@@ -102,12 +102,14 @@ GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 desc\n \t\t(*out_desc)->displayFlags = txt->displayFlags;\n \t\t(*out_desc)->vert_justif = txt->vertical_justification;\n \t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n-\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n-\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n-\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n-\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n-\t\t\tif (txt->font_table->fonts[i].fontName)\n-\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n+\t\tif (txt->font_table && txt->font_table->entry_count) {\n+\t\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n+\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n+\t\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n+\t\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n+\t\t\t\tif (txt->font_table->fonts[i].fontName)\n+\t\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n+\t\t\t}\n \t\t}\n \t}\n \treturn GF_OK;\n@@ -663,9 +665,12 @@ GF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs)\n \t}\n \n \twhile (gf_bs_available(bs)) {\n-\t\tGF_Box *a;\n+\t\tGF_Box *a = NULL;\n \t\tGF_Err e = gf_isom_box_parse(&a, bs);\n-\t\tif (e) break;\n+\t\tif (e) {\n+\t\t\tif (a) gf_isom_box_del(a);\n+\t\t\tbreak;\n+\t\t}\n \n \t\tswitch (a->type) {\n \t\tcase GF_ISOM_BOX_TYPE_STYL:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e075efa1bd0984e0e87f6752f1e5b991ba3a7cf7",
            "date": "2025-01-14T15:00:34Z",
            "author_login": "aureliendavid"
          },
          {
            "sha": "7af1bfcdc25dd74e158437abd13858281ae1bea0",
            "date": "2025-01-14T12:33:00Z",
            "author_login": "aureliendavid"
          },
          {
            "sha": "08572e41a7eae3d7e4329bf88a455ba6cb209936",
            "date": "2025-01-14T12:18:43Z",
            "author_login": "aureliendavid"
          },
          {
            "sha": "5f2c53efbc58ecfb01885c73b9507413efde6c81",
            "date": "2025-01-14T11:46:01Z",
            "author_login": "aureliendavid"
          },
          {
            "sha": "f2082beb80c470f4eaf2bb0421b56e8adcde303a",
            "date": "2025-01-14T11:45:02Z",
            "author_login": "aureliendavid"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Denial of Service in GitHub repository gpac/gpac prior to 2.3.0-DEV.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-10-16T09:15:12.090",
    "last_modified": "2024-11-21T08:42:05.743",
    "fix_date": "2023-10-13T10:21:25Z"
  },
  "references": [
    {
      "url": "https://github.com/gpac/gpac/commit/7a6f636db3360bb16d18078d51e8c596f31302a1",
      "source": "security@huntr.dev",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/0064cf76-ece1-495d-82b4-e4a1bebeb28e",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/gpac/gpac/commit/7a6f636db3360bb16d18078d51e8c596f31302a1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.dev/bounties/0064cf76-ece1-495d-82b4-e4a1bebeb28e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:10.605386",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gpac",
    "owner": "gpac",
    "created_at": "2014-05-03T11:29:57Z",
    "updated_at": "2025-01-14T12:51:06Z",
    "pushed_at": "2025-01-14T12:51:01Z",
    "size": 148655,
    "stars": 2857,
    "forks": 539,
    "open_issues": 84,
    "watchers": 2857,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 29230795,
      "JavaScript": 1164507,
      "C++": 591365,
      "Roff": 570792,
      "Python": 185337,
      "Makefile": 105620,
      "HTML": 100652,
      "Java": 92437,
      "GLSL": 90260,
      "Objective-C": 24884,
      "Shell": 21810,
      "NSIS": 17560,
      "Rez": 13704,
      "CSS": 4998,
      "Batchfile": 4898,
      "Dockerfile": 3216,
      "Nix": 1229
    },
    "commit_activity": {
      "total_commits_last_year": 1273,
      "avg_commits_per_week": 24.48076923076923,
      "days_active_last_year": 239
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T12:56:58.367536"
  }
}