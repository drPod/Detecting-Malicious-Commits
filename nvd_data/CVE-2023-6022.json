{
  "cve_id": "CVE-2023-6022",
  "github_data": {
    "repository": "prefecthq/prefect",
    "fix_commit": "227dfcc7e3374c212a4bcd68b14e090b1c02d9d3",
    "related_commits": [
      "227dfcc7e3374c212a4bcd68b14e090b1c02d9d3",
      "227dfcc7e3374c212a4bcd68b14e090b1c02d9d3"
    ],
    "patch_url": "https://github.com/prefecthq/prefect/commit/227dfcc7e3374c212a4bcd68b14e090b1c02d9d3.patch",
    "fix_commit_details": {
      "sha": "227dfcc7e3374c212a4bcd68b14e090b1c02d9d3",
      "commit_date": "2024-03-18T16:29:27Z",
      "author": {
        "login": "bunchesofdonald",
        "type": "User",
        "stats": {
          "total_commits": 369,
          "average_weekly_commits": 2.005434782608696,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 100
        }
      },
      "commit_message": {
        "title": "Add CSRF support to orchestration client (#12314)",
        "length": 49,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 381,
        "additions": 362,
        "deletions": 19
      },
      "files": [
        {
          "filename": "src/prefect/client/base.py",
          "status": "modified",
          "additions": 73,
          "deletions": 10,
          "patch": "@@ -1,16 +1,18 @@\n import copy\n import sys\n import threading\n+import uuid\n from collections import defaultdict\n from contextlib import asynccontextmanager\n-from functools import partial\n+from datetime import datetime, timezone\n from typing import (\n     Any,\n     AsyncGenerator,\n     Awaitable,\n     Callable,\n     Dict,\n     MutableMapping,\n+    Optional,\n     Protocol,\n     Set,\n     Tuple,\n@@ -21,10 +23,11 @@\n import anyio\n import httpx\n from asgi_lifespan import LifespanManager\n-from httpx import HTTPStatusError, Response\n+from httpx import HTTPStatusError, Request, Response\n from prefect._vendor.starlette import status\n from typing_extensions import Self\n \n+from prefect.client.schemas.objects import CsrfToken\n from prefect.exceptions import PrefectHTTPStatusError\n from prefect.logging import get_logger\n from prefect.settings import (\n@@ -188,9 +191,20 @@ class PrefectHttpxClient(httpx.AsyncClient):\n     [Configuring Cloudflare Rate Limiting](https://support.cloudflare.com/hc/en-us/articles/115001635128-Configuring-Rate-Limiting-from-UI)\n     \"\"\"\n \n+    def __init__(self, *args, enable_csrf_support: bool = False, **kwargs):\n+        self.enable_csrf_support: bool = enable_csrf_support\n+        self.csrf_token: Optional[str] = None\n+        self.csrf_token_expiration: Optional[datetime] = None\n+        self.csrf_client_id: uuid.UUID = uuid.uuid4()\n+\n+        super().__init__(*args, **kwargs)\n+\n     async def _send_with_retry(\n         self,\n-        request: Callable,\n+        request: Request,\n+        send: Callable[[Request], Awaitable[Response]],\n+        send_args: Tuple,\n+        send_kwargs: Dict,\n         retry_codes: Set[int] = set(),\n         retry_exceptions: Tuple[Exception, ...] = tuple(),\n     ):\n@@ -207,21 +221,34 @@ async def _send_with_retry(\n         try_count = 0\n         response = None\n \n+        is_change_request = request.method.lower() in {\"post\", \"put\", \"patch\", \"delete\"}\n+\n+        if self.enable_csrf_support and is_change_request:\n+            await self._add_csrf_headers(request=request)\n+\n         while try_count <= PREFECT_CLIENT_MAX_RETRIES.value():\n             try_count += 1\n             retry_seconds = None\n             exc_info = None\n \n             try:\n-                response = await request()\n+                response = await send(request, *send_args, **send_kwargs)\n             except retry_exceptions:  # type: ignore\n                 if try_count > PREFECT_CLIENT_MAX_RETRIES.value():\n                     raise\n                 # Otherwise, we will ignore this error but capture the info for logging\n                 exc_info = sys.exc_info()\n             else:\n-                # We got a response; return immediately if it is not retryable\n-                if response.status_code not in retry_codes:\n+                # We got a response; check if it's a CSRF error, otherwise\n+                # return immediately if it is not retryable\n+                if (\n+                    response.status_code == status.HTTP_403_FORBIDDEN\n+                    and \"Invalid CSRF token\" in response.text\n+                ):\n+                    # We got a CSRF error, clear the token and try again\n+                    self.csrf_token = None\n+                    await self._add_csrf_headers(request)\n+                elif response.status_code not in retry_codes:\n                     return response\n \n                 if \"Retry-After\" in response.headers:\n@@ -268,19 +295,24 @@ async def _send_with_retry(\n         # We ran out of retries, return the failed response\n         return response\n \n-    async def send(self, *args, **kwargs) -> Response:\n+    async def send(self, request: Request, *args, **kwargs) -> Response:\n         \"\"\"\n         Send a request with automatic retry behavior for the following status codes:\n \n+        - 403 Forbidden, if the request failed due to CSRF protection\n+        - 408 Request Timeout\n         - 429 CloudFlare-style rate limiting\n         - 502 Bad Gateway\n         - 503 Service unavailable\n+        - Any additional status codes provided in `PREFECT_CLIENT_RETRY_EXTRA_CODES`\n         \"\"\"\n \n-        api_request = partial(super().send, *args, **kwargs)\n-\n+        super_send = super().send\n         response = await self._send_with_retry(\n-            request=api_request,\n+            request=request,\n+            send=super_send,\n+            send_args=args,\n+            send_kwargs=kwargs,\n             retry_codes={\n                 status.HTTP_429_TOO_MANY_REQUESTS,\n                 status.HTTP_503_SERVICE_UNAVAILABLE,\n@@ -312,3 +344,34 @@ async def send(self, *args, **kwargs) -> Response:\n         response.raise_for_status()\n \n         return response\n+\n+    async def _add_csrf_headers(self, request: Request):\n+        now = datetime.now(timezone.utc)\n+\n+        if not self.enable_csrf_support:\n+            return\n+\n+        if not self.csrf_token or (\n+            self.csrf_token_expiration and now > self.csrf_token_expiration\n+        ):\n+            token_request = self.build_request(\n+                \"GET\", f\"/csrf-token?client={self.csrf_client_id}\"\n+            )\n+\n+            try:\n+                token_response = await self.send(token_request)\n+            except PrefectHTTPStatusError as exc:\n+                if exc.response.status_code == status.HTTP_404_NOT_FOUND:\n+                    # The token endpoint is not available, likely an older\n+                    # server version; disable CSRF support\n+                    self.enable_csrf_support = False\n+                    return\n+\n+                raise\n+\n+            token: CsrfToken = CsrfToken.parse_obj(token_response.json())\n+            self.csrf_token = token.token\n+            self.csrf_token_expiration = token.expiration\n+\n+        request.headers[\"Prefect-Csrf-Token\"] = self.csrf_token\n+        request.headers[\"Prefect-Csrf-Client\"] = str(self.csrf_client_id)"
        },
        {
          "filename": "src/prefect/client/cloud.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -72,7 +72,7 @@ def __init__(\n         httpx_settings.setdefault(\"base_url\", host)\n         if not PREFECT_UNIT_TEST_MODE.value():\n             httpx_settings.setdefault(\"follow_redirects\", True)\n-        self._client = PrefectHttpxClient(**httpx_settings)\n+        self._client = PrefectHttpxClient(**httpx_settings, enable_csrf_support=False)\n \n     async def api_healthcheck(self):\n         \"\"\""
        },
        {
          "filename": "src/prefect/client/orchestration.py",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -136,6 +136,7 @@\n     PREFECT_API_REQUEST_TIMEOUT,\n     PREFECT_API_TLS_INSECURE_SKIP_VERIFY,\n     PREFECT_API_URL,\n+    PREFECT_CLIENT_CSRF_SUPPORT_ENABLED,\n     PREFECT_CLOUD_API_URL,\n     PREFECT_UNIT_TEST_MODE,\n )\n@@ -316,7 +317,15 @@ def __init__(\n \n         if not PREFECT_UNIT_TEST_MODE:\n             httpx_settings.setdefault(\"follow_redirects\", True)\n-        self._client = PrefectHttpxClient(**httpx_settings)\n+\n+        enable_csrf_support = (\n+            self.server_type != ServerType.CLOUD\n+            and PREFECT_CLIENT_CSRF_SUPPORT_ENABLED.value()\n+        )\n+\n+        self._client = PrefectHttpxClient(\n+            **httpx_settings, enable_csrf_support=enable_csrf_support\n+        )\n         self._loop = None\n \n         # See https://www.python-httpx.org/advanced/#custom-transports"
        },
        {
          "filename": "src/prefect/client/schemas/objects.py",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -1632,3 +1632,16 @@ class GlobalConcurrencyLimit(ObjectBaseModel):\n             \" is used as a rate limit.\"\n         ),\n     )\n+\n+\n+class CsrfToken(ObjectBaseModel):\n+    token: str = Field(\n+        default=...,\n+        description=\"The CSRF token\",\n+    )\n+    client: str = Field(\n+        default=..., description=\"The client id associated with the CSRF token\"\n+    )\n+    expiration: DateTimeTZ = Field(\n+        default=..., description=\"The expiration time of the CSRF token\"\n+    )"
        },
        {
          "filename": "src/prefect/settings.py",
          "status": "modified",
          "additions": 38,
          "deletions": 3,
          "patch": "@@ -657,6 +657,21 @@ def default_cloud_ui_url(settings, value):\n may result in unexpected behavior.\n \"\"\"\n \n+PREFECT_CLIENT_CSRF_SUPPORT_ENABLED = Setting(bool, default=True)\n+\"\"\"\n+Determines if CSRF token handling is active in the Prefect client for API\n+requests.\n+\n+When enabled (`True`), the client automatically manages CSRF tokens by\n+retrieving, storing, and including them in applicable state-changing requests\n+(POST, PUT, PATCH, DELETE) to the API.\n+\n+Disabling this setting (`False`) means the client will not handle CSRF tokens,\n+which might be suitable for environments where CSRF protection is disabled.\n+\n+Defaults to `True`, ensuring CSRF protection is enabled by default.\n+\"\"\"\n+\n PREFECT_CLOUD_API_URL = Setting(\n     str,\n     default=\"https://api.prefect.cloud/api\",\n@@ -1208,11 +1223,31 @@ def default_cloud_ui_url(settings, value):\n \"\"\"\n \n PREFECT_SERVER_CSRF_PROTECTION_ENABLED = Setting(bool, default=False)\n-\"\"\"Whether or not to protect the API from CSRF attacks. Experimental and\n-currently defaults to `False`.\"\"\"\n+\"\"\"\n+Controls the activation of CSRF protection for the Prefect server API.\n+\n+When enabled (`True`), the server enforces CSRF validation checks on incoming\n+state-changing requests (POST, PUT, PATCH, DELETE), requiring a valid CSRF\n+token to be included in the request headers or body. This adds a layer of\n+security by preventing unauthorized or malicious sites from making requests on\n+behalf of authenticated users.\n+\n+It is recommended to enable this setting in production environments where the\n+API is exposed to web clients to safeguard against CSRF attacks.\n+\n+Note: Enabling this setting requires corresponding support in the client for\n+CSRF token management. See PREFECT_CLIENT_CSRF_SUPPORT_ENABLED for more.\n+\"\"\"\n \n PREFECT_SERVER_CSRF_TOKEN_EXPIRATION = Setting(timedelta, default=timedelta(hours=1))\n-\"\"\"How long a CSRF token is valid for. Defaults to 1 hour.\"\"\"\n+\"\"\"\n+Specifies the duration for which a CSRF token remains valid after being issued\n+by the server.\n+\n+The default expiration time is set to 1 hour, which offers a reasonable\n+compromise. Adjust this setting based on your specific security requirements\n+and usage patterns.\n+\"\"\"\n \n PREFECT_UI_ENABLED = Setting(\n     bool,"
        },
        {
          "filename": "tests/cli/test_worker.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -67,6 +67,7 @@ async def kubernetes_work_pool(prefect_client: PrefectClient):\n     with respx.mock(\n         assert_all_mocked=False, base_url=PREFECT_API_URL.value()\n     ) as respx_mock:\n+        respx_mock.get(\"/csrf-token\", params={\"client\": ANY}).pass_through()\n         respx_mock.route(path__startswith=\"/work_pools/\").pass_through()\n         respx_mock.route(path__startswith=\"/flow_runs/\").pass_through()\n         respx_mock.get(\"/collections/views/aggregate-worker-metadata\").mock("
        },
        {
          "filename": "tests/client/test_base_client.py",
          "status": "modified",
          "additions": 195,
          "deletions": 4,
          "patch": "@@ -1,11 +1,15 @@\n-from unittest.mock import call\n+from contextlib import asynccontextmanager\n+from datetime import datetime, timedelta, timezone\n+from typing import AsyncGenerator, List, Tuple\n+from unittest import mock\n \n import httpx\n import pytest\n from httpx import AsyncClient, Request, Response\n from prefect._vendor.starlette import status\n \n from prefect.client.base import PrefectHttpxClient, PrefectResponse\n+from prefect.client.schemas.objects import CsrfToken\n from prefect.exceptions import PrefectHTTPStatusError\n from prefect.settings import (\n     PREFECT_CLIENT_MAX_RETRIES,\n@@ -15,6 +19,8 @@\n )\n from prefect.testing.utilities import AsyncMock\n \n+now = datetime.now(timezone.utc)\n+\n RESPONSE_429_RETRY_AFTER_0 = Response(\n     status.HTTP_429_TOO_MANY_REQUESTS,\n     headers={\"Retry-After\": \"0\"},\n@@ -32,6 +38,31 @@\n     request=Request(\"a test request\", \"fake.url/fake/route\"),\n )\n \n+RESPONSE_CSRF = Response(\n+    status.HTTP_200_OK,\n+    json=CsrfToken(\n+        client=\"test_client\", token=\"test_token\", expiration=now + timedelta(days=1)\n+    ).dict(json_compatible=True, exclude_unset=True),\n+    request=Request(\"a test request\", \"fake.url/fake/route\"),\n+)\n+\n+RESPONSE_400 = Response(\n+    status.HTTP_400_BAD_REQUEST,\n+    json={\"detail\": \"You done bad things\"},\n+    request=Request(\"a test request\", \"fake.url/fake/route\"),\n+)\n+\n+RESPONSE_404 = Response(\n+    status.HTTP_404_NOT_FOUND,\n+    request=Request(\"a test request\", \"fake.url/fake/route\"),\n+)\n+\n+RESPONSE_INVALID_TOKEN = Response(\n+    status_code=status.HTTP_403_FORBIDDEN,\n+    json={\"detail\": \"Invalid CSRF token or client identifier.\"},\n+    request=Request(\"a test request\", \"fake.url/fake/route\"),\n+)\n+\n \n @pytest.fixture\n def disable_jitter():\n@@ -343,7 +374,7 @@ async def test_prefect_httpx_client_uses_exponential_backoff_without_retry_after\n                     url=\"fake.url/fake/route\", data={\"evenmorefake\": \"data\"}\n                 )\n         assert response.status_code == status.HTTP_200_OK\n-        mock_anyio_sleep.assert_has_awaits([call(2), call(4), call(8)])\n+        mock_anyio_sleep.assert_has_awaits([mock.call(2), mock.call(4), mock.call(8)])\n \n     @pytest.mark.usefixtures(\"disable_jitter\")\n     async def test_prefect_httpx_client_respects_retry_header_per_response(\n@@ -370,7 +401,9 @@ async def test_prefect_httpx_client_respects_retry_header_per_response(\n                     url=\"fake.url/fake/route\", data={\"evenmorefake\": \"data\"}\n                 )\n         assert response.status_code == status.HTTP_200_OK\n-        mock_anyio_sleep.assert_has_awaits([call(5), call(0), call(10), call(2.0)])\n+        mock_anyio_sleep.assert_has_awaits(\n+            [mock.call(5), mock.call(0), mock.call(10), mock.call(2.0)]\n+        )\n \n     async def test_prefect_httpx_client_adds_jitter_with_retry_header(\n         self, monkeypatch, mock_anyio_sleep\n@@ -433,7 +466,7 @@ async def test_prefect_httpx_client_adds_jitter_with_exponential_backoff(\n                 )\n         assert response.status_code == status.HTTP_200_OK\n         mock_anyio_sleep.assert_has_awaits(\n-            [call(pytest.approx(n, rel=0.2)) for n in [2, 4, 8]]\n+            [mock.call(pytest.approx(n, rel=0.2)) for n in [2, 4, 8]]\n         )\n \n     async def test_prefect_httpx_client_does_not_retry_other_exceptions(\n@@ -490,3 +523,161 @@ async def test_prefect_httpx_client_raises_prefect_http_status_error(\n                 )\n         expected = \"Response: {'extra_info': [{'message': 'a test error message'}]}\"\n         assert expected in str(exc.exconly())\n+\n+\n+@asynccontextmanager\n+async def mocked_client(\n+    responses: List[Response],\n+) -> AsyncGenerator[Tuple[PrefectHttpxClient, mock.AsyncMock], None]:\n+    with mock.patch(\"httpx.AsyncClient.send\", autospec=True) as send:\n+        send.side_effect = responses\n+        client = PrefectHttpxClient(enable_csrf_support=True)\n+        async with client:\n+            try:\n+                yield client, send\n+            finally:\n+                pass\n+\n+\n+class TestCsrfSupport:\n+    async def test_no_csrf_headers_not_change_request(self):\n+        async with mocked_client(responses=[RESPONSE_200]) as (client, send):\n+            await client.get(url=\"fake.url/fake/route\")\n+\n+        request = send.call_args[0][1]\n+        assert isinstance(request, httpx.Request)\n+\n+        assert \"Prefect-Csrf-Token\" not in request.headers\n+        assert \"Prefect-Csrf-Client\" not in request.headers\n+\n+    @pytest.mark.parametrize(\"method\", [\"post\", \"put\", \"patch\", \"delete\"])\n+    async def test_csrf_headers_on_change_request(self, method: str):\n+        async with mocked_client(responses=[RESPONSE_CSRF, RESPONSE_200]) as (\n+            client,\n+            send,\n+        ):\n+            await getattr(client, method)(url=\"fake.url/fake/route\")\n+\n+        assert send.await_count == 2\n+\n+        # The first call should be for the CSRF token\n+        request = send.call_args_list[0][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.method == \"GET\"\n+        assert request.url == httpx.URL(\n+            f\"/csrf-token?client={str(client.csrf_client_id)}\"\n+        )\n+\n+        # The second call should be for the actual request\n+        request = send.call_args_list[1][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.method == method.upper()\n+        assert request.url == httpx.URL(\"/fake.url/fake/route\")\n+        assert request.headers[\"Prefect-Csrf-Token\"] == \"test_token\"\n+        assert request.headers[\"Prefect-Csrf-Client\"] == str(client.csrf_client_id)\n+\n+    async def test_refreshes_token_on_csrf_403(self):\n+        async with mocked_client(\n+            responses=[\n+                RESPONSE_CSRF,\n+                RESPONSE_INVALID_TOKEN,\n+                RESPONSE_CSRF,\n+                RESPONSE_200,\n+            ]\n+        ) as (\n+            client,\n+            send,\n+        ):\n+            await client.post(url=\"fake.url/fake/route\")\n+\n+        assert send.await_count == 4\n+\n+        # The first call should be for the CSRF token\n+        request = send.call_args_list[0][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.method == \"GET\"\n+        assert request.url == httpx.URL(\n+            f\"/csrf-token?client={str(client.csrf_client_id)}\"\n+        )\n+\n+        # The second call should be for the actual request\n+        request = send.call_args_list[1][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.url == httpx.URL(\"/fake.url/fake/route\")\n+        assert request.headers[\"Prefect-Csrf-Token\"] == \"test_token\"\n+        assert request.headers[\"Prefect-Csrf-Client\"] == str(client.csrf_client_id)\n+\n+        # The third call should be a refresh of the CSRF token\n+        request = send.call_args_list[0][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.method == \"GET\"\n+        assert request.url == httpx.URL(\n+            f\"/csrf-token?client={str(client.csrf_client_id)}\"\n+        )\n+\n+        # The fourth call should be for the actual request\n+        request = send.call_args_list[1][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.url == httpx.URL(\"/fake.url/fake/route\")\n+        assert request.headers[\"Prefect-Csrf-Token\"] == \"test_token\"\n+        assert request.headers[\"Prefect-Csrf-Client\"] == str(client.csrf_client_id)\n+\n+    async def test_does_not_refresh_csrf_token_not_expired(self):\n+        async with mocked_client(responses=[RESPONSE_200]) as (\n+            client,\n+            send,\n+        ):\n+            client.csrf_token = \"fresh_token\"\n+            client.csrf_token_expiration = now + timedelta(days=1)\n+            await client.post(url=\"fake.url/fake/route\")\n+\n+        assert send.await_count == 1\n+\n+        request = send.call_args_list[0][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.url == httpx.URL(\"/fake.url/fake/route\")\n+        assert request.headers[\"Prefect-Csrf-Token\"] == \"fresh_token\"\n+        assert request.headers[\"Prefect-Csrf-Client\"] == str(client.csrf_client_id)\n+\n+    async def test_does_refresh_csrf_token_when_expired(self):\n+        async with mocked_client(responses=[RESPONSE_CSRF, RESPONSE_200]) as (\n+            client,\n+            send,\n+        ):\n+            client.csrf_token = \"old_token\"\n+            client.csrf_token_expiration = now - timedelta(days=1)\n+            await client.post(url=\"fake.url/fake/route\")\n+\n+        assert send.await_count == 2\n+\n+        # The first call should be for the CSRF token\n+        request = send.call_args_list[0][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.method == \"GET\"\n+        assert request.url == httpx.URL(\n+            f\"/csrf-token?client={str(client.csrf_client_id)}\"\n+        )\n+\n+        # The second call should be for the actual request\n+        request = send.call_args_list[1][0][1]\n+        assert isinstance(request, httpx.Request)\n+        assert request.url == httpx.URL(\"/fake.url/fake/route\")\n+        assert request.headers[\"Prefect-Csrf-Token\"] == \"test_token\"\n+        assert request.headers[\"Prefect-Csrf-Client\"] == str(client.csrf_client_id)\n+\n+    async def test_raises_exception_bad_csrf_token_response(self):\n+        async with mocked_client(responses=[RESPONSE_400]) as (\n+            client,\n+            _,\n+        ):\n+            with pytest.raises(PrefectHTTPStatusError):\n+                await client.post(url=\"fake.url/fake/route\")\n+\n+    async def test_disables_csrf_support_404_token_endpoint(self):\n+        async with mocked_client(responses=[RESPONSE_404, RESPONSE_200]) as (\n+            client,\n+            send,\n+        ):\n+            assert client.enable_csrf_support is True\n+            await client.post(url=\"fake.url/fake/route\")\n+            assert client.enable_csrf_support is False"
        },
        {
          "filename": "tests/client/test_prefect_client.py",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -76,6 +76,7 @@\n     PREFECT_API_KEY,\n     PREFECT_API_TLS_INSECURE_SKIP_VERIFY,\n     PREFECT_API_URL,\n+    PREFECT_CLIENT_CSRF_SUPPORT_ENABLED,\n     PREFECT_CLOUD_API_URL,\n     PREFECT_EXPERIMENTAL_ENABLE_FLOW_RUN_INFRA_OVERRIDES,\n     PREFECT_UNIT_TEST_MODE,\n@@ -1352,6 +1353,7 @@ async def test_prefect_api_tls_insecure_skip_verify_setting_set_to_true(monkeypa\n         transport=ANY,\n         base_url=ANY,\n         timeout=ANY,\n+        enable_csrf_support=ANY,\n     )\n \n \n@@ -1366,6 +1368,7 @@ async def test_prefect_api_tls_insecure_skip_verify_setting_set_to_false(monkeyp\n         transport=ANY,\n         base_url=ANY,\n         timeout=ANY,\n+        enable_csrf_support=ANY,\n     )\n \n \n@@ -1378,6 +1381,7 @@ async def test_prefect_api_tls_insecure_skip_verify_default_setting(monkeypatch)\n         transport=ANY,\n         base_url=ANY,\n         timeout=ANY,\n+        enable_csrf_support=ANY,\n     )\n \n \n@@ -2242,3 +2246,25 @@ async def test_delete_deployment_schedule_nonexistent(\n             await prefect_client.delete_deployment_schedule(\n                 deployment.id, nonexistent_schedule_id\n             )\n+\n+\n+class TestPrefectClientCsrfSupport:\n+    def test_enabled_ephemeral(self, prefect_client: PrefectClient):\n+        assert prefect_client.server_type == ServerType.EPHEMERAL\n+        assert prefect_client._client.enable_csrf_support\n+\n+    async def test_enabled_server_type(self, hosted_api_server):\n+        async with PrefectClient(hosted_api_server) as prefect_client:\n+            assert prefect_client.server_type == ServerType.SERVER\n+            assert prefect_client._client.enable_csrf_support\n+\n+    async def test_not_enabled_server_type_cloud(self):\n+        async with PrefectClient(PREFECT_CLOUD_API_URL.value()) as prefect_client:\n+            assert prefect_client.server_type == ServerType.CLOUD\n+            assert not prefect_client._client.enable_csrf_support\n+\n+    async def test_disabled_setting_disabled(self, hosted_api_server):\n+        with temporary_settings({PREFECT_CLIENT_CSRF_SUPPORT_ENABLED: False}):\n+            async with PrefectClient(hosted_api_server) as prefect_client:\n+                assert prefect_client.server_type == ServerType.SERVER\n+                assert not prefect_client._client.enable_csrf_support"
        },
        {
          "filename": "tests/test_deployments.py",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -1012,6 +1012,7 @@ def test_running_a_deployment_blocks_until_termination(\n                 ),\n             ]\n \n+            router.get(\"/csrf-token\", params={\"client\": mock.ANY}).pass_through()\n             router.get(f\"/deployments/name/{d.flow_name}/{d.name}\").pass_through()\n             router.post(f\"/deployments/{deployment_id}/create_flow_run\").pass_through()\n             flow_polls = router.get(re.compile(\"/flow_runs/.*\")).mock(\n@@ -1059,6 +1060,7 @@ async def test_running_a_deployment_blocks_until_termination_async(\n                 ),\n             ]\n \n+            router.get(\"/csrf-token\", params={\"client\": mock.ANY}).pass_through()\n             router.get(f\"/deployments/name/{d.flow_name}/{d.name}\").pass_through()\n             router.post(f\"/deployments/{deployment_id}/create_flow_run\").pass_through()\n             flow_polls = router.get(re.compile(\"/flow_runs/.*\")).mock(\n@@ -1184,6 +1186,7 @@ def test_returns_flow_run_on_timeout(\n         with respx.mock(\n             base_url=PREFECT_API_URL.value(), assert_all_mocked=True\n         ) as router:\n+            router.get(\"/csrf-token\", params={\"client\": mock.ANY}).pass_through()\n             router.get(f\"/deployments/name/{d.flow_name}/{d.name}\").pass_through()\n             router.post(f\"/deployments/{deployment_id}/create_flow_run\").pass_through()\n             flow_polls = router.request(\n@@ -1217,6 +1220,7 @@ def test_returns_flow_run_immediately_when_timeout_is_zero(\n             assert_all_mocked=True,\n             assert_all_called=False,\n         ) as router:\n+            router.get(\"/csrf-token\", params={\"client\": mock.ANY}).pass_through()\n             router.get(f\"/deployments/name/{d.flow_name}/{d.name}\").pass_through()\n             router.post(f\"/deployments/{deployment_id}/create_flow_run\").pass_through()\n             flow_polls = router.request(\n@@ -1261,6 +1265,7 @@ def test_polls_indefinitely(\n             assert_all_mocked=True,\n             assert_all_called=False,\n         ) as router:\n+            router.get(\"/csrf-token\", params={\"client\": mock.ANY}).pass_through()\n             router.get(f\"/deployments/name/{d.flow_name}/{d.name}\").pass_through()\n             router.post(f\"/deployments/{deployment_id}/create_flow_run\").pass_through()\n             flow_polls = router.request("
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "58b9693a28f86051b6c2aab5fbd26f39516b0921",
            "date": "2025-01-14T04:25:36Z",
            "author_login": "desertaxle"
          },
          {
            "sha": "71099db265a94d0811c9e5b77e308bc160ef1a56",
            "date": "2025-01-14T01:24:11Z",
            "author_login": "cicdw"
          },
          {
            "sha": "9234595759b07c367dd518f0d83b049f0bace583",
            "date": "2025-01-13T20:37:13Z",
            "author_login": "chrisguidry"
          },
          {
            "sha": "d2af034e5e24cea346d908a877defe9c114a983b",
            "date": "2025-01-13T20:23:10Z",
            "author_login": "cicdw"
          },
          {
            "sha": "f9f3b7b0e7e2ed39a4d917f14722bba677f96ed1",
            "date": "2025-01-13T19:12:12Z",
            "author_login": "desertaxle"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-352",
    "description": "Cross-Site Request Forgery (CSRF) in GitHub repository prefecthq/prefect prior to 2.16.5.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2023-11-16T17:15:09.200",
    "last_modified": "2024-11-21T08:42:59.960",
    "fix_date": "2024-03-18T16:29:27Z"
  },
  "references": [
    {
      "url": "https://github.com/prefecthq/prefect/commit/227dfcc7e3374c212a4bcd68b14e090b1c02d9d3",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/dab47d99-551c-4355-9ab1-c99cb90235af",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://github.com/prefecthq/prefect/commit/227dfcc7e3374c212a4bcd68b14e090b1c02d9d3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/dab47d99-551c-4355-9ab1-c99cb90235af",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:39.264658",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "prefect",
    "owner": "prefecthq",
    "created_at": "2018-06-29T21:59:26Z",
    "updated_at": "2025-01-14T14:44:44Z",
    "pushed_at": "2025-01-14T13:37:08Z",
    "size": 169342,
    "stars": 18008,
    "forks": 1689,
    "open_issues": 974,
    "watchers": 18008,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.x",
      "2.x"
    ],
    "languages": {
      "Python": 14610574,
      "TypeScript": 1143270,
      "Vue": 124187,
      "JavaScript": 11691,
      "Shell": 11503,
      "Jinja": 6637,
      "Dockerfile": 6384,
      "Lua": 5413,
      "HTML": 2944,
      "CSS": 2232,
      "Mako": 589,
      "Makefile": 304,
      "Brainfuck": 57
    },
    "commit_activity": {
      "total_commits_last_year": 3275,
      "avg_commits_per_week": 62.98076923076923,
      "days_active_last_year": 294
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:46:38.772303"
  }
}