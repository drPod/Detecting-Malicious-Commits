{
  "cve_id": "CVE-2023-7256",
  "github_data": {
    "repository": "the-tcpdump-group/libpcap",
    "fix_commit": "262e4f34979872d822ccedf9f318ed89c4d31c03",
    "related_commits": [
      "262e4f34979872d822ccedf9f318ed89c4d31c03",
      "2aa69b04d8173b18a0e3492e0c8f2f7fabdf642d"
    ],
    "patch_url": "https://github.com/the-tcpdump-group/libpcap/commit/262e4f34979872d822ccedf9f318ed89c4d31c03.patch",
    "fix_commit_details": {
      "sha": "262e4f34979872d822ccedf9f318ed89c4d31c03",
      "commit_date": "2023-09-28T07:37:57Z",
      "author": {
        "login": "guyharris",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Have sock_initaddress() return the list of addrinfo structures or NULL.",
        "length": 736,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 133,
        "additions": 75,
        "deletions": 58
      },
      "files": [
        {
          "filename": "pcap-rpcap.c",
          "status": "modified",
          "additions": 25,
          "deletions": 23,
          "patch": "@@ -1024,17 +1024,16 @@ rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n {\n \tstruct activehosts *temp;\t\t\t/* temp var needed to scan the host list chain */\n \tstruct addrinfo hints, *addrinfo, *ai_next;\t/* temp var needed to translate between hostname to its address */\n-\tint retval;\n \n \t/* retrieve the network address corresponding to 'host' */\n \taddrinfo = NULL;\n \tmemset(&hints, 0, sizeof(struct addrinfo));\n \thints.ai_family = PF_UNSPEC;\n \thints.ai_socktype = SOCK_STREAM;\n \n-\tretval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,\n+\taddrinfo = sock_initaddress(host, NULL, &hints, errbuf,\n \t    PCAP_ERRBUF_SIZE);\n-\tif (retval != 0)\n+\tif (addrinfo == NULL)\n \t{\n \t\t*error = 1;\n \t\treturn NULL;\n@@ -1186,7 +1185,9 @@ static int pcap_startcapture_remote(pcap_t *fp)\n \t\thints.ai_flags = AI_PASSIVE;\t/* Data connection is opened by the server toward the client */\n \n \t\t/* Let's the server pick up a free network port for us */\n-\t\tif (sock_initaddress(NULL, NULL, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)\n+\t\taddrinfo = sock_initaddress(NULL, NULL, &hints, fp->errbuf,\n+\t\t    PCAP_ERRBUF_SIZE);\n+\t\tif (addrinfo == NULL)\n \t\t\tgoto error_nodiscard;\n \n \t\tif ((sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER,\n@@ -1311,7 +1312,9 @@ static int pcap_startcapture_remote(pcap_t *fp)\n \t\t\tsnprintf(portstring, PCAP_BUF_SIZE, \"%d\", ntohs(startcapreply.portdata));\n \n \t\t\t/* Let's the server pick up a free network port for us */\n-\t\t\tif (sock_initaddress(host, portstring, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)\n+\t\t\taddrinfo = sock_initaddress(host, portstring, &hints,\n+\t\t\t    fp->errbuf, PCAP_ERRBUF_SIZE);\n+\t\t\tif (addrinfo == NULL)\n \t\t\t\tgoto error;\n \n \t\t\tif ((sockdata = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n@@ -2418,16 +2421,16 @@ rpcap_setup_session(const char *source, struct pcap_rmtauth *auth,\n \t\tif (port[0] == 0)\n \t\t{\n \t\t\t/* the user chose not to specify the port */\n-\t\t\tif (sock_initaddress(host, RPCAP_DEFAULT_NETPORT,\n-\t\t\t    &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n-\t\t\t\treturn -1;\n+\t\t\taddrinfo = sock_initaddress(host, RPCAP_DEFAULT_NETPORT,\n+\t\t\t    &hints, errbuf, PCAP_ERRBUF_SIZE);\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tif (sock_initaddress(host, port, &hints, &addrinfo,\n-\t\t\t    errbuf, PCAP_ERRBUF_SIZE) == -1)\n-\t\t\t\treturn -1;\n+\t\t\taddrinfo = sock_initaddress(host, port, &hints,\n+\t\t\t    errbuf, PCAP_ERRBUF_SIZE);\n \t\t}\n+\t\tif (addrinfo == NULL)\n+\t\t\treturn -1;\n \n \t\tif ((*sockctrlp = sock_open(host, addrinfo, SOCKOPEN_CLIENT, 0,\n \t\t    errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n@@ -3038,19 +3041,19 @@ SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const cha\n \t/* Do the work */\n \tif ((port == NULL) || (port[0] == 0))\n \t{\n-\t\tif (sock_initaddress(address, RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n-\t\t{\n-\t\t\treturn (SOCKET)-2;\n-\t\t}\n+\t\taddrinfo = sock_initaddress(address,\n+\t\t    RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, errbuf,\n+\t\t    PCAP_ERRBUF_SIZE);\n \t}\n \telse\n \t{\n-\t\tif (sock_initaddress(address, port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n-\t\t{\n-\t\t\treturn (SOCKET)-2;\n-\t\t}\n+\t\taddrinfo = sock_initaddress(address, port, &hints, errbuf,\n+\t\t    PCAP_ERRBUF_SIZE);\n+\t}\n+\tif (addrinfo == NULL)\n+\t{\n+\t\treturn (SOCKET)-2;\n \t}\n-\n \n \tif ((sockmain = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n \t{\n@@ -3210,7 +3213,6 @@ int pcap_remoteact_close(const char *host, char *errbuf)\n {\n \tstruct activehosts *temp, *prev;\t/* temp var needed to scan the host list chain */\n \tstruct addrinfo hints, *addrinfo, *ai_next;\t/* temp var needed to translate between hostname to its address */\n-\tint retval;\n \n \ttemp = activeHosts;\n \tprev = NULL;\n@@ -3221,9 +3223,9 @@ int pcap_remoteact_close(const char *host, char *errbuf)\n \thints.ai_family = PF_UNSPEC;\n \thints.ai_socktype = SOCK_STREAM;\n \n-\tretval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,\n+\taddrinfo = sock_initaddress(host, NULL, &hints, errbuf,\n \t    PCAP_ERRBUF_SIZE);\n-\tif (retval != 0)\n+\tif (addrinfo == NULL)\n \t{\n \t\treturn -1;\n \t}"
        },
        {
          "filename": "rpcapd/daemon.c",
          "status": "modified",
          "additions": 9,
          "deletions": 5,
          "patch": "@@ -2085,7 +2085,9 @@ daemon_msg_startcap_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,\n \t\t\tgoto error;\n \t\t}\n \n-\t\tif (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n+\t\taddrinfo = sock_initaddress(peerhost, portdata, &hints,\n+\t\t    errmsgbuf, PCAP_ERRBUF_SIZE);\n+\t\tif (addrinfo == NULL)\n \t\t\tgoto error;\n \n \t\tif ((session->sockdata = sock_open(peerhost, addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n@@ -2098,15 +2100,17 @@ daemon_msg_startcap_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,\n \t\tif (data_port[0] != '\\0')\n \t\t{\n \t\t\t// Use the specified network port\n-\t\t\tif (sock_initaddress(NULL, data_port, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n-\t\t\t\tgoto error;\n+\t\t\taddrinfo = sock_initaddress(NULL, data_port, &hints,\n+\t\t\t    errmsgbuf, PCAP_ERRBUF_SIZE);\n \t\t}\n \t\telse\n \t\t{\n \t\t\t// Make the server socket pick up a free network port for us\n-\t\t\tif (sock_initaddress(NULL, NULL, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n-\t\t\t\tgoto error;\n+\t\t\taddrinfo = sock_initaddress(NULL, NULL, &hints,\n+\t\t\t    errmsgbuf, PCAP_ERRBUF_SIZE);\n \t\t}\n+\t\tif (addrinfo == NULL)\n+\t\t\tgoto error;\n \n \t\tif ((session->sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1 /* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n \t\t\tgoto error;"
        },
        {
          "filename": "rpcapd/rpcapd.c",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -618,7 +618,9 @@ void main_startup(void)\n \t\t//\n \t\t// Get a list of sockets on which to listen.\n \t\t//\n-\t\tif (sock_initaddress((address[0]) ? address : NULL, port, &mainhints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n+\t\taddrinfo = sock_initaddress((address[0]) ? address : NULL,\n+\t\t    port, &mainhints, errbuf, PCAP_ERRBUF_SIZE);\n+\t\tif (addrinfo == NULL)\n \t\t{\n \t\t\trpcapd_log(LOGPRIO_DEBUG, \"%s\", errbuf);\n \t\t\treturn;\n@@ -1357,7 +1359,9 @@ main_active(void *ptr)\n \tmemset(errbuf, 0, sizeof(errbuf));\n \n \t// Do the work\n-\tif (sock_initaddress(activepars->address, activepars->port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n+\taddrinfo = sock_initaddress(activepars->address, activepars->port,\n+\t    &hints, errbuf, PCAP_ERRBUF_SIZE);\n+\tif (addrinfo == NULL)\n \t{\n \t\trpcapd_log(LOGPRIO_DEBUG, \"%s\", errbuf);\n \t\treturn 0;"
        },
        {
          "filename": "sockutils.c",
          "status": "modified",
          "additions": 33,
          "deletions": 25,
          "patch": "@@ -1069,20 +1069,21 @@ get_gai_errstring(char *errbuf, int errbuflen, const char *prefix, int err,\n  * \\param errbuflen: length of the buffer that will contains the error. The error message cannot be\n  * larger than 'errbuflen - 1' because the last char is reserved for the string terminator.\n  *\n- * \\return '0' if everything is fine, '-1' if some errors occurred. The error message is returned\n- * in the 'errbuf' variable. The addrinfo variable that has to be used in the following sockets calls is\n- * returned into the addrinfo parameter.\n+ * \\return a pointer to the first element in a list of addrinfo structures\n+ * if everything is fine, NULL if some errors occurred. The error message\n+ * is returned in the 'errbuf' variable.\n  *\n- * \\warning The 'addrinfo' variable has to be deleted by the programmer by calling freeaddrinfo() when\n- * it is no longer needed.\n+ * \\warning The list of addrinfo structures returned has to be deleted by\n+ * the programmer by calling freeaddrinfo() when it is no longer needed.\n  *\n  * \\warning This function requires the 'hints' variable as parameter. The semantic of this variable is the same\n  * of the one of the corresponding variable used into the standard getaddrinfo() socket function. We suggest\n  * the programmer to look at that function in order to set the 'hints' variable appropriately.\n  */\n-int sock_initaddress(const char *host, const char *port,\n-    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n+struct addrinfo *sock_initaddress(const char *host, const char *port,\n+    struct addrinfo *hints, char *errbuf, int errbuflen)\n {\n+\tstruct addrinfo *addrinfo;\n \tint retval;\n \n \t/*\n@@ -1094,9 +1095,13 @@ int sock_initaddress(const char *host, const char *port,\n \t * as those messages won't talk about a problem with the port if\n \t * no port was specified.\n \t */\n-\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n+\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, &addrinfo);\n \tif (retval != 0)\n \t{\n+\t\t/*\n+\t\t * That call failed.\n+\t\t * Determine whether the problem is that the host is bad.\n+\t\t */\n \t\tif (errbuf)\n \t\t{\n \t\t\tif (host != NULL && port != NULL) {\n@@ -1108,7 +1113,7 @@ int sock_initaddress(const char *host, const char *port,\n \t\t\t\tint try_retval;\n \n \t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n-\t\t\t\t    addrinfo);\n+\t\t\t\t    &addrinfo);\n \t\t\t\tif (try_retval == 0) {\n \t\t\t\t\t/*\n \t\t\t\t\t * Worked with just the host,\n@@ -1117,28 +1122,31 @@ int sock_initaddress(const char *host, const char *port,\n \t\t\t\t\t *\n \t\t\t\t\t * Free up the address info first.\n \t\t\t\t\t */\n-\t\t\t\t\tfreeaddrinfo(*addrinfo);\n+\t\t\t\t\tfreeaddrinfo(addrinfo);\n \t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n \t\t\t\t\t    \"\", retval, NULL, port);\n \t\t\t\t} else {\n \t\t\t\t\t/*\n \t\t\t\t\t * Didn't work with just the host,\n \t\t\t\t\t * so assume the problem is\n-\t\t\t\t\t * with the host.\n+\t\t\t\t\t * with the host; we assume\n+\t\t\t\t\t * the original error indicates\n+\t\t\t\t\t * the underlying problem.\n \t\t\t\t\t */\n \t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n \t\t\t\t\t    \"\", retval, host, NULL);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t/*\n \t\t\t\t * Either the host or port was null, so\n-\t\t\t\t * there's nothing to determine.\n+\t\t\t\t * there's nothing to determine; report\n+\t\t\t\t * the error from the original call.\n \t\t\t\t */\n \t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n \t\t\t\t    retval, host, port);\n \t\t\t}\n \t\t}\n-\t\treturn -1;\n+\t\treturn NULL;\n \t}\n \t/*\n \t * \\warning SOCKET: I should check all the accept() in order to bind to all addresses in case\n@@ -1153,30 +1161,28 @@ int sock_initaddress(const char *host, const char *port,\n \t * ignore all addresses that are neither?  (What, no IPX\n \t * support? :-))\n \t */\n-\tif (((*addrinfo)->ai_family != PF_INET) &&\n-\t    ((*addrinfo)->ai_family != PF_INET6))\n+\tif ((addrinfo->ai_family != PF_INET) &&\n+\t    (addrinfo->ai_family != PF_INET6))\n \t{\n \t\tif (errbuf)\n \t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n-\t\tfreeaddrinfo(*addrinfo);\n-\t\t*addrinfo = NULL;\n-\t\treturn -1;\n+\t\tfreeaddrinfo(addrinfo);\n+\t\treturn NULL;\n \t}\n \n \t/*\n \t * You can't do multicast (or broadcast) TCP.\n \t */\n-\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n-\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n+\tif ((addrinfo->ai_socktype == SOCK_STREAM) &&\n+\t    (sock_ismcastaddr(addrinfo->ai_addr) == 0))\n \t{\n \t\tif (errbuf)\n \t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n-\t\tfreeaddrinfo(*addrinfo);\n-\t\t*addrinfo = NULL;\n-\t\treturn -1;\n+\t\tfreeaddrinfo(addrinfo);\n+\t\treturn NULL;\n \t}\n \n-\treturn 0;\n+\treturn addrinfo;\n }\n \n /*\n@@ -2089,7 +2095,9 @@ int sock_present2network(const char *address, struct sockaddr_storage *sockaddr,\n \n \thints.ai_family = addr_family;\n \n-\tif (sock_initaddress(address, \"22222\" /* fake port */, &hints, &addrinfo, errbuf, errbuflen) == -1)\n+\taddrinfo = sock_initaddress(address, \"22222\" /* fake port */, &hints,\n+\t    errbuf, errbuflen);\n+\tif (addrinfo == NULL)\n \t\treturn 0;\n \n \tif (addrinfo->ai_family == PF_INET)"
        },
        {
          "filename": "sockutils.h",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -138,9 +138,8 @@ void sock_fmterrmsg(char *errbuf, size_t errbuflen, int errcode,\n     PCAP_FORMAT_STRING(const char *fmt), ...) PCAP_PRINTFLIKE(4, 5);\n void sock_geterrmsg(char *errbuf, size_t errbuflen,\n     PCAP_FORMAT_STRING(const char *fmt), ...)  PCAP_PRINTFLIKE(3, 4);\n-int sock_initaddress(const char *address, const char *port,\n-    struct addrinfo *hints, struct addrinfo **addrinfo,\n-    char *errbuf, int errbuflen);\n+struct addrinfo *sock_initaddress(const char *address, const char *port,\n+    struct addrinfo *hints, char *errbuf, int errbuflen);\n int sock_recv(SOCKET sock, SSL *, void *buffer, size_t size, int receiveall,\n     char *errbuf, int errbuflen);\n int sock_recv_dgram(SOCKET sock, SSL *, void *buffer, size_t size,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "55b339073f1c294c00b4e5b5a05531f50307749d",
            "date": "2025-01-14T07:56:28Z",
            "author_login": "fxlb"
          },
          {
            "sha": "54ff58b6adfae2624f1d74da963338e74a92333e",
            "date": "2025-01-13T19:58:32Z",
            "author_login": "fxlb"
          },
          {
            "sha": "a3ecee745bd19f4cd14542d7268ac41836bfa967",
            "date": "2025-01-13T17:55:19Z",
            "author_login": "infrastation"
          },
          {
            "sha": "394d2af271c9aa994d0c0387a8566063c0a5664b",
            "date": "2025-01-13T15:03:04Z",
            "author_login": "infrastation"
          },
          {
            "sha": "a8f2e2c61304c35233b6ec38aa4815e8e6804dbb",
            "date": "2025-01-10T22:44:01Z",
            "author_login": "infrastation"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.4,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-415",
    "description": "In affected libpcap versions during the setup of a remote packet capture the internal function sock_initaddress() calls getaddrinfo() and possibly freeaddrinfo(), but does not clearly indicate to the caller function whether freeaddrinfo() still remains to be called after the function returns.  This makes it possible in some scenarios that both the function and its caller call freeaddrinfo() for the same allocated memory block.  A similar problem was reported in Apple libpcap, to which Apple assigned CVE-2023-40400.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-08-31T00:15:05.240",
    "last_modified": "2024-09-19T17:53:15.207",
    "fix_date": "2023-09-28T07:37:57Z"
  },
  "references": [
    {
      "url": "https://github.com/the-tcpdump-group/libpcap/commit/262e4f34979872d822ccedf9f318ed89c4d31c03",
      "source": "security@tcpdump.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/the-tcpdump-group/libpcap/commit/2aa69b04d8173b18a0e3492e0c8f2f7fabdf642d",
      "source": "security@tcpdump.org",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.419257",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libpcap",
    "owner": "the-tcpdump-group",
    "created_at": "2013-04-14T21:46:36Z",
    "updated_at": "2025-01-14T07:59:57Z",
    "pushed_at": "2025-01-14T08:00:17Z",
    "size": 19420,
    "stars": 2758,
    "forks": 861,
    "open_issues": 135,
    "watchers": 2758,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "libpcap-0.6",
      "libpcap-0.7",
      "libpcap-0.8",
      "libpcap-0.9",
      "libpcap-1.0",
      "libpcap-1.1",
      "libpcap-1.2",
      "libpcap-1.3",
      "libpcap-1.4",
      "libpcap-1.5",
      "libpcap-1.6",
      "libpcap-1.7",
      "libpcap-1.8",
      "libpcap-1.9",
      "libpcap-1.10",
      "master"
    ],
    "languages": {
      "C": 2213301,
      "Roff": 194190,
      "CMake": 159822,
      "Perl": 144663,
      "M4": 86167,
      "Shell": 48113,
      "Makefile": 38238,
      "Lex": 18192,
      "Python": 10732
    },
    "commit_activity": {
      "total_commits_last_year": 453,
      "avg_commits_per_week": 8.711538461538462,
      "days_active_last_year": 176
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:39:53.087570"
  }
}