{
  "cve_id": "CVE-2023-7258",
  "github_data": {
    "repository": "google/gvisor",
    "fix_commit": "6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
    "related_commits": [
      "6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
      "6a112c60a257dadac59962e0bc9e9b5aee70b5b6"
    ],
    "patch_url": "https://github.com/google/gvisor/commit/6a112c60a257dadac59962e0bc9e9b5aee70b5b6.patch",
    "fix_commit_details": {
      "sha": "6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
      "commit_date": "2023-11-30T20:04:32Z",
      "author": {
        "login": "manninglucas",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Check for mounts marked as unmounted before propagating.",
        "length": 285,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 126,
        "additions": 91,
        "deletions": 35
      },
      "files": [
        {
          "filename": "pkg/sentry/vfs/mount.go",
          "status": "modified",
          "additions": 70,
          "deletions": 34,
          "patch": "@@ -33,7 +33,11 @@ import (\n // MountMax is the maximum number of mounts allowed. In Linux this can be\n // configured by the user at /proc/sys/fs/mount-max, but the default is\n // 100,000. We set the gVisor limit to 10,000.\n-const MountMax = 10000\n+const (\n+\tMountMax     = 10000\n+\tnsfsName     = \"nsfs\"\n+\tcgroupFsName = \"cgroup\"\n+)\n \n // A Mount is a replacement of a Dentry (Mount.key.point) from one Filesystem\n // (Mount.key.parent.fs) with a Dentry (Mount.root) from another Filesystem\n@@ -214,6 +218,19 @@ func (mnt *Mount) coveringMount() *Mount {\n \treturn child\n }\n \n+// validInMountNS checks if the mount is valid in the current mount namespace. This includes\n+// checking if has previously been unmounted. It is analogous to fs/namespace.c:check_mnt() in\n+// Linux.\n+//\n+// +checklocks:vfs.mountMu\n+func (vfs *VirtualFilesystem) validInMountNS(ctx context.Context, mnt *Mount) bool {\n+\tif mntns := MountNamespaceFromContext(ctx); mntns != nil {\n+\t\tvfs.delayDecRef(mntns)\n+\t\treturn mnt.ns == mntns && !mnt.umounted\n+\t}\n+\treturn false\n+}\n+\n // NewFilesystem creates a new filesystem object not yet associated with any\n // mounts. It can be installed into the filesystem tree with ConnectMountAt.\n // Note that only the filesystem-specific mount options from opts are used by\n@@ -253,20 +270,17 @@ func (vfs *VirtualFilesystem) MountDisconnected(ctx context.Context, creds *auth\n \treturn newMount(vfs, fs, root, nil /* mntns */, opts), nil\n }\n \n-// attachTreeLocked attaches the mount tree at mnt to vd and propagates the\n-// mount to vd.mount's peers and followers. This method consumes the reference\n-// on vd. It is analogous to fs/namespace.c:attach_recursive_mnt() in Linux.\n+// attachTreeLocked attaches the mount tree at mnt to mp and propagates the mount to mp.mount's\n+// peers and followers. This method consumes the reference on mp. It is analogous to\n+// fs/namespace.c:attach_recursive_mnt() in Linux. The mount point mp must have its dentry locked\n+// before calling attachTreeLocked.\n //\n // +checklocks:vfs.mountMu\n-func (vfs *VirtualFilesystem) attachTreeLocked(ctx context.Context, mnt *Mount, vd VirtualDentry) error {\n-\tmp, err := vfs.lockMountpoint(vd)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n+func (vfs *VirtualFilesystem) attachTreeLocked(ctx context.Context, mnt *Mount, mp VirtualDentry) error {\n \tcleanup := cleanup.Make(func() {\n \t\tvfs.cleanupGroupIDs(mnt.submountsLocked()) // +checklocksforce\n \t\tmp.dentry.mu.Unlock()\n-\t\tmp.DecRef(ctx)\n+\t\tvfs.delayDecRef(mp)\n \t})\n \tdefer cleanup.Clean()\n \t// This is equivalent to checking for SB_NOUSER in Linux, which is set on all\n@@ -279,7 +293,10 @@ func (vfs *VirtualFilesystem) attachTreeLocked(ctx context.Context, mnt *Mount,\n \t\treturn err\n \t}\n \n-\tvar propMnts map[*Mount]struct{}\n+\tvar (\n+\t\tpropMnts map[*Mount]struct{}\n+\t\terr      error\n+\t)\n \tif mp.mount.isShared {\n \t\tif err := vfs.allocMountGroupIDs(mnt, true); err != nil {\n \t\t\treturn err\n@@ -325,7 +342,16 @@ func (vfs *VirtualFilesystem) ConnectMountAt(ctx context.Context, creds *auth.Cr\n \t}\n \tvfs.lockMounts()\n \tdefer vfs.unlockMounts(ctx)\n-\treturn vfs.attachTreeLocked(ctx, mnt, vd)\n+\tmp, err := vfs.lockMountpoint(vd)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif mp.mount.neverConnected() || mp.mount.umounted {\n+\t\tmp.dentry.mu.Unlock()\n+\t\tvfs.delayDecRef(mp)\n+\t\treturn linuxerr.EINVAL\n+\t}\n+\treturn vfs.attachTreeLocked(ctx, mnt, mp)\n }\n \n // lockMountpoint returns VirtualDentry with a locked Dentry. If vd is a\n@@ -500,18 +526,37 @@ func (vfs *VirtualFilesystem) BindAt(ctx context.Context, creds *auth.Credential\n \n \tvfs.lockMounts()\n \tdefer vfs.unlockMounts(ctx)\n+\tmp, err := vfs.lockMountpoint(targetVd)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tcleanup := cleanup.Make(func() {\n+\t\tmp.dentry.mu.Unlock()\n+\t\tvfs.delayDecRef(mp) // +checklocksforce\n+\t})\n+\tdefer cleanup.Clean()\n+\t// Namespace mounts can be binded to other mount points.\n+\tfsName := sourceVd.mount.Filesystem().FilesystemType().Name()\n+\tif !vfs.validInMountNS(ctx, sourceVd.mount) && fsName != nsfsName && fsName != cgroupFsName {\n+\t\treturn linuxerr.EINVAL\n+\t}\n+\tif !vfs.validInMountNS(ctx, mp.mount) {\n+\t\treturn linuxerr.EINVAL\n+\t}\n+\n \tvar clone *Mount\n \tif recursive {\n \t\tclone, err = vfs.cloneMountTree(ctx, sourceVd.mount, sourceVd.dentry, 0, nil)\n \t} else {\n \t\tclone, err = vfs.cloneMount(sourceVd.mount, sourceVd.dentry, nil, 0)\n \t}\n \tif err != nil {\n-\t\tvfs.delayDecRef(targetVd)\n \t\treturn err\n \t}\n+\tcleanup.Release()\n+\n \tvfs.delayDecRef(clone)\n-\tif err := vfs.attachTreeLocked(ctx, clone, targetVd); err != nil {\n+\tif err := vfs.attachTreeLocked(ctx, clone, mp); err != nil {\n \t\tvfs.abortUncomittedChildren(ctx, clone)\n \t\treturn err\n \t}\n@@ -528,11 +573,8 @@ func (vfs *VirtualFilesystem) RemountAt(ctx context.Context, creds *auth.Credent\n \tvfs.lockMounts()\n \tdefer vfs.unlockMounts(ctx)\n \tmnt := vd.Mount()\n-\tif mntns := MountNamespaceFromContext(ctx); mntns != nil {\n-\t\tvfs.delayDecRef(mntns)\n-\t\tif mntns != mnt.ns {\n-\t\t\treturn linuxerr.EINVAL\n-\t\t}\n+\tif !vfs.validInMountNS(ctx, mnt) {\n+\t\treturn linuxerr.EINVAL\n \t}\n \treturn mnt.setMountOptions(opts)\n }\n@@ -576,15 +618,11 @@ func (vfs *VirtualFilesystem) UmountAt(ctx context.Context, creds *auth.Credenti\n \n \tvfs.lockMounts()\n \tdefer vfs.unlockMounts(ctx)\n-\tif mntns := MountNamespaceFromContext(ctx); mntns != nil {\n-\t\tvfs.delayDecRef(mntns)\n-\t\tif mntns != vd.mount.ns {\n-\t\t\treturn linuxerr.EINVAL\n-\t\t}\n-\n-\t\tif vd.mount == vd.mount.ns.root {\n-\t\t\treturn linuxerr.EINVAL\n-\t\t}\n+\tif !vfs.validInMountNS(ctx, vd.mount) {\n+\t\treturn linuxerr.EINVAL\n+\t}\n+\tif vd.mount == vd.mount.ns.root {\n+\t\treturn linuxerr.EINVAL\n \t}\n \n \tif opts.Flags&linux.MNT_DETACH == 0 && vfs.arePropMountsBusy(vd.mount) {\n@@ -899,7 +937,7 @@ func (mnt *Mount) LeakMessage() string {\n // This should only be set to true for debugging purposes, as it can generate an\n // extremely large amount of output and drastically degrade performance.\n func (mnt *Mount) LogRefs() bool {\n-\treturn false\n+\treturn true\n }\n \n // getMountAt returns the last Mount in the stack mounted at (mnt, d). It takes\n@@ -1099,9 +1137,7 @@ func (vfs *VirtualFilesystem) PivotRoot(ctx context.Context, creds *auth.Credent\n \t\treturn newRoot, oldRoot, linuxerr.EINVAL\n \t}\n \t// The current root and the new root must be in the context's mount namespace.\n-\tns := MountNamespaceFromContext(ctx)\n-\tvfs.delayDecRef(ns)\n-\tif oldRoot.mount.ns != ns || newRoot.mount.ns != ns {\n+\tif !vfs.validInMountNS(ctx, oldRoot.mount) || !vfs.validInMountNS(ctx, newRoot.mount) {\n \t\treturn newRoot, oldRoot, linuxerr.EINVAL\n \t}\n \t// The current root and the new root cannot be on the rootfs mount.\n@@ -1125,11 +1161,11 @@ func (vfs *VirtualFilesystem) PivotRoot(ctx context.Context, creds *auth.Credent\n \trootMp := vfs.disconnectLocked(oldRoot.mount)\n \n \tputOld.IncRef()\n-\tvfs.connectLocked(oldRoot.mount, putOld, ns)\n+\tvfs.connectLocked(oldRoot.mount, putOld, putOld.mount.ns)\n \tputOld.dentry.mu.Unlock()\n \n \trootMp.dentry.mu.Lock()\n-\tvfs.connectLocked(newRoot.mount, rootMp, ns)\n+\tvfs.connectLocked(newRoot.mount, rootMp, rootMp.mount.ns)\n \trootMp.dentry.mu.Unlock()\n \tvfs.mounts.seq.EndWrite()\n "
        },
        {
          "filename": "pkg/sentry/vfs/propagation.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -266,7 +266,7 @@ func (vfs *VirtualFilesystem) peers(m1, m2 *Mount) bool {\n // +checklocks:vfs.mountMu\n func (vfs *VirtualFilesystem) propagateMount(ctx context.Context, dstMnt *Mount, dstPoint *Dentry, state *propState) error {\n \t// Skip newly added mounts.\n-\tif dstMnt.neverConnected() {\n+\tif dstMnt.neverConnected() || dstMnt.umounted {\n \t\treturn nil\n \t}\n \tmp := VirtualDentry{mount: dstMnt, dentry: dstPoint}"
        },
        {
          "filename": "test/syscalls/linux/BUILD",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1406,6 +1406,7 @@ cc_binary(\n     linkstatic = 1,\n     deps = [\n         \"//test/util:capability_util\",\n+        \"//test/util:cleanup\",\n         \"//test/util:file_descriptor\",\n         \"//test/util:fs_util\",\n         \"@com_google_absl//absl/strings\","
        },
        {
          "filename": "test/syscalls/linux/mount.cc",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -52,9 +52,11 @@\n #include \"absl/strings/str_format.h\"\n #include \"absl/strings/str_split.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"absl/strings/substitute.h\"\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n #include \"test/util/capability_util.h\"\n+#include \"test/util/cleanup.h\"\n #include \"test/util/eventfd_util.h\"\n #include \"test/util/file_descriptor.h\"\n #include \"test/util/fs_util.h\"\n@@ -2268,6 +2270,23 @@ TEST(MountTest, RemountUnmounted) {\n               SyscallFailsWithErrno(EINVAL));\n }\n \n+TEST(MountTest, DetachedMountBindFails) {\n+  SKIP_IF(!ASSERT_NO_ERRNO_AND_VALUE(HaveCapability(CAP_SYS_ADMIN)));\n+\n+  const TempPath path1 = ASSERT_NO_ERRNO_AND_VALUE(TempPath::CreateDir());\n+  Cleanup mount_cleanup = ASSERT_NO_ERRNO_AND_VALUE(\n+      Mount(\"\", path1.path().c_str(), kTmpfs, 0, \"\", MNT_DETACH));\n+  mount_cleanup.Release();\n+  const FileDescriptor fd =\n+      ASSERT_NO_ERRNO_AND_VALUE(Open(path1.path().c_str(), O_RDONLY));\n+  std::string fd_path = absl::Substitute(\"/proc/self/fd/$0\", fd.get());\n+  ASSERT_THAT(umount2(path1.path().c_str(), MNT_DETACH), SyscallSucceeds());\n+  const TempPath path2 = ASSERT_NO_ERRNO_AND_VALUE(TempPath::CreateDir());\n+\n+  EXPECT_THAT(mount(fd_path.c_str(), path2.path().c_str(), \"\", MS_BIND, 0),\n+              SyscallFailsWithErrno(EINVAL));\n+}\n+\n }  // namespace\n \n }  // namespace testing"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3649ca9d9eb6cd4aed8ecfbfd13aef5fa8bdae7a",
            "date": "2025-01-14T05:08:55Z",
            "author_login": "EtiennePerot"
          },
          {
            "sha": "4ba931dd226e5a04d0d8b89586239ebba72b9e0e",
            "date": "2025-01-11T06:31:22Z",
            "author_login": "EtiennePerot"
          },
          {
            "sha": "3f0c7ccf85dfb162bd63e3065bf3f5f3882c9235",
            "date": "2025-01-11T03:41:27Z",
            "author_login": "EtiennePerot"
          },
          {
            "sha": "17962e58c1130cd150b4a1475f4e8cad3ae67423",
            "date": "2025-01-10T23:07:01Z",
            "author_login": "konstantin-s-bogom"
          },
          {
            "sha": "2d0e39a87f4cdaf24737973c4c9682a9ad2dbcc0",
            "date": "2025-01-10T19:41:53Z",
            "author_login": "gvisor-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "A denial of service exists in Gvisor Sandbox where a bug in reference counting code in mount point tracking could lead to a panic, making it possible for an attacker running as root and with permission to mount volumes to kill the sandbox. We recommend upgrading past commit\u00a06a112c60a257dadac59962e0bc9e9b5aee70b5b6",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-05-15T17:15:09.987",
    "last_modified": "2024-11-21T08:45:37.347",
    "fix_date": "2023-11-30T20:04:32Z"
  },
  "references": [
    {
      "url": "https://github.com/google/gvisor/commit/6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
      "source": "cve-coordination@google.com",
      "tags": []
    },
    {
      "url": "https://github.com/google/gvisor/commit/6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.917686",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gvisor",
    "owner": "google",
    "created_at": "2018-04-26T21:28:49Z",
    "updated_at": "2025-01-14T17:52:56Z",
    "pushed_at": "2025-01-14T07:11:20Z",
    "size": 91944,
    "stars": 16008,
    "forks": 1316,
    "open_issues": 428,
    "watchers": 16008,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "go",
      "master",
      "test/cl253260121",
      "test/cl258263294",
      "test/cl258809497",
      "test/cl260256471",
      "test/cl261281902",
      "test/cl263041320",
      "test/cl263368268",
      "test/cl264733455",
      "test/cl265283160",
      "test/cl265338961",
      "test/cl265530468",
      "test/cl266023098",
      "test/cl270351980",
      "test/cl273329276",
      "test/cl274909441",
      "test/cl275514308",
      "test/cl276483963",
      "test/cl277059836",
      "test/cl279796286"
    ],
    "languages": {
      "Go": 18512741,
      "C++": 4149254,
      "Starlark": 880509,
      "Assembly": 196145,
      "C": 103908,
      "Shell": 88273,
      "Makefile": 57766,
      "HTML": 29166,
      "Python": 21977,
      "Dockerfile": 11741,
      "Cuda": 9042,
      "SCSS": 8661,
      "Ruby": 2430,
      "JavaScript": 983,
      "Handlebars": 103,
      "Rust": 45
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T18:05:41.166884"
  }
}