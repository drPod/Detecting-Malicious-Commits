{
  "cve_id": "CVE-2024-10389",
  "github_data": {
    "repository": "google/safearchive",
    "fix_commit": "f7ce9d7b6f9c6ecd72d0b0f16216b046e55e44dc",
    "related_commits": [
      "f7ce9d7b6f9c6ecd72d0b0f16216b046e55e44dc"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "f7ce9d7b6f9c6ecd72d0b0f16216b046e55e44dc",
      "commit_date": "2024-10-15T08:24:47Z",
      "author": {
        "login": "a-googler",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Prevent path traversals via short filenames on Windows.",
        "length": 85,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 186,
        "additions": 182,
        "deletions": 4
      },
      "files": [
        {
          "filename": "sanitizer/BUILD.bazel",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -26,6 +26,7 @@ go_test(\n     size = \"small\",\n     srcs = [\n         \"sanitizer_nix_test.go\",\n+        \"sanitizer_test.go\",\n         \"sanitizer_win_test.go\",\n     ],\n     embed = [\":sanitizer\"],"
        },
        {
          "filename": "sanitizer/sanitizer.go",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -18,13 +18,19 @@ package sanitizer\n \n import (\n \t\"os\"\n+\t\"regexp\"\n+\t\"strings\"\n )\n \n const (\n \twinPathSeparator = `\\`\n \tnixPathSeparator = `/`\n )\n \n+var (\n+\twinShortFilenameRegex = regexp.MustCompile(`~\\d+\\.?`)\n+)\n+\n // SanitizePath sanitizes the supplied path by purely lexical processing.\n // The return value is safe to be joined together with a base directory (if the basedir is empty\n // and no symlinks are present there).\n@@ -43,3 +49,20 @@ func SanitizePath(in string) string {\n \n \treturn sanitized\n }\n+\n+// HasWindowsShortFilenames reports if any path component look like a Windows short filename.\n+// Short filenames on Windows may look like this:\n+// 1(3)~1.PNG     1 (3) (1).png\n+// DOWNLO~1       Downloads\n+// FOOOOO~1.JPG   fooooooooo.png.gif.jpg\n+func HasWindowsShortFilenames(in string) bool {\n+\tin = strings.ReplaceAll(in, \"\\\\\", \"/\")\n+\tparts := strings.Split(in, \"/\")\n+\tfor _, part := range parts {\n+\t\tmatched := winShortFilenameRegex.MatchString(part)\n+\t\tif matched {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"
        },
        {
          "filename": "sanitizer/sanitizer_test.go",
          "status": "added",
          "additions": 53,
          "deletions": 0,
          "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2024 Google LLC.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package sanitizer\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestHasWindowsShortFilenames(t *testing.T) {\n+\ttests := []struct {\n+\t\tin   string\n+\t\twant bool\n+\t}{\n+\t\t{in: \"ANDROI~2\", want: true},\n+\t\t{in: \"foo/ANDROI~2\", want: true},\n+\t\t{in: \"ANDROI~2/bar\", want: true},\n+\t\t{in: \"foo/ANDROI~2/bar\", want: true},\n+\t\t// Same with different case\n+\t\t{in: \"Androi~2\", want: true},\n+\t\t{in: \"foo/Androi~2\", want: true},\n+\t\t{in: \"Androi~2/bar\", want: true},\n+\t\t{in: \"foo/Androi~2/bar\", want: true},\n+\t\t// File extension\n+\t\t{in: \"FOOOOO~1.JPG \", want: true},\n+\t\t{in: \"foo/FOOOOO~1.JPG\", want: true},\n+\t\t{in: \"FOOOOO~1.JPG/bar\", want: true},\n+\t\t{in: \"foo/FOOOOO~1.JPG/bar\", want: true},\n+\t\t// Not a short filename\n+\t\t{in: \"3D Objects\", want: false},\n+\t\t{in: \"Some~Stuff\", want: false},\n+\t}\n+\tfor _, tc := range tests {\n+\t\tfor _, a := range []string{tc.in, strings.ReplaceAll(tc.in, \"\\\\\", \"/\")} {\n+\t\t\tgot := HasWindowsShortFilenames(a)\n+\t\t\tif got != tc.want {\n+\t\t\t\tt.Errorf(\"HasWindowsShortFilenames(%q) = %v, want %v\", a, got, tc.want)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "tar/tar.go",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -186,11 +186,16 @@ const (\n \t// By default, this is activated only on MacOS and Windows builds. If you are extracting to a\n \t// case insensitive filesystem on a Unix platform, you should activate this feature explicitly.\n \tPreventCaseInsensitiveSymlinkTraversal SecurityMode = 64\n+\t// SkipWindowsShortFilenames drops archive entries that have a path component that look like a\n+\t// Windows short filename (e.g. GIT~1).\n+\t// By default, this is activated only on Windows builds. If you are extracting to a Windows\n+\t// filesystem on a non-Windows platform, you should activate this feature explicitly.\n+\tSkipWindowsShortFilenames SecurityMode = 128\n )\n \n // MaximumSecurityMode enables all features for maximum security.\n // Recommended for integrations that need file contents only (and nothing unix specific).\n-const MaximumSecurityMode = SkipSpecialFiles | SanitizeFileMode | SanitizeFilenames | PreventSymlinkTraversal | DropXattrs | PreventCaseInsensitiveSymlinkTraversal\n+const MaximumSecurityMode = SkipSpecialFiles | SanitizeFileMode | SanitizeFilenames | PreventSymlinkTraversal | DropXattrs | PreventCaseInsensitiveSymlinkTraversal | SkipWindowsShortFilenames\n \n var (\n \t// ErrHeader invalid tar header\n@@ -297,6 +302,10 @@ func (tr *Reader) Next() (*tar.Header, error) {\n \t\t\th.Name = sanitizer.SanitizePath(h.Name)\n \t\t}\n \n+\t\tif tr.securityMode&SkipWindowsShortFilenames != 0 && sanitizer.HasWindowsShortFilenames(h.Name) {\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif tr.securityMode&PreventSymlinkTraversal != 0 {\n \t\t\thName := sanitizer.SanitizePath(h.Name)\n \t\t\thName = strings.TrimSuffix(hName, \"/\")"
        },
        {
          "filename": "tar/tar_test.go",
          "status": "modified",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -93,6 +93,23 @@ var (\n \t*/\n \t//go:embed case-insensitive.tar\n \teTraverseViaCaseInsensitiveLinksTar []byte\n+\n+\t/*\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 3D Objects\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 Androi~2\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 ANDROI~2\n+\t\tdrwxr-x--- imrer/primarygroup 0 2024-10-11 14:27 foo/\n+\t\tdrwxr-x--- imrer/primarygroup 0 2024-10-11 14:27 foo/ANDROI~2/\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 foo/ANDROI~2/bar\n+\t\tdrwxr-x--- imrer/primarygroup 0 2024-10-11 14:27 foo/FOOOOO~1.JPG/\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 foo/FOOOOO~1.JPG/bar\n+\t\tdrwxr-x--- imrer/primarygroup 0 2024-10-11 14:27 foo/Androi~2/\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 foo/Androi~2/bar\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 FOOOOO~1.JPG\n+\t\t-rw-r----- imrer/primarygroup 5 2024-10-11 14:27 Some~Stuff\n+\t*/\n+\t//go:embed winshort.tar\n+\teWinShortTar []byte\n )\n \n func isSlashRune(r rune) bool { return r == '/' || r == '\\\\' }\n@@ -493,3 +510,28 @@ func TestSafetarLinksCaseInsensitive(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n }\n+\n+func TestWindowsShortFilenames(t *testing.T) {\n+\tbuf := bytes.NewBuffer(eWinShortTar[:])\n+\tt.Logf(\"size of archive: %d\", len(buf.Bytes()))\n+\ttr := NewReader(buf)\n+\ttr.SetSecurityMode(tr.GetSecurityMode() | SkipWindowsShortFilenames)\n+\n+\tfor i, want := range []string{\"3D Objects\", \"foo/\", \"Some~Stuff\"} {\n+\t\thdr, err := tr.Next()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"No errors were expected at entry %d. Next() = %+v, want nil\", i, err)\n+\t\t}\n+\t\tif hdr.Name != want {\n+\t\t\tt.Errorf(\"Unexpected entry %d. Next().Name = %v, want %v\", i, hdr.Name, want)\n+\t\t}\n+\t}\n+\n+\thdr, err := tr.Next()\n+\tif hdr != nil {\n+\t\tt.Errorf(\"No more tar entries were expected. Next() = %+v, want nil\", hdr)\n+\t}\n+\tif err != io.EOF {\n+\t\tt.Fatal(err)\n+\t}\n+}"
        },
        {
          "filename": "tar/tar_win.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -18,4 +18,4 @@\n package tar\n \n // DefaultSecurityMode is a set of security features that are enabled by default.\n-const DefaultSecurityMode = SanitizeFilenames | PreventSymlinkTraversal | PreventCaseInsensitiveSymlinkTraversal\n+const DefaultSecurityMode = SanitizeFilenames | PreventSymlinkTraversal | PreventCaseInsensitiveSymlinkTraversal | SkipWindowsShortFilenames"
        },
        {
          "filename": "tar/winshort.tar",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "zip/winshort.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "zip/zip.go",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -130,11 +130,16 @@ const (\n \t// By default, this is activated only on MacOS and Windows builds. If you are extracting to a\n \t// case insensitive filesystem on a Unix platform, you should activate this feature explicitly.\n \tPreventCaseInsensitiveSymlinkTraversal SecurityMode = 16\n+\t// SkipWindowsShortFilenames drops archive entries that have a path component that look like a\n+\t// Windows short filename (e.g. GIT~1).\n+\t// By default, this is activated only on Windows builds. If you are extracting to a Windows\n+\t// filesystem on a non-Windows platform, you should activate this feature explicitly.\n+\tSkipWindowsShortFilenames SecurityMode = 32\n )\n \n // MaximumSecurityMode enables all security features. Apps that care about file contents only\n // and nothing unix specific (e.g. file modes or special devices) should use this mode.\n-const MaximumSecurityMode = SanitizeFilenames | PreventSymlinkTraversal | SanitizeFileMode | SkipSpecialFiles | PreventCaseInsensitiveSymlinkTraversal\n+const MaximumSecurityMode = SanitizeFilenames | PreventSymlinkTraversal | SanitizeFileMode | SkipSpecialFiles | PreventCaseInsensitiveSymlinkTraversal | SkipWindowsShortFilenames\n \n func isSpecialFile(f zip.File) bool {\n \tamode := f.Mode()\n@@ -163,6 +168,10 @@ func applyMagic(files []*zip.File, securityMode SecurityMode) []*zip.File {\n \t\t\tf.Name = sanitizer.SanitizePath(f.Name)\n \t\t}\n \n+\t\tif securityMode&SkipWindowsShortFilenames != 0 && sanitizer.HasWindowsShortFilenames(f.Name) {\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif securityMode&PreventSymlinkTraversal != 0 {\n \t\t\tfName := sanitizer.SanitizePath(f.Name)\n \t\t\tfName = strings.TrimSuffix(fName, \"/\")"
        },
        {
          "filename": "zip/zip_test.go",
          "status": "modified",
          "additions": 41,
          "deletions": 0,
          "patch": "@@ -92,6 +92,28 @@ var (\n \t*/\n \t//go:embed case-insensitive.zip\n \teCaseInsensitiveSymlinksZip []byte\n+\n+\t/*\n+\t\tArchive:  winshort.zip\n+\t\t  Length      Date    Time    Name\n+\t\t---------  ---------- -----   ----\n+\t\t        5  2024-10-11 14:27   3D Objects\n+\t\t        5  2024-10-11 14:27   Androi~2\n+\t\t        5  2024-10-11 14:27   ANDROI~2\n+\t\t        0  2024-10-11 14:27   foo/\n+\t\t        5  2024-10-11 14:27   FOOOOO~1.JPG\n+\t\t        5  2024-10-11 14:27   Some~Stuff\n+\t\t        0  2024-10-11 14:27   foo/ANDROI~2/\n+\t\t        5  2024-10-11 14:27   foo/ANDROI~2/bar\n+\t\t        0  2024-10-11 14:27   foo/FOOOOO~1.JPG/\n+\t\t        5  2024-10-11 14:27   foo/FOOOOO~1.JPG/bar\n+\t\t        0  2024-10-11 14:27   foo/Androi~2/\n+\t\t        5  2024-10-11 14:27   foo/Androi~2/bar\n+\t\t---------                     -------\n+\t\t       40                     12 files\n+\t*/\n+\t//go:embed winshort.zip\n+\teWinShortFilenamesZip []byte\n )\n \n func TestSafezip(t *testing.T) {\n@@ -343,3 +365,22 @@ func TestTypes(t *testing.T) {\n \t\tt.Errorf(\"type of zip.OpenReader().Reader: %v, type of zip.NewReader(): %v\", openReaderType, newReaderType)\n \t}\n }\n+\n+func TestWindowsShortFilenames(t *testing.T) {\n+\tpath := archiveToPath(t, eWinShortFilenamesZip)\n+\tr, err := OpenReader(path)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Error opening zip. OpenReader(%v) = %v, want nil\", path, err)\n+\t}\n+\tr.SetSecurityMode(r.GetSecurityMode() | SkipWindowsShortFilenames)\n+\n+\tif len(r.File) != 3 {\n+\t\tt.Fatalf(\"Unexpected number of files in the archive. len(OpenReader(%v).File) = %d, want 2.\", path, len(r.File))\n+\t}\n+\n+\tfor i, want := range []string{\"3D Objects\", \"foo/\", \"Some~Stuff\"} {\n+\t\tif r.File[i].Name != want {\n+\t\t\tt.Errorf(\"Unexpected entry. OpenReader(%v).File[%d].Name = %v, want %v\", path, i, r.File[i].Name, want)\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "zip/zip_win.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -19,4 +19,4 @@ package zip\n \n // DefaultSecurityMode enables path traversal security measures. This mode should be safe for all\n // existing integrations.\n-const DefaultSecurityMode = SanitizeFilenames | PreventSymlinkTraversal | PreventCaseInsensitiveSymlinkTraversal\n+const DefaultSecurityMode = SanitizeFilenames | PreventSymlinkTraversal | PreventCaseInsensitiveSymlinkTraversal | SkipWindowsShortFilenames"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f7ce9d7b6f9c6ecd72d0b0f16216b046e55e44dc",
            "date": "2024-10-15T08:24:47Z",
            "author_login": "a-googler"
          },
          {
            "sha": "05f9db39f9771167f692a70067a6ffbde37c9181",
            "date": "2024-10-15T08:17:12Z",
            "author_login": "a-googler"
          },
          {
            "sha": "d9d7ed1e5b288a0b29d193feaaf3160704f3526c",
            "date": "2024-10-14T12:52:49Z",
            "author_login": "a-googler"
          },
          {
            "sha": "43962120dd0a8a34d9037c020b633a993dc699f2",
            "date": "2024-05-06T13:41:59Z",
            "author_login": "a-googler"
          },
          {
            "sha": "70159a5fe2028c1abc83391260f084d6e91020a9",
            "date": "2023-08-02T07:02:58Z",
            "author_login": "a-googler"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-427",
    "description": "There exists a Path Traversal vulnerability in Safearchive on Platforms with Case-Insensitive Filesystems (e.g., NTFS). This allows Attackers to Write Arbitrary Files via Archive Extraction containing symbolic links. We recommend upgrading past commit\u00a0f7ce9d7b6f9c6ecd72d0b0f16216b046e55e44dc",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-04T11:15:04.647",
    "last_modified": "2024-11-21T17:15:09.200",
    "fix_date": "2024-10-15T08:24:47Z"
  },
  "references": [
    {
      "url": "https://github.com/google/safearchive/commit/f7ce9d7b6f9c6ecd72d0b0f16216b046e55e44dc",
      "source": "cve-coordination@google.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:29.193554",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "safearchive",
    "owner": "google",
    "created_at": "2023-07-24T12:38:36Z",
    "updated_at": "2025-01-14T06:38:27Z",
    "pushed_at": "2024-10-25T13:11:04Z",
    "size": 71,
    "stars": 62,
    "forks": 2,
    "open_issues": 0,
    "watchers": 62,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 68856,
      "Starlark": 4777
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:14:48.874830"
  }
}