{
  "cve_id": "CVE-2024-11403",
  "github_data": {
    "repository": "libjxl/libjxl",
    "fix_commit": "9cc451b91b74ba470fd72bd48c121e9f33d24c99",
    "related_commits": [
      "9cc451b91b74ba470fd72bd48c121e9f33d24c99"
    ],
    "patch_url": "https://github.com/libjxl/libjxl/commit/9cc451b91b74ba470fd72bd48c121e9f33d24c99.patch",
    "fix_commit_details": {
      "sha": "9cc451b91b74ba470fd72bd48c121e9f33d24c99",
      "commit_date": "2024-10-03T16:07:38Z",
      "author": {
        "login": "szabadka",
        "type": "User",
        "stats": {
          "total_commits": 437,
          "average_weekly_commits": 1.649056603773585,
          "total_additions": 75334,
          "total_deletions": 43723,
          "weeks_active": 80
        }
      },
      "commit_message": {
        "title": "Port the Huffman lookup table size fix from brunsli. (#3871)",
        "length": 122,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 32,
        "additions": 24,
        "deletions": 8
      },
      "files": [
        {
          "filename": "lib/jpegli/huffman.h",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -15,10 +15,18 @@ namespace jpegli {\n \n constexpr int kJpegHuffmanRootTableBits = 8;\n // Maximum huffman lookup table size.\n-// According to zlib/examples/enough.c, 758 entries are always enough for\n-// an alphabet of 257 symbols (256 + 1 special symbol for the all 1s code) and\n-// max bit length 16 if the root table has 8 bits.\n-constexpr int kJpegHuffmanLutSize = 758;\n+// Requirements: alphabet of 257 symbols (256 + 1 special symbol for the all 1s\n+// code) and max bit length 16, the root table has 8 bits.\n+// zlib/examples/enough.c works with an assumption that Huffman code is\n+// \"complete\". Input JPEGs might have this assumption broken, hence the\n+// following sum is used as estimate:\n+//  + number of 1-st level cells\n+//  + number of symbols\n+//  + asymptotic amount of repeated 2nd level cells\n+// The third number is 1 + 3 + ... + 255 i.e. it is assumed that sub-table of\n+// each \"size\" might be almost completely be filled with repetitions.\n+// Total sum is slightly less than 1024,...\n+constexpr int kJpegHuffmanLutSize = 1024;\n \n struct HuffmanTableEntry {\n   uint8_t bits;    // number of bits used for this symbol"
        },
        {
          "filename": "lib/jxl/jpeg/enc_jpeg_huffman_decode.h",
          "status": "modified",
          "additions": 12,
          "deletions": 4,
          "patch": "@@ -15,10 +15,18 @@ namespace jpeg {\n \n constexpr int kJpegHuffmanRootTableBits = 8;\n // Maximum huffman lookup table size.\n-// According to zlib/examples/enough.c, 758 entries are always enough for\n-// an alphabet of 257 symbols (256 + 1 special symbol for the all 1s code) and\n-// max bit length 16 if the root table has 8 bits.\n-constexpr int kJpegHuffmanLutSize = 758;\n+// Requirements: alphabet of 257 symbols (256 + 1 special symbol for the all 1s\n+// code) and max bit length 16, the root table has 8 bits.\n+// zlib/examples/enough.c works with an assumption that Huffman code is\n+// \"complete\". Input JPEGs might have this assumption broken, hence the\n+// following sum is used as estimate:\n+//  + number of 1-st level cells\n+//  + number of symbols\n+//  + asymptotic amount of repeated 2nd level cells\n+// The third number is 1 + 3 + ... + 255 i.e. it is assumed that sub-table of\n+// each \"size\" might be almost completely be filled with repetitions.\n+// Total sum is slightly less than 1024,...\n+constexpr int kJpegHuffmanLutSize = 1024;\n \n struct HuffmanTableEntry {\n   // Initialize the value to an invalid symbol so that we can recognize it"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "abdeb5fc0be552fbf4639e6b00a8ee460186795b",
            "date": "2025-01-14T09:37:17Z",
            "author_login": "eustas"
          },
          {
            "sha": "c48ddf64069fe50467e5812032f9b1e05b88b2e3",
            "date": "2025-01-14T08:46:23Z",
            "author_login": "eustas"
          },
          {
            "sha": "387c3291bb850f33a8de17846d4eb5e8aabe60ec",
            "date": "2025-01-14T08:33:35Z",
            "author_login": "eustas"
          },
          {
            "sha": "5352ad42290bf26d505d90ed4edf857b3e7d3578",
            "date": "2025-01-13T14:23:56Z",
            "author_login": "jonsneyers"
          },
          {
            "sha": "10ff565afbfa6d36820b369f2ec094a33708cdc4",
            "date": "2025-01-13T11:13:53Z",
            "author_login": "eustas"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-125",
    "description": "There exists an out of bounds read/write in LibJXL versions prior to commit\u00a09cc451b91b74ba470fd72bd48c121e9f33d24c99. The JPEG decoder used by the JPEG XL encoder\u00a0when doing JPEG recompression (i.e. if using JxlEncoderAddJPEGFrame on untrusted input) does not properly check bounds in the presence of incomplete codes. This could lead to an out-of-bounds write. In jpegli which is released as part of the same project, the same vulnerability is present. However, the relevant buffer is part of a bigger structure, and the code makes no assumptions on the values that could be overwritten. The issue could however cause jpegli to read uninitialised memory, or addresses of functions.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-25T14:15:06.310",
    "last_modified": "2024-11-25T14:15:06.310",
    "fix_date": "2024-10-03T16:07:38Z"
  },
  "references": [
    {
      "url": "https://github.com/libjxl/libjxl/commit/9cc451b91b74ba470fd72bd48c121e9f33d24c99",
      "source": "cve-coordination@google.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.301186",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libjxl",
    "owner": "libjxl",
    "created_at": "2021-02-19T00:56:12Z",
    "updated_at": "2025-01-14T09:46:16Z",
    "pushed_at": "2025-01-14T09:46:12Z",
    "size": 37575,
    "stars": 2778,
    "forks": 269,
    "open_issues": 379,
    "watchers": 2778,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v0.3.x",
      "v0.4.x",
      "v0.5.x",
      "v0.6.x",
      "v0.7.x",
      "v0.8.x",
      "v0.9.x",
      "v0.10.x",
      "v0.11.x"
    ],
    "languages": {
      "C++": 5827205,
      "C": 274043,
      "Python": 155915,
      "CMake": 116920,
      "Shell": 110779,
      "Starlark": 30269,
      "JavaScript": 17434,
      "Java": 15956,
      "HTML": 11360,
      "TypeScript": 3668,
      "MATLAB": 1037,
      "Nix": 861,
      "Roff": 80
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T13:05:50.283258"
  }
}