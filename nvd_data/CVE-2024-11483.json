{
  "cve_id": "CVE-2024-11483",
  "github_data": {
    "repository": "ansible/django-ansible-base",
    "fix_commit": "845b3e1838cc0762a7f9f3e0379c5274519d9a44",
    "related_commits": [
      "845b3e1838cc0762a7f9f3e0379c5274519d9a44"
    ],
    "patch_url": "https://github.com/ansible/django-ansible-base/commit/845b3e1838cc0762a7f9f3e0379c5274519d9a44.patch",
    "fix_commit_details": {
      "sha": "845b3e1838cc0762a7f9f3e0379c5274519d9a44",
      "commit_date": "2024-11-15T20:26:08Z",
      "author": {
        "login": "BrennanPaciorek",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "feat(oauth2_provider): check for OAuth2ScopePermission on all APIViews (#636)",
        "length": 441,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 446,
        "additions": 429,
        "deletions": 17
      },
      "files": [
        {
          "filename": "ansible_base/authentication/views/authenticator_users.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -7,7 +7,7 @@\n from django.http import Http404\n \n from ansible_base.authentication.models import Authenticator\n-from ansible_base.lib.utils.views.permissions import IsSuperuserOrAuditor\n+from ansible_base.lib.utils.views.permissions import IsSuperuserOrAuditor, try_add_oauth2_scope_permission\n \n logger = logging.getLogger('ansible_base.authentication.views.authenticator_users')\n \n@@ -22,7 +22,7 @@ def get_authenticator_user_view():\n             raise ModuleNotFoundError()\n \n         class AuthenticatorPluginRelatedUsersView(user_viewset_view):\n-            permission_classes = [IsSuperuserOrAuditor]\n+            permission_classes = try_add_oauth2_scope_permission([IsSuperuserOrAuditor])\n \n             def get_queryset(self, **kwargs):\n                 # during unit testing we get the pk from kwargs"
        },
        {
          "filename": "ansible_base/lib/dynamic_config/dynamic_urls.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -10,12 +10,14 @@\n for url_type in url_types:\n     globals()[url_type] = []\n \n-for app in getattr(settings, 'INSTALLED_APPS', []):\n+installed_apps = getattr(settings, 'INSTALLED_APPS', [])\n+for app in installed_apps:\n     if app.startswith('ansible_base.'):\n         if not importlib.util.find_spec(f'{app}.urls'):\n             logger.debug(f'Module {app} does not specify urls.py')\n             continue\n         url_module = __import__(f'{app}.urls', fromlist=url_types)\n         logger.debug(f'Including URLS from {app}.urls')\n         for url_type in ['api_version_urls', 'root_urls', 'api_urls']:\n-            globals()[url_type].extend(getattr(url_module, url_type, []))\n+            urls = getattr(url_module, url_type, [])\n+            globals()[url_type].extend(urls)"
        },
        {
          "filename": "ansible_base/lib/dynamic_config/settings_logic.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -283,6 +283,8 @@ def get_dab_settings(\n \n         dab_data['ALLOW_OAUTH2_FOR_EXTERNAL_USERS'] = False\n \n+        dab_data['ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_DEFAULT_IGNORED_VIEWS'] = []\n+\n     if caches is not None:\n         dab_data['CACHES'] = copy(caches)\n         # Ensure proper configuration for fallback cache"
        },
        {
          "filename": "ansible_base/lib/utils/views/permissions.py",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -1,5 +1,25 @@\n from rest_framework.permissions import SAFE_METHODS, BasePermission\n \n+from ansible_base.lib.utils.settings import get_setting\n+\n+oauth2_provider_installed = \"ansible_base.oauth2_provider\" in get_setting(\"INSTALLED_APPS\", [])\n+\n+\n+def try_add_oauth2_scope_permission(permission_classes: list):\n+    \"\"\"\n+    Attach OAuth2ScopePermission to the provided permission_classes list\n+\n+    :param permission_classes: list of rest_framework permissions\n+    :return: A list of permission_classes, including OAuth2ScopePermission\n+        if ansible_base.oauth2_provider is installed; otherwise the same\n+        permission_classes list supplied to the function\n+    \"\"\"\n+    if oauth2_provider_installed:\n+        from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n+\n+        return [OAuth2ScopePermission] + permission_classes\n+    return permission_classes\n+\n \n class IsSuperuser(BasePermission):\n     \"\"\""
        },
        {
          "filename": "ansible_base/lib/utils/views/urls.py",
          "status": "added",
          "additions": 24,
          "deletions": 0,
          "patch": "@@ -0,0 +1,24 @@\n+from typing import Type\n+\n+from rest_framework.schemas.generators import EndpointEnumerator\n+from rest_framework.views import APIView\n+\n+\n+def get_api_view_functions(urlpatterns=None) -> set[Type[APIView]]:\n+    \"\"\"\n+    Extract view classes from a urlpatterns list using the show_urls helper functions\n+\n+    :param urlpatterns: django urlpatterns list\n+    :return: set of all view classes used by the urlpatterns list\n+    \"\"\"\n+    views = set()\n+\n+    enumerator = EndpointEnumerator()\n+    # Get all active APIViews from urlconf\n+    endpoints = enumerator.get_api_endpoints(patterns=urlpatterns)\n+    for _, _, func in endpoints:\n+        # ApiView.as_view() breadcrumb\n+        if hasattr(func, 'cls'):\n+            views.add(func.cls)\n+\n+    return views"
        },
        {
          "filename": "ansible_base/oauth2_provider/apps.py",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -1,7 +1,14 @@\n from django.apps import AppConfig\n+from django.core.checks import register\n \n \n class Oauth2ProviderConfig(AppConfig):\n     default_auto_field = 'django.db.models.BigAutoField'\n     name = 'ansible_base.oauth2_provider'\n     label = 'dab_oauth2_provider'\n+\n+    def ready(self):\n+        # Load checks\n+        from ansible_base.oauth2_provider.checks.permisssions_check import oauth2_permission_scope_check\n+\n+        register(oauth2_permission_scope_check, \"oauth2_permissions\", deploy=True)"
        },
        {
          "filename": "ansible_base/oauth2_provider/checks/__init__.py",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "ansible_base/oauth2_provider/checks/permisssions_check.py",
          "status": "added",
          "additions": 153,
          "deletions": 0,
          "patch": "@@ -0,0 +1,153 @@\n+from typing import Iterable, Optional, Type, Union\n+\n+from django.apps import AppConfig\n+from django.conf import settings\n+from django.core.checks import CheckMessage, Debug, Error, Warning\n+from rest_framework.permissions import AllowAny, OperandHolder, OperationHolderMixin, SingleOperandHolder\n+from rest_framework.views import APIView\n+\n+from ansible_base.lib.utils.views.urls import get_api_view_functions\n+from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n+\n+\n+class OAuth2ScopePermissionCheck:\n+    \"\"\"\n+    Class containing logic for checking view classes for the\n+    OAuth2ScopePermission permission_class, and aggregating\n+    CheckMessage's for django system checks.\n+\n+    :param ignore_list: List of python import path strings for view classes exempt from the check logic.\n+    :type ignore_list: list\n+    \"\"\"\n+\n+    def __init__(self, ignore_list: Iterable[str], generate_check_messages=True):\n+        self.messages: list[CheckMessage] = []\n+        self.current_view: Optional[Type[APIView]] = None\n+        self.ignore_list = ignore_list\n+        self.generate_check_messages = generate_check_messages\n+\n+    def check_message(self, message: CheckMessage):\n+        if self.generate_check_messages:\n+            self.messages.append(message)\n+\n+    # These are all warning or error conditions, this function is mostly saying to not invert OAuth2ScopePermissions\n+    # Returns False.\n+    def process_single_operand_holder(self, operand_holder: SingleOperandHolder) -> bool:\n+        # The only unary operand for permission classes provided by rest_framework is ~ (not)\n+        if self.parse_permission_class(operand_holder.op1_class):\n+            self.check_message(\n+                Warning(\n+                    \"~ (not) operand used on OAuth2ScopePermission, probably a bad idea.\",\n+                    id=\"ansible_base.oauth2_provider.W001\",\n+                    obj=self.current_view,\n+                )\n+            )\n+\n+        return False\n+\n+    def process_operand_holder(self, operand_holder: OperandHolder) -> bool:\n+        return self.parse_permission_class(operand_holder.op1_class) or self.parse_permission_class(operand_holder.op2_class)\n+\n+    # Check if permission class is present in nested operands\n+    # Sort of recursive? Reasonably this should not be an issue, so long as we don't recurse on an unknown OperationHolderMixin type\n+    def parse_permission_class(self, cls: Union[Type[OperationHolderMixin], OperationHolderMixin]) -> bool:\n+        # First, most likely case, we're dealing with a BasePermission subclass.\n+        if cls is OAuth2ScopePermission:\n+            return True\n+        elif isinstance(cls, SingleOperandHolder):\n+            # Warning or Error case: Will not accept OAuth2 permission nested in NOT\n+            return self.process_single_operand_holder(cls)\n+        elif isinstance(cls, OperandHolder):\n+            return self.process_operand_holder(cls)\n+        return False\n+\n+    def check_view(self, view_class: Type[APIView]) -> bool:\n+        \"\"\"\n+        Primary function of the OAuth2ScopePermissionCheck.\n+\n+        Checks if OAuth2ScopePermission is present on the supplied view's\n+        permission_classes; ignores classes that are not APIViews, or that are\n+        in the ignore_list.\n+\n+        Appends CheckMessages to self.messages as a side effect.\n+\n+        :param view_class: django View class or rest_framework ApiView class\n+\n+        :return: True if view_class uses the OAuth2ScopePermission permission\n+            class, or has some mitigating circumstance that prohibits it, such as\n+            view_class not using permission classes, or its import path being in\n+            self.ignore_list; returns False otherwise.\n+        \"\"\"\n+        if f\"{view_class.__module__}.{view_class.__name__}\" in self.ignore_list:\n+            self.check_message(\n+                Debug(\n+                    \"View class in the ignore list. Ignoring.\",\n+                    obj=view_class,\n+                    id=\"ansible_base.oauth2_provider.D03\",\n+                )\n+            )\n+            return True\n+\n+        self.current_view = view_class\n+\n+        for permission_class in getattr(self.current_view, \"permission_classes\", []):\n+            if self.parse_permission_class(permission_class):\n+                self.check_message(\n+                    Debug(\n+                        \"Found OAuth2ScopePermission permission_class\",\n+                        obj=self.current_view,\n+                        id=\"ansible_base.oauth2_provider.D02\",\n+                    )\n+                )\n+                return True\n+\n+        if not self.current_view.permission_classes or AllowAny in self.current_view.permission_classes:\n+            self.check_message(\n+                Debug(\n+                    \"View object is fully permissive, OAuth2ScopePermission is not required\",\n+                    obj=self.current_view,\n+                    id=\"ansible_base.oauth2_provider.D04\",\n+                )\n+            )\n+            return True\n+\n+        # if we went though the whole loop without finding a valid permission_class, raise an error\n+        self.check_message(\n+            Error(\n+                \"View class has no valid usage of OAuth2ScopePermission\",\n+                obj=self.current_view,\n+                id=\"ansible_base.oauth2_provider.E002\",\n+            )\n+        )\n+        return False\n+\n+\n+def view_in_app_configs(view_class: type, app_configs: Optional[list[AppConfig]]) -> bool:\n+    if app_configs:\n+        for app_config in app_configs:\n+            if view_class.__module__.startswith(app_config.name):\n+                return True\n+        return False\n+    return True\n+\n+\n+def oauth2_permission_scope_check(app_configs: Optional[list[AppConfig]], **kwargs) -> list[CheckMessage]:\n+    \"\"\"\n+    Check for OAuth2ScopePermission permission class on all enabled views.\n+\n+    Ignore views in the ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_IGNORED_VIEWS setting\n+    \"\"\"\n+    ignore_list = set(\n+        getattr(settings, \"ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_DEFAULT_IGNORED_VIEWS\", [])\n+        + getattr(settings, \"ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_IGNORED_VIEWS\", [])\n+    )\n+\n+    check = OAuth2ScopePermissionCheck(ignore_list)\n+\n+    view_functions = get_api_view_functions()\n+    for view in view_functions:\n+        # Only run checks on included apps (or all if app_configs is None)\n+        if view_in_app_configs(view, app_configs):\n+            check.check_view(view)\n+\n+    return check.messages"
        },
        {
          "filename": "ansible_base/oauth2_provider/views/application.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,10 +3,11 @@\n from ansible_base.lib.utils.views.django_app_api import AnsibleBaseDjangoAppApiView\n from ansible_base.lib.utils.views.permissions import IsSuperuserOrAuditor\n from ansible_base.oauth2_provider.models import OAuth2Application\n+from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n from ansible_base.oauth2_provider.serializers import OAuth2ApplicationSerializer\n \n \n class OAuth2ApplicationViewSet(AnsibleBaseDjangoAppApiView, ModelViewSet):\n     queryset = OAuth2Application.objects.all()\n     serializer_class = OAuth2ApplicationSerializer\n-    permission_classes = [IsSuperuserOrAuditor]\n+    permission_classes = [OAuth2ScopePermission, IsSuperuserOrAuditor]"
        },
        {
          "filename": "ansible_base/oauth2_provider/views/token.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -10,6 +10,7 @@\n from ansible_base.lib.utils.settings import get_setting\n from ansible_base.lib.utils.views.django_app_api import AnsibleBaseDjangoAppApiView\n from ansible_base.oauth2_provider.models import OAuth2AccessToken, OAuth2RefreshToken\n+from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n from ansible_base.oauth2_provider.serializers import OAuth2TokenSerializer\n from ansible_base.oauth2_provider.views.permissions import OAuth2TokenPermission\n \n@@ -73,4 +74,4 @@ def create_token_response(self, request):\n class OAuth2TokenViewSet(ModelViewSet, AnsibleBaseDjangoAppApiView):\n     queryset = OAuth2AccessToken.objects.all()\n     serializer_class = OAuth2TokenSerializer\n-    permission_classes = [OAuth2TokenPermission]\n+    permission_classes = [OAuth2ScopePermission, OAuth2TokenPermission]"
        },
        {
          "filename": "ansible_base/rbac/api/views.py",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -11,6 +11,7 @@\n from rest_framework.viewsets import ModelViewSet\n \n from ansible_base.lib.utils.views.django_app_api import AnsibleBaseDjangoAppApiView\n+from ansible_base.lib.utils.views.permissions import try_add_oauth2_scope_permission\n from ansible_base.rbac.api.permissions import RoleDefinitionPermissions\n from ansible_base.rbac.api.serializers import (\n     RoleDefinitionDetailSerializer,\n@@ -44,7 +45,7 @@ class RoleMetadataView(AnsibleBaseDjangoAppApiView, GenericAPIView):\n     allowed_permissions: Valid permissions for a role of a given content_type\n     \"\"\"\n \n-    permission_classes = [permissions.IsAuthenticated]\n+    permission_classes = try_add_oauth2_scope_permission([permissions.IsAuthenticated])\n     serializer_class = RoleMetadataSerializer\n \n     def get(self, request, format=None):\n@@ -88,7 +89,7 @@ class RoleDefinitionViewSet(AnsibleBaseDjangoAppApiView, ModelViewSet):\n \n     queryset = RoleDefinition.objects.prefetch_related('created_by', 'modified_by', 'content_type', 'permissions')\n     serializer_class = RoleDefinitionSerializer\n-    permission_classes = [RoleDefinitionPermissions]\n+    permission_classes = try_add_oauth2_scope_permission([RoleDefinitionPermissions])\n \n     def get_serializer_class(self):\n         if self.action == 'update':\n@@ -112,7 +113,7 @@ def perform_destroy(self, instance):\n \n \n class BaseAssignmentViewSet(AnsibleBaseDjangoAppApiView, ModelViewSet):\n-    permission_classes = [permissions.IsAuthenticated]\n+    permission_classes = try_add_oauth2_scope_permission([permissions.IsAuthenticated])\n     # PUT and PATCH are not allowed because these are immutable\n     http_method_names = ['get', 'post', 'head', 'options', 'delete']\n     prefetch_related = ()"
        },
        {
          "filename": "ansible_base/resource_registry/views.py",
          "status": "modified",
          "additions": 12,
          "deletions": 7,
          "patch": "@@ -13,6 +13,7 @@\n \n from ansible_base.lib.utils.response import CSVStreamResponse, get_relative_url\n from ansible_base.lib.utils.views.django_app_api import AnsibleBaseDjangoAppApiView\n+from ansible_base.lib.utils.views.permissions import try_add_oauth2_scope_permission\n from ansible_base.resource_registry.models import Resource, ResourceType, service_id\n from ansible_base.resource_registry.registry import get_registry\n from ansible_base.resource_registry.serializers import ResourceListSerializer, ResourceSerializer, ResourceTypeSerializer, UserAuthenticationSerializer\n@@ -66,9 +67,11 @@ class ResourceAPIMixin:\n     \"\"\"\n \n     filter_backends = (FieldLookupBackend, TypeFilterBackend, OrderByBackend)\n-    permission_classes = [\n-        HasResourceRegistryPermissions,\n-    ]\n+    permission_classes = try_add_oauth2_scope_permission(\n+        [\n+            HasResourceRegistryPermissions,\n+        ]\n+    )\n     pagination_class = ResourcesPagination\n \n \n@@ -153,9 +156,11 @@ def manifest(self, request, name, *args, **kwargs):\n class ServiceMetadataView(\n     AnsibleBaseDjangoAppApiView,\n ):\n-    permission_classes = [\n-        HasResourceRegistryPermissions,\n-    ]\n+    permission_classes = try_add_oauth2_scope_permission(\n+        [\n+            HasResourceRegistryPermissions,\n+        ]\n+    )\n \n     # Corresponds to viewset action but given a different name so schema generators are not messed up\n     custom_action_label = \"service-metadata\"\n@@ -166,7 +171,7 @@ def get(self, request, **kwargs):\n \n \n class ServiceIndexRootView(AnsibleBaseDjangoAppApiView):\n-    permission_classes = [permissions.IsAuthenticated]\n+    permission_classes = try_add_oauth2_scope_permission([permissions.IsAuthenticated])\n \n     def get(self, request, format=None):\n         '''Link other resource registry endpoints'''"
        },
        {
          "filename": "docs/apps/oauth2_provider.md",
          "status": "modified",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -136,6 +136,52 @@ curl -H \"Authorization: Bearer <token-value>\" -X DELETE https://<service>/api/to\n ```\n \n \n+## OAuth2ScopePermission Check\n+\n+ansible_base.oauth2_provider defines a system check that checks all APIView\n+classes for an instance of OAuth2ScopePermission in its permission_classes\n+attribute.\n+\n+### Running the check\n+\n+You can run the check by running the management command:\n+`check --deploy --tag oauth2_permissions`.\n+\n+Examples:\n+```shell\n+# Run check for on all view classes enabled for the application\n+./manage.py check --deploy --tag oauth2_permissions\n+# Using the django-admin executable\n+django-admin check --deploy --tag oauth2_permissions\n+# For only checking views defined by the test app django application\n+django-admin check --deploy --tag oauth2_permissions test_app\n+```\n+\n+### Ignoring Views\n+\n+Some views do not need OAuth2ScopePermission, such as when the AllowAny\n+permission class is used by the APIView class; Adding OAuth2ScopePermission\n+will only break the view in this case.\n+\n+For such cases, a ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_IGNORED_VIEWS exists\n+to set ignores for views by their module path. For DAB views, these ignores\n+should be set automatically via dynamic settings logic. To add more ignores,\n+you can set the ignore list in your settings.py prior to calling the dynamic\n+settings logic:\n+\n+```python\n+ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_IGNORED_VIEWS = [\n+    'ansible_base.resource_registry.views.ValidateLocalUserView',\n+    'test_app.views.SomeOtherViewSet',\n+]\n+```\n+\n+To clear ignores, change the default ignores list after calling the dynamic\n+settings logic:\n+```python\n+ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_DEFAULT_IGNORED_VIEWS = []\n+```\n+\n ## More Information\n \n #### Managing OAuth2 Applications and Tokens"
        },
        {
          "filename": "test_app/settings.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -185,6 +185,7 @@\n ANSIBLE_BASE_JWT_MANAGED_ROLES.append(\"System Auditor\")  # noqa: F821 this is set by dynamic settings for jwt_consumer\n ANSIBLE_BASE_ALLOW_SINGLETON_USER_ROLES = True\n ANSIBLE_BASE_ALLOW_SINGLETON_TEAM_ROLES = True\n+ANSIBLE_BASE_OAUTH2_PROVIDER_PERMISSIONS_CHECK_IGNORED_VIEWS = [\"drf_spectacular.views.SpectacularSwaggerView\"]\n ALLOW_SHARED_RESOURCE_CUSTOM_ROLES = True  # Allow making custom roles with org change permission, for example\n ALLOW_LOCAL_ASSIGNING_JWT_ROLES = False\n "
        },
        {
          "filename": "test_app/tests/oauth2_provider/checks/__init__.py",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "test_app/tests/oauth2_provider/checks/test_permissions_check.py",
          "status": "added",
          "additions": 148,
          "deletions": 0,
          "patch": "@@ -0,0 +1,148 @@\n+import copy\n+from typing import Type\n+from unittest import mock\n+\n+import pytest\n+from django.core.checks import Debug, Error, Warning\n+from django.core.management import call_command\n+from django.core.management.base import SystemCheckError\n+from django.urls import path\n+from drf_spectacular.views import SpectacularSwaggerView\n+from rest_framework.permissions import AllowAny\n+from rest_framework.views import APIView\n+\n+from ansible_base.authentication.authenticator_plugins.saml import SAMLMetadataView\n+from ansible_base.authentication.views.authenticator import AuthenticatorViewSet\n+from ansible_base.authentication.views.ui_auth import UIAuth\n+from ansible_base.lib.utils.views.urls import get_api_view_functions\n+from ansible_base.oauth2_provider.checks.permisssions_check import oauth2_permission_scope_check, view_in_app_configs\n+from ansible_base.resource_registry.views import ValidateLocalUserView\n+from test_app import views\n+\n+urlpatterns = [\n+    # APIView without OAuth2ScopePermission (needs patch)\n+    path('api/users/', views.UserViewSet.as_view({\"get\": \"list\"}), name='user-view'),\n+    # APIView with OAuth2ScopePermission (happy path)\n+    path('api/teams/', views.TeamViewSet.as_view({\"get\": \"list\"}), name='team-list'),\n+    # APIView with binary Operands (Needs patch)\n+    path('api/authenticators/', AuthenticatorViewSet.as_view({\"get\": \"list\"}), name=\"authenticator-list\"),\n+    # APIView with inverted OAuth2ScopePermission (need patch)\n+    path('api/organizations/', views.OrganizationViewSet.as_view({\"get\": \"list\"}), name=\"organization-list\"),\n+    # Ignored view (ignored in settings.py)\n+    path('/docs/', SpectacularSwaggerView.as_view()),\n+    # Fully permissive APIView (via empty permission classes)\n+    path('/ui-auth/', UIAuth.as_view()),\n+    # Fully permissive APIView (via AllowAny)\n+    path('/validate-users-view/', ValidateLocalUserView.as_view()),\n+    # Non-ApiView view\n+    path('/non-api-view/', SAMLMetadataView.as_view()),\n+]\n+\n+\n+@pytest.fixture\n+def missing_permissions_view_class():\n+    PatchedUserViewSet = copy.deepcopy(views.UserViewSet)\n+    PatchedUserViewSet.permission_classes = [~AllowAny]\n+    with mock.patch(\"test_app.views.UserViewSet\", PatchedUserViewSet):\n+        yield PatchedUserViewSet\n+\n+\n+@pytest.fixture\n+def inverted_permissions_view_class():\n+    from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n+\n+    PatchedOrganizationViewSet = copy.deepcopy(views.OrganizationViewSet)\n+    PatchedOrganizationViewSet.permission_classes = [~OAuth2ScopePermission]\n+    with mock.patch(\"test_app.views.OrganizationViewSet\", PatchedOrganizationViewSet):\n+        yield PatchedOrganizationViewSet\n+\n+\n+@pytest.fixture\n+def nested_permissions_view_class():\n+    from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n+\n+    PatchedAuthenticatorViewSet = copy.deepcopy(AuthenticatorViewSet)\n+    PatchedAuthenticatorViewSet.permission_classes = [OAuth2ScopePermission & AllowAny]\n+    with mock.patch(\"ansible_base.authentication.views.authenticator.AuthenticatorViewSet\", PatchedAuthenticatorViewSet):\n+        yield PatchedAuthenticatorViewSet\n+\n+\n+@mock.patch(\"test_app.urls.urlpatterns\", urlpatterns)\n+class TestOAuth2PermissionsCheck:\n+    def test_get_api_view_functions(self):\n+        expected_results = set([views.UserViewSet, views.TeamViewSet, views.OrganizationViewSet, AuthenticatorViewSet, SpectacularSwaggerView])\n+        result = set(get_api_view_functions(urlpatterns))\n+        # Confirm mock works\n+        assert views.TestAppViewSet not in result\n+\n+        # Roundabout way of asserting that the result equals the expected results,\n+        # but tracebacks will show missing results\n+        assert expected_results.intersection(result).difference(expected_results) == set(), \"Missing results from get_api_view_functions\"\n+\n+    # Test the check by calling the check\n+    def test_check_function(\n+        self, inverted_permissions_view_class: Type[APIView], nested_permissions_view_class: Type[APIView], missing_permissions_view_class: Type[APIView]\n+    ):\n+        expected_messages = [\n+            Debug(\n+                \"Found OAuth2ScopePermission permission_class\",\n+                id=\"ansible_base.oauth2_provider.D02\",\n+                obj=nested_permissions_view_class,\n+            ),\n+            Debug(\n+                \"Found OAuth2ScopePermission permission_class\",\n+                id=\"ansible_base.oauth2_provider.D02\",\n+                obj=views.TeamViewSet,\n+            ),\n+            Warning(\n+                \"~ (not) operand used on OAuth2ScopePermission, probably a bad idea.\",\n+                id=\"ansible_base.oauth2_provider.W001\",\n+                obj=inverted_permissions_view_class,\n+            ),\n+            Error(\n+                \"View class has no valid usage of OAuth2ScopePermission\",\n+                id=\"ansible_base.oauth2_provider.E002\",\n+                obj=missing_permissions_view_class,\n+            ),\n+            Debug(\n+                \"View class in the ignore list. Ignoring.\",\n+                id=\"ansible_base.oauth2_provider.D03\",\n+                obj=SpectacularSwaggerView,\n+            ),\n+            Debug(\n+                \"View object is fully permissive, OAuth2ScopePermission is not required\",\n+                obj=ValidateLocalUserView,\n+                id=\"ansible_base.oauth2_provider.D04\",\n+            ),\n+            Debug(\n+                \"View object is fully permissive, OAuth2ScopePermission is not required\",\n+                obj=UIAuth,\n+                id=\"ansible_base.oauth2_provider.D04\",\n+            ),\n+        ]\n+        # Call check function\n+        messages = oauth2_permission_scope_check(None)\n+        # Verify messages\n+        for message in expected_messages:\n+            assert message in messages, \"Missing message in check results\"\n+\n+    # Test the check by running the management command\n+    # I Cannot figure out how to mock the check to assert it is called, so this should suffice.\n+    @pytest.mark.parametrize(\n+        \"call_command_args\",\n+        (\n+            [\"--deploy\", \"--tag\", \"oauth2_permissions\"],\n+            [\"--deploy\", \"--tag\", \"oauth2_permissions\", \"test_app\"],\n+        ),\n+    )\n+    # Need to mock the helper function, since patch cannot find the registered check function itself\n+    @mock.patch(\"ansible_base.oauth2_provider.checks.permisssions_check.view_in_app_configs\", spec=view_in_app_configs)\n+    def test_call_check(self, mocked_helper_function: mock.Mock, call_command_args):\n+        try:\n+            call_command(\"check\", *call_command_args)\n+        except SystemCheckError:\n+            # Should fail with this error with the patched urlconf\n+            pass\n+        finally:\n+            # Assert that view_in_app_config helper called, which would mean the check was most likely called\n+            mocked_helper_function.assert_called()"
        },
        {
          "filename": "test_app/views.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -11,6 +11,7 @@\n \n from ansible_base.lib.utils.response import get_fully_qualified_url\n from ansible_base.lib.utils.views.ansible_base import AnsibleBaseView\n+from ansible_base.oauth2_provider.permissions import OAuth2ScopePermission\n from ansible_base.oauth2_provider.views import DABOAuth2UserViewsetMixin\n from ansible_base.rbac import permission_registry\n from ansible_base.rbac.api.permissions import AnsibleBaseUserPermissions\n@@ -57,7 +58,7 @@ class TeamViewSet(TestAppViewSet):\n \n class UserViewSet(DABOAuth2UserViewsetMixin, TestAppViewSet):\n     queryset = models.User.objects.all()\n-    permission_classes = [AnsibleBaseUserPermissions]\n+    permission_classes = [OAuth2ScopePermission, AnsibleBaseUserPermissions]\n     serializer_class = serializers.UserSerializer\n     prefetch_related = ('created_by', 'modified_by', 'resource', 'resource__content_type')\n "
        }
      ],
      "file_patterns": {
        "security_files": 9,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 11,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "246f96af7d805ccff1fe3edcef7023caa3793a80",
            "date": "2025-01-13T16:50:43Z",
            "author_login": "bhavenst"
          },
          {
            "sha": "1cf551b7834453dcfd09de1a18b44f9538f93852",
            "date": "2024-12-18T21:35:36Z",
            "author_login": "AlanCoding"
          },
          {
            "sha": "7e0c0136ed5121ec5fd1f6a896ad8423461a5a0f",
            "date": "2024-12-17T14:01:01Z",
            "author_login": "tznamena"
          },
          {
            "sha": "b37fdd2ce8baa21cd2a40c96ff3a871e97363b14",
            "date": "2024-12-13T18:36:54Z",
            "author_login": "jctanner"
          },
          {
            "sha": "5a8bc6f6f20045f559266f43e4cb9c06e8478a1d",
            "date": "2024-12-12T18:51:27Z",
            "author_login": "jctanner"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N",
    "cwe_id": "CWE-284",
    "description": "A vulnerability was found in the Ansible Automation Platform (AAP). This flaw allows attackers to escalate privileges by improperly leveraging read-scoped OAuth2 tokens to gain write access. This issue affects API endpoints that rely on ansible_base.oauth2_provider for OAuth2 authentication. While the impact is limited to actions within the user\u2019s assigned permissions, it undermines scoped access controls, potentially allowing unintended modifications in the application and consuming services.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-11-25T04:15:03.683",
    "last_modified": "2024-12-18T04:15:07.210",
    "fix_date": "2024-11-15T20:26:08Z"
  },
  "references": [
    {
      "url": "https://access.redhat.com/errata/RHSA-2024:11145",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://access.redhat.com/security/cve/CVE-2024-11483",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2327579",
      "source": "secalert@redhat.com",
      "tags": []
    },
    {
      "url": "https://github.com/ansible/django-ansible-base/commit/845b3e1838cc0762a7f9f3e0379c5274519d9a44",
      "source": "secalert@redhat.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.300262",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "django-ansible-base",
    "owner": "ansible",
    "created_at": "2023-10-20T13:20:12Z",
    "updated_at": "2025-01-13T16:50:47Z",
    "pushed_at": "2025-01-13T16:50:46Z",
    "size": 1662,
    "stars": 19,
    "forks": 50,
    "open_issues": 55,
    "watchers": 19,
    "has_security_policy": false,
    "default_branch": "devel",
    "protected_branches": [
      "devel"
    ],
    "languages": {
      "Python": 1713753,
      "HTML": 45730,
      "Shell": 8439,
      "Makefile": 2879,
      "Dockerfile": 967,
      "CSS": 92
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T19:23:16.126439"
  }
}