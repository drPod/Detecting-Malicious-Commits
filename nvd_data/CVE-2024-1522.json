{
  "cve_id": "CVE-2024-1522",
  "github_data": {
    "repository": "parisneo/lollms-webui",
    "fix_commit": "0b51063119cfb5e391925d232a4af1de9dc32e2b",
    "related_commits": [
      "0b51063119cfb5e391925d232a4af1de9dc32e2b",
      "0b51063119cfb5e391925d232a4af1de9dc32e2b"
    ],
    "patch_url": "https://github.com/parisneo/lollms-webui/commit/0b51063119cfb5e391925d232a4af1de9dc32e2b.patch",
    "fix_commit_details": {
      "sha": "0b51063119cfb5e391925d232a4af1de9dc32e2b",
      "commit_date": "2024-02-14T23:35:04Z",
      "author": {
        "login": "ParisNeo",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Path traversal vulenerability fix",
        "length": 33,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 280,
        "additions": 204,
        "deletions": 76
      },
      "files": [
        {
          "filename": "app.py",
          "status": "modified",
          "additions": 38,
          "deletions": 19,
          "patch": "@@ -22,23 +22,10 @@\n from socketio import ASGIApp\n import webbrowser\n import threading\n-\n+import os\n \n app = FastAPI()\n \n-# Create a Socket.IO server\n-sio = socketio.AsyncServer(async_mode=\"asgi\", cors_allowed_origins=\"*\", ping_timeout=1200, ping_interval=30)  # Enable CORS for all origins\n-\n-\n-\n-@sio.event\n-async def disconnect(sid):\n-    ASCIIColors.yellow(f\"Disconnected: {sid}\")\n-\n-@sio.event\n-async def message(sid, data):\n-    ASCIIColors.yellow(f\"Message from {sid}: {data}\")\n-    await sio.send(sid, \"Message received!\")\n \n \n #app.mount(\"/socket.io\", StaticFiles(directory=\"path/to/socketio.js\"))\n@@ -64,9 +51,21 @@ async def message(sid, data):\n     if args.port:\n         config.port=args.port\n \n+    cert_file_path = lollms_paths.personal_certificates/\"cert.pem\"\n+    key_file_path = lollms_paths.personal_certificates/\"key.pem\"\n+    if os.path.exists(cert_file_path) and os.path.exists(key_file_path):\n+        is_https = True\n+    else:\n+        is_https = False        \n+\n+    # Create a Socket.IO server\n+    sio = socketio.AsyncServer(async_mode=\"asgi\", cors_allowed_origins=config.allowed_origins+[f\"https://localhost:{config['port']}\" if is_https else f\"http://localhost:{config['port']}\"], ping_timeout=1200, ping_interval=30)  # Enable CORS for selected origins\n+\n     LOLLMSWebUI.build_instance(config=config, lollms_paths=lollms_paths, args=args, sio=sio)\n     lollmsElfServer:LOLLMSWebUI = LOLLMSWebUI.get_instance()\n     lollmsElfServer.verbose = True\n+\n+\n     # Import all endpoints\n     from lollms.server.endpoints.lollms_binding_files_server import router as lollms_binding_files_server_router\n     from lollms.server.endpoints.lollms_infos import router as lollms_infos_router\n@@ -140,6 +139,18 @@ async def message(sid, data):\n     \n     \n     app.include_router(lollms_configuration_infos_router)\n+    \n+\n+\n+\n+    @sio.event\n+    async def disconnect(sid):\n+        ASCIIColors.yellow(f\"Disconnected: {sid}\")\n+\n+    @sio.event\n+    async def message(sid, data):\n+        ASCIIColors.yellow(f\"Message from {sid}: {data}\")\n+        await sio.send(sid, \"Message received!\")\n \n \n     lollms_generation_events_add(sio)\n@@ -158,6 +169,9 @@ async def message(sid, data):\n     app.mount(\"/playground\", StaticFiles(directory=Path(__file__).parent/\"web\"/\"dist\", html=True), name=\"playground\")\n     app.mount(\"/settings\", StaticFiles(directory=Path(__file__).parent/\"web\"/\"dist\", html=True), name=\"settings\")\n     app.mount(\"/\", StaticFiles(directory=Path(__file__).parent/\"web\"/\"dist\", html=True), name=\"static\")\n+\n+\n+\n     app = ASGIApp(socketio_server=sio, other_asgi_app=app)\n \n     lollmsElfServer.app = app\n@@ -179,15 +193,20 @@ async def message(sid, data):\n         #   thread.start()\n \n         # if autoshow\n-        if config.auto_show_browser:\n+\n+\n+        if config.auto_show_browser and not config.headless_server_mode:\n             if config['host']==\"0.0.0.0\":\n-                webbrowser.open(f\"http://localhost:{config['port']}\")\n+                webbrowser.open(f\"https://localhost:{config['port']}\" if is_https else f\"http://localhost:{config['port']}\")\n                 #webbrowser.open(f\"http://localhost:{6523}\") # needed for debug (to be removed in production)\n             else:\n-                webbrowser.open(f\"http://{config['host']}:{config['port']}\")\n+                webbrowser.open(f\"https://{config['host']}:{config['port']}\" if is_https else f\"http://{config['host']}:{config['port']}\")\n                 #webbrowser.open(f\"http://{config['host']}:{6523}\") # needed for debug (to be removed in production)\n-\n-        uvicorn.run(app, host=config.host, port=config.port)\n+                \n+        if is_https:\n+            uvicorn.run(app, host=config.host, port=config.port, ssl_certfile=cert_file_path, ssl_keyfile=key_file_path)\n+        else:\n+            uvicorn.run(app, host=config.host, port=config.port)\n            \n     except Exception as ex:\n         trace_exception(ex)"
        },
        {
          "filename": "configs/config.yaml",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1,9 +1,10 @@\n # =================== Lord Of Large Language Multimodal Systems Configuration file =========================== \n-version: 56\n+version: 58\n binding_name: null\n model_name: null\n \n-\n+headless_server_mode: False\n+allowed_origins: []\n \n # Host information\n host: localhost"
        },
        {
          "filename": "endpoints/lollms_advanced.py",
          "status": "modified",
          "additions": 52,
          "deletions": 54,
          "patch": "@@ -23,6 +23,15 @@\n import shutil\n import os\n import platform\n+import string\n+import re\n+\n+# Regular expression pattern to validate file paths\n+FILE_PATH_REGEX = r'^[a-zA-Z0-9_\\-\\\\\\/]+$'\n+\n+# Function to validate file paths using the regex pattern\n+def validate_file_path(path):\n+    return re.match(FILE_PATH_REGEX, path)\n \n from utilities.execution_engines.python_execution_engine import execute_python\n from utilities.execution_engines.latex_execution_engine import execute_latex\n@@ -48,12 +57,17 @@ async def execute_code(request: Request):\n     :param request: The HTTP request object.\n     :return: A JSON response with the status of the operation.\n     \"\"\"\n+    if lollmsElfServer.config.headless_server_mode:\n+        return {\"status\":False,\"error\":\"Code execution is blocked when in headless mode for obvious security reasons!\"}\n+\n+    if lollmsElfServer.config.host==\"0.0.0.0\":\n+        return {\"status\":False,\"error\":\"Code execution is blocked when the server is exposed outside for very obvipous reasons!\"}\n \n     try:\n         data = (await request.json())\n         code = data[\"code\"]\n-        discussion_id = data.get(\"discussion_id\",\"unknown_discussion\")\n-        message_id = data.get(\"message_id\",\"unknown_message\")\n+        discussion_id = int(data.get(\"discussion_id\",\"unknown_discussion\"))\n+        message_id = int(data.get(\"message_id\",\"unknown_message\"))\n         language = data.get(\"language\",\"python\")\n         \n \n@@ -87,43 +101,13 @@ async def execute_code(request: Request):\n             ASCIIColors.info(\"Executing graphviz code:\")\n             ASCIIColors.yellow(code)\n             return execute_graphviz(code, discussion_id, message_id)\n-        return {\"output\": \"Unsupported language\", \"execution_time\": 0}\n+        return {\"status\": False, \"error\": \"Unsupported language\", \"execution_time\": 0}\n     except Exception as ex:\n         trace_exception(ex)\n         lollmsElfServer.error(ex)\n         return {\"status\":False,\"error\":str(ex)}\n     \n \n-@router.post(\"/open_code_folder\")\n-async def open_code_folder(request: Request):\n-    \"\"\"\n-    Opens code folder.\n-\n-    :param request: The HTTP request object.\n-    :return: A JSON response with the status of the operation.\n-    \"\"\"\n-\n-    try:\n-        data = (await request.json())\n-        discussion_id = data.get(\"discussion_id\",\"unknown_discussion\")\n-\n-        ASCIIColors.info(\"Opening folder:\")\n-        # Create a temporary file.\n-        root_folder = lollmsElfServer.lollms_paths.personal_outputs_path/\"discussions\"/f\"d_{discussion_id}\"\n-        root_folder.mkdir(parents=True,exist_ok=True)\n-        if platform.system() == 'Windows':\n-            os.startfile(str(root_folder))\n-        elif platform.system() == 'Linux':\n-            os.system('xdg-open ' + str(root_folder))\n-        elif platform.system() == 'Darwin':\n-            os.system('open ' + str(root_folder))\n-        return {\"output\": \"OK\", \"execution_time\": 0}\n-    except Exception as ex:\n-        trace_exception(ex)\n-        lollmsElfServer.error(ex)\n-        return {\"status\":False,\"error\":str(ex)}\n-\n-\n \n @router.post(\"/open_code_folder_in_vs_code\")\n async def open_code_folder_in_vs_code(request: Request):\n@@ -138,9 +122,8 @@ async def open_code_folder_in_vs_code(request: Request):\n         if \"discussion_id\" in data:        \n             data = (await request.json())\n             code = data[\"code\"]\n-            discussion_id = data.get(\"discussion_id\",\"unknown_discussion\")\n-            message_id = data.get(\"message_id\",\"unknown_message\")\n-            language = data.get(\"language\",\"python\")\n+            discussion_id = int(data.get(\"discussion_id\",\"unknown_discussion\"))\n+            message_id = int(data.get(\"message_id\",\"unknown_message\"))\n \n             ASCIIColors.info(\"Opening folder:\")\n             # Create a temporary file.\n@@ -158,7 +141,7 @@ async def open_code_folder_in_vs_code(request: Request):\n             root_folder.mkdir(parents=True,exist_ok=True)\n             os.system('code ' + str(root_folder))\n \n-        return {\"output\": \"OK\", \"execution_time\": 0}\n+        return {\"status\": True, \"execution_time\": 0}\n     except Exception as ex:\n         trace_exception(ex)\n         lollmsElfServer.error(ex)\n@@ -175,9 +158,20 @@ async def open_file(request: Request):\n \n     try:\n         data = (await request.json())\n+        \n+        # Validate the 'path' parameter\n         path = data.get('path')\n-        os.system(\"start \"+path)\n-        return {\"output\": \"OK\", \"execution_time\": 0}\n+        if not validate_file_path(path):\n+            return {\"status\":False,\"error\":\"Invalid file path\"}\n+        \n+        # Sanitize the 'path' parameter\n+        path = os.path.realpath(path)\n+        \n+        # Use parameterized queries to pass the file path as a parameter\n+        os.system([\"start\", path])\n+        \n+        return {\"status\": True, \"execution_time\": 0}\n+    \n     except Exception as ex:\n         trace_exception(ex)\n         lollmsElfServer.error(ex)\n@@ -195,22 +189,19 @@ async def open_code_in_vs_code(request: Request):\n \n     try:\n         data = (await request.json())\n-        discussion_id = data.get(\"discussion_id\",\"unknown_discussion\")\n-        message_id = data.get(\"message_id\",\"\")\n+        discussion_id = int(data.get(\"discussion_id\",\"unknown_discussion\"))\n+        message_id = int(data.get(\"message_id\",\"\"))\n         code = data[\"code\"]\n-        discussion_id = data.get(\"discussion_id\",\"unknown_discussion\")\n-        message_id = data.get(\"message_id\",\"unknown_message\")\n-        language = data.get(\"language\",\"python\")\n \n         ASCIIColors.info(\"Opening folder:\")\n         # Create a temporary file.\n-        root_folder = lollmsElfServer.lollms_paths.personal_outputs_path/\"discussions\"/f\"d_{discussion_id}\"/f\"{message_id}.py\"\n+        root_folder = Path(os.path.realpath(lollmsElfServer.lollms_paths.personal_outputs_path/\"discussions\"/f\"d_{discussion_id}\"/f\"{message_id}.py\"))\n         root_folder.mkdir(parents=True,exist_ok=True)\n         tmp_file = root_folder/f\"ai_code_{message_id}.py\"\n         with open(tmp_file,\"w\") as f:\n             f.write(code)\n         os.system('code ' + str(root_folder))\n-        return {\"output\": \"OK\", \"execution_time\": 0}\n+        return {\"status\": True, \"execution_time\": 0}\n     except Exception as ex:\n         trace_exception(ex)\n         lollmsElfServer.error(ex)\n@@ -229,36 +220,43 @@ async def open_code_folder(request: Request):\n     try:\n         data = (await request.json())\n         if \"discussion_id\" in data:\n-            discussion_id = data.get(\"discussion_id\",\"unknown_discussion\")\n+            discussion_id = int(data.get(\"discussion_id\", \"unknown_discussion\"))\n \n             ASCIIColors.info(\"Opening folder:\")\n             # Create a temporary file.\n-            root_folder = lollmsElfServer.lollms_paths.personal_outputs_path/\"discussions\"/f\"d_{discussion_id}\"\n-            root_folder.mkdir(parents=True,exist_ok=True)\n+            root_folder = lollmsElfServer.lollms_paths.personal_outputs_path / \"discussions\" / f\"d_{discussion_id}\"\n+            root_folder.mkdir(parents=True, exist_ok=True)\n             if platform.system() == 'Windows':\n                 os.startfile(str(root_folder))\n             elif platform.system() == 'Linux':\n                 os.system('xdg-open ' + str(root_folder))\n             elif platform.system() == 'Darwin':\n                 os.system('open ' + str(root_folder))\n-            return {\"output\": \"OK\", \"execution_time\": 0}\n+            return {\"status\": True, \"execution_time\": 0}\n         elif \"folder_path\" in data:\n+            folder_path = os.path.realpath(data[\"folder_path\"])\n+            # Verify that this is a file and not an executable\n+            root_folder = Path(folder_path)\n+            is_valid_folder_path = root_folder.is_dir()\n+\n+            if not is_valid_folder_path:\n+                return {\"status\":False, \"error\":\"Invalid folder path\"}\n+\n             ASCIIColors.info(\"Opening folder:\")\n             # Create a temporary file.\n-            root_folder = data[\"folder_path\"]\n-            root_folder.mkdir(parents=True,exist_ok=True)\n+            root_folder.mkdir(parents=True, exist_ok=True)\n             if platform.system() == 'Windows':\n                 os.startfile(str(root_folder))\n             elif platform.system() == 'Linux':\n                 os.system('xdg-open ' + str(root_folder))\n             elif platform.system() == 'Darwin':\n                 os.system('open ' + str(root_folder))\n-            return {\"output\": \"OK\", \"execution_time\": 0}\n+            return {\"status\": True, \"execution_time\": 0}\n \n     except Exception as ex:\n         trace_exception(ex)\n         lollmsElfServer.error(ex)\n-        return {\"status\":False,\"error\":str(ex)}\n+        return {\"status\": False, \"error\": str(ex)}\n     \n \n @router.get(\"/start_recording\")"
        },
        {
          "filename": "lollms_core",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-Subproject commit ab03d2348fe546b1bf2947eeb6b8a0efc444b2b4\n+Subproject commit 002102b5c9d7884074f501d95978e792f7534bd6"
        },
        {
          "filename": "tests/pentests/path_traversal/avatar_vulenerability.py",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+\"\"\"\n+This code is attempting to perform a path traversal attack on your endpoint. Here's how it works:\n+The code imports the requests library, which is commonly used for making HTTP requests.\n+It defines the URL of your endpoint as url = 'http://localhost:9600/upload_avatar'.\n+It specifies the path to the file you want to upload as file_path = 'test.txt'.\n+It opens the file in binary mode using open(file_path, 'rb') and assigns it to the variable f.\n+It creates a dictionary called files with a single key-value pair. The key is 'avatar', which corresponds to the name of the file input field in your endpoint. The value is a tuple containing the file path and the file object f. In this case, the file path is '../../../../../../../../tmp/teeest.txt', which attempts to traverse up multiple levels in the directory structure and access the file located in /tmp/teeest.txt.\n+It sends a POST request to your endpoint with the files dictionary as the files parameter, which includes the file path traversal attempt.\n+Finally, it prints the response from the server.\n+This code is trying to exploit the path traversal vulnerability in your endpoint by specifying a file path that includes multiple ../ sequences to traverse up the directory structure and access a file outside of the intended directory.\n+To protect against this type of attack, you should implement the measures I mentioned earlier, such as file validation, randomized file names, and using a dedicated directory for storing uploaded files. Additionally, make sure to sanitize and validate all user input to prevent malicious file paths from being accepted.\n+\"\"\"\n+\n+\n+import requests\n+\n+# Endpoint URL\n+url = 'http://localhost:9600/upload_avatar'\n+\n+# Path to the file you want to upload\n+file_path = 'test.txt'\n+\n+# Open the file in binary mode and send it as 'avatar'\n+with open(file_path, 'rb') as f:\n+    files = {'avatar': ('../../../../../../../../tmp/teeest.txt', f)}\n+    response = requests.post(url, files=files)\n+\n+# Print the response from the server\n+print(response.json())\n\\ No newline at end of file"
        },
        {
          "filename": "tests/pentests/path_traversal/open_code_folder_vulenerability.py",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+import requests\n+\n+# Set the URL of the endpoint\n+url = \"http://localhost:9600/open_code_folder\"\n+\n+# Valid folder path\n+valid_folder_path = {\"folder_path\": \"c:\"}\n+\n+# Non-valid executable file path\n+non_valid_file_path = {\"folder_path\": \"c:/file.exe\"}\n+\n+# Send the valid folder path request\n+valid_response = requests.post(url, json=valid_folder_path)\n+print(valid_response.json())\n+\n+# Send the non-valid executable file path request\n+non_valid_response = requests.post(url, json=non_valid_file_path)\n+print(non_valid_response.json())"
        },
        {
          "filename": "tests/pentests/path_traversal/open_code_in_vs_code_vulenerability.py",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+import requests\n+\n+url = \"http://localhost:9600/open_code_in_vs_code\"\n+\n+# Valid request\n+valid_payload = {\n+    \"discussion_id\": \"0\",\n+    \"message_id\": \"0\",\n+    \"code\": \"print('test')\"\n+}\n+response = requests.post(url, json=valid_payload)\n+print(\"Valid request response:\", response.json())\n+\n+# Invalid request\n+invalid_payload = {\n+    \"discussion_id\": \"../invalid_discussion\",\n+    \"message_id\": \"../invalid_message\",\n+    \"code\": \"print('test')\"\n+}\n+response = requests.post(url, json=invalid_payload)\n+print(\"Invalid request response:\", response.json())"
        },
        {
          "filename": "tests/pentests/path_traversal/open_file_vulenerability.py",
          "status": "added",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -0,0 +1,40 @@\n+import os\n+import requests\n+\n+def test_vulnerabilities():\n+    \"\"\"\n+    This function tests for two vulnerabilities in the '/open_file' endpoint.\n+    1. Path Traversal vulnerability: It attempts to access sensitive files by providing a payload with multiple \"../\" to traverse directories.\n+    2. Command Injection vulnerability: It attempts to execute additional commands by appending a payload with \"&&\" and an echo statement.\n+\n+    :return: None\n+    \"\"\"\n+    # Test path traversal vulnerability\n+    payload = \"../../../../../../../../../../etc/passwd\"\n+    url = \"http://localhost:9600/open_file\"\n+    data = {\"path\": payload}\n+    \n+    response = requests.post(url, json=data)\n+    if response.status_code == 200:\n+        if \"root:x\" in response.text:\n+            print(\"Path Traversal vulnerability found!\")\n+        else:\n+            print(\"Path Traversal vulnerability not found.\")\n+    else:\n+        print(\"Error: \", response.status_code)\n+\n+    # Test command injection vulnerability\n+    payload = \"&& echo 'Command Injection Test'\"\n+    data = {\"path\": payload}\n+    \n+    response = requests.post(url, json=data)\n+    if response.status_code == 200:\n+        if \"Command Injection Test\" in response.text:\n+            print(\"Command Injection vulnerability found!\")\n+        else:\n+            print(\"Command Injection vulnerability not found.\")\n+    else:\n+        print(\"Error: \", response.status_code)\n+\n+# Call the test function\n+test_vulnerabilities()"
        },
        {
          "filename": "tests/pentests/test.txt",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+this is a test file to simulate an attack on lollms avatar\n\\ No newline at end of file"
        },
        {
          "filename": "web/src/views/SettingsView.vue",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -2815,6 +2815,7 @@ export default {\n             axios.post('/upload_avatar', formData)\n                 .then(response => {\n                     console.log(\"Avatar uploaded successfully\")\n+                    \n                     this.$store.state.toast.showToast(\"Avatar uploaded successfully!\", 4, true)\n                     // Assuming the server responds with the file name after successful upload\n                     const fileName = response.data.fileName;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "074fbb5988845100e16e33abe200c6fb0906ee49",
            "date": "2025-01-14T17:11:50Z",
            "author_login": "ParisNeo"
          },
          {
            "sha": "15b0e5ee7d3fdcec02e74e6ffceb09ddc44b7264",
            "date": "2025-01-14T17:11:41Z",
            "author_login": "ParisNeo"
          },
          {
            "sha": "78b7303da280e81d7891d022430c9e7019036409",
            "date": "2025-01-14T08:22:08Z",
            "author_login": "ParisNeo"
          },
          {
            "sha": "858e69c34a9f91c02d64f4736c2c61032a930ef5",
            "date": "2025-01-14T07:56:40Z",
            "author_login": "ParisNeo"
          },
          {
            "sha": "953879e8b018a8602bd142844c1d7f008e8ab01c",
            "date": "2025-01-13T22:54:09Z",
            "author_login": "ParisNeo"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-352",
    "description": "A Cross-Site Request Forgery (CSRF) vulnerability in the parisneo/lollms-webui project allows remote attackers to execute arbitrary code on a victim's system. The vulnerability stems from the `/execute_code` API endpoint, which does not properly validate requests, enabling an attacker to craft a malicious webpage that, when visited by a victim, submits a form to the victim's local lollms-webui instance to execute arbitrary OS commands. This issue allows attackers to take full control of the victim's system without requiring direct network access to the vulnerable application.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-03-30T18:15:45.930",
    "last_modified": "2024-11-21T08:50:45.060",
    "fix_date": "2024-02-14T23:35:04Z"
  },
  "references": [
    {
      "url": "https://github.com/parisneo/lollms-webui/commit/0b51063119cfb5e391925d232a4af1de9dc32e2b",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/687cef92-3432-4d6c-af92-868eccabbb71",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/parisneo/lollms-webui/commit/0b51063119cfb5e391925d232a4af1de9dc32e2b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/687cef92-3432-4d6c-af92-868eccabbb71",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.935568",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "lollms-webui",
    "owner": "parisneo",
    "created_at": "2023-04-06T16:38:00Z",
    "updated_at": "2025-01-14T10:08:17Z",
    "pushed_at": "2025-01-14T08:22:08Z",
    "size": 154737,
    "stars": 4437,
    "forks": 557,
    "open_issues": 162,
    "watchers": 4437,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "CSS": 2202947,
      "Vue": 1151251,
      "Python": 353630,
      "JavaScript": 179164,
      "Shell": 41865,
      "Batchfile": 30713,
      "Inno Setup": 27460,
      "HTML": 22305,
      "Jupyter Notebook": 3623,
      "Dockerfile": 1246
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:52:33.568829"
  }
}