{
  "cve_id": "CVE-2024-1728",
  "github_data": {
    "repository": "gradio-app/gradio",
    "fix_commit": "16fbe9cd0cffa9f2a824a0165beb43446114eec7",
    "related_commits": [
      "16fbe9cd0cffa9f2a824a0165beb43446114eec7",
      "16fbe9cd0cffa9f2a824a0165beb43446114eec7"
    ],
    "patch_url": "https://github.com/gradio-app/gradio/commit/16fbe9cd0cffa9f2a824a0165beb43446114eec7.patch",
    "fix_commit_details": {
      "sha": "16fbe9cd0cffa9f2a824a0165beb43446114eec7",
      "commit_date": "2024-02-22T02:21:20Z",
      "author": {
        "login": "aliabid94",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Prevent components from working with non-uploaded files (#7465)",
        "length": 325,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 76,
        "additions": 56,
        "deletions": 20
      },
      "files": [
        {
          "filename": ".changeset/moody-impalas-rule.md",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+---\n+\"gradio\": patch\n+---\n+\n+feat:Prevent components from working with non-uploaded files"
        },
        {
          "filename": "gradio/blocks.py",
          "status": "modified",
          "additions": 30,
          "deletions": 12,
          "patch": "@@ -9,7 +9,6 @@\n import secrets\n import string\n import sys\n-import tempfile\n import threading\n import time\n import warnings\n@@ -70,6 +69,7 @@\n     get_cancel_function,\n     get_continuous_fn,\n     get_package_version,\n+    get_upload_folder,\n )\n \n try:\n@@ -119,12 +119,7 @@ def __init__(\n         self._constructor_args: list[dict]\n         self.state_session_capacity = 10000\n         self.temp_files: set[str] = set()\n-        self.GRADIO_CACHE = str(\n-            Path(\n-                os.environ.get(\"GRADIO_TEMP_DIR\")\n-                or str(Path(tempfile.gettempdir()) / \"gradio\")\n-            ).resolve()\n-        )\n+        self.GRADIO_CACHE = get_upload_folder()\n \n         if render:\n             self.render()\n@@ -1110,6 +1105,7 @@ def __call__(self, *inputs, fn_index: int = 0, api_name: str | None = None):\n             inputs=processed_inputs,\n             request=None,\n             state={},\n+            explicit_call=True,\n         )\n         outputs = outputs[\"data\"]\n \n@@ -1299,7 +1295,11 @@ def validate_inputs(self, fn_index: int, inputs: list[Any]):\n             )\n \n     def preprocess_data(\n-        self, fn_index: int, inputs: list[Any], state: SessionState | None\n+        self,\n+        fn_index: int,\n+        inputs: list[Any],\n+        state: SessionState | None,\n+        explicit_call: bool = False,\n     ):\n         state = state or SessionState(self)\n         block_fn = self.fns[fn_index]\n@@ -1326,7 +1326,10 @@ def preprocess_data(\n                     if input_id in state:\n                         block = state[input_id]\n                     inputs_cached = processing_utils.move_files_to_cache(\n-                        inputs[i], block, add_urls=True\n+                        inputs[i],\n+                        block,\n+                        add_urls=True,\n+                        check_in_upload_folder=not explicit_call,\n                     )\n                     if getattr(block, \"data_model\", None) and inputs_cached is not None:\n                         if issubclass(block.data_model, GradioModel):  # type: ignore\n@@ -1522,8 +1525,14 @@ def handle_streaming_diffs(\n \n         return data\n \n-    def run_fn_batch(self, fn, batch, fn_index, state):\n-        return [fn(fn_index, list(i), state) for i in zip(*batch)]\n+    def run_fn_batch(self, fn, batch, fn_index, state, explicit_call=None):\n+        output = []\n+        for i in zip(*batch):\n+            args = [fn_index, list(i), state]\n+            if explicit_call is not None:\n+                args.append(explicit_call)\n+            output.append(fn(*args))\n+        return output\n \n     async def process_api(\n         self,\n@@ -1536,6 +1545,7 @@ async def process_api(\n         event_id: str | None = None,\n         event_data: EventData | None = None,\n         in_event_listener: bool = True,\n+        explicit_call: bool = False,\n     ) -> dict[str, Any]:\n         \"\"\"\n         Processes API calls from the frontend. First preprocesses the data,\n@@ -1548,6 +1558,8 @@ async def process_api(\n             iterators: the in-progress iterators for each generator function (key is function index)\n             event_id: id of event that triggered this API call\n             event_data: data associated with the event trigger itself\n+            in_event_listener: whether this API call is being made in response to an event listener\n+            explicit_call: whether this call is being made directly by calling the Blocks function, instead of through an event listener or API route\n         Returns: None\n         \"\"\"\n         block_fn = self.fns[fn_index]\n@@ -1575,6 +1587,7 @@ async def process_api(\n                 inputs,\n                 fn_index,\n                 state,\n+                explicit_call,\n                 limiter=self.limiter,\n             )\n             result = await self.call_function(\n@@ -1603,7 +1616,12 @@ async def process_api(\n                 inputs = []\n             else:\n                 inputs = await anyio.to_thread.run_sync(\n-                    self.preprocess_data, fn_index, inputs, state, limiter=self.limiter\n+                    self.preprocess_data,\n+                    fn_index,\n+                    inputs,\n+                    state,\n+                    explicit_call,\n+                    limiter=self.limiter,\n                 )\n             was_generating = old_iterator is not None\n             result = await self.call_function("
        },
        {
          "filename": "gradio/processing_utils.py",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -20,7 +20,7 @@\n \n from gradio import wasm_utils\n from gradio.data_classes import FileData, GradioModel, GradioRootModel\n-from gradio.utils import abspath\n+from gradio.utils import abspath, get_upload_folder, is_in_or_equal\n \n with warnings.catch_warnings():\n     warnings.simplefilter(\"ignore\")  # Ignore pydub warning if ffmpeg is not installed\n@@ -241,6 +241,7 @@ def move_files_to_cache(\n     block: Component,\n     postprocess: bool = False,\n     add_urls=False,\n+    check_in_upload_folder=False,\n ) -> dict:\n     \"\"\"Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.\n     Also handles the case where the file is on an external Gradio app (/proxy=...).\n@@ -252,6 +253,8 @@ def move_files_to_cache(\n         block: The component whose data is being processed\n         postprocess: Whether its running from postprocessing\n         root_url: The root URL of the local server, if applicable\n+        add_urls: Whether to add URLs to the payload\n+        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).\n     \"\"\"\n \n     def _move_to_cache(d: dict):\n@@ -264,6 +267,14 @@ def _move_to_cache(d: dict):\n             payload.path = payload.url\n         elif not block.proxy_url:\n             # If the file is on a remote server, do not move it to cache.\n+            if check_in_upload_folder and not client_utils.is_http_url_like(\n+                payload.path\n+            ):\n+                path = os.path.abspath(payload.path)\n+                if not is_in_or_equal(path, get_upload_folder()):\n+                    raise ValueError(\n+                        f\"File {path} is not in the upload folder and cannot be accessed.\"\n+                    )\n             temp_file_path = block.move_resource_to_block_cache(payload.path)\n             if temp_file_path is None:\n                 raise ValueError(\"Did not determine a file path for the resource.\")"
        },
        {
          "filename": "gradio/routes.py",
          "status": "modified",
          "additions": 2,
          "deletions": 7,
          "patch": "@@ -17,7 +17,6 @@\n import os\n import posixpath\n import secrets\n-import tempfile\n import threading\n import time\n import traceback\n@@ -67,9 +66,7 @@\n     move_uploaded_files_to_cache,\n )\n from gradio.state_holder import StateHolder\n-from gradio.utils import (\n-    get_package_version,\n-)\n+from gradio.utils import get_package_version, get_upload_folder\n \n if TYPE_CHECKING:\n     from gradio.blocks import Block\n@@ -136,9 +133,7 @@ def __init__(self, **kwargs):\n         self.cookie_id = secrets.token_urlsafe(32)\n         self.queue_token = secrets.token_urlsafe(32)\n         self.startup_events_triggered = False\n-        self.uploaded_file_dir = os.environ.get(\"GRADIO_TEMP_DIR\") or str(\n-            (Path(tempfile.gettempdir()) / \"gradio\").resolve()\n-        )\n+        self.uploaded_file_dir = get_upload_folder()\n         self.change_event: None | threading.Event = None\n         self._asyncio_tasks: list[asyncio.Task] = []\n         # Allow user to manually set `docs_url` and `redoc_url`"
        },
        {
          "filename": "gradio/utils.py",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n import os\n import pkgutil\n import re\n+import tempfile\n import threading\n import time\n import traceback\n@@ -1082,3 +1083,9 @@ def compare_objects(obj1, obj2, path=None):\n         return edits\n \n     return compare_objects(old, new)\n+\n+\n+def get_upload_folder() -> str:\n+    return os.environ.get(\"GRADIO_TEMP_DIR\") or str(\n+        (Path(tempfile.gettempdir()) / \"gradio\").resolve()\n+    )"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "43e05d72f43c9ac8dc18e4b885c9da08605b09e6",
            "date": "2025-01-14T18:43:37Z",
            "author_login": "abidlabs"
          },
          {
            "sha": "62cd4ef302cd7529d1f8842b416f9d8fcf6b5750",
            "date": "2025-01-14T15:52:06Z",
            "author_login": "hannahblair"
          },
          {
            "sha": "a91cb9c42c02b70273b4cd55ab18148a7436fe57",
            "date": "2025-01-13T19:14:27Z",
            "author_login": "amanchauhan11"
          },
          {
            "sha": "7fa9b6fc97b90a4c0d07cbf066b810247fc84724",
            "date": "2025-01-10T20:39:10Z",
            "author_login": "gradio-pr-bot"
          },
          {
            "sha": "e742dcccb376692c9ddd5a6c251080e7c5936574",
            "date": "2025-01-10T19:46:57Z",
            "author_login": "aliabid94"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-22",
    "description": "gradio-app/gradio is vulnerable to a local file inclusion vulnerability due to improper validation of user-supplied input in the UploadButton component. Attackers can exploit this vulnerability to read arbitrary files on the filesystem, such as private SSH keys, by manipulating the file path in the request to the `/queue/join` endpoint. This issue could potentially lead to remote code execution. The vulnerability is present in the handling of file upload paths, allowing attackers to redirect file uploads to unintended locations on the server.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-04-10T17:15:53.097",
    "last_modified": "2024-11-21T08:51:10.707",
    "fix_date": "2024-02-22T02:21:20Z"
  },
  "references": [
    {
      "url": "https://github.com/gradio-app/gradio/commit/16fbe9cd0cffa9f2a824a0165beb43446114eec7",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/9bb33b71-7995-425d-91cc-2c2a2f2a068a",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/gradio-app/gradio/commit/16fbe9cd0cffa9f2a824a0165beb43446114eec7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/9bb33b71-7995-425d-91cc-2c2a2f2a068a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.465362",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gradio",
    "owner": "gradio-app",
    "created_at": "2018-12-19T08:24:04Z",
    "updated_at": "2025-01-14T14:42:12Z",
    "pushed_at": "2025-01-14T12:42:39Z",
    "size": 280474,
    "stars": 35207,
    "forks": 2655,
    "open_issues": 470,
    "watchers": 35207,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 3114195,
      "Svelte": 1181173,
      "TypeScript": 956766,
      "JavaScript": 60749,
      "CSS": 51082,
      "Jupyter Notebook": 32113,
      "HTML": 22988,
      "Batchfile": 6463,
      "Shell": 6049,
      "MDX": 1670
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:07:33.405924"
  }
}