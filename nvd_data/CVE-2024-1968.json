{
  "cve_id": "CVE-2024-1968",
  "github_data": {
    "repository": "scrapy/scrapy",
    "fix_commit": "1d0502f25bbe55a22899af915623fda1aaeb9dd8",
    "related_commits": [
      "1d0502f25bbe55a22899af915623fda1aaeb9dd8",
      "1d0502f25bbe55a22899af915623fda1aaeb9dd8"
    ],
    "patch_url": "https://github.com/scrapy/scrapy/commit/1d0502f25bbe55a22899af915623fda1aaeb9dd8.patch",
    "fix_commit_details": {
      "sha": "1d0502f25bbe55a22899af915623fda1aaeb9dd8",
      "commit_date": "2024-05-13T17:51:49Z",
      "author": {
        "login": "Gallaecio",
        "type": "User",
        "stats": {
          "total_commits": 665,
          "average_weekly_commits": 0.7687861271676301,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 167
        }
      },
      "commit_message": {
        "title": "Merge branch 'advisory-fix' into 2.11",
        "length": 37,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 154,
        "additions": 144,
        "deletions": 10
      },
      "files": [
        {
          "filename": "scrapy/downloadermiddlewares/redirect.py",
          "status": "modified",
          "additions": 32,
          "deletions": 8,
          "patch": "@@ -20,14 +20,38 @@ def _build_redirect_request(source_request, *, url, **kwargs):\n     has_cookie_header = \"Cookie\" in redirect_request.headers\n     has_authorization_header = \"Authorization\" in redirect_request.headers\n     if has_cookie_header or has_authorization_header:\n-        source_request_netloc = urlparse_cached(source_request).netloc\n-        redirect_request_netloc = urlparse_cached(redirect_request).netloc\n-        if source_request_netloc != redirect_request_netloc:\n-            if has_cookie_header:\n-                del redirect_request.headers[\"Cookie\"]\n-            # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name\n-            if has_authorization_header:\n-                del redirect_request.headers[\"Authorization\"]\n+        default_ports = {\"http\": 80, \"https\": 443}\n+\n+        parsed_source_request = urlparse_cached(source_request)\n+        source_scheme, source_host, source_port = (\n+            parsed_source_request.scheme,\n+            parsed_source_request.hostname,\n+            parsed_source_request.port\n+            or default_ports.get(parsed_source_request.scheme),\n+        )\n+\n+        parsed_redirect_request = urlparse_cached(redirect_request)\n+        redirect_scheme, redirect_host, redirect_port = (\n+            parsed_redirect_request.scheme,\n+            parsed_redirect_request.hostname,\n+            parsed_redirect_request.port\n+            or default_ports.get(parsed_redirect_request.scheme),\n+        )\n+\n+        if has_cookie_header and (\n+            (source_scheme != redirect_scheme and redirect_scheme != \"https\")\n+            or source_host != redirect_host\n+        ):\n+            del redirect_request.headers[\"Cookie\"]\n+\n+        # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name\n+        if has_authorization_header and (\n+            source_scheme != redirect_scheme\n+            or source_host != redirect_host\n+            or source_port != redirect_port\n+        ):\n+            del redirect_request.headers[\"Authorization\"]\n+\n     return redirect_request\n \n "
        },
        {
          "filename": "tests/test_downloadermiddleware_redirect.py",
          "status": "modified",
          "additions": 112,
          "deletions": 2,
          "patch": "@@ -247,13 +247,18 @@ def test_utf8_location(self):\n         perc_encoded_utf8_url = \"http://scrapytest.org/a%C3%A7%C3%A3o\"\n         self.assertEqual(perc_encoded_utf8_url, req_result.url)\n \n-    def test_cross_domain_header_dropping(self):\n+    def test_cross_origin_header_dropping(self):\n         safe_headers = {\"A\": \"B\"}\n+        cookie_header = {\"Cookie\": \"a=b\"}\n+        authorization_header = {\"Authorization\": \"Bearer 123456\"}\n+\n         original_request = Request(\n             \"https://example.com\",\n-            headers={\"Cookie\": \"a=b\", \"Authorization\": \"a\", **safe_headers},\n+            headers={**safe_headers, **cookie_header, **authorization_header},\n         )\n \n+        # Redirects to the same origin (same scheme, same domain, same port)\n+        # keep all headers.\n         internal_response = Response(\n             \"https://example.com\",\n             headers={\"Location\": \"https://example.com/a\"},\n@@ -265,6 +270,71 @@ def test_cross_domain_header_dropping(self):\n         self.assertIsInstance(internal_redirect_request, Request)\n         self.assertEqual(original_request.headers, internal_redirect_request.headers)\n \n+        # Redirects to the same origin (same scheme, same domain, same port)\n+        # keep all headers also when the scheme is http.\n+        http_request = Request(\n+            \"http://example.com\",\n+            headers={**safe_headers, **cookie_header, **authorization_header},\n+        )\n+        http_response = Response(\n+            \"http://example.com\",\n+            headers={\"Location\": \"http://example.com/a\"},\n+            status=301,\n+        )\n+        http_redirect_request = self.mw.process_response(\n+            http_request, http_response, self.spider\n+        )\n+        self.assertIsInstance(http_redirect_request, Request)\n+        self.assertEqual(http_request.headers, http_redirect_request.headers)\n+\n+        # For default ports, whether the port is explicit or implicit does not\n+        # affect the outcome, it is still the same origin.\n+        to_explicit_port_response = Response(\n+            \"https://example.com\",\n+            headers={\"Location\": \"https://example.com:443/a\"},\n+            status=301,\n+        )\n+        to_explicit_port_redirect_request = self.mw.process_response(\n+            original_request, to_explicit_port_response, self.spider\n+        )\n+        self.assertIsInstance(to_explicit_port_redirect_request, Request)\n+        self.assertEqual(\n+            original_request.headers, to_explicit_port_redirect_request.headers\n+        )\n+\n+        # For default ports, whether the port is explicit or implicit does not\n+        # affect the outcome, it is still the same origin.\n+        to_implicit_port_response = Response(\n+            \"https://example.com:433\",\n+            headers={\"Location\": \"https://example.com/a\"},\n+            status=301,\n+        )\n+        to_implicit_port_redirect_request = self.mw.process_response(\n+            original_request, to_implicit_port_response, self.spider\n+        )\n+        self.assertIsInstance(to_implicit_port_redirect_request, Request)\n+        self.assertEqual(\n+            original_request.headers, to_implicit_port_redirect_request.headers\n+        )\n+\n+        # A port change drops the Authorization header because the origin\n+        # changes, but keeps the Cookie header because the domain remains the\n+        # same.\n+        different_port_response = Response(\n+            \"https://example.com\",\n+            headers={\"Location\": \"https://example.com:8080/a\"},\n+            status=301,\n+        )\n+        different_port_redirect_request = self.mw.process_response(\n+            original_request, different_port_response, self.spider\n+        )\n+        self.assertIsInstance(different_port_redirect_request, Request)\n+        self.assertEqual(\n+            {**safe_headers, **cookie_header},\n+            different_port_redirect_request.headers.to_unicode_dict(),\n+        )\n+\n+        # A domain change drops both the Authorization and the Cookie header.\n         external_response = Response(\n             \"https://example.com\",\n             headers={\"Location\": \"https://example.org/a\"},\n@@ -278,6 +348,46 @@ def test_cross_domain_header_dropping(self):\n             safe_headers, external_redirect_request.headers.to_unicode_dict()\n         )\n \n+        # A scheme upgrade (http \u2192 https) drops the Authorization header\n+        # because the origin changes, but keeps the Cookie header because the\n+        # domain remains the same.\n+        upgrade_response = Response(\n+            \"http://example.com\",\n+            headers={\"Location\": \"https://example.com/a\"},\n+            status=301,\n+        )\n+        upgrade_redirect_request = self.mw.process_response(\n+            http_request, upgrade_response, self.spider\n+        )\n+        self.assertIsInstance(upgrade_redirect_request, Request)\n+        self.assertEqual(\n+            {**safe_headers, **cookie_header},\n+            upgrade_redirect_request.headers.to_unicode_dict(),\n+        )\n+\n+        # A scheme downgrade (https \u2192 http) drops the Authorization header\n+        # because the origin changes, and the Cookie header because its value\n+        # cannot indicate whether the cookies were secure (HTTPS-only) or not.\n+        #\n+        # Note: If the Cookie header is set by the cookie management\n+        # middleware, as recommended in the docs, the dropping of Cookie on\n+        # scheme downgrade is not an issue, because the cookie management\n+        # middleware will add again the Cookie header to the new request if\n+        # appropriate.\n+        downgrade_response = Response(\n+            \"https://example.com\",\n+            headers={\"Location\": \"http://example.com/a\"},\n+            status=301,\n+        )\n+        downgrade_redirect_request = self.mw.process_response(\n+            original_request, downgrade_response, self.spider\n+        )\n+        self.assertIsInstance(downgrade_redirect_request, Request)\n+        self.assertEqual(\n+            safe_headers,\n+            downgrade_redirect_request.headers.to_unicode_dict(),\n+        )\n+\n \n class MetaRefreshMiddlewareTest(unittest.TestCase):\n     def setUp(self):"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1c1e83895c15dc491c6c133982cde22d778dcae6",
            "date": "2025-01-14T15:40:24Z",
            "author_login": "protokoul"
          },
          {
            "sha": "98ba61256deceba7b04b938a97005258f4ef5c66",
            "date": "2025-01-14T14:36:56Z",
            "author_login": "Gallaecio"
          },
          {
            "sha": "402500b164efc01257679247d3dd1628a5f90f5e",
            "date": "2025-01-10T18:08:27Z",
            "author_login": "ionut-ciubotariu"
          },
          {
            "sha": "1fc91bb46262118c9ff7aa2b4719d880f727699f",
            "date": "2025-01-08T16:28:51Z",
            "author_login": "BurnzZ"
          },
          {
            "sha": "b6d69e389576c137a33d14c9e9319891dce68442",
            "date": "2025-01-07T17:29:31Z",
            "author_login": "Gallaecio"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "In scrapy/scrapy, an issue was identified where the Authorization header is not removed during redirects that only change the scheme (e.g., HTTPS to HTTP) but remain within the same domain. This behavior contravenes the Fetch standard, which mandates the removal of Authorization headers in cross-origin requests when the scheme, host, or port changes. Consequently, when a redirect downgrades from HTTPS to HTTP, the Authorization header may be inadvertently exposed in plaintext, leading to potential sensitive information disclosure to unauthorized actors. The flaw is located in the _build_redirect_request function of the redirect middleware.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-05-20T08:15:08.850",
    "last_modified": "2024-11-21T08:51:42.033",
    "fix_date": "2024-05-13T17:51:49Z"
  },
  "references": [
    {
      "url": "https://github.com/scrapy/scrapy/commit/1d0502f25bbe55a22899af915623fda1aaeb9dd8",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/27f6a021-a891-446a-ada5-0226d619dd1a",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/scrapy/scrapy/commit/1d0502f25bbe55a22899af915623fda1aaeb9dd8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/27f6a021-a891-446a-ada5-0226d619dd1a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:24.263875",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "scrapy",
    "owner": "scrapy",
    "created_at": "2010-02-22T02:01:14Z",
    "updated_at": "2025-01-14T12:03:42Z",
    "pushed_at": "2025-01-10T18:08:27Z",
    "size": 26971,
    "stars": 53789,
    "forks": 10611,
    "open_issues": 611,
    "watchers": 53789,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 2367474,
      "HTML": 3290,
      "Roff": 2010,
      "Shell": 252
    },
    "commit_activity": {
      "total_commits_last_year": 389,
      "avg_commits_per_week": 7.480769230769231,
      "days_active_last_year": 122
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T13:18:23.407520"
  }
}