{
  "cve_id": "CVE-2024-2032",
  "github_data": {
    "repository": "zenml-io/zenml",
    "fix_commit": "afcaf741ef9114c9b32f722f101b97de3d8d147b",
    "related_commits": [
      "afcaf741ef9114c9b32f722f101b97de3d8d147b",
      "afcaf741ef9114c9b32f722f101b97de3d8d147b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "afcaf741ef9114c9b32f722f101b97de3d8d147b",
      "commit_date": "2024-03-04T09:05:43Z",
      "author": {
        "login": "avishniakov",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Uniquely constrained users table (#2483)",
        "length": 537,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 105,
        "additions": 71,
        "deletions": 34
      },
      "files": [
        {
          "filename": "src/zenml/zen_stores/migrations/versions/72675226b2de_unique_users.py",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+\"\"\"unique users [72675226b2de].\n+\n+Revision ID: 72675226b2de\n+Revises: 0.55.4\n+Create Date: 2024-02-29 14:58:25.584731\n+\n+\"\"\"\n+\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"72675226b2de\"\n+down_revision = \"0.55.4\"\n+branch_labels = None\n+depends_on = None\n+\n+\n+def upgrade() -> None:\n+    \"\"\"Upgrade database schema and/or data, creating a new revision.\"\"\"\n+    with op.batch_alter_table(\"user\", schema=None) as batch_op:\n+        batch_op.create_unique_constraint(\n+            \"uq_user_name_is_service_account\", [\"name\", \"is_service_account\"]\n+        )\n+\n+\n+def downgrade() -> None:\n+    \"\"\"Downgrade database schema and/or data back to the previous revision.\"\"\"\n+    with op.batch_alter_table(\"user\", schema=None) as batch_op:\n+        batch_op.drop_constraint(\n+            \"uq_user_name_is_service_account\", type_=\"unique\"\n+        )"
        },
        {
          "filename": "src/zenml/zen_stores/schemas/user_schemas.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -17,7 +17,7 @@\n from typing import TYPE_CHECKING, Any, List, Optional\n from uuid import UUID\n \n-from sqlalchemy import TEXT, Column\n+from sqlalchemy import TEXT, Column, UniqueConstraint\n from sqlmodel import Field, Relationship\n \n from zenml.models import (\n@@ -65,6 +65,7 @@ class UserSchema(NamedSchema, table=True):\n     \"\"\"SQL Model for users.\"\"\"\n \n     __tablename__ = \"user\"\n+    __table_args__ = (UniqueConstraint(\"name\", \"is_service_account\"),)\n \n     is_service_account: bool = Field(default=False)\n     full_name: str"
        },
        {
          "filename": "src/zenml/zen_stores/sql_zen_store.py",
          "status": "modified",
          "additions": 35,
          "deletions": 31,
          "patch": "@@ -5146,28 +5146,29 @@ def create_service_account(\n                 already exists.\n         \"\"\"\n         with Session(self.engine) as session:\n+            # Check if a service account with the given name already\n+            # exists\n+            err_msg = (\n+                f\"Unable to create service account with name \"\n+                f\"'{service_account.name}': Found existing service \"\n+                \"account with this name.\"\n+            )\n+            try:\n+                self._get_account_schema(\n+                    service_account.name, session=session, service_account=True\n+                )\n+                raise EntityExistsError(err_msg)\n+            except KeyError:\n+                pass\n+\n             # Create the service account\n             new_account = UserSchema.from_service_account_request(\n                 service_account\n             )\n             session.add(new_account)\n+            # on commit an IntegrityError may arise we let it bubble up\n+            session.commit()\n \n-            # Check if a service account with the given name already\n-            # exists\n-            service_accounts = session.execute(\n-                select(UserSchema).where(\n-                    UserSchema.name == service_account.name,\n-                    UserSchema.is_service_account.is_(True),  # type: ignore[attr-defined]\n-                )\n-            ).fetchall()\n-            if len(service_accounts) == 1:\n-                session.commit()\n-            else:\n-                raise EntityExistsError(\n-                    f\"Unable to create service account with name \"\n-                    f\"'{service_account.name}': Found existing service \"\n-                    \"account with this name.\"\n-                )\n             return new_account.to_service_account_model(include_metadata=True)\n \n     def get_service_account(\n@@ -7357,24 +7358,27 @@ def create_user(self, user: UserRequest) -> UserResponse:\n                 already exists.\n         \"\"\"\n         with Session(self.engine) as session:\n+            # Check if a user account with the given name already exists\n+            err_msg = (\n+                f\"Unable to create user with name '{user.name}': \"\n+                f\"Found an existing user account with this name.\"\n+            )\n+            try:\n+                self._get_account_schema(\n+                    user.name,\n+                    session=session,\n+                    # Filter out service accounts\n+                    service_account=False,\n+                )\n+                raise EntityExistsError(err_msg)\n+            except KeyError:\n+                pass\n+\n             # Create the user\n             new_user = UserSchema.from_user_request(user)\n             session.add(new_user)\n-\n-            # Check if a user account with the given name already exists\n-            users = session.execute(\n-                select(UserSchema).where(\n-                    UserSchema.name == user.name,\n-                    UserSchema.is_service_account.is_(False),  # type: ignore[attr-defined]\n-                )\n-            ).fetchall()\n-            if len(users) == 1:\n-                session.commit()\n-            else:\n-                raise EntityExistsError(\n-                    f\"Unable to create user with name '{user.name}': \"\n-                    f\"Found an existing user account with this name.\"\n-                )\n+            # on commit an IntegrityError may arise we let it bubble up\n+            session.commit()\n             return new_user.to_model(include_metadata=True)\n \n     def get_user("
        },
        {
          "filename": "tests/integration/functional/zen_stores/test_zen_store.py",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -22,6 +22,7 @@\n \n import pytest\n from pydantic import SecretStr\n+from sqlalchemy.exc import IntegrityError\n \n from tests.integration.functional.utils import sample_name\n from tests.integration.functional.zen_stores.utils import (\n@@ -422,7 +423,7 @@ def silent_create_user(user_request: UserRequest):\n         \"\"\"\n         try:\n             clean_client.zen_store.create_user(user_request)\n-        except EntityExistsError:\n+        except (EntityExistsError, IntegrityError):\n             pass\n \n     user_name = \"test_user\"\n@@ -463,7 +464,7 @@ def silent_create_service_account(\n             clean_client.zen_store.create_service_account(\n                 service_account_request\n             )\n-        except EntityExistsError:\n+        except (EntityExistsError, IntegrityError):\n             pass\n \n     user_name = \"test_user\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9a66334a60f51b79706e49b336c1d2c2d5873195",
            "date": "2025-01-23T09:36:11Z",
            "author_login": "bcdurak"
          },
          {
            "sha": "eb2ee3a5ad5ebd4ff61c267a8e49573fb440e91a",
            "date": "2025-01-21T20:44:30Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "dd91059487726ca3be42ab1bc879d92bd9fba2d4",
            "date": "2025-01-21T13:51:18Z",
            "author_login": "wjayesh"
          },
          {
            "sha": "fec095633b2750575b7a043ca761ed4bb497e73b",
            "date": "2025-01-21T13:29:47Z",
            "author_login": "wjayesh"
          },
          {
            "sha": "ffa4ec32929d5e008f4bba3116f1bbc8134326e5",
            "date": "2025-01-21T13:20:33Z",
            "author_login": "stefannica"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:N/I:L/A:L",
    "cwe_id": "CWE-366",
    "description": "A race condition vulnerability exists in zenml-io/zenml versions up to and including 0.55.3, which allows for the creation of multiple users with the same username when requests are sent in parallel. This issue was fixed in version 0.55.5. The vulnerability arises due to insufficient handling of concurrent user creation requests, leading to data inconsistencies and potential authentication problems. Specifically, concurrent processes may overwrite or corrupt user data, complicating user identification and posing security risks. This issue is particularly concerning for APIs that rely on usernames as input parameters, such as PUT /api/v1/users/test_race, where it could lead to further complications.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-06-06T19:15:53.060",
    "last_modified": "2024-11-21T09:08:53.180",
    "fix_date": "2024-03-04T09:05:43Z"
  },
  "references": [
    {
      "url": "https://github.com/zenml-io/zenml/commit/afcaf741ef9114c9b32f722f101b97de3d8d147b",
      "source": "security@huntr.dev",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.com/bounties/6199cd5d-611f-4ea9-96c5-52a952ba5a56",
      "source": "security@huntr.dev",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/zenml-io/zenml/commit/afcaf741ef9114c9b32f722f101b97de3d8d147b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.com/bounties/6199cd5d-611f-4ea9-96c5-52a952ba5a56",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:26.346457",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "zenml",
    "owner": "zenml-io",
    "created_at": "2020-11-19T09:25:46Z",
    "updated_at": "2025-01-25T16:35:19Z",
    "pushed_at": "2025-01-26T06:20:26Z",
    "size": 570246,
    "stars": 4352,
    "forks": 467,
    "open_issues": 36,
    "watchers": 4352,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 9352583,
      "Shell": 44542,
      "Smarty": 21416,
      "Dockerfile": 19050,
      "Jinja": 4977,
      "HTML": 2568,
      "Mako": 695
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:36:10.634921"
  }
}