{
  "cve_id": "CVE-2024-2035",
  "github_data": {
    "repository": "zenml-io/zenml",
    "fix_commit": "b95f083efffa56831cd41d8ed536aeb0b6038fa3",
    "related_commits": [
      "b95f083efffa56831cd41d8ed536aeb0b6038fa3",
      "b95f083efffa56831cd41d8ed536aeb0b6038fa3"
    ],
    "patch_url": "https://github.com/zenml-io/zenml/commit/b95f083efffa56831cd41d8ed536aeb0b6038fa3.patch",
    "fix_commit_details": {
      "sha": "b95f083efffa56831cd41d8ed536aeb0b6038fa3",
      "commit_date": "2024-03-12T16:09:59Z",
      "author": {
        "login": "avishniakov",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Add admin users notion (#2494)",
        "length": 1523,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 670,
        "additions": 603,
        "deletions": 67
      },
      "files": [
        {
          "filename": "examples/quickstart/README.md",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -24,7 +24,7 @@ Along the way we will also show you how to:\n \n You can use Google Colab to see ZenML in action, no signup / installation required!\n \n-<a href=\"https://colab.research.google.com/github/zenml-io/zenml/blob/main/examples/quickstart/run.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n+<a href=\"https://colab.research.google.com/github/zenml-io/zenml/blob/main/examples/quickstart/quickstart.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>\n \n ## :computer: Run Locally\n \n@@ -208,4 +208,4 @@ The best way to get a production ZenML instance up and running with all batterie\n Also, make sure to join our <a href=\"https://zenml.io/slack\" target=\"_blank\">\n     <img width=\"15\" src=\"https://cdn3.iconfinder.com/data/icons/logos-and-brands-adobe/512/306_Slack-512.png\" alt=\"Slack\"/>\n     <b>Slack Community</b> \n-</a> to become part of the ZenML family!\n\\ No newline at end of file\n+</a> to become part of the ZenML family!"
        },
        {
          "filename": "src/zenml/cli/user_management.py",
          "status": "modified",
          "additions": 71,
          "deletions": 4,
          "patch": "@@ -120,15 +120,27 @@ def list_users(ctx: click.Context, **kwargs: Any) -> None:\n     required=False,\n     type=str,\n )\n+@click.option(\n+    \"--is_admin\",\n+    is_flag=True,\n+    help=(\n+        \"Whether the user should be an admin. If not specified, the user will \"\n+        \"be a regular user.\"\n+    ),\n+    required=False,\n+    default=False,\n+)\n def create_user(\n     user_name: str,\n     password: Optional[str] = None,\n+    is_admin: bool = False,\n ) -> None:\n     \"\"\"Create a new user.\n \n     Args:\n         user_name: The name of the user to create.\n         password: The password of the user to create.\n+        is_admin: Whether the user should be an admin.\n     \"\"\"\n     client = Client()\n     if not password:\n@@ -146,7 +158,9 @@ def create_user(\n             )\n \n     try:\n-        new_user = client.create_user(name=user_name, password=password)\n+        new_user = client.create_user(\n+            name=user_name, password=password, is_admin=is_admin\n+        )\n \n         cli_utils.declare(f\"Created user '{new_user.name}'.\")\n     except EntityExistsError as err:\n@@ -162,8 +176,7 @@ def create_user(\n \n @user.command(\n     \"update\",\n-    help=\"Update user information through the cli. All attributes \"\n-    \"except for password can be updated through the cli.\",\n+    help=\"Update user information through the cli.\",\n )\n @click.argument(\"user_name_or_id\", type=str, required=True)\n @click.option(\n@@ -191,26 +204,80 @@ def create_user(\n     required=False,\n     help=\"New user email.\",\n )\n+@click.option(\n+    \"--password\",\n+    \"-p\",\n+    \"updated_password\",\n+    type=str,\n+    required=False,\n+    help=\"New user password.\",\n+)\n+@click.option(\n+    \"--admin\",\n+    \"-a\",\n+    \"make_admin\",\n+    is_flag=True,\n+    required=False,\n+    default=None,\n+    help=\"Whether the user should be an admin.\",\n+)\n+@click.option(\n+    \"--user\",\n+    \"-u\",\n+    \"make_user\",\n+    is_flag=True,\n+    required=False,\n+    default=None,\n+    help=\"Whether the user should be a regular user.\",\n+)\n def update_user(\n     user_name_or_id: str,\n     updated_name: Optional[str] = None,\n     updated_full_name: Optional[str] = None,\n     updated_email: Optional[str] = None,\n+    updated_password: Optional[str] = None,\n+    make_admin: Optional[bool] = None,\n+    make_user: Optional[bool] = None,\n ) -> None:\n-    \"\"\"Create a new user.\n+    \"\"\"Update an existing user.\n \n     Args:\n         user_name_or_id: The name of the user to create.\n         updated_name: The name of the user to create.\n         updated_full_name: The name of the user to create.\n         updated_email: The name of the user to create.\n+        updated_password: The name of the user to create.\n+        make_admin: Whether the user should be an admin.\n+        make_user: Whether the user should be a regular user.\n     \"\"\"\n+    if make_admin is not None and make_user is not None:\n+        cli_utils.error(\n+            \"Cannot set both --admin and --user flags as these are mutually exclusive.\"\n+        )\n     try:\n+        current_user = Client().get_user(\n+            user_name_or_id, allow_name_prefix_match=False\n+        )\n+        if current_user.is_admin and make_user:\n+            confirmation = cli_utils.confirmation(\n+                f\"Currently user `{current_user.name}` is an admin. Are you sure you want to make them a regular user?\"\n+            )\n+            if not confirmation:\n+                cli_utils.declare(\"User update canceled.\")\n+                return\n+\n+        updated_is_admin = None\n+        if make_admin is True:\n+            updated_is_admin = True\n+        elif make_user is True:\n+            updated_is_admin = False\n         Client().update_user(\n             name_id_or_prefix=user_name_or_id,\n             updated_name=updated_name,\n             updated_full_name=updated_full_name,\n             updated_email=updated_email,\n+            updated_password=updated_password,\n+            updated_is_admin=updated_is_admin,\n         )\n     except (KeyError, IllegalOperationError) as err:\n         cli_utils.error(str(err))"
        },
        {
          "filename": "src/zenml/client.py",
          "status": "modified",
          "additions": 13,
          "deletions": 1,
          "patch": "@@ -691,18 +691,22 @@ def create_user(\n         self,\n         name: str,\n         password: Optional[str] = None,\n+        is_admin: bool = False,\n     ) -> UserResponse:\n         \"\"\"Create a new user.\n \n         Args:\n             name: The name of the user.\n             password: The password of the user. If not provided, the user will\n                 be created with empty password.\n+            is_admin: Whether the user should be an admin.\n \n         Returns:\n             The model of the created user.\n         \"\"\"\n-        user = UserRequest(name=name, password=password or None)\n+        user = UserRequest(\n+            name=name, password=password or None, is_admin=is_admin\n+        )\n         user.active = (\n             password != \"\" if self.zen_store.type != StoreType.REST else True\n         )\n@@ -801,6 +805,8 @@ def update_user(\n         updated_email: Optional[str] = None,\n         updated_email_opt_in: Optional[bool] = None,\n         updated_hub_token: Optional[str] = None,\n+        updated_password: Optional[str] = None,\n+        updated_is_admin: Optional[bool] = None,\n     ) -> UserResponse:\n         \"\"\"Update a user.\n \n@@ -811,6 +817,8 @@ def update_user(\n             updated_email: The new email of the user.\n             updated_email_opt_in: The new email opt-in status of the user.\n             updated_hub_token: Update the hub token\n+            updated_password: The new password of the user.\n+            updated_is_admin: Whether the user should be an admin.\n \n         Returns:\n             The updated user.\n@@ -830,6 +838,10 @@ def update_user(\n             user_update.email_opted_in = updated_email_opt_in\n         if updated_hub_token is not None:\n             user_update.hub_token = updated_hub_token\n+        if updated_password is not None:\n+            user_update.password = updated_password\n+        if updated_is_admin is not None:\n+            user_update.is_admin = updated_is_admin\n \n         return self.zen_store.update_user(\n             user_id=user.id, user_update=user_update"
        },
        {
          "filename": "src/zenml/models/v2/core/service_account.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -147,6 +147,7 @@ def to_user_model(self) -> \"UserResponse\":\n                 email_opted_in=False,\n                 created=self.created,\n                 updated=self.updated,\n+                is_admin=False,\n             ),\n             metadata=UserResponseMetadata(\n                 description=self.description,"
        },
        {
          "filename": "src/zenml/models/v2/core/user.py",
          "status": "modified",
          "additions": 78,
          "deletions": 36,
          "patch": "@@ -26,7 +26,7 @@\n )\n from uuid import UUID\n \n-from pydantic import Field, root_validator\n+from pydantic import BaseModel, Field, root_validator\n \n from zenml.constants import STR_FIELD_MAX_LENGTH\n from zenml.models.v2.base.base import (\n@@ -35,40 +35,23 @@\n     BaseRequest,\n     BaseResponseMetadata,\n     BaseResponseResources,\n+    BaseZenModel,\n )\n from zenml.models.v2.base.filter import AnyQuery, BaseFilter\n-from zenml.models.v2.base.update import update_model\n \n if TYPE_CHECKING:\n     from passlib.context import CryptContext\n \n     from zenml.models.v2.base.filter import AnySchema\n \n-# ------------------ Request Model ------------------\n-\n+# ------------------ Base Model ------------------\n \n-class UserRequest(BaseRequest):\n-    \"\"\"Request model for users.\"\"\"\n \n-    # Analytics fields for user request models\n-    ANALYTICS_FIELDS: ClassVar[List[str]] = [\n-        \"name\",\n-        \"full_name\",\n-        \"active\",\n-        \"email_opted_in\",\n-    ]\n+class UserBase(BaseModel):\n+    \"\"\"Base model for users.\"\"\"\n \n     # Fields\n-    name: str = Field(\n-        title=\"The unique username for the account.\",\n-        max_length=STR_FIELD_MAX_LENGTH,\n-    )\n-    full_name: str = Field(\n-        default=\"\",\n-        title=\"The full name for the account owner. Only relevant for user \"\n-        \"accounts.\",\n-        max_length=STR_FIELD_MAX_LENGTH,\n-    )\n+\n     email: Optional[str] = Field(\n         default=None,\n         title=\"The email address associated with the account.\",\n@@ -99,17 +82,6 @@ class UserRequest(BaseRequest):\n         default=None,\n         title=\"The external user ID associated with the account.\",\n     )\n-    active: bool = Field(default=False, title=\"Whether the account is active.\")\n-\n-    class Config:\n-        \"\"\"Pydantic configuration class.\"\"\"\n-\n-        # Validate attributes when assigning them\n-        validate_assignment = True\n-\n-        # Forbid extra attributes to prevent unexpected behavior\n-        extra = \"forbid\"\n-        underscore_attrs_are_private = True\n \n     @classmethod\n     def _get_crypt_context(cls) -> \"CryptContext\":\n@@ -165,13 +137,71 @@ def generate_activation_token(self) -> str:\n         return self.activation_token\n \n \n+# ------------------ Request Model ------------------\n+\n+\n+class UserRequest(UserBase, BaseRequest):\n+    \"\"\"Request model for users.\"\"\"\n+\n+    # Analytics fields for user request models\n+    ANALYTICS_FIELDS: ClassVar[List[str]] = [\n+        \"name\",\n+        \"full_name\",\n+        \"active\",\n+        \"email_opted_in\",\n+    ]\n+\n+    name: str = Field(\n+        title=\"The unique username for the account.\",\n+        max_length=STR_FIELD_MAX_LENGTH,\n+    )\n+    full_name: str = Field(\n+        default=\"\",\n+        title=\"The full name for the account owner. Only relevant for user \"\n+        \"accounts.\",\n+        max_length=STR_FIELD_MAX_LENGTH,\n+    )\n+    is_admin: bool = Field(\n+        title=\"Whether the account is an administrator.\",\n+    )\n+    active: bool = Field(default=False, title=\"Whether the account is active.\")\n+\n+    class Config:\n+        \"\"\"Pydantic configuration class.\"\"\"\n+\n+        # Validate attributes when assigning them\n+        validate_assignment = True\n+\n+        # Forbid extra attributes to prevent unexpected behavior\n+        extra = \"forbid\"\n+        underscore_attrs_are_private = True\n+\n+\n # ------------------ Update Model ------------------\n \n \n-@update_model\n-class UserUpdate(UserRequest):\n+class UserUpdate(UserBase, BaseZenModel):\n     \"\"\"Update model for users.\"\"\"\n \n+    name: Optional[str] = Field(\n+        title=\"The unique username for the account.\",\n+        max_length=STR_FIELD_MAX_LENGTH,\n+        default=None,\n+    )\n+    full_name: Optional[str] = Field(\n+        default=None,\n+        title=\"The full name for the account owner. Only relevant for user \"\n+        \"accounts.\",\n+        max_length=STR_FIELD_MAX_LENGTH,\n+    )\n+    is_admin: Optional[bool] = Field(\n+        default=None,\n+        title=\"Whether the account is an administrator.\",\n+    )\n+    active: Optional[bool] = Field(\n+        default=None, title=\"Whether the account is active.\"\n+    )\n+\n     @root_validator\n     def user_email_updates(cls, values: Dict[str, Any]) -> Dict[str, Any]:\n         \"\"\"Validate that the UserUpdateModel conforms to the email-opt-in-flow.\n@@ -231,6 +261,9 @@ class UserResponseBody(BaseDatedResponseBody):\n     is_service_account: bool = Field(\n         title=\"Indicates whether this is a service account or a user account.\"\n     )\n+    is_admin: bool = Field(\n+        title=\"Whether the account is an administrator.\",\n+    )\n \n \n class UserResponseMetadata(BaseResponseMetadata):\n@@ -340,6 +373,15 @@ def is_service_account(self) -> bool:\n         \"\"\"\n         return self.get_body().is_service_account\n \n+    @property\n+    def is_admin(self) -> bool:\n+        \"\"\"The `is_admin` property.\n+\n+        Returns:\n+            Whether the user is an admin.\n+        \"\"\"\n+        return self.get_body().is_admin\n+\n     @property\n     def email(self) -> Optional[str]:\n         \"\"\"The `email` property."
        },
        {
          "filename": "src/zenml/models/v2/misc/external_user.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -25,6 +25,7 @@ class ExternalUserModel(BaseModel):\n     id: UUID\n     email: str\n     name: Optional[str] = None\n+    is_admin: bool = False\n \n     class Config:\n         \"\"\"Pydantic configuration.\"\"\""
        },
        {
          "filename": "src/zenml/zen_server/auth.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -588,6 +588,7 @@ def authenticate_external_user(external_access_token: str) -> AuthContext:\n                 email_opted_in=True,\n                 active=True,\n                 email=external_user.email,\n+                is_admin=external_user.is_admin,\n             ),\n         )\n     except KeyError:\n@@ -603,6 +604,7 @@ def authenticate_external_user(external_access_token: str) -> AuthContext:\n                 email_opted_in=True,\n                 active=True,\n                 email=external_user.email,\n+                is_admin=external_user.is_admin,\n             )\n         )\n "
        },
        {
          "filename": "src/zenml/zen_server/rbac/endpoint_utils.py",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -59,7 +59,10 @@ def verify_permissions_and_create_entity(\n                 \"different user.\"\n             )\n \n-    verify_permission(resource_type=resource_type, action=Action.CREATE)\n+    verify_permission(\n+        resource_type=resource_type,\n+        action=Action.CREATE,\n+    )\n     return create_method(request_model)\n \n "
        },
        {
          "filename": "src/zenml/zen_server/rbac/utils.py",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -233,7 +233,10 @@ def verify_permission_for_model(model: AnyResponse, action: Action) -> None:\n     batch_verify_permissions_for_models(models=[model], action=action)\n \n \n-def batch_verify_permissions(resources: Set[Resource], action: Action) -> None:\n+def batch_verify_permissions(\n+    resources: Set[Resource],\n+    action: Action,\n+) -> None:\n     \"\"\"Batch permission verification.\n \n     Args:"
        },
        {
          "filename": "src/zenml/zen_server/routers/users_endpoints.py",
          "status": "modified",
          "additions": 65,
          "deletions": 7,
          "patch": "@@ -59,6 +59,7 @@\n     handle_exceptions,\n     make_dependable,\n     server_config,\n+    verify_admin_status_if_no_rbac,\n     zen_store,\n )\n \n@@ -112,6 +113,9 @@ def list_users(\n     if allowed_ids is not None:\n         # Make sure users can see themselves\n         allowed_ids.add(auth_context.user.id)\n+    else:\n+        if not auth_context.user.is_admin and not server_config().rbac_enabled:\n+            allowed_ids = {auth_context.user.id}\n \n     user_filter_model.configure_rbac(\n         authenticated_user_id=auth_context.user.id, id=allowed_ids\n@@ -139,14 +143,15 @@ def list_users(\n     @handle_exceptions\n     def create_user(\n         user: UserRequest,\n-        _: AuthContext = Security(authorize),\n+        auth_context: AuthContext = Security(authorize),\n     ) -> UserResponse:\n         \"\"\"Creates a user.\n \n         # noqa: DAR401\n \n         Args:\n             user: User to create.\n+            auth_context: Authentication context.\n \n         Returns:\n             The created user.\n@@ -163,6 +168,10 @@ def create_user(\n         else:\n             user.active = True\n \n+        verify_admin_status_if_no_rbac(\n+            auth_context.user.is_admin, \"create user\"\n+        )\n+\n         new_user = verify_permissions_and_create_entity(\n             request_model=user,\n             resource_type=ResourceType.USER,\n@@ -202,7 +211,13 @@ def get_user(\n         user_name_or_id=user_name_or_id, hydrate=hydrate\n     )\n     if user.id != auth_context.user.id:\n-        verify_permission_for_model(user, action=Action.READ)\n+        verify_admin_status_if_no_rbac(\n+            auth_context.user.is_admin, \"get other user\"\n+        )\n+        verify_permission_for_model(\n+            user,\n+            action=Action.READ,\n+        )\n \n     return dehydrate_response_model(user)\n \n@@ -235,11 +250,32 @@ def update_user(\n \n         Returns:\n             The updated user.\n+\n+        Raises:\n+            IllegalOperationError: if the user tries change admin status,\n+                while not an admin\n         \"\"\"\n         user = zen_store().get_user(user_name_or_id)\n         if user.id != auth_context.user.id:\n-            verify_permission_for_model(user, action=Action.UPDATE)\n+            verify_admin_status_if_no_rbac(\n+                auth_context.user.is_admin, \"update other user\"\n+            )\n+            verify_permission_for_model(\n+                user,\n+                action=Action.UPDATE,\n+            )\n+        if (\n+            user_update.is_admin is not None\n+            and user.is_admin != user_update.is_admin\n+            and not auth_context.user.is_admin\n+        ):\n+            raise IllegalOperationError(\n+                \"Only admins can change the admin status of other users.\"\n+            )\n \n+        user_update.activation_token = user.activation_token\n+        if not auth_context.user.is_admin or user.id == auth_context.user.id:\n+            user_update.active = user.active\n         updated_user = zen_store().update_user(\n             user_id=user.id,\n             user_update=user_update,\n@@ -279,6 +315,7 @@ def activate_user(\n         )\n         user_update.active = True\n         user_update.activation_token = None\n+        user_update.is_admin = user.is_admin\n         return zen_store().update_user(\n             user_id=user.id, user_update=user_update\n         )\n@@ -305,10 +342,21 @@ def deactivate_user(\n \n         Returns:\n             The generated activation token.\n+\n+        Raises:\n+            IllegalOperationError: if the user is trying to deactivate\n+                themselves.\n         \"\"\"\n         user = zen_store().get_user(user_name_or_id)\n-        if user.id != auth_context.user.id:\n-            verify_permission_for_model(user, action=Action.UPDATE)\n+        if user.id == auth_context.user.id:\n+            raise IllegalOperationError(\"Cannot deactivate yourself.\")\n+        verify_admin_status_if_no_rbac(\n+            auth_context.user.is_admin, \"deactivate user\"\n+        )\n+        verify_permission_for_model(\n+            user,\n+            action=Action.UPDATE,\n+        )\n \n         user_update = UserUpdate(\n             name=user.name,\n@@ -354,7 +402,13 @@ def delete_user(\n                 \"administrator.\"\n             )\n         else:\n-            verify_permission_for_model(user, action=Action.DELETE)\n+            verify_admin_status_if_no_rbac(\n+                auth_context.user.is_admin, \"delete user\"\n+            )\n+            verify_permission_for_model(\n+                user,\n+                action=Action.DELETE,\n+            )\n \n         zen_store().delete_user(user_name_or_id=user_name_or_id)\n \n@@ -402,7 +456,6 @@ def email_opt_in_response(\n                     email=user_response.email,\n                     source=\"zenml server\",\n                 )\n-\n             updated_user = zen_store().update_user(\n                 user_id=user.id, user_update=user_update\n             )\n@@ -460,6 +513,11 @@ def update_myself(\n         Returns:\n             The updated user.\n         \"\"\"\n+        current_user = zen_store().get_user(auth_context.user.id)\n+        user.activation_token = current_user.activation_token\n+        user.active = current_user.active\n+        user.is_admin = current_user.is_admin\n+\n         updated_user = zen_store().update_user(\n             user_id=auth_context.user.id, user_update=user\n         )"
        },
        {
          "filename": "src/zenml/zen_server/utils.py",
          "status": "modified",
          "additions": 32,
          "deletions": 1,
          "patch": "@@ -27,7 +27,7 @@\n     ENV_ZENML_SERVER,\n )\n from zenml.enums import ServerProviderType\n-from zenml.exceptions import OAuthError\n+from zenml.exceptions import IllegalOperationError, OAuthError\n from zenml.logger import get_logger\n from zenml.plugins.plugin_flavor_registry import PluginFlavorRegistry\n from zenml.zen_server.deploy.deployment import ServerDeployment\n@@ -396,3 +396,34 @@ def get_ip_location(ip_address: str) -> Tuple[str, str, str]:\n     except Exception:\n         logger.exception(f\"Could not get IP location for {ip_address}.\")\n         return \"\", \"\", \"\"\n+\n+\n+def verify_admin_status_if_no_rbac(\n+    admin_status: Optional[bool],\n+    action: Optional[str] = None,\n+) -> None:\n+    \"\"\"Validate the admin status for sensitive requests.\n+\n+    Only add this check in endpoints meant for admin use only.\n+\n+    Args:\n+        admin_status: Whether the user is an admin or not. This is only used\n+            if explicitly specified in the call and even if passed will be\n+            ignored, if RBAC is enabled.\n+        action: The action that is being performed, used for output only.\n+\n+    Raises:\n+        IllegalOperationError: If the admin status is not valid.\n+    \"\"\"\n+    if not server_config().rbac_enabled:\n+        if not action:\n+            action = \"this action\"\n+        else:\n+            action = f\"`{action.strip('`')}`\"\n+\n+        if admin_status is False:\n+            raise IllegalOperationError(\n+                message=f\"Only admin users can perform {action} \"\n+                \"without RBAC enabled.\",\n+            )\n+    return"
        },
        {
          "filename": "src/zenml/zen_stores/migrations/versions/1a9a9d2a836d_admin_users.py",
          "status": "added",
          "additions": 56,
          "deletions": 0,
          "patch": "@@ -0,0 +1,56 @@\n+\"\"\"admin users [1a9a9d2a836d].\n+\n+Revision ID: 1a9a9d2a836d\n+Revises: 0.55.5\n+Create Date: 2024-03-04 15:48:16.580871\n+\n+\"\"\"\n+\n+import sqlalchemy as sa\n+import sqlmodel\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"1a9a9d2a836d\"\n+down_revision = \"0.55.5\"\n+branch_labels = None\n+depends_on = None\n+\n+\n+def upgrade() -> None:\n+    \"\"\"Upgrade database schema and/or data, creating a new revision.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    bind = op.get_bind()\n+    session = sqlmodel.Session(bind=bind)\n+\n+    with op.batch_alter_table(\"user\", schema=None) as batch_op:\n+        batch_op.add_column(\n+            sa.Column(\n+                \"is_admin\",\n+                sa.Boolean(),\n+                nullable=False,\n+                server_default=sa.sql.expression.false(),\n+            )\n+        )\n+\n+    # during migration we treat all users as admin for backward compatibility\n+    # this should be adjusted by server admins after upgrade\n+    session.execute(\n+        sa.text(\n+            \"\"\"\n+            UPDATE user\n+            SET is_admin = true\n+            WHERE NOT is_service_account AND external_user_id IS NULL\n+            \"\"\"\n+        )\n+    )\n+    # ### end Alembic commands ###\n+\n+\n+def downgrade() -> None:\n+    \"\"\"Downgrade database schema and/or data back to the previous revision.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    with op.batch_alter_table(\"user\", schema=None) as batch_op:\n+        batch_op.drop_column(\"is_admin\")\n+\n+    # ### end Alembic commands ###"
        },
        {
          "filename": "src/zenml/zen_stores/schemas/user_schemas.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -77,6 +77,7 @@ class UserSchema(NamedSchema, table=True):\n     hub_token: Optional[str] = Field(nullable=True)\n     email_opted_in: Optional[bool] = Field(nullable=True)\n     external_user_id: Optional[UUID] = Field(nullable=True)\n+    is_admin: bool = Field(default=False)\n \n     stacks: List[\"StackSchema\"] = Relationship(back_populates=\"user\")\n     components: List[\"StackComponentSchema\"] = Relationship(\n@@ -167,6 +168,7 @@ def from_user_request(cls, model: UserRequest) -> \"UserSchema\":\n             email_opted_in=model.email_opted_in,\n             email=model.email,\n             is_service_account=False,\n+            is_admin=model.is_admin,\n         )\n \n     @classmethod\n@@ -189,6 +191,7 @@ def from_service_account_request(\n             is_service_account=True,\n             email_opted_in=False,\n             full_name=\"\",\n+            is_admin=False,\n         )\n \n     def update_user(self, user_update: UserUpdate) -> \"UserSchema\":\n@@ -271,6 +274,7 @@ def to_model(\n                 is_service_account=self.is_service_account,\n                 created=self.created,\n                 updated=self.updated,\n+                is_admin=self.is_admin,\n             ),\n             metadata=metadata,\n         )"
        },
        {
          "filename": "src/zenml/zen_stores/sql_zen_store.py",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -7514,6 +7514,14 @@ def update_user(\n                 user_id, session=session, service_account=False\n             )\n \n+            if (\n+                existing_user.name == self._default_user_name\n+                and user_update.is_admin is False\n+            ):\n+                raise IllegalOperationError(\n+                    \"The default user's admin status cannot be removed.\"\n+                )\n+\n             if (\n                 user_update.name is not None\n                 and user_update.name != existing_user.name\n@@ -7604,6 +7612,7 @@ def _get_or_create_default_user(self) -> UserResponse:\n                     name=default_user_name,\n                     active=True,\n                     password=password,\n+                    is_admin=True,\n                 )\n             )\n "
        },
        {
          "filename": "tests/integration/functional/zen_stores/test_zen_store.py",
          "status": "modified",
          "additions": 251,
          "deletions": 6,
          "patch": "@@ -12,10 +12,12 @@\n #  or implied. See the License for the specific language governing\n #  permissions and limitations under the License.\n import os\n+import random\n import time\n import uuid\n from contextlib import ExitStack as does_not_raise\n from datetime import datetime\n+from string import ascii_lowercase\n from threading import Thread\n from typing import Dict, List, Optional, Tuple\n from uuid import UUID, uuid4\n@@ -127,6 +129,7 @@\n from zenml.models.v2.core.user import UserFilter\n from zenml.utils import code_repository_utils, source_utils\n from zenml.utils.enum_utils import StrEnum\n+from zenml.zen_stores.rest_zen_store import RestZenStore\n from zenml.zen_stores.sql_zen_store import SqlZenStore\n \n DEFAULT_NAME = \"default\"\n@@ -377,6 +380,235 @@ def test_deleting_default_workspace_fails():\n # '-------'\n \n \n+class TestAdminUser:\n+    default_pwd = \"\".join(random.choices(ascii_lowercase, k=10))\n+\n+    def test_creation_as_admin_and_non_admin(self):\n+        \"\"\"Tests creating a user as an admin and as a non-admin.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        with UserContext(login=True, is_admin=False):\n+            zen_store: RestZenStore = Client().zen_store\n+            # this is not allowed for non-admin users\n+            with pytest.raises(IllegalOperationError):\n+                zen_store.create_user(\n+                    UserRequest(\n+                        name=sample_name(\"test_user\"),\n+                        password=self.default_pwd,\n+                        is_admin=False,\n+                    )\n+                )\n+\n+    def test_listing_users(self):\n+        \"\"\"Tests listing users as an admin and as a non-admin.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            zen_store: RestZenStore = Client().zen_store\n+            users = zen_store.list_users(UserFilter())\n+            assert users.total >= 2\n+\n+            # this is limited to self only for non-admin users\n+            with LoginContext(\n+                user_name=test_user.name, password=self.default_pwd\n+            ):\n+                zen_store = Client().zen_store\n+                users = zen_store.list_users(UserFilter())\n+                assert users.total == 1\n+\n+    def test_get_users(self):\n+        \"\"\"Tests getting users as an admin and as a non-admin.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            zen_store: RestZenStore = Client().zen_store\n+\n+            user = zen_store.get_user(test_user.name)\n+            assert user.id == test_user.id\n+\n+            # this is not allowed for non-admin users\n+            with LoginContext(\n+                user_name=test_user.name, password=self.default_pwd\n+            ):\n+                zen_store = Client().zen_store\n+                with pytest.raises(IllegalOperationError):\n+                    zen_store.get_user(DEFAULT_USERNAME)\n+\n+    def test_update_users(self):\n+        \"\"\"Tests updating users as an admin and as a non-admin.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            zen_store: RestZenStore = Client().zen_store\n+\n+            user = zen_store.update_user(\n+                test_user.id,\n+                UserUpdate(full_name=\"foo@bar.ai\"),\n+            )\n+            assert user.full_name == \"foo@bar.ai\"\n+\n+            with UserContext(login=True, is_admin=False):\n+                zen_store = Client().zen_store\n+\n+                # this is not allowed for non-admin users\n+                with pytest.raises(IllegalOperationError):\n+                    zen_store.update_user(\n+                        test_user.id,\n+                        UserUpdate(full_name=\"bar@foo.io\"),\n+                    )\n+\n+            # user is allowed to update itself\n+            with LoginContext(\n+                user_name=test_user.name, password=self.default_pwd\n+            ):\n+                zen_store = Client().zen_store\n+                user = zen_store.update_user(\n+                    test_user.id,\n+                    UserUpdate(full_name=\"bar@foo.io\"),\n+                )\n+\n+                assert user.full_name == \"bar@foo.io\"\n+\n+    def test_deactivate_users(self):\n+        \"\"\"Tests deactivating users as an admin and as a non-admin.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        zen_store: RestZenStore = Client().zen_store\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            with UserContext(is_admin=False) as test_user2:\n+                # this is not allowed for non-admin users\n+                with LoginContext(\n+                    user_name=test_user.name, password=self.default_pwd\n+                ):\n+                    new_zen_store: RestZenStore = Client().zen_store\n+                    with pytest.raises(IllegalOperationError):\n+                        new_zen_store.put(\n+                            f\"{USERS}/{str(test_user2.id)}{DEACTIVATE}\"\n+                        )\n+\n+                response_body = zen_store.put(\n+                    f\"{USERS}/{str(test_user2.id)}{DEACTIVATE}\",\n+                )\n+                deactivated_user = UserResponse.parse_obj(response_body)\n+                assert deactivated_user.name == test_user2.name\n+\n+    def test_delete_users(self):\n+        \"\"\"Tests deleting users as an admin and as a non-admin.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        zen_store: RestZenStore = Client().zen_store\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            with UserContext(is_admin=False) as test_user2:\n+                # this is not allowed for non-admin users\n+                with LoginContext(\n+                    user_name=test_user.name, password=self.default_pwd\n+                ):\n+                    new_zen_store: RestZenStore = Client().zen_store\n+                    with pytest.raises(IllegalOperationError):\n+                        new_zen_store.delete_user(test_user2.id)\n+\n+            zen_store.delete_user(test_user.id)\n+\n+    def test_update_self_via_normal_endpoint(self):\n+        \"\"\"Tests updating self in admin and non-admin setting.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        zen_store: RestZenStore = Client().zen_store\n+        default_user = zen_store.get_user(DEFAULT_USERNAME)\n+        with pytest.raises(IllegalOperationError):\n+            # cannot update admin status for default user\n+            zen_store.update_user(\n+                default_user.id,\n+                UserUpdate(name=default_user.name, is_admin=False),\n+            )\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            # this is not allowed for non-admin users\n+            with LoginContext(\n+                user_name=test_user.name, password=self.default_pwd\n+            ):\n+                new_zen_store: RestZenStore = Client().zen_store\n+                with pytest.raises(IllegalOperationError):\n+                    new_zen_store.update_user(\n+                        test_user.id,\n+                        UserUpdate(\n+                            name=test_user.name,\n+                            is_admin=True,\n+                        ),\n+                    )\n+\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            zen_store.update_user(\n+                test_user.id,\n+                UserUpdate(name=test_user.name, is_admin=True),\n+            )\n+            with LoginContext(\n+                user_name=test_user.name, password=self.default_pwd\n+            ):\n+                new_zen_store: RestZenStore = Client().zen_store\n+                new_zen_store.update_user(\n+                    test_user.id,\n+                    UserUpdate(\n+                        name=test_user.name,\n+                        is_admin=False,\n+                    ),\n+                )\n+\n+    def test_update_self_via_current_user_endpoint(self):\n+        \"\"\"Tests updating self in admin and non-admin setting.\"\"\"\n+        if Client().zen_store.type == StoreType.SQL:\n+            pytest.skip(\"SQL ZenStore does not support admin users.\")\n+\n+        zen_store: RestZenStore = Client().zen_store\n+        default_user = zen_store.get_user(DEFAULT_USERNAME)\n+        assert default_user.is_admin\n+        # self update cannot change admin status\n+        zen_store.put(\n+            \"/current-user\",\n+            body=UserUpdate(name=default_user.name, is_admin=False),\n+        )\n+        default_user = zen_store.get_user(DEFAULT_USERNAME)\n+        assert default_user.is_admin\n+        with UserContext(\n+            password=self.default_pwd, is_admin=False\n+        ) as test_user:\n+            with LoginContext(\n+                user_name=test_user.name, password=self.default_pwd\n+            ):\n+                new_zen_store: RestZenStore = Client().zen_store\n+                assert not test_user.is_admin\n+                # self update cannot change admin status\n+                new_zen_store.put(\n+                    \"/current-user\",\n+                    body=UserUpdate(\n+                        name=test_user.name,\n+                        is_admin=True,\n+                    ),\n+                )\n+                user = zen_store.get_user(test_user.id)\n+                assert not user.is_admin\n+\n+\n def test_active_user():\n     \"\"\"Tests the active user can be queried with .get_user().\"\"\"\n     zen_store = Client().zen_store\n@@ -397,14 +629,20 @@ def test_creating_user_with_existing_name_fails():\n     with UserContext() as existing_user:\n         with pytest.raises(EntityExistsError):\n             zen_store.create_user(\n-                UserRequest(name=existing_user.name, password=\"password\")\n+                UserRequest(\n+                    name=existing_user.name,\n+                    password=\"password\",\n+                    is_admin=False,\n+                )\n             )\n \n     with ServiceAccountContext() as existing_service_account:\n         with does_not_raise():\n             user = zen_store.create_user(\n                 UserRequest(\n-                    name=existing_service_account.name, password=\"password\"\n+                    name=existing_service_account.name,\n+                    password=\"password\",\n+                    is_admin=False,\n                 )\n             )\n             # clean up\n@@ -434,7 +672,9 @@ def silent_create_user(user_request: UserRequest):\n     for _ in range(count):\n         t = Thread(\n             target=silent_create_user,\n-            args=(UserRequest(name=user_name, password=password),),\n+            args=(\n+                UserRequest(name=user_name, password=password, is_admin=False),\n+            ),\n         )\n         threads.append(t)\n     for t in threads:\n@@ -740,7 +980,7 @@ def test_create_user_no_password():\n         with pytest.raises(AuthorizationException):\n             response_body = store.put(\n                 f\"{USERS}/{str(user.id)}{ACTIVATE}\",\n-                body=UserUpdate(password=\"password\"),\n+                body=UserUpdate(password=\"password\", is_admin=user.is_admin),\n             )\n \n         with pytest.raises(AuthorizationException):\n@@ -750,7 +990,9 @@ def test_create_user_no_password():\n         response_body = store.put(\n             f\"{USERS}/{str(user.id)}{ACTIVATE}\",\n             body=UserUpdate(\n-                password=\"password\", activation_token=user.activation_token\n+                password=\"password\",\n+                activation_token=user.activation_token,\n+                is_admin=user.is_admin,\n             ),\n         )\n         activated_user = UserResponse.parse_obj(response_body)\n@@ -793,7 +1035,9 @@ def test_reactivate_user():\n         with pytest.raises(AuthorizationException):\n             response_body = store.put(\n                 f\"{USERS}/{str(user.id)}{ACTIVATE}\",\n-                body=UserUpdate(password=\"newpassword\"),\n+                body=UserUpdate(\n+                    password=\"newpassword\", is_admin=user.is_admin\n+                ),\n             )\n \n         with pytest.raises(AuthorizationException):\n@@ -809,6 +1053,7 @@ def test_reactivate_user():\n             body=UserUpdate(\n                 password=\"newpassword\",\n                 activation_token=deactivated_user.activation_token,\n+                is_admin=user.is_admin,\n             ),\n         )\n         activated_user = UserResponse.parse_obj(response_body)"
        },
        {
          "filename": "tests/integration/functional/zen_stores/utils.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -191,6 +191,7 @@ def __init__(\n         login: bool = False,\n         existing_user: bool = False,\n         delete: bool = True,\n+        is_admin: bool = True,\n     ):\n         if existing_user:\n             self.user_name = user_name\n@@ -207,11 +208,15 @@ def __init__(\n             self.password = password or random_str(32)\n         self.existing_user = existing_user\n         self.delete = delete\n+        self.is_admin = is_admin\n \n     def __enter__(self):\n         if not self.existing_user:\n             new_user = UserRequest(\n-                name=self.user_name, password=self.password, active=True\n+                name=self.user_name,\n+                password=self.password,\n+                active=True,\n+                is_admin=self.is_admin,\n             )\n             self.created_user = self.store.create_user(new_user)\n         else:\n@@ -1011,7 +1016,7 @@ def cleanup(self) -> None:\n     entity_name=\"workspace\",\n )\n user_crud_test_config = CrudTestConfig(\n-    create_model=UserRequest(name=sample_name(\"sample_user\")),\n+    create_model=UserRequest(name=sample_name(\"sample_user\"), is_admin=True),\n     update_model=UserUpdate(name=sample_name(\"updated_sample_user\")),\n     filter_model=UserFilter,\n     entity_name=\"user\","
        },
        {
          "filename": "tests/unit/conftest.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -372,6 +372,7 @@ def sample_user_model() -> UserResponse:\n             created=datetime.now(),\n             updated=datetime.now(),\n             is_service_account=False,\n+            is_admin=True,\n         ),\n         metadata=UserResponseMetadata(),\n     )"
        },
        {
          "filename": "tests/unit/models/test_user_models.py",
          "status": "modified",
          "additions": 2,
          "deletions": 6,
          "patch": "@@ -26,15 +26,11 @@ def test_user_request_model_fails_with_long_password():\n     \"\"\"Test that the user request model fails with long passwords.\"\"\"\n     long_password = \"a\" * (STR_FIELD_MAX_LENGTH + 1)\n     with pytest.raises(ValidationError):\n-        UserRequest(\n-            password=long_password,\n-        )\n+        UserRequest(password=long_password, is_admin=False)\n \n \n def test_user_request_model_fails_with_long_activation_token():\n     \"\"\"Test that the user request model fails with long activation tokens.\"\"\"\n     long_token = \"a\" * (STR_FIELD_MAX_LENGTH + 1)\n     with pytest.raises(ValidationError):\n-        UserRequest(\n-            activation_token=long_token,\n-        )\n+        UserRequest(activation_token=long_token, is_admin=False)"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 14,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "59ebe58a931b01e362a410fdd31897c93757ad94",
            "date": "2025-01-13T16:44:34Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "91a8513e69fbd44cd7de630fca8d2a6954120714",
            "date": "2025-01-13T14:46:13Z",
            "author_login": "schustmi"
          },
          {
            "sha": "ef3bc8be215d2f59f002f89b779665fa0702a591",
            "date": "2025-01-10T13:25:37Z",
            "author_login": "schustmi"
          },
          {
            "sha": "80f2ed2c38a8ccadb77ef2d3638f08e321f2dc43",
            "date": "2025-01-10T08:11:58Z",
            "author_login": "htahir1"
          },
          {
            "sha": "c2fe19eb039c133a53ba68730251209a84876285",
            "date": "2025-01-09T10:43:55Z",
            "author_login": "bcdurak"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H",
    "cwe_id": "CWE-1220",
    "description": "An improper authorization vulnerability exists in the zenml-io/zenml repository, specifically within the API PUT /api/v1/users/id endpoint. This vulnerability allows any authenticated user to modify the information of other users, including changing the `active` status of user accounts to false, effectively deactivating them. This issue affects version 0.55.3 and was fixed in version 0.56.2. The impact of this vulnerability is significant as it allows for the deactivation of admin accounts, potentially disrupting the functionality and security of the application.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-06T19:15:53.313",
    "last_modified": "2024-11-21T09:08:53.557",
    "fix_date": "2024-03-12T16:09:59Z"
  },
  "references": [
    {
      "url": "https://github.com/zenml-io/zenml/commit/b95f083efffa56831cd41d8ed536aeb0b6038fa3",
      "source": "security@huntr.dev",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.com/bounties/1cfc6493-082e-4229-9f2f-496801a6557c",
      "source": "security@huntr.dev",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/zenml-io/zenml/commit/b95f083efffa56831cd41d8ed536aeb0b6038fa3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://huntr.com/bounties/1cfc6493-082e-4229-9f2f-496801a6557c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:26.346586",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zenml",
    "owner": "zenml-io",
    "created_at": "2020-11-19T09:25:46Z",
    "updated_at": "2025-01-14T12:18:07Z",
    "pushed_at": "2025-01-14T11:42:49Z",
    "size": 561721,
    "stars": 4313,
    "forks": 466,
    "open_issues": 38,
    "watchers": 4313,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 9297441,
      "Shell": 45611,
      "Smarty": 20620,
      "Dockerfile": 19050,
      "Jinja": 4977,
      "HTML": 2568,
      "Mako": 695
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:05:19.405915"
  }
}