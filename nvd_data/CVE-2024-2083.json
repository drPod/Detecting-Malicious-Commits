{
  "cve_id": "CVE-2024-2083",
  "github_data": {
    "repository": "zenml-io/zenml",
    "fix_commit": "00e934f33a243a554f5f65b80eefd5ea5117367b",
    "related_commits": [
      "00e934f33a243a554f5f65b80eefd5ea5117367b",
      "00e934f33a243a554f5f65b80eefd5ea5117367b"
    ],
    "patch_url": "https://github.com/zenml-io/zenml/commit/00e934f33a243a554f5f65b80eefd5ea5117367b.patch",
    "fix_commit_details": {
      "sha": "00e934f33a243a554f5f65b80eefd5ea5117367b",
      "commit_date": "2024-03-05T08:02:33Z",
      "author": {
        "login": "avishniakov",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Improve Artifact Store isolation (#2490)",
        "length": 595,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 392,
        "additions": 279,
        "deletions": 113
      },
      "files": [
        {
          "filename": "src/zenml/artifact_stores/base_artifact_store.py",
          "status": "modified",
          "additions": 113,
          "deletions": 54,
          "patch": "@@ -13,8 +13,10 @@\n #  permissions and limitations under the License.\n \"\"\"The base interface to extend the ZenML artifact store.\"\"\"\n \n+import inspect\n import textwrap\n from abc import abstractmethod\n+from pathlib import Path\n from typing import (\n     Any,\n     Callable,\n@@ -44,50 +46,93 @@\n PathType = Union[bytes, str]\n \n \n-def _sanitize_potential_path(potential_path: Any) -> Any:\n-    \"\"\"Sanitizes the input if it is a path.\n+class _sanitize_paths:\n+    \"\"\"Sanitizes path inputs before calling the original function.\n \n-    If the input is a **remote** path, this function replaces backslash path\n-    separators by forward slashes.\n+    Extra decoration layer is needed to pass in fixed artifact store root\n+    path for static methods that are called on filesystems directly.\n \n     Args:\n-        potential_path: Value that potentially refers to a (remote) path.\n+        func: The function to decorate.\n+        fixed_root_path: The fixed artifact store root path.\n+        is_static: Whether the function is static or not.\n \n     Returns:\n-        The original input or a sanitized version of it in case of a remote\n-        path.\n+        Function that calls the input function with sanitized path inputs.\n     \"\"\"\n-    if isinstance(potential_path, bytes):\n-        path = fileio.convert_to_str(potential_path)\n-    elif isinstance(potential_path, str):\n-        path = potential_path\n-    else:\n-        # Neither string nor bytes, this is not a path\n-        return potential_path\n \n-    if io_utils.is_remote(path):\n-        # If we have a remote path, replace windows path separators with\n-        # slashes\n-        import ntpath\n-        import posixpath\n+    def __init__(self, func: Callable[..., Any], fixed_root_path: str) -> None:\n+        \"\"\"Initializes the decorator.\n \n-        path = path.replace(ntpath.sep, posixpath.sep)\n+        Args:\n+            func: The function to decorate.\n+            fixed_root_path: The fixed artifact store root path.\n+        \"\"\"\n+        self.func = func\n+        self.fixed_root_path = fixed_root_path\n \n-    return path\n+        self.path_args: List[int] = []\n+        self.path_kwargs: List[str] = []\n+        for i, param in enumerate(\n+            inspect.signature(self.func).parameters.values()\n+        ):\n+            if param.annotation == PathType:\n+                self.path_kwargs.append(param.name)\n+                if param.default == inspect.Parameter.empty:\n+                    self.path_args.append(i)\n \n+    def _validate_path(self, path: str) -> None:\n+        \"\"\"Validates a path.\n \n-def _sanitize_paths(_func: Callable[..., Any]) -> Callable[..., Any]:\n-    \"\"\"Sanitizes path inputs before calling the original function.\n+        Args:\n+            path: The path to validate.\n \n-    Args:\n-        _func: The function for which to sanitize the inputs.\n+        Raises:\n+            FileNotFoundError: If the path is outside of the artifact store\n+                bounds.\n+        \"\"\"\n+        if not path.startswith(self.fixed_root_path):\n+            raise FileNotFoundError(\n+                f\"File `{path}` is outside of \"\n+                f\"artifact store bounds `{self.fixed_root_path}`\"\n+            )\n \n-    Returns:\n-        Function that calls the input function with sanitized path inputs.\n-    \"\"\"\n+    def _sanitize_potential_path(self, potential_path: Any) -> Any:\n+        \"\"\"Sanitizes the input if it is a path.\n+\n+        If the input is a **remote** path, this function replaces backslash path\n+        separators by forward slashes.\n \n-    def inner_function(*args: Any, **kwargs: Any) -> Any:\n-        \"\"\"Inner function.\n+        Args:\n+            potential_path: Value that potentially refers to a (remote) path.\n+\n+        Returns:\n+            The original input or a sanitized version of it in case of a remote\n+            path.\n+        \"\"\"\n+        if isinstance(potential_path, bytes):\n+            path = fileio.convert_to_str(potential_path)\n+        elif isinstance(potential_path, str):\n+            path = potential_path\n+        else:\n+            # Neither string nor bytes, this is not a path\n+            return potential_path\n+\n+        if io_utils.is_remote(path):\n+            # If we have a remote path, replace windows path separators with\n+            # slashes\n+            import ntpath\n+            import posixpath\n+\n+            path = path.replace(ntpath.sep, posixpath.sep)\n+            self._validate_path(path)\n+        else:\n+            self._validate_path(str(Path(path).absolute().resolve()))\n+\n+        return path\n+\n+    def __call__(self, *args: Any, **kwargs: Any) -> Any:\n+        \"\"\"Decorator function that sanitizes paths before calling the original function.\n \n         Args:\n             *args: Positional args.\n@@ -96,15 +141,28 @@ def inner_function(*args: Any, **kwargs: Any) -> Any:\n         Returns:\n             Output of the input function called with sanitized paths.\n         \"\"\"\n-        args = tuple(_sanitize_potential_path(arg) for arg in args)\n+        # verify if `self` is part of the args\n+        has_self = bool(args and isinstance(args[0], BaseArtifactStore))\n+\n+        # sanitize inputs for relevant args and kwargs, keep rest unchanged\n+        args = tuple(\n+            self._sanitize_potential_path(\n+                arg,\n+            )\n+            if i + has_self in self.path_args\n+            else arg\n+            for i, arg in enumerate(args)\n+        )\n         kwargs = {\n-            key: _sanitize_potential_path(value)\n+            key: self._sanitize_potential_path(\n+                value,\n+            )\n+            if key in self.path_kwargs\n+            else value\n             for key, value in kwargs.items()\n         }\n \n-        return _func(*args, **kwargs)\n-\n-    return inner_function\n+        return self.func(*args, **kwargs)\n \n \n class BaseArtifactStoreConfig(StackComponentConfig):\n@@ -323,6 +381,7 @@ def stat(self, path: PathType) -> Any:\n             The stat descriptor.\n         \"\"\"\n \n+    @abstractmethod\n     def size(self, path: PathType) -> Optional[int]:\n         \"\"\"Get the size of a file in bytes.\n \n@@ -376,30 +435,30 @@ def _register(self) -> None:\n         from zenml.io.filesystem_registry import default_filesystem_registry\n         from zenml.io.local_filesystem import LocalFilesystem\n \n+        overloads: Dict[str, Any] = {\n+            \"SUPPORTED_SCHEMES\": self.config.SUPPORTED_SCHEMES,\n+        }\n+        for abc_method in inspect.getmembers(BaseArtifactStore):\n+            if getattr(abc_method[1], \"__isabstractmethod__\", False):\n+                sanitized_method = _sanitize_paths(\n+                    getattr(self, abc_method[0]), self.path\n+                )\n+                # prepare overloads for filesystem methods\n+                overloads[abc_method[0]] = staticmethod(sanitized_method)\n+\n+                # decorate artifact store methods\n+                setattr(\n+                    self,\n+                    abc_method[0],\n+                    sanitized_method,\n+                )\n+\n         # Local filesystem is always registered, no point in doing it again.\n         if isinstance(self, LocalFilesystem):\n             return\n \n         filesystem_class = type(\n-            self.__class__.__name__,\n-            (BaseFilesystem,),\n-            {\n-                \"SUPPORTED_SCHEMES\": self.config.SUPPORTED_SCHEMES,\n-                \"open\": staticmethod(_sanitize_paths(self.open)),\n-                \"copyfile\": staticmethod(_sanitize_paths(self.copyfile)),\n-                \"exists\": staticmethod(_sanitize_paths(self.exists)),\n-                \"glob\": staticmethod(_sanitize_paths(self.glob)),\n-                \"isdir\": staticmethod(_sanitize_paths(self.isdir)),\n-                \"listdir\": staticmethod(_sanitize_paths(self.listdir)),\n-                \"makedirs\": staticmethod(_sanitize_paths(self.makedirs)),\n-                \"mkdir\": staticmethod(_sanitize_paths(self.mkdir)),\n-                \"remove\": staticmethod(_sanitize_paths(self.remove)),\n-                \"rename\": staticmethod(_sanitize_paths(self.rename)),\n-                \"rmtree\": staticmethod(_sanitize_paths(self.rmtree)),\n-                \"size\": staticmethod(_sanitize_paths(self.size)),\n-                \"stat\": staticmethod(_sanitize_paths(self.stat)),\n-                \"walk\": staticmethod(_sanitize_paths(self.walk)),\n-            },\n+            self.__class__.__name__, (BaseFilesystem,), overloads\n         )\n \n         default_filesystem_registry.register(filesystem_class)"
        },
        {
          "filename": "src/zenml/artifacts/utils.py",
          "status": "modified",
          "additions": 7,
          "deletions": 3,
          "patch": "@@ -152,7 +152,7 @@ def save_artifact(\n     if not uri.startswith(artifact_store.path):\n         uri = os.path.join(artifact_store.path, uri)\n \n-    if manual_save and fileio.exists(uri):\n+    if manual_save and artifact_store.exists(uri):\n         # This check is only necessary for manual saves as we already check\n         # it when creating the directory for step output artifacts\n         other_artifacts = client.list_artifact_versions(uri=uri, size=1)\n@@ -162,7 +162,7 @@ def save_artifact(\n                 f\"{uri} because the URI is already used by artifact \"\n                 f\"{other_artifact.name} (version {other_artifact.version}).\"\n             )\n-    fileio.makedirs(uri)\n+    artifact_store.makedirs(uri)\n \n     # Find and initialize the right materializer class\n     if isinstance(materializer, type):\n@@ -752,6 +752,7 @@ def _load_file_from_artifact_store(\n     Raises:\n         DoesNotExistException: If the file does not exist in the artifact store.\n         NotImplementedError: If the artifact store cannot open the file.\n+        IOError: If the artifact store rejects the request.\n     \"\"\"\n     try:\n         with artifact_store.open(uri, mode) as text_file:\n@@ -761,6 +762,8 @@ def _load_file_from_artifact_store(\n             f\"File '{uri}' does not exist in artifact store \"\n             f\"'{artifact_store.name}'.\"\n         )\n+    except IOError as e:\n+        raise e\n     except Exception as e:\n         logger.exception(e)\n         link = \"https://docs.zenml.io/stacks-and-components/component-guide/artifact-stores/custom#enabling-artifact-visualizations-with-custom-artifact-stores\"\n@@ -819,7 +822,8 @@ def load_model_from_metadata(model_uri: str) -> Any:\n         The ML model object loaded into memory.\n     \"\"\"\n     # Load the model from its metadata\n-    with fileio.open(\n+    artifact_store = Client().active_stack.artifact_store\n+    with artifact_store.open(\n         os.path.join(model_uri, MODEL_METADATA_YAML_FILE_NAME), \"r\"\n     ) as f:\n         metadata = read_yaml(f.name)"
        },
        {
          "filename": "src/zenml/logging/step_logging.py",
          "status": "modified",
          "additions": 8,
          "deletions": 6,
          "patch": "@@ -23,7 +23,7 @@\n from uuid import uuid4\n \n from zenml.artifact_stores import BaseArtifactStore\n-from zenml.io import fileio\n+from zenml.client import Client\n from zenml.logger import get_logger\n from zenml.logging import (\n     STEP_LOGS_STORAGE_INTERVAL_SECONDS,\n@@ -64,6 +64,7 @@ def prepare_logs_uri(\n     Returns:\n         The URI of the logs file.\n     \"\"\"\n+    artifact_store = Client().active_stack.artifact_store\n     if log_key is None:\n         log_key = str(uuid4())\n \n@@ -74,16 +75,16 @@ def prepare_logs_uri(\n     )\n \n     # Create the dir\n-    if not fileio.exists(logs_base_uri):\n-        fileio.makedirs(logs_base_uri)\n+    if not artifact_store.exists(logs_base_uri):\n+        artifact_store.makedirs(logs_base_uri)\n \n     # Delete the file if it already exists\n     logs_uri = os.path.join(logs_base_uri, f\"{log_key}.log\")\n-    if fileio.exists(logs_uri):\n+    if artifact_store.exists(logs_uri):\n         logger.warning(\n             f\"Logs file {logs_uri} already exists! Removing old log file...\"\n         )\n-        fileio.remove(logs_uri)\n+        artifact_store.remove(logs_uri)\n     return logs_uri\n \n \n@@ -135,12 +136,13 @@ def write(self, text: str) -> None:\n \n     def save_to_file(self) -> None:\n         \"\"\"Method to save the buffer to the given URI.\"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         if not self.disabled:\n             try:\n                 self.disabled = True\n \n                 if self.buffer:\n-                    with fileio.open(self.logs_uri, \"a\") as file:\n+                    with artifact_store.open(self.logs_uri, \"a\") as file:\n                         for message in self.buffer:\n                             file.write(\n                                 remove_ansi_escape_codes(message) + \"\\n\""
        },
        {
          "filename": "src/zenml/materializers/base_materializer.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -156,8 +156,9 @@ def save_visualizations(self, data: Any) -> Dict[str, VisualizationType]:\n \n         Example:\n         ```\n+        artifact_store = Client().active_stack.artifact_store\n         visualization_uri = os.path.join(self.uri, \"visualization.html\")\n-        with fileio.open(visualization_uri, \"w\") as f:\n+        with artifact_store.open(visualization_uri, \"w\") as f:\n             f.write(\"<html><body>data</body></html>\")\n \n         visualization_uri_2 = os.path.join(self.uri, \"visualization.png\")"
        },
        {
          "filename": "src/zenml/materializers/built_in_materializer.py",
          "status": "modified",
          "additions": 15,
          "deletions": 11,
          "patch": "@@ -26,8 +26,8 @@\n     Union,\n )\n \n+from zenml.client import Client\n from zenml.enums import ArtifactType\n-from zenml.io import fileio\n from zenml.logger import get_logger\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.materializers.materializer_registry import materializer_registry\n@@ -135,7 +135,8 @@ def load(self, data_type: Type[Any]) -> Any:\n         Returns:\n             The data read.\n         \"\"\"\n-        with fileio.open(self.data_path, \"rb\") as file_:\n+        artifact_store = Client().active_stack.artifact_store\n+        with artifact_store.open(self.data_path, \"rb\") as file_:\n             return file_.read()\n \n     def save(self, data: Any) -> None:\n@@ -144,7 +145,8 @@ def save(self, data: Any) -> None:\n         Args:\n             data: The data to store.\n         \"\"\"\n-        with fileio.open(self.data_path, \"wb\") as file_:\n+        artifact_store = Client().active_stack.artifact_store\n+        with artifact_store.open(self.data_path, \"wb\") as file_:\n             file_.write(data)\n \n \n@@ -282,17 +284,18 @@ def load(self, data_type: Type[Any]) -> Any:\n         Raises:\n             RuntimeError: If the data was not found.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         # If the data was not serialized, there must be metadata present.\n-        if not fileio.exists(self.data_path) and not fileio.exists(\n-            self.metadata_path\n-        ):\n+        if not artifact_store.exists(\n+            self.data_path\n+        ) and not artifact_store.exists(self.metadata_path):\n             raise RuntimeError(\n                 f\"Materialization of type {data_type} failed. Expected either\"\n                 f\"{self.data_path} or {self.metadata_path} to exist.\"\n             )\n \n         # If the data was serialized as JSON, deserialize it.\n-        if fileio.exists(self.data_path):\n+        if artifact_store.exists(self.data_path):\n             outputs = yaml_utils.read_json(self.data_path)\n \n         # Otherwise, use the metadata to reconstruct the data as a list.\n@@ -355,6 +358,7 @@ def save(self, data: Any) -> None:\n         Raises:\n             Exception: If any exception occurs, it is raised after cleanup.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         # tuple and set: handle as list.\n         if isinstance(data, tuple) or isinstance(data, set):\n             data = list(data)\n@@ -375,7 +379,7 @@ def save(self, data: Any) -> None:\n         try:\n             for i, element in enumerate(data):\n                 element_path = os.path.join(self.uri, str(i))\n-                fileio.mkdir(element_path)\n+                artifact_store.mkdir(element_path)\n                 type_ = type(element)\n                 materializer_class = materializer_registry[type_]\n                 materializer = materializer_class(uri=element_path)\n@@ -398,11 +402,11 @@ def save(self, data: Any) -> None:\n         # If an error occurs, delete all created files.\n         except Exception as e:\n             # Delete metadata\n-            if fileio.exists(self.metadata_path):\n-                fileio.remove(self.metadata_path)\n+            if artifact_store.exists(self.metadata_path):\n+                artifact_store.remove(self.metadata_path)\n             # Delete all elements that were already saved.\n             for entry in metadata:\n-                fileio.rmtree(entry[\"path\"])\n+                artifact_store.rmtree(entry[\"path\"])\n             raise e\n \n     def extract_metadata(self, data: Any) -> Dict[str, \"MetadataType\"]:"
        },
        {
          "filename": "src/zenml/materializers/cloudpickle_materializer.py",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -18,9 +18,9 @@\n \n import cloudpickle\n \n+from zenml.client import Client\n from zenml.enums import ArtifactType\n from zenml.environment import Environment\n-from zenml.io import fileio\n from zenml.logger import get_logger\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.utils.io_utils import (\n@@ -59,6 +59,7 @@ def load(self, data_type: Type[Any]) -> Any:\n             The loaded artifact data.\n         \"\"\"\n         # validate python version\n+        artifact_store = Client().active_stack.artifact_store\n         source_python_version = self._load_python_version()\n         current_python_version = Environment().python_version()\n         if source_python_version != current_python_version:\n@@ -72,7 +73,7 @@ def load(self, data_type: Type[Any]) -> Any:\n \n         # load data\n         filepath = os.path.join(self.uri, DEFAULT_FILENAME)\n-        with fileio.open(filepath, \"rb\") as fid:\n+        with artifact_store.open(filepath, \"rb\") as fid:\n             data = cloudpickle.load(fid)\n         return data\n \n@@ -93,6 +94,7 @@ def save(self, data: Any) -> None:\n         Args:\n             data: The data to save.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         # Log a warning if this materializer was not explicitly specified for\n         # the given data type.\n         if type(self) == CloudpickleMaterializer:\n@@ -111,7 +113,7 @@ def save(self, data: Any) -> None:\n \n         # save data\n         filepath = os.path.join(self.uri, DEFAULT_FILENAME)\n-        with fileio.open(filepath, \"wb\") as fid:\n+        with artifact_store.open(filepath, \"wb\") as fid:\n             cloudpickle.dump(data, fid)\n \n     def _save_python_version(self) -> None:"
        },
        {
          "filename": "src/zenml/materializers/numpy_materializer.py",
          "status": "modified",
          "additions": 14,
          "deletions": 8,
          "patch": "@@ -19,8 +19,8 @@\n \n import numpy as np\n \n+from zenml.client import Client\n from zenml.enums import ArtifactType, VisualizationType\n-from zenml.io import fileio\n from zenml.logger import get_logger\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.metadata.metadata_types import DType, MetadataType\n@@ -57,12 +57,13 @@ def load(self, data_type: Type[Any]) -> \"Any\":\n         Returns:\n             The numpy array.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         numpy_file = os.path.join(self.uri, NUMPY_FILENAME)\n \n-        if fileio.exists(numpy_file):\n-            with fileio.open(numpy_file, \"rb\") as f:\n+        if artifact_store.exists(numpy_file):\n+            with artifact_store.open(numpy_file, \"rb\") as f:\n                 return np.load(f, allow_pickle=True)\n-        elif fileio.exists(os.path.join(self.uri, DATA_FILENAME)):\n+        elif artifact_store.exists(os.path.join(self.uri, DATA_FILENAME)):\n             logger.warning(\n                 \"A legacy artifact was found. \"\n                 \"This artifact was created with an older version of \"\n@@ -81,7 +82,7 @@ def load(self, data_type: Type[Any]) -> \"Any\":\n                     os.path.join(self.uri, SHAPE_FILENAME)\n                 )\n                 shape_tuple = tuple(shape_dict.values())\n-                with fileio.open(\n+                with artifact_store.open(\n                     os.path.join(self.uri, DATA_FILENAME), \"rb\"\n                 ) as f:\n                     input_stream = pa.input_stream(f)\n@@ -102,7 +103,10 @@ def save(self, arr: \"NDArray[Any]\") -> None:\n         Args:\n             arr: The numpy array to write.\n         \"\"\"\n-        with fileio.open(os.path.join(self.uri, NUMPY_FILENAME), \"wb\") as f:\n+        artifact_store = Client().active_stack.artifact_store\n+        with artifact_store.open(\n+            os.path.join(self.uri, NUMPY_FILENAME), \"wb\"\n+        ) as f:\n             np.save(f, arr)\n \n     def save_visualizations(\n@@ -155,8 +159,9 @@ def _save_histogram(self, output_path: str, arr: \"NDArray[Any]\") -> None:\n         \"\"\"\n         import matplotlib.pyplot as plt\n \n+        artifact_store = Client().active_stack.artifact_store\n         plt.hist(arr)\n-        with fileio.open(output_path, \"wb\") as f:\n+        with artifact_store.open(output_path, \"wb\") as f:\n             plt.savefig(f)\n         plt.close()\n \n@@ -169,7 +174,8 @@ def _save_image(self, output_path: str, arr: \"NDArray[Any]\") -> None:\n         \"\"\"\n         from matplotlib.image import imsave\n \n-        with fileio.open(output_path, \"wb\") as f:\n+        artifact_store = Client().active_stack.artifact_store\n+        with artifact_store.open(output_path, \"wb\") as f:\n             imsave(f, arr)\n \n     def extract_metadata("
        },
        {
          "filename": "src/zenml/materializers/pandas_materializer.py",
          "status": "modified",
          "additions": 10,
          "deletions": 7,
          "patch": "@@ -18,8 +18,8 @@\n \n import pandas as pd\n \n+from zenml.client import Client\n from zenml.enums import ArtifactType, VisualizationType\n-from zenml.io import fileio\n from zenml.logger import get_logger\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.metadata.metadata_types import DType, MetadataType\n@@ -77,9 +77,10 @@ def load(self, data_type: Type[Any]) -> Union[pd.DataFrame, pd.Series]:\n         Returns:\n             The pandas dataframe or series.\n         \"\"\"\n-        if fileio.exists(self.parquet_path):\n+        artifact_store = Client().active_stack.artifact_store\n+        if artifact_store.exists(self.parquet_path):\n             if self.pyarrow_exists:\n-                with fileio.open(self.parquet_path, mode=\"rb\") as f:\n+                with artifact_store.open(self.parquet_path, mode=\"rb\") as f:\n                     df = pd.read_parquet(f)\n             else:\n                 raise ImportError(\n@@ -90,7 +91,7 @@ def load(self, data_type: Type[Any]) -> Union[pd.DataFrame, pd.Series]:\n                     \"'`pip install pyarrow fastparquet`'.\"\n                 )\n         else:\n-            with fileio.open(self.csv_path, mode=\"rb\") as f:\n+            with artifact_store.open(self.csv_path, mode=\"rb\") as f:\n                 df = pd.read_csv(f, index_col=0, parse_dates=True)\n \n         # validate the type of the data.\n@@ -122,14 +123,15 @@ def save(self, df: Union[pd.DataFrame, pd.Series]) -> None:\n         Args:\n             df: The pandas dataframe or series to write.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         if isinstance(df, pd.Series):\n             df = df.to_frame(name=\"series\")\n \n         if self.pyarrow_exists:\n-            with fileio.open(self.parquet_path, mode=\"wb\") as f:\n+            with artifact_store.open(self.parquet_path, mode=\"wb\") as f:\n                 df.to_parquet(f, compression=COMPRESSION_TYPE)\n         else:\n-            with fileio.open(self.csv_path, mode=\"wb\") as f:\n+            with artifact_store.open(self.csv_path, mode=\"wb\") as f:\n                 df.to_csv(f, index=True)\n \n     def save_visualizations(\n@@ -143,9 +145,10 @@ def save_visualizations(\n         Returns:\n             A dictionary of visualization URIs and their types.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         describe_uri = os.path.join(self.uri, \"describe.csv\")\n         describe_uri = describe_uri.replace(\"\\\\\", \"/\")\n-        with fileio.open(describe_uri, mode=\"wb\") as f:\n+        with artifact_store.open(describe_uri, mode=\"wb\") as f:\n             df.describe().to_csv(f)\n         return {describe_uri: VisualizationType.CSV}\n "
        },
        {
          "filename": "src/zenml/materializers/service_materializer.py",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -16,8 +16,8 @@\n import os\n from typing import TYPE_CHECKING, Any, ClassVar, Dict, Tuple, Type\n \n+from zenml.client import Client\n from zenml.enums import ArtifactType\n-from zenml.io import fileio\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.services.service import BaseService\n from zenml.services.service_registry import ServiceRegistry\n@@ -46,8 +46,9 @@ def load(self, data_type: Type[Any]) -> BaseService:\n         Returns:\n             A ZenML service instance.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         filepath = os.path.join(self.uri, SERVICE_CONFIG_FILENAME)\n-        with fileio.open(filepath, \"r\") as f:\n+        with artifact_store.open(filepath, \"r\") as f:\n             service = ServiceRegistry().load_service_from_json(f.read())\n         return service\n \n@@ -60,8 +61,9 @@ def save(self, service: BaseService) -> None:\n         Args:\n             service: A ZenML service instance.\n         \"\"\"\n+        artifact_store = Client().active_stack.artifact_store\n         filepath = os.path.join(self.uri, SERVICE_CONFIG_FILENAME)\n-        with fileio.open(filepath, \"w\") as f:\n+        with artifact_store.open(filepath, \"w\") as f:\n             f.write(service.json(indent=4))\n \n     def extract_metadata("
        },
        {
          "filename": "src/zenml/materializers/structured_string_materializer.py",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -16,8 +16,8 @@\n import os\n from typing import Dict, Type, Union\n \n+from zenml.client import Client\n from zenml.enums import ArtifactType, VisualizationType\n-from zenml.io import fileio\n from zenml.logger import get_logger\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.types import CSVString, HTMLString, MarkdownString\n@@ -47,7 +47,8 @@ def load(self, data_type: Type[STRUCTURED_STRINGS]) -> STRUCTURED_STRINGS:\n         Returns:\n             The loaded data.\n         \"\"\"\n-        with fileio.open(self._get_filepath(data_type), \"r\") as f:\n+        artifact_store = Client().active_stack.artifact_store\n+        with artifact_store.open(self._get_filepath(data_type), \"r\") as f:\n             return data_type(f.read())\n \n     def save(self, data: STRUCTURED_STRINGS) -> None:\n@@ -56,7 +57,8 @@ def save(self, data: STRUCTURED_STRINGS) -> None:\n         Args:\n             data: The data to save as an HTML or Markdown file.\n         \"\"\"\n-        with fileio.open(self._get_filepath(type(data)), \"w\") as f:\n+        artifact_store = Client().active_stack.artifact_store\n+        with artifact_store.open(self._get_filepath(type(data)), \"w\") as f:\n             f.write(data)\n \n     def save_visualizations("
        },
        {
          "filename": "src/zenml/orchestrators/output_utils.py",
          "status": "modified",
          "additions": 7,
          "deletions": 5,
          "patch": "@@ -17,7 +17,7 @@\n from typing import TYPE_CHECKING, Dict, Sequence\n from uuid import uuid4\n \n-from zenml.io import fileio\n+from zenml.client import Client\n from zenml.logger import get_logger\n \n if TYPE_CHECKING:\n@@ -72,16 +72,17 @@ def prepare_output_artifact_uris(\n     Returns:\n         A dictionary mapping output names to artifact URIs.\n     \"\"\"\n+    artifact_store = stack.artifact_store\n     output_artifact_uris: Dict[str, str] = {}\n     for output_name in step.config.outputs.keys():\n         artifact_uri = generate_artifact_uri(\n             artifact_store=stack.artifact_store,\n             step_run=step_run,\n             output_name=output_name,\n         )\n-        if fileio.exists(artifact_uri):\n+        if artifact_store.exists(artifact_uri):\n             raise RuntimeError(\"Artifact already exists\")\n-        fileio.makedirs(artifact_uri)\n+        artifact_store.makedirs(artifact_uri)\n         output_artifact_uris[output_name] = artifact_uri\n     return output_artifact_uris\n \n@@ -92,6 +93,7 @@ def remove_artifact_dirs(artifact_uris: Sequence[str]) -> None:\n     Args:\n         artifact_uris: URIs of the artifacts to remove the directories for.\n     \"\"\"\n+    artifact_store = Client().active_stack.artifact_store\n     for artifact_uri in artifact_uris:\n-        if fileio.isdir(artifact_uri):\n-            fileio.rmtree(artifact_uri)\n+        if artifact_store.isdir(artifact_uri):\n+            artifact_store.rmtree(artifact_uri)"
        },
        {
          "filename": "tests/integration/functional/artifacts/test_base_artifact_store.py",
          "status": "added",
          "additions": 65,
          "deletions": 0,
          "patch": "@@ -0,0 +1,65 @@\n+#  Copyright (c) ZenML GmbH 2024. All Rights Reserved.\n+#\n+#  Licensed under the Apache License, Version 2.0 (the \"License\");\n+#  you may not use this file except in compliance with the License.\n+#  You may obtain a copy of the License at:\n+#\n+#       https://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+#  or implied. See the License for the specific language governing\n+#  permissions and limitations under the License.\n+\n+import os\n+from pathlib import Path\n+\n+import pytest\n+\n+from zenml.client import Client\n+\n+\n+def test_files_outside_of_artifact_store_are_not_reachable_by_it(\n+    clean_client: \"Client\",\n+):\n+    \"\"\"Tests that no operations outside of bounds of artifact store could happen.\"\"\"\n+    a_s = clean_client.active_stack.artifact_store\n+\n+    outside_dir = Path(a_s.path) / \"..\"\n+    outside_file = str(outside_dir / \"tmp.file\")\n+    try:\n+        # create a file outside of artifact store\n+        with open(outside_file, \"w\") as f:\n+            f.write(\"test\")\n+        # try to open it via artifact store interface\n+        with pytest.raises(FileNotFoundError):\n+            a_s.open(outside_file, \"r\")\n+        # try to copy it via artifact store interface\n+        with pytest.raises(FileNotFoundError):\n+            a_s.copyfile(outside_file, \".\", \"r\")\n+    except Exception as e:\n+        raise e\n+    finally:\n+        os.remove(outside_file)\n+\n+    inside_file = str(Path(a_s.path) / \"tmp.file\")\n+    try:\n+        # create a file inside of artifact store\n+        with open(inside_file, \"w\") as f:\n+            f.write(\"test\")\n+        # try to open it via artifact store interface\n+        assert a_s.open(inside_file, \"r\").read() == \"test\"\n+        # try to copy it via artifact store interface\n+        inside_file2 = str(Path(a_s.path) / \"tmp2.file\")\n+        a_s.copyfile(inside_file, inside_file2, \"r\")\n+        # try to open it via artifact store interface\n+        assert open(inside_file2, \"r\").read() == \"test\"\n+        # try to copy it via artifact store interface, but with target outside of bounds\n+        with pytest.raises(FileNotFoundError):\n+            a_s.copyfile(inside_file, \".\", \"r\")\n+    except Exception as e:\n+        raise e\n+    finally:\n+        os.remove(inside_file)\n+        os.remove(inside_file2)"
        },
        {
          "filename": "tests/integration/functional/artifacts/test_utils.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -262,7 +262,7 @@ def artifact_metadata_logging_pipeline():\n \n \n def test_download_artifact_files_from_response(\n-    tmp_path, clean_client_with_run\n+    tmp_path, clean_client_with_run: \"Client\"\n ):\n     \"\"\"Test that we can download artifact files from an artifact version.\"\"\"\n     artifact: ArtifactResponse = clean_client_with_run.get_artifact("
        },
        {
          "filename": "tests/unit/artifacts/test_utils.py",
          "status": "modified",
          "additions": 9,
          "deletions": 4,
          "patch": "@@ -26,6 +26,7 @@\n     load_model_from_metadata,\n     save_model_metadata,\n )\n+from zenml.client import Client\n from zenml.constants import MODEL_METADATA_YAML_FILE_NAME\n from zenml.materializers.numpy_materializer import NUMPY_FILENAME\n from zenml.models import ArtifactVersionResponse, Page\n@@ -65,12 +66,14 @@ def test_save_model_metadata(model_artifact):\n \n \n @pytest.fixture\n-def model_metadata_dir(model_artifact):\n+def model_metadata_dir(model_artifact, clean_client: \"Client\"):\n     # Save the model metadata to a temporary file\n     file_path = save_model_metadata(model_artifact)\n \n     # Move the file to a temporary directory\n-    temp_dir = tempfile.mkdtemp()\n+    temp_dir = tempfile.mkdtemp(\n+        dir=clean_client.active_stack.artifact_store.path\n+    )\n     shutil.move(\n         file_path, os.path.join(temp_dir, MODEL_METADATA_YAML_FILE_NAME)\n     )\n@@ -119,9 +122,11 @@ def test_load_artifact_from_response(mocker, model_artifact):\n \n \n @pytest.fixture\n-def numpy_file_uri():\n+def numpy_file_uri(clean_client: \"Client\"):\n     # Create a temporary file to save the numpy array\n-    temp_dir = tempfile.mkdtemp()\n+    temp_dir = tempfile.mkdtemp(\n+        dir=clean_client.active_stack.artifact_store.path\n+    )\n     numpy_file = os.path.join(temp_dir, NUMPY_FILENAME)\n \n     # Save a numpy array to the temporary file"
        },
        {
          "filename": "tests/unit/materializers/test_built_in_materializer.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -16,6 +16,7 @@\n from typing import Optional, Type\n \n from tests.unit.test_general import _test_materializer\n+from zenml.client import Client\n from zenml.materializers.base_materializer import BaseMaterializer\n from zenml.materializers.built_in_materializer import (\n     BuiltInContainerMaterializer,\n@@ -190,7 +191,9 @@ def load(self, data_type: Type[CustomType]) -> Optional[CustomType]:\n         return data_type()\n \n \n-def test_container_materializer_for_custom_types(mocker):\n+def test_container_materializer_for_custom_types(\n+    mocker, clean_client: \"Client\"\n+):\n     \"\"\"Test container materializer for custom types.\n \n     This ensures that:\n@@ -202,7 +205,9 @@ def test_container_materializer_for_custom_types(mocker):\n     from zenml.materializers.materializer_registry import materializer_registry\n \n     example = [CustomType(), CustomSubType()]\n-    with TemporaryDirectory() as artifact_uri:\n+    with TemporaryDirectory(\n+        dir=clean_client.active_stack.artifact_store.path\n+    ) as artifact_uri:\n         materializer = BuiltInContainerMaterializer(uri=artifact_uri)\n \n         # Container materializer should find materializer for both elements in"
        },
        {
          "filename": "tests/unit/materializers/test_cloudpickle_materializer.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -60,7 +60,9 @@ def test_cloudpickle_materializer_is_not_registered(clean_client):\n def test_cloudpickle_materializer_can_load_pickle(clean_client):\n     \"\"\"Test that the cloudpickle materializer can load regular pickle.\"\"\"\n     my_object = Unmaterializable()\n-    with TemporaryDirectory() as artifact_uri:\n+    with TemporaryDirectory(\n+        dir=clean_client.active_stack.artifact_store.path\n+    ) as artifact_uri:\n         artifact_filepath = os.path.join(artifact_uri, DEFAULT_FILENAME)\n         with open(artifact_filepath, \"wb\") as f:\n             pickle.dump(my_object, f)"
        },
        {
          "filename": "tests/unit/test_general.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -16,6 +16,7 @@\n from tempfile import TemporaryDirectory\n from typing import Any, Callable, Optional, Type\n \n+from zenml.client import Client\n from zenml.constants import ENV_ZENML_DEBUG\n from zenml.enums import VisualizationType\n from zenml.materializers.base_materializer import BaseMaterializer\n@@ -76,7 +77,8 @@ def _test_materializer(\n     if materializer_class is None:\n         materializer_class = materializer_registry[step_output_type]\n \n-    with TemporaryDirectory() as artifact_uri:\n+    artifact_store_uri = Client().active_stack.artifact_store.path\n+    with TemporaryDirectory(dir=artifact_store_uri) as artifact_uri:\n         materializer = materializer_class(uri=artifact_uri)\n         existing_files = os.listdir(artifact_uri)\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 6,
        "unique_directories": 9,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "59ebe58a931b01e362a410fdd31897c93757ad94",
            "date": "2025-01-13T16:44:34Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "91a8513e69fbd44cd7de630fca8d2a6954120714",
            "date": "2025-01-13T14:46:13Z",
            "author_login": "schustmi"
          },
          {
            "sha": "ef3bc8be215d2f59f002f89b779665fa0702a591",
            "date": "2025-01-10T13:25:37Z",
            "author_login": "schustmi"
          },
          {
            "sha": "80f2ed2c38a8ccadb77ef2d3638f08e321f2dc43",
            "date": "2025-01-10T08:11:58Z",
            "author_login": "htahir1"
          },
          {
            "sha": "c2fe19eb039c133a53ba68730251209a84876285",
            "date": "2025-01-09T10:43:55Z",
            "author_login": "bcdurak"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-29",
    "description": "A directory traversal vulnerability exists in the zenml-io/zenml repository, specifically within the /api/v1/steps endpoint. Attackers can exploit this vulnerability by manipulating the 'logs' URI path in the request to fetch arbitrary file content, bypassing intended access restrictions. The vulnerability arises due to the lack of validation for directory traversal patterns, allowing attackers to access files outside of the restricted directory.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-04-16T00:15:11.057",
    "last_modified": "2024-11-21T09:09:00.493",
    "fix_date": "2024-03-05T08:02:33Z"
  },
  "references": [
    {
      "url": "https://github.com/zenml-io/zenml/commit/00e934f33a243a554f5f65b80eefd5ea5117367b",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/f24b2216-6a4b-42a1-becb-9b47e6cf117f",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/zenml-io/zenml/commit/00e934f33a243a554f5f65b80eefd5ea5117367b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/f24b2216-6a4b-42a1-becb-9b47e6cf117f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.491941",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zenml",
    "owner": "zenml-io",
    "created_at": "2020-11-19T09:25:46Z",
    "updated_at": "2025-01-14T12:18:07Z",
    "pushed_at": "2025-01-14T11:42:49Z",
    "size": 561721,
    "stars": 4313,
    "forks": 466,
    "open_issues": 38,
    "watchers": 4313,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 9297441,
      "Shell": 45611,
      "Smarty": 20620,
      "Dockerfile": 19050,
      "Jinja": 4977,
      "HTML": 2568,
      "Mako": 695
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:05:19.405915"
  }
}