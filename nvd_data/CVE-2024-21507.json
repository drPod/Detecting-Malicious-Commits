{
  "cve_id": "CVE-2024-21507",
  "github_data": {
    "repository": "sidorares/node-mysql2",
    "fix_commit": "0d54b0ca6498c823098426038162ef10df02c818",
    "related_commits": [
      "0d54b0ca6498c823098426038162ef10df02c818",
      "0d54b0ca6498c823098426038162ef10df02c818"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "0d54b0ca6498c823098426038162ef10df02c818",
      "commit_date": "2024-03-26T05:40:26Z",
      "author": {
        "login": "wellwelwel",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix(cache): improve cache key serialization (#2424)",
        "length": 208,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 533,
        "additions": 518,
        "deletions": 15
      },
      "files": [
        {
          "filename": "lib/parsers/parser_cache.js",
          "status": "modified",
          "additions": 28,
          "deletions": 15,
          "patch": "@@ -3,26 +3,38 @@\n const LRU = require('lru-cache').default;\n \n const parserCache = new LRU({\n-  max: 15000\n+  max: 15000,\n });\n \n function keyFromFields(type, fields, options, config) {\n-  let res =\n-    `${type}` +\n-    `/${typeof options.nestTables}` +\n-    `/${options.nestTables}` +\n-    `/${options.rowsAsArray}` +\n-    `/${options.supportBigNumbers || config.supportBigNumbers}` +\n-    `/${options.bigNumberStrings || config.bigNumberStrings}` +\n-    `/${typeof options.typeCast}` +\n-    `/${options.timezone || config.timezone}` +\n-    `/${options.decimalNumbers}` +\n-    `/${options.dateStrings}`;\n+  const res = [\n+    type,\n+    typeof options.nestTables,\n+    options.nestTables,\n+    Boolean(options.rowsAsArray),\n+    Boolean(options.supportBigNumbers || config.supportBigNumbers),\n+    Boolean(options.bigNumberStrings || config.bigNumberStrings),\n+    typeof options.typeCast,\n+    options.timezone || config.timezone,\n+    Boolean(options.decimalNumbers),\n+    options.dateStrings,\n+  ];\n+\n   for (let i = 0; i < fields.length; ++i) {\n     const field = fields[i];\n-    res += `/${field.name}:${field.columnType}:${field.length}:${field.schema}:${field.table}:${field.flags}:${field.characterSet}`;\n+\n+    res.push([\n+      field.name,\n+      field.columnType,\n+      field.length,\n+      field.schema,\n+      field.table,\n+      field.flags,\n+      field.characterSet,\n+    ]);\n   }\n-  return res;\n+\n+  return JSON.stringify(res, null, 0);\n }\n \n function getParser(type, fields, options, config, compiler) {\n@@ -49,5 +61,6 @@ function clearCache() {\n module.exports = {\n   getParser: getParser,\n   setMaxCache: setMaxCache,\n-  clearCache: clearCache\n+  clearCache: clearCache,\n+  _keyFromFields: keyFromFields,\n };"
        },
        {
          "filename": "test/unit/parsers/cache-key-serialization.js",
          "status": "added",
          "additions": 490,
          "deletions": 0,
          "patch": "@@ -0,0 +1,490 @@\n+'use strict';\n+\n+const assert = require('assert');\n+const _keyFromFields =\n+  require('../../../lib/parsers/parser_cache.js')._keyFromFields;\n+\n+// Invalid\n+const test1 = {\n+  type: undefined,\n+  fields: [\n+    {\n+      name: undefined,\n+      columnType: undefined,\n+      length: undefined,\n+      schema: undefined,\n+      table: undefined,\n+      flags: undefined,\n+      characterSet: undefined,\n+    },\n+  ],\n+  options: {\n+    nestTables: undefined,\n+    rowsAsArray: undefined,\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    typeCast: undefined,\n+    timezone: undefined,\n+    decimalNumbers: undefined,\n+    dateStrings: undefined,\n+  },\n+  config: {\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    timezone: undefined,\n+  },\n+};\n+\n+// Invalid, except for `config` (global overwriting)\n+const test2 = {\n+  type: undefined,\n+  fields: [\n+    {\n+      name: undefined,\n+      columnType: undefined,\n+      length: undefined,\n+      schema: undefined,\n+      table: undefined,\n+      flags: undefined,\n+      characterSet: undefined,\n+    },\n+  ],\n+  options: {\n+    nestTables: undefined,\n+    rowsAsArray: undefined,\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    typeCast: undefined,\n+    timezone: undefined,\n+    decimalNumbers: undefined,\n+    dateStrings: undefined,\n+  },\n+  config: {\n+    supportBigNumbers: false,\n+    bigNumberStrings: false,\n+    timezone: 'local',\n+  },\n+};\n+\n+// Invalid, except for options\n+const test3 = {\n+  type: undefined,\n+  fields: [\n+    {\n+      name: undefined,\n+      columnType: undefined,\n+      length: undefined,\n+      schema: undefined,\n+      table: undefined,\n+      flags: undefined,\n+      characterSet: undefined,\n+    },\n+  ],\n+  options: {\n+    nestTables: '',\n+    rowsAsArray: false,\n+    supportBigNumbers: false,\n+    bigNumberStrings: false,\n+    typeCast: true,\n+    timezone: 'local',\n+    decimalNumbers: false,\n+    dateStrings: false,\n+  },\n+  config: {\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    timezone: undefined,\n+  },\n+};\n+\n+// Based on results of `SELECT * FROM test WHERE value = ?`\n+const test4 = {\n+  type: 'binary',\n+  fields: [\n+    {\n+      name: 'id',\n+      columnType: '3',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '16899',\n+      characterSet: '63',\n+    },\n+    {\n+      name: 'value',\n+      columnType: '246',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '0',\n+      characterSet: '63',\n+    },\n+  ],\n+  options: {\n+    nestTables: false,\n+    rowsAsArray: false,\n+    supportBigNumbers: false,\n+    bigNumberStrings: false,\n+    typeCast: true,\n+    timezone: 'local',\n+    decimalNumbers: false,\n+    dateStrings: 'DATETIME',\n+  },\n+  config: {\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    timezone: undefined,\n+  },\n+};\n+\n+// Same from test4, but with invalid booleans need to reach out the same key\n+const test5 = {\n+  type: 'binary',\n+  fields: [\n+    {\n+      name: 'id',\n+      columnType: '3',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '16899',\n+      characterSet: '63',\n+    },\n+    {\n+      name: 'value',\n+      columnType: '246',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '0',\n+      characterSet: '63',\n+    },\n+  ],\n+  options: {\n+    nestTables: false,\n+    rowsAsArray: undefined,\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    typeCast: true,\n+    timezone: 'local',\n+    decimalNumbers: undefined,\n+    dateStrings: 'DATETIME',\n+  },\n+  config: {\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    timezone: undefined,\n+  },\n+};\n+\n+// Forcing delimiters on strings fields\n+// Checking for quotes escape\n+const test6 = {\n+  type: 'binary',\n+  fields: [\n+    {\n+      name: ':',\n+      columnType: '\u00a9',\n+      length: undefined,\n+      schema: '/',\n+      table: ',',\n+      flags: '_',\n+      characterSet: '\u274c',\n+    },\n+  ],\n+  options: {\n+    nestTables: false,\n+    rowsAsArray: true,\n+    supportBigNumbers: true,\n+    bigNumberStrings: true,\n+    typeCast: true,\n+    timezone: '\"\"`\\'',\n+    decimalNumbers: true,\n+    dateStrings: '#',\n+  },\n+  config: {\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    timezone: undefined,\n+  },\n+};\n+\n+// valid with `true` on booleans\n+const test7 = {\n+  type: 'binary',\n+  fields: [\n+    {\n+      name: 'id',\n+      columnType: '3',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '16899',\n+      characterSet: '63',\n+    },\n+    {\n+      name: 'value',\n+      columnType: '246',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '0',\n+      characterSet: '63',\n+    },\n+  ],\n+  options: {\n+    nestTables: true,\n+    rowsAsArray: true,\n+    supportBigNumbers: true,\n+    bigNumberStrings: true,\n+    typeCast: true,\n+    timezone: 'local',\n+    decimalNumbers: true,\n+    dateStrings: 'DATETIME',\n+  },\n+  config: {\n+    supportBigNumbers: true,\n+    bigNumberStrings: true,\n+    timezone: true,\n+  },\n+};\n+\n+// Expects the same result from test7, but using valid values instead of `true` on booleans fields\n+const test8 = {\n+  type: 'binary',\n+  fields: [\n+    {\n+      name: 'id',\n+      columnType: '3',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '16899',\n+      characterSet: '63',\n+    },\n+    {\n+      name: 'value',\n+      columnType: '246',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '0',\n+      characterSet: '63',\n+    },\n+  ],\n+  options: {\n+    nestTables: true,\n+    rowsAsArray: 2,\n+    supportBigNumbers: 'yes',\n+    bigNumberStrings: [],\n+    typeCast: true,\n+    timezone: 'local',\n+    decimalNumbers: {\n+      a: null,\n+    },\n+    dateStrings: 'DATETIME',\n+  },\n+  config: {\n+    supportBigNumbers: true,\n+    bigNumberStrings: true,\n+    timezone: true,\n+  },\n+};\n+\n+// Invalid: checking function parser in wrong fields, expecting to be `null`\n+const test9 = {\n+  type: 'binary',\n+  fields: [\n+    {\n+      name: 'id',\n+      columnType: '3',\n+      length: undefined,\n+      schema: 'test',\n+      table: 'test',\n+      flags: '16899',\n+      characterSet: '63',\n+    },\n+  ],\n+  options: {\n+    nestTables: false,\n+    rowsAsArray: false,\n+    supportBigNumbers: false,\n+    // Expected: true\n+    bigNumberStrings: (_, next) => next(),\n+    // Expected: \"function\"\n+    typeCast: (_, next) => next(),\n+    timezone: 'local',\n+    decimalNumbers: false,\n+    // Expected: null\n+    dateStrings: (_, next) => next(),\n+  },\n+  config: {\n+    supportBigNumbers: undefined,\n+    bigNumberStrings: undefined,\n+    timezone: undefined,\n+  },\n+};\n+\n+const result1 = _keyFromFields(\n+  test1.type,\n+  test1.fields,\n+  test1.options,\n+  test1.config,\n+);\n+const result2 = _keyFromFields(\n+  test2.type,\n+  test2.fields,\n+  test2.options,\n+  test2.config,\n+);\n+const result3 = _keyFromFields(\n+  test3.type,\n+  test3.fields,\n+  test3.options,\n+  test3.config,\n+);\n+const result4 = _keyFromFields(\n+  test4.type,\n+  test4.fields,\n+  test4.options,\n+  test4.config,\n+);\n+const result5 = _keyFromFields(\n+  test5.type,\n+  test5.fields,\n+  test5.options,\n+  test5.config,\n+);\n+const result6 = _keyFromFields(\n+  test6.type,\n+  test6.fields,\n+  test6.options,\n+  test6.config,\n+);\n+const result7 = _keyFromFields(\n+  test7.type,\n+  test7.fields,\n+  test7.options,\n+  test7.config,\n+);\n+const result8 = _keyFromFields(\n+  test8.type,\n+  test8.fields,\n+  test8.options,\n+  test8.config,\n+);\n+const result9 = _keyFromFields(\n+  test9.type,\n+  test9.fields,\n+  test9.options,\n+  test9.config,\n+);\n+\n+assert.deepStrictEqual(\n+  result1,\n+  '[null,\"undefined\",null,false,false,false,\"undefined\",null,false,null,[null,null,null,null,null,null,null]]',\n+);\n+assert(JSON.parse(result1));\n+\n+assert.deepStrictEqual(\n+  result2,\n+  '[null,\"undefined\",null,false,false,false,\"undefined\",\"local\",false,null,[null,null,null,null,null,null,null]]',\n+);\n+assert(JSON.parse(result2));\n+\n+assert.deepStrictEqual(\n+  result3,\n+  '[null,\"string\",\"\",false,false,false,\"boolean\",\"local\",false,false,[null,null,null,null,null,null,null]]',\n+);\n+assert(JSON.parse(result3));\n+\n+assert.deepStrictEqual(\n+  result4,\n+  '[\"binary\",\"boolean\",false,false,false,false,\"boolean\",\"local\",false,\"DATETIME\",[\"id\",\"3\",null,\"test\",\"test\",\"16899\",\"63\"],[\"value\",\"246\",null,\"test\",\"test\",\"0\",\"63\"]]',\n+);\n+assert(JSON.parse(result4));\n+\n+assert.deepStrictEqual(result4, result5);\n+assert(JSON.parse(result5));\n+\n+assert.deepStrictEqual(\n+  result6,\n+  '[\"binary\",\"boolean\",false,true,true,true,\"boolean\",\"\\\\\"\\\\\"`\\'\",true,\"#\",[\":\",\"\u00a9\",null,\"/\",\",\",\"_\",\"\u274c\"]]',\n+);\n+// Ensuring that JSON is valid with invalid delimiters\n+assert(JSON.parse(result6));\n+\n+assert.deepStrictEqual(\n+  result7,\n+  '[\"binary\",\"boolean\",true,true,true,true,\"boolean\",\"local\",true,\"DATETIME\",[\"id\",\"3\",null,\"test\",\"test\",\"16899\",\"63\"],[\"value\",\"246\",null,\"test\",\"test\",\"0\",\"63\"]]',\n+);\n+assert(JSON.parse(result7));\n+\n+assert.deepStrictEqual(result7, result8);\n+assert(JSON.parse(result8));\n+\n+assert.deepStrictEqual(\n+  result9,\n+  '[\"binary\",\"boolean\",false,false,false,true,\"function\",\"local\",false,null,[\"id\",\"3\",null,\"test\",\"test\",\"16899\",\"63\"]]',\n+);\n+assert(JSON.parse(result9));\n+assert(JSON.parse(result9)[5] === true);\n+assert(JSON.parse(result9)[6] === 'function');\n+assert(JSON.parse(result9)[9] === null);\n+\n+// Testing twice all existent tests needs to return 7 keys, since two of them expects to be the same\n+assert(\n+  Array.from(\n+    new Set([\n+      _keyFromFields(test1.type, test1.fields, test1.options, test1.config),\n+      _keyFromFields(test1.type, test1.fields, test1.options, test1.config),\n+      _keyFromFields(test2.type, test2.fields, test2.options, test2.config),\n+      _keyFromFields(test2.type, test2.fields, test2.options, test2.config),\n+      _keyFromFields(test3.type, test3.fields, test3.options, test3.config),\n+      _keyFromFields(test3.type, test3.fields, test3.options, test3.config),\n+      _keyFromFields(test4.type, test4.fields, test4.options, test4.config),\n+      _keyFromFields(test4.type, test4.fields, test4.options, test4.config),\n+      _keyFromFields(test5.type, test5.fields, test5.options, test5.config),\n+      _keyFromFields(test5.type, test5.fields, test5.options, test5.config),\n+      _keyFromFields(test6.type, test6.fields, test6.options, test6.config),\n+      _keyFromFields(test6.type, test6.fields, test6.options, test6.config),\n+      _keyFromFields(test7.type, test7.fields, test7.options, test7.config),\n+      _keyFromFields(test7.type, test7.fields, test7.options, test7.config),\n+      _keyFromFields(test8.type, test8.fields, test8.options, test8.config),\n+      _keyFromFields(test8.type, test8.fields, test8.options, test8.config),\n+      _keyFromFields(test9.type, test9.fields, test9.options, test9.config),\n+      _keyFromFields(test9.type, test9.fields, test9.options, test9.config),\n+    ]),\n+  ).length === 7,\n+);\n+\n+const stringify = JSON.stringify;\n+\n+// Overwriting the native `JSON.stringify`\n+JSON.stringify = (value, replacer, space = 8) => stringify(value, replacer, space);\n+\n+// Testing twice all existent tests needs to return 7 keys, since two of them expects to be the same\n+assert(\n+  Array.from(\n+    new Set([\n+      result1,\n+      _keyFromFields(test1.type, test1.fields, test1.options, test1.config),\n+      result2,\n+      _keyFromFields(test2.type, test2.fields, test2.options, test2.config),\n+      result3,\n+      _keyFromFields(test3.type, test3.fields, test3.options, test3.config),\n+      result4,\n+      _keyFromFields(test4.type, test4.fields, test4.options, test4.config),\n+      result5,\n+      _keyFromFields(test5.type, test5.fields, test5.options, test5.config),\n+      result6,\n+      _keyFromFields(test6.type, test6.fields, test6.options, test6.config),\n+      result7,\n+      _keyFromFields(test7.type, test7.fields, test7.options, test7.config),\n+      result8,\n+      _keyFromFields(test8.type, test8.fields, test8.options, test8.config),\n+      result9,\n+      _keyFromFields(test9.type, test9.fields, test9.options, test9.config),\n+    ]),\n+  ).length === 7,\n+);"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b97f476d883d993cddc83213150d16cf3907e60e",
            "date": "2025-01-25T00:52:02Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "f48a2cd3d0b2fa7b8aeea3164024ecb917e7fab3",
            "date": "2025-01-25T00:44:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "8957e3a5312de867b977aeee95c395513383e9c2",
            "date": "2025-01-24T21:01:23Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "2e8e286c4783955758cf68ffa898962fc6081671",
            "date": "2025-01-23T22:38:58Z",
            "author_login": "wellwelwel"
          },
          {
            "sha": "78b16621e77c03d9c7ef1010e95f0156a75b3c5f",
            "date": "2025-01-23T21:00:13Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L",
    "cwe_id": "CWE-20",
    "description": "Versions of the package mysql2 before 3.9.3 are vulnerable to Improper Input Validation through the keyFromFields function, resulting in cache poisoning. An attacker can inject a colon (:) character within a value of the attacker-crafted key.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-10T05:15:48.290",
    "last_modified": "2024-11-21T08:54:34.667",
    "fix_date": "2024-03-26T05:40:26Z"
  },
  "references": [
    {
      "url": "https://blog.slonser.info/posts/mysql2-attacker-configuration/",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/sidorares/node-mysql2/commit/0d54b0ca6498c823098426038162ef10df02c818",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/sidorares/node-mysql2/pull/2424",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-JS-MYSQL2-6591300",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://blog.slonser.info/posts/mysql2-attacker-configuration/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/sidorares/node-mysql2/commit/0d54b0ca6498c823098426038162ef10df02c818",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/sidorares/node-mysql2/pull/2424",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-JS-MYSQL2-6591300",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.462377",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "node-mysql2",
    "owner": "sidorares",
    "created_at": "2013-04-17T05:23:59Z",
    "updated_at": "2025-01-25T16:31:49Z",
    "pushed_at": "2025-01-25T00:54:19Z",
    "size": 112328,
    "stars": 4138,
    "forks": 627,
    "open_issues": 486,
    "watchers": 4138,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 772914,
      "TypeScript": 56469,
      "Shell": 123,
      "HTML": 43
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:22:35.378615"
  }
}