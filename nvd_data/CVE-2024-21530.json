{
  "cve_id": "CVE-2024-21530",
  "github_data": {
    "repository": "fadeevab/cocoon",
    "fix_commit": "1b6392173ce35db4736a94b62b2d2973f9a71441",
    "related_commits": [
      "1b6392173ce35db4736a94b62b2d2973f9a71441"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "1b6392173ce35db4736a94b62b2d2973f9a71441",
      "commit_date": "2023-10-17T12:50:14Z",
      "author": {
        "login": "ProjectInitiative",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Support sequential calls of encryption API (#23)",
        "length": 412,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 181,
        "additions": 110,
        "deletions": 71
      },
      "files": [
        {
          "filename": "src/lib.rs",
          "status": "modified",
          "additions": 64,
          "deletions": 45,
          "patch": "@@ -43,7 +43,7 @@\n //! # use cocoon::{MiniCocoon, Error};\n //! #\n //! # fn main() -> Result<(), Error> {\n-//! let cocoon = MiniCocoon::from_key(b\"0123456789abcdef0123456789abcdef\", &[0; 32]);\n+//! let mut cocoon = MiniCocoon::from_key(b\"0123456789abcdef0123456789abcdef\", &[0; 32]);\n //!\n //! let wrapped = cocoon.wrap(b\"my secret data\")?;\n //! assert_ne!(&wrapped, b\"my secret data\");\n@@ -69,8 +69,8 @@\n //! #\n //! # fn main() -> Result<(), Error> {\n //! let mut data = b\"my secret data\".to_vec();\n-//! let cocoon = Cocoon::new(b\"password\");\n-//! # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+//! let mut cocoon = Cocoon::new(b\"password\");\n+//! # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n //! # let mut file = Cursor::new(vec![0; 150]);\n //!\n //! cocoon.dump(data, &mut file)?;\n@@ -101,7 +101,7 @@\n //! #\n //! # fn main() -> Result<(), Error> {\n //! let mut data = \"my secret data\".to_owned().into_bytes();\n-//! let cocoon = MiniCocoon::from_key(b\"0123456789abcdef0123456789abcdef\", &[0; 32]);\n+//! let mut cocoon = MiniCocoon::from_key(b\"0123456789abcdef0123456789abcdef\", &[0; 32]);\n //!\n //! let detached_prefix = cocoon.encrypt(&mut data)?;\n //! assert_ne!(data, b\"my secret data\");\n@@ -149,7 +149,7 @@\n //!     // Supply some password to Cocoon: it can be any byte array, basically.\n //!     // Don't use a hard-coded password in real life!\n //!     // It could be a user-supplied password.\n-//!     let cocoon = Cocoon::new(b\"secret password\");\n+//!     let mut cocoon = Cocoon::new(b\"secret password\");\n //!\n //!     // Dump the serialized database into a file as an encrypted container.\n //!     let container = cocoon.dump(encoded, &mut file)?;\n@@ -322,8 +322,8 @@ pub use mini::*;\n /// # use cocoon::{Cocoon, Error};\n /// #\n /// # fn main() -> Result<(), Error> {\n-/// let cocoon = Cocoon::new(b\"password\");\n-/// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+/// let mut cocoon = Cocoon::new(b\"password\");\n+/// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n ///\n /// let wrapped = cocoon.wrap(b\"my secret data\")?;\n /// assert_ne!(&wrapped, b\"my secret data\");\n@@ -435,7 +435,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// ```\n     /// use cocoon::Cocoon;\n     ///\n-    /// let cocoon = Cocoon::new(b\"my secret password\");\n+    /// let mut cocoon = Cocoon::new(b\"my secret password\");\n     /// ```\n     pub fn new(password: &'a [u8]) -> Self {\n         Cocoon {\n@@ -464,7 +464,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// // ThreadRng is used just for example.\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = Cocoon::from_seed(b\"password\", seed);\n+    /// let mut cocoon = Cocoon::from_seed(b\"password\", seed);\n     /// ```\n     ///\n     /// **WARNING**: Use this method carefully, don't feed it with a static seed unless testing!\n@@ -493,7 +493,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// # // [`ThreadRng`] is used here just as an example. It is supposed to apply some other\n     /// # // cryptographically secure RNG when [`ThreadRng`] is not accessible.\n     /// # let mut good_rng = rand::rngs::ThreadRng::default();\n-    /// let cocoon = Cocoon::from_rng(b\"password\", good_rng).unwrap();\n+    /// let mut cocoon = Cocoon::from_rng(b\"password\", good_rng).unwrap();\n     /// ```\n     pub fn from_rng<R: RngCore>(password: &'a [u8], rng: R) -> Result<Self, rand::Error> {\n         Ok(Cocoon {\n@@ -516,7 +516,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// ```\n     /// use cocoon::Cocoon;\n     ///\n-    /// let cocoon = Cocoon::from_entropy(b\"password\");\n+    /// let mut cocoon = Cocoon::from_entropy(b\"password\");\n     /// ```\n     #[cfg(any(feature = \"getrandom\", test))]\n     #[cfg_attr(docs_rs, doc(cfg(feature = \"getrandom\")))]\n@@ -546,7 +546,7 @@ impl<'a> Cocoon<'a, Parsing> {\n     /// ```compile_fail\n     /// use cocoon::Cocoon;\n     ///\n-    /// let cocoon = Cocoon::parse_only(b\"password\");\n+    /// let mut cocoon = Cocoon::parse_only(b\"password\");\n     ///\n     /// // The compilation process fails here denying to use any encryption method.\n     /// cocoon.wrap(b\"my data\");\n@@ -557,7 +557,7 @@ impl<'a> Cocoon<'a, Parsing> {\n     /// use cocoon::{Cocoon, Error};\n     ///\n     /// # fn main() -> Result<(), Error> {\n-    /// let cocoon = Cocoon::parse_only(b\"password\");\n+    /// let mut cocoon = Cocoon::parse_only(b\"password\");\n     ///\n     /// # let mut data = [\n     /// #     244, 85, 222, 144, 119, 169, 144, 11, 178, 216, 4, 57, 17, 47, 0,\n@@ -591,7 +591,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// ```\n     /// use cocoon::{Cocoon, CocoonCipher};\n     ///\n-    /// let cocoon = Cocoon::new(b\"password\").with_cipher(CocoonCipher::Aes256Gcm);\n+    /// let mut cocoon = Cocoon::new(b\"password\").with_cipher(CocoonCipher::Aes256Gcm);\n     /// cocoon.wrap(b\"my secret data\");\n     /// ```\n     pub fn with_cipher(mut self, cipher: CocoonCipher) -> Self {\n@@ -608,7 +608,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// ```\n     /// use cocoon::Cocoon;\n     ///\n-    /// let cocoon = Cocoon::new(b\"password\").with_weak_kdf();\n+    /// let mut cocoon = Cocoon::new(b\"password\").with_weak_kdf();\n     /// cocoon.wrap(b\"my secret data\").expect(\"New container\");\n     /// ```\n     pub fn with_weak_kdf(mut self) -> Self {\n@@ -625,8 +625,8 @@ impl<'a> Cocoon<'a, Creation> {\n     /// # use cocoon::{Cocoon, Error};\n     /// #\n     /// # fn main() -> Result<(), Error> {\n-    /// let cocoon = Cocoon::new(b\"password\");\n-    /// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+    /// let mut cocoon = Cocoon::new(b\"password\");\n+    /// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n     ///\n     /// let wrapped = cocoon.wrap(b\"my secret data\")?;\n     /// assert_ne!(&wrapped, b\"my secret data\");\n@@ -636,7 +636,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// ```\n     #[cfg(feature = \"alloc\")]\n     #[cfg_attr(docs_rs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n-    pub fn wrap(&self, data: &[u8]) -> Result<Vec<u8>, Error> {\n+    pub fn wrap(&mut self, data: &[u8]) -> Result<Vec<u8>, Error> {\n         // Allocation is needed because there is no way to prefix encrypted\n         // data with a header without an allocation. It means that we need\n         // to copy data at least once. It's necessary to avoid any further copying.\n@@ -669,8 +669,8 @@ impl<'a> Cocoon<'a, Creation> {\n     /// #\n     /// # fn main() -> Result<(), Error> {\n     /// let mut data = b\"my secret data\".to_vec();\n-    /// let cocoon = Cocoon::new(b\"password\");\n-    /// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+    /// let mut cocoon = Cocoon::new(b\"password\");\n+    /// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n     /// # let mut file = Cursor::new(vec![0; 150]);\n     ///\n     /// cocoon.dump(data, &mut file)?;\n@@ -680,7 +680,7 @@ impl<'a> Cocoon<'a, Creation> {\n     /// # }\n     #[cfg(feature = \"std\")]\n     #[cfg_attr(docs_rs, doc(cfg(feature = \"std\")))]\n-    pub fn dump(&self, mut data: Vec<u8>, writer: &mut impl Write) -> Result<(), Error> {\n+    pub fn dump(&mut self, mut data: Vec<u8>, writer: &mut impl Write) -> Result<(), Error> {\n         let detached_prefix = self.encrypt(&mut data)?;\n \n         writer.write_all(&detached_prefix)?;\n@@ -706,27 +706,25 @@ impl<'a> Cocoon<'a, Creation> {\n     /// # // cryptographically secure RNG when [`ThreadRng`] is not accessible.\n     /// # let mut good_rng = rand::rngs::ThreadRng::default();\n     /// let mut data = \"my secret data\".to_owned().into_bytes();\n-    /// let cocoon = Cocoon::from_rng(b\"password\", good_rng).unwrap();\n-    /// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+    /// let mut cocoon = Cocoon::from_rng(b\"password\", good_rng).unwrap();\n+    /// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n     ///\n     /// let detached_prefix = cocoon.encrypt(&mut data)?;\n     /// assert_ne!(data, b\"my secret data\");\n     /// # Ok(())\n     /// # }\n     /// ```\n-    pub fn encrypt(&self, data: &mut [u8]) -> Result<[u8; PREFIX_SIZE], Error> {\n+    pub fn encrypt(&mut self, data: &mut [u8]) -> Result<[u8; PREFIX_SIZE], Error> {\n         let mut salt = [0u8; 16];\n         let mut nonce = [0u8; 12];\n \n-        match &self.rng {\n+        match self.rng {\n             #[cfg(feature = \"std\")]\n-            RngVariant::Thread(rng) => {\n-                let mut rng = rng.clone();\n+            RngVariant::Thread(ref mut rng) => {\n                 rng.fill_bytes(&mut salt);\n                 rng.fill_bytes(&mut nonce);\n             }\n-            RngVariant::Std(rng) => {\n-                let mut rng = rng.clone();\n+            RngVariant::Std(ref mut rng) => {\n                 rng.fill_bytes(&mut salt);\n                 rng.fill_bytes(&mut nonce);\n             }\n@@ -771,8 +769,8 @@ impl<'a, M> Cocoon<'a, M> {\n     /// # use cocoon::{Cocoon, Error};\n     /// #\n     /// # fn main() -> Result<(), Error> {\n-    /// let cocoon = Cocoon::new(b\"password\");\n-    /// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+    /// let mut cocoon = Cocoon::new(b\"password\");\n+    /// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n     ///\n     /// # let wrapped = cocoon.wrap(b\"my secret data\")?;\n     /// # assert_ne!(&wrapped, b\"my secret data\");\n@@ -813,8 +811,8 @@ impl<'a, M> Cocoon<'a, M> {\n     /// #\n     /// # fn main() -> Result<(), Error> {\n     /// let mut data = b\"my secret data\".to_vec();\n-    /// let cocoon = Cocoon::new(b\"password\");\n-    /// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+    /// let mut cocoon = Cocoon::new(b\"password\");\n+    /// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n     /// # let mut file = Cursor::new(vec![0; 150]);\n     ///\n     /// # cocoon.dump(data, &mut file)?;\n@@ -855,8 +853,8 @@ impl<'a, M> Cocoon<'a, M> {\n     /// # // cryptographically secure RNG when [`ThreadRng`] is not accessible.\n     /// # let mut good_rng = rand::rngs::ThreadRng::default();\n     /// let mut data = \"my secret data\".to_owned().into_bytes();\n-    /// let cocoon = Cocoon::from_rng(b\"password\", good_rng).unwrap();\n-    /// # let cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n+    /// let mut cocoon = Cocoon::from_rng(b\"password\", good_rng).unwrap();\n+    /// # let mut cocoon = cocoon.with_weak_kdf(); // Speed up doc tests.\n     ///\n     /// let detached_prefix = cocoon.encrypt(&mut data)?;\n     /// assert_ne!(data, b\"my secret data\");\n@@ -932,10 +930,10 @@ mod test {\n \n     #[test]\n     fn cocoon_encrypt() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]).with_weak_kdf();\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]).with_weak_kdf();\n         let mut data = \"my secret data\".to_owned().into_bytes();\n \n-        let detached_prefix = cocoon.encrypt(&mut data).unwrap();\n+        let detached_prefix = &cocoon.encrypt(&mut data).unwrap();\n \n         assert_eq!(\n             &[\n@@ -951,11 +949,22 @@ mod test {\n             &[186, 240, 214, 29, 4, 147, 205, 72, 210, 7, 167, 234, 199, 53],\n             &data[..]\n         );\n+\n+        let mut cipher_data: Vec<Vec<u8>> = Vec::new();\n+        cipher_data.push(data.to_vec());\n+        for _ in 0..10 {\n+            data = \"my secret data\".to_owned().into_bytes();\n+            let _ = cocoon.encrypt(&mut data).unwrap();\n+            cipher_data.push(data.to_vec());\n+            for i in 0..cipher_data.len() - 2 {\n+                assert_ne!(&cipher_data.last().unwrap(), &cipher_data.get(i).unwrap())\n+            }\n+        }\n     }\n \n     #[test]\n     fn cocoon_encrypt_aes() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32])\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32])\n             .with_weak_kdf()\n             .with_cipher(CocoonCipher::Aes256Gcm);\n         let mut data = \"my secret data\".to_owned().into_bytes();\n@@ -976,6 +985,16 @@ mod test {\n             &[88, 183, 11, 7, 192, 224, 203, 107, 144, 162, 48, 78, 61, 223],\n             &data[..]\n         );\n+        let mut cipher_data: Vec<Vec<u8>> = Vec::new();\n+        cipher_data.push(data.to_vec());\n+        for _ in 0..10 {\n+            data = \"my secret data\".to_owned().into_bytes();\n+            let _ = cocoon.encrypt(&mut data).unwrap();\n+            cipher_data.push(data.to_vec());\n+            for i in 0..cipher_data.len() - 2 {\n+                assert_ne!(&cipher_data.last().unwrap(), &cipher_data.get(i).unwrap())\n+            }\n+        }\n     }\n \n     #[test]\n@@ -1018,15 +1037,15 @@ mod test {\n \n     #[test]\n     fn cocoon_wrap() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n         let wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         assert_eq!(wrapped[wrapped.len() - 4..], [27, 107, 178, 181]);\n     }\n \n     #[test]\n     fn cocoon_wrap_unwrap() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n         let wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n         let original = cocoon.unwrap(&wrapped).expect(\"Unwrapped container\");\n \n@@ -1035,7 +1054,7 @@ mod test {\n \n     #[test]\n     fn cocoon_wrap_unwrap_corrupted() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n         let mut wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         let last = wrapped.len() - 1;\n@@ -1045,7 +1064,7 @@ mod test {\n \n     #[test]\n     fn cocoon_unwrap_larger_is_ok() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n         let mut wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         wrapped.push(0);\n@@ -1056,7 +1075,7 @@ mod test {\n \n     #[test]\n     fn cocoon_unwrap_too_short() {\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]);\n         let mut wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         wrapped.pop();\n@@ -1090,7 +1109,7 @@ mod test {\n     fn cocoon_dump_parse() {\n         let buf = vec![0; 100];\n         let mut file = Cursor::new(buf);\n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]).with_weak_kdf();\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]).with_weak_kdf();\n \n         // Prepare data inside of `Vec` container.\n         let data = b\"my data\".to_vec();\n@@ -1113,7 +1132,7 @@ mod test {\n         File::create(read_only_file.clone()).expect(\"Test file\");\n         let mut file = File::open(read_only_file).expect(\"Test file\");\n \n-        let cocoon = Cocoon::from_seed(b\"password\", [0; 32]).with_weak_kdf();\n+        let mut cocoon = Cocoon::from_seed(b\"password\", [0; 32]).with_weak_kdf();\n \n         // Prepare data inside of `Vec` container.\n         let data = b\"my data\".to_vec();"
        },
        {
          "filename": "src/mini.rs",
          "status": "modified",
          "additions": 46,
          "deletions": 26,
          "patch": "@@ -34,7 +34,7 @@ pub struct MiniCocoon {\n /// # use cocoon::{MiniCocoon, Error};\n /// #\n /// # fn main() -> Result<(), Error> {\n-/// let cocoon = MiniCocoon::from_key(b\"0123456789abcdef0123456789abcdef\", &[0; 32]);\n+/// let mut cocoon = MiniCocoon::from_key(b\"0123456789abcdef0123456789abcdef\", &[0; 32]);\n ///\n /// let wrapped = cocoon.wrap(b\"my secret data\")?;\n /// assert_ne!(&wrapped, b\"my secret data\");\n@@ -92,7 +92,7 @@ impl MiniCocoon {\n     /// // Key must be 32 bytes of length. Let it be another 32 random bytes.\n     /// let key = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = MiniCocoon::from_key(&key, &seed);\n+    /// let mut cocoon = MiniCocoon::from_key(&key, &seed);\n     /// ```\n     pub fn from_key(key: &[u8], seed: &[u8]) -> Self {\n         let mut k = [0u8; KEY_SIZE];\n@@ -126,7 +126,7 @@ impl MiniCocoon {\n     /// // ThreadRng is used as an example.\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = MiniCocoon::from_password(b\"my password\", &seed);\n+    /// let mut cocoon = MiniCocoon::from_password(b\"my password\", &seed);\n     /// ```\n     pub fn from_password(password: &[u8], seed: &[u8]) -> Self {\n         let config = CocoonConfig::default();\n@@ -152,7 +152,7 @@ impl MiniCocoon {\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n     /// let key = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = MiniCocoon::from_key(&key, &seed).with_cipher(CocoonCipher::Chacha20Poly1305);\n+    /// let mut cocoon = MiniCocoon::from_key(&key, &seed).with_cipher(CocoonCipher::Chacha20Poly1305);\n     /// cocoon.wrap(b\"my secret data\");\n     /// ```\n     pub fn with_cipher(mut self, cipher: CocoonCipher) -> Self {\n@@ -171,7 +171,7 @@ impl MiniCocoon {\n     /// #\n     /// # fn main() -> Result<(), Error> {\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n-    /// let cocoon = MiniCocoon::from_password(b\"password\", &seed);\n+    /// let mut cocoon = MiniCocoon::from_password(b\"password\", &seed);\n     ///\n     /// let wrapped = cocoon.wrap(b\"my secret data\")?;\n     /// assert_ne!(&wrapped, b\"my secret data\");\n@@ -181,7 +181,7 @@ impl MiniCocoon {\n     /// ```\n     #[cfg(feature = \"alloc\")]\n     #[cfg_attr(docs_rs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n-    pub fn wrap(&self, data: &[u8]) -> Result<Vec<u8>, Error> {\n+    pub fn wrap(&mut self, data: &[u8]) -> Result<Vec<u8>, Error> {\n         // Allocation is needed because there is no way to prefix encrypted\n         // data with a header without an allocation. It means that we need\n         // to copy data at least once. It's necessary to avoid any further copying.\n@@ -218,7 +218,7 @@ impl MiniCocoon {\n     ///            17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = MiniCocoon::from_key(&key, &seed);\n+    /// let mut cocoon = MiniCocoon::from_key(&key, &seed);\n     /// # let mut file = Cursor::new(vec![0; 150]);\n     ///\n     /// let mut data = b\"my secret data\".to_vec();\n@@ -230,7 +230,7 @@ impl MiniCocoon {\n     /// # }\n     #[cfg(feature = \"std\")]\n     #[cfg_attr(docs_rs, doc(cfg(feature = \"std\")))]\n-    pub fn dump(&self, mut data: Vec<u8>, writer: &mut impl Write) -> Result<(), Error> {\n+    pub fn dump(&mut self, mut data: Vec<u8>, writer: &mut impl Write) -> Result<(), Error> {\n         let detached_prefix = self.encrypt(&mut data)?;\n \n         writer.write_all(&detached_prefix)?;\n@@ -252,7 +252,7 @@ impl MiniCocoon {\n     /// # use cocoon::{MiniCocoon, Error};\n     /// #\n     /// # fn main() -> Result<(), Error> {\n-    /// let cocoon = MiniCocoon::from_password(b\"password\", &[1; 32]);\n+    /// let mut cocoon = MiniCocoon::from_password(b\"password\", &[1; 32]);\n     ///\n     /// let mut data = \"my secret data\".to_owned().into_bytes();\n     ///\n@@ -261,11 +261,9 @@ impl MiniCocoon {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    pub fn encrypt(&self, data: &mut [u8]) -> Result<[u8; MINI_PREFIX_SIZE], Error> {\n-        let mut rng = self.rng.clone();\n-\n+    pub fn encrypt(&mut self, data: &mut [u8]) -> Result<[u8; MINI_PREFIX_SIZE], Error> {\n         let mut nonce = [0u8; 12];\n-        rng.fill_bytes(&mut nonce);\n+        self.rng.fill_bytes(&mut nonce);\n \n         let header = MiniCocoonHeader::new(nonce, data.len());\n         let prefix = MiniFormatPrefix::new(header);\n@@ -300,7 +298,7 @@ impl MiniCocoon {\n     /// let key = b\"0123456789abcdef0123456789abcdef\";\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = MiniCocoon::from_key(key, &seed);\n+    /// let mut cocoon = MiniCocoon::from_key(key, &seed);\n     ///\n     /// # let wrapped = cocoon.wrap(b\"my secret data\")?;\n     /// # assert_ne!(&wrapped, b\"my secret data\");\n@@ -344,7 +342,7 @@ impl MiniCocoon {\n     /// let key = b\"0123456789abcdef0123456789abcdef\";\n     /// let seed = rand::thread_rng().gen::<[u8; 32]>();\n     ///\n-    /// let cocoon = MiniCocoon::from_key(key, &seed);\n+    /// let mut cocoon = MiniCocoon::from_key(key, &seed);\n     /// # let mut file = Cursor::new(vec![0; 150]);\n     /// #\n     /// # let mut data = b\"my secret data\".to_vec();\n@@ -384,7 +382,7 @@ impl MiniCocoon {\n     /// #\n     /// # fn main() -> Result<(), Error> {\n     /// let mut data = \"my secret data\".to_owned().into_bytes();\n-    /// let cocoon = MiniCocoon::from_password(b\"password\", &[0; 32]);\n+    /// let mut cocoon = MiniCocoon::from_password(b\"password\", &[0; 32]);\n     ///\n     /// let detached_prefix = cocoon.encrypt(&mut data)?;\n     /// assert_ne!(data, b\"my secret data\");\n@@ -453,7 +451,7 @@ mod test {\n \n     #[test]\n     fn mini_cocoon_encrypt() {\n-        let cocoon = MiniCocoon::from_password(b\"password\", &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_password(b\"password\", &[0; 32]);\n         let mut data = \"my secret data\".to_owned().into_bytes();\n \n         let detached_prefix = cocoon.encrypt(&mut data).unwrap();\n@@ -470,11 +468,22 @@ mod test {\n             &[98, 34, 35, 62, 28, 121, 71, 223, 170, 151, 215, 104, 52, 187],\n             &data[..]\n         );\n+\n+        let mut cipher_data: Vec<Vec<u8>> = Vec::new();\n+        cipher_data.push(data.to_vec());\n+        for _ in 0..10 {\n+            data = \"my secret data\".to_owned().into_bytes();\n+            let _ = cocoon.encrypt(&mut data).unwrap();\n+            cipher_data.push(data.to_vec());\n+            for i in 0..cipher_data.len() - 2 {\n+                assert_ne!(&cipher_data.last().unwrap(), &cipher_data.get(i).unwrap())\n+            }\n+        }\n     }\n \n     #[test]\n     fn mini_cocoon_encrypt_aes() {\n-        let cocoon =\n+        let mut cocoon =\n             MiniCocoon::from_password(b\"password\", &[0; 32]).with_cipher(CocoonCipher::Aes256Gcm);\n         let mut data = \"my secret data\".to_owned().into_bytes();\n \n@@ -492,6 +501,17 @@ mod test {\n             &[41, 58, 226, 219, 28, 132, 21, 216, 165, 46, 246, 120, 10, 92],\n             &data[..]\n         );\n+\n+        let mut cipher_data: Vec<Vec<u8>> = Vec::new();\n+        cipher_data.push(data.to_vec());\n+        for _ in 0..10 {\n+            data = \"my secret data\".to_owned().into_bytes();\n+            let _ = cocoon.encrypt(&mut data).unwrap();\n+            cipher_data.push(data.to_vec());\n+            for i in 0..cipher_data.len() - 2 {\n+                assert_ne!(&cipher_data.last().unwrap(), &cipher_data.get(i).unwrap())\n+            }\n+        }\n     }\n \n     #[test]\n@@ -533,15 +553,15 @@ mod test {\n \n     #[test]\n     fn mini_cocoon_wrap() {\n-        let cocoon = MiniCocoon::from_password(b\"password\", &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_password(b\"password\", &[0; 32]);\n         let wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         assert_eq!(wrapped[wrapped.len() - 4..], [107, 58, 119, 44]);\n     }\n \n     #[test]\n     fn mini_cocoon_wrap_unwrap() {\n-        let cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n         let wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n         let original = cocoon.unwrap(&wrapped).expect(\"Unwrapped container\");\n \n@@ -550,17 +570,17 @@ mod test {\n \n     #[test]\n     fn mini_cocoon_wrap_unwrap_corrupted() {\n-        let cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n         let mut wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         let last = wrapped.len() - 1;\n         wrapped[last] += 1;\n-        cocoon.unwrap(&wrapped).expect_err(\"Unwrapped container\");\n+        let _ = &cocoon.unwrap(&wrapped).expect_err(\"Unwrapped container\");\n     }\n \n     #[test]\n     fn mini_cocoon_unwrap_larger_is_ok() {\n-        let cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n         let mut wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         wrapped.push(0);\n@@ -571,7 +591,7 @@ mod test {\n \n     #[test]\n     fn mini_cocoon_unwrap_too_short() {\n-        let cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n         let mut wrapped = cocoon.wrap(b\"data\").expect(\"Wrapped container\");\n \n         wrapped.pop();\n@@ -605,7 +625,7 @@ mod test {\n     fn mini_cocoon_dump_parse() {\n         let buf = vec![0; 100];\n         let mut file = Cursor::new(buf);\n-        let cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n \n         // Prepare data inside of `Vec` container.\n         let data = b\"my data\".to_vec();\n@@ -628,7 +648,7 @@ mod test {\n         File::create(read_only_file.clone()).expect(\"Test file\");\n         let mut file = File::open(read_only_file).expect(\"Test file\");\n \n-        let cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n+        let mut cocoon = MiniCocoon::from_key(&[1; 32], &[0; 32]);\n \n         // Prepare data inside of `Vec` container.\n         let data = b\"my data\".to_vec();"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2d6519cc2e97ff2b6f3a4f4ba11d373cbc8a3cfc",
            "date": "2024-09-02T10:59:51Z",
            "author_login": "fadeevab"
          },
          {
            "sha": "fdc0032109a175c6c9e106853c160e8e7138a0de",
            "date": "2024-09-02T10:56:48Z",
            "author_login": "Deaths-Door"
          },
          {
            "sha": "9240eccd5c90df3a53fd32c38ae5636a5fb49137",
            "date": "2024-09-01T14:02:04Z",
            "author_login": "fadeevab"
          },
          {
            "sha": "8e108cc1359b4426b2e3213bd62d310a9d06198c",
            "date": "2024-09-01T13:44:37Z",
            "author_login": "fadeevab"
          },
          {
            "sha": "c8460f64597e639d9796097599ca7d5e5485f9d1",
            "date": "2024-05-27T14:28:45Z",
            "author_login": "fadeevab"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-323",
    "description": "Versions of the package cocoon before 0.4.0 are vulnerable to Reusing a Nonce, Key Pair in Encryption when the encrypt, wrap, and dump functions are sequentially called. An attacker can generate the same ciphertext by creating a new encrypted message with the same cocoon object.\r\r**Note:**\rThe issue does NOT affect objects created with Cocoon::new which utilizes ThreadRng.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-10-02T05:15:11.300",
    "last_modified": "2024-10-04T13:50:43.727",
    "fix_date": "2023-10-17T12:50:14Z"
  },
  "references": [
    {
      "url": "https://github.com/advisories/GHSA-6878-6wc2-pf5h",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/fadeevab/cocoon/issues/22",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://rustsec.org/advisories/RUSTSEC-2023-0068.html",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-RUST-COCOON-6028364",
      "source": "report@snyk.io",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.102797",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "cocoon",
    "owner": "fadeevab",
    "created_at": "2020-05-11T13:44:43Z",
    "updated_at": "2024-11-23T09:22:11Z",
    "pushed_at": "2024-09-02T10:59:58Z",
    "size": 116,
    "stars": 71,
    "forks": 13,
    "open_issues": 0,
    "watchers": 71,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 98527
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:49:44.904157"
  }
}