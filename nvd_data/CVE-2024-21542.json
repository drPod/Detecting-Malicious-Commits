{
  "cve_id": "CVE-2024-21542",
  "github_data": {
    "repository": "spotify/luigi",
    "fix_commit": "b5d1b965ead7d9f777a3216369b5baf23ec08999",
    "related_commits": [
      "b5d1b965ead7d9f777a3216369b5baf23ec08999"
    ],
    "patch_url": "https://github.com/spotify/luigi/commit/b5d1b965ead7d9f777a3216369b5baf23ec08999.patch",
    "fix_commit_details": {
      "sha": "b5d1b965ead7d9f777a3216369b5baf23ec08999",
      "commit_date": "2024-09-07T14:07:58Z",
      "author": {
        "login": "dlstadther",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #3309 from Ali-Razmjoo/fix-tarfile-extraction",
        "length": 179,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 238,
        "additions": 228,
        "deletions": 10
      },
      "files": [
        {
          "filename": "luigi/contrib/lsf_runner.py",
          "status": "modified",
          "additions": 3,
          "deletions": 5,
          "patch": "@@ -28,7 +28,7 @@\n except ImportError:\n     import pickle\n import logging\n-import tarfile\n+from luigi.safe_extractor import SafeExtractor\n \n \n def do_work_on_compute_node(work_dir):\n@@ -52,10 +52,8 @@ def extract_packages_archive(work_dir):\n     curdir = os.path.abspath(os.curdir)\n \n     os.chdir(work_dir)\n-    tar = tarfile.open(package_file)\n-    for tarinfo in tar:\n-        tar.extract(tarinfo)\n-    tar.close()\n+    extractor = SafeExtractor(work_dir)\n+    extractor.safe_extract(package_file)\n     if '' not in sys.path:\n         sys.path.insert(0, '')\n "
        },
        {
          "filename": "luigi/contrib/sge_runner.py",
          "status": "modified",
          "additions": 3,
          "deletions": 5,
          "patch": "@@ -36,7 +36,7 @@\n import sys\n import pickle\n import logging\n-import tarfile\n+from luigi.safe_extractor import SafeExtractor\n \n \n def _do_work_on_compute_node(work_dir, tarball=True):\n@@ -64,10 +64,8 @@ def _extract_packages_archive(work_dir):\n     curdir = os.path.abspath(os.curdir)\n \n     os.chdir(work_dir)\n-    tar = tarfile.open(package_file)\n-    for tarinfo in tar:\n-        tar.extract(tarinfo)\n-    tar.close()\n+    extractor = SafeExtractor(work_dir)\n+    extractor.safe_extract(package_file)\n     if '' not in sys.path:\n         sys.path.insert(0, '')\n "
        },
        {
          "filename": "luigi/safe_extractor.py",
          "status": "added",
          "additions": 97,
          "deletions": 0,
          "patch": "@@ -0,0 +1,97 @@\n+# -*- coding: utf-8 -*-\n+#\n+# Copyright 2012-2015 Spotify AB\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+This module provides a class `SafeExtractor` that offers a secure way to extract tar files while\n+mitigating path traversal vulnerabilities, which can occur when files inside the archive are\n+crafted to escape the intended extraction directory.\n+\n+The `SafeExtractor` ensures that the extracted file paths are validated before extraction to\n+prevent malicious archives from extracting files outside the intended directory.\n+\n+Classes:\n+    SafeExtractor: A class to securely extract tar files with protection against path traversal attacks.\n+\n+Usage Example:\n+    extractor = SafeExtractor(\"/desired/directory\")\n+    extractor.safe_extract(\"archive.tar\")\n+\"\"\"\n+\n+import os\n+import tarfile\n+\n+\n+class SafeExtractor:\n+    \"\"\"\n+    A class to safely extract tar files, ensuring that no path traversal\n+    vulnerabilities are exploited.\n+\n+    Attributes:\n+        path (str): The directory to extract files into.\n+\n+    Methods:\n+        _is_within_directory(directory, target):\n+            Checks if a target path is within a given directory.\n+\n+        safe_extract(tar_path, members=None, \\\\*, numeric_owner=False):\n+            Safely extracts the contents of a tar file to the specified directory.\n+    \"\"\"\n+\n+    def __init__(self, path=\".\"):\n+        \"\"\"\n+        Initializes the SafeExtractor with the specified directory path.\n+\n+        Args:\n+            path (str): The directory to extract files into. Defaults to the current directory.\n+        \"\"\"\n+        self.path = path\n+\n+    @staticmethod\n+    def _is_within_directory(directory, target):\n+        \"\"\"\n+        Checks if a target path is within a given directory.\n+\n+        Args:\n+            directory (str): The directory to check against.\n+            target (str): The target path to check.\n+\n+        Returns:\n+            bool: True if the target path is within the directory, False otherwise.\n+        \"\"\"\n+        abs_directory = os.path.abspath(directory)\n+        abs_target = os.path.abspath(target)\n+        prefix = os.path.commonprefix([abs_directory, abs_target])\n+        return prefix == abs_directory\n+\n+    def safe_extract(self, tar_path, members=None, *, numeric_owner=False):\n+        \"\"\"\n+        Safely extracts the contents of a tar file to the specified directory.\n+\n+        Args:\n+            tar_path (str): The path to the tar file to extract.\n+            members (list, optional): A list of members to extract. Defaults to None.\n+            numeric_owner (bool, optional): If True, only the numeric owner will be used. Defaults to False.\n+\n+        Raises:\n+            RuntimeError: If a path traversal attempt is detected.\n+        \"\"\"\n+        with tarfile.open(tar_path, 'r') as tar:\n+            for member in tar.getmembers():\n+                member_path = os.path.join(self.path, member.name)\n+                if not self._is_within_directory(self.path, member_path):\n+                    raise RuntimeError(\"Attempted Path Traversal in Tar File\")\n+            tar.extractall(self.path, members, numeric_owner=numeric_owner)"
        },
        {
          "filename": "test/safe_extractor_test.py",
          "status": "added",
          "additions": 125,
          "deletions": 0,
          "patch": "@@ -0,0 +1,125 @@\n+# -*- coding: utf-8 -*-\n+#\n+# Copyright 2012-2015 Spotify AB\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Safe Extractor Test\n+=============\n+\n+Tests for the Safe Extractor class in luigi.safe_extractor module.\n+\"\"\"\n+\n+import os\n+import shutil\n+import tarfile\n+import tempfile\n+import unittest\n+\n+from luigi.safe_extractor import SafeExtractor\n+\n+\n+class TestSafeExtract(unittest.TestCase):\n+    \"\"\"\n+    Unit test class for testing the SafeExtractor module.\n+    \"\"\"\n+\n+    def setUp(self):\n+        \"\"\"Set up a temporary directory for test files.\"\"\"\n+        self.temp_dir = tempfile.mkdtemp()\n+        self.test_file_template = 'test_file_{}.txt'\n+        self.tar_file_name = 'test.tar'\n+        self.tar_file_name_with_traversal = f'traversal_{self.tar_file_name}'\n+\n+    def tearDown(self):\n+        \"\"\"Clean up the temporary directory after each test.\"\"\"\n+        shutil.rmtree(self.temp_dir)\n+\n+    def create_test_tar(self, tar_path, file_count=1, with_traversal=False):\n+        \"\"\"\n+        Create a tar file containing test files.\n+\n+        Args:\n+            tar_path (str): Path where the tar file will be created.\n+            file_count (int): Number of test files to include.\n+            with_traversal (bool): If True, creates a tar file with path traversal vulnerability.\n+        \"\"\"\n+        # Default content for the test files\n+        file_contents = [f'This is {self.test_file_template.format(i)}' for i in range(file_count)]\n+\n+        with tarfile.open(tar_path, 'w') as tar:\n+            for i in range(file_count):\n+                file_name = self.test_file_template.format(i)\n+                file_path = os.path.join(self.temp_dir, file_name)\n+\n+                # Write content to each test file\n+                with open(file_path, 'w') as f:\n+                    f.write(file_contents[i])\n+\n+                # If path traversal is enabled, create malicious paths\n+                archive_name = f'../../{file_name}' if with_traversal else file_name\n+\n+                # Add the file to the tar archive\n+                tar.add(file_path, arcname=archive_name)\n+\n+    def verify_extracted_files(self, file_count):\n+        \"\"\"\n+        Verify that the correct files were extracted and their contents match expectations.\n+\n+        Args:\n+            file_count (int): Number of files to verify.\n+        \"\"\"\n+        for i in range(file_count):\n+            file_name = self.test_file_template.format(i)\n+            file_path = os.path.join(self.temp_dir, file_name)\n+\n+            # Check if the file exists\n+            self.assertTrue(os.path.exists(file_path), f\"File {file_name} does not exist.\")\n+\n+            # Check if the file content is correct\n+            with open(file_path, 'r') as f:\n+                content = f.read()\n+                expected_content = f'This is {file_name}'\n+                self.assertEqual(content, expected_content, f\"Content mismatch in {file_name}.\")\n+\n+    def test_safe_extract(self):\n+        \"\"\"Test normal safe extraction of tar files.\"\"\"\n+        tar_path = os.path.join(self.temp_dir, self.tar_file_name)\n+\n+        # Create a tar file with 3 files\n+        self.create_test_tar(tar_path, file_count=3)\n+\n+        # Initialize SafeExtractor and perform extraction\n+        extractor = SafeExtractor(self.temp_dir)\n+        extractor.safe_extract(tar_path)\n+\n+        # Verify that all 3 files were extracted correctly\n+        self.verify_extracted_files(3)\n+\n+    def test_safe_extract_with_traversal(self):\n+        \"\"\"Test safe extraction for tar files with path traversal (should raise an error).\"\"\"\n+        tar_path = os.path.join(self.temp_dir, self.tar_file_name_with_traversal)\n+\n+        # Create a tar file with a path traversal file\n+        self.create_test_tar(tar_path, file_count=1, with_traversal=True)\n+\n+        # Initialize SafeExtractor and expect RuntimeError due to path traversal\n+        extractor = SafeExtractor(self.temp_dir)\n+        with self.assertRaises(RuntimeError):\n+            extractor.safe_extract(tar_path)\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b2b3b58b0b23745b15b032494cb95eb8b07c0f02",
            "date": "2024-12-18T00:52:38Z",
            "author_login": "dlstadther"
          },
          {
            "sha": "5fe0b84f938368f0374d3cc4b28fcc845c07367c",
            "date": "2024-12-16T19:18:27Z",
            "author_login": "ccmaymay"
          },
          {
            "sha": "101b820dea0023f79092f5c17e096db9e89423a4",
            "date": "2024-12-12T02:07:52Z",
            "author_login": "dlstadther"
          },
          {
            "sha": "74a5a2109d9a7d7ea13329f8aec4bff89d154cb4",
            "date": "2024-12-11T13:57:06Z",
            "author_login": "dmkoch"
          },
          {
            "sha": "3d76fa24a0a86f1612720b0502c524698e52d40d",
            "date": "2024-12-06T00:50:06Z",
            "author_login": "dlstadther"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-29",
    "description": "Versions of the package luigi before 3.6.0 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) due to improper destination file path validation in the _extract_packages_archive function.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-12-10T05:15:07.567",
    "last_modified": "2024-12-10T05:15:07.567",
    "fix_date": "2024-09-07T14:07:58Z"
  },
  "references": [
    {
      "url": "https://github.com/spotify/luigi/commit/b5d1b965ead7d9f777a3216369b5baf23ec08999",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/spotify/luigi/issues/3301",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/spotify/luigi/releases/tag/v3.6.0",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-PYTHON-LUIGI-7830489",
      "source": "report@snyk.io",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:33.114336",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "luigi",
    "owner": "spotify",
    "created_at": "2012-09-20T15:06:38Z",
    "updated_at": "2025-01-14T00:45:32Z",
    "pushed_at": "2024-12-18T00:52:38Z",
    "size": 11057,
    "stars": 18016,
    "forks": 2404,
    "open_issues": 137,
    "watchers": 18016,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 2209447,
      "JavaScript": 178687,
      "HTML": 43634,
      "CSS": 5575,
      "Shell": 3119
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:12:38.126784"
  }
}