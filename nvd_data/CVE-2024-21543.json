{
  "cve_id": "CVE-2024-21543",
  "github_data": {
    "repository": "sunscrapers/djoser",
    "fix_commit": "d33c3993c0c735f23cbedc60fa59fce69354f19d",
    "related_commits": [
      "d33c3993c0c735f23cbedc60fa59fce69354f19d"
    ],
    "patch_url": "https://github.com/sunscrapers/djoser/commit/d33c3993c0c735f23cbedc60fa59fce69354f19d.patch",
    "fix_commit_details": {
      "sha": "d33c3993c0c735f23cbedc60fa59fce69354f19d",
      "commit_date": "2024-05-03T20:32:45Z",
      "author": {
        "login": "tomwojcik",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "rollback 8f65bfff16577c7fb0f52bbabf5fb69f6809ba62, add support for ModelBackend.user_can_authenticate",
        "length": 101,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 244,
        "additions": 220,
        "deletions": 24
      },
      "files": [
        {
          "filename": "djoser/serializers.py",
          "status": "modified",
          "additions": 3,
          "deletions": 7,
          "patch": "@@ -118,17 +118,13 @@ def __init__(self, *args, **kwargs):\n \n     def validate(self, attrs):\n         password = attrs.get(\"password\")\n-        params = {settings.LOGIN_FIELD: attrs.get(settings.LOGIN_FIELD)}\n+        params = {\"username\": attrs.get(settings.LOGIN_FIELD)}\n         self.user = authenticate(\n             request=self.context.get(\"request\"), **params, password=password\n         )\n         if not self.user:\n-            self.user = User.objects.filter(**params).first()\n-            if self.user and not self.user.check_password(password):\n-                self.fail(\"invalid_credentials\")\n-        if self.user and self.user.is_active:\n-            return attrs\n-        self.fail(\"invalid_credentials\")\n+            self.fail(\"invalid_credentials\")\n+        return attrs\n \n \n class UserFunctionsMixin:"
        },
        {
          "filename": "testproject/testapp/tests/test_token_create.py",
          "status": "modified",
          "additions": 217,
          "deletions": 17,
          "patch": "@@ -1,6 +1,9 @@\n import django\n+from unittest import mock\n+\n from django.conf import settings as django_settings\n from django.contrib.auth import user_logged_in, user_login_failed\n+from django.contrib.auth.backends import ModelBackend\n from django.test import override_settings\n from djet import assertions\n from rest_framework import status\n@@ -37,9 +40,221 @@ def test_post_should_login_user(self):\n         self.assertNotEqual(user.last_login, previous_last_login)\n         self.assertTrue(self.signal_sent)\n \n+    @override_settings(\n+        AUTHENTICATION_BACKENDS=[\n+            \"django.contrib.auth.backends.ModelBackend\",\n+        ]\n+    )\n+    @override_settings(\n+        DJOSER=dict(django_settings.DJOSER, **{\"LOGIN_FIELD\": \"username\"})\n+    )\n+    def test_post_should_not_login_if_model_backend_user_can_authenticate__LOGIN_FIELD_username__USERNAME_FIELD_username(  # noqa: E501\n+        self,\n+    ):\n+        user = create_user()\n+        user_logged_in.connect(self.signal_receiver)\n+        previous_last_login = user.last_login\n+\n+        with mock.patch(\"djoser.serializers.User.USERNAME_FIELD\", \"username\"):\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_200_OK)\n+\n+                user.refresh_from_db()\n+                self.assertEqual(response.data[\"auth_token\"], user.auth_token.key)\n+                self.assertNotEqual(user.last_login, previous_last_login)\n+                self.assertTrue(self.signal_sent)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+    @override_settings(\n+        AUTHENTICATION_BACKENDS=[\n+            \"django.contrib.auth.backends.ModelBackend\",\n+        ]\n+    )\n+    @override_settings(DJOSER=dict(django_settings.DJOSER, **{\"LOGIN_FIELD\": \"email\"}))\n+    def test_post_should_not_login_if_model_backend_user_can_authenticate__LOGIN_FIELD_email__USERNAME_FIELD_username(  # noqa: E501\n+        self,\n+    ):\n+        user = create_user()\n+        user_logged_in.connect(self.signal_receiver)\n+        previous_last_login = user.last_login\n+\n+        with mock.patch(\"djoser.serializers.User.USERNAME_FIELD\", \"username\"):\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+        user.refresh_from_db()\n+        self.assertEqual(user.last_login, previous_last_login)\n+        self.assertFalse(self.signal_sent)\n+\n+    @override_settings(\n+        AUTHENTICATION_BACKENDS=[\n+            \"django.contrib.auth.backends.ModelBackend\",\n+        ]\n+    )\n+    @override_settings(\n+        DJOSER=dict(django_settings.DJOSER, **{\"LOGIN_FIELD\": \"username\"})\n+    )\n+    def test_post_should_not_login_if_model_backend_user_can_authenticate__LOGIN_FIELD_username__USERNAME_FIELD_email(  # noqa: E501\n+        self,\n+    ):\n+        user = create_user()\n+        user_logged_in.connect(self.signal_receiver)\n+        previous_last_login = user.last_login\n+\n+        with mock.patch(\"djoser.serializers.User.USERNAME_FIELD\", \"email\"):\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+        user.refresh_from_db()\n+        self.assertEqual(user.last_login, previous_last_login)\n+        self.assertFalse(self.signal_sent)\n+\n+    @override_settings(\n+        AUTHENTICATION_BACKENDS=[\n+            \"django.contrib.auth.backends.ModelBackend\",\n+        ]\n+    )\n+    @override_settings(DJOSER=dict(django_settings.DJOSER, **{\"LOGIN_FIELD\": \"email\"}))\n+    def test_post_should_not_login_if_model_backend_user_can_authenticate__LOGIN_FIELD_email__USERNAME_FIELD_email(  # noqa: E501\n+        self,\n+    ):\n+        user = create_user()\n+        user_logged_in.connect(self.signal_receiver)\n+        previous_last_login = user.last_login\n+\n+        with mock.patch(\"djoser.serializers.User.USERNAME_FIELD\", \"email\"):\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url,\n+                    {\"username\": user.username, \"password\": user.raw_password},\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=True\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_200_OK)\n+\n+                user.refresh_from_db()\n+                self.assertEqual(response.data[\"auth_token\"], user.auth_token.key)\n+                self.assertNotEqual(user.last_login, previous_last_login)\n+                self.assertTrue(self.signal_sent)\n+\n+            with mock.patch.object(\n+                ModelBackend, \"user_can_authenticate\", return_value=False\n+            ):\n+                response = self.client.post(\n+                    self.base_url, {\"email\": user.email, \"password\": user.raw_password}\n+                )\n+                self.assert_status_equal(response, status.HTTP_400_BAD_REQUEST)\n+\n     def test_post_should_not_login_if_user_is_not_active(self):\n-        \"\"\"In Django >= 1.10 authenticate() returns None if user is inactive,\n-        while in Django < 1.10 authenticate() succeeds if user is inactive.\"\"\"\n         user = create_user()\n         data = {\"username\": user.username, \"password\": user.raw_password}\n         user.is_active = False\n@@ -81,18 +296,3 @@ def test_post_should_not_login_if_empty_request(self):\n             response.data[\"non_field_errors\"],\n             [settings.CONSTANTS.messages.INVALID_CREDENTIALS_ERROR],\n         )\n-\n-    @override_settings(DJOSER=dict(django_settings.DJOSER, **{\"LOGIN_FIELD\": \"email\"}))\n-    def test_login_using_email(self):\n-        user = create_user()\n-        previous_last_login = user.last_login\n-        data = {\"email\": user.email, \"password\": user.raw_password}\n-        user_logged_in.connect(self.signal_receiver)\n-\n-        response = self.client.post(self.base_url, data)\n-        user.refresh_from_db()\n-\n-        self.assert_status_equal(response, status.HTTP_200_OK)\n-        self.assertEqual(response.data[\"auth_token\"], user.auth_token.key)\n-        self.assertNotEqual(user.last_login, previous_last_login)\n-        self.assertTrue(self.signal_sent)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9deaa635c8521e2c030b810c4753da0f3a358c1f",
            "date": "2024-11-10T13:06:08Z",
            "author_login": "tomwojcik"
          },
          {
            "sha": "016ca3a8c7a2e6713bc0a8e71748c463ab486134",
            "date": "2024-11-10T12:04:35Z",
            "author_login": "tomwojcik"
          },
          {
            "sha": "49dff8703ec1bc2fd8dc7995b28b48cce6fac2dc",
            "date": "2024-11-10T12:01:02Z",
            "author_login": "tomwojcik"
          },
          {
            "sha": "3442a509308f7ff01ff97829d89d089fdcf0e279",
            "date": "2024-11-10T11:55:12Z",
            "author_login": "tomwojcik"
          },
          {
            "sha": "25d845176ef6bb3ad832862982aabcb32b5b8f87",
            "date": "2024-11-10T11:50:16Z",
            "author_login": "tomwojcik"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-287",
    "description": "Versions of the package djoser before 2.3.0 are vulnerable to Authentication Bypass when the authenticate() function fails. This is because the system falls back to querying the database directly, granting access to users with valid credentials, and eventually bypassing custom authentication checks such as two-factor authentication, LDAP validations, or requirements from configured AUTHENTICATION_BACKENDS.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-12-13T05:15:07.653",
    "last_modified": "2024-12-13T20:15:19.613",
    "fix_date": "2024-05-03T20:32:45Z"
  },
  "references": [
    {
      "url": "https://github.com/sunscrapers/djoser/commit/d33c3993c0c735f23cbedc60fa59fce69354f19d",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/sunscrapers/djoser/issues/795",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/sunscrapers/djoser/pull/819",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/sunscrapers/djoser/releases/tag/2.3.0",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-PYTHON-DJOSER-8366540",
      "source": "report@snyk.io",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:33.136100",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "djoser",
    "owner": "sunscrapers",
    "created_at": "2014-09-30T14:50:08Z",
    "updated_at": "2025-01-11T20:12:01Z",
    "pushed_at": "2024-11-10T13:40:22Z",
    "size": 1824,
    "stars": 2565,
    "forks": 460,
    "open_issues": 188,
    "watchers": 2565,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Python": 174346,
      "JavaScript": 9739,
      "HTML": 6261,
      "Makefile": 657
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:20:33.089818"
  }
}