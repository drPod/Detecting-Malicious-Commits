{
  "cve_id": "CVE-2024-21548",
  "github_data": {
    "repository": "oven-sh/bun",
    "fix_commit": "a234e067a5dc7837602df3fb5489e826920cc65a",
    "related_commits": [
      "a234e067a5dc7837602df3fb5489e826920cc65a"
    ],
    "patch_url": "https://github.com/oven-sh/bun/commit/a234e067a5dc7837602df3fb5489e826920cc65a.patch",
    "fix_commit_details": {
      "sha": "a234e067a5dc7837602df3fb5489e826920cc65a",
      "commit_date": "2024-10-08T07:34:31Z",
      "author": {
        "login": "Jarred-Sumner",
        "type": "User",
        "stats": {
          "total_commits": 7689,
          "average_weekly_commits": 39.03045685279188,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 194
        }
      },
      "commit_message": {
        "title": "Make .get() ignore Object.prototype instead of using getOwn (#14322)",
        "length": 68,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 477,
        "additions": 283,
        "deletions": 194
      },
      "files": [
        {
          "filename": "src/bun.js/api/BunObject.zig",
          "status": "modified",
          "additions": 16,
          "deletions": 16,
          "patch": "@@ -329,11 +329,11 @@ pub fn braces(\n     if (arguments.nextEat()) |opts_val| {\n         if (opts_val.isObject()) {\n             if (comptime bun.Environment.allow_assert) {\n-                if (opts_val.getOwnTruthy(globalThis, \"tokenize\")) |tokenize_val| {\n+                if (opts_val.getTruthy(globalThis, \"tokenize\")) |tokenize_val| {\n                     tokenize = if (tokenize_val.isBoolean()) tokenize_val.asBoolean() else false;\n                 }\n \n-                if (opts_val.getOwnTruthy(globalThis, \"parse\")) |tokenize_val| {\n+                if (opts_val.getTruthy(globalThis, \"parse\")) |tokenize_val| {\n                     parse = if (tokenize_val.isBoolean()) tokenize_val.asBoolean() else false;\n                 }\n             }\n@@ -461,11 +461,11 @@ pub fn which(\n \n     if (arguments.nextEat()) |arg| {\n         if (!arg.isEmptyOrUndefinedOrNull() and arg.isObject()) {\n-            if (arg.getOwn(globalThis, \"PATH\")) |str_| {\n+            if (arg.get(globalThis, \"PATH\")) |str_| {\n                 path_str = str_.toSlice(globalThis, globalThis.bunVM().allocator);\n             }\n \n-            if (arg.getOwn(globalThis, \"cwd\")) |str_| {\n+            if (arg.get(globalThis, \"cwd\")) |str_| {\n                 cwd_str = str_.toSlice(globalThis, globalThis.bunVM().allocator);\n             }\n         }\n@@ -514,7 +514,7 @@ pub fn inspect(\n         const arg1 = arguments[1];\n \n         if (arg1.isObject()) {\n-            if (arg1.getOwnTruthy(globalThis, \"depth\")) |opt| {\n+            if (arg1.getTruthy(globalThis, \"depth\")) |opt| {\n                 if (opt.isInt32()) {\n                     const arg = opt.toInt32();\n                     if (arg < 0) {\n@@ -779,7 +779,7 @@ pub fn openInEditor(\n \n     if (arguments.nextEat()) |opts| {\n         if (!opts.isUndefinedOrNull()) {\n-            if (opts.getOwnTruthy(globalThis, \"editor\")) |editor_val| {\n+            if (opts.getTruthy(globalThis, \"editor\")) |editor_val| {\n                 var sliced = editor_val.toSlice(globalThis, arguments.arena.allocator());\n                 const prev_name = edit.name;\n \n@@ -799,11 +799,11 @@ pub fn openInEditor(\n                 }\n             }\n \n-            if (opts.getOwnTruthy(globalThis, \"line\")) |line_| {\n+            if (opts.getTruthy(globalThis, \"line\")) |line_| {\n                 line = line_.toSlice(globalThis, arguments.arena.allocator()).slice();\n             }\n \n-            if (opts.getOwnTruthy(globalThis, \"column\")) |column_| {\n+            if (opts.getTruthy(globalThis, \"column\")) |column_| {\n                 column = column_.toSlice(globalThis, arguments.arena.allocator()).slice();\n             }\n         }\n@@ -1711,7 +1711,7 @@ pub const Crypto = struct {\n \n                 pub fn fromJS(globalObject: *JSC.JSGlobalObject, value: JSC.JSValue) ?Value {\n                     if (value.isObject()) {\n-                        if (value.getOwnTruthy(globalObject, \"algorithm\")) |algorithm_value| {\n+                        if (value.getTruthy(globalObject, \"algorithm\")) |algorithm_value| {\n                             if (!algorithm_value.isString()) {\n                                 globalObject.throwInvalidArgumentType(\"hash\", \"algorithm\", \"string\");\n                                 return null;\n@@ -1728,7 +1728,7 @@ pub const Crypto = struct {\n                                         .bcrypt = PasswordObject.Algorithm.Value.bcrpyt_default,\n                                     };\n \n-                                    if (value.getOwnTruthy(globalObject, \"cost\")) |rounds_value| {\n+                                    if (value.getTruthy(globalObject, \"cost\")) |rounds_value| {\n                                         if (!rounds_value.isNumber()) {\n                                             globalObject.throwInvalidArgumentType(\"hash\", \"cost\", \"number\");\n                                             return null;\n@@ -1749,7 +1749,7 @@ pub const Crypto = struct {\n                                 inline .argon2id, .argon2d, .argon2i => |tag| {\n                                     var argon = Algorithm.Argon2Params{};\n \n-                                    if (value.getOwnTruthy(globalObject, \"timeCost\")) |time_value| {\n+                                    if (value.getTruthy(globalObject, \"timeCost\")) |time_value| {\n                                         if (!time_value.isNumber()) {\n                                             globalObject.throwInvalidArgumentType(\"hash\", \"timeCost\", \"number\");\n                                             return null;\n@@ -1765,7 +1765,7 @@ pub const Crypto = struct {\n                                         argon.time_cost = @as(u32, @intCast(time_cost));\n                                     }\n \n-                                    if (value.getOwnTruthy(globalObject, \"memoryCost\")) |memory_value| {\n+                                    if (value.getTruthy(globalObject, \"memoryCost\")) |memory_value| {\n                                         if (!memory_value.isNumber()) {\n                                             globalObject.throwInvalidArgumentType(\"hash\", \"memoryCost\", \"number\");\n                                             return null;\n@@ -4599,11 +4599,11 @@ fn stringWidth(globalObject: *JSC.JSGlobalObject, callframe: *JSC.CallFrame) JSC\n     var ambiguous_as_wide = false;\n \n     if (options_object.isObject()) {\n-        if (options_object.getOwnTruthy(globalObject, \"countAnsiEscapeCodes\")) |count_ansi_escapes_value| {\n+        if (options_object.getTruthy(globalObject, \"countAnsiEscapeCodes\")) |count_ansi_escapes_value| {\n             if (count_ansi_escapes_value.isBoolean())\n                 count_ansi_escapes = count_ansi_escapes_value.toBoolean();\n         }\n-        if (options_object.getOwnTruthy(globalObject, \"ambiguousIsNarrow\")) |ambiguous_is_narrow| {\n+        if (options_object.getTruthy(globalObject, \"ambiguousIsNarrow\")) |ambiguous_is_narrow| {\n             if (ambiguous_is_narrow.isBoolean())\n                 ambiguous_as_wide = !ambiguous_is_narrow.toBoolean();\n         }\n@@ -4784,7 +4784,7 @@ pub const JSZlib = struct {\n                 library = .zlib;\n             }\n \n-            if (options_val.getOwnTruthy(globalThis, \"library\")) |library_value| {\n+            if (options_val.getTruthy(globalThis, \"library\")) |library_value| {\n                 if (!library_value.isString()) {\n                     globalThis.throwInvalidArguments(\"Expected library to be a string\", .{});\n                     return .zero;\n@@ -4911,7 +4911,7 @@ pub const JSZlib = struct {\n                 library = .zlib;\n             }\n \n-            if (options_val.getOwnTruthy(globalThis, \"library\")) |library_value| {\n+            if (options_val.getTruthy(globalThis, \"library\")) |library_value| {\n                 if (!library_value.isString()) {\n                     globalThis.throwInvalidArguments(\"Expected library to be a string\", .{});\n                     return .zero;"
        },
        {
          "filename": "src/bun.js/api/JSBundler.zig",
          "status": "modified",
          "additions": 26,
          "deletions": 26,
          "patch": "@@ -109,7 +109,7 @@ pub const JSBundler = struct {\n                         return error.JSError;\n                     }\n \n-                    if (plugin.getOwnOptional(globalThis, \"name\", ZigString.Slice) catch null) |slice| {\n+                    if (plugin.getOptional(globalThis, \"name\", ZigString.Slice) catch null) |slice| {\n                         defer slice.deinit();\n                         if (slice.len == 0) {\n                             globalThis.throwInvalidArguments(\"Expected plugin to have a non-empty name\", .{});\n@@ -153,13 +153,13 @@ pub const JSBundler = struct {\n                 }\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"macros\")) |macros_flag| {\n+            if (config.getTruthy(globalThis, \"macros\")) |macros_flag| {\n                 if (!macros_flag.coerce(bool, globalThis)) {\n                     this.no_macros = true;\n                 }\n             }\n \n-            if (try config.getOwnOptional(globalThis, \"bytecode\", bool)) |bytecode| {\n+            if (try config.getOptional(globalThis, \"bytecode\", bool)) |bytecode| {\n                 this.bytecode = bytecode;\n \n                 if (bytecode) {\n@@ -169,7 +169,7 @@ pub const JSBundler = struct {\n                 }\n             }\n \n-            if (try config.getOwnOptionalEnum(globalThis, \"target\", options.Target)) |target| {\n+            if (try config.getOptionalEnum(globalThis, \"target\", options.Target)) |target| {\n                 this.target = target;\n \n                 if (target != .bun and this.bytecode) {\n@@ -179,18 +179,18 @@ pub const JSBundler = struct {\n             }\n \n             var has_out_dir = false;\n-            if (try config.getOwnOptional(globalThis, \"outdir\", ZigString.Slice)) |slice| {\n+            if (try config.getOptional(globalThis, \"outdir\", ZigString.Slice)) |slice| {\n                 defer slice.deinit();\n                 try this.outdir.appendSliceExact(slice.slice());\n                 has_out_dir = true;\n             }\n \n-            if (try config.getOwnOptional(globalThis, \"banner\", ZigString.Slice)) |slice| {\n+            if (try config.getOptional(globalThis, \"banner\", ZigString.Slice)) |slice| {\n                 defer slice.deinit();\n                 try this.banner.appendSliceExact(slice.slice());\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"sourcemap\")) |source_map_js| {\n+            if (config.getTruthy(globalThis, \"sourcemap\")) |source_map_js| {\n                 if (bun.FeatureFlags.breaking_changes_1_2 and config.isBoolean()) {\n                     if (source_map_js == .true) {\n                         this.source_map = if (has_out_dir)\n@@ -207,11 +207,11 @@ pub const JSBundler = struct {\n                 }\n             }\n \n-            if (try config.getOwnOptionalEnum(globalThis, \"packages\", options.PackagesOption)) |packages| {\n+            if (try config.getOptionalEnum(globalThis, \"packages\", options.PackagesOption)) |packages| {\n                 this.packages = packages;\n             }\n \n-            if (try config.getOwnOptionalEnum(globalThis, \"format\", options.Format)) |format| {\n+            if (try config.getOptionalEnum(globalThis, \"format\", options.Format)) |format| {\n                 this.format = format;\n \n                 if (this.bytecode and format != .cjs) {\n@@ -220,28 +220,28 @@ pub const JSBundler = struct {\n                 }\n             }\n \n-            // if (try config.getOwnOptional(globalThis, \"hot\", bool)) |hot| {\n+            // if (try config.getOptional(globalThis, \"hot\", bool)) |hot| {\n             //     this.hot = hot;\n             // }\n \n-            if (try config.getOwnOptional(globalThis, \"splitting\", bool)) |hot| {\n+            if (try config.getOptional(globalThis, \"splitting\", bool)) |hot| {\n                 this.code_splitting = hot;\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"minify\")) |hot| {\n+            if (config.getTruthy(globalThis, \"minify\")) |hot| {\n                 if (hot.isBoolean()) {\n                     const value = hot.coerce(bool, globalThis);\n                     this.minify.whitespace = value;\n                     this.minify.syntax = value;\n                     this.minify.identifiers = value;\n                 } else if (hot.isObject()) {\n-                    if (try hot.getOwnOptional(globalThis, \"whitespace\", bool)) |whitespace| {\n+                    if (try hot.getOptional(globalThis, \"whitespace\", bool)) |whitespace| {\n                         this.minify.whitespace = whitespace;\n                     }\n-                    if (try hot.getOwnOptional(globalThis, \"syntax\", bool)) |syntax| {\n+                    if (try hot.getOptional(globalThis, \"syntax\", bool)) |syntax| {\n                         this.minify.syntax = syntax;\n                     }\n-                    if (try hot.getOwnOptional(globalThis, \"identifiers\", bool)) |syntax| {\n+                    if (try hot.getOptional(globalThis, \"identifiers\", bool)) |syntax| {\n                         this.minify.identifiers = syntax;\n                     }\n                 } else {\n@@ -265,19 +265,19 @@ pub const JSBundler = struct {\n                 return error.JSError;\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"emitDCEAnnotations\")) |flag| {\n+            if (config.getTruthy(globalThis, \"emitDCEAnnotations\")) |flag| {\n                 if (flag.coerce(bool, globalThis)) {\n                     this.emit_dce_annotations = true;\n                 }\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"ignoreDCEAnnotations\")) |flag| {\n+            if (config.getTruthy(globalThis, \"ignoreDCEAnnotations\")) |flag| {\n                 if (flag.coerce(bool, globalThis)) {\n                     this.ignore_dce_annotations = true;\n                 }\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"conditions\")) |conditions_value| {\n+            if (config.getTruthy(globalThis, \"conditions\")) |conditions_value| {\n                 if (conditions_value.isString()) {\n                     var slice = conditions_value.toSliceOrNull(globalThis) orelse {\n                         globalThis.throwInvalidArguments(\"Expected conditions to be an array of strings\", .{});\n@@ -303,7 +303,7 @@ pub const JSBundler = struct {\n \n             {\n                 const path: ZigString.Slice = brk: {\n-                    if (try config.getOwnOptional(globalThis, \"root\", ZigString.Slice)) |slice| {\n+                    if (try config.getOptional(globalThis, \"root\", ZigString.Slice)) |slice| {\n                         break :brk slice;\n                     }\n \n@@ -344,21 +344,21 @@ pub const JSBundler = struct {\n                 }\n             }\n \n-            // if (try config.getOwnOptional(globalThis, \"dir\", ZigString.Slice)) |slice| {\n+            // if (try config.getOptional(globalThis, \"dir\", ZigString.Slice)) |slice| {\n             //     defer slice.deinit();\n             //     this.appendSliceExact(slice.slice()) catch unreachable;\n             // } else {\n             //     this.appendSliceExact(globalThis.bunVM().bundler.fs.top_level_dir) catch unreachable;\n             // }\n \n-            if (try config.getOwnOptional(globalThis, \"publicPath\", ZigString.Slice)) |slice| {\n+            if (try config.getOptional(globalThis, \"publicPath\", ZigString.Slice)) |slice| {\n                 defer slice.deinit();\n                 try this.public_path.appendSliceExact(slice.slice());\n             }\n \n-            if (config.getOwnTruthy(globalThis, \"naming\")) |naming| {\n+            if (config.getTruthy(globalThis, \"naming\")) |naming| {\n                 if (naming.isString()) {\n-                    if (try config.getOwnOptional(globalThis, \"naming\", ZigString.Slice)) |slice| {\n+                    if (try config.getOptional(globalThis, \"naming\", ZigString.Slice)) |slice| {\n                         defer slice.deinit();\n                         if (!strings.hasPrefixComptime(slice.slice(), \"./\")) {\n                             try this.names.owned_entry_point.appendSliceExact(\"./\");\n@@ -367,7 +367,7 @@ pub const JSBundler = struct {\n                         this.names.entry_point.data = this.names.owned_entry_point.list.items;\n                     }\n                 } else if (naming.isObject()) {\n-                    if (try naming.getOwnOptional(globalThis, \"entry\", ZigString.Slice)) |slice| {\n+                    if (try naming.getOptional(globalThis, \"entry\", ZigString.Slice)) |slice| {\n                         defer slice.deinit();\n                         if (!strings.hasPrefixComptime(slice.slice(), \"./\")) {\n                             try this.names.owned_entry_point.appendSliceExact(\"./\");\n@@ -376,7 +376,7 @@ pub const JSBundler = struct {\n                         this.names.entry_point.data = this.names.owned_entry_point.list.items;\n                     }\n \n-                    if (try naming.getOwnOptional(globalThis, \"chunk\", ZigString.Slice)) |slice| {\n+                    if (try naming.getOptional(globalThis, \"chunk\", ZigString.Slice)) |slice| {\n                         defer slice.deinit();\n                         if (!strings.hasPrefixComptime(slice.slice(), \"./\")) {\n                             try this.names.owned_chunk.appendSliceExact(\"./\");\n@@ -385,7 +385,7 @@ pub const JSBundler = struct {\n                         this.names.chunk.data = this.names.owned_chunk.list.items;\n                     }\n \n-                    if (try naming.getOwnOptional(globalThis, \"asset\", ZigString.Slice)) |slice| {\n+                    if (try naming.getOptional(globalThis, \"asset\", ZigString.Slice)) |slice| {\n                         defer slice.deinit();\n                         if (!strings.hasPrefixComptime(slice.slice(), \"./\")) {\n                             try this.names.owned_asset.appendSliceExact(\"./\");"
        },
        {
          "filename": "src/bun.js/api/JSTranspiler.zig",
          "status": "modified",
          "additions": 23,
          "deletions": 23,
          "patch": "@@ -329,7 +329,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         return transpiler;\n     }\n \n-    if (object.getOwnTruthy(globalObject, \"define\")) |define| {\n+    if (object.getTruthy(globalObject, \"define\")) |define| {\n         define: {\n             if (define.isUndefinedOrNull()) {\n                 break :define;\n@@ -378,7 +378,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (object.getOwn(globalThis, \"external\")) |external| {\n+    if (object.get(globalThis, \"external\")) |external| {\n         external: {\n             if (external.isUndefinedOrNull()) break :external;\n \n@@ -418,7 +418,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (object.getOwn(globalThis, \"loader\")) |loader| {\n+    if (object.get(globalThis, \"loader\")) |loader| {\n         if (Loader.fromJS(globalThis, loader, exception)) |resolved| {\n             if (!resolved.isJavaScriptLike()) {\n                 JSC.throwInvalidArguments(\"only JavaScript-like loaders supported for now\", .{}, globalObject, exception);\n@@ -433,7 +433,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (object.getOwn(globalThis, \"target\")) |target| {\n+    if (object.get(globalThis, \"target\")) |target| {\n         if (Target.fromJS(globalThis, target, exception)) |resolved| {\n             transpiler.transform.target = resolved.toAPI();\n         }\n@@ -443,7 +443,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (object.getOwn(globalThis, \"tsconfig\")) |tsconfig| {\n+    if (object.get(globalThis, \"tsconfig\")) |tsconfig| {\n         tsconfig: {\n             if (tsconfig.isUndefinedOrNull()) break :tsconfig;\n             const kind = tsconfig.jsType();\n@@ -482,7 +482,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         else => false,\n     };\n \n-    if (object.getOwnTruthy(globalThis, \"macro\")) |macros| {\n+    if (object.getTruthy(globalThis, \"macro\")) |macros| {\n         macros: {\n             if (macros.isUndefinedOrNull()) break :macros;\n             if (macros.isBoolean()) {\n@@ -517,39 +517,39 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (object.getOwnOptional(globalThis, \"autoImportJSX\", bool) catch return transpiler) |flag| {\n+    if (object.getOptional(globalThis, \"autoImportJSX\", bool) catch return transpiler) |flag| {\n         transpiler.runtime.auto_import_jsx = flag;\n     }\n \n-    if (object.getOwnOptional(globalThis, \"allowBunRuntime\", bool) catch return transpiler) |flag| {\n+    if (object.getOptional(globalThis, \"allowBunRuntime\", bool) catch return transpiler) |flag| {\n         transpiler.runtime.allow_runtime = flag;\n     }\n \n-    if (object.getOwnOptional(globalThis, \"inline\", bool) catch return transpiler) |flag| {\n+    if (object.getOptional(globalThis, \"inline\", bool) catch return transpiler) |flag| {\n         transpiler.runtime.inlining = flag;\n     }\n \n-    if (object.getOwnOptional(globalThis, \"minifyWhitespace\", bool) catch return transpiler) |flag| {\n+    if (object.getOptional(globalThis, \"minifyWhitespace\", bool) catch return transpiler) |flag| {\n         transpiler.minify_whitespace = flag;\n     }\n \n-    if (object.getOwnOptional(globalThis, \"deadCodeElimination\", bool) catch return transpiler) |flag| {\n+    if (object.getOptional(globalThis, \"deadCodeElimination\", bool) catch return transpiler) |flag| {\n         transpiler.dead_code_elimination = flag;\n     }\n \n-    if (object.getOwnTruthy(globalThis, \"minify\")) |hot| {\n+    if (object.getTruthy(globalThis, \"minify\")) |hot| {\n         if (hot.isBoolean()) {\n             transpiler.minify_whitespace = hot.coerce(bool, globalThis);\n             transpiler.minify_syntax = transpiler.minify_whitespace;\n             transpiler.minify_identifiers = transpiler.minify_syntax;\n         } else if (hot.isObject()) {\n-            if (try hot.getOwnOptional(globalThis, \"whitespace\", bool)) |whitespace| {\n+            if (try hot.getOptional(globalThis, \"whitespace\", bool)) |whitespace| {\n                 transpiler.minify_whitespace = whitespace;\n             }\n-            if (try hot.getOwnOptional(globalThis, \"syntax\", bool)) |syntax| {\n+            if (try hot.getOptional(globalThis, \"syntax\", bool)) |syntax| {\n                 transpiler.minify_syntax = syntax;\n             }\n-            if (try hot.getOwnOptional(globalThis, \"identifiers\", bool)) |syntax| {\n+            if (try hot.getOptional(globalThis, \"identifiers\", bool)) |syntax| {\n                 transpiler.minify_identifiers = syntax;\n             }\n         } else {\n@@ -558,7 +558,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (object.getOwn(globalThis, \"sourcemap\")) |flag| {\n+    if (object.get(globalThis, \"sourcemap\")) |flag| {\n         if (flag.isBoolean() or flag.isUndefinedOrNull()) {\n             if (flag.toBoolean()) {\n                 transpiler.transform.source_map = .@\"inline\";\n@@ -575,21 +575,21 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         }\n     }\n \n-    if (try object.getOwnOptionalEnum(globalThis, \"packages\", options.PackagesOption)) |packages| {\n+    if (try object.getOptionalEnum(globalThis, \"packages\", options.PackagesOption)) |packages| {\n         transpiler.transform.packages = packages.toAPI();\n     }\n \n     var tree_shaking: ?bool = null;\n-    if (object.getOwnOptional(globalThis, \"treeShaking\", bool) catch return transpiler) |treeShaking| {\n+    if (object.getOptional(globalThis, \"treeShaking\", bool) catch return transpiler) |treeShaking| {\n         tree_shaking = treeShaking;\n     }\n \n     var trim_unused_imports: ?bool = null;\n-    if (object.getOwnOptional(globalThis, \"trimUnusedImports\", bool) catch return transpiler) |trimUnusedImports| {\n+    if (object.getOptional(globalThis, \"trimUnusedImports\", bool) catch return transpiler) |trimUnusedImports| {\n         trim_unused_imports = trimUnusedImports;\n     }\n \n-    if (object.getOwnTruthy(globalThis, \"exports\")) |exports| {\n+    if (object.getTruthy(globalThis, \"exports\")) |exports| {\n         if (!exports.isObject()) {\n             JSC.throwInvalidArguments(\"exports must be an object\", .{}, globalObject, exception);\n             return transpiler;\n@@ -598,7 +598,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         var replacements = Runtime.Features.ReplaceableExport.Map{};\n         errdefer replacements.clearAndFree(bun.default_allocator);\n \n-        if (exports.getOwnTruthy(globalThis, \"eliminate\")) |eliminate| {\n+        if (exports.getTruthy(globalThis, \"eliminate\")) |eliminate| {\n             if (!eliminate.jsType().isArray()) {\n                 JSC.throwInvalidArguments(\"exports.eliminate must be an array\", .{}, globalObject, exception);\n                 return transpiler;\n@@ -640,7 +640,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n             }\n         }\n \n-        if (exports.getOwnTruthy(globalThis, \"replace\")) |replace| {\n+        if (exports.getTruthy(globalThis, \"replace\")) |replace| {\n             if (!replace.isObject()) {\n                 JSC.throwInvalidArguments(\"replace must be an object\", .{}, globalObject, exception);\n                 return transpiler;\n@@ -717,7 +717,7 @@ fn transformOptionsFromJSC(globalObject: JSC.C.JSContextRef, temp_allocator: std\n         transpiler.runtime.replace_exports = replacements;\n     }\n \n-    if (object.getOwnTruthy(globalThis, \"logLevel\")) |logLevel| {\n+    if (object.getTruthy(globalThis, \"logLevel\")) |logLevel| {\n         if (logger.Log.Level.Map.fromJS(globalObject, logLevel)) |level| {\n             transpiler.log.level = level;\n         } else {"
        },
        {
          "filename": "src/bun.js/api/bun/socket.zig",
          "status": "modified",
          "additions": 13,
          "deletions": 13,
          "patch": "@@ -239,7 +239,7 @@ const Handlers = struct {\n             .{ \"onHandshake\", \"handshake\" },\n         };\n         inline for (pairs) |pair| {\n-            if (opts.getOwnTruthyComptime(globalObject, pair.@\"1\")) |callback_value| {\n+            if (opts.getTruthyComptime(globalObject, pair.@\"1\")) |callback_value| {\n                 if (!callback_value.isCell() or !callback_value.isCallable(globalObject.vm())) {\n                     exception.* = JSC.toInvalidArguments(comptime std.fmt.comptimePrint(\"Expected \\\"{s}\\\" callback to be a function\", .{pair.@\"1\"}), .{}, globalObject).asObjectRef();\n                     return null;\n@@ -254,7 +254,7 @@ const Handlers = struct {\n             return null;\n         }\n \n-        if (opts.getOwnTruthy(globalObject, \"binaryType\")) |binary_type_value| {\n+        if (opts.getTruthy(globalObject, \"binaryType\")) |binary_type_value| {\n             if (!binary_type_value.isString()) {\n                 exception.* = JSC.toInvalidArguments(\"Expected \\\"binaryType\\\" to be a string\", .{}, globalObject).asObjectRef();\n                 return null;\n@@ -341,13 +341,13 @@ pub const SocketConfig = struct {\n         }\n \n         hostname_or_unix: {\n-            if (opts.getOwnTruthy(globalObject, \"fd\")) |fd_| {\n+            if (opts.getTruthy(globalObject, \"fd\")) |fd_| {\n                 if (fd_.isNumber()) {\n                     break :hostname_or_unix;\n                 }\n             }\n \n-            if (opts.getOwnTruthy(globalObject, \"unix\")) |unix_socket| {\n+            if (opts.getTruthy(globalObject, \"unix\")) |unix_socket| {\n                 if (!unix_socket.isString()) {\n                     exception.* = JSC.toInvalidArguments(\"Expected \\\"unix\\\" to be a string\", .{}, globalObject).asObjectRef();\n                     return null;\n@@ -365,17 +365,17 @@ pub const SocketConfig = struct {\n                 }\n             }\n \n-            if (opts.getOwnTruthy(globalObject, \"exclusive\")) |_| {\n+            if (opts.getTruthy(globalObject, \"exclusive\")) |_| {\n                 exclusive = true;\n             }\n \n-            if (opts.getOwnTruthy(globalObject, \"hostname\") orelse opts.getOwnTruthy(globalObject, \"host\")) |hostname| {\n+            if (opts.getTruthy(globalObject, \"hostname\") orelse opts.getTruthy(globalObject, \"host\")) |hostname| {\n                 if (!hostname.isString()) {\n                     exception.* = JSC.toInvalidArguments(\"Expected \\\"hostname\\\" to be a string\", .{}, globalObject).asObjectRef();\n                     return null;\n                 }\n \n-                var port_value = opts.getOwn(globalObject, \"port\") orelse JSValue.zero;\n+                var port_value = opts.get(globalObject, \"port\") orelse JSValue.zero;\n                 hostname_or_unix = hostname.getZigString(globalObject).toSlice(bun.default_allocator);\n \n                 if (port_value.isEmptyOrUndefinedOrNull() and hostname_or_unix.len > 0) {\n@@ -423,7 +423,7 @@ pub const SocketConfig = struct {\n             return null;\n         }\n \n-        var handlers = Handlers.fromJS(globalObject, opts.getOwn(globalObject, \"socket\") orelse JSValue.zero, exception) orelse {\n+        var handlers = Handlers.fromJS(globalObject, opts.get(globalObject, \"socket\") orelse JSValue.zero, exception) orelse {\n             hostname_or_unix.deinit();\n             return null;\n         };\n@@ -542,7 +542,7 @@ pub const Listener = struct {\n \n         var exception: JSC.C.JSValueRef = null;\n \n-        const socket_obj = opts.getOwn(globalObject, \"socket\") orelse {\n+        const socket_obj = opts.get(globalObject, \"socket\") orelse {\n             globalObject.throw(\"Expected \\\"socket\\\" object\", .{});\n             return .zero;\n         };\n@@ -1069,7 +1069,7 @@ pub const Listener = struct {\n         vm.eventLoop().ensureWaker();\n \n         var connection: Listener.UnixOrHost = blk: {\n-            if (opts.getOwnTruthy(globalObject, \"fd\")) |fd_| {\n+            if (opts.getTruthy(globalObject, \"fd\")) |fd_| {\n                 if (fd_.isNumber()) {\n                     const fd = fd_.asFileDescriptor();\n                     break :blk .{ .fd = fd };\n@@ -2308,7 +2308,7 @@ fn NewSocket(comptime ssl: bool) type {\n \n             var exception: JSC.C.JSValueRef = null;\n \n-            const socket_obj = opts.getOwn(globalObject, \"socket\") orelse {\n+            const socket_obj = opts.get(globalObject, \"socket\") orelse {\n                 globalObject.throw(\"Expected \\\"socket\\\" option\", .{});\n                 return .zero;\n             };\n@@ -3082,7 +3082,7 @@ fn NewSocket(comptime ssl: bool) type {\n                 return .zero;\n             }\n \n-            const socket_obj = opts.getOwn(globalObject, \"socket\") orelse {\n+            const socket_obj = opts.get(globalObject, \"socket\") orelse {\n                 globalObject.throw(\"Expected \\\"socket\\\" option\", .{});\n                 return .zero;\n             };\n@@ -4007,7 +4007,7 @@ pub fn jsUpgradeDuplexToTLS(globalObject: *JSC.JSGlobalObject, callframe: *JSC.C\n         return .zero;\n     }\n \n-    const socket_obj = opts.getOwn(globalObject, \"socket\") orelse {\n+    const socket_obj = opts.get(globalObject, \"socket\") orelse {\n         globalObject.throw(\"Expected \\\"socket\\\" option\", .{});\n         return .zero;\n     };"
        },
        {
          "filename": "src/bun.js/api/bun/subprocess.zig",
          "status": "modified",
          "additions": 17,
          "deletions": 17,
          "patch": "@@ -1745,15 +1745,15 @@ pub const Subprocess = struct {\n             } else if (!args.isObject()) {\n                 globalThis.throwInvalidArguments(\"cmd must be an array\", .{});\n                 return .zero;\n-            } else if (args.getOwnTruthy(globalThis, \"cmd\")) |cmd_value_| {\n+            } else if (args.getTruthy(globalThis, \"cmd\")) |cmd_value_| {\n                 cmd_value = cmd_value_;\n             } else {\n                 globalThis.throwInvalidArguments(\"cmd must be an array\", .{});\n                 return .zero;\n             }\n \n             if (args.isObject()) {\n-                if (args.getOwnTruthy(globalThis, \"argv0\")) |argv0_| {\n+                if (args.getTruthy(globalThis, \"argv0\")) |argv0_| {\n                     const argv0_str = argv0_.getZigString(globalThis);\n                     if (argv0_str.len > 0) {\n                         argv0 = argv0_str.toOwnedSliceZ(allocator) catch {\n@@ -1764,7 +1764,7 @@ pub const Subprocess = struct {\n                 }\n \n                 // need to update `cwd` before searching for executable with `Which.which`\n-                if (args.getOwnTruthy(globalThis, \"cwd\")) |cwd_| {\n+                if (args.getTruthy(globalThis, \"cwd\")) |cwd_| {\n                     const cwd_str = cwd_.getZigString(globalThis);\n                     if (cwd_str.len > 0) {\n                         cwd = cwd_str.toOwnedSliceZ(allocator) catch {\n@@ -1849,10 +1849,10 @@ pub const Subprocess = struct {\n             if (args != .zero and args.isObject()) {\n                 // This must run before the stdio parsing happens\n                 if (!is_sync) {\n-                    if (args.getOwnTruthy(globalThis, \"ipc\")) |val| {\n+                    if (args.getTruthy(globalThis, \"ipc\")) |val| {\n                         if (val.isCell() and val.isCallable(globalThis.vm())) {\n                             maybe_ipc_mode = ipc_mode: {\n-                                if (args.getOwnTruthy(globalThis, \"serialization\")) |mode_val| {\n+                                if (args.getTruthy(globalThis, \"serialization\")) |mode_val| {\n                                     if (mode_val.isString()) {\n                                         break :ipc_mode IPC.Mode.fromJS(globalThis, mode_val) orelse {\n                                             if (!globalThis.hasException()) {\n@@ -1875,15 +1875,15 @@ pub const Subprocess = struct {\n                     }\n                 }\n \n-                if (args.getOwnTruthy(globalThis, \"signal\")) |signal_val| {\n+                if (args.getTruthy(globalThis, \"signal\")) |signal_val| {\n                     if (signal_val.as(JSC.WebCore.AbortSignal)) |signal| {\n                         abort_signal = signal.ref();\n                     } else {\n                         return globalThis.throwInvalidArgumentTypeValue(\"signal\", \"AbortSignal\", signal_val);\n                     }\n                 }\n \n-                if (args.getOwnTruthy(globalThis, \"onDisconnect\")) |onDisconnect_| {\n+                if (args.getTruthy(globalThis, \"onDisconnect\")) |onDisconnect_| {\n                     if (!onDisconnect_.isCell() or !onDisconnect_.isCallable(globalThis.vm())) {\n                         globalThis.throwInvalidArguments(\"onDisconnect must be a function or undefined\", .{});\n                         return .zero;\n@@ -1895,7 +1895,7 @@ pub const Subprocess = struct {\n                         onDisconnect_.withAsyncContextIfNeeded(globalThis);\n                 }\n \n-                if (args.getOwnTruthy(globalThis, \"onExit\")) |onExit_| {\n+                if (args.getTruthy(globalThis, \"onExit\")) |onExit_| {\n                     if (!onExit_.isCell() or !onExit_.isCallable(globalThis.vm())) {\n                         globalThis.throwInvalidArguments(\"onExit must be a function or undefined\", .{});\n                         return .zero;\n@@ -1907,7 +1907,7 @@ pub const Subprocess = struct {\n                         onExit_.withAsyncContextIfNeeded(globalThis);\n                 }\n \n-                if (args.getOwnTruthy(globalThis, \"env\")) |object| {\n+                if (args.getTruthy(globalThis, \"env\")) |object| {\n                     if (!object.isObject()) {\n                         globalThis.throwInvalidArguments(\"env must be an object\", .{});\n                         return .zero;\n@@ -1923,7 +1923,7 @@ pub const Subprocess = struct {\n                     };\n                     env_array = envp_managed.moveToUnmanaged();\n                 }\n-                if (args.getOwn(globalThis, \"stdio\")) |stdio_val| {\n+                if (args.get(globalThis, \"stdio\")) |stdio_val| {\n                     if (!stdio_val.isEmptyOrUndefinedOrNull()) {\n                         if (stdio_val.jsType().isArray()) {\n                             var stdio_iter = stdio_val.arrayIterator(globalThis);\n@@ -1962,44 +1962,44 @@ pub const Subprocess = struct {\n                         }\n                     }\n                 } else {\n-                    if (args.getOwn(globalThis, \"stdin\")) |value| {\n+                    if (args.get(globalThis, \"stdin\")) |value| {\n                         if (!stdio[0].extract(globalThis, 0, value))\n                             return .zero;\n                     }\n \n-                    if (args.getOwn(globalThis, \"stderr\")) |value| {\n+                    if (args.get(globalThis, \"stderr\")) |value| {\n                         if (!stdio[2].extract(globalThis, 2, value))\n                             return .zero;\n                     }\n \n-                    if (args.getOwn(globalThis, \"stdout\")) |value| {\n+                    if (args.get(globalThis, \"stdout\")) |value| {\n                         if (!stdio[1].extract(globalThis, 1, value))\n                             return .zero;\n                     }\n                 }\n \n                 if (comptime !is_sync) {\n-                    if (args.getOwn(globalThis, \"lazy\")) |lazy_val| {\n+                    if (args.get(globalThis, \"lazy\")) |lazy_val| {\n                         if (lazy_val.isBoolean()) {\n                             lazy = lazy_val.toBoolean();\n                         }\n                     }\n                 }\n \n-                if (args.getOwn(globalThis, \"detached\")) |detached_val| {\n+                if (args.get(globalThis, \"detached\")) |detached_val| {\n                     if (detached_val.isBoolean()) {\n                         detached = detached_val.toBoolean();\n                     }\n                 }\n \n                 if (Environment.isWindows) {\n-                    if (args.getOwn(globalThis, \"windowsHide\")) |val| {\n+                    if (args.get(globalThis, \"windowsHide\")) |val| {\n                         if (val.isBoolean()) {\n                             windows_hide = val.asBoolean();\n                         }\n                     }\n \n-                    if (args.getOwn(globalThis, \"windowsVerbatimArguments\")) |val| {\n+                    if (args.get(globalThis, \"windowsVerbatimArguments\")) |val| {\n                         if (val.isBoolean()) {\n                             windows_verbatim_arguments = val.asBoolean();\n                         }"
        },
        {
          "filename": "src/bun.js/api/bun/udp_socket.zig",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -129,7 +129,7 @@ pub const UDPSocketConfig = struct {\n         }\n \n         const hostname = brk: {\n-            if (options.getOwnTruthy(globalThis, \"hostname\")) |value| {\n+            if (options.getTruthy(globalThis, \"hostname\")) |value| {\n                 if (!value.isString()) {\n                     globalThis.throwInvalidArguments(\"Expected \\\"hostname\\\" to be a string\", .{});\n                     return null;\n@@ -144,7 +144,7 @@ pub const UDPSocketConfig = struct {\n         defer if (globalThis.hasException()) default_allocator.free(hostname);\n \n         const port: u16 = brk: {\n-            if (options.getOwnTruthy(globalThis, \"port\")) |value| {\n+            if (options.getTruthy(globalThis, \"port\")) |value| {\n                 const number = value.coerceToInt32(globalThis);\n                 if (number < 0 or number > 0xffff) {\n                     globalThis.throwInvalidArguments(\"Expected \\\"port\\\" to be an integer between 0 and 65535\", .{});\n@@ -161,13 +161,13 @@ pub const UDPSocketConfig = struct {\n             .port = port,\n         };\n \n-        if (options.getOwnTruthy(globalThis, \"socket\")) |socket| {\n+        if (options.getTruthy(globalThis, \"socket\")) |socket| {\n             if (!socket.isObject()) {\n                 globalThis.throwInvalidArguments(\"Expected \\\"socket\\\" to be an object\", .{});\n                 return null;\n             }\n \n-            if (options.getOwnTruthy(globalThis, \"binaryType\")) |value| {\n+            if (options.getTruthy(globalThis, \"binaryType\")) |value| {\n                 if (!value.isString()) {\n                     globalThis.throwInvalidArguments(\"Expected \\\"socket.binaryType\\\" to be a string\", .{});\n                     return null;\n@@ -180,7 +180,7 @@ pub const UDPSocketConfig = struct {\n             }\n \n             inline for (handlers) |handler| {\n-                if (socket.getOwnTruthyComptime(globalThis, handler.@\"0\")) |value| {\n+                if (socket.getTruthyComptime(globalThis, handler.@\"0\")) |value| {\n                     if (!value.isCell() or !value.isCallable(globalThis.vm())) {\n                         globalThis.throwInvalidArguments(\"Expected \\\"socket.{s}\\\" to be a function\", .{handler.@\"0\"});\n                         return null;\n@@ -198,13 +198,13 @@ pub const UDPSocketConfig = struct {\n             }\n         }\n \n-        if (options.getOwnTruthy(globalThis, \"connect\")) |connect| {\n+        if (options.getTruthy(globalThis, \"connect\")) |connect| {\n             if (!connect.isObject()) {\n                 globalThis.throwInvalidArguments(\"Expected \\\"connect\\\" to be an object\", .{});\n                 return null;\n             }\n \n-            const connect_host_js = connect.getOwnTruthy(globalThis, \"hostname\") orelse {\n+            const connect_host_js = connect.getTruthy(globalThis, \"hostname\") orelse {\n                 globalThis.throwInvalidArguments(\"Expected \\\"connect.hostname\\\" to be a string\", .{});\n                 return null;\n             };\n@@ -214,7 +214,7 @@ pub const UDPSocketConfig = struct {\n                 return null;\n             }\n \n-            const connect_port_js = connect.getOwnTruthy(globalThis, \"port\") orelse {\n+            const connect_port_js = connect.getTruthy(globalThis, \"port\") orelse {\n                 globalThis.throwInvalidArguments(\"Expected \\\"connect.port\\\" to be an integer\", .{});\n                 return null;\n             };"
        },
        {
          "filename": "src/bun.js/api/ffi.zig",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -655,7 +655,7 @@ pub const FFI = struct {\n             return .zero;\n         }\n \n-        if (object.getOwnTruthy(globalThis, \"flags\")) |flags_value| {\n+        if (object.getTruthy(globalThis, \"flags\")) |flags_value| {\n             if (flags_value.isArray()) {\n                 var iter = flags_value.arrayIterator(globalThis);\n \n@@ -692,7 +692,7 @@ pub const FFI = struct {\n             return .zero;\n         }\n \n-        if (object.getOwnTruthy(globalThis, \"define\")) |define_value| {\n+        if (object.getTruthy(globalThis, \"define\")) |define_value| {\n             if (define_value.isObject()) {\n                 const Iter = JSC.JSPropertyIterator(.{ .include_value = true, .skip_empty_name = true });\n                 var iter = Iter.init(globalThis, define_value);\n@@ -722,7 +722,7 @@ pub const FFI = struct {\n             return .zero;\n         }\n \n-        if (object.getOwnTruthy(globalThis, \"include\")) |include_value| {\n+        if (object.getTruthy(globalThis, \"include\")) |include_value| {\n             compile_c.include_dirs = StringArray.fromJS(globalThis, include_value, \"include\");\n         }\n \n@@ -1347,11 +1347,11 @@ pub const FFI = struct {\n \n         var threadsafe = false;\n \n-        if (value.getOwnTruthy(global, \"threadsafe\")) |threadsafe_value| {\n+        if (value.getTruthy(global, \"threadsafe\")) |threadsafe_value| {\n             threadsafe = threadsafe_value.toBoolean();\n         }\n \n-        if (value.getOwnTruthy(global, \"returns\")) |ret_value| brk: {\n+        if (value.getTruthy(global, \"returns\")) |ret_value| brk: {\n             if (ret_value.isAnyInt()) {\n                 const int = ret_value.toInt32();\n                 switch (int) {"
        },
        {
          "filename": "src/bun.js/api/filesystem_router.zig",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -69,7 +69,7 @@ pub const FileSystemRouter = struct {\n         var asset_prefix_slice: ZigString.Slice = .{};\n \n         var out_buf: [bun.MAX_PATH_BYTES * 2]u8 = undefined;\n-        if (argument.getOwn(globalThis, \"style\")) |style_val| {\n+        if (argument.get(globalThis, \"style\")) |style_val| {\n             if (!style_val.getZigString(globalThis).eqlComptime(\"nextjs\")) {\n                 globalThis.throwInvalidArguments(\"Only 'nextjs' style is currently implemented\", .{});\n                 return null;\n@@ -79,7 +79,7 @@ pub const FileSystemRouter = struct {\n             return null;\n         }\n \n-        if (argument.getOwn(globalThis, \"dir\")) |dir| {\n+        if (argument.get(globalThis, \"dir\")) |dir| {\n             if (!dir.isString()) {\n                 globalThis.throwInvalidArguments(\"Expected dir to be a string\", .{});\n                 return null;\n@@ -104,7 +104,7 @@ pub const FileSystemRouter = struct {\n         arena.* = bun.ArenaAllocator.init(globalThis.allocator());\n         const allocator = arena.allocator();\n         var extensions = std.ArrayList(string).init(allocator);\n-        if (argument.getOwn(globalThis, \"fileExtensions\")) |file_extensions| {\n+        if (argument.get(globalThis, \"fileExtensions\")) |file_extensions| {\n             if (!file_extensions.jsType().isArray()) {\n                 globalThis.throwInvalidArguments(\"Expected fileExtensions to be an Array\", .{});\n                 origin_str.deinit();\n@@ -128,7 +128,7 @@ pub const FileSystemRouter = struct {\n             }\n         }\n \n-        if (argument.getOwnTruthy(globalThis, \"assetPrefix\")) |asset_prefix| {\n+        if (argument.getTruthy(globalThis, \"assetPrefix\")) |asset_prefix| {\n             if (!asset_prefix.isString()) {\n                 globalThis.throwInvalidArguments(\"Expected assetPrefix to be a string\", .{});\n                 origin_str.deinit();\n@@ -174,7 +174,7 @@ pub const FileSystemRouter = struct {\n             return null;\n         };\n \n-        if (argument.getOwn(globalThis, \"origin\")) |origin| {\n+        if (argument.get(globalThis, \"origin\")) |origin| {\n             if (!origin.isString()) {\n                 globalThis.throwInvalidArguments(\"Expected origin to be a string\", .{});\n                 arena.deinit();"
        },
        {
          "filename": "src/bun.js/api/glob.zig",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -120,23 +120,23 @@ const ScanOpts = struct {\n             return null;\n         }\n \n-        if (optsObj.getOwnTruthy(globalThis, \"onlyFiles\")) |only_files| {\n+        if (optsObj.getTruthy(globalThis, \"onlyFiles\")) |only_files| {\n             out.only_files = if (only_files.isBoolean()) only_files.asBoolean() else false;\n         }\n \n-        if (optsObj.getOwnTruthy(globalThis, \"throwErrorOnBrokenSymlink\")) |error_on_broken| {\n+        if (optsObj.getTruthy(globalThis, \"throwErrorOnBrokenSymlink\")) |error_on_broken| {\n             out.error_on_broken_symlinks = if (error_on_broken.isBoolean()) error_on_broken.asBoolean() else false;\n         }\n \n-        if (optsObj.getOwnTruthy(globalThis, \"followSymlinks\")) |followSymlinksVal| {\n+        if (optsObj.getTruthy(globalThis, \"followSymlinks\")) |followSymlinksVal| {\n             out.follow_symlinks = if (followSymlinksVal.isBoolean()) followSymlinksVal.asBoolean() else false;\n         }\n \n-        if (optsObj.getOwnTruthy(globalThis, \"absolute\")) |absoluteVal| {\n+        if (optsObj.getTruthy(globalThis, \"absolute\")) |absoluteVal| {\n             out.absolute = if (absoluteVal.isBoolean()) absoluteVal.asBoolean() else false;\n         }\n \n-        if (optsObj.getOwnTruthy(globalThis, \"cwd\")) |cwdVal| {\n+        if (optsObj.getTruthy(globalThis, \"cwd\")) |cwdVal| {\n             if (!cwdVal.isString()) {\n                 globalThis.throw(\"{s}: invalid `cwd`, not a string\", .{fnName});\n                 return null;\n@@ -152,7 +152,7 @@ const ScanOpts = struct {\n             }\n         }\n \n-        if (optsObj.getOwnTruthy(globalThis, \"dot\")) |dot| {\n+        if (optsObj.getTruthy(globalThis, \"dot\")) |dot| {\n             out.dot = if (dot.isBoolean()) dot.asBoolean() else false;\n         }\n "
        },
        {
          "filename": "src/bun.js/api/server.zig",
          "status": "modified",
          "additions": 46,
          "deletions": 46,
          "patch": "@@ -764,7 +764,7 @@ pub const ServerConfig = struct {\n             result.reject_unauthorized = @intFromBool(vm.getTLSRejectUnauthorized());\n \n             // Required\n-            if (obj.getOwnTruthy(global, \"keyFile\")) |key_file_name| {\n+            if (obj.getTruthy(global, \"keyFile\")) |key_file_name| {\n                 var sliced = key_file_name.toSlice(global, bun.default_allocator);\n                 defer sliced.deinit();\n                 if (sliced.len > 0) {\n@@ -780,7 +780,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"key\")) |js_obj| {\n+            if (obj.getTruthy(global, \"key\")) |js_obj| {\n                 if (js_obj.jsType().isArray()) {\n                     const count = js_obj.getLength(global);\n                     if (count > 0) {\n@@ -863,7 +863,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"certFile\")) |cert_file_name| {\n+            if (obj.getTruthy(global, \"certFile\")) |cert_file_name| {\n                 var sliced = cert_file_name.toSlice(global, bun.default_allocator);\n                 defer sliced.deinit();\n                 if (sliced.len > 0) {\n@@ -878,7 +878,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"ALPNProtocols\")) |protocols| {\n+            if (obj.getTruthy(global, \"ALPNProtocols\")) |protocols| {\n                 if (JSC.Node.StringOrBuffer.fromJS(global, arena.allocator(), protocols)) |sb| {\n                     defer sb.deinit();\n                     const sliced = sb.slice();\n@@ -896,7 +896,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"cert\")) |js_obj| {\n+            if (obj.getTruthy(global, \"cert\")) |js_obj| {\n                 if (js_obj.jsType().isArray()) {\n                     const count = js_obj.getLength(global);\n                     if (count > 0) {\n@@ -979,7 +979,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"requestCert\")) |request_cert| {\n+            if (obj.getTruthy(global, \"requestCert\")) |request_cert| {\n                 if (request_cert.isBoolean()) {\n                     result.request_cert = if (request_cert.asBoolean()) 1 else 0;\n                     any = true;\n@@ -990,7 +990,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"rejectUnauthorized\")) |reject_unauthorized| {\n+            if (obj.getTruthy(global, \"rejectUnauthorized\")) |reject_unauthorized| {\n                 if (reject_unauthorized.isBoolean()) {\n                     result.reject_unauthorized = if (reject_unauthorized.asBoolean()) 1 else 0;\n                     any = true;\n@@ -1001,7 +1001,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"ciphers\")) |ssl_ciphers| {\n+            if (obj.getTruthy(global, \"ciphers\")) |ssl_ciphers| {\n                 var sliced = ssl_ciphers.toSlice(global, bun.default_allocator);\n                 defer sliced.deinit();\n                 if (sliced.len > 0) {\n@@ -1011,7 +1011,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"serverName\") orelse obj.getOwnTruthy(global, \"servername\")) |server_name| {\n+            if (obj.getTruthy(global, \"serverName\") orelse obj.getTruthy(global, \"servername\")) |server_name| {\n                 var sliced = server_name.toSlice(global, bun.default_allocator);\n                 defer sliced.deinit();\n                 if (sliced.len > 0) {\n@@ -1021,7 +1021,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"ca\")) |js_obj| {\n+            if (obj.getTruthy(global, \"ca\")) |js_obj| {\n                 if (js_obj.jsType().isArray()) {\n                     const count = js_obj.getLength(global);\n                     if (count > 0) {\n@@ -1104,7 +1104,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (obj.getOwnTruthy(global, \"caFile\")) |ca_file_name| {\n+            if (obj.getTruthy(global, \"caFile\")) |ca_file_name| {\n                 var sliced = ca_file_name.toSlice(global, bun.default_allocator);\n                 defer sliced.deinit();\n                 if (sliced.len > 0) {\n@@ -1118,25 +1118,25 @@ pub const ServerConfig = struct {\n             }\n             // Optional\n             if (any) {\n-                if (obj.getOwnTruthy(global, \"secureOptions\")) |secure_options| {\n+                if (obj.getTruthy(global, \"secureOptions\")) |secure_options| {\n                     if (secure_options.isNumber()) {\n                         result.secure_options = secure_options.toU32();\n                     }\n                 }\n \n-                if (obj.getOwnTruthy(global, \"clientRenegotiationLimit\")) |client_renegotiation_limit| {\n+                if (obj.getTruthy(global, \"clientRenegotiationLimit\")) |client_renegotiation_limit| {\n                     if (client_renegotiation_limit.isNumber()) {\n                         result.client_renegotiation_limit = client_renegotiation_limit.toU32();\n                     }\n                 }\n \n-                if (obj.getOwnTruthy(global, \"clientRenegotiationWindow\")) |client_renegotiation_window| {\n+                if (obj.getTruthy(global, \"clientRenegotiationWindow\")) |client_renegotiation_window| {\n                     if (client_renegotiation_window.isNumber()) {\n                         result.client_renegotiation_window = client_renegotiation_window.toU32();\n                     }\n                 }\n \n-                if (obj.getOwnTruthy(global, \"dhParamsFile\")) |dh_params_file_name| {\n+                if (obj.getTruthy(global, \"dhParamsFile\")) |dh_params_file_name| {\n                     var sliced = dh_params_file_name.toSlice(global, bun.default_allocator);\n                     defer sliced.deinit();\n                     if (sliced.len > 0) {\n@@ -1149,15 +1149,15 @@ pub const ServerConfig = struct {\n                     }\n                 }\n \n-                if (obj.getOwnTruthy(global, \"passphrase\")) |passphrase| {\n+                if (obj.getTruthy(global, \"passphrase\")) |passphrase| {\n                     var sliced = passphrase.toSlice(global, bun.default_allocator);\n                     defer sliced.deinit();\n                     if (sliced.len > 0) {\n                         result.passphrase = bun.default_allocator.dupeZ(u8, sliced.slice()) catch unreachable;\n                     }\n                 }\n \n-                if (obj.getOwn(global, \"lowMemoryMode\")) |low_memory_mode| {\n+                if (obj.get(global, \"lowMemoryMode\")) |low_memory_mode| {\n                     if (low_memory_mode.isBoolean() or low_memory_mode.isUndefined()) {\n                         result.low_memory_mode = low_memory_mode.toBoolean();\n                         any = true;\n@@ -1240,7 +1240,7 @@ pub const ServerConfig = struct {\n                 return args;\n             }\n \n-            if (arg.getOwn(global, \"static\")) |static| {\n+            if (arg.get(global, \"static\")) |static| {\n                 if (!static.isObject()) {\n                     JSC.throwInvalidArguments(\"Bun.serve expects 'static' to be an object shaped like { [pathname: string]: Response }\", .{}, global, exception);\n                     return args;\n@@ -1285,7 +1285,7 @@ pub const ServerConfig = struct {\n \n             if (global.hasException()) return args;\n \n-            if (arg.getOwn(global, \"idleTimeout\")) |value| {\n+            if (arg.get(global, \"idleTimeout\")) |value| {\n                 if (!value.isUndefinedOrNull()) {\n                     if (!value.isAnyInt()) {\n                         JSC.throwInvalidArguments(\"Bun.serve expects idleTimeout to be an integer\", .{}, global, exception);\n@@ -1303,7 +1303,7 @@ pub const ServerConfig = struct {\n                 }\n             }\n \n-            if (arg.getOwnTruthy(global, \"webSocket\") orelse arg.getOwnTruthy(global, \"websocket\")) |websocket_object| {\n+            if (arg.getTruthy(global, \"webSocket\") orelse arg.getTruthy(global, \"websocket\")) |websocket_object| {\n                 if (!websocket_object.isObject()) {\n                     JSC.throwInvalidArguments(\"Expected websocket to be an object\", .{}, global, exception);\n                     if (args.ssl_config) |*conf| {\n@@ -1323,7 +1323,7 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwnTruthy(global, \"port\")) |port_| {\n+            if (arg.getTruthy(global, \"port\")) |port_| {\n                 args.address.tcp.port = @as(\n                     u16,\n                     @intCast(@min(\n@@ -1335,7 +1335,7 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwnTruthy(global, \"baseURI\")) |baseURI| {\n+            if (arg.getTruthy(global, \"baseURI\")) |baseURI| {\n                 var sliced = baseURI.toSlice(global, bun.default_allocator);\n \n                 if (sliced.len > 0) {\n@@ -1345,7 +1345,7 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwnTruthy(global, \"hostname\") orelse arg.getOwnTruthy(global, \"host\")) |host| {\n+            if (arg.getTruthy(global, \"hostname\") orelse arg.getTruthy(global, \"host\")) |host| {\n                 const host_str = host.toSlice(\n                     global,\n                     bun.default_allocator,\n@@ -1359,7 +1359,7 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwnTruthy(global, \"unix\")) |unix| {\n+            if (arg.getTruthy(global, \"unix\")) |unix| {\n                 const unix_str = unix.toSlice(\n                     global,\n                     bun.default_allocator,\n@@ -1376,7 +1376,7 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwn(global, \"id\")) |id| {\n+            if (arg.get(global, \"id\")) |id| {\n                 if (id.isUndefinedOrNull()) {\n                     args.allow_hot = false;\n                 } else {\n@@ -1394,18 +1394,18 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwn(global, \"development\")) |dev| {\n+            if (arg.get(global, \"development\")) |dev| {\n                 args.development = dev.coerce(bool, global);\n                 args.reuse_port = !args.development;\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwn(global, \"reusePort\")) |dev| {\n+            if (arg.get(global, \"reusePort\")) |dev| {\n                 args.reuse_port = dev.coerce(bool, global);\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwn(global, \"inspector\")) |inspector| {\n+            if (arg.get(global, \"inspector\")) |inspector| {\n                 args.inspector = inspector.coerce(bool, global);\n \n                 if (args.inspector and !args.development) {\n@@ -1415,14 +1415,14 @@ pub const ServerConfig = struct {\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwnTruthy(global, \"maxRequestBodySize\")) |max_request_body_size| {\n+            if (arg.getTruthy(global, \"maxRequestBodySize\")) |max_request_body_size| {\n                 if (max_request_body_size.isNumber()) {\n                     args.max_request_body_size = @as(u64, @intCast(@max(0, max_request_body_size.toInt64())));\n                 }\n             }\n             if (global.hasException()) return args;\n \n-            if (arg.getOwnTruthyComptime(global, \"error\")) |onError| {\n+            if (arg.getTruthyComptime(global, \"error\")) |onError| {\n                 if (!onError.isCallable(global.vm())) {\n                     JSC.throwInvalidArguments(\"Expected error to be a function\", .{}, global, exception);\n                     return args;\n@@ -4191,7 +4191,7 @@ pub const WebSocketServer = struct {\n \n             var valid = false;\n \n-            if (object.getOwnTruthyComptime(globalObject, \"message\")) |message_| {\n+            if (object.getTruthyComptime(globalObject, \"message\")) |message_| {\n                 if (!message_.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the message option\", .{});\n                     return null;\n@@ -4202,7 +4202,7 @@ pub const WebSocketServer = struct {\n                 valid = true;\n             }\n \n-            if (object.getOwnTruthy(globalObject, \"open\")) |open_| {\n+            if (object.getTruthy(globalObject, \"open\")) |open_| {\n                 if (!open_.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the open option\", .{});\n                     return null;\n@@ -4213,7 +4213,7 @@ pub const WebSocketServer = struct {\n                 valid = true;\n             }\n \n-            if (object.getOwnTruthy(globalObject, \"close\")) |close_| {\n+            if (object.getTruthy(globalObject, \"close\")) |close_| {\n                 if (!close_.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the close option\", .{});\n                     return null;\n@@ -4224,7 +4224,7 @@ pub const WebSocketServer = struct {\n                 valid = true;\n             }\n \n-            if (object.getOwnTruthy(globalObject, \"drain\")) |drain_| {\n+            if (object.getTruthy(globalObject, \"drain\")) |drain_| {\n                 if (!drain_.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the drain option\", .{});\n                     return null;\n@@ -4235,7 +4235,7 @@ pub const WebSocketServer = struct {\n                 valid = true;\n             }\n \n-            if (object.getOwnTruthy(globalObject, \"onError\")) |onError_| {\n+            if (object.getTruthy(globalObject, \"onError\")) |onError_| {\n                 if (!onError_.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the onError option\", .{});\n                     return null;\n@@ -4245,7 +4245,7 @@ pub const WebSocketServer = struct {\n                 onError.ensureStillAlive();\n             }\n \n-            if (object.getOwnTruthy(globalObject, \"ping\")) |cb| {\n+            if (object.getTruthy(globalObject, \"ping\")) |cb| {\n                 if (!cb.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the ping option\", .{});\n                     return null;\n@@ -4255,7 +4255,7 @@ pub const WebSocketServer = struct {\n                 valid = true;\n             }\n \n-            if (object.getOwnTruthy(globalObject, \"pong\")) |cb| {\n+            if (object.getTruthy(globalObject, \"pong\")) |cb| {\n                 if (!cb.isCallable(vm)) {\n                     globalObject.throwInvalidArguments(\"websocket expects a function for the pong option\", .{});\n                     return null;\n@@ -4354,7 +4354,7 @@ pub const WebSocketServer = struct {\n             return null;\n         }\n \n-        if (object.getOwn(globalObject, \"perMessageDeflate\")) |per_message_deflate| {\n+        if (object.get(globalObject, \"perMessageDeflate\")) |per_message_deflate| {\n             getter: {\n                 if (per_message_deflate.isUndefined()) {\n                     break :getter;\n@@ -4369,7 +4369,7 @@ pub const WebSocketServer = struct {\n                     break :getter;\n                 }\n \n-                if (per_message_deflate.getOwnTruthy(globalObject, \"compress\")) |compression| {\n+                if (per_message_deflate.getTruthy(globalObject, \"compress\")) |compression| {\n                     if (compression.isBoolean()) {\n                         server.compression |= if (compression.toBoolean()) uws.SHARED_COMPRESSOR else 0;\n                     } else if (compression.isString()) {\n@@ -4389,7 +4389,7 @@ pub const WebSocketServer = struct {\n                     }\n                 }\n \n-                if (per_message_deflate.getOwnTruthy(globalObject, \"decompress\")) |compression| {\n+                if (per_message_deflate.getTruthy(globalObject, \"decompress\")) |compression| {\n                     if (compression.isBoolean()) {\n                         server.compression |= if (compression.toBoolean()) uws.SHARED_DECOMPRESSOR else 0;\n                     } else if (compression.isString()) {\n@@ -4411,7 +4411,7 @@ pub const WebSocketServer = struct {\n             }\n         }\n \n-        if (object.getOwn(globalObject, \"maxPayloadLength\")) |value| {\n+        if (object.get(globalObject, \"maxPayloadLength\")) |value| {\n             if (!value.isUndefinedOrNull()) {\n                 if (!value.isAnyInt()) {\n                     globalObject.throwInvalidArguments(\"websocket expects maxPayloadLength to be an integer\", .{});\n@@ -4421,7 +4421,7 @@ pub const WebSocketServer = struct {\n             }\n         }\n \n-        if (object.getOwn(globalObject, \"idleTimeout\")) |value| {\n+        if (object.get(globalObject, \"idleTimeout\")) |value| {\n             if (!value.isUndefinedOrNull()) {\n                 if (!value.isAnyInt()) {\n                     globalObject.throwInvalidArguments(\"websocket expects idleTimeout to be an integer\", .{});\n@@ -4441,7 +4441,7 @@ pub const WebSocketServer = struct {\n                 server.idleTimeout = idleTimeout;\n             }\n         }\n-        if (object.getOwn(globalObject, \"backpressureLimit\")) |value| {\n+        if (object.get(globalObject, \"backpressureLimit\")) |value| {\n             if (!value.isUndefinedOrNull()) {\n                 if (!value.isAnyInt()) {\n                     globalObject.throwInvalidArguments(\"websocket expects backpressureLimit to be an integer\", .{});\n@@ -4452,7 +4452,7 @@ pub const WebSocketServer = struct {\n             }\n         }\n \n-        if (object.getOwn(globalObject, \"closeOnBackpressureLimit\")) |value| {\n+        if (object.get(globalObject, \"closeOnBackpressureLimit\")) |value| {\n             if (!value.isUndefinedOrNull()) {\n                 if (!value.isBoolean()) {\n                     globalObject.throwInvalidArguments(\"websocket expects closeOnBackpressureLimit to be a boolean\", .{});\n@@ -4463,7 +4463,7 @@ pub const WebSocketServer = struct {\n             }\n         }\n \n-        if (object.getOwn(globalObject, \"sendPings\")) |value| {\n+        if (object.get(globalObject, \"sendPings\")) |value| {\n             if (!value.isUndefinedOrNull()) {\n                 if (!value.isBoolean()) {\n                     globalObject.throwInvalidArguments(\"websocket expects sendPings to be a boolean\", .{});\n@@ -4474,7 +4474,7 @@ pub const WebSocketServer = struct {\n             }\n         }\n \n-        if (object.getOwn(globalObject, \"publishToSelf\")) |value| {\n+        if (object.get(globalObject, \"publishToSelf\")) |value| {\n             if (!value.isUndefinedOrNull()) {\n                 if (!value.isBoolean()) {\n                     globalObject.throwInvalidArguments(\"websocket expects publishToSelf to be a boolean\", .{});"
        },
        {
          "filename": "src/bun.js/base.zig",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1103,7 +1103,7 @@ pub fn wrapInstanceMethod(\n                     },\n                     ?JSC.Cloudflare.ContentOptions => {\n                         if (iter.nextEat()) |content_arg| {\n-                            if (content_arg.getOwn(globalThis.ptr(), \"html\")) |html_val| {\n+                            if (content_arg.get(globalThis.ptr(), \"html\")) |html_val| {\n                                 args[i] = .{ .html = html_val.toBoolean() };\n                             }\n                         } else {\n@@ -1267,7 +1267,7 @@ pub fn wrapStaticMethod(\n                     },\n                     ?JSC.Cloudflare.ContentOptions => {\n                         if (iter.nextEat()) |content_arg| {\n-                            if (content_arg.getOwn(globalThis.ptr(), \"html\")) |html_val| {\n+                            if (content_arg.get(globalThis.ptr(), \"html\")) |html_val| {\n                                 args[i] = .{ .html = html_val.toBoolean() };\n                             }\n                         } else {"
        },
        {
          "filename": "src/bun.js/bindings/ObjectBindings.cpp",
          "status": "added",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -0,0 +1,76 @@\n+#include \"root.h\"\n+#include <JavaScriptCore/JSObject.h>\n+#include <JavaScriptCore/JSObjectInlines.h>\n+#include <JavaScriptCore/PropertySlot.h>\n+#include <JavaScriptCore/JSGlobalObject.h>\n+\n+namespace Bun {\n+\n+using namespace JSC;\n+\n+static bool getNonIndexPropertySlotPrototypePollutionMitigation(JSC::VM& vm, JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)\n+{\n+    // This method only supports non-index PropertyNames.\n+    ASSERT(!parseIndex(propertyName));\n+\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    JSObject* objectPrototype = nullptr;\n+    while (true) {\n+        Structure* structure = object->structureID().decode();\n+        if (LIKELY(!TypeInfo::overridesGetOwnPropertySlot(object->inlineTypeFlags()))) {\n+            if (object->getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))\n+                return true;\n+        } else {\n+            bool hasSlot = structure->classInfoForCells()->methodTable.getOwnPropertySlot(object, globalObject, propertyName, slot);\n+            RETURN_IF_EXCEPTION(scope, false);\n+            if (hasSlot)\n+                return true;\n+            if (UNLIKELY(slot.isVMInquiry() && slot.isTaintedByOpaqueObject()))\n+                return false;\n+            if (object->type() == ProxyObjectType && slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)\n+                return false;\n+        }\n+        JSValue prototype;\n+        if (LIKELY(!structure->typeInfo().overridesGetPrototype() || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))\n+            prototype = object->getPrototypeDirect();\n+        else {\n+            prototype = object->getPrototype(vm, globalObject);\n+            RETURN_IF_EXCEPTION(scope, false);\n+        }\n+        if (!prototype.isObject())\n+            return false;\n+        object = asObject(prototype);\n+        // -- If we reach the object prototype, we stop.\n+        if (objectPrototype == nullptr) {\n+            objectPrototype = globalObject->objectPrototype();\n+        }\n+        if (object == objectPrototype) {\n+            return false;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+JSC::JSValue getIfPropertyExistsPrototypePollutionMitigation(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSObject* object, const JSC::PropertyName& name)\n+{\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    auto propertySlot = PropertySlot(object, PropertySlot::InternalMethodType::HasProperty);\n+    auto isDefined = getNonIndexPropertySlotPrototypePollutionMitigation(vm, object, globalObject, name, propertySlot);\n+\n+    if (!isDefined) {\n+        return {};\n+    }\n+\n+    scope.assertNoException();\n+    JSValue value = propertySlot.getValue(globalObject, name);\n+    RETURN_IF_EXCEPTION(scope, {});\n+    return value;\n+}\n+\n+JSC::JSValue getIfPropertyExistsPrototypePollutionMitigation(JSC::JSGlobalObject* globalObject, JSC::JSObject* object, const JSC::PropertyName& name)\n+{\n+    return getIfPropertyExistsPrototypePollutionMitigation(JSC::getVM(globalObject), globalObject, object, name);\n+}\n+\n+}"
        },
        {
          "filename": "src/bun.js/bindings/ObjectBindings.h",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+#pragma once\n+\n+namespace Bun {\n+\n+JSC::JSValue getIfPropertyExistsPrototypePollutionMitigation(JSC::JSGlobalObject* globalObject, JSC::JSObject* object, const JSC::PropertyName& name);\n+\n+/**\n+ * This is `JSObject::getIfPropertyExists`, except it stops when it reaches globalObject->objectPrototype().\n+ *\n+ * This means that for a prototype pollution attack to work, they would need to modify the specific prototype instead of the generic one shared by most objects.\n+ *\n+ * This method also does not support index properties.\n+ */\n+JSC::JSValue getIfPropertyExistsPrototypePollutionMitigation(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSObject* object, const JSC::PropertyName& name);\n+\n+}"
        },
        {
          "filename": "src/bun.js/bindings/bindings.cpp",
          "status": "modified",
          "additions": 6,
          "deletions": 4,
          "patch": "@@ -123,6 +123,7 @@\n #include \"JavaScriptCore/CustomGetterSetter.h\"\n \n #include \"ErrorStackFrame.h\"\n+#include \"ObjectBindings.h\"\n \n #if OS(DARWIN)\n #if BUN_DEBUG\n@@ -3708,23 +3709,24 @@ JSC__JSValue JSC__JSValue__getIfPropertyExistsImpl(JSC__JSValue JSValue0,\n     const auto identifier = JSC::Identifier::fromString(vm, propertyString);\n     const auto property = JSC::PropertyName(identifier);\n \n-    return JSC::JSValue::encode(object->getIfPropertyExists(globalObject, property));\n+    return JSC::JSValue::encode(Bun::getIfPropertyExistsPrototypePollutionMitigation(vm, globalObject, object, property));\n }\n \n extern \"C\" JSC__JSValue JSC__JSValue__getIfPropertyExistsImplString(JSC__JSValue JSValue0, JSC__JSGlobalObject* globalObject, BunString* propertyName)\n {\n     ASSERT_NO_PENDING_EXCEPTION(globalObject);\n     JSValue value = JSC::JSValue::decode(JSValue0);\n-    if (UNLIKELY(!value.isObject()))\n+    JSC::JSObject* object = value.getObject();\n+    if (UNLIKELY(!object))\n         return JSValue::encode({});\n \n     JSC::VM& vm = globalObject->vm();\n-    JSC::JSObject* object = value.getObject();\n+\n     WTF::String propertyNameString = propertyName->tag == BunStringTag::Empty ? WTF::String(\"\"_s) : propertyName->toWTFString(BunString::ZeroCopy);\n     auto identifier = JSC::Identifier::fromString(vm, propertyNameString);\n     auto property = JSC::PropertyName(identifier);\n \n-    return JSC::JSValue::encode(object->getIfPropertyExists(globalObject, property));\n+    return JSC::JSValue::encode(Bun::getIfPropertyExistsPrototypePollutionMitigation(vm, globalObject, object, property));\n }\n \n extern \"C\" JSC__JSValue JSC__JSValue__getOwn(JSC__JSValue JSValue0, JSC__JSGlobalObject* globalObject, BunString* propertyName)"
        },
        {
          "filename": "src/bun.js/modules/NodeModuleModule.h",
          "status": "modified",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -22,11 +22,6 @@ namespace Bun {\n   void addNodeModuleConstructorProperties(JSC::VM &vm, Zig::GlobalObject *globalObject);\n }\n \n-\n-\n-\n-\n-\n namespace Zig {\n \n void generateNativeModule_NodeModule(                                     "
        },
        {
          "filename": "src/bun.js/webcore.zig",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -403,7 +403,7 @@ pub const Crypto = struct {\n                 return .zero;\n             }\n \n-            if (options_value.getOwnTruthy(globalThis, \"cost\") orelse options_value.getOwnTruthy(globalThis, \"N\")) |N_value| {\n+            if (options_value.getTruthy(globalThis, \"cost\") orelse options_value.getTruthy(globalThis, \"N\")) |N_value| {\n                 if (cost != null) return throwInvalidParameter(globalThis);\n                 const N_int = N_value.to(i64);\n                 if (N_int < 0 or !N_value.isNumber()) {\n@@ -418,7 +418,7 @@ pub const Crypto = struct {\n                 }\n             }\n \n-            if (options_value.getOwnTruthy(globalThis, \"blockSize\") orelse options_value.getOwn(globalThis, \"r\")) |r_value| {\n+            if (options_value.getTruthy(globalThis, \"blockSize\") orelse options_value.getTruthy(globalThis, \"r\")) |r_value| {\n                 if (blockSize != null) return throwInvalidParameter(globalThis);\n                 const r_int = r_value.to(i64);\n                 if (r_int < 0 or !r_value.isNumber()) {\n@@ -433,7 +433,7 @@ pub const Crypto = struct {\n                 }\n             }\n \n-            if (options_value.getOwnTruthy(globalThis, \"parallelization\") orelse options_value.getOwn(globalThis, \"p\")) |p_value| {\n+            if (options_value.getTruthy(globalThis, \"parallelization\") orelse options_value.getTruthy(globalThis, \"p\")) |p_value| {\n                 if (parallelization != null) return throwInvalidParameter(globalThis);\n                 const p_int = p_value.to(i64);\n                 if (p_int < 0 or !p_value.isNumber()) {\n@@ -448,7 +448,7 @@ pub const Crypto = struct {\n                 }\n             }\n \n-            if (options_value.getOwnTruthy(globalThis, \"maxmem\")) |value| {\n+            if (options_value.getTruthy(globalThis, \"maxmem\")) |value| {\n                 const p_int = value.to(i64);\n                 if (p_int < 0 or !value.isNumber()) {\n                     return throwInvalidParams("
        },
        {
          "filename": "src/bun.js/webcore/blob.zig",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1018,7 +1018,7 @@ pub const Blob = struct {\n \n         if (args.nextEat()) |options_object| {\n             if (options_object.isObject()) {\n-                if (options_object.getOwnTruthy(globalThis, \"createPath\")) |create_directory| {\n+                if (options_object.getTruthy(globalThis, \"createPath\")) |create_directory| {\n                     if (!create_directory.isBoolean()) {\n                         globalThis.throwInvalidArgumentType(\"write\", \"options.createPath\", \"boolean\");\n                         return .zero;"
        },
        {
          "filename": "src/bun.js/webcore/streams.zig",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -533,7 +533,7 @@ pub const StreamStart = union(Tag) {\n             return .{ .empty = {} };\n         }\n \n-        if (value.getOwn(globalThis, \"chunkSize\")) |chunkSize| {\n+        if (value.get(globalThis, \"chunkSize\")) |chunkSize| {\n             if (chunkSize.isNumber())\n                 return .{ .chunk_size = @as(Blob.SizeType, @intCast(@as(i52, @truncate(chunkSize.toInt64())))) };\n         }"
        },
        {
          "filename": "src/bundler.zig",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -166,7 +166,7 @@ pub const PluginRunner = struct {\n             bun.String.init(importer),\n             target,\n         ) orelse return null;\n-        const path_value = on_resolve_plugin.getOwn(global, \"path\") orelse return null;\n+        const path_value = on_resolve_plugin.get(global, \"path\") orelse return null;\n         if (path_value.isEmptyOrUndefinedOrNull()) return null;\n         if (!path_value.isString()) {\n             log.addError(null, loc, \"Expected \\\"path\\\" to be a string\") catch unreachable;\n@@ -199,7 +199,7 @@ pub const PluginRunner = struct {\n         }\n         var static_namespace = true;\n         const user_namespace: bun.String = brk: {\n-            if (on_resolve_plugin.getOwn(global, \"namespace\")) |namespace_value| {\n+            if (on_resolve_plugin.get(global, \"namespace\")) |namespace_value| {\n                 if (!namespace_value.isString()) {\n                     log.addError(null, loc, \"Expected \\\"namespace\\\" to be a string\") catch unreachable;\n                     return null;\n@@ -265,7 +265,7 @@ pub const PluginRunner = struct {\n             importer,\n             target,\n         ) orelse return null;\n-        const path_value = on_resolve_plugin.getOwn(global, \"path\") orelse return null;\n+        const path_value = on_resolve_plugin.get(global, \"path\") orelse return null;\n         if (path_value.isEmptyOrUndefinedOrNull()) return null;\n         if (!path_value.isString()) {\n             return JSC.ErrorableString.err(\n@@ -295,7 +295,7 @@ pub const PluginRunner = struct {\n         }\n         var static_namespace = true;\n         const user_namespace: bun.String = brk: {\n-            if (on_resolve_plugin.getOwn(global, \"namespace\")) |namespace_value| {\n+            if (on_resolve_plugin.get(global, \"namespace\")) |namespace_value| {\n                 if (!namespace_value.isString()) {\n                     return JSC.ErrorableString.err(\n                         error.JSErrorObject,"
        },
        {
          "filename": "src/css/values/color_js.zig",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -230,17 +230,17 @@ pub fn jsFunctionColor(globalThis: *JSC.JSGlobalObject, callFrame: *JSC.CallFram\n                 },\n             }\n         } else if (args[0].isObject()) {\n-            const r = colorIntFromJS(globalThis, args[0].getOwn(globalThis, \"r\") orelse .zero, \"r\") orelse return .zero;\n+            const r = colorIntFromJS(globalThis, args[0].get(globalThis, \"r\") orelse .zero, \"r\") orelse return .zero;\n \n             if (globalThis.hasException()) {\n                 return .zero;\n             }\n-            const g = colorIntFromJS(globalThis, args[0].getOwn(globalThis, \"g\") orelse .zero, \"g\") orelse return .zero;\n+            const g = colorIntFromJS(globalThis, args[0].get(globalThis, \"g\") orelse .zero, \"g\") orelse return .zero;\n \n             if (globalThis.hasException()) {\n                 return .zero;\n             }\n-            const b = colorIntFromJS(globalThis, args[0].getOwn(globalThis, \"b\") orelse .zero, \"b\") orelse return .zero;\n+            const b = colorIntFromJS(globalThis, args[0].get(globalThis, \"b\") orelse .zero, \"b\") orelse return .zero;\n \n             if (globalThis.hasException()) {\n                 return .zero;"
        },
        {
          "filename": "src/dns.zig",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -74,23 +74,23 @@ pub const GetAddrInfo = struct {\n             if (value.isObject()) {\n                 var options = Options{};\n \n-                if (value.getOwn(globalObject, \"family\")) |family| {\n+                if (value.get(globalObject, \"family\")) |family| {\n                     options.family = try Family.fromJS(family, globalObject);\n                 }\n \n-                if (value.getOwn(globalObject, \"socketType\") orelse value.getOwn(globalObject, \"socktype\")) |socktype| {\n+                if (value.get(globalObject, \"socketType\") orelse value.get(globalObject, \"socktype\")) |socktype| {\n                     options.socktype = try SocketType.fromJS(socktype, globalObject);\n                 }\n \n-                if (value.getOwn(globalObject, \"protocol\")) |protocol| {\n+                if (value.get(globalObject, \"protocol\")) |protocol| {\n                     options.protocol = try Protocol.fromJS(protocol, globalObject);\n                 }\n \n-                if (value.getOwn(globalObject, \"backend\")) |backend| {\n+                if (value.get(globalObject, \"backend\")) |backend| {\n                     options.backend = try Backend.fromJS(backend, globalObject);\n                 }\n \n-                if (value.getOwn(globalObject, \"flags\")) |flags| {\n+                if (value.get(globalObject, \"flags\")) |flags| {\n                     if (!flags.isNumber())\n                         return error.InvalidFlags;\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 8,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5c5793050c058e91a156843ba90aec2a49caa95f",
            "date": "2025-01-14T02:43:18Z",
            "author_login": "RiskyMH"
          },
          {
            "sha": "6b197d8a7c09f091d4fd4fab848898a396daf655",
            "date": "2025-01-14T02:41:43Z",
            "author_login": "RiskyMH"
          },
          {
            "sha": "bf0d937975d6fefd492d980a879d2315525c49ed",
            "date": "2025-01-14T02:22:43Z",
            "author_login": "cirospaciari"
          },
          {
            "sha": "e5ea345e6b9243e1fd740ee296f84db37a6a0adb",
            "date": "2025-01-14T00:33:08Z",
            "author_login": "fel1x-developer"
          },
          {
            "sha": "acae4a35613c9206257bdc47d434aa00dd61dbea",
            "date": "2025-01-13T10:39:54Z",
            "author_login": "Jarred-Sumner"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-1321",
    "description": "Versions of the package bun before 1.1.30 are vulnerable to Prototype Pollution due to improper input sanitization. An attacker can exploit this vulnerability through Bun's APIs that accept objects.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-12-18T06:15:23.360",
    "last_modified": "2024-12-18T15:15:09.947",
    "fix_date": "2024-10-08T07:34:31Z"
  },
  "references": [
    {
      "url": "https://github.com/oven-sh/bun/commit/a234e067a5dc7837602df3fb5489e826920cc65a",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://github.com/oven-sh/bun/pull/14119",
      "source": "report@snyk.io",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-JS-BUN-8499549",
      "source": "report@snyk.io",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.881618",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "bun",
    "owner": "oven-sh",
    "created_at": "2021-04-14T00:48:17Z",
    "updated_at": "2025-01-14T12:57:30Z",
    "pushed_at": "2025-01-14T11:58:13Z",
    "size": 226646,
    "stars": 75289,
    "forks": 2836,
    "open_issues": 4263,
    "watchers": 75289,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Zig": 21273009,
      "C++": 6752853,
      "TypeScript": 3046730,
      "C": 848836,
      "JavaScript": 467178,
      "CMake": 127409,
      "Shell": 114383,
      "Python": 92405,
      "Makefile": 89252,
      "Objective-C": 41796,
      "Perl": 30364,
      "PowerShell": 27771,
      "Rust": 25715,
      "Dockerfile": 19501,
      "CSS": 19327,
      "Ruby": 14292,
      "HTML": 13226,
      "HCL": 4148,
      "MDX": 864,
      "AMPL": 112
    },
    "commit_activity": {
      "total_commits_last_year": 3478,
      "avg_commits_per_week": 66.88461538461539,
      "days_active_last_year": 351
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:01:54.046663"
  }
}