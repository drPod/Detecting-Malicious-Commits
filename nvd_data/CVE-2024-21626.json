{
  "cve_id": "CVE-2024-21626",
  "github_data": {
    "repository": "opencontainers/runc",
    "fix_commit": "02120488a4c0fc487d1ed2867e901eeed7ce8ecf",
    "related_commits": [
      "02120488a4c0fc487d1ed2867e901eeed7ce8ecf",
      "02120488a4c0fc487d1ed2867e901eeed7ce8ecf"
    ],
    "patch_url": "https://github.com/opencontainers/runc/commit/02120488a4c0fc487d1ed2867e901eeed7ce8ecf.patch",
    "fix_commit_details": {
      "sha": "02120488a4c0fc487d1ed2867e901eeed7ce8ecf",
      "commit_date": "2024-01-31T20:04:29Z",
      "author": {
        "login": "cyphar",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-xr7r-f8xq-vfvv",
        "length": 88,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 204,
        "additions": 166,
        "deletions": 38
      },
      "files": [
        {
          "filename": "libcontainer/cgroups/file.go",
          "status": "modified",
          "additions": 16,
          "deletions": 15,
          "patch": "@@ -66,16 +66,16 @@ var (\n \t// TestMode is set to true by unit tests that need \"fake\" cgroupfs.\n \tTestMode bool\n \n-\tcgroupFd     int = -1\n-\tprepOnce     sync.Once\n-\tprepErr      error\n-\tresolveFlags uint64\n+\tcgroupRootHandle *os.File\n+\tprepOnce         sync.Once\n+\tprepErr          error\n+\tresolveFlags     uint64\n )\n \n func prepareOpenat2() error {\n \tprepOnce.Do(func() {\n \t\tfd, err := unix.Openat2(-1, cgroupfsDir, &unix.OpenHow{\n-\t\t\tFlags: unix.O_DIRECTORY | unix.O_PATH,\n+\t\t\tFlags: unix.O_DIRECTORY | unix.O_PATH | unix.O_CLOEXEC,\n \t\t})\n \t\tif err != nil {\n \t\t\tprepErr = &os.PathError{Op: \"openat2\", Path: cgroupfsDir, Err: err}\n@@ -86,15 +86,16 @@ func prepareOpenat2() error {\n \t\t\t}\n \t\t\treturn\n \t\t}\n+\t\tfile := os.NewFile(uintptr(fd), cgroupfsDir)\n+\n \t\tvar st unix.Statfs_t\n-\t\tif err = unix.Fstatfs(fd, &st); err != nil {\n+\t\tif err := unix.Fstatfs(int(file.Fd()), &st); err != nil {\n \t\t\tprepErr = &os.PathError{Op: \"statfs\", Path: cgroupfsDir, Err: err}\n \t\t\tlogrus.Warnf(\"falling back to securejoin: %s\", prepErr)\n \t\t\treturn\n \t\t}\n \n-\t\tcgroupFd = fd\n-\n+\t\tcgroupRootHandle = file\n \t\tresolveFlags = unix.RESOLVE_BENEATH | unix.RESOLVE_NO_MAGICLINKS\n \t\tif st.Type == unix.CGROUP2_SUPER_MAGIC {\n \t\t\t// cgroupv2 has a single mountpoint and no \"cpu,cpuacct\" symlinks\n@@ -121,29 +122,29 @@ func openFile(dir, file string, flags int) (*os.File, error) {\n \t\treturn openFallback(path, flags, mode)\n \t}\n \n-\tfd, err := unix.Openat2(cgroupFd, relPath,\n+\tfd, err := unix.Openat2(int(cgroupRootHandle.Fd()), relPath,\n \t\t&unix.OpenHow{\n \t\t\tResolve: resolveFlags,\n \t\t\tFlags:   uint64(flags) | unix.O_CLOEXEC,\n \t\t\tMode:    uint64(mode),\n \t\t})\n \tif err != nil {\n \t\terr = &os.PathError{Op: \"openat2\", Path: path, Err: err}\n-\t\t// Check if cgroupFd is still opened to cgroupfsDir\n+\t\t// Check if cgroupRootHandle is still opened to cgroupfsDir\n \t\t// (happens when this package is incorrectly used\n \t\t// across the chroot/pivot_root/mntns boundary, or\n \t\t// when /sys/fs/cgroup is remounted).\n \t\t//\n \t\t// TODO: if such usage will ever be common, amend this\n-\t\t// to reopen cgroupFd and retry openat2.\n-\t\tfdPath, closer := utils.ProcThreadSelf(\"fd/\" + strconv.Itoa(cgroupFd))\n+\t\t// to reopen cgroupRootHandle and retry openat2.\n+\t\tfdPath, closer := utils.ProcThreadSelf(\"fd/\" + strconv.Itoa(int(cgroupRootHandle.Fd())))\n \t\tdefer closer()\n \t\tfdDest, _ := os.Readlink(fdPath)\n \t\tif fdDest != cgroupfsDir {\n-\t\t\t// Wrap the error so it is clear that cgroupFd\n+\t\t\t// Wrap the error so it is clear that cgroupRootHandle\n \t\t\t// is opened to an unexpected/wrong directory.\n-\t\t\terr = fmt.Errorf(\"cgroupFd %d unexpectedly opened to %s != %s: %w\",\n-\t\t\t\tcgroupFd, fdDest, cgroupfsDir, err)\n+\t\t\terr = fmt.Errorf(\"cgroupRootHandle %d unexpectedly opened to %s != %s: %w\",\n+\t\t\t\tcgroupRootHandle.Fd(), fdDest, cgroupfsDir, err)\n \t\t}\n \t\treturn nil, err\n \t}"
        },
        {
          "filename": "libcontainer/container_linux.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -332,6 +332,15 @@ func (c *Container) start(process *Process) (retErr error) {\n \t\t}()\n \t}\n \n+\t// Before starting \"runc init\", mark all non-stdio open files as O_CLOEXEC\n+\t// to make sure we don't leak any files into \"runc init\". Any files to be\n+\t// passed to \"runc init\" through ExtraFiles will get dup2'd by the Go\n+\t// runtime and thus their O_CLOEXEC flag will be cleared. This is some\n+\t// additional protection against attacks like CVE-2024-21626, by making\n+\t// sure we never leak files to \"runc init\" we didn't intend to.\n+\tif err := utils.CloseExecFrom(3); err != nil {\n+\t\treturn fmt.Errorf(\"unable to mark non-stdio fds as cloexec: %w\", err)\n+\t}\n \tif err := parent.start(); err != nil {\n \t\treturn fmt.Errorf(\"unable to start container process: %w\", err)\n \t}"
        },
        {
          "filename": "libcontainer/init_linux.go",
          "status": "modified",
          "additions": 32,
          "deletions": 1,
          "patch": "@@ -7,6 +7,7 @@ import (\n \t\"fmt\"\n \t\"net\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"runtime\"\n \t\"runtime/debug\"\n \t\"strconv\"\n@@ -89,7 +90,7 @@ func Init() {\n \t}\n \t// Normally, StartInitialization() never returns, meaning\n \t// if we are here, it had failed.\n-\tos.Exit(1)\n+\tos.Exit(255)\n }\n \n // Normally, this function does not return. If it returns, with or without an\n@@ -274,6 +275,32 @@ func populateProcessEnvironment(env []string) error {\n \treturn nil\n }\n \n+// verifyCwd ensures that the current directory is actually inside the mount\n+// namespace root of the current process.\n+func verifyCwd() error {\n+\t// getcwd(2) on Linux detects if cwd is outside of the rootfs of the\n+\t// current mount namespace root, and in that case prefixes \"(unreachable)\"\n+\t// to the returned string. glibc's getcwd(3) and Go's Getwd() both detect\n+\t// when this happens and return ENOENT rather than returning a non-absolute\n+\t// path. In both cases we can therefore easily detect if we have an invalid\n+\t// cwd by checking the return value of getcwd(3). See getcwd(3) for more\n+\t// details, and CVE-2024-21626 for the security issue that motivated this\n+\t// check.\n+\t//\n+\t// We have to use unix.Getwd() here because os.Getwd() has a workaround for\n+\t// $PWD which involves doing stat(.), which can fail if the current\n+\t// directory is inaccessible to the container process.\n+\tif wd, err := unix.Getwd(); errors.Is(err, unix.ENOENT) {\n+\t\treturn errors.New(\"current working directory is outside of container mount namespace root -- possible container breakout detected\")\n+\t} else if err != nil {\n+\t\treturn fmt.Errorf(\"failed to verify if current working directory is safe: %w\", err)\n+\t} else if !filepath.IsAbs(wd) {\n+\t\t// We shouldn't ever hit this, but check just in case.\n+\t\treturn fmt.Errorf(\"current working directory is not absolute -- possible container breakout detected: cwd is %q\", wd)\n+\t}\n+\treturn nil\n+}\n+\n // finalizeNamespace drops the caps, sets the correct user\n // and working dir, and closes any leaked file descriptors\n // before executing the command inside the namespace\n@@ -332,6 +359,10 @@ func finalizeNamespace(config *initConfig) error {\n \t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n \t\t}\n \t}\n+\t// Make sure our final working directory is inside the container.\n+\tif err := verifyCwd(); err != nil {\n+\t\treturn err\n+\t}\n \tif err := system.ClearKeepCaps(); err != nil {\n \t\treturn fmt.Errorf(\"unable to clear keep caps: %w\", err)\n \t}"
        },
        {
          "filename": "libcontainer/integration/seccomp_test.go",
          "status": "modified",
          "additions": 10,
          "deletions": 10,
          "patch": "@@ -13,7 +13,7 @@ import (\n \tlibseccomp \"github.com/seccomp/libseccomp-golang\"\n )\n \n-func TestSeccompDenyGetcwdWithErrno(t *testing.T) {\n+func TestSeccompDenySyslogWithErrno(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n \t}\n@@ -25,7 +25,7 @@ func TestSeccompDenyGetcwdWithErrno(t *testing.T) {\n \t\tDefaultAction: configs.Allow,\n \t\tSyscalls: []*configs.Syscall{\n \t\t\t{\n-\t\t\t\tName:     \"getcwd\",\n+\t\t\t\tName:     \"syslog\",\n \t\t\t\tAction:   configs.Errno,\n \t\t\t\tErrnoRet: &errnoRet,\n \t\t\t},\n@@ -39,7 +39,7 @@ func TestSeccompDenyGetcwdWithErrno(t *testing.T) {\n \tbuffers := newStdBuffers()\n \tpwd := &libcontainer.Process{\n \t\tCwd:    \"/\",\n-\t\tArgs:   []string{\"pwd\"},\n+\t\tArgs:   []string{\"dmesg\"},\n \t\tEnv:    standardEnvironment,\n \t\tStdin:  buffers.Stdin,\n \t\tStdout: buffers.Stdout,\n@@ -65,17 +65,17 @@ func TestSeccompDenyGetcwdWithErrno(t *testing.T) {\n \t}\n \n \tif exitCode == 0 {\n-\t\tt.Fatalf(\"Getcwd should fail with negative exit code, instead got %d!\", exitCode)\n+\t\tt.Fatalf(\"dmesg should fail with negative exit code, instead got %d!\", exitCode)\n \t}\n \n-\texpected := \"pwd: getcwd: No such process\"\n+\texpected := \"dmesg: klogctl: No such process\"\n \tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n \tif actual != expected {\n \t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)\n \t}\n }\n \n-func TestSeccompDenyGetcwd(t *testing.T) {\n+func TestSeccompDenySyslog(t *testing.T) {\n \tif testing.Short() {\n \t\treturn\n \t}\n@@ -85,7 +85,7 @@ func TestSeccompDenyGetcwd(t *testing.T) {\n \t\tDefaultAction: configs.Allow,\n \t\tSyscalls: []*configs.Syscall{\n \t\t\t{\n-\t\t\t\tName:   \"getcwd\",\n+\t\t\t\tName:   \"syslog\",\n \t\t\t\tAction: configs.Errno,\n \t\t\t},\n \t\t},\n@@ -98,7 +98,7 @@ func TestSeccompDenyGetcwd(t *testing.T) {\n \tbuffers := newStdBuffers()\n \tpwd := &libcontainer.Process{\n \t\tCwd:    \"/\",\n-\t\tArgs:   []string{\"pwd\"},\n+\t\tArgs:   []string{\"dmesg\"},\n \t\tEnv:    standardEnvironment,\n \t\tStdin:  buffers.Stdin,\n \t\tStdout: buffers.Stdout,\n@@ -124,10 +124,10 @@ func TestSeccompDenyGetcwd(t *testing.T) {\n \t}\n \n \tif exitCode == 0 {\n-\t\tt.Fatalf(\"Getcwd should fail with negative exit code, instead got %d!\", exitCode)\n+\t\tt.Fatalf(\"dmesg should fail with negative exit code, instead got %d!\", exitCode)\n \t}\n \n-\texpected := \"pwd: getcwd: Operation not permitted\"\n+\texpected := \"dmesg: klogctl: Operation not permitted\"\n \tactual := strings.Trim(buffers.Stderr.String(), \"\\n\")\n \tif actual != expected {\n \t\tt.Fatalf(\"Expected output %s but got %s\\n\", expected, actual)"
        },
        {
          "filename": "libcontainer/setns_init_linux.go",
          "status": "modified",
          "additions": 19,
          "deletions": 0,
          "patch": "@@ -14,6 +14,7 @@ import (\n \t\"github.com/opencontainers/runc/libcontainer/keys\"\n \t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n \t\"github.com/opencontainers/runc/libcontainer/system\"\n+\t\"github.com/opencontainers/runc/libcontainer/utils\"\n )\n \n // linuxSetnsInit performs the container's initialization for running a new process\n@@ -138,5 +139,23 @@ func (l *linuxSetnsInit) Init() error {\n \t\tl.config.Args[0] = name\n \t\treturn system.Fexecve(l.dmzExe.Fd(), l.config.Args, os.Environ())\n \t}\n+\t// Close all file descriptors we are not passing to the container. This is\n+\t// necessary because the execve target could use internal runc fds as the\n+\t// execve path, potentially giving access to binary files from the host\n+\t// (which can then be opened by container processes, leading to container\n+\t// escapes). Note that because this operation will close any open file\n+\t// descriptors that are referenced by (*os.File) handles from underneath\n+\t// the Go runtime, we must not do any file operations after this point\n+\t// (otherwise the (*os.File) finaliser could close the wrong file). See\n+\t// CVE-2024-21626 for more information as to why this protection is\n+\t// necessary.\n+\t//\n+\t// This is not needed for runc-dmz, because the extra execve(2) step means\n+\t// that all O_CLOEXEC file descriptors have already been closed and thus\n+\t// the second execve(2) from runc-dmz cannot access internal file\n+\t// descriptors from runc.\n+\tif err := utils.UnsafeCloseFrom(l.config.PassedFilesCount + 3); err != nil {\n+\t\treturn err\n+\t}\n \treturn system.Exec(name, l.config.Args, os.Environ())\n }"
        },
        {
          "filename": "libcontainer/standard_init_linux.go",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -281,5 +281,23 @@ func (l *linuxStandardInit) Init() error {\n \t\tl.config.Args[0] = name\n \t\treturn system.Fexecve(l.dmzExe.Fd(), l.config.Args, os.Environ())\n \t}\n+\t// Close all file descriptors we are not passing to the container. This is\n+\t// necessary because the execve target could use internal runc fds as the\n+\t// execve path, potentially giving access to binary files from the host\n+\t// (which can then be opened by container processes, leading to container\n+\t// escapes). Note that because this operation will close any open file\n+\t// descriptors that are referenced by (*os.File) handles from underneath\n+\t// the Go runtime, we must not do any file operations after this point\n+\t// (otherwise the (*os.File) finaliser could close the wrong file). See\n+\t// CVE-2024-21626 for more information as to why this protection is\n+\t// necessary.\n+\t//\n+\t// This is not needed for runc-dmz, because the extra execve(2) step means\n+\t// that all O_CLOEXEC file descriptors have already been closed and thus\n+\t// the second execve(2) from runc-dmz cannot access internal file\n+\t// descriptors from runc.\n+\tif err := utils.UnsafeCloseFrom(l.config.PassedFilesCount + 3); err != nil {\n+\t\treturn err\n+\t}\n \treturn system.Exec(name, l.config.Args, os.Environ())\n }"
        },
        {
          "filename": "libcontainer/utils/utils_unix.go",
          "status": "modified",
          "additions": 62,
          "deletions": 12,
          "patch": "@@ -11,6 +11,7 @@ import (\n \t\"runtime\"\n \t\"strconv\"\n \t\"sync\"\n+\t_ \"unsafe\" // for go:linkname\n \n \tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n \t\"github.com/sirupsen/logrus\"\n@@ -53,14 +54,11 @@ func haveCloseRangeCloexec() bool {\n \treturn haveCloseRangeCloexecBool\n }\n \n-// CloseExecFrom applies O_CLOEXEC to all file descriptors currently open for\n-// the process (except for those below the given fd value).\n-func CloseExecFrom(minFd int) error {\n-\tif haveCloseRangeCloexec() {\n-\t\terr := unix.CloseRange(uint(minFd), math.MaxUint, unix.CLOSE_RANGE_CLOEXEC)\n-\t\treturn os.NewSyscallError(\"close_range\", err)\n-\t}\n+type fdFunc func(fd int)\n \n+// fdRangeFrom calls the passed fdFunc for each file descriptor that is open in\n+// the current process.\n+func fdRangeFrom(minFd int, fn fdFunc) error {\n \tprocSelfFd, closer := ProcThreadSelf(\"fd\")\n \tdefer closer()\n \n@@ -88,15 +86,67 @@ func CloseExecFrom(minFd int) error {\n \t\tif fd < minFd {\n \t\t\tcontinue\n \t\t}\n-\t\t// Intentionally ignore errors from unix.CloseOnExec -- the cases where\n-\t\t// this might fail are basically file descriptors that have already\n-\t\t// been closed (including and especially the one that was created when\n-\t\t// os.ReadDir did the \"opendir\" syscall).\n-\t\tunix.CloseOnExec(fd)\n+\t\t// Ignore the file descriptor we used for readdir, as it will be closed\n+\t\t// when we return.\n+\t\tif uintptr(fd) == fdDir.Fd() {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Run the closure.\n+\t\tfn(fd)\n \t}\n \treturn nil\n }\n \n+// CloseExecFrom sets the O_CLOEXEC flag on all file descriptors greater or\n+// equal to minFd in the current process.\n+func CloseExecFrom(minFd int) error {\n+\t// Use close_range(CLOSE_RANGE_CLOEXEC) if possible.\n+\tif haveCloseRangeCloexec() {\n+\t\terr := unix.CloseRange(uint(minFd), math.MaxUint, unix.CLOSE_RANGE_CLOEXEC)\n+\t\treturn os.NewSyscallError(\"close_range\", err)\n+\t}\n+\t// Otherwise, fall back to the standard loop.\n+\treturn fdRangeFrom(minFd, unix.CloseOnExec)\n+}\n+\n+//go:linkname runtime_IsPollDescriptor internal/poll.IsPollDescriptor\n+\n+// In order to make sure we do not close the internal epoll descriptors the Go\n+// runtime uses, we need to ensure that we skip descriptors that match\n+// \"internal/poll\".IsPollDescriptor. Yes, this is a Go runtime internal thing,\n+// unfortunately there's no other way to be sure we're only keeping the file\n+// descriptors the Go runtime needs. Hopefully nothing blows up doing this...\n+func runtime_IsPollDescriptor(fd uintptr) bool //nolint:revive\n+\n+// UnsafeCloseFrom closes all file descriptors greater or equal to minFd in the\n+// current process, except for those critical to Go's runtime (such as the\n+// netpoll management descriptors).\n+//\n+// NOTE: That this function is incredibly dangerous to use in most Go code, as\n+// closing file descriptors from underneath *os.File handles can lead to very\n+// bad behaviour (the closed file descriptor can be re-used and then any\n+// *os.File operations would apply to the wrong file). This function is only\n+// intended to be called from the last stage of runc init.\n+func UnsafeCloseFrom(minFd int) error {\n+\t// We cannot use close_range(2) even if it is available, because we must\n+\t// not close some file descriptors.\n+\treturn fdRangeFrom(minFd, func(fd int) {\n+\t\tif runtime_IsPollDescriptor(uintptr(fd)) {\n+\t\t\t// These are the Go runtimes internal netpoll file descriptors.\n+\t\t\t// These file descriptors are operated on deep in the Go scheduler,\n+\t\t\t// and closing those files from underneath Go can result in panics.\n+\t\t\t// There is no issue with keeping them because they are not\n+\t\t\t// executable and are not useful to an attacker anyway. Also we\n+\t\t\t// don't have any choice.\n+\t\t\treturn\n+\t\t}\n+\t\t// There's nothing we can do about errors from close(2), and the\n+\t\t// only likely error to be seen is EBADF which indicates the fd was\n+\t\t// already closed (in which case, we got what we wanted).\n+\t\t_ = unix.Close(fd)\n+\t})\n+}\n+\n // NewSockPair returns a new SOCK_STREAM unix socket pair.\n func NewSockPair(name string) (parent, child *os.File, err error) {\n \tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_STREAM|unix.SOCK_CLOEXEC, 0)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "610aa88ab201f289c05c2e262912d0630f46eb35",
            "date": "2025-01-10T20:23:22Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "4120935737a51cbf23676977cc8bf0b6717702f1",
            "date": "2025-01-09T10:45:31Z",
            "author_login": "lifubang"
          },
          {
            "sha": "06f1e0765576dcf6d8c2ef5e56d309618310992c",
            "date": "2024-06-23T23:31:57Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "6171da60058fe58c6bd2f2a4ae8be381cfc12cce",
            "date": "2024-12-23T01:32:02Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "c49b89168140c70dc1badd17d5ed361788898fe9",
            "date": "2024-12-21T19:52:25Z",
            "author_login": "kolyshkin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-403",
    "description": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc 1.1.11 and earlier, due to an internal file descriptor leak, an attacker could cause a newly-spawned container process (from runc exec) to have a working directory in the host filesystem namespace, allowing for a container escape by giving access to the host filesystem (\"attack 2\"). The same attack could be used by a malicious image to allow a container process to gain access to the host filesystem through runc run (\"attack 1\"). Variants of attacks 1 and 2 could be also be used to overwrite semi-arbitrary host binaries, allowing for complete container escapes (\"attack 3a\" and \"attack 3b\"). runc 1.1.12 includes patches for this issue. ",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-31T22:15:53.780",
    "last_modified": "2024-11-21T08:54:45.180",
    "fix_date": "2024-01-31T20:04:29Z"
  },
  "references": [
    {
      "url": "http://packetstormsecurity.com/files/176993/runc-1.1.11-File-Descriptor-Leak-Privilege-Escalation.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/02/01/1",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/02/02/3",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/02120488a4c0fc487d1ed2867e901eeed7ce8ecf",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/releases/tag/v1.1.12",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/02/msg00005.html",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2NLXNE23Q5ESQUAI22Z7A63JX2WMPJ2J/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SYMO3BANINS6RGFQFKPRG4FIOJ7GWYTL/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "http://packetstormsecurity.com/files/176993/runc-1.1.11-File-Descriptor-Leak-Privilege-Escalation.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory",
        "VDB Entry"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/02/01/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/02/02/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/02120488a4c0fc487d1ed2867e901eeed7ce8ecf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/releases/tag/v1.1.12",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/02/msg00005.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2NLXNE23Q5ESQUAI22Z7A63JX2WMPJ2J/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SYMO3BANINS6RGFQFKPRG4FIOJ7GWYTL/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://www.vicarius.io/vsociety/posts/leaky-vessels-part-1-cve-2024-21626",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.553575",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "runc",
    "owner": "opencontainers",
    "created_at": "2015-06-05T23:30:45Z",
    "updated_at": "2025-01-14T11:33:23Z",
    "pushed_at": "2025-01-13T07:56:10Z",
    "size": 21572,
    "stars": 12051,
    "forks": 2130,
    "open_issues": 365,
    "watchers": 12051,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.1",
      "release-1.2"
    ],
    "languages": {
      "Go": 1253070,
      "Shell": 305324,
      "C": 45119,
      "Makefile": 7226,
      "Dockerfile": 2644,
      "Ruby": 2035
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:26:33.730029"
  }
}