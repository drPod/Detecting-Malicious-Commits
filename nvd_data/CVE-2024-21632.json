{
  "cve_id": "CVE-2024-21632",
  "github_data": {
    "repository": "synth/omniauth-microsoft_graph",
    "fix_commit": "f132078389612b797c872b45bd0e0b47382414c1",
    "related_commits": [
      "f132078389612b797c872b45bd0e0b47382414c1",
      "f132078389612b797c872b45bd0e0b47382414c1"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "f132078389612b797c872b45bd0e0b47382414c1",
      "commit_date": "2023-12-19T23:32:51Z",
      "author": {
        "login": "dzunk",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Add email domain verification",
        "length": 29,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 235,
        "additions": 230,
        "deletions": 5
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 34,
          "deletions": 1,
          "patch": "@@ -32,10 +32,43 @@ end\n ```\n \n #### Login Hint\n-Just add {login_hint: \"email@example.com\"} to your url generation to form:\n+Just add `{login_hint: \"email@example.com\"}` to your url generation to form:\n ```ruby\n /auth/microsoft_graph?login_hint=email@example.com\n ```\n+\n+#### Domain Verification\n+Because Microsoft allows users to set vanity emails on their accounts, the value of the user's \"email\" doesn't establish membership in that domain. Put another way, user malicious@hacker.biz can edit their email in Active Directory to ceo@yourcompany.com, and (depending on your auth implementation) may be able to log in automatically as that user.\n+\n+To establish membership in the claimed email domain, we use two strategies:\n+\n+* `email` domain matches `userPrincipalName` domain (which by definition is a verified domain)\n+* The user's `id_token` includes the `xms_edov` (\"Email Domain Ownership Verified\") claim, with a truthy value\n+\n+The `xms_edov` claim is [optional](https://github.com/MicrosoftDocs/azure-docs/issues/111425), and must be configured in the Azure console before it's available in the token. Refer to [Clerk's guide](https://clerk.com/docs/authentication/social-connections/microsoft#stay-secure-against-the-n-o-auth-vulnerability) for instructions on configuring the claim.\n+\n+If you're not able or don't need to support domain verification, you can bypass for an individual domain:\n+```ruby\n+Rails.application.config.middleware.use OmniAuth::Builder do\n+  provider :microsoft_graph,\n+           ENV['AZURE_APPLICATION_CLIENT_ID'],\n+           ENV['AZURE_APPLICATION_CLIENT_SECRET'],\n+           skip_domain_verification: %w[contoso.com]\n+end\n+```\n+\n+Or, you can disable domain verification entirely. We *strongly recommend* that you do *not* disable domain verification if at all possible.\n+```ruby\n+Rails.application.config.middleware.use OmniAuth::Builder do\n+  provider :microsoft_graph,\n+           ENV['AZURE_APPLICATION_CLIENT_ID'],\n+           ENV['AZURE_APPLICATION_CLIENT_SECRET'],\n+           skip_domain_verification: true\n+end\n+```\n+\n+[nOAuth: How Microsoft OAuth Misconfiguration Can Lead to Full Account Takeover](https://www.descope.com/blog/post/noauth) from [Descope](https://www.descope.com/)\n+\n ### Upgrading to 1.0.0\n This version requires OmniAuth v2. If you are using Rails, you will need to include or upgrade `omniauth-rails_csrf_protection`. If you upgrade and get an error in your logs complaining about \"authenticity error\" or similiar, make sure to do `bundle update omniauth-rails_csrf_protection`\n "
        },
        {
          "filename": "lib/omniauth/microsoft_graph.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1,2 +1,3 @@\n+require \"omniauth/microsoft_graph/domain_verifier\"\n require \"omniauth/microsoft_graph/version\"\n require \"omniauth/strategies/microsoft_graph\""
        },
        {
          "filename": "lib/omniauth/microsoft_graph/domain_verifier.rb",
          "status": "added",
          "additions": 86,
          "deletions": 0,
          "patch": "@@ -0,0 +1,86 @@\n+# frozen_string_literal: true\n+require 'jwt' # for token signature validation\n+require 'omniauth' # to inherit from OmniAuth::Error\n+require 'oauth2' # to rescue OAuth2::Error\n+\n+module OmniAuth\n+  module MicrosoftGraph\n+    # Verify user email domains to mitigate the nOAuth vulnerability\n+    # https://www.descope.com/blog/post/noauth\n+    # https://clerk.com/docs/authentication/social-connections/microsoft#stay-secure-against-the-n-o-auth-vulnerability\n+    OIDC_CONFIG_URL = 'https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration'\n+\n+    class DomainVerificationError < OmniAuth::Error; end\n+\n+    class DomainVerifier\n+      def self.verify!(auth_hash, access_token, options)\n+        new(auth_hash, access_token, options).verify!\n+      end\n+\n+      def initialize(auth_hash, access_token, options)\n+        @email_domain = auth_hash['info']['email']&.split('@')&.last\n+        @upn_domain = auth_hash['extra']['raw_info']['userPrincipalName']&.split('@')&.last\n+        @access_token = access_token\n+        @id_token = access_token.params['id_token']\n+        @skip_verification = options[:skip_domain_verification]\n+      end\n+\n+      def verify!\n+        # The userPrincipalName property is mutable, but must always contain a\n+        # verified domain:\n+        #\n+        #  \"The general format is alias@domain, where domain must be present in\n+        #  the tenant's collection of verified domains.\"\n+        #  https://learn.microsoft.com/en-us/graph/api/resources/user?view=graph-rest-1.0\n+        #\n+        # This means while it's not suitable for consistently identifying a user\n+        # (the domain might change), it is suitable for verifying membership in\n+        # a given domain.\n+        return true if email_domain == upn_domain ||\n+          skip_verification == true ||\n+          (skip_verification.is_a?(Array) && skip_verification.include?(email_domain)) ||\n+          domain_verified_jwt_claim\n+        raise DomainVerificationError, verification_error_message\n+      end\n+\n+      private\n+\n+      attr_reader :access_token,\n+                  :email_domain,\n+                  :id_token,\n+                  :permitted_domains,\n+                  :skip_verification,\n+                  :upn_domain\n+\n+      # https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims-reference\n+      # Microsoft offers an optional claim `xms_edov` that will indicate whether the\n+      # user's email domain is part of the organization's verified domains. This has to be\n+      # explicitly configured in the app registration.\n+      #\n+      # To get to it, we need to decode the ID token with the key material from Microsoft's\n+      # OIDC configuration endpoint, and inspect it for the claim in question.\n+      def domain_verified_jwt_claim\n+        oidc_config = access_token.get(OIDC_CONFIG_URL).parsed\n+        algorithms = oidc_config['id_token_signing_alg_values_supported']\n+        keys = JWT::JWK::Set.new(access_token.get(oidc_config['jwks_uri']).parsed)\n+        decoded_token = JWT.decode(id_token, nil, true, algorithms: algorithms, jwks: keys)\n+        # https://github.com/MicrosoftDocs/azure-docs/issues/111425#issuecomment-1761043378\n+        # Comments seemed to indicate the value is not consistent\n+        ['1', 1, 'true', true].include?(decoded_token.first['xms_edov'])\n+      rescue JWT::VerificationError, ::OAuth2::Error\n+        false\n+      end\n+\n+      def verification_error_message\n+        <<~MSG\n+          The email domain '#{email_domain}' is not a verified domain for this Azure AD account.\n+          You can either:\n+            * Update the user's email to match the principal domain '#{upn_domain}'\n+            * Skip verification on the '#{email_domain}' domain (not recommended)\n+            * Disable verification with `skip_domain_verification: true` (NOT RECOMMENDED!)\n+          Refer to the README for more details.\n+        MSG\n+      end\n+    end\n+  end\n+end"
        },
        {
          "filename": "lib/omniauth/strategies/microsoft_graph.rb",
          "status": "modified",
          "additions": 14,
          "deletions": 3,
          "patch": "@@ -22,6 +22,7 @@ class MicrosoftGraph < OmniAuth::Strategies::OAuth2\n \n       option :scope, DEFAULT_SCOPE\n       option :authorized_client_ids, []\n+      option :skip_domain_verification, false\n \n       uid { raw_info[\"id\"] }\n \n@@ -43,6 +44,12 @@ class MicrosoftGraph < OmniAuth::Strategies::OAuth2\n         }\n       end\n \n+      def auth_hash\n+        super.tap do |ah|\n+          verify_email(ah, access_token)\n+        end\n+      end\n+\n       def authorize_params\n         super.tap do |params|\n           options[:authorize_options].each do |k|\n@@ -54,15 +61,15 @@ def authorize_params\n \n           session['omniauth.state'] = params[:state] if params[:state]\n         end\n-      end     \n+      end\n \n       def raw_info\n         @raw_info ||= access_token.get('https://graph.microsoft.com/v1.0/me').parsed\n       end\n \n       def callback_url\n         options[:callback_url] || full_host + script_name + callback_path\n-      end  \n+      end\n \n       def custom_build_access_token\n         access_token = get_access_token(request)\n@@ -119,7 +126,11 @@ def verify_token(access_token)\n         raw_response = client.request(:get, 'https://graph.microsoft.com/v1.0/me',\n                                       params: { access_token: access_token }).parsed\n         (raw_response['aud'] == options.client_id) || options.authorized_client_ids.include?(raw_response['aud'])\n-      end              \n+      end\n+\n+      def verify_email(auth_hash, access_token)\n+        OmniAuth::MicrosoftGraph::DomainVerifier.verify!(auth_hash, access_token, options)\n+      end\n     end\n   end\n end"
        },
        {
          "filename": "omniauth-microsoft_graph.gemspec",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -18,6 +18,7 @@ Gem::Specification.new do |spec|\n   spec.test_files    = spec.files.grep(%r{^(test|spec|features)/})\n   spec.require_paths = [\"lib\"]\n \n+  spec.add_runtime_dependency 'jwt', '>= 2.0'\n   spec.add_runtime_dependency 'omniauth', '~> 2.0'\n   spec.add_runtime_dependency 'omniauth-oauth2', '~> 1.8.0'\n   spec.add_development_dependency \"sinatra\", '~> 0'"
        },
        {
          "filename": "spec/omniauth/microsoft_graph/domain_verifier_spec.rb",
          "status": "added",
          "additions": 82,
          "deletions": 0,
          "patch": "@@ -0,0 +1,82 @@\n+# frozen_string_literal: true\n+\n+require 'spec_helper'\n+require 'omniauth/microsoft_graph/domain_verifier'\n+\n+RSpec.describe OmniAuth::MicrosoftGraph::DomainVerifier do\n+  subject(:verifier) { described_class.new(auth_hash, access_token, options) }\n+\n+  let(:auth_hash) do\n+    {\n+      'info' => { 'email' => email },\n+      'extra' => { 'raw_info' => { 'userPrincipalName' => upn } }\n+    }\n+  end\n+  let(:email) { 'foo@example.com' }\n+  let(:upn) { 'bar@hackerman.biz' }\n+  let(:options) { { skip_domain_verification: false } }\n+  let(:access_token) { double('OAuth2::AccessToken', params: { 'id_token' => id_token }) }\n+  let(:id_token) { nil }\n+\n+  describe '#verify!' do\n+    subject(:result) { verifier.verify! }\n+\n+    context 'when email domain and userPrincipalName domain match' do\n+      let(:email) { 'foo@example.com' }\n+      let(:upn) { 'bar@example.com' }\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when domain validation is disabled' do\n+      let(:options) { super().merge(skip_domain_verification: true) }\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when the email domain is explicitly permitted' do\n+      let(:options) { super().merge(skip_domain_verification: ['example.com']) }\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when the ID token indicates domain verification' do\n+      # Sign a fake ID token with our own local key\n+      let(:mock_key) do\n+        optional_parameters = { kid: 'mock-kid', use: 'sig', alg: 'RS256' }\n+        JWT::JWK.new(OpenSSL::PKey::RSA.new(2048), optional_parameters)\n+      end\n+      let(:id_token) do\n+        payload = { email: email, xms_edov: true }\n+        JWT.encode(payload, mock_key.signing_key, mock_key[:alg], kid: mock_key[:kid])\n+      end\n+\n+      # Mock the API responses to return the local key\n+      before do\n+        allow(access_token).to receive(:get)\n+          .with(OmniAuth::MicrosoftGraph::OIDC_CONFIG_URL)\n+          .and_return(\n+            double('OAuth2::Response', parsed: {\n+              'id_token_signing_alg_values_supported' => ['RS256'],\n+              'jwks_uri' => 'https://example.com/jwks-keys'\n+            })\n+          )\n+        allow(access_token).to receive(:get)\n+          .with('https://example.com/jwks-keys')\n+          .and_return(\n+            double('OAuth2::Response', parsed: JWT::JWK::Set.new(mock_key).export)\n+          )\n+      end\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when all verification strategies fail' do\n+      before { allow(access_token).to receive(:get).and_raise(::OAuth2::Error.new('whoops')) }\n+\n+      it 'raises a DomainVerificationError' do\n+        expect { result }.to raise_error OmniAuth::MicrosoftGraph::DomainVerificationError\n+      end\n+    end\n+  end\n+end"
        },
        {
          "filename": "spec/omniauth/strategies/microsoft_graph_oauth2_spec.rb",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -280,6 +280,18 @@\n       end\n     end\n \n+    context 'when email verification fails' do\n+      let(:response_hash) { { mail: 'something@domain.invalid' } }\n+      let(:error) { OmniAuth::MicrosoftGraph::DomainVerificationError.new }\n+\n+      before do\n+        allow(OmniAuth::MicrosoftGraph::DomainVerifier).to receive(:verify!).and_raise(error)\n+      end\n+\n+      it 'raises an error' do\n+        expect { subject.auth_hash }.to raise_error error\n+      end\n+    end\n   end\n \n   describe '#extra' do\n@@ -445,5 +457,4 @@\n       end.to raise_error(OAuth2::Error)\n     end\n   end\n-\n end"
        }
      ],
      "file_patterns": {
        "security_files": 6,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9836bd535cc6fc5f5da0a45ea98df038600bdf51",
            "date": "2024-06-02T02:23:50Z",
            "author_login": "synth"
          },
          {
            "sha": "33bc98eeb26de1d54e40bac0da140071be770575",
            "date": "2024-06-02T02:21:13Z",
            "author_login": "synth"
          },
          {
            "sha": "68aeca2ce448067afa75ee5b2f5aa72eb2daed6e",
            "date": "2024-06-02T00:37:59Z",
            "author_login": "jaedonfarrugia"
          },
          {
            "sha": "21f4204ebb6e75aab10f265b4dff0e68b87ea642",
            "date": "2024-06-01T18:06:20Z",
            "author_login": "synth"
          },
          {
            "sha": "44375892aadf6f0c503263f5873fdd5d1adcafac",
            "date": "2024-06-01T18:04:28Z",
            "author_login": "synth"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
    "cwe_id": "CWE-287",
    "description": "omniauth-microsoft_graph provides an Omniauth strategy for the Microsoft Graph API. Prior to versions 2.0.0, the implementation did not validate the legitimacy of the `email` attribute of the user nor did it give/document an option to do so, making it susceptible to nOAuth misconfiguration in cases when the `email` is used as a trusted user identifier. This could lead to account takeover. Version 2.0.0 contains a fix for this issue.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-02T22:15:10.103",
    "last_modified": "2024-11-21T08:54:46.027",
    "fix_date": "2023-12-19T23:32:51Z"
  },
  "references": [
    {
      "url": "https://github.com/synth/omniauth-microsoft_graph/commit/f132078389612b797c872b45bd0e0b47382414c1",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/synth/omniauth-microsoft_graph/security/advisories/GHSA-5g66-628f-7cvj",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.descope.com/blog/post/noauth",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit"
      ]
    },
    {
      "url": "https://github.com/synth/omniauth-microsoft_graph/commit/f132078389612b797c872b45bd0e0b47382414c1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/synth/omniauth-microsoft_graph/security/advisories/GHSA-5g66-628f-7cvj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.descope.com/blog/post/noauth",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:44.126560",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "omniauth-microsoft_graph",
    "owner": "synth",
    "created_at": "2016-06-18T09:10:55Z",
    "updated_at": "2025-01-16T18:37:59Z",
    "pushed_at": "2024-11-18T21:16:24Z",
    "size": 73,
    "stars": 40,
    "forks": 62,
    "open_issues": 2,
    "watchers": 40,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 33492
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:43:19.815417"
  }
}