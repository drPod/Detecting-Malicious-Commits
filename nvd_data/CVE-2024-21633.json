{
  "cve_id": "CVE-2024-21633",
  "github_data": {
    "repository": "iBotPeaches/Apktool",
    "fix_commit": "d348c43b24a9de350ff6e5bd610545a10c1fc712",
    "related_commits": [
      "d348c43b24a9de350ff6e5bd610545a10c1fc712",
      "d348c43b24a9de350ff6e5bd610545a10c1fc712"
    ],
    "patch_url": "https://github.com/iBotPeaches/Apktool/commit/d348c43b24a9de350ff6e5bd610545a10c1fc712.patch",
    "fix_commit_details": {
      "sha": "d348c43b24a9de350ff6e5bd610545a10c1fc712",
      "commit_date": "2024-01-02T11:11:03Z",
      "author": {
        "login": "iBotPeaches",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Prevent arbitrary file writes with malicious resource names. (#3484)",
        "length": 782,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 120,
        "additions": 100,
        "deletions": 20
      },
      "files": [
        {
          "filename": "brut.apktool/apktool-lib/src/main/java/brut/androlib/ApkBuilder.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -480,7 +480,7 @@ private void copyUnknownFiles(ZipOutputStream outputFile, Map<String, String> fi\n             File inputFile;\n \n             try {\n-                inputFile = new File(unknownFileDir, BrutIO.sanitizeUnknownFile(unknownFileDir, unknownFileInfo.getKey()));\n+                inputFile = new File(unknownFileDir, BrutIO.sanitizeFilepath(unknownFileDir, unknownFileInfo.getKey()));\n             } catch (RootUnknownFileException | InvalidUnknownFileException | TraversalUnknownFileException exception) {\n                 LOGGER.warning(String.format(\"Skipping file %s (%s)\", unknownFileInfo.getKey(), exception.getMessage()));\n                 continue;"
        },
        {
          "filename": "brut.apktool/apktool-lib/src/main/java/brut/androlib/res/ResourcesDecoder.java",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -154,12 +154,12 @@ public void decodeResources(File outDir) throws AndrolibException {\n         decoders.setDecoder(\"xml\", new XmlPullStreamDecoder(axmlParser, getResXmlSerializer()));\n \n         ResFileDecoder fileDecoder = new ResFileDecoder(decoders);\n-        Directory in, out;\n+        Directory in, out, outRes;\n \n         try {\n             out = new FileDirectory(outDir);\n             in = mApkInfo.getApkFile().getDirectory();\n-            out = out.createDir(\"res\");\n+            outRes = out.createDir(\"res\");\n         } catch (DirectoryException ex) {\n             throw new AndrolibException(ex);\n         }\n@@ -169,14 +169,14 @@ public void decodeResources(File outDir) throws AndrolibException {\n \n             LOGGER.info(\"Decoding file-resources...\");\n             for (ResResource res : pkg.listFiles()) {\n-                fileDecoder.decode(res, in, out, mResFileMapping);\n+                fileDecoder.decode(res, in, outRes, mResFileMapping);\n             }\n \n             LOGGER.info(\"Decoding values */* XMLs...\");\n             for (ResValuesFile valuesFile : pkg.listValuesFiles()) {\n-                generateValuesFile(valuesFile, out, xmlSerializer);\n+                generateValuesFile(valuesFile, outRes, xmlSerializer);\n             }\n-            generatePublicXml(pkg, out, xmlSerializer);\n+            generatePublicXml(pkg, outRes, xmlSerializer);\n         }\n \n         AndrolibException decodeError = axmlParser.getFirstError();"
        },
        {
          "filename": "brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResFileDecoder.java",
          "status": "modified",
          "additions": 9,
          "deletions": 1,
          "patch": "@@ -25,6 +25,7 @@\n import brut.directory.DirUtil;\n import brut.directory.Directory;\n import brut.directory.DirectoryException;\n+import brut.util.BrutIO;\n \n import java.io.*;\n import java.util.Map;\n@@ -44,8 +45,15 @@ public void decode(ResResource res, Directory inDir, Directory outDir, Map<Strin\n         ResFileValue fileValue = (ResFileValue) res.getValue();\n         String inFilePath = fileValue.toString();\n         String inFileName = fileValue.getStrippedPath();\n-        String outResName = res.getFilePath();\n         String typeName = res.getResSpec().getType().getName();\n+        String outResName = res.getFilePath();\n+\n+        if (BrutIO.detectPossibleDirectoryTraversal(outResName)) {\n+            outResName = inFileName;\n+            LOGGER.warning(String.format(\n+                \"Potentially malicious file path: %s, using instead %s\", res.getFilePath(), outResName\n+            ));\n+        }\n \n         String ext = null;\n         String outFileName;"
        },
        {
          "filename": "brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ResourceDirectoryTraversalTest.java",
          "status": "added",
          "additions": 65,
          "deletions": 0,
          "patch": "@@ -0,0 +1,65 @@\n+/*\n+ *  Copyright (C) 2010 Ryszard Wi\u015bniewski <brut.alll@gmail.com>\n+ *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package brut.androlib.decode;\n+\n+import brut.androlib.ApkDecoder;\n+import brut.androlib.BaseTest;\n+import brut.androlib.Config;\n+import brut.androlib.TestUtils;\n+import brut.common.BrutException;\n+import brut.directory.ExtFile;\n+import brut.util.OS;\n+import brut.util.OSDetection;\n+import org.junit.AfterClass;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class ResourceDirectoryTraversalTest extends BaseTest {\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        TestUtils.cleanFrameworkFile();\n+        sTmpDir = new ExtFile(OS.createTempDirectory());\n+        TestUtils.copyResourceDir(ResourceDirectoryTraversalTest.class, \"decode/arbitrary-write/\", sTmpDir);\n+        Assume.assumeFalse(OSDetection.isWindows());\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws BrutException {\n+        OS.rmdir(sTmpDir);\n+    }\n+\n+    @Test\n+    public void checkIfMaliciousRawFileIsDisassembledProperly() throws BrutException, IOException {\n+        String apk = \"GHSA-2hqv-2xv4-5h5w.apk\";\n+\n+        Config config = Config.getDefaultConfig();\n+        config.forceDelete = true;\n+        ApkDecoder apkDecoder = new ApkDecoder(config, new File(sTmpDir + File.separator + apk));\n+        File outDir = new File(sTmpDir + File.separator + apk + \".out\");\n+        apkDecoder.decode(outDir);\n+\n+        File pocTestFile =  new File(outDir,\"res/raw/poc\");\n+        assertTrue(pocTestFile.exists());\n+    }\n+}"
        },
        {
          "filename": "brut.apktool/apktool-lib/src/test/java/brut/androlib/util/UnknownDirectoryTraversalTest.java",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -51,7 +51,7 @@ public static void afterClass() throws BrutException {\n \n     @Test\n     public void validFileTest() throws IOException, BrutException {\n-        String validFilename = BrutIO.sanitizeUnknownFile(sTmpDir, \"file\");\n+        String validFilename = BrutIO.sanitizeFilepath(sTmpDir, \"file\");\n         assertEquals(validFilename, \"file\");\n \n         File validFile = new File(sTmpDir, validFilename);\n@@ -60,18 +60,18 @@ public void validFileTest() throws IOException, BrutException {\n \n     @Test(expected = TraversalUnknownFileException.class)\n     public void invalidBackwardFileTest() throws IOException, BrutException {\n-        BrutIO.sanitizeUnknownFile(sTmpDir, \"../file\");\n+        BrutIO.sanitizeFilepath(sTmpDir, \"../file\");\n     }\n \n     @Test(expected = RootUnknownFileException.class)\n     public void invalidRootFileTest() throws IOException, BrutException {\n         String rootLocation = OSDetection.isWindows() ? \"C:/\" : File.separator;\n-        BrutIO.sanitizeUnknownFile(sTmpDir, rootLocation + \"file\");\n+        BrutIO.sanitizeFilepath(sTmpDir, rootLocation + \"file\");\n     }\n \n     @Test(expected = InvalidUnknownFileException.class)\n     public void noFilePassedTest() throws IOException, BrutException {\n-        BrutIO.sanitizeUnknownFile(sTmpDir, \"\");\n+        BrutIO.sanitizeFilepath(sTmpDir, \"\");\n     }\n \n     @Test(expected = TraversalUnknownFileException.class)\n@@ -83,12 +83,12 @@ public void invalidBackwardPathOnWindows() throws IOException, BrutException {\n             invalidPath = \"..\\\\..\\\\app.exe\";\n         }\n \n-        BrutIO.sanitizeUnknownFile(sTmpDir, invalidPath);\n+        BrutIO.sanitizeFilepath(sTmpDir, invalidPath);\n     }\n \n     @Test\n     public void validDirectoryFileTest() throws IOException, BrutException {\n-        String validFilename = BrutIO.sanitizeUnknownFile(sTmpDir, \"dir\" + File.separator + \"file\");\n+        String validFilename = BrutIO.sanitizeFilepath(sTmpDir, \"dir\" + File.separator + \"file\");\n         assertEquals(\"dir\" + File.separator + \"file\", validFilename);\n     }\n }"
        },
        {
          "filename": "brut.apktool/apktool-lib/src/test/resources/decode/arbitrary-write/GHSA-2hqv-2xv4-5h5w.apk",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "brut.j.dir/src/main/java/brut/directory/DirUtil.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -89,7 +89,7 @@ public static void copyToDir(Directory in, File out, String fileName)\n             } else if (!in.containsDir(fileName) && !in.containsFile(fileName)) {\n                 // Skip copies of directories/files not found.\n             } else {\n-                String cleanedFilename = BrutIO.sanitizeUnknownFile(out, fileName);\n+                String cleanedFilename = BrutIO.sanitizeFilepath(out, fileName);\n                 if (! cleanedFilename.isEmpty()) {\n                     File outFile = new File(out, cleanedFilename);\n                     //noinspection ResultOfMethodCallIgnored"
        },
        {
          "filename": "brut.j.dir/src/main/java/brut/directory/FileDirectory.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -119,7 +119,7 @@ private void loadAll() {\n         }\n     }\n \n-    private File getDir() {\n+    public File getDir() {\n         return mDir;\n     }\n }"
        },
        {
          "filename": "brut.j.dir/src/main/java/brut/directory/ZipUtils.java",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -57,8 +57,8 @@ private static void processFolder(final File folder, final ZipOutputStream zipOu\n             throws BrutException, IOException {\n         for (final File file : folder.listFiles()) {\n             if (file.isFile()) {\n-                final String cleanedPath = BrutIO.sanitizeUnknownFile(folder, file.getPath().substring(prefixLength));\n-                final ZipEntry zipEntry = new ZipEntry(BrutIO.normalizePath(cleanedPath));\n+                final String cleanedPath = BrutIO.sanitizeFilepath(folder, file.getPath().substring(prefixLength));\n+                final ZipEntry zipEntry = new ZipEntry(BrutIO.adaptSeparatorToUnix(cleanedPath));\n \n                 // aapt binary by default takes in parameters via -0 arsc to list extensions that shouldn't be\n                 // compressed. We will replicate that behavior"
        },
        {
          "filename": "brut.j.util/src/main/java/brut/util/BrutIO.java",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -74,8 +74,8 @@ public static CRC32 calculateCrc(InputStream input) throws IOException {\n         return crc;\n     }\n \n-    public static String sanitizeUnknownFile(final File directory, final String entry) throws IOException, BrutException {\n-        if (entry.length() == 0) {\n+    public static String sanitizeFilepath(final File directory, final String entry) throws IOException, BrutException {\n+        if (entry.isEmpty()) {\n             throw new InvalidUnknownFileException(\"Invalid Unknown File\");\n         }\n \n@@ -94,7 +94,14 @@ public static String sanitizeUnknownFile(final File directory, final String entr\n         return canonicalEntryPath.substring(canonicalDirPath.length());\n     }\n \n-    public static String normalizePath(String path) {\n+    public static boolean detectPossibleDirectoryTraversal(String entry) {\n+        if (OSDetection.isWindows()) {\n+            return entry.contains(\"..\\\\\") || entry.contains(\"\\\\..\");\n+        }\n+        return entry.contains(\"../\") || entry.contains(\"/..\");\n+    }\n+\n+    public static String adaptSeparatorToUnix(String path) {\n         char separator = File.separatorChar;\n \n         if (separator != '/') {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 8,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f8092846d09a0598cdf193d238918855b84cf52d",
            "date": "2024-12-29T13:09:28Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "836a24365c8e4a36e371739ae6d301b3cf7f8a67",
            "date": "2024-12-29T12:34:01Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "f6d568ba353a9458cf67379a3433e84cdae90155",
            "date": "2024-12-29T12:23:08Z",
            "author_login": "IgorEisberg"
          },
          {
            "sha": "70a99d2e1c41f1788f8352b76ae3f68d61d54bb2",
            "date": "2024-12-20T14:37:36Z",
            "author_login": "iBotPeaches"
          },
          {
            "sha": "543386612a5fb149069816079eb63b6a8b20e414",
            "date": "2024-12-17T01:17:10Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-22",
    "description": "Apktool is a tool for reverse engineering Android APK files. In versions 2.9.1 and prior, Apktool infers resource files' output path according to their resource names which can be manipulated by attacker to place files at desired location on the system Apktool runs on. Affected environments are those in which an attacker may write/overwrite any file that user has write access, and either user name is known or cwd is under user folder. Commit d348c43b24a9de350ff6e5bd610545a10c1fc712 contains a patch for this issue.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-03T17:15:13.103",
    "last_modified": "2024-11-21T08:54:46.160",
    "fix_date": "2024-01-02T11:11:03Z"
  },
  "references": [
    {
      "url": "https://github.com/iBotPeaches/Apktool/commit/d348c43b24a9de350ff6e5bd610545a10c1fc712",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/iBotPeaches/Apktool/security/advisories/GHSA-2hqv-2xv4-5h5w",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/iBotPeaches/Apktool/commit/d348c43b24a9de350ff6e5bd610545a10c1fc712",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/iBotPeaches/Apktool/security/advisories/GHSA-2hqv-2xv4-5h5w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:44.134099",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Apktool",
    "owner": "iBotPeaches",
    "created_at": "2012-03-19T17:46:53Z",
    "updated_at": "2025-01-14T12:47:40Z",
    "pushed_at": "2025-01-13T10:02:41Z",
    "size": 314542,
    "stars": 20709,
    "forks": 3630,
    "open_issues": 77,
    "watchers": 20709,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "2.7.x",
      "2.9.x",
      "docs",
      "master"
    ],
    "languages": {
      "Java": 705168,
      "Shell": 5394,
      "Smali": 3679,
      "Batchfile": 1156
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:58:08.125070"
  }
}