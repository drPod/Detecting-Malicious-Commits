{
  "cve_id": "CVE-2024-21664",
  "github_data": {
    "repository": "lestrrat-go/jwx",
    "fix_commit": "0e8802ce6842625845d651456493e7c87625601f",
    "related_commits": [
      "0e8802ce6842625845d651456493e7c87625601f",
      "8c53d0ae52d5ab1e2b37c5abb67def9e7958fd65",
      "d69a721931a5c48b9850a42404f18e143704adcd",
      "0e8802ce6842625845d651456493e7c87625601f",
      "8c53d0ae52d5ab1e2b37c5abb67def9e7958fd65",
      "d69a721931a5c48b9850a42404f18e143704adcd"
    ],
    "patch_url": "https://github.com/lestrrat-go/jwx/commit/0e8802ce6842625845d651456493e7c87625601f.patch",
    "fix_commit_details": {
      "sha": "0e8802ce6842625845d651456493e7c87625601f",
      "commit_date": "2024-01-09T00:45:34Z",
      "author": {
        "login": "lestrrat",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-pvcr-v8j8-j5q3",
        "length": 329,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 72,
        "additions": 72,
        "deletions": 0
      },
      "files": [
        {
          "filename": "Changes",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -10,6 +10,16 @@ v2.0.19 UNRELEASED\n     was caused by actual verification step or something else, for example, while fetching\n     a key from datasource\n \n+[Security Fixes]\n+  * [jws] JWS messages formated in full JSON format (i.e. not the compact format, which\n+    consists of three base64 strings concatenated with a '.') with missing \"protected\"\n+    headers could cause a panic, thereby introducing a possiblity of a DoS.\n+\n+    This has been fixed so that the `jws.Parse` function succeeds in parsing a JWS message\n+    lacking a protected header. Calling `jws.Verify` on this same JWS message will result\n+    in a failed verification attempt. Note that this behavior will differ slightly when\n+    parsing JWS messages in compact form, which result in an error. \n+\n v2.0.18 03 Dec 2023\n [Security Fixes]\n   * [jwe] A large number in p2c parameter for PBKDF2 based encryptions could cause a DoS attack,"
        },
        {
          "filename": "jws/jws_test.go",
          "status": "modified",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -1835,3 +1835,55 @@ func TestValidateKey(t *testing.T) {\n \t_, err = jws.Verify(signed, jws.WithKey(jwa.RS256, pubKey), jws.WithValidateKey(true))\n \trequire.NoError(t, err, `jws.Verify should succeed`)\n }\n+\n+func TestEmptyProtectedField(t *testing.T) {\n+\t// MEMO: this was the only test case from the original report\n+\t// This passes. It should produce an invalid JWS message, but\n+\t// that's not `jws.Parse`'s problem.\n+\t_, err := jws.Parse([]byte(`{\"signature\": \"\"}`))\n+\trequire.NoError(t, err, `jws.Parse should fail`)\n+\n+\t// Also test that non-flattened serialization passes.\n+\t_, err = jws.Parse([]byte(`{\"signatures\": [{}]}`))\n+\trequire.NoError(t, err, `jws.Parse should fail`)\n+\n+\t// MEMO: rest of the cases are present to be extra pedantic about it\n+\n+\tprivKey, err := jwxtest.GenerateRsaJwk()\n+\trequire.NoError(t, err, `jwxtest.GenerateRsaJwk should succeed`)\n+\n+\t// This fails. `jws.Parse` works, but the subsequent verification\n+\t// workflow fails to verify anything without the presense of a signature or\n+\t// a protected header.\n+\t_, err = jws.Verify([]byte(`{\"signature\": \"\"}`), jws.WithKey(jwa.RS256, privKey))\n+\trequire.Error(t, err, `jws.Parse should fail`)\n+\n+\t// Create a valid signatre.\n+\tsigned, err := jws.Sign([]byte(\"Lorem Ipsum\"), jws.WithKey(jwa.RS256, privKey))\n+\trequire.NoError(t, err, `jws.Sign should succeed`)\n+\n+\t_, payload, signature, err := jws.SplitCompact(signed)\n+\trequire.NoError(t, err, `jws.SplitCompact should succeed`)\n+\n+\t// This fails as well. we have a valid signature and a valid\n+\t// key to verify it, but no protected headers\n+\t_, err = jws.Verify(\n+\t\t[]byte(fmt.Sprintf(`{\"signature\": \"%s\"}`, signature)),\n+\t\tjws.WithKey(jwa.RS256, privKey),\n+\t)\n+\trequire.Error(t, err, `jws.Verify should fail`)\n+\n+\t// Test for cases when we have an incomplete compact form JWS\n+\tvar buf bytes.Buffer\n+\tbuf.WriteRune('.')\n+\tbuf.Write(payload)\n+\tbuf.WriteRune('.')\n+\tbuf.Write(signature)\n+\tinvalidMessage := buf.Bytes()\n+\n+\t// This is an error because the format is simply wrong.\n+\t// Whereas in the other JSON-based JWS's case the lack of protected field\n+\t// is not a SYNTAX error, this one is, and therefore we barf.\n+\t_, err = jws.Parse(invalidMessage)\n+\trequire.Error(t, err, `jws.Parse should fail`)\n+}"
        },
        {
          "filename": "jws/message.go",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -278,6 +278,11 @@ func (m *Message) UnmarshalJSON(buf []byte) error {\n \t\t\t}\n \t\t\tsig.SetDecodeCtx(nil)\n \n+\t\t\tif sig.protected == nil {\n+\t\t\t\t// Instead of barfing on a nil protected header, use an empty header\n+\t\t\t\tsig.protected = NewHeaders()\n+\t\t\t}\n+\n \t\t\tif i == 0 {\n \t\t\t\tif !getB64Value(sig.protected) {\n \t\t\t\t\tb64 = false\n@@ -313,6 +318,11 @@ func (m *Message) UnmarshalJSON(buf []byte) error {\n \t\t\tsig.protected = prt\n \t\t}\n \n+\t\tif sig.protected == nil {\n+\t\t\t// Instead of barfing on a nil protected header, use an empty header\n+\t\t\tsig.protected = NewHeaders()\n+\t\t}\n+\n \t\tdecoded, err := base64.DecodeString(*mup.Signature)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(`failed to base64 decode flattened signature: %w`, err)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "19d4fae3f38edda58757b5f7da39d3875e296f26",
            "date": "2024-12-04T01:54:09Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "2e57119d7ac121220efe7efae836dc893d0950b2",
            "date": "2024-11-24T23:57:50Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "7be8d77a3de9811ad9db66d144d5901ccfed7830",
            "date": "2024-11-24T06:55:12Z",
            "author_login": "lestrrat"
          },
          {
            "sha": "24d60ab4e9149dd91031f2c6385a537b368b4659",
            "date": "2024-11-11T07:57:03Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "27f2f3fb779a7cd684145c09937b4ee8976e2589",
            "date": "2024-11-11T07:50:18Z",
            "author_login": "lestrrat"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-476",
    "description": "jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. Calling `jws.Parse` with a JSON serialized payload where the `signature` field is present while `protected` is absent can lead to a nil pointer dereference. The vulnerability can be used to crash/DOS a system doing JWS verification. This vulnerability has been patched in versions 2.0.19 and 1.2.28.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-09T20:15:43.740",
    "last_modified": "2024-11-21T08:54:49.440",
    "fix_date": "2024-01-09T00:45:34Z"
  },
  "references": [
    {
      "url": "https://github.com/lestrrat-go/jwx/commit/0e8802ce6842625845d651456493e7c87625601f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/commit/8c53d0ae52d5ab1e2b37c5abb67def9e7958fd65",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/commit/d69a721931a5c48b9850a42404f18e143704adcd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-pvcr-v8j8-j5q3",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/commit/0e8802ce6842625845d651456493e7c87625601f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/commit/8c53d0ae52d5ab1e2b37c5abb67def9e7958fd65",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/commit/d69a721931a5c48b9850a42404f18e143704adcd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-pvcr-v8j8-j5q3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:06:44.152961",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jwx",
    "owner": "lestrrat-go",
    "created_at": "2015-11-04T05:12:52Z",
    "updated_at": "2025-01-14T07:34:16Z",
    "pushed_at": "2025-01-07T07:26:48Z",
    "size": 14286,
    "stars": 1983,
    "forks": 164,
    "open_issues": 9,
    "watchers": 1983,
    "has_security_policy": false,
    "default_branch": "develop/v3",
    "protected_branches": [
      "develop/v1",
      "develop/v2",
      "develop/v2.2",
      "develop/v3",
      "v1",
      "v2",
      "v3"
    ],
    "languages": {
      "Go": 973485,
      "Starlark": 24657,
      "Shell": 7002,
      "Perl": 2801,
      "Makefile": 2366
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:02:24.530300"
  }
}