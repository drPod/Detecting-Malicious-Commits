{
  "cve_id": "CVE-2024-22415",
  "github_data": {
    "repository": "jupyter-lsp/jupyterlab-lsp",
    "fix_commit": "4ad12f204ad0b85580fc32137c647baaff044e95",
    "related_commits": [
      "4ad12f204ad0b85580fc32137c647baaff044e95",
      "4ad12f204ad0b85580fc32137c647baaff044e95"
    ],
    "patch_url": "https://github.com/jupyter-lsp/jupyterlab-lsp/commit/4ad12f204ad0b85580fc32137c647baaff044e95.patch",
    "fix_commit_details": {
      "sha": "4ad12f204ad0b85580fc32137c647baaff044e95",
      "commit_date": "2024-01-17T21:58:35Z",
      "author": {
        "login": "krassowski",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-4qhp-652w-c22x",
        "length": 485,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 274,
        "additions": 260,
        "deletions": 14
      },
      "files": [
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/handlers.py",
          "status": "modified",
          "additions": 56,
          "deletions": 5,
          "patch": "@@ -2,14 +2,32 @@\n \"\"\"\n from typing import Optional, Text\n \n+from jupyter_core.utils import ensure_async\n from jupyter_server.base.handlers import APIHandler\n-from jupyter_server.base.zmqhandlers import WebSocketHandler, WebSocketMixin\n from jupyter_server.utils import url_path_join as ujoin\n+from tornado import web\n+from tornado.websocket import WebSocketHandler\n+\n+try:\n+    from jupyter_server.auth.decorator import authorized\n+except ImportError:\n+\n+    def authorized(method):  # type: ignore\n+        \"\"\"A no-op fallback for `jupyter_server 1.x`\"\"\"\n+        return method\n+\n+\n+try:\n+    from jupyter_server.base.websocket import WebSocketMixin\n+except ImportError:\n+    from jupyter_server.base.zmqhandlers import WebSocketMixin\n \n from .manager import LanguageServerManager\n from .schema import SERVERS_RESPONSE\n from .specs.utils import censored_spec\n \n+AUTH_RESOURCE = \"lsp\"\n+\n \n class BaseHandler(APIHandler):\n     manager = None  # type: LanguageServerManager\n@@ -21,10 +39,43 @@ def initialize(self, manager: LanguageServerManager):\n class LanguageServerWebSocketHandler(  # type: ignore\n     WebSocketMixin, WebSocketHandler, BaseHandler\n ):\n-    \"\"\"Setup tornado websocket to route to language server sessions\"\"\"\n+    \"\"\"Setup tornado websocket to route to language server sessions.\n+\n+    The logic of `get` and `pre_get` methods is derived from jupyter-server ws handlers,\n+    and should be kept in sync to follow best practice established by upstream; see:\n+    https://github.com/jupyter-server/jupyter_server/blob/v2.12.5/jupyter_server/services/kernels/websocket.py#L36\n+    \"\"\"\n+\n+    auth_resource = AUTH_RESOURCE\n \n     language_server: Optional[Text] = None\n \n+    async def pre_get(self):\n+        \"\"\"Handle a pre_get.\"\"\"\n+        # authenticate first\n+        # authenticate the request before opening the websocket\n+        user = self.current_user\n+        if user is None:\n+            self.log.warning(\"Couldn't authenticate WebSocket connection\")\n+            raise web.HTTPError(403)\n+\n+        if not hasattr(self, \"authorizer\"):\n+            return\n+\n+        # authorize the user.\n+        is_authorized = await ensure_async(\n+            self.authorizer.is_authorized(self, user, \"execute\", AUTH_RESOURCE)\n+        )\n+        if not is_authorized:\n+            raise web.HTTPError(403)\n+\n+    async def get(self, *args, **kwargs):\n+        \"\"\"Get an event socket.\"\"\"\n+        await self.pre_get()\n+        res = super().get(*args, **kwargs)\n+        if res is not None:\n+            await res\n+\n     async def open(self, language_server):\n         await self.manager.ready()\n         self.language_server = language_server\n@@ -47,11 +98,11 @@ class LanguageServersHandler(BaseHandler):\n     Response should conform to schema in schema/servers.schema.json\n     \"\"\"\n \n+    auth_resource = AUTH_RESOURCE\n     validator = SERVERS_RESPONSE\n \n-    def initialize(self, *args, **kwargs):\n-        super().initialize(*args, **kwargs)\n-\n+    @web.authenticated\n+    @authorized\n     async def get(self):\n         \"\"\"finish with the JSON representations of the sessions\"\"\"\n         await self.manager.ready()"
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/paths.py",
          "status": "modified",
          "additions": 12,
          "deletions": 2,
          "patch": "@@ -1,6 +1,7 @@\n import os\n-import pathlib\n import re\n+from pathlib import Path\n+from typing import Union\n from urllib.parse import unquote, urlparse\n \n RE_PATH_ANCHOR = r\"^file://([^/]+|/[A-Z]:)\"\n@@ -12,7 +13,7 @@ def normalized_uri(root_dir):\n     Special care must be taken around windows paths: the canonical form of\n     windows drives and UNC paths is lower case\n     \"\"\"\n-    root_uri = pathlib.Path(root_dir).expanduser().resolve().as_uri()\n+    root_uri = Path(root_dir).expanduser().resolve().as_uri()\n     root_uri = re.sub(\n         RE_PATH_ANCHOR, lambda m: \"file://{}\".format(m.group(1).lower()), root_uri\n     )\n@@ -33,3 +34,12 @@ def file_uri_to_path(file_uri):\n     else:\n         result = file_uri_path_unquoted  # pragma: no cover\n     return result\n+\n+\n+def is_relative(root: Union[str, Path], path: Union[str, Path]) -> bool:\n+    \"\"\"Return if path is relative to root\"\"\"\n+    try:\n+        Path(path).resolve().relative_to(Path(root).resolve())\n+        return True\n+    except ValueError:\n+        return False"
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/serverextension.py",
          "status": "modified",
          "additions": 9,
          "deletions": 1,
          "patch": "@@ -4,6 +4,7 @@\n from pathlib import Path\n \n import traitlets\n+from tornado import ioloop\n \n from .handlers import add_handlers\n from .manager import LanguageServerManager\n@@ -73,4 +74,11 @@ def load_jupyter_server_extension(nbapp):\n     page_config.update(rootUri=root_uri, virtualDocumentsUri=virtual_documents_uri)\n \n     add_handlers(nbapp)\n-    nbapp.io_loop.call_later(0, initialize, nbapp, virtual_documents_uri)\n+\n+    if hasattr(nbapp, \"io_loop\"):\n+        io_loop = nbapp.io_loop\n+    else:\n+        # handle jupyter_server 1.x\n+        io_loop = ioloop.IOLoop.current()\n+\n+    io_loop.call_later(0, initialize, nbapp, virtual_documents_uri)"
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/tests/conftest.py",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -5,6 +5,7 @@\n \n from jupyter_server.serverapp import ServerApp\n from pytest import fixture\n+from tornado.httpserver import HTTPRequest\n from tornado.httputil import HTTPServerRequest\n from tornado.queues import Queue\n from tornado.web import Application\n@@ -141,9 +142,11 @@ def send_ping(self):\n \n class MockHandler(LanguageServersHandler):\n     _payload = None\n+    _jupyter_current_user = \"foo\"  # type:ignore[assignment]\n \n     def __init__(self):\n-        pass\n+        self.request = HTTPRequest(\"GET\")\n+        self.application = Application()\n \n     def finish(self, payload):\n         self._payload = payload"
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/tests/test_auth.py",
          "status": "added",
          "additions": 117,
          "deletions": 0,
          "patch": "@@ -0,0 +1,117 @@\n+\"\"\"Integration tests of authorization running under jupyter-server.\"\"\"\n+import json\n+import os\n+import socket\n+import subprocess\n+import time\n+import uuid\n+from typing import Generator, Tuple\n+from urllib.error import HTTPError, URLError\n+from urllib.request import urlopen\n+\n+import pytest\n+\n+from .conftest import KNOWN_SERVERS\n+\n+LOCALHOST = \"127.0.0.1\"\n+REST_ROUTES = [\"/lsp/status\"]\n+WS_ROUTES = [f\"/lsp/ws/{ls}\" for ls in KNOWN_SERVERS]\n+\n+\n+@pytest.mark.parametrize(\"route\", REST_ROUTES)\n+def test_auth_rest(route: str, a_server_url_and_token: Tuple[str, str]) -> None:\n+    \"\"\"Verify a REST route only provides access to an authenticated user.\"\"\"\n+    base_url, token = a_server_url_and_token\n+\n+    verify_response(base_url, route)\n+\n+    url = f\"{base_url}{route}\"\n+\n+    with urlopen(f\"{url}?token={token}\") as response:\n+        raw_body = response.read().decode(\"utf-8\")\n+\n+    decode_error = None\n+\n+    try:\n+        json.loads(raw_body)\n+    except json.decoder.JSONDecodeError as err:\n+        decode_error = err\n+    assert not decode_error, f\"the response for {url} was not JSON\"\n+\n+\n+@pytest.mark.parametrize(\"route\", WS_ROUTES)\n+def test_auth_websocket(route: str, a_server_url_and_token: Tuple[str, str]) -> None:\n+    \"\"\"Verify a WebSocket does not provide access to an unauthenticated user.\"\"\"\n+    verify_response(a_server_url_and_token[0], route)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def a_server_url_and_token(\n+    tmp_path_factory: pytest.TempPathFactory,\n+) -> Generator[Tuple[str, str], None, None]:\n+    \"\"\"Start a temporary, isolated jupyter server.\"\"\"\n+    token = str(uuid.uuid4())\n+    port = get_unused_port()\n+\n+    root_dir = tmp_path_factory.mktemp(\"root_dir\")\n+    home = tmp_path_factory.mktemp(\"home\")\n+    server_conf = home / \"etc/jupyter/jupyter_config.json\"\n+\n+    server_conf.parent.mkdir(parents=True)\n+    extensions = {\"jupyter_lsp\": True, \"jupyterlab\": False, \"nbclassic\": False}\n+    app = {\"jpserver_extensions\": extensions, \"token\": token}\n+    config_data = {\"ServerApp\": app, \"IdentityProvider\": {\"token\": token}}\n+\n+    server_conf.write_text(json.dumps(config_data), encoding=\"utf-8\")\n+    args = [\"jupyter-server\", f\"--port={port}\", \"--no-browser\"]\n+    env = dict(os.environ)\n+    env.update(\n+        HOME=str(home),\n+        USERPROFILE=str(home),\n+        JUPYTER_CONFIG_DIR=str(server_conf.parent),\n+    )\n+    proc = subprocess.Popen(args, cwd=str(root_dir), env=env, stdin=subprocess.PIPE)\n+    url = f\"http://{LOCALHOST}:{port}\"\n+    retries = 20\n+    while retries:\n+        time.sleep(1)\n+        try:\n+            urlopen(f\"{url}/favicon.ico\")\n+            break\n+        except URLError:\n+            print(f\"[{retries} / 20] ...\", flush=True)\n+            retries -= 1\n+            continue\n+    yield url, token\n+    proc.terminate()\n+    proc.communicate(b\"y\\n\")\n+    proc.wait()\n+    assert proc.returncode is not None, \"jupyter-server probably still running\"\n+\n+\n+def get_unused_port():\n+    \"\"\"Get an unused port by trying to listen to any random port.\n+\n+    Probably could introduce race conditions if inside a tight loop.\n+    \"\"\"\n+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+    sock.bind((LOCALHOST, 0))\n+    sock.listen(1)\n+    port = sock.getsockname()[1]\n+    sock.close()\n+    return port\n+\n+\n+def verify_response(base_url: str, route: str, expect: int = 403):\n+    \"\"\"Verify that a response returns the expected error.\"\"\"\n+    error = None\n+    body = None\n+    url = f\"{base_url}{route}\"\n+    try:\n+        with urlopen(url) as res:\n+            body = res.read()\n+    except HTTPError as err:\n+        error = err\n+    assert error, f\"no HTTP error for {url}: {body}\"\n+    http_code = error.getcode()\n+    assert http_code == expect, f\"{url} HTTP code was unexpected: {body}\""
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/tests/test_paths.py",
          "status": "modified",
          "additions": 40,
          "deletions": 1,
          "patch": "@@ -4,7 +4,7 @@\n \n import pytest\n \n-from ..paths import file_uri_to_path, normalized_uri\n+from ..paths import file_uri_to_path, is_relative, normalized_uri\n \n WIN = platform.system() == \"Windows\"\n HOME = pathlib.Path(\"~\").expanduser()\n@@ -17,6 +17,45 @@ def test_normalize_posix_path_home(root_dir, expected_root_uri):  # pragma: no c\n     assert normalized_uri(root_dir) == expected_root_uri\n \n \n+@pytest.mark.skipif(WIN, reason=\"can't test POSIX paths on Windows\")\n+@pytest.mark.parametrize(\n+    \"root, path\",\n+    [[\"~\", \"~/a\"], [\"~\", \"~/a/../b/\"], [\"/\", \"/\"], [\"/a\", \"/a/b\"], [\"/a\", \"/a/b/../c\"]],\n+)\n+def test_is_relative_ok(root, path):\n+    assert is_relative(root, path)\n+\n+\n+@pytest.mark.skipif(WIN, reason=\"can't test POSIX paths on Windows\")\n+@pytest.mark.parametrize(\n+    \"root, path\",\n+    [\n+        [\"~\", \"~/..\"],\n+        [\"~\", \"/\"],\n+        [\"/a\", \"/\"],\n+        [\"/a/b\", \"/a\"],\n+        [\"/a/b\", \"/a/b/..\"],\n+        [\"/a\", \"/a/../b\"],\n+        [\"/a\", \"a//\"],\n+    ],\n+)\n+def test_is_relative_not_ok(root, path):\n+    assert not is_relative(root, path)\n+\n+\n+@pytest.mark.skipif(not WIN, reason=\"can't test Windows paths on POSIX\")\n+@pytest.mark.parametrize(\n+    \"root, path\",\n+    [\n+        [\"c:\\\\Users\\\\user1\", \"c:\\\\Users\\\\\"],\n+        [\"c:\\\\Users\\\\user1\", \"d:\\\\\"],\n+        [\"c:\\\\Users\", \"c:\\\\Users\\\\..\"],\n+    ],\n+)\n+def test_is_relative_not_ok_win(root, path):\n+    assert not is_relative(root, path)\n+\n+\n @pytest.mark.skipif(PY35, reason=\"can't test non-existent paths on py35\")\n @pytest.mark.skipif(WIN, reason=\"can't test POSIX paths on Windows\")\n @pytest.mark.parametrize("
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/tests/test_virtual_documents_shadow.py",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -210,6 +210,21 @@ def run_shadow(message):\n         )\n \n \n+@pytest.mark.asyncio\n+async def test_shadow_traversal(shadow_path, manager):\n+    file_beyond_shadow_root_uri = (Path(shadow_path) / \"..\" / \"test.py\").as_uri()\n+\n+    shadow = setup_shadow_filesystem(Path(shadow_path).as_uri())\n+\n+    def run_shadow(message):\n+        return shadow(\"client\", message, \"python-lsp-server\", manager)\n+\n+    with pytest.raises(\n+        ShadowFilesystemError, match=\"is not relative to shadow filesystem root\"\n+    ):\n+        await run_shadow(did_open(file_beyond_shadow_root_uri, \"content\"))\n+\n+\n @pytest.fixture\n def forbidden_shadow_path(tmpdir):\n     path = Path(tmpdir) / \"no_permission_dir\"\n@@ -238,7 +253,7 @@ def send_change():\n     # no message should be emitted during the first two attempts\n     assert caplog.text == \"\"\n \n-    # a wargning should be emitted on third failure\n+    # a warning should be emitted on third failure\n     with caplog.at_level(logging.WARNING):\n         assert await send_change() is None\n     assert \"initialization of shadow filesystem failed three times\" in caplog.text"
        },
        {
          "filename": "python_packages/jupyter_lsp/jupyter_lsp/virtual_documents_shadow.py",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -8,7 +8,7 @@\n from tornado.gen import convert_yielded\n \n from .manager import lsp_message_listener\n-from .paths import file_uri_to_path\n+from .paths import file_uri_to_path, is_relative\n from .types import LanguageServerManagerAPI\n \n # TODO: make configurable\n@@ -171,6 +171,11 @@ async def shadow_virtual_documents(scope, message, language_server, manager):\n             initialized = True\n \n         path = file_uri_to_path(uri)\n+        if not is_relative(shadow_filesystem, path):\n+            raise ShadowFilesystemError(\n+                f\"Path {path} is not relative to shadow filesystem root\"\n+            )\n+\n         editable_file = EditableFile(path)\n \n         await editable_file.read()"
        },
        {
          "filename": "requirements/utest.txt",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -6,4 +6,3 @@ pytest-cov\n pytest-flake8\n pytest-runner\n python-lsp-server\n-pluggy<1.0,>=0.12  # Python 3.5 CI Travis, may need update with new pytest releases, see issue 259"
        },
        {
          "filename": "scripts/bump_versions.py",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -47,7 +47,6 @@ def maybe_change_version(self, dry: bool):\n             self.change_version(new_version=version, dry=dry)\n \n     def change_version(self, new_version: str, dry: bool):\n-\n         changelog = CHANGELOG.read_text(encoding=\"utf-8\")\n         if new_version not in changelog:\n             raise Exception("
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b2eb9b174172ce7050b515b082b86fc873264d79",
            "date": "2025-01-14T08:58:59Z",
            "author_login": "fcollonval"
          },
          {
            "sha": "f5d2b9ee99828a96e3afa2d575ce390966b69368",
            "date": "2025-01-09T09:29:08Z",
            "author_login": "jtpio"
          },
          {
            "sha": "ec483e9aee36f82c87e56e44e72ab89d27db8729",
            "date": "2024-06-21T15:17:42Z",
            "author_login": "krassowski"
          },
          {
            "sha": "b159ae2736b26463d8cc8f0ef78f4b2ce9913370",
            "date": "2024-04-09T16:58:35Z",
            "author_login": "krassowski"
          },
          {
            "sha": "acc0d741bcba58c317f80a5fcf0ac07663e6ae0c",
            "date": "2024-04-09T15:48:54Z",
            "author_login": "krassowski"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-23",
    "description": "jupyter-lsp is a coding assistance tool for JupyterLab (code navigation + hover suggestions + linters + autocompletion + rename) using Language Server Protocol. Installations of jupyter-lsp running in environments without configured file system access control (on the operating system level), and with jupyter-server instances exposed to non-trusted network are vulnerable to unauthorised access and modification of file system beyond the jupyter root directory. This issue has been patched in version 2.2.2 and all users are advised to upgrade. Users unable to upgrade should uninstall jupyter-lsp.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-18T21:15:09.087",
    "last_modified": "2024-11-21T08:56:14.390",
    "fix_date": "2024-01-17T21:58:35Z"
  },
  "references": [
    {
      "url": "https://github.com/jupyter-lsp/jupyterlab-lsp/commit/4ad12f204ad0b85580fc32137c647baaff044e95",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/jupyter-lsp/jupyterlab-lsp/security/advisories/GHSA-4qhp-652w-c22x",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/jupyter-lsp/jupyterlab-lsp/commit/4ad12f204ad0b85580fc32137c647baaff044e95",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/jupyter-lsp/jupyterlab-lsp/security/advisories/GHSA-4qhp-652w-c22x",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.504312",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jupyterlab-lsp",
    "owner": "jupyter-lsp",
    "created_at": "2019-08-17T11:34:22Z",
    "updated_at": "2025-01-14T14:13:53Z",
    "pushed_at": "2025-01-14T08:58:59Z",
    "size": 9589,
    "stars": 1838,
    "forks": 148,
    "open_issues": 206,
    "watchers": 1838,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "TypeScript": 529823,
      "Python": 170485,
      "RobotFramework": 99809,
      "Jupyter Notebook": 16323,
      "CSS": 16018,
      "JavaScript": 7945,
      "R": 538,
      "Shell": 483,
      "SCSS": 132,
      "TeX": 113,
      "Less": 97,
      "Dockerfile": 84,
      "Julia": 44
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T23:03:24.372757"
  }
}