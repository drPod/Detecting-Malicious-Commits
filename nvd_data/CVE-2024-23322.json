{
  "cve_id": "CVE-2024-23322",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "843f9e6a123ed47ce139b421c14e7126f2ac685e",
    "related_commits": [
      "843f9e6a123ed47ce139b421c14e7126f2ac685e",
      "843f9e6a123ed47ce139b421c14e7126f2ac685e"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "843f9e6a123ed47ce139b421c14e7126f2ac685e",
      "commit_date": "2023-11-15T20:38:45Z",
      "author": {
        "login": "yanavlasov",
        "type": "User",
        "stats": {
          "total_commits": 353,
          "average_weekly_commits": 0.7968397291196389,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 163
        }
      },
      "commit_message": {
        "title": "Fix crash when idle and request per try timeouts occur within backoff interval",
        "length": 320,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 90,
        "additions": 90,
        "deletions": 0
      },
      "files": [
        {
          "filename": "changelogs/current.yaml",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -55,6 +55,9 @@ bug_fixes:\n - area: url matching\n   change: |\n     Fixed excessive CPU utilization when using regex URL template matcher.\n+- area: http\n+  change: |\n+    Fixed crash when HTTP request idle and per try timeouts occurs within backoff interval.\n \n removed_config_or_runtime:\n # *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`"
        },
        {
          "filename": "source/common/router/router.cc",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -1115,6 +1115,7 @@ void Filter::onResponseTimeout() {\n // Called when the per try timeout is hit but we didn't reset the request\n // (hedge_on_per_try_timeout enabled).\n void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n+  ASSERT(!upstream_request.retried());\n   // Track this as a timeout for outlier detection purposes even though we didn't\n   // cancel the request yet and might get a 2xx later.\n   updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,"
        },
        {
          "filename": "source/common/router/upstream_request.cc",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -510,11 +510,20 @@ void UpstreamRequest::setupPerTryTimeout() {\n \n void UpstreamRequest::onPerTryIdleTimeout() {\n   ENVOY_STREAM_LOG(debug, \"upstream per try idle timeout\", *parent_.callbacks());\n+  if (per_try_timeout_) {\n+    // Disable the per try idle timer, so it does not trigger further retries\n+    per_try_timeout_->disableTimer();\n+  }\n   stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::StreamIdleTimeout);\n   parent_.onPerTryIdleTimeout(*this);\n }\n \n void UpstreamRequest::onPerTryTimeout() {\n+  if (per_try_idle_timeout_) {\n+    // Delete the per try idle timer, so it does not trigger further retries.\n+    // The timer has to be deleted to prevent data flow from re-arming it.\n+    per_try_idle_timeout_.reset();\n+  }\n   // If we've sent anything downstream, ignore the per try timeout and let the response continue\n   // up to the global timeout\n   if (!parent_.downstreamResponseStarted()) {"
        },
        {
          "filename": "test/integration/http_timeout_integration_test.cc",
          "status": "modified",
          "additions": 77,
          "deletions": 0,
          "patch": "@@ -631,4 +631,81 @@ TEST_P(HttpTimeoutIntegrationTest, RequestHeaderTimeout) {\n   EXPECT_THAT(response, AllOf(HasSubstr(\"408\"), HasSubstr(\"header\")));\n }\n \n+// Validate that Envoy correctly handles per try and per try IDLE timeouts\n+// that are firing within the backoff interval.\n+TEST_P(HttpTimeoutIntegrationTest, OriginalRequestCompletesBeforeBackoffTimer) {\n+  auto host = config_helper_.createVirtualHost(\"example.com\", \"/test_retry\");\n+  host.set_include_is_timeout_retry_header(true);\n+  config_helper_.addVirtualHost(host);\n+  config_helper_.addConfigModifier(\n+      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n+              hcm) -> void {\n+        auto* route_config = hcm.mutable_route_config();\n+        auto* virtual_host = route_config->mutable_virtual_hosts(1);\n+        auto* route = virtual_host->mutable_routes(0)->mutable_route();\n+        auto* retry_policy = route->mutable_retry_policy();\n+        retry_policy->mutable_per_try_idle_timeout()->set_seconds(0);\n+        // per try IDLE timeout is 400 ms\n+        retry_policy->mutable_per_try_idle_timeout()->set_nanos(400 * 1000 * 1000);\n+      });\n+  initialize();\n+\n+  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort(\"http\")));\n+  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n+      {\":method\", \"POST\"},\n+      {\":path\", \"/test_retry\"},\n+      {\":scheme\", \"http\"},\n+      {\":authority\", \"example.com\"},\n+      {\"x-forwarded-for\", \"10.0.0.1\"},\n+      {\"x-envoy-retry-on\", \"5xx\"},\n+      // Enable hedge_on_per_try_timeout so that original request is not reset\n+      {\"x-envoy-hedge-on-per-try-timeout\", \"true\"},\n+      {\"x-envoy-upstream-rq-timeout-ms\", \"500\"},\n+      // Make per try timeout the same as the per try idle timeout\n+      // NOTE: it can be a bit longer, within the back off interval\n+      {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"400\"}});\n+  auto response = std::move(encoder_decoder.second);\n+  request_encoder_ = &encoder_decoder.first;\n+\n+  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n+  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n+  codec_client_->sendData(*request_encoder_, 0, true);\n+\n+  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n+\n+  // Trigger per try timeout (but not global timeout). This will actually trigger\n+  // both IDLE and request timeouts in the same I/O operation.\n+  timeSystem().advanceTimeWait(std::chrono::milliseconds(400));\n+\n+  // Trigger retry (there's a 25ms backoff before it's issued).\n+  timeSystem().advanceTimeWait(std::chrono::milliseconds(26));\n+\n+  // Wait for a second request to be sent upstream\n+  FakeStreamPtr upstream_request2;\n+\n+  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request2));\n+\n+  ASSERT_TRUE(upstream_request2->waitForHeadersComplete());\n+\n+  // Expect the x-envoy-is-timeout-header to set to indicate to the upstream this is a retry\n+  // initiated by a previous per try timeout.\n+  EXPECT_EQ(upstream_request2->headers().getEnvoyIsTimeoutRetryValue(), \"true\");\n+\n+  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n+\n+  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n+\n+  // Respond to the second request (it does not matter which request gets response).\n+  upstream_request2->encodeHeaders(response_headers, true);\n+  ASSERT_TRUE(response->waitForEndStream());\n+\n+  // The first request should be reset since we used the response from the second request.\n+  ASSERT_TRUE(upstream_request_->waitForReset(std::chrono::seconds(15)));\n+\n+  codec_client_->close();\n+  EXPECT_TRUE(response->complete());\n+  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n+}\n+\n } // namespace Envoy"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "38a7619e5c5d23d279e75ca1bb67a55d1e3d766f",
            "date": "2025-01-26T08:27:27Z",
            "author_login": "ae-govau"
          },
          {
            "sha": "5f7ee8585fd3324925fa694030ce127db746f9ed",
            "date": "2025-01-26T08:12:00Z",
            "author_login": "antoniovleonti"
          },
          {
            "sha": "ad2a1c700b1cc6c8b1581bc3e2990d696501f105",
            "date": "2025-01-24T15:25:19Z",
            "author_login": "asedeno"
          },
          {
            "sha": "969348a552e76101e5dadde6b8f65694a5198fdf",
            "date": "2025-01-24T11:36:03Z",
            "author_login": "zirain"
          },
          {
            "sha": "2a9c998e1732f07f597acfa10c23342730c8fdc4",
            "date": "2025-01-24T11:11:22Z",
            "author_login": "krinkinmu"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-416",
    "description": "Envoy is a high-performance edge/middle/service proxy. Envoy will crash when certain timeouts happen within the same interval. The crash occurs when the following are true: 1. hedge_on_per_try_timeout is enabled, 2. per_try_idle_timeout is enabled (it can only be done in configuration), 3. per-try-timeout is enabled, either through headers or configuration and its value is equal, or within the backoff interval of the per_try_idle_timeout. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-09T23:15:08.747",
    "last_modified": "2024-11-21T08:57:30.260",
    "fix_date": "2023-11-15T20:38:45Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/843f9e6a123ed47ce139b421c14e7126f2ac685e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-6p83-mfmh-qv38",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/843f9e6a123ed47ce139b421c14e7126f2ac685e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-6p83-mfmh-qv38",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.109352",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-26T06:15:25Z",
    "pushed_at": "2025-01-24T15:25:20Z",
    "size": 241791,
    "stars": 25373,
    "forks": 4864,
    "open_issues": 1660,
    "watchers": 25373,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48447088,
      "Starlark": 3112278,
      "Java": 1321815,
      "Python": 604443,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 231950,
      "Go": 183281,
      "Rust": 107631,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3237,
      "avg_commits_per_week": 62.25,
      "days_active_last_year": 300
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:41:58.674890"
  }
}