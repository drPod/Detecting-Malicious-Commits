{
  "cve_id": "CVE-2024-23327",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
    "related_commits": [
      "63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
      "63895ea8e3cca9c5d3ab4c5c128ed1369969d54a"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a.patch",
    "fix_commit_details": {
      "sha": "63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
      "commit_date": "2023-07-08T11:35:42Z",
      "author": {
        "login": "jacobneiltaylor",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix crash from AWS NLB healthchecks when proxy protocol is enabled",
        "length": 318,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 117,
        "additions": 107,
        "deletions": 10
      },
      "files": [
        {
          "filename": "changelogs/current.yaml",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -48,6 +48,10 @@ bug_fixes:\n - area: tracing\n   change: |\n     Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n+- area: proxy protocol\n+  change: |\n+    Fixed a crash when Envoy is configured for PROXY protocol on both a listener and cluster, and the listener receives\n+    a PROXY protocol header with address type LOCAL (typically used for health checks).\n \n removed_config_or_runtime:\n # *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`"
        },
        {
          "filename": "source/extensions/common/proxy_protocol/proxy_protocol_header.cc",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -127,6 +127,15 @@ bool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer\n   }\n \n   ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n+  if (proxy_proto_data.src_addr_ == nullptr || proxy_proto_data.src_addr_->ip() == nullptr) {\n+    IS_ENVOY_BUG(\"Missing or incorrect source IP in proxy_proto_data_\");\n+    return false;\n+  }\n+  if (proxy_proto_data.dst_addr_ == nullptr || proxy_proto_data.dst_addr_->ip() == nullptr) {\n+    IS_ENVOY_BUG(\"Missing or incorrect dest IP in proxy_proto_data_\");\n+    return false;\n+  }\n+\n   const auto& src = *proxy_proto_data.src_addr_->ip();\n   const auto& dst = *proxy_proto_data.dst_addr_->ip();\n   generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),"
        },
        {
          "filename": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
          "status": "modified",
          "additions": 23,
          "deletions": 10,
          "patch": "@@ -144,24 +144,37 @@ ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n   if (proxy_protocol_header_.has_value() &&\n       !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n           Network::ProxyProtocolFilterState::key())) {\n-    if (!proxy_protocol_header_.value().local_command_) {\n-      auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n+    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n+    if (proxy_protocol_header_.value().local_command_) {\n+      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n+                proxy_protocol_header_.value().wholeHeaderLength(),\n+                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n+\n+      cb_->filterState().setData(\n+          Network::ProxyProtocolFilterState::key(),\n+          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n+              socket.connectionInfoProvider().remoteAddress(),\n+              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n+          StreamInfo::FilterState::StateType::Mutable,\n+          StreamInfo::FilterState::LifeSpan::Connection);\n+    } else {\n       ENVOY_LOG(\n           trace,\n-          \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",\n+          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n+          \"buffer: {}\",\n           proxy_protocol_header_.value().wholeHeaderLength(),\n           Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n           proxy_protocol_header_.value().extensions_length_,\n           Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                              proxy_protocol_header_.value().extensions_length_));\n+      cb_->filterState().setData(\n+          Network::ProxyProtocolFilterState::key(),\n+          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n+              proxy_protocol_header_.value().remote_address_,\n+              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n+          StreamInfo::FilterState::StateType::Mutable,\n+          StreamInfo::FilterState::LifeSpan::Connection);\n     }\n-\n-    cb_->filterState().setData(\n-        Network::ProxyProtocolFilterState::key(),\n-        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n-            proxy_protocol_header_.value().remote_address_,\n-            proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n-        StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n   }\n \n   if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {"
        },
        {
          "filename": "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc",
          "status": "modified",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -626,6 +626,34 @@ TEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n   disconnect();\n }\n \n+TEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n+  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n+  // no address, 1 TLV is present.\n+  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n+                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n+                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n+  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n+  connect(true, &proto_config);\n+  write(buffer, sizeof(buffer));\n+  expectData(\"moredata\");\n+\n+  auto& filter_state = server_connection_->streamInfo().filterState();\n+  const auto& proxy_proto_data = filter_state\n+                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n+                                         Network::ProxyProtocolFilterState::key())\n+                                     ->value();\n+\n+  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n+      Envoy::Network::Address::IpVersion::v6) {\n+    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n+  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n+             Envoy::Network::Address::IpVersion::v4) {\n+    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n+  }\n+  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n+  disconnect();\n+}\n+\n TEST_P(ProxyProtocolTest, V2ShortV4) {\n   // An ipv4/tcp connection that has incorrect addr-len encoded\n   constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,"
        },
        {
          "filename": "test/extensions/transport_sockets/proxy_protocol/proxy_protocol_integration_test.cc",
          "status": "modified",
          "additions": 41,
          "deletions": 0,
          "patch": "@@ -640,5 +640,46 @@ TEST_P(ProxyProtocolTLVsIntegrationTest, TestV2TLVProxyProtocolPassAll) {\n   ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n }\n \n+TEST_P(ProxyProtocolTLVsIntegrationTest, TestV2ProxyProtocolPassWithTypeLocal) {\n+  setup(true, {}, {});\n+  initialize();\n+\n+  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n+\n+  // A well-formed proxy protocol v2 header sampled from an AWS NLB healthcheck request, with\n+  // command type 'LOCAL' (0 for the low 4 bits of the 13th octet).\n+  constexpr uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51,\n+                                     0x55, 0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00,\n+                                     'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n+  Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n+  ASSERT_TRUE(tcp_client->write(buffer.toString()));\n+  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n+  std::string header_start;\n+  // - signature\n+  // - version and command type, address family and protocol, length of addresses\n+  // - src address, dest address\n+  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n+    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n+                         0x21, 0x11, 0x00, 0x0c, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n+    header_start = std::string(data, sizeof(data));\n+  } else {\n+    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n+                         0x21, 0x21, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n+                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n+    header_start = std::string(data, sizeof(data));\n+  }\n+\n+  constexpr absl::string_view more_data(\"moredata\");\n+  const size_t offset = header_start.length() + (2 * sizeof(uint16_t)); // Skip over the ports\n+  std::string observed_data;\n+  ASSERT_TRUE(fake_upstream_connection_->waitForData(offset + more_data.length(), &observed_data));\n+  EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n+  EXPECT_EQ(more_data, absl::string_view(&observed_data[offset], more_data.length()));\n+\n+  tcp_client->close();\n+  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n+}\n+\n } // namespace\n } // namespace Envoy"
        },
        {
          "filename": "test/per_file_coverage.sh",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ declare -a KNOWN_LOW_COVERAGE=(\n \"source/exe:90.3\"\n \"source/extensions/clusters/common:91.5\" # This can be increased again once `#24903` lands\n \"source/extensions/common:93.0\" #flaky: be careful adjusting\n+\"source/extensions/common/proxy_protocol:93.8\" # Adjusted for security patch\n \"source/extensions/common/tap:94.5\"\n \"source/extensions/common/wasm:88.0\" # flaky: be careful adjusting\n \"source/extensions/common/wasm/ext:92.0\""
        },
        {
          "filename": "tools/spelling/spelling_dictionary.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -993,6 +993,7 @@ netblocks\n netfilter\n netlink\n netmask\n+NLB\n NLMSG\n nonblocking\n noncopyable"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 7,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c93cf7af47f7e24c83b563d3b956074333bc4bf7",
            "date": "2025-01-14T17:23:07Z",
            "author_login": "phlax"
          },
          {
            "sha": "078dae3549912e632c3776a5e9a4679226093276",
            "date": "2025-01-14T14:27:08Z",
            "author_login": "agrawroh"
          },
          {
            "sha": "7b20933ee263eb9aeaceee6bc309b80b997cbbb2",
            "date": "2025-01-14T14:13:49Z",
            "author_login": "phlax"
          },
          {
            "sha": "03cb8d59f80a2a75d9e1289c909e5979a79ace91",
            "date": "2025-01-13T06:31:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3487b225f48717dd5a2babb5f921df4353633cee",
            "date": "2025-01-13T06:10:11Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-476",
    "description": "Envoy is a high-performance edge/middle/service proxy. When PPv2 is enabled both on a listener and subsequent cluster, the Envoy instance will segfault when attempting to craft the upstream PPv2 header. This occurs when the downstream request has a command type of LOCAL and does not have the protocol block. This issue has been addressed in releases 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-09T23:15:09.647",
    "last_modified": "2024-11-21T08:57:31.030",
    "fix_date": "2023-07-08T11:35:42Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.110094",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}