{
  "cve_id": "CVE-2024-23334",
  "github_data": {
    "repository": "aio-libs/aiohttp",
    "fix_commit": "1c335944d6a8b1298baf179b7c0b3069f10c514b",
    "related_commits": [
      "1c335944d6a8b1298baf179b7c0b3069f10c514b",
      "1c335944d6a8b1298baf179b7c0b3069f10c514b"
    ],
    "patch_url": "https://github.com/aio-libs/aiohttp/commit/1c335944d6a8b1298baf179b7c0b3069f10c514b.patch",
    "fix_commit_details": {
      "sha": "1c335944d6a8b1298baf179b7c0b3069f10c514b",
      "commit_date": "2024-01-28T18:13:06Z",
      "author": {
        "login": "Dreamsorcerer",
        "type": "User",
        "stats": {
          "total_commits": 756,
          "average_weekly_commits": 1.2813559322033898,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 119
        }
      },
      "commit_message": {
        "title": "Validate static paths (#8079)",
        "length": 79,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 138,
        "additions": 128,
        "deletions": 10
      },
      "files": [
        {
          "filename": "CHANGES/8079.bugfix.rst",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Improved validation of paths for static resources -- by :user:`bdraco`."
        },
        {
          "filename": "aiohttp/web_urldispatcher.py",
          "status": "modified",
          "additions": 14,
          "deletions": 4,
          "patch": "@@ -573,9 +573,14 @@ def url_for(  # type: ignore[override]\n             url = url / filename\n \n         if append_version:\n+            unresolved_path = self._directory.joinpath(filename)\n             try:\n-                filepath = self._directory.joinpath(filename).resolve()\n-                if not self._follow_symlinks:\n+                if self._follow_symlinks:\n+                    normalized_path = Path(os.path.normpath(unresolved_path))\n+                    normalized_path.relative_to(self._directory)\n+                    filepath = normalized_path.resolve()\n+                else:\n+                    filepath = unresolved_path.resolve()\n                     filepath.relative_to(self._directory)\n             except (ValueError, FileNotFoundError):\n                 # ValueError for case when path point to symlink\n@@ -640,8 +645,13 @@ async def _handle(self, request: Request) -> StreamResponse:\n                 # /static/\\\\machine_name\\c$ or /static/D:\\path\n                 # where the static dir is totally different\n                 raise HTTPForbidden()\n-            filepath = self._directory.joinpath(filename).resolve()\n-            if not self._follow_symlinks:\n+            unresolved_path = self._directory.joinpath(filename)\n+            if self._follow_symlinks:\n+                normalized_path = Path(os.path.normpath(unresolved_path))\n+                normalized_path.relative_to(self._directory)\n+                filepath = normalized_path.resolve()\n+            else:\n+                filepath = unresolved_path.resolve()\n                 filepath.relative_to(self._directory)\n         except (ValueError, FileNotFoundError) as error:\n             # relatively safe"
        },
        {
          "filename": "docs/web_advanced.rst",
          "status": "modified",
          "additions": 13,
          "deletions": 3,
          "patch": "@@ -262,12 +262,22 @@ instead could be enabled with ``show_index`` parameter set to ``True``::\n \n    web.static('/prefix', path_to_static_folder, show_index=True)\n \n-When a symlink from the static directory is accessed, the server responses to\n-client with ``HTTP/404 Not Found`` by default. To allow the server to follow\n-symlinks, parameter ``follow_symlinks`` should be set to ``True``::\n+When a symlink that leads outside the static directory is accessed, the server\n+responds to the client with ``HTTP/404 Not Found`` by default. To allow the server to\n+follow symlinks that lead outside the static root, the parameter ``follow_symlinks``\n+should be set to ``True``::\n \n    web.static('/prefix', path_to_static_folder, follow_symlinks=True)\n \n+.. caution::\n+\n+   Enabling ``follow_symlinks`` can be a security risk, and may lead to\n+   a directory transversal attack. You do NOT need this option to follow symlinks\n+   which point to somewhere else within the static directory, this option is only\n+   used to break out of the security sandbox. Enabling this option is highly\n+   discouraged, and only expected to be used for edge cases in a local\n+   development setting where remote users do not have access to the server.\n+\n When you want to enable cache busting,\n parameter ``append_version`` can be set to ``True``\n "
        },
        {
          "filename": "docs/web_reference.rst",
          "status": "modified",
          "additions": 9,
          "deletions": 3,
          "patch": "@@ -1784,9 +1784,15 @@ Application and Router\n                               by default it's not allowed and HTTP/403 will\n                               be returned on directory access.\n \n-      :param bool follow_symlinks: flag for allowing to follow symlinks from\n-                              a directory, by default it's not allowed and\n-                              HTTP/404 will be returned on access.\n+      :param bool follow_symlinks: flag for allowing to follow symlinks that lead\n+                              outside the static root directory, by default it's not allowed and\n+                              HTTP/404 will be returned on access.  Enabling ``follow_symlinks``\n+                              can be a security risk, and may lead to a directory transversal attack.\n+                              You do NOT need this option to follow symlinks which point to somewhere\n+                              else within the static directory, this option is only used to break out\n+                              of the security sandbox. Enabling this option is highly discouraged,\n+                              and only expected to be used for edge cases in a local development\n+                              setting where remote users do not have access to the server.\n \n       :param bool append_version: flag for adding file version (hash)\n                               to the url query string, this value will"
        },
        {
          "filename": "tests/test_web_urldispatcher.py",
          "status": "modified",
          "additions": 91,
          "deletions": 0,
          "patch": "@@ -108,6 +108,97 @@ async def test_follow_symlink(\n     assert (await r.text()) == data\n \n \n+async def test_follow_symlink_directory_traversal(\n+    tmp_path: pathlib.Path, aiohttp_client: AiohttpClient\n+) -> None:\n+    # Tests that follow_symlinks does not allow directory transversal\n+    data = \"private\"\n+\n+    private_file = tmp_path / \"private_file\"\n+    private_file.write_text(data)\n+\n+    safe_path = tmp_path / \"safe_dir\"\n+    safe_path.mkdir()\n+\n+    app = web.Application()\n+\n+    # Register global static route:\n+    app.router.add_static(\"/\", str(safe_path), follow_symlinks=True)\n+    client = await aiohttp_client(app)\n+\n+    await client.start_server()\n+    # We need to use a raw socket to test this, as the client will normalize\n+    # the path before sending it to the server.\n+    reader, writer = await asyncio.open_connection(client.host, client.port)\n+    writer.write(b\"GET /../private_file HTTP/1.1\\r\\n\\r\\n\")\n+    response = await reader.readuntil(b\"\\r\\n\\r\\n\")\n+    assert b\"404 Not Found\" in response\n+    writer.close()\n+    await writer.wait_closed()\n+    await client.close()\n+\n+\n+async def test_follow_symlink_directory_traversal_after_normalization(\n+    tmp_path: pathlib.Path, aiohttp_client: AiohttpClient\n+) -> None:\n+    # Tests that follow_symlinks does not allow directory transversal\n+    # after normalization\n+    #\n+    # Directory structure\n+    # |-- secret_dir\n+    # |   |-- private_file (should never be accessible)\n+    # |   |-- symlink_target_dir\n+    # |       |-- symlink_target_file (should be accessible via the my_symlink symlink)\n+    # |       |-- sandbox_dir\n+    # |           |-- my_symlink -> symlink_target_dir\n+    #\n+    secret_path = tmp_path / \"secret_dir\"\n+    secret_path.mkdir()\n+\n+    # This file is below the symlink target and should not be reachable\n+    private_file = secret_path / \"private_file\"\n+    private_file.write_text(\"private\")\n+\n+    symlink_target_path = secret_path / \"symlink_target_dir\"\n+    symlink_target_path.mkdir()\n+\n+    sandbox_path = symlink_target_path / \"sandbox_dir\"\n+    sandbox_path.mkdir()\n+\n+    # This file should be reachable via the symlink\n+    symlink_target_file = symlink_target_path / \"symlink_target_file\"\n+    symlink_target_file.write_text(\"readable\")\n+\n+    my_symlink_path = sandbox_path / \"my_symlink\"\n+    pathlib.Path(str(my_symlink_path)).symlink_to(str(symlink_target_path), True)\n+\n+    app = web.Application()\n+\n+    # Register global static route:\n+    app.router.add_static(\"/\", str(sandbox_path), follow_symlinks=True)\n+    client = await aiohttp_client(app)\n+\n+    await client.start_server()\n+    # We need to use a raw socket to test this, as the client will normalize\n+    # the path before sending it to the server.\n+    reader, writer = await asyncio.open_connection(client.host, client.port)\n+    writer.write(b\"GET /my_symlink/../private_file HTTP/1.1\\r\\n\\r\\n\")\n+    response = await reader.readuntil(b\"\\r\\n\\r\\n\")\n+    assert b\"404 Not Found\" in response\n+    writer.close()\n+    await writer.wait_closed()\n+\n+    reader, writer = await asyncio.open_connection(client.host, client.port)\n+    writer.write(b\"GET /my_symlink/symlink_target_file HTTP/1.1\\r\\n\\r\\n\")\n+    response = await reader.readuntil(b\"\\r\\n\\r\\n\")\n+    assert b\"200 OK\" in response\n+    response = await reader.readuntil(b\"readable\")\n+    assert response == b\"readable\"\n+    writer.close()\n+    await writer.wait_closed()\n+    await client.close()\n+\n+\n @pytest.mark.parametrize(\n     \"dir_name,filename,data\",\n     ["
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9482755b40ce69814eea6f65bfbd4c12d1878174",
            "date": "2025-01-10T10:46:29Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "76f4309a6cbfc12d918c65b5bffdcf0d4bb691c6",
            "date": "2025-01-10T10:39:38Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c5c204f8b661bb1c9d183e17b37013ee222b2cbd",
            "date": "2025-01-10T10:37:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a91dc8f78e97f9be30e13c39e457e8e2a2651702",
            "date": "2025-01-08T10:27:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "237d46722a0e56363c4a07dcf31e73fe4c2ea392",
            "date": "2025-01-07T11:14:58Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. When using aiohttp as a web server and configuring static routes, it is necessary to specify the root path for static files. Additionally, the option 'follow_symlinks' can be used to determine whether to follow symbolic links outside the static root directory. When 'follow_symlinks' is set to True, there is no validation to check if reading a file is within the root directory. This can lead to directory traversal vulnerabilities, resulting in unauthorized access to arbitrary files on the system, even when symlinks are not present.  Disabling follow_symlinks and using a reverse proxy are encouraged mitigations.  Version 3.9.2 fixes this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-01-29T23:15:08.563",
    "last_modified": "2024-11-21T08:57:32.007",
    "fix_date": "2024-01-28T18:13:06Z"
  },
  "references": [
    {
      "url": "https://github.com/aio-libs/aiohttp/commit/1c335944d6a8b1298baf179b7c0b3069f10c514b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/pull/8079",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/security/advisories/GHSA-5h86-8mv2-jq9f",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ICUOCFGTB25WUT336BZ4UNYLSZOUVKBD/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XXWVZIVAYWEBHNRIILZVB3R3SDQNNAA7/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/commit/1c335944d6a8b1298baf179b7c0b3069f10c514b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/pull/8079",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/security/advisories/GHSA-5h86-8mv2-jq9f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ICUOCFGTB25WUT336BZ4UNYLSZOUVKBD/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XXWVZIVAYWEBHNRIILZVB3R3SDQNNAA7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.543322",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "aiohttp",
    "owner": "aio-libs",
    "created_at": "2013-10-01T23:04:01Z",
    "updated_at": "2025-01-14T07:45:00Z",
    "pushed_at": "2025-01-13T11:21:32Z",
    "size": 31707,
    "stars": 15317,
    "forks": 2050,
    "open_issues": 250,
    "watchers": 15317,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "3.8",
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "master"
    ],
    "languages": {
      "Python": 2241563,
      "Cython": 41302,
      "Makefile": 5839,
      "Gherkin": 1248,
      "Dockerfile": 298,
      "C": 170,
      "Shell": 148
    },
    "commit_activity": {
      "total_commits_last_year": 2401,
      "avg_commits_per_week": 46.17307692307692,
      "days_active_last_year": 226
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:12:57.567310"
  }
}