{
  "cve_id": "CVE-2024-23654",
  "github_data": {
    "repository": "discourse/discourse-ai",
    "fix_commit": "94ba0dadc2cf38e8f81c3936974c167219878edd",
    "related_commits": [
      "94ba0dadc2cf38e8f81c3936974c167219878edd",
      "94ba0dadc2cf38e8f81c3936974c167219878edd"
    ],
    "patch_url": "https://github.com/discourse/discourse-ai/commit/94ba0dadc2cf38e8f81c3936974c167219878edd.patch",
    "fix_commit_details": {
      "sha": "94ba0dadc2cf38e8f81c3936974c167219878edd",
      "commit_date": "2024-02-21T20:14:50Z",
      "author": {
        "login": "romanrizzi",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "SECURITY: Place a SSRF protection when calling services from the plugin. (#485)",
        "length": 256,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 35,
        "additions": 21,
        "deletions": 14
      },
      "files": [
        {
          "filename": "lib/completions/endpoints/base.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -69,7 +69,7 @@ def perform_completion!(dialect, user, model_params = {})\n \n           prompt = dialect.translate\n \n-          Net::HTTP.start(\n+          FinalDestination::HTTP.start(\n             model_uri.host,\n             model_uri.port,\n             use_ssl: true,"
        },
        {
          "filename": "lib/inference/cloudflare_workers_ai.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -14,7 +14,8 @@ def self.perform!(model, content)\n \n         endpoint = \"#{base_url}#{model}\"\n \n-        response = Faraday.post(endpoint, content.to_json, headers)\n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n+        response = conn.post(endpoint, content.to_json, headers)\n \n         raise Net::HTTPBadResponse if ![200].include?(response.status)\n "
        },
        {
          "filename": "lib/inference/discourse_classifier.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -8,7 +8,8 @@ def self.perform!(endpoint, model, content, api_key)\n \n         headers[\"X-API-KEY\"] = api_key if api_key.present?\n \n-        response = Faraday.post(endpoint, { model: model, content: content }.to_json, headers)\n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n+        response = conn.post(endpoint, { model: model, content: content }.to_json, headers)\n \n         raise Net::HTTPBadResponse if ![200, 415].include?(response.status)\n "
        },
        {
          "filename": "lib/inference/discourse_reranker.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -8,8 +8,9 @@ def self.perform!(endpoint, model, content, candidates, api_key)\n \n         headers[\"X-API-KEY\"] = api_key if api_key.present?\n \n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n         response =\n-          Faraday.post(\n+          conn.post(\n             endpoint,\n             { model: model, content: content, candidates: candidates }.to_json,\n             headers,"
        },
        {
          "filename": "lib/inference/gemini_embeddings.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -11,7 +11,8 @@ def self.perform!(content)\n \n         body = { content: { parts: [{ text: content }] } }\n \n-        response = Faraday.post(url, body.to_json, headers)\n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n+        response = conn.post(url, body.to_json, headers)\n \n         raise Net::HTTPBadResponse if ![200].include?(response.status)\n "
        },
        {
          "filename": "lib/inference/hugging_face_text_embeddings.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -18,7 +18,8 @@ def self.perform!(content)\n           headers[\"X-API-KEY\"] = SiteSetting.ai_hugging_face_tei_api_key\n         end\n \n-        response = Faraday.post(api_endpoint, body, headers)\n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n+        response = conn.post(api_endpoint, body, headers)\n \n         raise Net::HTTPBadResponse if ![200].include?(response.status)\n "
        },
        {
          "filename": "lib/inference/open_ai_embeddings.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -15,7 +15,8 @@ def self.perform!(content, model:, dimensions: nil)\n         payload = { model: model, input: content }\n         payload[:dimensions] = dimensions if dimensions.present?\n \n-        response = Faraday.post(SiteSetting.ai_openai_embeddings_url, payload.to_json, headers)\n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n+        response = conn.post(SiteSetting.ai_openai_embeddings_url, payload.to_json, headers)\n \n         case response.status\n         when 200"
        },
        {
          "filename": "lib/inference/open_ai_image_generator.rb",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -28,7 +28,7 @@ def self.perform!(prompt, model: \"dall-e-3\", size: \"1024x1024\", api_key: nil, ap\n           response_format: \"b64_json\",\n         }\n \n-        Net::HTTP.start(\n+        FinalDestination::HTTP.start(\n           uri.host,\n           uri.port,\n           use_ssl: uri.scheme == \"https\","
        },
        {
          "filename": "lib/inference/stability_generator.rb",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -57,7 +57,8 @@ def self.perform!(\n \n         endpoint = \"v1/generation/#{engine}/text-to-image\"\n \n-        response = Faraday.post(\"#{api_url}/#{endpoint}\", payload.to_json, headers)\n+        conn = Faraday.new { |f| f.adapter FinalDestination::FaradayAdapter }\n+        response = conn.post(\"#{api_url}/#{endpoint}\", payload.to_json, headers)\n \n         if response.status != 200\n           Rails.logger.error("
        },
        {
          "filename": "spec/lib/completions/endpoints/endpoint_compliance.rb",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -99,21 +99,21 @@ def tool\n \n   def with_chunk_array_support\n     mock = mocked_http\n-    @original_net_http = ::Net.send(:remove_const, :HTTP)\n-    ::Net.send(:const_set, :HTTP, mock)\n+    @original_net_http = ::FinalDestination.send(:remove_const, :HTTP)\n+    ::FinalDestination.send(:const_set, :HTTP, mock)\n \n     yield\n   ensure\n-    ::Net.send(:remove_const, :HTTP)\n-    ::Net.send(:const_set, :HTTP, @original_net_http)\n+    ::FinalDestination.send(:remove_const, :HTTP)\n+    ::FinalDestination.send(:const_set, :HTTP, @original_net_http)\n   end\n \n   protected\n \n   # Copied from https://github.com/bblimke/webmock/issues/629\n   # Workaround for stubbing a streamed response\n   def mocked_http\n-    Class.new(::Net::HTTP) do\n+    Class.new(FinalDestination::HTTP) do\n       def request(*)\n         super do |response|\n           response.instance_eval do"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c4d2b7de1d47f0f021919a8651921d19b1f394a9",
            "date": "2025-01-14T18:39:19Z",
            "author_login": "romanrizzi"
          },
          {
            "sha": "6721c6751d946e43d53a3d61acf1c5d3070503c8",
            "date": "2025-01-14T17:42:40Z",
            "author_login": "romanrizzi"
          },
          {
            "sha": "bbae790c2b3eb783e515b575cc8789e8483230d8",
            "date": "2025-01-14T17:35:31Z",
            "author_login": "keegangeorge"
          },
          {
            "sha": "356ea7720142e6bcd73935d0dac6fb394d749c7f",
            "date": "2025-01-14T16:30:52Z",
            "author_login": "romanrizzi"
          },
          {
            "sha": "09ca1237576056aad60226aa7d81b551c6b778cb",
            "date": "2025-01-14T15:54:18Z",
            "author_login": "romanrizzi"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:N/A:N",
    "cwe_id": "CWE-918",
    "description": "discourse-ai is the AI plugin for the open-source discussion platform Discourse. Prior to commit 94ba0dadc2cf38e8f81c3936974c167219878edd, interactions with different AI services are vulnerable to admin-initiated SSRF attacks. Versions of the plugin that include commit 94ba0dadc2cf38e8f81c3936974c167219878edd contain a patch. As a workaround, one may disable the discourse-ai plugin.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-21T21:15:09.060",
    "last_modified": "2024-11-21T08:58:05.963",
    "fix_date": "2024-02-21T20:14:50Z"
  },
  "references": [
    {
      "url": "https://github.com/discourse/discourse-ai/commit/94ba0dadc2cf38e8f81c3936974c167219878edd",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/discourse/discourse-ai/security/advisories/GHSA-32cj-rm2q-22cc",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/discourse/discourse-ai/commit/94ba0dadc2cf38e8f81c3936974c167219878edd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/discourse/discourse-ai/security/advisories/GHSA-32cj-rm2q-22cc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.145990",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "discourse-ai",
    "owner": "discourse",
    "created_at": "2023-02-17T14:33:44Z",
    "updated_at": "2025-01-14T18:39:23Z",
    "pushed_at": "2025-01-14T20:06:42Z",
    "size": 14366,
    "stars": 75,
    "forks": 23,
    "open_issues": 6,
    "watchers": 75,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "security/backport-ssrf-protection"
    ],
    "languages": {
      "Ruby": 1528230,
      "JavaScript": 326671,
      "SCSS": 39808,
      "CSS": 12058,
      "HTML": 10755,
      "Handlebars": 7269
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:13:11.649956"
  }
}