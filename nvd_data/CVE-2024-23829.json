{
  "cve_id": "CVE-2024-23829",
  "github_data": {
    "repository": "aio-libs/aiohttp",
    "fix_commit": "33ccdfb0a12690af5bb49bda2319ec0907fa7827",
    "related_commits": [
      "33ccdfb0a12690af5bb49bda2319ec0907fa7827",
      "33ccdfb0a12690af5bb49bda2319ec0907fa7827"
    ],
    "patch_url": "https://github.com/aio-libs/aiohttp/commit/33ccdfb0a12690af5bb49bda2319ec0907fa7827.patch",
    "fix_commit_details": {
      "sha": "33ccdfb0a12690af5bb49bda2319ec0907fa7827",
      "commit_date": "2024-01-28T16:27:47Z",
      "author": {
        "login": "Dreamsorcerer",
        "type": "User",
        "stats": {
          "total_commits": 756,
          "average_weekly_commits": 1.2813559322033898,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 119
        }
      },
      "commit_message": {
        "title": "Improve validation in HTTP parser (#8074)",
        "length": 183,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 181,
        "additions": 164,
        "deletions": 17
      },
      "files": [
        {
          "filename": "CHANGES/8074.bugfix.rst",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+Fixed an unhandled exception in the Python HTTP parser on header lines starting with a colon -- by :user:`pajod`.\n+\n+Invalid request lines with anything but a dot between the HTTP major and minor version are now rejected. Invalid header field names containing question mark or slash are now rejected. Such requests are incompatible with :rfc:`9110#section-5.6.2` and are not known to be of any legitimate use.\n+\n+(BACKWARD INCOMPATIBLE)"
        },
        {
          "filename": "CONTRIBUTORS.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -263,6 +263,7 @@ Pankaj Pandey\n Parag Jain\n Pau Freixes\n Paul Colomiets\n+Paul J. Dorn\n Paulius \u0160ileikis\n Paulus Schoutsen\n Pavel Kamaev"
        },
        {
          "filename": "aiohttp/http_parser.py",
          "status": "modified",
          "additions": 18,
          "deletions": 14,
          "patch": "@@ -69,12 +69,11 @@\n #     tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n #             \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n #     token = 1*tchar\n-METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")\n-VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")\n-HDRRE: Final[Pattern[bytes]] = re.compile(\n-    rb\"[\\x00-\\x1F\\x7F-\\xFF()<>@,;:\\[\\]={} \\t\\\"\\\\]\"\n-)\n-HEXDIGIT = re.compile(rb\"[0-9a-fA-F]+\")\n+_TCHAR_SPECIALS: Final[str] = re.escape(\"!#$%&'*+-.^_`|~\")\n+TOKENRE: Final[Pattern[str]] = re.compile(f\"[0-9A-Za-z{_TCHAR_SPECIALS}]+\")\n+VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d)\\.(\\d)\", re.ASCII)\n+DIGITS: Final[Pattern[str]] = re.compile(r\"\\d+\", re.ASCII)\n+HEXDIGITS: Final[Pattern[bytes]] = re.compile(rb\"[0-9a-fA-F]+\")\n \n \n class RawRequestMessage(NamedTuple):\n@@ -133,6 +132,7 @@ def parse_headers(\n         self, lines: List[bytes]\n     ) -> Tuple[\"CIMultiDictProxy[str]\", RawHeaders]:\n         headers: CIMultiDict[str] = CIMultiDict()\n+        # note: \"raw\" does not mean inclusion of OWS before/after the field value\n         raw_headers = []\n \n         lines_idx = 1\n@@ -146,13 +146,14 @@ def parse_headers(\n             except ValueError:\n                 raise InvalidHeader(line) from None\n \n+            if len(bname) == 0:\n+                raise InvalidHeader(bname)\n+\n             # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2\n             if {bname[0], bname[-1]} & {32, 9}:  # {\" \", \"\\t\"}\n                 raise InvalidHeader(line)\n \n             bvalue = bvalue.lstrip(b\" \\t\")\n-            if HDRRE.search(bname):\n-                raise InvalidHeader(bname)\n             if len(bname) > self.max_field_size:\n                 raise LineTooLong(\n                     \"request header name {}\".format(\n@@ -161,6 +162,9 @@ def parse_headers(\n                     str(self.max_field_size),\n                     str(len(bname)),\n                 )\n+            name = bname.decode(\"utf-8\", \"surrogateescape\")\n+            if not TOKENRE.fullmatch(name):\n+                raise InvalidHeader(bname)\n \n             header_length = len(bvalue)\n \n@@ -207,7 +211,6 @@ def parse_headers(\n                     )\n \n             bvalue = bvalue.strip(b\" \\t\")\n-            name = bname.decode(\"utf-8\", \"surrogateescape\")\n             value = bvalue.decode(\"utf-8\", \"surrogateescape\")\n \n             # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5\n@@ -331,7 +334,8 @@ def get_content_length() -> Optional[int]:\n \n                             # Shouldn't allow +/- or other number formats.\n                             # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2\n-                            if not length_hdr.strip(\" \\t\").isdecimal():\n+                            # msg.headers is already stripped of leading/trailing wsp\n+                            if not DIGITS.fullmatch(length_hdr):\n                                 raise InvalidHeader(CONTENT_LENGTH)\n \n                             return int(length_hdr)\n@@ -559,7 +563,7 @@ def parse_message(self, lines: List[bytes]) -> RawRequestMessage:\n             )\n \n         # method\n-        if not METHRE.fullmatch(method):\n+        if not TOKENRE.fullmatch(method):\n             raise BadStatusLine(method)\n \n         # version\n@@ -676,8 +680,8 @@ def parse_message(self, lines: List[bytes]) -> RawResponseMessage:\n             raise BadStatusLine(line)\n         version_o = HttpVersion(int(match.group(1)), int(match.group(2)))\n \n-        # The status code is a three-digit number\n-        if len(status) != 3 or not status.isdecimal():\n+        # The status code is a three-digit ASCII number, no padding\n+        if len(status) != 3 or not DIGITS.fullmatch(status):\n             raise BadStatusLine(line)\n         status_i = int(status)\n \n@@ -818,7 +822,7 @@ def feed_data(\n                         if self._lax:  # Allow whitespace in lax mode.\n                             size_b = size_b.strip()\n \n-                        if not re.fullmatch(HEXDIGIT, size_b):\n+                        if not re.fullmatch(HEXDIGITS, size_b):\n                             exc = TransferEncodingError(\n                                 chunk[:pos].decode(\"ascii\", \"surrogateescape\")\n                             )"
        },
        {
          "filename": "tests/test_http_parser.py",
          "status": "modified",
          "additions": 140,
          "deletions": 3,
          "patch": "@@ -3,7 +3,8 @@\n \n import asyncio\n import re\n-from typing import Any, List\n+from contextlib import nullcontext\n+from typing import Any, Dict, List\n from unittest import mock\n from urllib.parse import quote\n \n@@ -168,11 +169,27 @@ def test_cve_2023_37276(parser: Any) -> None:\n         parser.feed_data(text)\n \n \n+@pytest.mark.parametrize(\n+    \"rfc9110_5_6_2_token_delim\",\n+    r'\"(),/:;<=>?@[\\]{}',\n+)\n+def test_bad_header_name(parser: Any, rfc9110_5_6_2_token_delim: str) -> None:\n+    text = f\"POST / HTTP/1.1\\r\\nhead{rfc9110_5_6_2_token_delim}er: val\\r\\n\\r\\n\".encode()\n+    expectation = pytest.raises(http_exceptions.BadHttpMessage)\n+    if rfc9110_5_6_2_token_delim == \":\":\n+        # Inserting colon into header just splits name/value earlier.\n+        expectation = nullcontext()\n+    with expectation:\n+        parser.feed_data(text)\n+\n+\n @pytest.mark.parametrize(\n     \"hdr\",\n     (\n         \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length\n         \"Content-Length: +256\",\n+        \"Content-Length: \\N{superscript one}\",\n+        \"Content-Length: \\N{mathematical double-struck digit one}\",\n         \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5\n         \"Bar: abc\\ndef\",\n         \"Baz: abc\\x00def\",\n@@ -265,6 +282,20 @@ def test_parse_headers_longline(parser: Any) -> None:\n         parser.feed_data(text)\n \n \n+def test_parse_unusual_request_line(parser: Any) -> None:\n+    if not isinstance(response, HttpResponseParserPy):\n+        pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")\n+    text = b\"#smol //a HTTP/1.3\\r\\n\\r\\n\"\n+    messages, upgrade, tail = parser.feed_data(text)\n+    assert len(messages) == 1\n+    msg, _ = messages[0]\n+    assert msg.compression is None\n+    assert not msg.upgrade\n+    assert msg.method == \"#smol\"\n+    assert msg.path == \"//a\"\n+    assert msg.version == (1, 3)\n+\n+\n def test_parse(parser: Any) -> None:\n     text = b\"GET /test HTTP/1.1\\r\\n\\r\\n\"\n     messages, upgrade, tail = parser.feed_data(text)\n@@ -567,6 +598,45 @@ def test_headers_content_length_err_2(parser: Any) -> None:\n         parser.feed_data(text)\n \n \n+_pad: Dict[bytes, str] = {\n+    b\"\": \"empty\",\n+    # not a typo. Python likes triple zero\n+    b\"\\000\": \"NUL\",\n+    b\" \": \"SP\",\n+    b\"  \": \"SPSP\",\n+    # not a typo: both 0xa0 and 0x0a in case of 8-bit fun\n+    b\"\\n\": \"LF\",\n+    b\"\\xa0\": \"NBSP\",\n+    b\"\\t \": \"TABSP\",\n+}\n+\n+\n+@pytest.mark.parametrize(\"hdr\", [b\"\", b\"foo\"], ids=[\"name-empty\", \"with-name\"])\n+@pytest.mark.parametrize(\"pad2\", _pad.keys(), ids=[\"post-\" + n for n in _pad.values()])\n+@pytest.mark.parametrize(\"pad1\", _pad.keys(), ids=[\"pre-\" + n for n in _pad.values()])\n+def test_invalid_header_spacing(\n+    parser: Any, pad1: bytes, pad2: bytes, hdr: bytes\n+) -> None:\n+    text = b\"GET /test HTTP/1.1\\r\\n\" b\"%s%s%s: value\\r\\n\\r\\n\" % (pad1, hdr, pad2)\n+    expectation = pytest.raises(http_exceptions.BadHttpMessage)\n+    if pad1 == pad2 == b\"\" and hdr != b\"\":\n+        # one entry in param matrix is correct: non-empty name, not padded\n+        expectation = nullcontext()\n+    if pad1 == pad2 == hdr == b\"\":\n+        if not isinstance(response, HttpResponseParserPy):\n+            pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")\n+    with expectation:\n+        parser.feed_data(text)\n+\n+\n+def test_empty_header_name(parser: Any) -> None:\n+    if not isinstance(response, HttpResponseParserPy):\n+        pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")\n+    text = b\"GET /test HTTP/1.1\\r\\n\" b\":test\\r\\n\\r\\n\"\n+    with pytest.raises(http_exceptions.BadHttpMessage):\n+        parser.feed_data(text)\n+\n+\n def test_invalid_header(parser: Any) -> None:\n     text = b\"GET /test HTTP/1.1\\r\\n\" b\"test line\\r\\n\\r\\n\"\n     with pytest.raises(http_exceptions.BadHttpMessage):\n@@ -689,6 +759,34 @@ def test_http_request_bad_status_line(parser: Any) -> None:\n     assert r\"\\n\" not in exc_info.value.message\n \n \n+_num: Dict[bytes, str] = {\n+    # dangerous: accepted by Python int()\n+    # unicodedata.category(\"\\U0001D7D9\") == 'Nd'\n+    \"\\N{mathematical double-struck digit one}\".encode(): \"utf8digit\",\n+    # only added for interop tests, refused by Python int()\n+    # unicodedata.category(\"\\U000000B9\") == 'No'\n+    \"\\N{superscript one}\".encode(): \"utf8number\",\n+    \"\\N{superscript one}\".encode(\"latin-1\"): \"latin1number\",\n+}\n+\n+\n+@pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())\n+def test_http_request_bad_status_line_number(\n+    parser: Any, nonascii_digit: bytes\n+) -> None:\n+    text = b\"GET /digit HTTP/1.\" + nonascii_digit + b\"\\r\\n\\r\\n\"\n+    with pytest.raises(http_exceptions.BadStatusLine):\n+        parser.feed_data(text)\n+\n+\n+def test_http_request_bad_status_line_separator(parser: Any) -> None:\n+    # single code point, old, multibyte NFKC, multibyte NFKD\n+    utf8sep = \"\\N{arabic ligature sallallahou alayhe wasallam}\".encode()\n+    text = b\"GET /ligature HTTP/1\" + utf8sep + b\"1\\r\\n\\r\\n\"\n+    with pytest.raises(http_exceptions.BadStatusLine):\n+        parser.feed_data(text)\n+\n+\n def test_http_request_bad_status_line_whitespace(parser: Any) -> None:\n     text = b\"GET\\n/path\\fHTTP/1.1\\r\\n\\r\\n\"\n     with pytest.raises(http_exceptions.BadStatusLine):\n@@ -710,6 +808,31 @@ def test_http_request_upgrade(parser: Any) -> None:\n     assert tail == b\"some raw data\"\n \n \n+def test_http_request_parser_utf8_request_line(parser: Any) -> None:\n+    if not isinstance(response, HttpResponseParserPy):\n+        pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")\n+    messages, upgrade, tail = parser.feed_data(\n+        # note the truncated unicode sequence\n+        b\"GET /P\\xc3\\xbcnktchen\\xa0\\xef\\xb7 HTTP/1.1\\r\\n\" +\n+        # for easier grep: ASCII 0xA0 more commonly known as non-breaking space\n+        # note the leading and trailing spaces\n+        \"sTeP:  \\N{latin small letter sharp s}nek\\t\\N{no-break space}  \"\n+        \"\\r\\n\\r\\n\".encode()\n+    )\n+    msg = messages[0][0]\n+\n+    assert msg.method == \"GET\"\n+    assert msg.path == \"/P\u00fcnktchen\\udca0\\udcef\\udcb7\"\n+    assert msg.version == (1, 1)\n+    assert msg.headers == CIMultiDict([(\"STEP\", \"\u00dfnek\\t\\xa0\")])\n+    assert msg.raw_headers == ((b\"sTeP\", \"\u00dfnek\\t\\xa0\".encode()),)\n+    assert not msg.should_close\n+    assert msg.compression is None\n+    assert not msg.upgrade\n+    assert not msg.chunked\n+    assert msg.url.path == URL(\"/P%C3%BCnktchen\\udca0\\udcef\\udcb7\").path\n+\n+\n def test_http_request_parser_utf8(parser: Any) -> None:\n     text = \"GET /path HTTP/1.1\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()\n     messages, upgrade, tail = parser.feed_data(text)\n@@ -759,9 +882,15 @@ def test_http_request_parser_two_slashes(parser: Any) -> None:\n     assert not msg.chunked\n \n \n-def test_http_request_parser_bad_method(parser: Any) -> None:\n+@pytest.mark.parametrize(\n+    \"rfc9110_5_6_2_token_delim\",\n+    [bytes([i]) for i in rb'\"(),/:;<=>?@[\\]{}'],\n+)\n+def test_http_request_parser_bad_method(\n+    parser: Any, rfc9110_5_6_2_token_delim: bytes\n+) -> None:\n     with pytest.raises(http_exceptions.BadStatusLine):\n-        parser.feed_data(b'G=\":<>(e),[T];?\" /get HTTP/1.1\\r\\n\\r\\n')\n+        parser.feed_data(rfc9110_5_6_2_token_delim + b'ET\" /get HTTP/1.1\\r\\n\\r\\n')\n \n \n def test_http_request_parser_bad_version(parser: Any) -> None:\n@@ -979,6 +1108,14 @@ def test_http_response_parser_code_not_int(response: Any) -> None:\n         response.feed_data(b\"HTTP/1.1 ttt test\\r\\n\\r\\n\")\n \n \n+@pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())\n+def test_http_response_parser_code_not_ascii(\n+    response: Any, nonascii_digit: bytes\n+) -> None:\n+    with pytest.raises(http_exceptions.BadStatusLine):\n+        response.feed_data(b\"HTTP/1.1 20\" + nonascii_digit + b\" test\\r\\n\\r\\n\")\n+\n+\n def test_http_request_chunked_payload(parser: Any) -> None:\n     text = b\"GET /test HTTP/1.1\\r\\n\" b\"transfer-encoding: chunked\\r\\n\\r\\n\"\n     msg, payload = parser.feed_data(text)[0][0]"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "9482755b40ce69814eea6f65bfbd4c12d1878174",
            "date": "2025-01-10T10:46:29Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "76f4309a6cbfc12d918c65b5bffdcf0d4bb691c6",
            "date": "2025-01-10T10:39:38Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c5c204f8b661bb1c9d183e17b37013ee222b2cbd",
            "date": "2025-01-10T10:37:48Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a91dc8f78e97f9be30e13c39e457e8e2a2651702",
            "date": "2025-01-08T10:27:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "237d46722a0e56363c4a07dcf31e73fe4c2ea392",
            "date": "2025-01-07T11:14:58Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L",
    "cwe_id": "CWE-444",
    "description": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. Security-sensitive parts of the Python HTTP parser retained minor differences in allowable character sets, that must trigger error handling to robustly match frame boundaries of proxies in order to protect against injection of additional requests. Additionally, validation could trigger exceptions that were not handled consistently with processing of other malformed input.  Being more lenient than internet standards require could, depending on deployment environment, assist in request smuggling. The unhandled exception could cause excessive resource consumption on the application server and/or its logging facilities. This vulnerability exists due to an incomplete fix for CVE-2023-47627. Version 3.9.2 fixes this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-29T23:15:08.767",
    "last_modified": "2024-11-21T08:58:30.683",
    "fix_date": "2024-01-28T16:27:47Z"
  },
  "references": [
    {
      "url": "https://github.com/aio-libs/aiohttp/commit/33ccdfb0a12690af5bb49bda2319ec0907fa7827",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/pull/8074",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/security/advisories/GHSA-8qpw-xqxj-h4r2",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ICUOCFGTB25WUT336BZ4UNYLSZOUVKBD/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XXWVZIVAYWEBHNRIILZVB3R3SDQNNAA7/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/commit/33ccdfb0a12690af5bb49bda2319ec0907fa7827",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/pull/8074",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/aio-libs/aiohttp/security/advisories/GHSA-8qpw-xqxj-h4r2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ICUOCFGTB25WUT336BZ4UNYLSZOUVKBD/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XXWVZIVAYWEBHNRIILZVB3R3SDQNNAA7/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.543998",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "aiohttp",
    "owner": "aio-libs",
    "created_at": "2013-10-01T23:04:01Z",
    "updated_at": "2025-01-14T07:45:00Z",
    "pushed_at": "2025-01-13T11:21:32Z",
    "size": 31707,
    "stars": 15317,
    "forks": 2050,
    "open_issues": 250,
    "watchers": 15317,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "3.8",
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "master"
    ],
    "languages": {
      "Python": 2241563,
      "Cython": 41302,
      "Makefile": 5839,
      "Gherkin": 1248,
      "Dockerfile": 298,
      "C": 170,
      "Shell": 148
    },
    "commit_activity": {
      "total_commits_last_year": 2401,
      "avg_commits_per_week": 46.17307692307692,
      "days_active_last_year": 226
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:12:57.567310"
  }
}