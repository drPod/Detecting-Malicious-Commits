{
  "cve_id": "CVE-2024-23839",
  "github_data": {
    "repository": "OISF/suricata",
    "fix_commit": "cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
    "related_commits": [
      "cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
      "cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f"
    ],
    "patch_url": "https://github.com/OISF/suricata/commit/cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f.patch",
    "fix_commit_details": {
      "sha": "cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
      "commit_date": "2023-11-07T09:33:21Z",
      "author": {
        "login": "catenacyber",
        "type": "User",
        "stats": {
          "total_commits": 1048,
          "average_weekly_commits": 1.2186046511627906,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 238
        }
      },
      "commit_message": {
        "title": "detect: fixes use-after-free with http.request_header",
        "length": 556,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 114,
        "additions": 88,
        "deletions": 26
      },
      "files": [
        {
          "filename": "src/detect-http-header.c",
          "status": "modified",
          "additions": 88,
          "deletions": 26,
          "patch": "@@ -48,6 +48,7 @@\n #include \"util-print.h\"\n #include \"util-memcmp.h\"\n #include \"util-profiling.h\"\n+#include \"util-validate.h\"\n \n #include \"app-layer.h\"\n #include \"app-layer-parser.h\"\n@@ -467,6 +468,8 @@ void DetectHttpHeaderRegister(void)\n \n static int g_http_request_header_buffer_id = 0;\n static int g_http_response_header_buffer_id = 0;\n+static int g_request_header_thread_id = 0;\n+static int g_response_header_thread_id = 0;\n \n static InspectionBuffer *GetHttp2HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n         const DetectEngineTransforms *transforms, Flow *_f, const struct MpmListIdDataArgs *cbdata,\n@@ -580,6 +583,36 @@ static int PrefilterMpmHttp2HeaderRegister(DetectEngineCtx *de_ctx, SigGroupHead\n             mpm_reg->app_v2.tx_min_progress, pectx, PrefilterMpmHttpHeaderFree, mpm_reg->name);\n }\n \n+typedef struct HttpMultiBufItem {\n+    uint8_t *buffer;\n+    size_t len;\n+} HttpMultiBufItem;\n+\n+typedef struct HttpMultiBufHeaderThreadData {\n+    // array of items, being defined as a buffer with its length just above\n+    HttpMultiBufItem *items;\n+    // capacity of items (size of allocation)\n+    size_t cap;\n+    // length of items (number in use)\n+    size_t len;\n+} HttpMultiBufHeaderThreadData;\n+\n+static void *HttpMultiBufHeaderThreadDataInit(void *data)\n+{\n+    HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));\n+    return td;\n+}\n+\n+static void HttpMultiBufHeaderThreadDataFree(void *data)\n+{\n+    HttpMultiBufHeaderThreadData *td = data;\n+    for (size_t i = 0; i < td->cap; i++) {\n+        SCFree(td->items[i].buffer);\n+    }\n+    SCFree(td->items);\n+    SCFree(td);\n+}\n+\n static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n         const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,\n         int list_id)\n@@ -593,10 +626,15 @@ static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, cons\n     if (buffer->initialized)\n         return buffer;\n \n-    HttpHeaderThreadData *hdr_td = NULL;\n-    HttpHeaderBuffer *buf =\n-            HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);\n-    if (unlikely(buf == NULL)) {\n+    int kw_thread_id;\n+    if (flags & STREAM_TOSERVER) {\n+        kw_thread_id = g_request_header_thread_id;\n+    } else {\n+        kw_thread_id = g_response_header_thread_id;\n+    }\n+    HttpMultiBufHeaderThreadData *hdr_td =\n+            DetectThreadCtxGetGlobalKeywordThreadCtx(det_ctx, kw_thread_id);\n+    if (unlikely(hdr_td == NULL)) {\n         return NULL;\n     }\n \n@@ -607,33 +645,53 @@ static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, cons\n     } else {\n         headers = tx->response_headers;\n     }\n-    if (cbdata->local_id < htp_table_size(headers)) {\n-        htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);\n-        size_t size1 = bstr_size(h->name);\n-        size_t size2 = bstr_size(h->value);\n-        size_t b_len = size1 + 2 + size2;\n-        if (b_len > buf->size) {\n-            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {\n+    size_t no_of_headers = htp_table_size(headers);\n+    if (cbdata->local_id == 0) {\n+        // We initialize a big buffer on first item\n+        // Then, we will just use parts of it\n+        hdr_td->len = 0;\n+        if (hdr_td->cap < no_of_headers) {\n+            void *new_buffer = SCRealloc(hdr_td->items, no_of_headers * sizeof(HttpMultiBufItem));\n+            if (unlikely(new_buffer == NULL)) {\n                 return NULL;\n             }\n+            hdr_td->items = new_buffer;\n+            // zeroes the new part of the items\n+            memset(hdr_td->items + hdr_td->cap, 0,\n+                    (no_of_headers - hdr_td->cap) * sizeof(HttpMultiBufItem));\n+            hdr_td->cap = no_of_headers;\n         }\n-        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));\n-        buf->buffer[size1] = ':';\n-        buf->buffer[size1 + 1] = ' ';\n-        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));\n-        buf->len = b_len;\n-    } else {\n-        InspectionBufferSetupMultiEmpty(buffer);\n-        return NULL;\n-    }\n-    if (buf->len == 0) {\n-        InspectionBufferSetupMultiEmpty(buffer);\n-        return NULL;\n+        for (size_t i = 0; i < no_of_headers; i++) {\n+            htp_header_t *h = htp_table_get_index(headers, i, NULL);\n+            size_t size1 = bstr_size(h->name);\n+            size_t size2 = bstr_size(h->value);\n+            size_t size = size1 + size2 + 2;\n+            if (hdr_td->items[i].len < size) {\n+                // Use realloc, as this pointer is not freed until HttpMultiBufHeaderThreadDataFree\n+                hdr_td->items[i].buffer = SCRealloc(hdr_td->items[i].buffer, size);\n+                if (unlikely(hdr_td->items[i].buffer == NULL)) {\n+                    return NULL;\n+                }\n+            }\n+            memcpy(hdr_td->items[i].buffer, bstr_ptr(h->name), size1);\n+            hdr_td->items[i].buffer[size1] = ':';\n+            hdr_td->items[i].buffer[size1 + 1] = ' ';\n+            memcpy(hdr_td->items[i].buffer + size1 + 2, bstr_ptr(h->value), size2);\n+            hdr_td->items[i].len = size;\n+        }\n+        hdr_td->len = no_of_headers;\n     }\n \n-    InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);\n-\n-    SCReturnPtr(buffer, \"InspectionBuffer\");\n+    // cbdata->local_id is the index of the requested header buffer\n+    // hdr_td->len is the number of header buffers\n+    if (cbdata->local_id < hdr_td->len) {\n+        // we have one valid header buffer\n+        InspectionBufferSetupMulti(buffer, transforms, hdr_td->items[cbdata->local_id].buffer,\n+                hdr_td->items[cbdata->local_id].len);\n+        SCReturnPtr(buffer, \"InspectionBuffer\");\n+    } // else there are no more header buffer to get\n+    InspectionBufferSetupMultiEmpty(buffer);\n+    return NULL;\n }\n \n static void PrefilterTxHttp1Header(DetectEngineThreadCtx *det_ctx, const void *pectx, Packet *p,\n@@ -751,6 +809,8 @@ void DetectHttpRequestHeaderRegister(void)\n     DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header name and value\");\n     g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"http_request_header\");\n     DetectBufferTypeSupportsMultiInstance(\"http_request_header\");\n+    g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\",\n+            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n }\n \n static int DetectHTTPResponseHeaderSetup(DetectEngineCtx *de_ctx, Signature *s, const char *arg)\n@@ -786,6 +846,8 @@ void DetectHttpResponseHeaderRegister(void)\n     DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header name and value\");\n     g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"http_response_header\");\n     DetectBufferTypeSupportsMultiInstance(\"http_response_header\");\n+    g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\",\n+            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n }\n \n /************************************Unittests*********************************/"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "637708acb476cdae526b870e4301e22197da1869",
            "date": "2025-01-13T12:39:21Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "a92212d6e504b535c63ce8d234bf4804c7b8dcca",
            "date": "2025-01-10T16:27:55Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "eab212b0be760daa2689bcb6e2d05c12fd708682",
            "date": "2025-01-10T15:57:51Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "ae1a4ef757583e4307d3322130f893db4b716a59",
            "date": "2024-11-11T06:26:11Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "e6be049c5dc2859a833fc21321bc7bfd15be2904",
            "date": "2024-11-11T06:21:03Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H",
    "cwe_id": "CWE-416",
    "description": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine.  Prior to 7.0.3, specially crafted traffic can cause a heap use after free if the ruleset uses the http.request_header or http.response_header keyword.  The vulnerability has been patched in 7.0.3.  To work around the vulnerability, avoid the http.request_header and http.response_header keywords.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-26T16:27:58.090",
    "last_modified": "2024-12-19T19:38:28.107",
    "fix_date": "2023-11-07T09:33:21Z"
  },
  "references": [
    {
      "url": "https://github.com/OISF/suricata/commit/cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-qxj6-hr2p-mmc7",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GOCOBFUTIFHOP2PZOH4ENRFXRBHIRKK4/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZXJIT7R53ZXROO3I256RFUWTIW4ECK6P/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6657",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-qxj6-hr2p-mmc7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GOCOBFUTIFHOP2PZOH4ENRFXRBHIRKK4/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZXJIT7R53ZXROO3I256RFUWTIW4ECK6P/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6657",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.160322",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "OISF",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-14T12:53:46Z",
    "pushed_at": "2025-01-14T06:40:06Z",
    "size": 74648,
    "stars": 4847,
    "forks": 1483,
    "open_issues": 74,
    "watchers": 4847,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 13993560,
      "Rust": 3470702,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45461,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1056,
      "avg_commits_per_week": 20.307692307692307,
      "days_active_last_year": 254
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:41:46.043023"
  }
}