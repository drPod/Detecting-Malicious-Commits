{
  "cve_id": "CVE-2024-24479",
  "github_data": {
    "repository": "wireshark/wireshark",
    "fix_commit": "c3720cff158c265dec2a0c6104b1d65954ae6bfd",
    "related_commits": [
      "c3720cff158c265dec2a0c6104b1d65954ae6bfd",
      "c3720cff158c265dec2a0c6104b1d65954ae6bfd"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "c3720cff158c265dec2a0c6104b1d65954ae6bfd",
      "commit_date": "2023-09-12T08:23:35Z",
      "author": {
        "login": "guyharris",
        "type": "User",
        "stats": {
          "total_commits": 17610,
          "average_weekly_commits": 12.788671023965142,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 1232
        }
      },
      "commit_message": {
        "title": "Various enhancements and fixes to format_fractional_part_nsecs().",
        "length": 833,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 128,
        "additions": 77,
        "deletions": 51
      },
      "files": [
        {
          "filename": "wsutil/to_str.c",
          "status": "modified",
          "additions": 76,
          "deletions": 50,
          "patch": "@@ -653,12 +653,17 @@ eui64_to_str(wmem_allocator_t *scope, const guint64 ad) {\n #define CHARS_NANOSECONDS\t9\t/* 000000001 */\n \n /*\n- * Format the fractonal part of a time, with the specified precision)\n+ * Format the fractional part of a time, with the specified precision.\n+ * Returns the number of bytes formatted.\n  */\n-void\n+int\n format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n {\n+\tgchar *ptr;\n+\tsize_t remaining;\n+\tint num_bytes;\n \tgsize decimal_point_len;\n+\tguint32 frac_part;\n \tgint8 num_buf[CHARS_NANOSECONDS];\n \tgint8 *num_end = &num_buf[CHARS_NANOSECONDS];\n \tgint8 *num_ptr;\n@@ -671,22 +676,50 @@ format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const cha\n \t\t * No room in the buffer for anything, including\n \t\t * a terminating '\\0'.\n \t\t */\n-\t\treturn;\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * If the fractional part is >= 1, don't show it as a\n+\t * fractional part.\n+\t */\n+\tif (nsecs >= 1000000000U) {\n+\t\tnum_bytes = snprintf(buf, buflen, \"%s(%u nanoseconds)\",\n+\t\t    decimal_point, nsecs);\n+\t\tif ((unsigned int)num_bytes >= buflen) {\n+\t\t\t/*\n+\t\t\t * That filled up or would have overflowed\n+\t\t\t * the buffer.  Nothing more to do; return\n+\t\t\t * the remaining space in the buffer, minus\n+\t\t\t * one byte for the terminating '\\0',* as\n+\t\t\t * that's the number of bytes we copied.\n+\t\t\t */\n+\t\t\treturn (int)(buflen - 1);\n+\t\t}\n+\t\treturn num_bytes;\n \t}\n \n+\tptr = buf;\n+\tremaining = buflen;\n+\tnum_bytes = 0;\n+\n \t/*\n \t * Copy the decimal point.\n \t */\n \tdecimal_point_len = g_strlcpy(buf, decimal_point, buflen);\n \tif (decimal_point_len >= buflen) {\n \t\t/*\n \t\t * The decimal point didn't fit in the buffer\n-\t\t * and was truncated.  Nothing more to do.\n+\t\t * and was truncated.  Nothing more to do;\n+\t\t * return the remaining space in the buffer,\n+\t\t * minus one byte for the terminating '\\0',\n+\t\t * as that's the number of bytes we copied.\n \t\t */\n-\t\treturn;\n+\t\treturn (int)(buflen - 1);\n \t}\n-\tbuf += decimal_point_len;\n-\tbuflen -= decimal_point_len;\n+\tptr += decimal_point_len;\n+\tremaining -= decimal_point_len;\n+\tnum_bytes += decimal_point_len;\n \n \t/*\n \t * Fill in num_buf with the nanoseconds value, padded with\n@@ -709,104 +742,101 @@ format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const cha\n \t\t/*\n \t\t * Scale down to units of 1/10 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 100000000, precision);\n+\t\tfrac_part = nsecs / 100000000U;\n \t\tbreak;\n \n \tcase 2:\n \t\t/*\n \t\t * Scale down to units of 1/100 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 10000000, precision);\n+\t\tfrac_part = nsecs / 10000000U;\n \t\tbreak;\n \n \tcase 3:\n \t\t/*\n \t\t * Scale down to units of 1/1000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 1000000, precision);\n+\t\tfrac_part = nsecs / 1000000U;\n \t\tbreak;\n \n \tcase 4:\n \t\t/*\n \t\t * Scale down to units of 1/10000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 100000, precision);\n+\t\tfrac_part = nsecs / 100000U;\n \t\tbreak;\n \n \tcase 5:\n \t\t/*\n \t\t * Scale down to units of 1/100000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 10000, precision);\n+\t\tfrac_part = nsecs / 10000U;\n \t\tbreak;\n \n \tcase 6:\n \t\t/*\n \t\t * Scale down to units of 1/1000000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 1000, precision);\n+\t\tfrac_part = nsecs / 1000U;\n \t\tbreak;\n \n \tcase 7:\n \t\t/*\n \t\t * Scale down to units of 1/10000000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 100, precision);\n+\t\tfrac_part = nsecs / 100U;\n \t\tbreak;\n \n \tcase 8:\n \t\t/*\n \t\t * Scale down to units of 1/100000000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 10, precision);\n+\t\tfrac_part = nsecs / 10U;\n \t\tbreak;\n \n \tcase 9:\n \t\t/*\n \t\t * We're already in units of 1/1000000000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end, nsecs,\n-\t\t    precision);\n+\t\tfrac_part = nsecs;\n \t\tbreak;\n \n \tdefault:\n \t\tws_assert_not_reached();\n \t\tbreak;\n \t}\n \n+\tnum_ptr = uint_to_str_back_len(num_end, frac_part, precision);\n+\n \t/*\n \t * The length of the string that we want to copy to the buffer\n \t * is the minimum of:\n \t *\n \t *    the length of the digit string;\n-\t *    the size of the buffer, minus 1 for the terminating\n-\t *      '\\0'.\n+\t *    the remaining space in the buffer, minus 1 for the\n+\t *      terminating '\\0'.\n \t */\n-\tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);\n+\tnum_len = MIN((size_t)(num_end - num_ptr), remaining - 1);\n \tif (num_len == 0) {\n \t\t/*\n \t\t * Not enough room to copy anything.\n+\t\t * Return the number of bytes we've generated.\n \t\t */\n-\t\treturn;\n+\t\treturn num_bytes;\n \t}\n \n \t/*\n \t * Copy over the fractional part.\n \t */\n-\tmemcpy(buf, num_ptr, num_len);\n+\tmemcpy(ptr, num_ptr, num_len);\n+\tptr += num_len;\n+\tnum_bytes += num_len;\n \n \t/*\n \t * '\\0'-terminate it.\n \t */\n-\t*(buf + num_len) = '\\0';\n+\t*ptr = '\\0';\n+\treturn num_bytes;\n }\n \n void\n@@ -892,8 +922,8 @@ format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n {\n \tstruct tm tm, *tmp;\n \tgchar *ptr;\n-\tsize_t buf_remaining;\n-\tint num_chars;\n+\tsize_t remaining;\n+\tint num_bytes;\n \n \tif (local)\n \t\ttmp = ws_localtime_r(&ns->secs, &tm);\n@@ -904,45 +934,41 @@ format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n \t\treturn;\n \t}\n \tptr = buf;\n-\tbuf_remaining = buflen;\n-\tnum_chars = snprintf(ptr, buf_remaining,\n+\tremaining = buflen;\n+\tnum_bytes = snprintf(ptr, remaining,\n \t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n \t    tmp->tm_year + 1900,\n \t    tmp->tm_mon + 1,\n \t    tmp->tm_mday,\n \t    tmp->tm_hour,\n \t    tmp->tm_min,\n \t    tmp->tm_sec);\n-\tif (num_chars < 0) {\n+\tif (num_bytes < 0) {\n \t\t/*\n+\t\t * That got an error.\n \t\t * Not much else we can do.\n \t\t */\n \t\tsnprintf(buf, buflen, \"snprintf() failed\");\n \t\treturn;\n \t}\n-\tif ((unsigned int)num_chars >= buf_remaining) {\n+\tif ((unsigned int)num_bytes >= remaining) {\n \t\t/*\n-\t\t * Either that got an error (num_chars < 0) or it\n-\t\t * filled up or would have overflowed the buffer\n-\t\t * (num_chars >= buf_remaining).\n+\t\t * That filled up or would have overflowed the buffer.\n \t\t * Nothing more we can do.\n \t\t */\n \t\treturn;\n \t}\n-\tptr += num_chars;\n-\tbuf_remaining -= num_chars;\n+\tptr += num_bytes;\n+\tremaining -= num_bytes;\n \n-\tif (precision == 0) {\n+\tif (precision != 0) {\n \t\t/*\n-\t\t * Seconds precision, so no nanosecond.\n+\t\t * Append the fractional part.\n+\t\t * Get the nsecs as a 32-bit unsigned value, as it should\n+\t\t * never be negative, so we treat it as unsigned.\n \t\t */\n-\t\treturn;\n+\t\tformat_fractional_part_nsecs(ptr, remaining, (guint32)ns->nsecs, decimal_point, precision);\n \t}\n-\n-\t/*\n-\t * Append the fractional part.\n-\t */\n-\tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n }\n \n /*"
        },
        {
          "filename": "wsutil/to_str.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -299,7 +299,7 @@ WS_DLL_PUBLIC gchar *ipxnet_to_str_punct(wmem_allocator_t *scope, const guint32\n \n WS_DLL_PUBLIC gchar *eui64_to_str(wmem_allocator_t *scope, const guint64 ad);\n \n-WS_DLL_PUBLIC void format_fractional_part_nsecs(gchar *, size_t, guint32, const char *, int);\n+WS_DLL_PUBLIC int format_fractional_part_nsecs(gchar *, size_t, guint32, const char *, int);\n \n WS_DLL_PUBLIC void display_epoch_time(gchar *, size_t, const nstime_t *, int);\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "91cfd6d16d6f57c765d6708808673a2ac16eaa9d",
            "date": "2025-01-24T23:38:23Z",
            "author_login": "johnthacker"
          },
          {
            "sha": "798e31fc1e92a8572f8eb2a7b53fdf7931674514",
            "date": "2025-01-24T05:05:23Z",
            "author_login": "johnthacker"
          },
          {
            "sha": "93a913066382cab380bfe42bd15df971dedd0c1e",
            "date": "2025-01-24T15:47:39Z",
            "author_login": "johnthacker"
          },
          {
            "sha": "d14e835726e2b75adc73262720fdde9b7019f528",
            "date": "2025-01-25T01:09:04Z",
            "author_login": "geraldcombs"
          },
          {
            "sha": "3cd7081f0f31377440d8689774a5e577df79b1ef",
            "date": "2025-01-25T01:57:23Z",
            "author_login": "johnthacker"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-120",
    "description": "A Buffer Overflow in Wireshark before 4.2.0 allows a remote attacker to cause a denial of service via the wsutil/to_str.c, and format_fractional_part_nsecs components. NOTE: this is disputed by the vendor because neither release 4.2.0 nor any other release was affected.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-21T19:15:09.077",
    "last_modified": "2024-11-21T08:59:19.487",
    "fix_date": "2023-09-12T08:23:35Z"
  },
  "references": [
    {
      "url": "https://gist.github.com/1047524396/c50ad17e9a1a18990043a7cd27814c78",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/wireshark/wireshark/commit/c3720cff158c265dec2a0c6104b1d65954ae6bfd",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZT2BX7UARZVVWKITSZMHW7BHXGIKRSR2/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://gist.github.com/1047524396/c50ad17e9a1a18990043a7cd27814c78",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/wireshark/wireshark/commit/c3720cff158c265dec2a0c6104b1d65954ae6bfd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZT2BX7UARZVVWKITSZMHW7BHXGIKRSR2/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.144866",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "wireshark",
    "owner": "wireshark",
    "created_at": "2014-06-29T18:37:22Z",
    "updated_at": "2025-01-14T06:31:56Z",
    "pushed_at": "2025-01-14T06:31:52Z",
    "size": 1123592,
    "stars": 7492,
    "forks": 1910,
    "open_issues": 2,
    "watchers": 7492,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 249769887,
      "C++": 6560190,
      "Python": 2875784,
      "Perl": 854385,
      "CMake": 707737,
      "Lua": 390687,
      "Shell": 297586,
      "Lex": 193245,
      "NSIS": 132499,
      "HTML": 34111,
      "PowerShell": 27327,
      "XSLT": 11560,
      "PostScript": 6954,
      "Makefile": 4457,
      "Objective-C": 3844,
      "Objective-C++": 1390
    },
    "commit_activity": {
      "total_commits_last_year": 3260,
      "avg_commits_per_week": 62.69230769230769,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T13:00:32.847054"
  }
}