{
  "cve_id": "CVE-2024-24568",
  "github_data": {
    "repository": "OISF/suricata",
    "fix_commit": "478a2a38f54e2ae235f8486bff87d7d66b6307f0",
    "related_commits": [
      "478a2a38f54e2ae235f8486bff87d7d66b6307f0",
      "478a2a38f54e2ae235f8486bff87d7d66b6307f0"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "478a2a38f54e2ae235f8486bff87d7d66b6307f0",
      "commit_date": "2024-01-25T15:01:14Z",
      "author": {
        "login": "catenacyber",
        "type": "User",
        "stats": {
          "total_commits": 1071,
          "average_weekly_commits": 1.24245939675174,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 239
        }
      },
      "commit_message": {
        "title": "http2: handle reassembly for continuation frames",
        "length": 960,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 89,
        "additions": 85,
        "deletions": 4
      },
      "files": [
        {
          "filename": "rules/http2-events.rules",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -20,3 +20,4 @@ alert http2 any any -> any any (msg:\"SURICATA HTTP2 variable-length integer over\n alert http2 any any -> any any (msg:\"SURICATA HTTP2 too many streams\"; flow:established; app-layer-event:http2.too_many_streams; classtype:protocol-command-decode; sid:2290012; rev:1;)\n alert http2 any any -> any any (msg:\"SURICATA HTTP2 authority host mismatch\"; flow:established,to_server; app-layer-event:http2.authority_host_mismatch; classtype:protocol-command-decode; sid:2290013; rev:1;)\n alert http2 any any -> any any (msg:\"SURICATA HTTP2 user info in uri\"; flow:established,to_server; app-layer-event:http2.userinfo_in_uri; classtype:protocol-command-decode; sid:2290014; rev:1;)\n+alert http2 any any -> any any (msg:\"SURICATA HTTP2 reassembly limit reached\"; flow:established; app-layer-event:http2.reassembly_limit_reached; classtype:protocol-command-decode; sid:2290015; rev:1;)"
        },
        {
          "filename": "rust/src/http2/http2.rs",
          "status": "modified",
          "additions": 82,
          "deletions": 4,
          "patch": "@@ -61,6 +61,8 @@ const HTTP2_FRAME_RSTSTREAM_LEN: usize = 4;\n const HTTP2_FRAME_PRIORITY_LEN: usize = 5;\n const HTTP2_FRAME_WINDOWUPDATE_LEN: usize = 4;\n pub static mut HTTP2_MAX_TABLESIZE: u32 = 65536; // 0x10000\n+// maximum size of reassembly for header + continuation\n+static mut HTTP2_MAX_REASS: usize = 102400;\n static mut HTTP2_MAX_STREAMS: usize = 4096; // 0x1000\n \n #[repr(u8)]\n@@ -406,6 +408,7 @@ pub enum HTTP2Event {\n     TooManyStreams,\n     AuthorityHostMismatch,\n     UserinfoInUri,\n+    ReassemblyLimitReached,\n }\n \n pub struct HTTP2DynTable {\n@@ -432,6 +435,12 @@ impl HTTP2DynTable {\n     }\n }\n \n+#[derive(Default)]\n+struct HTTP2HeaderReassemblyBuffer {\n+    data: Vec<u8>,\n+    stream_id: u32,\n+}\n+\n pub struct HTTP2State {\n     state_data: AppLayerStateData,\n     tx_id: u64,\n@@ -441,6 +450,9 @@ pub struct HTTP2State {\n     dynamic_headers_tc: HTTP2DynTable,\n     transactions: VecDeque<HTTP2Transaction>,\n     progress: HTTP2ConnectionState,\n+\n+    c2s_buf: HTTP2HeaderReassemblyBuffer,\n+    s2c_buf: HTTP2HeaderReassemblyBuffer,\n }\n \n impl State<HTTP2Transaction> for HTTP2State {\n@@ -473,6 +485,8 @@ impl HTTP2State {\n             dynamic_headers_tc: HTTP2DynTable::new(),\n             transactions: VecDeque::new(),\n             progress: HTTP2ConnectionState::Http2StateInit,\n+            c2s_buf: HTTP2HeaderReassemblyBuffer::default(),\n+            s2c_buf: HTTP2HeaderReassemblyBuffer::default(),\n         }\n     }\n \n@@ -686,8 +700,11 @@ impl HTTP2State {\n     }\n \n     fn parse_frame_data(\n-        &mut self, ftype: u8, input: &[u8], complete: bool, hflags: u8, dir: Direction,\n+        &mut self, head: &parser::HTTP2FrameHeader, input: &[u8], complete: bool, dir: Direction,\n+        reass_limit_reached: &mut bool,\n     ) -> HTTP2FrameTypeData {\n+        let ftype = head.ftype;\n+        let hflags = head.flags;\n         match num::FromPrimitive::from_u8(ftype) {\n             Some(parser::HTTP2FrameType::GoAway) => {\n                 if input.len() < HTTP2_FRAME_GOAWAY_LEN {\n@@ -847,17 +864,47 @@ impl HTTP2State {\n                 return HTTP2FrameTypeData::DATA;\n             }\n             Some(parser::HTTP2FrameType::Continuation) => {\n+                let buf = if dir == Direction::ToClient {\n+                    &mut self.s2c_buf\n+                } else {\n+                    &mut self.c2s_buf\n+                };\n+                if head.stream_id == buf.stream_id {\n+                    let max_reass = unsafe { HTTP2_MAX_REASS };\n+                    if buf.data.len() + input.len() < max_reass {\n+                        buf.data.extend(input);\n+                    } else if buf.data.len() < max_reass {\n+                        buf.data.extend(&input[..max_reass - buf.data.len()]);\n+                        *reass_limit_reached = true;\n+                    }\n+                    if head.flags & parser::HTTP2_FLAG_HEADER_END_HEADERS == 0 {\n+                        let hs = parser::HTTP2FrameContinuation {\n+                            blocks: Vec::new(),\n+                        };\n+                        return HTTP2FrameTypeData::CONTINUATION(hs);\n+                    }\n+                } // else try to parse anyways\n+                let input_reass = if head.stream_id == buf.stream_id { &buf.data } else { input };\n+\n                 let dyn_headers = if dir == Direction::ToClient {\n                     &mut self.dynamic_headers_tc\n                 } else {\n                     &mut self.dynamic_headers_ts\n                 };\n-                match parser::http2_parse_frame_continuation(input, dyn_headers) {\n+                match parser::http2_parse_frame_continuation(input_reass, dyn_headers) {\n                     Ok((_, hs)) => {\n+                        if head.stream_id == buf.stream_id {\n+                            buf.stream_id = 0;\n+                            buf.data.clear();\n+                        }\n                         self.process_headers(&hs.blocks, dir);\n                         return HTTP2FrameTypeData::CONTINUATION(hs);\n                     }\n                     Err(Err::Incomplete(_)) => {\n+                        if head.stream_id == buf.stream_id {\n+                            buf.stream_id = 0;\n+                            buf.data.clear();\n+                        }\n                         if complete {\n                             self.set_event(HTTP2Event::InvalidFrameData);\n                             return HTTP2FrameTypeData::UNHANDLED(HTTP2FrameUnhandled {\n@@ -870,6 +917,10 @@ impl HTTP2State {\n                         }\n                     }\n                     Err(_) => {\n+                        if head.stream_id == buf.stream_id {\n+                            buf.stream_id = 0;\n+                            buf.data.clear();\n+                        }\n                         self.set_event(HTTP2Event::InvalidFrameData);\n                         return HTTP2FrameTypeData::UNHANDLED(HTTP2FrameUnhandled {\n                             reason: HTTP2FrameUnhandledReason::ParsingError,\n@@ -878,6 +929,22 @@ impl HTTP2State {\n                 }\n             }\n             Some(parser::HTTP2FrameType::Headers) => {\n+                if head.flags & parser::HTTP2_FLAG_HEADER_END_HEADERS == 0 {\n+                    let buf = if dir == Direction::ToClient {\n+                        &mut self.s2c_buf\n+                    } else {\n+                        &mut self.c2s_buf\n+                    };\n+                    buf.data.clear();\n+                    buf.data.extend(input);\n+                    buf.stream_id = head.stream_id;\n+                    let hs = parser::HTTP2FrameHeaders {\n+                        padlength: None,\n+                        priority: None,\n+                        blocks: Vec::new(),\n+                    };\n+                    return HTTP2FrameTypeData::HEADERS(hs);\n+                }\n                 let dyn_headers = if dir == Direction::ToClient {\n                     &mut self.dynamic_headers_tc\n                 } else {\n@@ -961,15 +1028,19 @@ impl HTTP2State {\n                         input = &rem[hlsafe..];\n                         continue;\n                     }\n+                    let mut reass_limit_reached = false;\n                     let txdata = self.parse_frame_data(\n-                        head.ftype,\n+                        &head,\n                         &rem[..hlsafe],\n                         complete,\n-                        head.flags,\n                         dir,\n+                        &mut reass_limit_reached,\n                     );\n \n                     let tx = self.find_or_create_tx(&head, &txdata, dir);\n+                    if reass_limit_reached {\n+                        tx.tx_data.set_event(HTTP2Event::ReassemblyLimitReached as u8);\n+                    }\n                     tx.handle_frame(&head, &txdata, dir);\n                     let over = head.flags & parser::HTTP2_FLAG_HEADER_EOS != 0;\n                     let ftype = head.ftype;\n@@ -1306,6 +1377,13 @@ pub unsafe extern \"C\" fn rs_http2_register_parser() {\n                 SCLogError!(\"Invalid value for http2.max-table-size\");\n             }\n         }\n+        if let Some(val) = conf_get(\"app-layer.protocols.http2.max-reassembly-size\") {\n+            if let Ok(v) = val.parse::<u32>() {\n+                HTTP2_MAX_REASS = v as usize;\n+            } else {\n+                SCLogError!(\"Invalid value for http2.max-reassembly-size\");\n+            }\n+        }\n         SCLogDebug!(\"Rust http2 parser registered.\");\n     } else {\n         SCLogNotice!(\"Protocol detector and parser disabled for HTTP2.\");"
        },
        {
          "filename": "suricata.yaml.in",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -934,6 +934,8 @@ app-layer:\n       #max-streams: 4096\n       # Maximum headers table size\n       #max-table-size: 65536\n+      # Maximum reassembly size for header + continuation frames\n+      #max-reassembly-size: 102400\n     smtp:\n       enabled: yes\n       raw-extraction: no"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d63ad75d91014018acd950b0a35e03e23c38e8cc",
            "date": "2025-01-22T22:32:35Z",
            "author_login": "jasonish"
          },
          {
            "sha": "c8b28b1512141c57e1d5cf5216aea07ba13371bf",
            "date": "2025-01-21T22:57:31Z",
            "author_login": "jasonish"
          },
          {
            "sha": "d3c556b82da5273cd5a9f8d529dc896bdb346518",
            "date": "2025-01-21T21:23:15Z",
            "author_login": "jasonish"
          },
          {
            "sha": "c4fc2aac3b2a4b8fcd3d2deb7ffbd647c9155444",
            "date": "2025-01-21T21:21:46Z",
            "author_login": "jasonish"
          },
          {
            "sha": "a0bb260d916c2e2247df6a81142fc3eba201d1e8",
            "date": "2025-01-23T12:54:22Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-284",
    "description": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine.  Prior to 7.0.3, the rules inspecting HTTP2 headers can get bypassed by crafted traffic. The vulnerability has been patched in 7.0.3.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-26T16:27:58.293",
    "last_modified": "2024-12-19T19:30:33.157",
    "fix_date": "2024-01-25T15:01:14Z"
  },
  "references": [
    {
      "url": "https://github.com/OISF/suricata/commit/478a2a38f54e2ae235f8486bff87d7d66b6307f0",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-gv29-5hqw-5h8c",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GOCOBFUTIFHOP2PZOH4ENRFXRBHIRKK4/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZXJIT7R53ZXROO3I256RFUWTIW4ECK6P/",
      "source": "security-advisories@github.com",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6717",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/478a2a38f54e2ae235f8486bff87d7d66b6307f0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-gv29-5hqw-5h8c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GOCOBFUTIFHOP2PZOH4ENRFXRBHIRKK4/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZXJIT7R53ZXROO3I256RFUWTIW4ECK6P/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mailing List"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6717",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.160520",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "OISF",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-26T01:29:23Z",
    "pushed_at": "2025-01-24T13:42:36Z",
    "size": 74939,
    "stars": 4895,
    "forks": 1489,
    "open_issues": 83,
    "watchers": 4895,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 14021986,
      "Rust": 3489814,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45599,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1060,
      "avg_commits_per_week": 20.384615384615383,
      "days_active_last_year": 255
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-26T07:36:01.568394"
  }
}