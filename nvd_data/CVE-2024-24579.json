{
  "cve_id": "CVE-2024-24579",
  "github_data": {
    "repository": "anchore/stereoscope",
    "fix_commit": "09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204",
    "related_commits": [
      "09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204",
      "09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204"
    ],
    "patch_url": "https://github.com/anchore/stereoscope/commit/09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204.patch",
    "fix_commit_details": {
      "sha": "09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204",
      "commit_date": "2024-01-31T15:43:03Z",
      "author": {
        "login": "wagoodman",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix tar path traversal issue (#214)",
        "length": 101,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 300,
        "additions": 272,
        "deletions": 28
      },
      "files": [
        {
          "filename": "pkg/file/tarutil.go",
          "status": "modified",
          "additions": 51,
          "deletions": 28,
          "patch": "@@ -6,8 +6,10 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/pkg/errors\"\n+\t\"github.com/spf13/afero\"\n \n \t\"github.com/anchore/stereoscope/internal/log\"\n )\n@@ -124,40 +126,61 @@ func MetadataFromTar(reader io.ReadCloser, tarPath string) (Metadata, error) {\n \treturn *metadata, nil\n }\n \n-// UntarToDirectory writes the contents of the given tar reader to the given destination\n+// UntarToDirectory writes the contents of the given tar reader to the given destination. Note: this is meant to handle\n+// archives for images (not image contents) thus intentionally does not handle links or any kinds of special files.\n func UntarToDirectory(reader io.Reader, dst string) error {\n-\tvisitor := func(entry TarFileEntry) error {\n-\t\ttarget := filepath.Join(dst, entry.Header.Name)\n-\n-\t\tswitch entry.Header.Typeflag {\n-\t\tcase tar.TypeDir:\n-\t\t\tif _, err := os.Stat(target); err != nil {\n-\t\t\t\tif err := os.MkdirAll(target, 0755); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t}\n+\treturn IterateTar(\n+\t\treader,\n+\t\ttarVisitor{\n+\t\t\tfs:          afero.NewOsFs(),\n+\t\t\tdestination: dst,\n+\t\t}.visit,\n+\t)\n+}\n+\n+type tarVisitor struct {\n+\tfs          afero.Fs\n+\tdestination string\n+}\n+\n+func (v tarVisitor) visit(entry TarFileEntry) error {\n+\ttarget := filepath.Join(v.destination, entry.Header.Name)\n \n-\t\tcase tar.TypeReg:\n-\t\t\tf, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))\n-\t\t\tif err != nil {\n+\t// we should not allow for any destination path to be outside of where we are unarchiving to\n+\tif !strings.HasPrefix(target, v.destination) {\n+\t\treturn fmt.Errorf(\"potential path traversal attack with entry: %q\", entry.Header.Name)\n+\t}\n+\n+\tswitch entry.Header.Typeflag {\n+\tcase tar.TypeSymlink, tar.TypeLink:\n+\t\t// we don't handle this is to prevent any potential traversal attacks\n+\t\tlog.WithFields(\"path\", entry.Header.Name).Trace(\"skipping symlink/link entry in image tar\")\n+\n+\tcase tar.TypeDir:\n+\t\tif _, err := v.fs.Stat(target); err != nil {\n+\t\t\tif err := v.fs.MkdirAll(target, 0755); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n+\t\t}\n \n-\t\t\t// limit the reader on each file read to prevent decompression bomb attacks\n-\t\t\tnumBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))\n-\t\t\tif numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {\n-\t\t\t\treturn fmt.Errorf(\"zip read limit hit (potential decompression bomb attack)\")\n-\t\t\t}\n-\t\t\tif err != nil {\n-\t\t\t\treturn fmt.Errorf(\"unable to copy file: %w\", err)\n-\t\t\t}\n+\tcase tar.TypeReg:\n+\t\tf, err := v.fs.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \n-\t\t\tif err = f.Close(); err != nil {\n-\t\t\t\tlog.Errorf(\"failed to close file during untar of path=%q: %w\", f.Name(), err)\n-\t\t\t}\n+\t\t// limit the reader on each file read to prevent decompression bomb attacks\n+\t\tnumBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))\n+\t\tif numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {\n+\t\t\treturn fmt.Errorf(\"zip read limit hit (potential decompression bomb attack)\")\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"unable to copy file: %w\", err)\n \t\t}\n-\t\treturn nil\n-\t}\n \n-\treturn IterateTar(reader, visitor)\n+\t\tif err = f.Close(); err != nil {\n+\t\t\tlog.Errorf(\"failed to close file during untar of path=%q: %w\", f.Name(), err)\n+\t\t}\n+\t}\n+\treturn nil\n }"
        },
        {
          "filename": "pkg/file/tarutil_test.go",
          "status": "modified",
          "additions": 221,
          "deletions": 0,
          "patch": "@@ -4,17 +4,24 @@\n package file\n \n import (\n+\t\"archive/tar\"\n \t\"crypto/sha256\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"sort\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"github.com/scylladb/go-set/strset\"\n+\t\"github.com/spf13/afero\"\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n const (\n@@ -181,3 +188,217 @@ func fileExists(t testing.TB, filename string) bool {\n \t}\n \treturn !info.IsDir()\n }\n+\n+func Test_tarVisitor_visit(t *testing.T) {\n+\tassertNoFilesInRoot := func(t testing.TB, fs afero.Fs) {\n+\t\tt.Helper()\n+\n+\t\tallowableFiles := strset.New(\"tmp\")\n+\n+\t\t// list all files in root\n+\t\tfiles, err := afero.ReadDir(fs, \"/\")\n+\t\trequire.NoError(t, err)\n+\n+\t\tfor _, f := range files {\n+\t\t\tassert.True(t, allowableFiles.Has(f.Name()), \"unexpected file in root: %s\", f.Name())\n+\t\t}\n+\t}\n+\n+\tassertPaths := func(expectedFiles []string, expectedDirs []string) func(t testing.TB, fs afero.Fs) {\n+\t\treturn func(t testing.TB, fs afero.Fs) {\n+\t\t\tt.Helper()\n+\n+\t\t\tsort.Strings(expectedFiles)\n+\t\t\thaveFiles := strset.New()\n+\t\t\thaveDirs := strset.New()\n+\t\t\terr := afero.Walk(fs, \"/\", func(path string, info os.FileInfo, err error) error {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tif info.IsDir() {\n+\t\t\t\t\thaveDirs.Add(path)\n+\t\t\t\t} else {\n+\t\t\t\t\thaveFiles.Add(path)\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t})\n+\n+\t\t\thaveFilesList := haveFiles.List()\n+\t\t\tsort.Strings(haveFilesList)\n+\n+\t\t\thaveDirsList := haveDirs.List()\n+\t\t\tsort.Strings(haveDirsList)\n+\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tif d := cmp.Diff(expectedFiles, haveFilesList); d != \"\" {\n+\t\t\t\tt.Errorf(\"unexpected files (-want +got):\\n%s\", d)\n+\t\t\t}\n+\n+\t\t\tif d := cmp.Diff(expectedDirs, haveDirsList); d != \"\" {\n+\t\t\t\tt.Errorf(\"unexpected dirs (-want +got):\\n%s\", d)\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\n+\ttests := []struct {\n+\t\tname     string\n+\t\tentry    TarFileEntry\n+\t\twantErr  require.ErrorAssertionFunc\n+\t\tassertFs []func(t testing.TB, fs afero.Fs)\n+\t}{\n+\t\t{\n+\t\t\tname: \"regular file is written\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeReg,\n+\t\t\t\t\tName:     \"file.txt\",\n+\t\t\t\t\tLinkname: \"\",\n+\t\t\t\t\tSize:     2,\n+\t\t\t\t},\n+\t\t\t\tReader: strings.NewReader(\"hi\"),\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{\"/tmp/file.txt\"},\n+\t\t\t\t\t[]string{\"/\", \"/tmp\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"regular file with possible path traversal errors out\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeReg,\n+\t\t\t\t\tName:     \"../file.txt\",\n+\t\t\t\t\tLinkname: \"\",\n+\t\t\t\t\tSize:     2,\n+\t\t\t\t},\n+\t\t\t\tReader: strings.NewReader(\"hi\"),\n+\t\t\t},\n+\t\t\twantErr: require.Error,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"directory is created\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeDir,\n+\t\t\t\t\tName:     \"dir\",\n+\t\t\t\t\tLinkname: \"\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{},\n+\t\t\t\t\t[]string{\"/\", \"/tmp\", \"/tmp/dir\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"symlink is ignored\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeSymlink,\n+\t\t\t\t\tName:     \"symlink\",\n+\t\t\t\t\tLinkname: \"./../to-location\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{},\n+\t\t\t\t\t[]string{\"/\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"hardlink is ignored\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeLink,\n+\t\t\t\t\tName:     \"link\",\n+\t\t\t\t\tLinkname: \"./../to-location\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{},\n+\t\t\t\t\t[]string{\"/\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"device is ignored\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeChar,\n+\t\t\t\t\tName:     \"device\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{},\n+\t\t\t\t\t[]string{\"/\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"block device is ignored\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeBlock,\n+\t\t\t\t\tName:     \"device\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{},\n+\t\t\t\t\t[]string{\"/\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"pipe is ignored\",\n+\t\t\tentry: TarFileEntry{\n+\t\t\t\tSequence: 0,\n+\t\t\t\tHeader: tar.Header{\n+\t\t\t\t\tTypeflag: tar.TypeFifo,\n+\t\t\t\t\tName:     \"pipe\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tassertFs: []func(t testing.TB, fs afero.Fs){\n+\t\t\t\tassertPaths(\n+\t\t\t\t\t[]string{},\n+\t\t\t\t\t[]string{\"/\"},\n+\t\t\t\t),\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tif tt.wantErr == nil {\n+\t\t\t\ttt.wantErr = require.NoError\n+\t\t\t}\n+\t\t\tv := tarVisitor{\n+\t\t\t\tfs:          afero.NewMemMapFs(),\n+\t\t\t\tdestination: \"/tmp\",\n+\t\t\t}\n+\t\t\terr := v.visit(tt.entry)\n+\t\t\ttt.wantErr(t, err)\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor _, fn := range tt.assertFs {\n+\t\t\t\tfn(t, v.fs)\n+\t\t\t}\n+\n+\t\t\t// even if the test has no other assertions, check that the root is empty\n+\t\t\tassertNoFilesInRoot(t, v.fs)\n+\t\t})\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e394cf5ed172b1979f3c1c631ab769fc72a2c182",
            "date": "2025-01-08T17:02:57Z",
            "author_login": "wagoodman"
          },
          {
            "sha": "86fec8eeae46a0959dd6644bdb1f689bfd7c0c40",
            "date": "2025-01-08T16:38:44Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "87cf9eb7bb37346e7de3e75c97b3429150023795",
            "date": "2025-01-08T16:38:36Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "6633b73de02a12e86413fc71c1c468abbba2cddd",
            "date": "2024-12-23T18:19:50Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3984f6f3d54945c488a648077fe8a1e3e04c1a60",
            "date": "2024-12-13T12:17:37Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-22",
    "description": "stereoscope is a go library for processing container images and simulating a squash filesystem.  Prior to version 0.0.1, it is possible to craft an OCI tar archive that, when stereoscope attempts to unarchive the contents, will result in writing to paths outside of the unarchive temporary directory. Specifically, use of `github.com/anchore/stereoscope/pkg/file.UntarToDirectory()` function, the  `github.com/anchore/stereoscope/pkg/image/oci.TarballImageProvider` struct, or the higher level `github.com/anchore/stereoscope/pkg/image.Image.Read()` function express this vulnerability. As a workaround, if you are using the OCI archive as input into stereoscope then you can switch to using an OCI layout by unarchiving the tar archive and provide the unarchived directory to stereoscope.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-31T17:15:40.170",
    "last_modified": "2024-11-21T08:59:27.897",
    "fix_date": "2024-01-31T15:43:03Z"
  },
  "references": [
    {
      "url": "https://github.com/anchore/stereoscope/commit/09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/anchore/stereoscope/security/advisories/GHSA-hpxr-w9w7-g4gv",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/anchore/stereoscope/commit/09dacab4d9ee65ee8bc7af8ebf4aa7b5aaa36204",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/anchore/stereoscope/security/advisories/GHSA-hpxr-w9w7-g4gv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.553003",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "stereoscope",
    "owner": "anchore",
    "created_at": "2020-05-05T18:39:19Z",
    "updated_at": "2025-01-12T03:07:40Z",
    "pushed_at": "2025-01-10T20:59:48Z",
    "size": 1087,
    "stars": 88,
    "forks": 47,
    "open_issues": 27,
    "watchers": 88,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 603790,
      "Makefile": 5593,
      "Shell": 4474,
      "Dockerfile": 2976
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T22:38:55.488197"
  }
}