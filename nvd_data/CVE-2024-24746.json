{
  "cve_id": "CVE-2024-24746",
  "github_data": {
    "repository": "apache/mynewt-nimble",
    "fix_commit": "d42a0ebe6632bd0c318560e4293a522634f60594",
    "related_commits": [
      "d42a0ebe6632bd0c318560e4293a522634f60594",
      "d42a0ebe6632bd0c318560e4293a522634f60594"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "d42a0ebe6632bd0c318560e4293a522634f60594",
      "commit_date": "2024-01-29T15:28:12Z",
      "author": {
        "login": "sjanc",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "nimble/host: Fix disconnect on host connection timeout",
        "length": 268,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 111,
        "additions": 49,
        "deletions": 62
      },
      "files": [
        {
          "filename": "nimble/host/src/ble_hs_conn.c",
          "status": "modified",
          "additions": 49,
          "deletions": 62,
          "patch": "@@ -477,86 +477,73 @@ ble_hs_conn_timer(void)\n #endif\n \n     struct ble_hs_conn *conn;\n-    ble_npl_time_t now;\n-    int32_t next_exp_in;\n+    ble_npl_time_t now = ble_npl_time_get();\n+    int32_t next_exp_in = BLE_HS_FOREVER;\n+    int32_t next_exp_in_new;\n+    bool next_exp_in_updated;\n     int32_t time_diff;\n-    uint16_t conn_handle;\n \n-    for (;;) {\n-        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n-        next_exp_in = BLE_HS_FOREVER;\n-        now = ble_npl_time_get();\n+    ble_hs_lock();\n \n-        ble_hs_lock();\n-\n-        /* This loop performs one of two tasks:\n-         * 1. Determine if any connections need to be terminated due to timeout.\n-         *    If so, break out of the loop and terminate the connection.  This\n-         *    function will need to be executed again.\n-         * 2. Otherwise, determine when the next timeout will occur.\n-         */\n-        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n-            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n+    /* This loop performs one of two tasks:\n+     * 1. Determine if any connections need to be terminated due to timeout. If\n+     *    so connection is disconnected.\n+     * 2. Otherwise, determine when the next timeout will occur.\n+     */\n+    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n+        if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n+            next_exp_in_updated = false;\n \n #if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n-                /* Check each connection's rx fragment timer.  If too much time\n-                 * passes after a partial packet is received, the connection is\n-                 * terminated.\n-                 */\n-                if (conn->bhc_rx_chan != NULL) {\n-                    time_diff = conn->bhc_rx_timeout - now;\n-\n-                    if (time_diff <= 0) {\n-                        /* ACL reassembly has timed out.  Remember the connection\n-                         * handle so it can be terminated after the mutex is\n-                         * unlocked.\n-                         */\n-                        conn_handle = conn->bhc_handle;\n-                        break;\n-                    }\n-\n-                    /* Determine if this connection is the soonest to time out. */\n-                    if (time_diff < next_exp_in) {\n-                        next_exp_in = time_diff;\n-                    }\n-                }\n-#endif\n+            /* Check each connection's rx fragment timer.  If too much time\n+             * passes after a partial packet is received, the connection is\n+             * terminated.\n+             */\n+            if (conn->bhc_rx_chan != NULL) {\n+                time_diff = conn->bhc_rx_timeout - now;\n \n-#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n-                /* Check each connection's rx queued write timer.  If too much\n-                 * time passes after a prep write is received, the queue is\n-                 * cleared.\n-                 */\n-                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                 if (time_diff <= 0) {\n-                    /* ACL reassembly has timed out.  Remember the connection\n-                     * handle so it can be terminated after the mutex is\n-                     * unlocked.\n-                     */\n-                    conn_handle = conn->bhc_handle;\n-                    break;\n+                    /* ACL reassembly has timed out.*/\n+                    ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);\n+                    continue;\n                 }\n \n                 /* Determine if this connection is the soonest to time out. */\n                 if (time_diff < next_exp_in) {\n-                    next_exp_in = time_diff;\n+                    next_exp_in_new = time_diff;\n+                    next_exp_in_updated = true;\n                 }\n+            }\n #endif\n+\n+#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n+            /* Check each connection's rx queued write timer.  If too much\n+             * time passes after a prep write is received, the queue is\n+             * cleared.\n+             */\n+            time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n+            if (time_diff <= 0) {\n+                /* Queued write has timed out.*/\n+                ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);\n+                continue;\n             }\n-        }\n \n-        ble_hs_unlock();\n+            /* Determine if this connection is the soonest to time out. */\n+            if (time_diff < next_exp_in) {\n+                next_exp_in_new = time_diff;\n+                next_exp_in_updated = true;\n+            }\n+#endif\n \n-        /* If a connection has timed out, terminate it.  We need to repeatedly\n-         * call this function again to determine when the next timeout is.\n-         */\n-        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n-            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n-            continue;\n+            if (next_exp_in_updated) {\n+                next_exp_in = next_exp_in_new;\n+            }\n         }\n-\n-        return next_exp_in;\n     }\n+\n+    ble_hs_unlock();\n+\n+    return next_exp_in;\n }\n \n int"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "63db05e991af2279e1c2b956f6975e8164741e0d",
            "date": "2024-11-27T19:02:14Z",
            "author_login": "szymon-czapracki"
          },
          {
            "sha": "cf947cd5ae3fcab858f6adcc288dd3f2630fb9db",
            "date": "2024-12-27T21:48:57Z",
            "author_login": "chrysn"
          },
          {
            "sha": "39b367f0033f852eabf34d44304bea106db86a5b",
            "date": "2024-12-24T01:53:56Z",
            "author_login": "chrysn"
          },
          {
            "sha": "3eacaf5624b40384993075d367a19f46a2c449b4",
            "date": "2024-12-18T16:23:51Z",
            "author_login": "sjanc"
          },
          {
            "sha": "2fcb7812d765adc6f167c2c6a5c56e2bfaf2c6e9",
            "date": "2025-01-03T15:09:32Z",
            "author_login": "guy-m"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-835",
    "description": "Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in Apache NimBLE.\u00a0\n\nSpecially crafted GATT operation can cause infinite loop in GATT server leading to denial of service in Bluetooth stack or device.\n\nThis issue affects Apache NimBLE: through 1.6.0.\nUsers are recommended to upgrade to version 1.7.0, which fixes the issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-06T12:15:08.310",
    "last_modified": "2024-11-21T08:59:36.647",
    "fix_date": "2024-01-29T15:28:12Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/04/05/2",
      "source": "security@apache.org",
      "tags": []
    },
    {
      "url": "https://github.com/apache/mynewt-nimble/commit/d42a0ebe6632bd0c318560e4293a522634f60594",
      "source": "security@apache.org",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread/bptkzc0o2ymjk8qqzqdmy39kcmh27078",
      "source": "security@apache.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/04/05/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/apache/mynewt-nimble/commit/d42a0ebe6632bd0c318560e4293a522634f60594",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.apache.org/thread/bptkzc0o2ymjk8qqzqdmy39kcmh27078",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.437819",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "mynewt-nimble",
    "owner": "apache",
    "created_at": "2017-12-04T19:34:47Z",
    "updated_at": "2025-01-24T09:03:22Z",
    "pushed_at": "2025-01-24T09:07:39Z",
    "size": 17126,
    "stars": 732,
    "forks": 409,
    "open_issues": 219,
    "watchers": 732,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 8389109,
      "Python": 105770,
      "Ruby": 25717,
      "Makefile": 14154,
      "Shell": 8499,
      "C++": 5605,
      "Batchfile": 1870
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:01:40.040428"
  }
}