{
  "cve_id": "CVE-2024-24747",
  "github_data": {
    "repository": "minio/minio",
    "fix_commit": "0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776",
    "related_commits": [
      "0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776",
      "0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776"
    ],
    "patch_url": "https://github.com/minio/minio/commit/0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776.patch",
    "fix_commit_details": {
      "sha": "0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776",
      "commit_date": "2024-01-31T18:56:45Z",
      "author": {
        "login": "donatello",
        "type": "User",
        "stats": {
          "total_commits": 361,
          "average_weekly_commits": 0.6760299625468165,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 186
        }
      },
      "commit_message": {
        "title": "fix: permission checks for editing access keys (#18928)",
        "length": 421,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 203,
        "additions": 120,
        "deletions": 83
      },
      "files": [
        {
          "filename": "cmd/admin-handlers-users.go",
          "status": "modified",
          "additions": 12,
          "deletions": 9,
          "patch": "@@ -774,6 +774,16 @@ func (a adminAPIHandlers) UpdateServiceAccount(w http.ResponseWriter, r *http.Re\n \t\treturn\n \t}\n \n+\t// Permission checks:\n+\t//\n+\t// 1. Any type of account (i.e. access keys (previously/still called service\n+\t// accounts), STS accounts, internal IDP accounts, etc) with the\n+\t// policy.UpdateServiceAccountAdminAction permission can update any service\n+\t// account.\n+\t//\n+\t// 2. We would like to let a user update their own access keys, however it\n+\t// is currently blocked pending a re-design. Users are still able to delete\n+\t// and re-create them.\n \tif !globalIAMSys.IsAllowed(policy.Args{\n \t\tAccountName:     cred.AccessKey,\n \t\tGroups:          cred.Groups,\n@@ -782,15 +792,8 @@ func (a adminAPIHandlers) UpdateServiceAccount(w http.ResponseWriter, r *http.Re\n \t\tIsOwner:         owner,\n \t\tClaims:          cred.Claims,\n \t}) {\n-\t\trequestUser := cred.AccessKey\n-\t\tif cred.ParentUser != \"\" {\n-\t\t\trequestUser = cred.ParentUser\n-\t\t}\n-\n-\t\tif requestUser != svcAccount.ParentUser {\n-\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n-\t\t\treturn\n-\t\t}\n+\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n+\t\treturn\n \t}\n \n \tpassword := cred.SecretKey"
        },
        {
          "filename": "cmd/admin-handlers-users_test.go",
          "status": "modified",
          "additions": 90,
          "deletions": 8,
          "patch": "@@ -206,6 +206,7 @@ func TestIAMInternalIDPServerSuite(t *testing.T) {\n \t\t\t\tsuite.TestCannedPolicies(c)\n \t\t\t\tsuite.TestGroupAddRemove(c)\n \t\t\t\tsuite.TestServiceAccountOpsByAdmin(c)\n+\t\t\t\tsuite.TestServiceAccountPrivilegeEscalationBug(c)\n \t\t\t\tsuite.TestServiceAccountOpsByUser(c)\n \t\t\t\tsuite.TestAddServiceAccountPerms(c)\n \t\t\t\tsuite.TearDownSuite(c)\n@@ -896,14 +897,6 @@ func (s *TestSuiteIAM) TestServiceAccountOpsByUser(c *check) {\n \t// 3. Check S3 access\n \tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n \n-\t// 4. Check that svc account can restrict the policy, and that the\n-\t// session policy can be updated.\n-\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, accessKey, bucket)\n-\n-\t// 4. Check that service account's secret key and account status can be\n-\t// updated.\n-\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, accessKey, bucket)\n-\n \t// 5. Check that service account can be deleted.\n \tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n \n@@ -979,6 +972,95 @@ func (s *TestSuiteIAM) TestServiceAccountOpsByAdmin(c *check) {\n \tc.assertSvcAccDeletion(ctx, s, s.adm, accessKey, bucket)\n }\n \n+func (s *TestSuiteIAM) TestServiceAccountPrivilegeEscalationBug(c *check) {\n+\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n+\tdefer cancel()\n+\n+\terr := s.client.MakeBucket(ctx, \"public\", minio.MakeBucketOptions{})\n+\tif err != nil {\n+\t\tc.Fatalf(\"bucket creat error: %v\", err)\n+\t}\n+\n+\terr = s.client.MakeBucket(ctx, \"private\", minio.MakeBucketOptions{})\n+\tif err != nil {\n+\t\tc.Fatalf(\"bucket creat error: %v\", err)\n+\t}\n+\n+\tpubPolicyBytes := []byte(`{\n+ \"Version\": \"2012-10-17\",\n+ \"Statement\": [\n+  {\n+   \"Effect\": \"Allow\",\n+   \"Action\": [\n+    \"s3:*\"\n+   ],\n+   \"Resource\": [\n+    \"arn:aws:s3:::public\",\n+    \"arn:aws:s3:::public/*\"\n+   ]\n+  }\n+ ]\n+}`)\n+\n+\tfullS3PolicyBytes := []byte(`{\n+  \"Version\": \"2012-10-17\",\n+  \"Statement\": [\n+    {\n+      \"Effect\": \"Allow\",\n+      \"Action\": [\n+        \"s3:*\"\n+      ],\n+      \"Resource\": [\n+        \"arn:aws:s3:::*\"\n+      ]\n+    }\n+  ]\n+}\n+`)\n+\n+\t// Create a service account for the root user.\n+\tcr, err := s.adm.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n+\t\tTargetUser: globalActiveCred.AccessKey,\n+\t\tPolicy:     pubPolicyBytes,\n+\t})\n+\tif err != nil {\n+\t\tc.Fatalf(\"admin should be able to create service account for themselves %s\", err)\n+\t}\n+\n+\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n+\n+\t// Check that the service account can access the public bucket.\n+\tbuckets, err := svcClient.ListBuckets(ctx)\n+\tif err != nil {\n+\t\tc.Fatalf(\"err fetching buckets %s\", err)\n+\t}\n+\tif len(buckets) != 1 || buckets[0].Name != \"public\" {\n+\t\tc.Fatalf(\"service account should only have access to public bucket\")\n+\t}\n+\n+\t// Create an madmin client with the service account creds.\n+\tsvcAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n+\t\tCreds:  credentials.NewStaticV4(cr.AccessKey, cr.SecretKey, \"\"),\n+\t\tSecure: s.secure,\n+\t})\n+\tif err != nil {\n+\t\tc.Fatalf(\"Err creating svcacct admin client: %v\", err)\n+\t}\n+\tsvcAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n+\n+\t// Attempt to update the policy on the service account.\n+\terr = svcAdmClient.UpdateServiceAccount(ctx, cr.AccessKey,\n+\t\tmadmin.UpdateServiceAccountReq{\n+\t\t\tNewPolicy: fullS3PolicyBytes,\n+\t\t})\n+\n+\tif err == nil {\n+\t\tc.Fatalf(\"service account should not be able to update policy on itself\")\n+\t} else if !strings.Contains(err.Error(), \"Access Denied\") {\n+\t\tc.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+}\n+\n func (s *TestSuiteIAM) SetUpAccMgmtPlugin(c *check) {\n \tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n \tdefer cancel()"
        },
        {
          "filename": "cmd/auth-handler.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -162,7 +162,8 @@ func validateAdminSignature(ctx context.Context, r *http.Request, region string)\n \ts3Err := ErrAccessDenied\n \tif _, ok := r.Header[xhttp.AmzContentSha256]; ok &&\n \t\tgetRequestAuthType(r) == authTypeSigned {\n-\t\t// We only support admin credentials to access admin APIs.\n+\n+\t\t// Get credential information from the request.\n \t\tcred, owner, s3Err = getReqAccessKeyV4(r, region, serviceS3)\n \t\tif s3Err != ErrNone {\n \t\t\treturn cred, owner, s3Err"
        },
        {
          "filename": "cmd/iam.go",
          "status": "modified",
          "additions": 14,
          "deletions": 31,
          "patch": "@@ -974,7 +974,7 @@ func (sys *IAMSys) NewServiceAccount(ctx context.Context, parentUser string, gro\n \t\tm[iamPolicyClaimNameSA()] = inheritedPolicyType\n \t}\n \n-\t// Add all the necessary claims for the service accounts.\n+\t// Add all the necessary claims for the service account.\n \tfor k, v := range opts.claims {\n \t\t_, ok := m[k]\n \t\tif !ok {\n@@ -1848,37 +1848,14 @@ func (sys *IAMSys) IsAllowedServiceAccount(args policy.Args, parentUser string)\n \t\treturn isOwnerDerived || combinedPolicy.IsAllowed(parentArgs)\n \t}\n \n-\t// Now check if we have a sessionPolicy.\n-\tspolicy, ok := args.Claims[sessionPolicyNameExtracted]\n-\tif !ok {\n-\t\treturn false\n-\t}\n-\n-\tspolicyStr, ok := spolicy.(string)\n-\tif !ok {\n-\t\t// Sub policy if set, should be a string reject\n-\t\t// malformed/malicious requests.\n-\t\treturn false\n-\t}\n-\n-\t// Check if policy is parseable.\n-\tsubPolicy, err := policy.ParseConfig(bytes.NewReader([]byte(spolicyStr)))\n-\tif err != nil {\n-\t\t// Log any error in input session policy config.\n-\t\tlogger.LogIf(GlobalContext, err)\n-\t\treturn false\n-\t}\n-\n-\t// This can only happen if policy was set but with an empty JSON.\n-\tif subPolicy.Version == \"\" && len(subPolicy.Statements) == 0 {\n-\t\treturn isOwnerDerived || combinedPolicy.IsAllowed(parentArgs)\n-\t}\n-\n-\tif subPolicy.Version == \"\" {\n-\t\treturn false\n+\t// 3. If an inline session-policy is present, evaluate it.\n+\thasSessionPolicy, isAllowedSP := isAllowedBySessionPolicy(args)\n+\tif hasSessionPolicy {\n+\t\treturn isAllowedSP && (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))\n \t}\n \n-\treturn subPolicy.IsAllowed(parentArgs) && (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))\n+\t// Sub policy not set. Evaluate only the parent policies.\n+\treturn (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))\n }\n \n // IsAllowedSTS is meant for STS based temporary credentials,\n@@ -2000,8 +1977,14 @@ func isAllowedBySessionPolicy(args policy.Args) (hasSessionPolicy bool, isAllowe\n \t\treturn\n \t}\n \n+\t// As the session policy exists, even if the parent is the root account, it\n+\t// must be restricted by it. So, we set `.IsOwner` to false here\n+\t// unconditionally.\n+\tsessionPolicyArgs := args\n+\tsessionPolicyArgs.IsOwner = false\n+\n \t// Sub policy is set and valid.\n-\treturn hasSessionPolicy, subPolicy.IsAllowed(args)\n+\treturn hasSessionPolicy, subPolicy.IsAllowed(sessionPolicyArgs)\n }\n \n // GetCombinedPolicy returns a combined policy combining all policies"
        },
        {
          "filename": "cmd/signature-v4-utils.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -158,8 +158,8 @@ func checkKeyValid(r *http.Request, accessKey string) (auth.Credentials, bool, A\n \t\t// Check if the access key is part of users credentials.\n \t\tu, ok := globalIAMSys.GetUser(r.Context(), accessKey)\n \t\tif !ok {\n-\t\t\t// Credentials will be invalid but and disabled\n-\t\t\t// return a different error in such a scenario.\n+\t\t\t// Credentials could be valid but disabled - return a different\n+\t\t\t// error in such a scenario.\n \t\t\tif u.Credentials.Status == auth.AccountOff {\n \t\t\t\treturn cred, false, ErrAccessKeyDisabled\n \t\t\t}"
        },
        {
          "filename": "cmd/sts-handlers_test.go",
          "status": "modified",
          "additions": 0,
          "deletions": 32,
          "patch": "@@ -909,14 +909,6 @@ func (s *TestSuiteIAM) TestLDAPSTSServiceAccounts(c *check) {\n \t// 3. Check S3 access\n \tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n \n-\t// 4. Check that svc account can restrict the policy, and that the\n-\t// session policy can be updated.\n-\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n-\t// 4. Check that service account's secret key and account status can be\n-\t// updated.\n-\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n \t// 5. Check that service account can be deleted.\n \tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n \n@@ -1101,14 +1093,6 @@ func (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithGroups(c *check) {\n \t// 3. Check S3 access\n \tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n \n-\t// 4. Check that svc account can restrict the policy, and that the\n-\t// session policy can be updated.\n-\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n-\t// 4. Check that service account's secret key and account status can be\n-\t// updated.\n-\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n \t// 5. Check that service account can be deleted.\n \tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n \n@@ -1358,14 +1342,6 @@ func (s *TestSuiteIAM) TestOpenIDServiceAcc(c *check) {\n \t// 3. Check S3 access\n \tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n \n-\t// 4. Check that svc account can restrict the policy, and that the\n-\t// session policy can be updated.\n-\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n-\t// 4. Check that service account's secret key and account status can be\n-\t// updated.\n-\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n \t// 5. Check that service account can be deleted.\n \tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n \n@@ -1658,14 +1634,6 @@ func (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicy(c *check) {\n \t// 3. Check S3 access\n \tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n \n-\t// 4. Check that svc account can restrict the policy, and that the\n-\t// session policy can be updated.\n-\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n-\t// 4. Check that service account's secret key and account status can be\n-\t// updated.\n-\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n-\n \t// 5. Check that service account can be deleted.\n \tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n }"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4952bdb77035e8142b2f0fc5b86181aeb1d3e82e",
            "date": "2025-01-14T19:53:02Z",
            "author_login": "poornas"
          },
          {
            "sha": "00b2ef29323e786a8958bf0bedced133cb06245f",
            "date": "2025-01-08T11:09:24Z",
            "author_login": "vadmeste"
          },
          {
            "sha": "4536ecfaa4d81dd3f648616094a4936162089db8",
            "date": "2025-01-06T15:51:54Z",
            "author_login": "klauspost"
          },
          {
            "sha": "43a74029685512ce9b1b76c053d48b43fc8d64fc",
            "date": "2025-01-03T05:34:47Z",
            "author_login": "harshavardhana"
          },
          {
            "sha": "330dca9a354cdf445d71979170bbe3d27971d127",
            "date": "2024-12-21T04:24:45Z",
            "author_login": "allanrogerr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-269",
    "description": "MinIO is a High Performance Object Storage. When someone creates an access key, it inherits the permissions of the parent key. Not only for `s3:*` actions, but also `admin:*` actions. Which means unless somewhere above in the access-key hierarchy, the `admin` rights are denied, access keys will be able to simply override their own `s3` permissions to something more permissive. The vulnerability is fixed in RELEASE.2024-01-31T20-20-33Z.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-01-31T22:15:54.813",
    "last_modified": "2024-11-21T08:59:36.850",
    "fix_date": "2024-01-31T18:56:45Z"
  },
  "references": [
    {
      "url": "https://github.com/minio/minio/commit/0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/minio/minio/releases/tag/RELEASE.2024-01-31T20-20-33Z",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/minio/minio/security/advisories/GHSA-xx8w-mq23-29g4",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/minio/minio/commit/0ae4915a9391ef4b3ec80f5fcdcf24ee6884e776",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/minio/minio/releases/tag/RELEASE.2024-01-31T20-20-33Z",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch",
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/minio/minio/security/advisories/GHSA-xx8w-mq23-29g4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Patch",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.554469",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "minio",
    "owner": "minio",
    "created_at": "2015-01-14T19:23:58Z",
    "updated_at": "2025-01-14T10:52:24Z",
    "pushed_at": "2025-01-08T11:09:25Z",
    "size": 131770,
    "stars": 49440,
    "forks": 5609,
    "open_issues": 33,
    "watchers": 49440,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release"
    ],
    "languages": {
      "Go": 8661217,
      "Shell": 72203,
      "Makefile": 11634,
      "Mustache": 6628,
      "Smarty": 872,
      "Dockerfile": 229
    },
    "commit_activity": {
      "total_commits_last_year": 949,
      "avg_commits_per_week": 18.25,
      "days_active_last_year": 271
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T12:53:58.932687"
  }
}