{
  "cve_id": "CVE-2024-24759",
  "github_data": {
    "repository": "mindsdb/mindsdb",
    "fix_commit": "5f7496481bd3db1d06a2d2e62c0dce960a1fe12b",
    "related_commits": [
      "5f7496481bd3db1d06a2d2e62c0dce960a1fe12b"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "5f7496481bd3db1d06a2d2e62c0dce960a1fe12b",
      "commit_date": "2024-01-05T10:52:51Z",
      "author": {
        "login": "dusvyat",
        "type": "User",
        "stats": {
          "total_commits": 332,
          "average_weekly_commits": 0.9880952380952381,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 64
        }
      },
      "commit_message": {
        "title": "Release v23.12.4.2 (#8573)",
        "length": 2260,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1296,
        "additions": 939,
        "deletions": 357
      },
      "files": [
        {
          "filename": "mindsdb/__about__.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n __title__ = 'MindsDB'\n __package_name__ = 'mindsdb'\n-__version__ = '23.12.4.1'\n+__version__ = '23.12.4.2'\n __description__ = \"MindsDB server, provides server capabilities to mindsdb native python library\"\n __email__ = \"jorge@mindsdb.com\"\n __author__ = 'MindsDB Inc'"
        },
        {
          "filename": "mindsdb/integrations/handlers/anyscale_endpoints_handler/anyscale_endpoints_handler.py",
          "status": "modified",
          "additions": 44,
          "deletions": 14,
          "patch": "@@ -1,6 +1,6 @@\n import os\n-import json\n import openai\n+import json\n import contextlib\n from typing import Optional, Dict\n \n@@ -32,7 +32,6 @@ def __init__(self, *args, **kwargs):\n         self.rate_limit = 25  # requests per minute\n         self.max_batch_size = 20\n         self.default_max_tokens = 100\n-        self.ft_cls = openai.FineTuningJob  # non-legacy fine-tuning endpoint\n \n     @staticmethod\n     @contextlib.contextmanager\n@@ -47,24 +46,25 @@ def _anyscale_base_api(key='OPENAI_API_BASE'):\n \n     def create(self, target, args=None, **kwargs):\n         with self._anyscale_base_api():\n+            # load base and fine-tuned models, then hand over\n             self._set_models(args.get('using', {}))\n-\n-            # load fine-tuned models, then hand over\n             _args = self.model_storage.json_get('args')\n             base_models = self.chat_completion_models\n             self.chat_completion_models = _args.get('chat_completion_models', base_models) if _args else base_models\n             super().create(target, args, **kwargs)\n \n     def predict(self, df: pd.DataFrame, args: Optional[Dict] = None) -> pd.DataFrame:\n         with self._anyscale_base_api():\n-            # load fine-tuned models, then hand over\n+            # load base and fine-tuned models, then hand over\n+            self._set_models(args.get('using', {}))\n             _args = self.model_storage.json_get('args')\n             base_models = self.chat_completion_models\n             self.chat_completion_models = _args.get('chat_completion_models', base_models) if _args else base_models\n             return super().predict(df, args)\n \n     def finetune(self, df: Optional[pd.DataFrame] = None, args: Optional[Dict] = None) -> None:\n         with self._anyscale_base_api():\n+            self._set_models(args.get('using', {}))\n             super().finetune(df, args)\n             # rewrite chat_completion_models to include the newly fine-tuned model\n             args = self.model_storage.json_get('args')\n@@ -90,11 +90,10 @@ def describe(self, attribute: Optional[str] = None) -> pd.DataFrame:\n     def _set_models(self, args):\n         if 'api_key' in args:\n             args['openai_api_key'] = args['api_key']  # remove this once #7496 is fixed\n-        self.all_models = [m['id'] for m in openai.Model.list(\n-            api_key=get_api_key('openai', args, self.engine_storage),\n-            api_base=ANYSCALE_API_BASE)['data']]\n-        self.chat_completion_models = self.all_models\n-        self.supported_ft_models = self.all_models  # base models compatible with fine-tuning\n+        client = self._get_client(get_api_key('openai', args, self.engine_storage))\n+        self.all_models = [m.id for m in client.models.list()]\n+        self.chat_completion_models = [m.id for m in client.models.list() if m.rayllm_metadata['engine_config']['model_type'] == 'text-generation']  # noqa\n+        self.supported_ft_models = self.chat_completion_models  # base models compatible with fine-tuning\n \n     @staticmethod\n     def _check_ft_cols(df, cols):\n@@ -107,19 +106,46 @@ def _prepare_ft_jsonl(self, df, temp_storage_path, temp_filename, _, test_size=0\n             df: has exactly two columns, `role` and `content`. Rows contain >= 1 chats in long (stacked) format.\n             For more details, check `FineTuning -> Data Format` in the Anyscale API reference.\n         \"\"\"\n+        def _is_valid(chat):\n+            \"\"\" Check if chat is valid according to Anyscale criteria.\"\"\"\n+            roles = [m['role'] for m in chat]\n+            transitions = {None: ['system', 'user'], 'system': ['user'], 'user': ['assistant'], 'assistant': ['user']}\n+\n+            # check base condition\n+            if not ('user' in roles and 'assistant' in roles):\n+                return False\n+\n+            # check order is valid\n+            state = None\n+            for role in roles:\n+                if role not in transitions[state]:\n+                    return False\n+                else:\n+                    state = role\n+\n+            # chat is valid, return\n+            return True\n+\n         # 1. aggregate each chat sequence into one row\n         chats = []\n         chat = []\n         for i, row in df.iterrows():\n             if row['role'] == 'system' and len(chat) > 0:\n-                chats.append({'messages': chat})\n+                if _is_valid(chat):\n+                    chats.append({'messages': chat})\n                 chat = []\n             event = {'role': row['role'], 'content': row['content']}\n             chat.append(event)\n-        chats.append({'messages': chat})\n+\n+        if _is_valid(chat):\n+            chats.append({'messages': chat})\n+\n         series = pd.Series(chats)\n-        train = series.iloc[:int(len(series) * (1 - test_size))]\n-        val = series.iloc[-int(len(series) * test_size) - 1:]\n+        if len(series) < 20 * 2:\n+            raise Exception(\"Dataset is too small to finetune. Please include at least 40 samples (complete chats).\")\n+        val_size = max(20, int(len(series) * test_size))  # at least 20 samples required by Anyscale\n+        train = series.iloc[:-val_size]\n+        val = series.iloc[-val_size:]\n \n         # 2. write as jsonl\n         file_names = {\n@@ -190,3 +216,7 @@ def check_data_for_format_errors(items: list):\n             check_data_for_format_errors(items)\n         except Exception as e:\n             raise Exception(f\"Fine-tuning data format is not valid. Got: {e}\")\n+\n+    @staticmethod\n+    def _get_client(api_key, base_url=ANYSCALE_API_BASE, org=None):\n+        return openai.OpenAI(api_key=api_key, base_url=base_url, organization=org)"
        },
        {
          "filename": "mindsdb/integrations/handlers/anyscale_endpoints_handler/requirements.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,2 +1,2 @@\n-openai == 0.28.1\n+openai == 1.6.1\n -r mindsdb/integrations/handlers/openai_handler/requirements.txt"
        },
        {
          "filename": "mindsdb/integrations/handlers/instatus_handler/README.md",
          "status": "modified",
          "additions": 101,
          "deletions": 41,
          "patch": "@@ -17,11 +17,49 @@ Please follow this [link](https://dashboard.instatus.com/developer) to get the a\n ## Implemented Features\n \n - [x] Instatus status pages table\n-  - [x] Get status pages\n-  - [x] Create a status page\n-  - [x] Update a status page\n-\n-## Example Usage\n+  - [x] Support SELECT\n+  - [x] Support INSERT\n+  - [x] Support UPDATE\n+- [x] Instatus components table\n+  - [x] Support SELECT\n+  - [x] Support INSERT\n+  - [x] Support UPDATE\n+\n+## TODO\n+- [ ] Instatus Incidents table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Incidents updates table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Maintenances table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Maintenance updates table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Templates table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Teammates table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Subscribers table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+- [ ] Instatus Metrics table\n+  - [ ] Support SELECT\n+  - [ ] Support INSERT\n+  - [ ] Support UPDATE\n+\n+## Connection\n \n The first step is to create a database with the new `instatus` engine.\n \n@@ -33,47 +71,24 @@ WITH\n     \"api_key\": \"<your-instatus-api-key>\" --- Instatus API key to use for authentication.\n   };\n ```\n+## Usage (Status pages table)\n \n-### Get your status pages\n-\n-Example 1: Select all columns\n+### SELECT\n \n ```sql\n SELECT *\n FROM mindsdb_instatus.status_pages;\n ```\n \n-Example 2: Select specific columns\n-\n-```sql\n-SELECT id, name, status\n-FROM mindsdb_instatus.status_pages;\n-```\n-\n-Example 3: Get specific status page\n+### WHERE\n \n ```sql\n SELECT *\n FROM mindsdb_instatus.status_pages\n WHERE id = '<status-page-id>';\n ```\n \n-Example 4: Apply limit\n-\n-```sql\n-SELECT *\n-FROM mindsdb_instatus.status_pages\n-LIMIT 10;\n-```\n-\n-### Create a status page\n-\n-```sql\n-INSERT INTO mindsdb_instatus.status_pages (column1, column2, column3, ...)\n-VALUES (value1, value2, value3, ...);\n-```\n-\n-Example:\n+### INSERT\n \n ```sql\n INSERT INTO mindsdb_instatus.status_pages (email, name, subdomain, components, logoUrl, faviconUrl, websiteUrl, language, useLargeHeader, brandColor, okColor, disruptedColor, degradedColor, downColor, noticeColor, unknownColor, googleAnalytics, subscribeBySms, smsService, twilioSid, twilioToken, twilioSender, nexmoKey, nexmoSecret, nexmoSender, htmlInMeta, htmlAboveHeader, htmlBelowHeader, htmlAboveFooter, htmlBelowFooter, htmlBelowSummary, cssGlobal, launchDate, dateFormat, dateFormatShort, timeFormat)\n@@ -88,15 +103,7 @@ Note:\n - `components` is required field (Example: '[\"Website\", \"App\", \"API\"]')\n - other fields are optional\n \n-### Update a status page\n-\n-```sql\n-UPDATE mindsdb_instatus.status_pages\n-SET column1 = value1, column2 = value2, ...\n-WHERE id = '<status-page-id>';\n-```\n-\n-Example:\n+### UPDATE\n \n ```sql\n UPDATE mindsdb_instatus.status_pages\n@@ -145,3 +152,56 @@ SET name = 'mindsdb',\n     }'\n WHERE id = '<status-page-id>';\n ```\n+\n+## Usage (Components table)\n+\n+### SELECT\n+\n+```sql\n+SELECT *\n+FROM mindsdb_instatus.components\n+WHERE page_id = '<status-page-id>';\n+```\n+\n+### WHERE\n+\n+```sql\n+SELECT *\n+FROM mindsdb_instatus.components\n+WHERE page_id = '<status-page-id>'\n+AND component_id = '<component-id>';\n+```\n+\n+### CREATE\n+\n+```sql\n+INSERT INTO mindsdb_instatus.components (page_id, name, description, status, order, showUptime, grouped, translations_name_in_fr, translations_desc_in_fr)\n+VALUES (\n+  '<page-id>',\n+  'Test component',\n+  'Testing',\n+  'OPERATIONAL',\n+  6,\n+  true,\n+  false,\n+  \"Composant de test\",\n+  \"En test\"\n+);\n+```\n+\n+### UPDATE\n+\n+```sql\n+UPDATE mindsdb_instatus.components\n+SET\n+  name = 'Test component 4',\n+  description = 'Test test test',\n+  status = 'OPERATIONAL',\n+  order = 6,\n+  showUptime = true,\n+  grouped = false,\n+  translations_name_in_fr = \"Composant de test 4\",\n+  translations_desc_in_fr = \"Test test test\"\n+WHERE page_id = '<status-page-id>'\n+AND component_id = '<component-id>';\n+```"
        },
        {
          "filename": "mindsdb/integrations/handlers/instatus_handler/instatus_handler.py",
          "status": "modified",
          "additions": 5,
          "deletions": 9,
          "patch": "@@ -1,4 +1,4 @@\n-from mindsdb.integrations.handlers.instatus_handler.instatus_tables import StatusPages\n+from mindsdb.integrations.handlers.instatus_handler.instatus_tables import StatusPages, Components\n from mindsdb.integrations.libs.api_handler import APIHandler\n from mindsdb.integrations.libs.response import HandlerStatusResponse as StatusResponse\n from mindsdb.utilities import log\n@@ -31,6 +31,7 @@ def __init__(self, name: str, **kwargs) -> None:\n \n         _tables = [\n             StatusPages,\n+            Components\n         ]\n \n         for Table in _tables:\n@@ -91,7 +92,7 @@ def native_query(self, query: str) -> StatusResponse:\n         ast = parse_sql(query, dialect=\"mindsdb\")\n         return self.query(ast)\n \n-    def call_instatus_api(self, endpoint: str, method: str = 'GET', params: dict = None, data=None) -> pd.DataFrame:\n+    def call_instatus_api(self, endpoint: str, method: str = 'GET', params: dict = None, json_data: dict = {}) -> pd.DataFrame:\n         if not params:\n             params = {}\n \n@@ -101,16 +102,11 @@ def call_instatus_api(self, endpoint: str, method: str = 'GET', params: dict = N\n         if method.upper() in ('GET', 'POST', 'PUT', 'DELETE'):\n             headers['Content-Type'] = 'application/json'\n \n-            if method.upper() in ('POST', 'PUT', 'DELETE'):\n-                response = requests.request(method, url, headers=headers, params=params, data=data)\n-            else:\n-                response = requests.get(url, headers=headers, params=params)\n+            response = requests.request(method, url, headers=headers, params=params, json=json_data)\n \n             if response.status_code == 200:\n                 data = response.json()\n-                return pd.DataFrame(data) if isinstance(data, list) else pd.DataFrame({\n-                    'data': data\n-                })\n+                return pd.DataFrame(data) if isinstance(data, list) else pd.DataFrame([data])\n             else:\n                 raise Exception(f\"Error connecting to Instatus API: {response.status_code} - {response.text}\")\n "
        },
        {
          "filename": "mindsdb/integrations/handlers/instatus_handler/instatus_tables.py",
          "status": "modified",
          "additions": 231,
          "deletions": 7,
          "patch": "@@ -5,6 +5,11 @@\n from mindsdb.integrations.utilities.sql_utils import extract_comparison_conditions\n from mindsdb_sql.parser.ast.select.constant import Constant\n import json\n+import re\n+\n+langCodes = [\"ar\", \"cs\", \"da\", \"de\", \"en\", \"es\", \"et\", \"fi\", \"fr\", \"hu\", \"id\", \"it\", \"ja\", \"ko\",\n+             \"nl\", \"no\", \"pl\", \"pt\", \"pt-BR\", \"ro\", \"rs\", \"ru\", \"sl\", \"sq\", \"sv\", \"tr\", \"uk\",\n+             \"vi\", \"zh\", \"zh-TW\"]\n \n \n class StatusPages(APITable):\n@@ -87,11 +92,16 @@ def insert(self, query: ast.Insert) -> None:\n         \"\"\"\n         data = {}\n         for column, value in zip(query.columns, query.values[0]):\n-            if isinstance(value, Constant):\n-                data[column.name] = value.value\n-            else:\n-                data[column.name] = value\n-        self.handler.call_instatus_api(endpoint='/v1/pages', method='POST', data=json.dumps(data))\n+            if isinstance(value, str):\n+                try:\n+                    value = json.loads(value)\n+                except json.JSONDecodeError:\n+                    if value == 'True':\n+                        value = True\n+                    elif value == 'False':\n+                        value = False\n+            data[column.name] = value\n+        self.handler.call_instatus_api(endpoint='/v1/pages', method='POST', json_data=data)\n \n     def update(self, query: ast.Update) -> None:\n         \"\"\"Receive query as AST (abstract syntax tree) and act upon it somehow.\n@@ -114,10 +124,14 @@ def update(self, query: ast.Update) -> None:\n         for key, value in query.update_columns.items():\n             if isinstance(value, Constant):\n                 if key == 'components':\n-                    data[key] = json.loads(value.value)  # Convert 'components' value to a Python list\n+                    data[key] = json.loads(value.value)\n                 else:\n                     data[key] = value.value\n-        self.handler.call_instatus_api(endpoint=f'/v2/{_id}', method='PUT', data=json.dumps(data))\n+\n+        if 'components' in data and isinstance(data['components'], str):\n+            data['components'] = json.loads(data['components'])\n+\n+        self.handler.call_instatus_api(endpoint=f'/v2/{_id}', method='PUT', json_data=data)\n \n     def get_columns(self, ignore: List[str] = []) -> List[str]:\n         \"\"\"columns\n@@ -167,3 +181,213 @@ def get_columns(self, ignore: List[str] = []) -> List[str]:\n             \"createdAt\",\n             \"updatedAt\"\n         ]\n+\n+\n+class Components(APITable):\n+\n+    # table name in the database\n+    name = 'components'\n+\n+    def select(self, query: ast.Select) -> pd.DataFrame:\n+        \"\"\"Receive query as AST (abstract syntax tree) and act upon it.\n+\n+        Args:\n+            query (ASTNode): SQL query represented as AST. Usually it should be ast.Select\n+\n+        Returns:\n+            pd.DataFrame\n+        \"\"\"\n+        conditions = extract_comparison_conditions(query.where)\n+\n+        if len(conditions) == 0:\n+            raise Exception('WHERE clause is required')\n+\n+        # Get page id and component id from query\n+        pageId = None\n+        componentId = None\n+        for condition in conditions:\n+            if condition[1] == 'page_id' and condition[0] == '=':\n+                pageId = condition[2]\n+\n+            if condition[1] == 'component_id' and condition[0] == '=':\n+                componentId = condition[2]\n+\n+        # Get column names from query\n+        selected_columns = []\n+        for target in query.targets:\n+            if isinstance(target, ast.Star):\n+                selected_columns = self.get_columns()\n+                break\n+            elif isinstance(target, ast.Identifier):\n+                selected_columns.append(target.parts[-1])\n+            else:\n+                raise ValueError(f\"Unknown query target {type(target)}\")\n+\n+        limit = query.limit.value if query.limit else None\n+        if componentId:\n+            # Call instatus API and get the response as pd.DataFrame\n+            df = self.handler.call_instatus_api(endpoint=f'/v1/{pageId}/components/{componentId}')\n+            for langCode in langCodes:\n+                try:\n+                    df[f\"translations_name_in_{langCode}\"] = df[\"translations\"].apply(lambda x: x.get(\"name\", None)).apply(lambda x: x.get(langCode, None))\n+                    df[f\"translations_desc_in_{langCode}\"] = df[\"translations\"].apply(lambda x: x.get(\"description\", None)).apply(lambda x: x.get(langCode, None))\n+                except AttributeError:\n+                    df[f\"translations_name_in_{langCode}\"] = None\n+                    df[f\"translations_desc_in_{langCode}\"] = None\n+            df = df.drop(columns=[\"translations\"])\n+\n+            result_df = df[selected_columns]\n+        else:\n+            # Call instatus API and get the response as pd.DataFrame\n+            page_size = 100\n+            # Calculate the number of pages required\n+            page_count = (limit + page_size - 1) // page_size if limit else 1\n+            result_df = pd.DataFrame(columns=selected_columns)\n+\n+            # Call instatus API and get the response as pd.DataFrame for each page\n+            for page in range(1, page_count + 1):\n+                current_page_size = min(page_size, limit) if limit else page_size\n+\n+                df = self.handler.call_instatus_api(endpoint=f'/v1/{pageId}/components', params={'page': page, 'per_page': current_page_size})\n+                # Break if no more data is available or limit is reached\n+                if len(df) == 0 or (limit and limit <= 0) or limit == 0:\n+                    break\n+                ''' Add translations_name_in_{langCode} and translations_desc_in_{langCode} columns to the dataframe'''\n+                for i in range(len(df)):\n+                    for langCode in langCodes:\n+                        try:\n+                            df.at[i, f\"translations_name_in_{langCode}\"] = df.at[i, \"translations\"].get(\"name\", {}).get(langCode, None)\n+                            df.at[i, f\"translations_desc_in_{langCode}\"] = df.at[i, \"translations\"].get(\"description\", {}).get(langCode, None)\n+                        except AttributeError:\n+                            df.at[i, f\"translations_name_in_{langCode}\"] = None\n+                            df.at[i, f\"translations_desc_in_{langCode}\"] = None\n+\n+                # Drop the 'translations' column\n+                df = df.drop(columns=[\"translations\"])\n+                # Concatenate the dataframes\n+                result_df = pd.concat([result_df, df[selected_columns]], ignore_index=True)\n+\n+                if limit:\n+                    limit -= len(df)\n+\n+        return result_df\n+\n+    def insert(self, query: ast.Insert) -> None:\n+        \"\"\"Receive query as AST (abstract syntax tree) and act upon it somehow.\n+\n+        Args:\n+            query (ASTNode): sql query represented as AST. Usually it should be ast.Insert\n+\n+        Returns:\n+            None\n+        \"\"\"\n+        data = {'translations': {\n+            \"name\": {},\n+            \"description\": {}\n+        }}\n+\n+        for column, value in zip(query.columns, query.values[0]):\n+            if isinstance(value, Constant):\n+                data[column.name] = json.loads(value.value) if column.name == 'translations' else value.value\n+            elif isinstance(value, str):\n+                try:\n+                    if re.match(r'^translations_name_in_[a-zA-Z\\-]+$', column.name):\n+                        lang_code = column.name.split('_')[-1]\n+                        if lang_code not in langCodes:\n+                            raise Exception(f'Invalid language code {lang_code}')\n+                        data['translations']['name'][lang_code] = value\n+                    elif re.match(r'^translations_desc_in_[a-zA-Z\\-]+$', column.name):\n+                        lang_code = column.name.split('_')[-1]\n+                        if lang_code not in langCodes:\n+                            raise Exception(f'Invalid language code {lang_code}')\n+                        data['translations']['description'][lang_code] = value\n+                    else:\n+                        data[column.name] = json.loads(value)\n+                except json.JSONDecodeError:\n+                    data[column.name] = True if value == 'True' else (False if value == 'False' else value)\n+\n+        page_id = data.pop('page_id', None)\n+\n+        if page_id is not None:\n+            self.handler.call_instatus_api(endpoint=f'/v1/{page_id}/components', method='POST', json_data=data)\n+\n+    def update(self, query: ast.Update) -> None:\n+        \"\"\"Receive query as AST (abstract syntax tree) and act upon it somehow.\n+\n+        Args:\n+            query (ASTNode): sql query represented as AST. Usually it should be ast.Update\n+        Returns:\n+            None\n+        \"\"\"\n+        conditions = extract_comparison_conditions(query.where)\n+        # Get page id and component id from query\n+        pageId = None\n+        componentId = None\n+        for condition in conditions:\n+            if condition[1] == 'page_id' and condition[0] == '=':\n+                pageId = condition[2]\n+            elif condition[1] == 'component_id' and condition[0] == '=':\n+                componentId = condition[2]\n+            else:\n+                raise Exception(\"page_id and component_id both are required\")\n+\n+        data = {'translations': {\n+            \"name\": {},\n+            \"description\": {}\n+        }}\n+        for key, value in query.update_columns.items():\n+            if isinstance(value, Constant):\n+                if re.match(r'^translations_name_in_[a-zA-Z\\-]+$', key):\n+                    lang_code = key.split('_')[-1]\n+                    if lang_code not in langCodes:\n+                        raise Exception(f'Invalid language code {lang_code}')\n+                    data['translations']['name'][lang_code] = value.value\n+                elif re.match(r'^translations_desc_in_[a-zA-Z\\-]+$', key):\n+                    lang_code = key.split('_')[-1]\n+                    if lang_code not in langCodes:\n+                        raise Exception(f'Invalid language code {lang_code}')\n+                    data['translations']['description'][lang_code] = value.value\n+                else:\n+                    data[key] = value.value\n+        self.handler.call_instatus_api(endpoint=f'/v1/{pageId}/components/{componentId}', method='PUT', json_data=data)\n+\n+    def get_columns(self, ignore: List[str] = []) -> List[str]:\n+        \"\"\"columns\n+\n+        Args:\n+            ignore (List[str], optional): exclusion items. Defaults to [].\n+\n+        Returns:\n+            List[str]: available columns with `ignore` items removed from the list.\n+        \"\"\"\n+        return [\n+            \"id\",\n+            \"name\",\n+            \"nameTranslationId\",\n+            \"description\",\n+            \"descriptionTranslationId\",\n+            \"status\",\n+            \"order\",\n+            \"showUptime\",\n+            \"createdAt\",\n+            \"updatedAt\",\n+            \"archivedAt\",\n+            \"siteId\",\n+            \"uniqueEmail\",\n+            \"oldGroup\",\n+            \"groupId\",\n+            \"isParent\",\n+            \"isCollapsed\",\n+            \"monitorId\",\n+            \"nameHtml\",\n+            \"nameHtmlTranslationId\",\n+            \"descriptionHtml\",\n+            \"descriptionHtmlTranslationId\",\n+            \"isThirdParty\",\n+            \"thirdPartyStatus\",\n+            \"thirdPartyComponentId\",\n+            \"thirdPartyComponentServiceId\",\n+            \"importedFromStatuspage\",\n+            \"startDate\",\n+            \"group\",\n+        ] + [f'translations_name_in_{langCode}' for langCode in langCodes] + [f'translations_desc_in_{langCode}' for langCode in langCodes]"
        },
        {
          "filename": "mindsdb/integrations/handlers/langchain_embedding_handler/requirements.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,2 +1,2 @@\n-openai == 0.28.1\n+openai == 1.6.1\n tiktoken~=0.4.0"
        },
        {
          "filename": "mindsdb/integrations/handlers/langchain_handler/langchain_handler.py",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -184,6 +184,7 @@ def _get_chat_model_params(self, args, pred_args):\n             model_kwargs['best_of'] = pred_args.get('best_of', None)\n             model_kwargs['logit_bias'] = pred_args.get('logit_bias', None)\n             model_kwargs['openai_api_key'] = get_api_key('openai', args, self.engine_storage)\n+            model_kwargs['openai_organization'] = args.get('api_organization', None)\n \n         model_kwargs = {k: v for k, v in model_kwargs.items() if v is not None}  # filter out None values\n         return model_kwargs\n@@ -418,9 +419,9 @@ def finetune(self, df: Optional[pd.DataFrame] = None, args: Optional[Dict] = Non\n     def sql_agent_completion(self, df, args=None, pred_args=None):\n         \"\"\"This completion will be used to answer based on information passed by any MindsDB DB or API engine.\"\"\"\n         db = MindsDBSQL(engine=args['executor'], metadata=args['executor'].session.integration_controller)\n-        toolkit = SQLDatabaseToolkit(db=db)\n         model_name = args.get('model_name', self.default_model)\n-        llm = OpenAI(temperature=0) if model_name not in OPEN_AI_CHAT_MODELS else ChatOpenAI(temperature=0)\n+        llm = OpenAI(temperature=0) if model_name not in OPEN_AI_CHAT_MODELS else self._create_chat_model(args, pred_args)  # noqa\n+        toolkit = SQLDatabaseToolkit(db=db, llm=llm)\n         agent = create_sql_agent(\n             llm=llm,\n             toolkit=toolkit,"
        },
        {
          "filename": "mindsdb/integrations/handlers/langchain_handler/requirements.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,4 +1,4 @@\n-openai == 0.28.1\n+openai == 1.6.1\n wikipedia==1.4.0\n tiktoken >= 0.3.0\n anthropic==0.3.5"
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/README.md",
          "status": "modified",
          "additions": 51,
          "deletions": 1,
          "patch": "@@ -8,7 +8,8 @@ LlamaIndex is a data framework for your LLM application. In this handler, we use\n - [x] LlamaIndex ML Handler\n   - [x] [Support Web Page Reader](https://gpt-index.readthedocs.io/en/latest/examples/data_connectors/WebPageDemo.html)\n   - [x] [Support Database Reader](https://gpt-index.readthedocs.io/en/latest/examples/data_connectors/DatabaseReaderDemo.html)\n-\n+  - [x] [Support Github Reader](https://llamahub.ai/l/youtube_transcript?from=loaders)\n+  - [x] [Support YoutubeTranscript Reader](https://llamahub.ai/l/youtube_transcript?from=loaders) **Note: To run YoutubeLoader `pip install youtube_transcript_api`**\n \n \n ## Example Usage\n@@ -56,3 +57,52 @@ JOIN files.question_table as t;\n ~~~~\n \n ![](https://i.ibb.co/WPgXJDs/Screenshot-2023-05-30-at-7-54-32-PM.png)\n+\n+## Example usage for GithubLoader\n+```sql\n+CREATE MODEL github_loader\n+PREDICT answer\n+USING \n+  engine = 'llama_index', \n+  index_class = 'VectorStoreIndex',\n+  owner = 'mindsdb',\n+  repo = 'mindsdb',\n+  branch = 'staging',\n+  reader = 'GithubRepositoryReader',\n+  filter_type = 'include',\n+  filter_file_extensions = ['.py','.html','.md'],\n+  input_column = 'questions',\n+  openai_api_key = '<your_openai_key>',\n+  github_token = '<your_github_token>';\n+```\n+\n+```sql\n+SELECT a.questions, b.answer\n+FROM github_loader as b\n+JOIN files.questions as a\n+```\n+\n+```sql\n+SELECT question, answer\n+FROM github_loader\n+WHERE questions = 'Explain steps to setup MindsDB on local machine?'\n+```\n+\n+## Example usage for YoutubeTranscriptLoader\n+```sql\n+CREATE MODEL youtube_loader\n+PREDICT answer\n+USING \n+  engine = 'llama_index', \n+  index_class = 'VectorStoreIndex',\n+  ytlinks = ['<link_of_youtube_videos>'],\n+  reader = 'YoutubeTranscriptReader',\n+  input_column = 'questions',\n+  openai_api_key = '<your_openai_key>';\n+```\n+\n+```sql\n+SELECT question, answer\n+FROM youtube_loader\n+WHERE questions = 'What was the video about?'\n+```\n\\ No newline at end of file"
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/__about__.py",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -1,9 +1,9 @@\n-__title__ = 'MindsDB LlamaIndex  handler'\n-__package_name__ = 'mindsdb_llama_index_handler'\n-__version__ = '0.0.1'\n+__title__ = \"MindsDB LlamaIndex  handler\"\n+__package_name__ = \"mindsdb_llama_index_handler\"\n+__version__ = \"0.0.1\"\n __description__ = \"MindsDB handler for LlamaIndex\"\n-__author__ = 'Balaji Seetharaman '\n-__github__ = 'https://github.com/mindsdb/mindsdb'\n-__pypi__ = 'https://pypi.org/project/mindsdb/'\n-__license__ = 'MIT'\n-__copyright__ = 'Copyright 2023 - mindsdb'\n+__author__ = \"Balaji Seetharaman \"\n+__github__ = \"https://github.com/mindsdb/mindsdb\"\n+__pypi__ = \"https://pypi.org/project/mindsdb/\"\n+__license__ = \"MIT\"\n+__copyright__ = \"Copyright 2023 - mindsdb\""
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/__init__.py",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -1,18 +1,18 @@\n from mindsdb.integrations.libs.const import HANDLER_TYPE\n \n from .__about__ import __version__ as version, __description__ as description\n+\n try:\n-    from .llama_index_handler import  LlamaIndexHandler as Handler\n+    from .llama_index_handler import LlamaIndexHandler as Handler\n+\n     import_error = None\n except Exception as e:\n     Handler = None\n     import_error = e\n \n-title = 'LlamaIndex'\n-name = 'llama_index'\n+title = \"LlamaIndex\"\n+name = \"llama_index\"\n type = HANDLER_TYPE.ML\n permanent = True\n \n-__all__ = [\n-    'Handler', 'version', 'name', 'type', 'title', 'description', 'import_error'\n-]\n+__all__ = [\"Handler\", \"version\", \"name\", \"type\", \"title\", \"description\", \"import_error\"]"
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/config.py",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+# this dict is used to configure the data loader and match one on one arguments passed by the user in args\n+data_loaders = {\n+    \"DFReader\": {\n+        # TODO: add parameter of DFReader\n+    },\n+    \"SimpleWebPageReader\": {\n+        \"source_url_link\": \"<url>\",\n+    },\n+    \"GithubRepositoryReader\": {\n+        \"owner\": \"<owner>\",\n+        \"repo\": \"<repository>\",\n+        \"github_token\": \"<github_token>\",\n+        \"branch\": \"<branch>\",\n+    },\n+    \"YoutubeTranscriptReader\": {\n+        \"ytlinks\": [\"<youtube_link>\"],\n+    },\n+}"
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/github_loader_helper.py",
          "status": "added",
          "additions": 65,
          "deletions": 0,
          "patch": "@@ -0,0 +1,65 @@\n+import os\n+from llama_hub.github_repo import GithubRepositoryReader\n+\n+\n+def _get_github_token(args, connection_args):\n+    \"\"\"\n+    API_KEY preference order:\n+        1. provided at model creation\n+        2. provided at engine creation\n+        3. GITHUB_TOKEN env variable\n+\n+    Note: method is not case-sensitive.\n+    \"\"\"\n+    key = \"GITHUB_TOKEN\"\n+    for k in key, key.lower():\n+        if args.get(k):\n+            return args[k]\n+\n+        connection_args = connection_args\n+        if connection_args.get(k):\n+            return connection_args[k]\n+\n+        api_key = os.getenv(k)\n+        if os.environ.get(k):\n+            return api_key\n+\n+    return None\n+\n+\n+def _get_filter_file_extensions(args):\n+    \"\"\"\n+    Returns file extensions to filter, if Filter type is EXCLUDE the file extensions will be excluded\n+    from the knowledge source, if Filter type is INCLUDE the file extensions will be included in the\n+    knowledge source.\n+    \"\"\"\n+    # filter_file_extensions is not provided\n+    if \"filter_file_extensions\" not in args:\n+        return None\n+\n+    # if filter_type is provided with EXCLUDE or INCLUDE\n+    if args[\"filter_file_extensions\"] and args[\"filter_type\"].upper() == \"INCLUDE\":\n+        filter_file_extensions = args[\"filter_file_extensions\"]\n+        return (filter_file_extensions, GithubRepositoryReader.FilterType.INCLUDE)\n+    else:\n+        filter_file_extensions = args[\"filter_file_extensions\"]\n+        return (filter_file_extensions, GithubRepositoryReader.FilterType.EXCLUDE)\n+\n+\n+def _get_filter_directories(args):\n+    \"\"\"\n+    Returns directories to filter, if Filter type is EXCLUDE the directories will be excluded\n+    from the knowledge source, if Filter type is INCLUDE the directories will be included in the\n+    knowledge source.\n+    \"\"\"\n+    # filter_directories is not provided\n+    if \"filter_directories\" not in args:\n+        return None\n+\n+    # if filter_type is provided with EXCLUDE or INCLUDE\n+    if args[\"filter_directories\"] and args[\"filter_type\"].upper() == \"INCLUDE\":\n+        filter_directories = args[\"filter_directories\"]\n+        return (filter_directories, GithubRepositoryReader.FilterType.INCLUDE)\n+    else:\n+        filter_directories = args[\"filter_directories\"]\n+        return (filter_directories, GithubRepositoryReader.FilterType.EXCLUDE)"
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/llama_index_handler.py",
          "status": "modified",
          "additions": 211,
          "deletions": 136,
          "patch": "@@ -3,229 +3,304 @@\n \n import openai\n import pandas as pd\n-from langchain.llms import OpenAI\n import llama_index\n+\n+from langchain.llms import OpenAI\n from llama_index.readers.schema.base import Document\n-from llama_index import SimpleWebPageReader, QuestionAnswerPrompt\n+from llama_index.readers import SimpleWebPageReader\n+from llama_index.prompts import PromptTemplate\n from llama_index import ServiceContext, StorageContext, load_index_from_storage\n from llama_index import LLMPredictor, OpenAIEmbedding\n from llama_index.indices.vector_store.base import VectorStore\n \n+from llama_hub.github_repo import GithubClient, GithubRepositoryReader\n+from llama_hub.youtube_transcript import YoutubeTranscriptReader, is_youtube_video\n+\n from mindsdb.integrations.libs.base import BaseMLEngine\n from mindsdb.utilities.config import Config\n from mindsdb.utilities.security import is_private_url\n+from mindsdb.integrations.handlers.llama_index_handler import config\n+from mindsdb.integrations.handlers.llama_index_handler.github_loader_helper import (\n+    _get_github_token,\n+    _get_filter_file_extensions,\n+    _get_filter_directories,\n+)\n+from mindsdb.integrations.utilities.handler_utils import get_api_key\n \n \n def _validate_prompt_template(prompt_template: str):\n-    if '{context_str}' not in prompt_template or '{query_str}' not in prompt_template:\n+    if \"{context_str}\" not in prompt_template or \"{query_str}\" not in prompt_template:\n         raise Exception(\n-            \"Provided prompt template is invalid, missing `{context_str}`, `{query_str}`. Please ensure both placeholders are present and try again.\")  # noqa\n+            \"Provided prompt template is invalid, missing `{context_str}`, `{query_str}`. Please ensure both placeholders are present and try again.\"\n+        )  # noqa\n \n \n class LlamaIndexHandler(BaseMLEngine):\n-    \"\"\" Integration with the LlamaIndex data framework for LLM applications. \"\"\"\n-    name = 'llama_index'\n+    \"\"\"Integration with the LlamaIndex data framework for LLM applications.\"\"\"\n+\n+    name = \"llama_index\"\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n         self.generative = True\n-        self.default_index_class = 'GPTVectorStoreIndex'\n-        self.supported_index_class = ['GPTVectorStoreIndex']\n-        self.default_reader = 'DFReader'\n-        self.supported_reader = ['DFReader', 'SimpleWebPageReader']\n+        self.default_index_class = \"GPTVectorStoreIndex\"\n+        self.supported_index_class = [\"GPTVectorStoreIndex\", \"VectorStoreIndex\"]\n+        self.default_reader = \"DFReader\"\n+        self.supported_reader = [\n+            \"DFReader\",\n+            \"SimpleWebPageReader\",\n+            \"GithubRepositoryReader\",\n+            \"YoutubeTranscriptReader\",\n+        ]\n \n     @staticmethod\n     def create_validation(target, args=None, **kwargs):\n-        if 'prompt_template' in args['using']:\n-            _validate_prompt_template(args['using']['prompt_template'])\n-\n-        if args['using'].get('mode') == 'conversational':\n-            for param in ('user_column', 'assistant_column'):\n-                if param not in args['using']:\n-                    raise Exception(f'Conversational mode requires {param} parameter')\n-\n-    def create(self, target: str, df: Optional[pd.DataFrame] = None, args: Optional[Dict] = None) -> None:\n-        if 'using' not in args:\n-            raise Exception(\"LlamaIndex engine requires a USING clause! Refer to its documentation for more details.\")\n-\n-        if 'index_class' not in args['using']:\n-            args['using']['index_class'] = self.default_index_class\n-        elif args['using']['index_class'] not in self.supported_index_class:\n-            raise Exception(f\"Invalid index class argument. Please use one of {self.supported_index_class}\")\n-\n-        if 'reader' not in args['using']:\n-            args['using']['reader'] = self.default_reader\n-        elif args['using']['reader'] not in self.supported_reader:\n-            raise Exception(f\"Invalid operation mode. Please use one of {self.supported_reader}\")\n+        reader = args[\"using\"].get(\"reader\", None)\n+        if reader not in config.data_loaders:\n+            raise Exception(\n+                f\"Invalid reader argument. Please use one of {config.data_loaders.keys()}\"\n+            )\n+        config_dict = config.data_loaders[reader]\n+\n+        missing_keys = [key for key in config_dict if key not in args[\"using\"]]\n+        if missing_keys:\n+            raise Exception(f\"{reader} requires {missing_keys} arguments\")\n+\n+        if \"prompt_template\" in args[\"using\"]:\n+            _validate_prompt_template(args[\"using\"][\"prompt_template\"])\n+\n+        if args[\"using\"].get(\"mode\") == \"conversational\":\n+            for param in (\"user_column\", \"assistant_column\"):\n+                if param not in args[\"using\"]:\n+                    raise Exception(f\"Conversational mode requires {param} parameter\")\n+\n+    def create(\n+        self,\n+        target: str,\n+        df: Optional[pd.DataFrame] = None,\n+        args: Optional[Dict] = None,\n+    ) -> None:\n+        if \"using\" not in args:\n+            raise Exception(\n+                \"LlamaIndex engine requires a USING clause! Refer to its documentation for more details.\"\n+            )\n+\n+        if \"index_class\" not in args[\"using\"]:\n+            args[\"using\"][\"index_class\"] = self.default_index_class\n+        elif args[\"using\"][\"index_class\"] not in self.supported_index_class:\n+            raise Exception(\n+                f\"Invalid index class argument. Please use one of {self.supported_index_class}\"\n+            )\n+\n+        if \"reader\" not in args[\"using\"]:\n+            args[\"using\"][\"reader\"] = self.default_reader\n+        elif args[\"using\"][\"reader\"] not in self.supported_reader:\n+            raise Exception(\n+                f\"Invalid operation mode. Please use one of {self.supported_reader}\"\n+            )\n \n         # workaround to create llama model without input data\n         if df is None or df.empty:\n-            df = pd.DataFrame([{'text': ''}])\n-\n-        if args['using']['reader'] == 'DFReader':\n-            dstrs = df.apply(lambda x: ', '.join([f'{col}: {str(entry)}' for col, entry in zip(df.columns, x)]), axis=1)\n+            df = pd.DataFrame([{\"text\": \"\"}])\n+\n+        if args[\"using\"][\"reader\"] == \"DFReader\":\n+            dstrs = df.apply(\n+                lambda x: \", \".join(\n+                    [f\"{col}: {str(entry)}\" for col, entry in zip(df.columns, x)]\n+                ),\n+                axis=1,\n+            )\n             reader = list(map(lambda x: Document(text=x), dstrs.tolist()))\n \n-        elif args['using']['reader'] == 'SimpleWebPageReader':\n-            if 'source_url_link' not in args['using']:\n-                raise Exception(\"SimpleWebPageReader requires a `source_url_link` parameter. Refer to LlamaIndex documentation for more details.\")  # noqa\n-\n-            url = args['using']['source_url_link']\n+        elif args[\"using\"][\"reader\"] == \"SimpleWebPageReader\":\n+            url = args[\"using\"][\"source_url_link\"]\n             config = Config()\n             is_cloud = config.get(\"cloud\", False)\n             if is_cloud and is_private_url(url):\n-                raise Exception(f'URL is private: {url}')\n+                raise Exception(f\"URL is private: {url}\")\n \n             reader = SimpleWebPageReader(html_to_text=True).load_data([url])\n \n+        elif args[\"using\"][\"reader\"] == \"GithubRepositoryReader\":\n+            engine_storage = self.engine_storage\n+\n+            key = \"GITHUB_TOKEN\"\n+            github_token = get_api_key(\n+                key, \"llama_index\", args[\"using\"], engine_storage, strict=False\n+            )\n+            if github_token is None:\n+                github_token = get_api_key(\n+                    key.lower(),\n+                    \"llama_index\",\n+                    args[\"using\"],\n+                    engine_storage,\n+                    strict=True,\n+                )\n+\n+            github_client = GithubClient(github_token)\n+            owner = args[\"using\"][\"owner\"]\n+            repo = args[\"using\"][\"repo\"]\n+            filter_file_extensions = _get_filter_file_extensions(args[\"using\"])\n+            filter_directories = _get_filter_directories(args[\"using\"])\n+\n+            reader = GithubRepositoryReader(\n+                github_client,\n+                owner=owner,\n+                repo=repo,\n+                verbose=True,\n+                filter_file_extensions=filter_file_extensions,\n+                filter_directories=filter_directories,\n+            ).load_data(branch=args[\"using\"].get(\"branch\", \"main\"))\n+\n+        elif args[\"using\"][\"reader\"] == \"YoutubeTranscriptReader\":\n+            ytlinks = args[\"using\"][\"ytlinks\"]\n+            for link in ytlinks:\n+                if not is_youtube_video(link):\n+                    raise Exception(f\"Invalid youtube link: {link}\")\n+            reader = YoutubeTranscriptReader().load_data(ytlinks)\n+\n         else:\n-            raise Exception(f\"Invalid operation mode. Please use one of {self.supported_reader}.\")\n+            raise Exception(\n+                f\"Invalid operation mode. Please use one of {self.supported_reader}.\"\n+            )\n \n-        self.model_storage.json_set('args', args)\n+        self.model_storage.json_set(\"args\", args)\n         index = self._setup_index(reader)\n-        path = self.model_storage.folder_get('context')\n+        path = self.model_storage.folder_get(\"context\")\n         index.storage_context.persist(persist_dir=path)\n-        self.model_storage.folder_sync('context')\n+        self.model_storage.folder_sync(\"context\")\n \n     def update(self, args) -> None:\n-        prompt_template = args['using'].get('prompt_template', args.get('prompt_template', None))\n+        prompt_template = args[\"using\"].get(\n+            \"prompt_template\", args.get(\"prompt_template\", None)\n+        )\n         if prompt_template is not None:\n             _validate_prompt_template(prompt_template)\n-        args_cur = self.model_storage.json_get('args')\n-        args_cur['using'].update(args['using'])\n+        args_cur = self.model_storage.json_get(\"args\")\n+        args_cur[\"using\"].update(args[\"using\"])\n \n         # check new set of arguments\n         self.create_validation(None, args_cur)\n \n-        self.model_storage.json_set('args', args_cur)\n+        self.model_storage.json_set(\"args\", args_cur)\n \n-    def predict(self, df: Optional[pd.DataFrame] = None, args: Optional[Dict] = None) -> pd.DataFrame:\n-        pred_args = args['predict_params'] if args else {}\n+    def predict(\n+        self, df: Optional[pd.DataFrame] = None, args: Optional[Dict] = None\n+    ) -> pd.DataFrame:\n+        pred_args = args[\"predict_params\"] if args else {}\n \n-        args = self.model_storage.json_get('args')\n+        args = self.model_storage.json_get(\"args\")\n         engine_kwargs = {}\n \n-        if args['using'].get('mode') == 'conversational':\n-            user_column = args['using']['user_column']\n-            assistant_column = args['using']['assistant_column']\n+        if args[\"using\"].get(\"mode\") == \"conversational\":\n+            user_column = args[\"using\"][\"user_column\"]\n+            assistant_column = args[\"using\"][\"assistant_column\"]\n \n             messages = []\n-            for row in df[:-1].to_dict('records'):\n+            for row in df[:-1].to_dict(\"records\"):\n+                messages.append(f\"user: {row[user_column]}\")\n+                messages.append(f\"assistant: {row[assistant_column]}\")\n \n-                messages.append(f'user: {row[user_column]}')\n-                messages.append(f'assistant: {row[assistant_column]}')\n+            conversation = \"\\n\".join(messages)\n \n-            conversation = '\\n'.join(messages)\n+            questions = [df.iloc[-1][user_column]]\n \n-            questions = [\n-                df.iloc[-1][user_column]\n-            ]\n-\n-            if 'prompt' in pred_args and pred_args['prompt'] is not None:\n-                user_prompt = pred_args['prompt']\n+            if \"prompt\" in pred_args and pred_args[\"prompt\"] is not None:\n+                user_prompt = pred_args[\"prompt\"]\n             else:\n-                user_prompt = args['using'].get('prompt', '')\n-\n-            prompt_template = f'{user_prompt}\\n'\\\n-                f'---------------------\\n' \\\n-                f'We have provided context information below. \\n' \\\n-                f'{{context_str}}\\n' \\\n-                f'---------------------\\n' \\\n-                f'This is previous conversation history:\\n' \\\n-                f'{conversation}\\n' \\\n-                f'---------------------\\n' \\\n-                f'Given this information, please answer the question: {{query_str}}'\n-\n-            engine_kwargs['text_qa_template'] = QuestionAnswerPrompt(prompt_template)\n+                user_prompt = args[\"using\"].get(\"prompt\", \"\")\n+\n+            prompt_template = (\n+                f\"{user_prompt}\\n\"\n+                f\"---------------------\\n\"\n+                f\"We have provided context information below. \\n\"\n+                f\"{{context_str}}\\n\"\n+                f\"---------------------\\n\"\n+                f\"This is previous conversation history:\\n\"\n+                f\"{conversation}\\n\"\n+                f\"---------------------\\n\"\n+                f\"Given this information, please answer the question: {{query_str}}\"\n+            )\n+\n+            engine_kwargs[\"text_qa_template\"] = PromptTemplate(prompt_template)\n \n         else:\n-            input_column = args['using'].get('input_column', None)\n+            input_column = args[\"using\"].get(\"input_column\", None)\n \n-            prompt_template = args['using'].get('prompt_template', args.get('prompt_template', None))\n+            prompt_template = args[\"using\"].get(\n+                \"prompt_template\", args.get(\"prompt_template\", None)\n+            )\n             if prompt_template is not None:\n                 _validate_prompt_template(prompt_template)\n-                engine_kwargs['text_qa_template'] = QuestionAnswerPrompt(prompt_template)\n+                engine_kwargs[\"text_qa_template\"] = PromptTemplate(prompt_template)\n \n             if input_column is None:\n-                raise Exception(f'`input_column` must be provided at model creation time or through USING clause when predicting. Please try again.')  # noqa\n+                raise Exception(\n+                    f\"`input_column` must be provided at model creation time or through USING clause when predicting. Please try again.\"\n+                )  # noqa\n \n             if input_column not in df.columns:\n-                raise Exception(f'Column \"{input_column}\" not found in input data! Please try again.')\n+                raise Exception(\n+                    f'Column \"{input_column}\" not found in input data! Please try again.'\n+                )\n \n             questions = df[input_column]\n \n-        index_path = self.model_storage.folder_get('context')\n+        index_path = self.model_storage.folder_get(\"context\")\n         storage_context = StorageContext.from_defaults(persist_dir=index_path)\n         service_context = self._get_service_context()\n-        index = load_index_from_storage(storage_context, service_context=service_context)\n+        index = load_index_from_storage(\n+            storage_context, service_context=service_context\n+        )\n         query_engine = index.as_query_engine(**engine_kwargs)\n \n         results = []\n \n         for question in questions:\n-            query_results = query_engine.query(question)  # TODO: provide extra_info in explain_target col\n+            query_results = query_engine.query(\n+                question\n+            )  # TODO: provide extra_info in explain_target col\n             results.append(query_results.response)\n \n-        result_df = pd.DataFrame({'question': questions, args['target']: results})  # result_df['answer'].tolist()\n+        result_df = pd.DataFrame(\n+            {\"question\": questions, args[\"target\"]: results}\n+        )  # result_df['answer'].tolist()\n         return result_df\n \n     def _get_service_context(self):\n-        args = self.model_storage.json_get('args')\n-        openai_api_key = self._get_llama_index_api_key(args['using'])\n+        args = self.model_storage.json_get(\"args\")\n+        engine_storage = self.engine_storage\n+\n+        key = \"OPENAI_API_KEY\"\n+        openai_api_key = get_api_key(\n+            key, \"llama_index\", args[\"using\"], engine_storage, strict=False\n+        )\n+        if openai_api_key is None:\n+            openai_api_key = get_api_key(\n+                key.lower(), \"llama_index\", args[\"using\"], engine_storage, strict=True\n+            )\n+\n         openai.api_key = openai_api_key  # TODO: shouldn't have to do this! bug?\n-        llm_kwargs = {\n-            'openai_api_key': openai_api_key\n-        }\n-        if 'temperature' in args['using']:\n-            llm_kwargs['temperature'] = args['using']['temperature']\n-        if 'model_name' in args['using']:\n-            llm_kwargs['model_name'] = args['using']['model_name']\n-        if 'max_tokens' in args['using']:\n-            llm_kwargs['max_tokens'] = args['using']['max_tokens']\n+        llm_kwargs = {\"openai_api_key\": openai_api_key}\n+        if \"temperature\" in args[\"using\"]:\n+            llm_kwargs[\"temperature\"] = args[\"using\"][\"temperature\"]\n+        if \"model_name\" in args[\"using\"]:\n+            llm_kwargs[\"model_name\"] = args[\"using\"][\"model_name\"]\n+        if \"max_tokens\" in args[\"using\"]:\n+            llm_kwargs[\"max_tokens\"] = args[\"using\"][\"max_tokens\"]\n \n         llm = OpenAI(**llm_kwargs)  # TODO: all usual params should go here\n         embed_model = OpenAIEmbedding(openai_api_key=openai_api_key)\n         service_context = ServiceContext.from_defaults(\n-            llm_predictor=LLMPredictor(llm=llm),\n-            embed_model=embed_model\n+            llm_predictor=LLMPredictor(llm=llm), embed_model=embed_model\n         )\n         return service_context\n-    \n+\n     def _setup_index(self, documents):\n-        args = self.model_storage.json_get('args')\n-        indexer: VectorStore = getattr(llama_index, args['using']['index_class'])\n-        index = indexer.from_documents(documents, service_context=self._get_service_context())\n+        args = self.model_storage.json_get(\"args\")\n+        indexer: VectorStore = getattr(llama_index, args[\"using\"][\"index_class\"])\n+        index = indexer.from_documents(\n+            documents, service_context=self._get_service_context()\n+        )\n \n         return index\n-\n-    def _get_llama_index_api_key(self, args, strict=True):\n-        \"\"\"\n-        API_KEY preference order:\n-            1. provided at model creation\n-            2. provided at engine creation\n-            3. OPENAI_API_KEY env variable\n-            4. llama_index.OPENAI_API_KEY setting in config.json\n-\n-        Note: method is not case sensitive.\n-        \"\"\"\n-        key = 'OPENAI_API_KEY'\n-        for k in key, key.lower():\n-            # 1\n-            if args.get(k):\n-                return args[k]\n-            # 2\n-            connection_args = self.engine_storage.get_connection_args()\n-            if k in connection_args:\n-                return connection_args[k]\n-            # 3\n-            api_key = os.getenv(k)\n-            if api_key is not None:\n-                return api_key\n-            # 4\n-            config = Config()\n-            openai_cfg = config.get('llama_index', {})\n-            if k in openai_cfg:\n-                return openai_cfg[k]\n-\n-        if strict:\n-            raise Exception(f'Missing API key \"{k}\". Either re-create this ML_ENGINE specifying the `{k}` parameter, or re-create this model and pass the API key with `USING` syntax.')  # noqa"
        },
        {
          "filename": "mindsdb/integrations/handlers/llama_index_handler/requirements.txt",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1,2 +1,3 @@\n-llama-index==0.8.57\n-openai == 0.28.1\n+llama-index==0.9.23\n+llama-hub==0.0.62\n+openai == 1.6.1"
        },
        {
          "filename": "mindsdb/integrations/handlers/openai_handler/constants.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -9,10 +9,10 @@\n     'gpt-4-1106-preview',\n )\n COMPLETION_MODELS = ('babbage-002', 'davinci-002')\n-FINETUNING_MODELS = ('gpt-3.5-turbo', 'babbage-002', 'davinci-002')\n+FINETUNING_MODELS = ('gpt-3.5-turbo', 'babbage-002', 'davinci-002','gpt-4')\n COMPLETION_LEGACY_BASE_MODELS = ('davinci', 'curie', 'babbage', 'ada')\n \n-FINETUNING_LEGACY_MODELS = COMPLETION_LEGACY_BASE_MODELS\n+FINETUNING_LEGACY_MODELS = FINETUNING_MODELS\n COMPLETION_LEGACY_MODELS = (\n     COMPLETION_LEGACY_BASE_MODELS\n     + tuple(f'text-{model}-001' for model in COMPLETION_LEGACY_BASE_MODELS)"
        },
        {
          "filename": "mindsdb/integrations/handlers/openai_handler/helpers.py",
          "status": "modified",
          "additions": 24,
          "deletions": 23,
          "patch": "@@ -1,22 +1,32 @@\n import os\n-from typing import List, Optional\n+from typing import List\n import random\n import time\n import math\n \n import openai\n+from openai import OpenAI\n+\n import tiktoken\n \n import mindsdb.utilities.profiler as profiler\n from mindsdb.integrations.handlers.openai_handler.constants import OPENAI_API_BASE\n \n \n+class PendingFT(openai.OpenAIError):\n+    message: str\n+    def __init__(self, message) -> None:\n+        super().__init__()\n+        self.message = message\n+\n+\n def retry_with_exponential_backoff(\n     initial_delay: float = 1,\n     hour_budget: float = 0.3,\n     jitter: bool = False,\n     exponential_base: int = 2,\n-    errors: tuple = (openai.error.RateLimitError, openai.error.APIConnectionError),\n+    wait_errors: tuple = (openai.APITimeoutError, openai.APIConnectionError, PendingFT),\n+    status_errors: tuple = (openai.APIStatusError, openai.APIResponseValidationError),\n ):\n     \"\"\"\n     Wrapper to enable optional arguments. It means this decorator always needs to be called with parenthesis:\n@@ -55,20 +65,13 @@ def wrapper(*args, **kwargs):\n             while True:\n                 try:\n                     return func(*args, **kwargs)\n-                except errors as e:\n-                    if e.error is not None:\n-                        if (\n-                            e.error['type'] == 'invalid_request_error'\n-                            and 'Too many parallel completions' in e.error['message']\n-                            or 'Please reduce the length of the messages'\n-                            in e.error['message']\n-                        ):\n-                            raise e  # InvalidRequestError triggers batched mode in the previous call\n-                        if e.error['type'] == 'insufficient_quota':\n-                            raise Exception(\n-                                'API key has exceeded its quota, please try 1) increasing it or 2) using another key.'\n-                            )  # noqa\n \n+                except status_errors as e:\n+                    raise Exception(\n+                        f'Error status {e.status_code} raised by OpenAI API: {e.body.get(\"message\", \"Please refer to `https://platform.openai.com/docs/guides/error-codes` for more information.\")}'   # noqa\n+                    )  # noqa\n+\n+                except wait_errors:\n                     num_retries += 1\n                     if num_retries > max_retries:\n                         raise Exception(\n@@ -78,12 +81,10 @@ def wrapper(*args, **kwargs):\n                     delay *= exponential_base * (1 + jitter * random.random())\n                     time.sleep(delay)\n \n-                except openai.error.OpenAIError as e:\n-                    if e.error is not None and e.error['type'] == 'insufficient_quota':\n-                        raise Exception(\n-                            'API key has exceeded its quota, please try 1) increasing it or 2) using another key.'\n-                        )  # noqa\n-                    raise e\n+                except openai.OpenAIError as e:\n+                    raise Exception(\n+                        f'General {str(e)} error raised by OpenAI. Please refer to `https://platform.openai.com/docs/guides/error-codes` for more information.'    # noqa\n+                    )\n \n                 except Exception as e:\n                     raise e\n@@ -146,6 +147,6 @@ def get_available_models(api_key: str) -> List[str]:\n     \"\"\"\n \n     api_base = os.environ.get('OPENAI_API_BASE', OPENAI_API_BASE)\n-    res = openai.Model.list(api_key=api_key, api_base=api_base)\n+    res = OpenAI(api_key=api_key, base_url=api_base).models.list()\n \n-    return [models[\"id\"] for models in res.data]\n+    return [models.id for models in res.data]"
        },
        {
          "filename": "mindsdb/integrations/handlers/openai_handler/openai_handler.py",
          "status": "modified",
          "additions": 92,
          "deletions": 82,
          "patch": "@@ -8,8 +8,8 @@\n import subprocess\n import concurrent.futures\n from typing import Optional, Dict\n-\n import openai\n+from openai import OpenAI\n import numpy as np\n import pandas as pd\n \n@@ -20,11 +20,12 @@\n     retry_with_exponential_backoff,\n     truncate_msgs_for_token_limit,\n     get_available_models,\n+    PendingFT,\n )\n from mindsdb.integrations.handlers.openai_handler.constants import (\n     CHAT_MODELS,\n     IMAGE_MODELS,\n-    FINETUNING_LEGACY_MODELS,\n+    FINETUNING_MODELS,\n     OPENAI_API_BASE,\n )\n from mindsdb.integrations.utilities.handler_utils import get_api_key\n@@ -55,8 +56,7 @@ def __init__(self, *args, **kwargs):\n         self.max_batch_size = 20\n         self.default_max_tokens = 100\n         self.chat_completion_models = CHAT_MODELS\n-        self.supported_ft_models = FINETUNING_LEGACY_MODELS  # base models compatible with finetuning  # TODO #7387: transition to new endpoint before 4/1/24. Useful reference: Anyscale handler. # noqa\n-        self.ft_cls = openai.FineTune\n+        self.supported_ft_models = FINETUNING_MODELS # base models compatible with finetuning  # TODO #7387: transition to new endpoint before 4/1/24. Useful reference: Anyscale handler. # noqa\n \n     @staticmethod\n     def create_validation(target, args=None, **kwargs):\n@@ -121,6 +121,7 @@ def create_validation(target, args=None, **kwargs):\n                 \"temperature\",\n                 \"api_key\",\n                 \"openai_api_key\",\n+                \"api_organization\",\n             }\n         )\n \n@@ -162,6 +163,13 @@ def predict(self, df: pd.DataFrame, args: Optional[Dict] = None) -> pd.DataFrame\n \n         pred_args = args['predict_params'] if args else {}\n         args = self.model_storage.json_get('args')\n+        args['api_base'] = pred_args.get(\n+                    'api_base',\n+                    args.get(\n+                        'api_base', os.environ.get('OPENAI_API_BASE', OPENAI_API_BASE)\n+                    ))\n+        if pred_args.get('api_organization'):\n+            args['api_organization'] = pred_args['api_organization']\n         df = df.reset_index(drop=True)\n \n         if pred_args.get('mode'):\n@@ -259,12 +267,6 @@ def predict(self, df: pd.DataFrame, args: Optional[Dict] = None) -> pd.DataFrame\n                 'best_of': pred_args.get('best_of', None),\n                 'logit_bias': pred_args.get('logit_bias', None),\n                 'user': pred_args.get('user', None),\n-                'api_base': pred_args.get(\n-                    'api_base',\n-                    args.get(\n-                        'api_base', os.environ.get('OPENAI_API_BASE', OPENAI_API_BASE)\n-                    ),\n-                ),  # noqa\n             }\n \n             if (\n@@ -388,11 +390,9 @@ def _completion(\n         \"\"\"\n \n         @retry_with_exponential_backoff()\n-        def _submit_completion(model_name, prompts, api_key, api_args, args, df):\n+        def _submit_completion(model_name, prompts, api_args, args, df):\n             kwargs = {\n                 'model': model_name,\n-                'api_key': api_key,\n-                'organization': args.get('api_organization'),\n             }\n             if model_name in IMAGE_MODELS:\n                 return _submit_image_completion(kwargs, prompts, api_args)\n@@ -420,32 +420,32 @@ def _log_api_call(params, response):\n         def _submit_normal_completion(kwargs, prompts, api_args):\n             def _tidy(comp):\n                 tidy_comps = []\n-                for c in comp['choices']:\n-                    if 'text' in c:\n-                        tidy_comps.append(c['text'].strip('\\n').strip(''))\n+                for c in comp.choices:\n+                    if hasattr(c,'text'):\n+                        tidy_comps.append(c.text.strip('\\n').strip(''))\n                 return tidy_comps\n \n             kwargs['prompt'] = prompts\n             kwargs = {**kwargs, **api_args}\n \n             before_openai_query(kwargs)\n-            resp = _tidy(openai.Completion.create(**kwargs))\n+            resp = _tidy(client.completions.create(**kwargs))\n             _log_api_call(kwargs, resp)\n             return resp\n \n         def _submit_embedding_completion(kwargs, prompts, api_args):\n             def _tidy(comp):\n                 tidy_comps = []\n-                for c in comp['data']:\n-                    if 'embedding' in c:\n-                        tidy_comps.append([c['embedding']])\n+                for c in comp.data:\n+                    if hasattr(c,'embedding'):\n+                        tidy_comps.append([c.embedding])\n                 return tidy_comps\n \n             kwargs['input'] = prompts\n             kwargs = {**kwargs, **api_args}\n \n             before_openai_query(kwargs)\n-            resp = _tidy(openai.Embedding.create(**kwargs))\n+            resp = _tidy(client.embeddings.create(**kwargs))\n             _log_api_call(kwargs, resp)\n             return resp\n \n@@ -454,9 +454,9 @@ def _submit_chat_completion(\n         ):\n             def _tidy(comp):\n                 tidy_comps = []\n-                for c in comp['choices']:\n-                    if 'message' in c:\n-                        tidy_comps.append(c['message']['content'].strip('\\n').strip(''))\n+                for c in comp.choices:\n+                    if hasattr(c,'message'):\n+                        tidy_comps.append(c.message.content.strip('\\n').strip(''))\n                 return tidy_comps\n \n             completions = []\n@@ -496,7 +496,7 @@ def _tidy(comp):\n                     pkwargs = {**kwargs, **api_args}\n \n                     before_openai_query(kwargs)\n-                    resp = _tidy(openai.ChatCompletion.create(**pkwargs))\n+                    resp = _tidy(client.chat.completions.create(**pkwargs))\n                     _log_api_call(pkwargs, resp)\n \n                     completions.extend(resp)\n@@ -505,7 +505,7 @@ def _tidy(comp):\n                     pkwargs = {**kwargs, **api_args}\n \n                     before_openai_query(kwargs)\n-                    resp = _tidy(openai.ChatCompletion.create(**pkwargs))\n+                    resp = _tidy(client.chat.completions.create(**pkwargs))\n                     _log_api_call(pkwargs, resp)\n \n                     completions.extend(resp)\n@@ -536,26 +536,31 @@ def _tidy(comp):\n         def _submit_image_completion(kwargs, prompts, api_args):\n             def _tidy(comp):\n                 return [\n-                    c[0]['url'] if 'url' in c[0].keys() else c[0]['b64_json']\n+                    c.url if hasattr(c,'url')  else c.b64_json\n                     for c in comp\n                 ]\n \n             completions = [\n-                openai.Image.create(**{'prompt': p, **kwargs, **api_args})['data']\n+                client.images.generate(**{'prompt': p, **kwargs, **api_args}).data[0]\n                 for p in prompts\n             ]\n             return _tidy(completions)\n+        \n \n+        client = self._get_client(\n+            api_key=api_key,\n+            base_url=args.get('api_base'),\n+            org=args.pop('api_organization') if 'api_organization' in args else None,\n+            )\n         try:\n             # check if simple completion works\n             completion = _submit_completion(\n-                model_name, prompts, api_key, api_args, args, df\n+                model_name, prompts, api_args, args, df\n             )\n             return completion\n-        except openai.error.InvalidRequestError as e:\n+        except Exception as e:\n             # else, we get the max batch size\n-            e = e.user_message\n-            if 'you can currently request up to at most a total of' in e:\n+            if 'you can currently request up to at most a total of' in str(e):\n                 pattern = 'a total of'\n                 max_batch_size = int(e[e.find(pattern) + len(pattern) :].split(').')[0])\n             else:\n@@ -569,7 +574,6 @@ def _tidy(comp):\n                 partial = _submit_completion(\n                     model_name,\n                     prompts[i * max_batch_size : (i + 1) * max_batch_size],\n-                    api_key,\n                     api_args,\n                     args,\n                     df,\n@@ -591,7 +595,6 @@ def _tidy(comp):\n                         _submit_completion,\n                         model_name,\n                         prompts[i * max_batch_size : (i + 1) * max_batch_size],\n-                        api_key,\n                         api_args,\n                         args,\n                         df,\n@@ -610,14 +613,18 @@ def describe(self, attribute: Optional[str] = None) -> pd.DataFrame:\n         # TODO: Update to use update() artifacts\n \n         args = self.model_storage.json_get('args')\n-\n+        api_key = get_api_key('openai', args, self.engine_storage)\n+        client= self._get_client(\n+            api_key=api_key,\n+            base_url=args.get('api_base'),\n+            org=args.get('api_organization')\n+            )\n         if attribute == 'args':\n             return pd.DataFrame(args.items(), columns=['key', 'value'])\n         elif attribute == 'metadata':\n-            api_key = get_api_key('openai', args, self.engine_storage)\n             model_name = args.get('model_name', self.default_model)\n-            meta = openai.Model.retrieve(model_name, api_key=api_key)\n-            return pd.DataFrame(meta.items(), columns=['key', 'value'])\n+            meta = client.models.retrieve(model_name)\n+            return pd.DataFrame(dict(meta).items(), columns=['key', 'value'])\n         else:\n             tables = ['args', 'metadata']\n             return pd.DataFrame(tables, columns=['tables'])\n@@ -644,6 +651,11 @@ def finetune(\n         using_args = args.pop('using') if 'using' in args else {}\n         prompt_col = using_args.get('prompt_column', 'prompt')\n         completion_col = using_args.get('completion_column', 'completion')\n+        \n+        api_key = get_api_key('openai', args, self.engine_storage)\n+        api_base = using_args.get('api_base', os.environ['OPENAI_API_BASE'])\n+        org = using_args.get('api_organization')\n+        client = self._get_client(api_key=api_key, base_url=api_base, org=org)\n \n         self._check_ft_cols(df, [prompt_col, completion_col])\n \n@@ -655,10 +667,6 @@ def finetune(\n                 f\"This model cannot be finetuned. Supported base models are {self.supported_ft_models}\"\n             )\n \n-        openai.api_key = get_api_key('openai', args, self.engine_storage)\n-        openai.api_base = args.get(\n-            'api_base', os.environ.get('OPENAI_API_BASE', OPENAI_API_BASE)\n-        )\n         finetune_time = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')\n \n         temp_storage_path = tempfile.mkdtemp()\n@@ -672,18 +680,15 @@ def finetune(\n         jsons = {k: None for k in file_names.keys()}\n         for split, file_name in file_names.items():\n             if os.path.isfile(os.path.join(temp_storage_path, file_name)):\n-                jsons[split] = openai.File.create(\n-                    file=open(f\"{temp_storage_path}/{file_name}\", \"rb\"),\n-                    # api_base=openai.api_base,  # TODO: rm\n-                    purpose='fine-tune',\n-                )\n+                jsons[split] = client.files.create(file=open(f\"{temp_storage_path}/{file_name}\", \"rb\"),\n+                purpose='fine-tune')\n \n-        if type(jsons['train']) in (openai.File, openai.openai_object.OpenAIObject):\n+        if type(jsons['train']) is openai.types.FileObject:\n             train_file_id = jsons['train'].id\n         else:\n             train_file_id = jsons['base'].id\n \n-        if type(jsons['val']) in (openai.File, openai.openai_object.OpenAIObject):\n+        if type(jsons['val']) is openai.types.FileObject:\n             val_file_id = jsons['val'].id\n         else:\n             val_file_id = None\n@@ -698,31 +703,34 @@ def finetune(\n \n         start_time = datetime.datetime.now()\n \n-        ft_stats, result_file_id = self._ft_call(ft_params, args.get('hour_budget', 8))\n-        ft_model_name = ft_stats['fine_tuned_model']\n+        ft_stats, result_file_id = self._ft_call(ft_params, client, args.get('hour_budget', 8))\n+        ft_model_name = ft_stats.fine_tuned_model\n \n         end_time = datetime.datetime.now()\n         runtime = end_time - start_time\n-        name_extension = openai.File.retrieve(id=result_file_id).filename\n+        name_extension = client.files.retrieve(file_id=result_file_id).filename\n         result_path = f'{temp_storage_path}/ft_{finetune_time}_result_{name_extension}'\n-        with open(result_path, 'wb') as f:\n-            f.write(openai.File.download(id=result_file_id))\n-\n-        if '.csv' in name_extension:\n-            # legacy endpoint\n-            train_stats = pd.read_csv(result_path)\n-            if 'validation_token_accuracy' in train_stats.columns:\n-                train_stats = train_stats[\n-                    train_stats['validation_token_accuracy'].notnull()\n-                ]\n-            args['ft_api_info'] = ft_stats.to_dict_recursive()\n-            args['ft_result_stats'] = train_stats.to_dict()\n \n-        elif '.json' in name_extension:\n-            train_stats = pd.read_json(\n-                path_or_buf=result_path, lines=True\n-            )  # new endpoint\n-            args['ft_api_info'] = args['ft_result_stats'] = train_stats.to_dict()\n+        try:\n+            client.files.content(file_id=result_file_id).stream_to_file(result_path)\n+            if '.csv' in name_extension:\n+                # legacy endpoint\n+                train_stats = pd.read_csv(result_path)\n+                if 'validation_token_accuracy' in train_stats.columns:\n+                    train_stats = train_stats[\n+                        train_stats['validation_token_accuracy'].notnull()\n+                    ]\n+                args['ft_api_info'] = ft_stats.dict()\n+                args['ft_result_stats'] = train_stats.to_dict()\n+\n+            elif '.json' in name_extension:\n+                train_stats = pd.read_json(\n+                    path_or_buf=result_path, lines=True\n+                )  # new endpoint\n+                args['ft_api_info'] = args['ft_result_stats'] = train_stats.to_dict()\n+\n+        except Exception:\n+            logger.info(f'Error retrieving fine-tuning results. Please check manually for information on job {ft_stats.id} (result file {result_file_id}).')\n \n         args['model_name'] = ft_model_name\n         args['runtime'] = runtime.total_seconds()\n@@ -768,12 +776,11 @@ def _prepare_ft_jsonl(self, df, _, temp_filename, temp_model_path):\n         }\n         return file_names\n \n-    @staticmethod\n-    def _get_ft_model_type(model_name: str):\n-        for model_type in ['ada', 'curie', 'babbage', 'davinci']:\n+    def _get_ft_model_type(self, model_name: str):\n+        for model_type in self.supported_ft_models:\n             if model_type in model_name.lower():\n                 return model_type\n-        return 'ada'\n+        return 'babbage-002'\n \n     @staticmethod\n     def _add_extra_ft_params(ft_params, using_args):\n@@ -797,36 +804,39 @@ def _add_extra_ft_params(ft_params, using_args):\n         }\n         return {**ft_params, **extra_params}\n \n-    def _ft_call(self, ft_params, hour_budget):\n+    def _ft_call(self, ft_params, client, hour_budget):\n         \"\"\"\n         Separate method to account for both legacy and new endpoints.\n         Currently, `OpenAIHandler` uses the legacy endpoint.\n         Others, like `AnyscaleEndpointsHandler`, use the new endpoint.\n         \"\"\"\n-        ft_result = self.ft_cls.create(\n+        ft_result = client.fine_tuning.jobs.create(\n             **{k: v for k, v in ft_params.items() if v is not None}\n         )\n \n         @retry_with_exponential_backoff(\n             hour_budget=hour_budget,\n-            errors=(openai.error.RateLimitError, openai.error.OpenAIError),\n         )\n         def _check_ft_status(model_id):\n-            ft_retrieved = self.ft_cls.retrieve(id=model_id)\n-            if ft_retrieved['status'] in ('succeeded', 'failed', 'cancelled'):\n+            ft_retrieved = client.fine_tuning.jobs.retrieve(fine_tuning_job_id=model_id)\n+            if ft_retrieved.status in ('succeeded', 'failed', 'cancelled'):\n                 return ft_retrieved\n             else:\n-                raise openai.error.OpenAIError('Fine-tuning still pending!')\n+                raise PendingFT('Fine-tuning still pending!')\n \n         ft_stats = _check_ft_status(ft_result.id)\n \n-        if ft_stats['status'] != 'succeeded':\n+        if ft_stats.status != 'succeeded':\n             raise Exception(\n-                f\"Fine-tuning did not complete successfully (status: {ft_stats['status']}). Error message: {ft_stats['events'][-1]['message']}\"\n+                f\"Fine-tuning did not complete successfully (status: {ft_stats.status}). Error message: {ft_stats.events[-1].message}\"\n             )  # noqa\n \n-        result_file_id = self.ft_cls.retrieve(id=ft_result.id)['result_files'][0]\n+        result_file_id = client.fine_tuning.jobs.retrieve(fine_tuning_job_id=ft_result.id).result_files[0]\n         if hasattr(result_file_id, 'id'):\n             result_file_id = result_file_id.id  # legacy endpoint\n \n         return ft_stats, result_file_id\n+    \n+    @staticmethod\n+    def _get_client(api_key, base_url=OPENAI_API_BASE, org=None):\n+        return OpenAI(api_key=api_key, base_url=base_url, organization=org)"
        },
        {
          "filename": "mindsdb/integrations/handlers/openai_handler/requirements.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,2 +1,2 @@\n-openai == 0.28.1\n+openai == 1.6.1\n tiktoken >= 0.3.0"
        },
        {
          "filename": "mindsdb/integrations/handlers/rag_handler/requirements.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -1,6 +1,5 @@\n -r mindsdb/integrations/handlers/chromadb_handler/requirements.txt\n-openai == 0.28.1\n-pydantic>=1.10.8\n+openai==1.6.1\n html2text\n writerai~=1.1.0\n pydantic"
        },
        {
          "filename": "mindsdb/integrations/handlers/rag_handler/settings.py",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -108,9 +108,9 @@ def get_available_openai_model_ids(args: dict) -> list:\n \n     openai.api_key = args[\"openai_api_key\"]\n \n-    res = openai.Engine.list()\n+    models = openai.OpenAI().models.list().data\n \n-    return [models[\"id\"] for models in res.data]\n+    return [models.id for models in models]\n \n \n @dataclass\n@@ -266,12 +266,12 @@ def load_writer_llm(self) -> Writer:\n \n     def load_openai_llm(self) -> partial:\n         \"\"\"Load OpenAI LLM API interface\"\"\"\n-        openai.api_key = self.config_dict[\"openai_api_key\"]\n+        client = openai.OpenAI(api_key=self.config_dict[\"openai_api_key\"])\n         config = self.config_dict.copy()\n         config.pop(\"openai_api_key\")\n         config[\"model\"] = config.pop(\"model_id\")\n \n-        return partial(openai.Completion.create, **config)\n+        return partial(client.completions.create, **config)\n \n \n class RAGBaseParameters(BaseModel):"
        },
        {
          "filename": "tests/handler_tests/test_instatus_handler.py",
          "status": "modified",
          "additions": 56,
          "deletions": 9,
          "patch": "@@ -11,6 +11,10 @@ class InstatusHandlerTest(unittest.TestCase):\n     def setUpClass(cls):\n         cls.handler = InstatusHandler(name='mindsdb_instatus', connection_data={'api_key': os.environ.get('INSTATUS_API_KEY')})\n \n+    def setUp(self):\n+        self.pageId = self.handler.call_instatus_api(endpoint='/v2/pages')['id'][0]\n+        self.componentId = self.handler.call_instatus_api(endpoint=f'/v1/{self.pageId}/components')['id'][0]\n+\n     def test_0_check_connection(self):\n         assert self.handler.check_connection()\n \n@@ -22,21 +26,23 @@ def test_2_get_tables(self):\n         assert tables.type is not RESPONSE_TYPE.ERROR\n \n     def test_3_get_columns(self):\n-        columns = self.handler.get_columns(table_name='status_pages')\n-        assert type(columns) is not RESPONSE_TYPE.ERROR\n+        status_pages_columns = self.handler.get_columns(table_name='status_pages')\n+        components_columns = self.handler.get_columns(table_name='components')\n+        assert type(status_pages_columns) is not RESPONSE_TYPE.ERROR\n+        assert type(components_columns) is not RESPONSE_TYPE.ERROR\n \n-    def test_4_select(self):\n+    def test_4_select_status_pages(self):\n         query = '''SELECT *\n                     FROM mindsdb_instatus.status_pages'''\n         self.assertTrue(self.handler.native_query(query))\n \n-    def test_5_select_by_conditions(self):\n+    def test_5_select_status_pages_by_conditions(self):\n         query = '''SELECT name, status, subdomain\n                     FROM mindsdb_instatus.status_pages\n                     WHERE id = \"clo3xshsk1114842hkn377y3lrap\"'''\n         self.assertTrue(self.handler.native_query(query))\n \n-    def test_6_insert(self):\n+    def test_6_insert_status_pages(self):\n         query = f'''INSERT INTO mindsdb_instatus.status_pages (email, name, subdomain, components, logoUrl) VALUES ('{os.environ.get('EMAIL_ID')}', 'mindsdb', 'somtirtha-roy', '[\"Website\", \"App\", \"API\"]', 'https://instatus.com/sample.png')'''\n         try:\n             self.assertTrue(self.handler.native_query(query))\n@@ -45,9 +51,7 @@ def test_6_insert(self):\n             if \"This subdomain is taken by another status page\" in error_message:\n                 print(\"Subdomain is already taken. Choose a different one.\")\n \n-    def test_7_update(self):\n-        # get the id of the row to be updated\n-        _id = self.handler.call_instatus_api(endpoint='/v2/pages')['id'][0]\n+    def test_7_update_status_pages(self):\n         # update the row with the id obtained\n         query = f'''UPDATE mindsdb_instatus.status_pages\n                 SET logoUrl = 'https://instatus.com/sample.png',\n@@ -89,7 +93,50 @@ def test_7_update(self):\n                         \"fr\": \"nasa\"\n                         }}\n                     }}'\n-                WHERE id = \"{_id}\"'''\n+                WHERE id = \"{self.pageId}\"'''\n+        self.assertTrue(self.handler.native_query(query))\n+\n+    def test_8_select_components(self):\n+        query = f'''SELECT *\n+                    FROM mindsdb_instatus.components\n+                    WHERE page_id = '{self.pageId}';'''\n+        self.assertTrue(self.handler.native_query(query))\n+\n+    def test_9_select_components_by_conditions(self):\n+        query = f'''SELECT *\n+                    FROM mindsdb_instatus.components\n+                    WHERE page_id = '{self.pageId}'\n+                    AND component_id = '{self.componentId}';'''\n+        self.assertTrue(self.handler.native_query(query))\n+\n+    def test_10_insert_components(self):\n+        query = f'''INSERT INTO mindsdb_instatus.components (page_id, name, description, status, order, showUptime, grouped, translations_name_in_fr, translations_desc_in_fr)\n+                    VALUES (\n+                        '{self.pageId}',\n+                        'Test component',\n+                        'Testing',\n+                        'OPERATIONAL',\n+                        6,\n+                        true,\n+                        false,\n+                        \"Composant de test\",\n+                        \"En test\"\n+                    );'''\n+        self.assertTrue(self.handler.native_query(query))\n+\n+    def test_11_update_components(self):\n+        query = f'''UPDATE mindsdb_instatus.components\n+                    SET\n+                        name = 'Test component 4',\n+                        description = 'Test test test',\n+                        status = 'OPERATIONAL',\n+                        order = 6,\n+                        showUptime = true,\n+                        grouped = false,\n+                        translations_name_in_fr = \"Composant de test 4\",\n+                        translations_desc_in_fr = \"Test test test\"\n+                    WHERE page_id = '{self.pageId}'\n+                    AND component_id = '{self.componentId}';'''\n         self.assertTrue(self.handler.native_query(query))\n \n "
        },
        {
          "filename": "tests/unit/ml_handlers/test_langchain_embedding.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -180,7 +180,7 @@ def test_no_input_columns(self, mock_handler):\n                 \"content2\": [\"world\", \"hello\", \"bar\", \"foo\"],\n             }\n         )\n-        self.set_handler(mock_handler, name=\"pg\", tables={\"df\": df})\n+        self.save_file(\"df\", df)\n \n         # create the model with no input columns specified should use\n         # all columns when embedding the documents\n@@ -217,7 +217,7 @@ class = 'fake', -- a more user friendly name\n         ret = self.run_sql(\n             \"\"\"\n             SELECT * FROM proj.test_dummy_no_input_columns\n-            JOIN pg.df\n+            JOIN files.df\n             \"\"\"\n         )\n \n@@ -231,7 +231,7 @@ class = 'fake', -- a more user friendly name\n         ret = self.run_sql(\n             \"\"\"\n             CREATE MODEL proj.test_dummy_no_input_columns_from_df\n-            FROM pg (\n+            FROM files (\n                 SELECT *, NULL as embeddings FROM df  -- this requires an empty column called embeddings\n             )\n             PREDICT embeddings"
        },
        {
          "filename": "tests/unit/ml_handlers/test_openai.py",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -7,8 +7,10 @@\n from mindsdb.integrations.handlers.openai_handler.openai_handler import OpenAIHandler\n from ..executor_test_base import BaseExecutorTest\n \n+OPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n \n-@pytest.mark.skipif(os.environ.get('OPENAI_API_KEY') is None, reason='Missing API key!')\n+\n+@pytest.mark.skipif(OPENAI_API_KEY is None, reason='Missing API key!')\n class TestOpenAI(BaseExecutorTest):\n     \"\"\"Test Class for OpenAI Integration Testing\"\"\"\n \n@@ -225,6 +227,9 @@ class MockHandlerStorage:\n             def json_get(self, key):\n                 return {'ft-suffix': {'ft-suffix': '$'}}[key]  # finetuning suffix, irrelevant for this test but needed for init  # noqa\n \n+            def get_connection_args(self):\n+                return {'api_key': OPENAI_API_KEY}    # noqa\n+\n         # create project\n         handler = OpenAIHandler(\n             model_storage=None,  # the storage does not matter for this test"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 6,
        "test_files": 3,
        "unique_directories": 10,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "809f56913a6d909ad90a3a57007b7368e1aef288",
            "date": "2025-01-24T16:18:10Z",
            "author_login": "StpMax"
          },
          {
            "sha": "2cba898a76b0e38579eb5315de05394928d133ba",
            "date": "2025-01-23T18:43:48Z",
            "author_login": "tmichaeldb"
          },
          {
            "sha": "658b9e7d285537accc01de311560e3bb78f00821",
            "date": "2025-01-23T13:30:48Z",
            "author_login": "ZoranPandovski"
          },
          {
            "sha": "6cb8d546829426bea33ee52b00dbd0752fceb512",
            "date": "2025-01-23T12:45:43Z",
            "author_login": "ea-rus"
          },
          {
            "sha": "5f77f906b59f887f27782256b6f25a4afc9d634a",
            "date": "2025-01-22T18:09:28Z",
            "author_login": "lucas-koontz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:L",
    "cwe_id": "CWE-918",
    "description": "MindsDB is a platform for building artificial intelligence from enterprise data. Prior to version 23.12.4.2, a threat actor can bypass the server-side request forgery protection on the whole website with DNS Rebinding. The vulnerability can also lead to denial of service. Version 23.12.4.2 contains a patch.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-05T17:15:12.380",
    "last_modified": "2024-09-06T13:06:18.623",
    "fix_date": "2024-01-05T10:52:51Z"
  },
  "references": [
    {
      "url": "https://github.com/mindsdb/mindsdb/commit/5f7496481bd3db1d06a2d2e62c0dce960a1fe12b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/mindsdb/mindsdb/security/advisories/GHSA-4jcv-vp96-94xr",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.098360",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "mindsdb",
    "owner": "mindsdb",
    "created_at": "2018-08-02T17:56:45Z",
    "updated_at": "2025-01-25T22:13:06Z",
    "pushed_at": "2025-01-24T17:24:28Z",
    "size": 254299,
    "stars": 27114,
    "forks": 4895,
    "open_issues": 141,
    "watchers": 27114,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 6117615,
      "Dockerfile": 6230,
      "HCL": 2986,
      "Makefile": 772,
      "HTML": 595,
      "Mako": 540,
      "Shell": 196
    },
    "commit_activity": {
      "total_commits_last_year": 2172,
      "avg_commits_per_week": 41.76923076923077,
      "days_active_last_year": 242
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T08:32:07.848002"
  }
}