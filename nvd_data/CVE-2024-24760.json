{
  "cve_id": "CVE-2024-24760",
  "github_data": {
    "repository": "mailcow/mailcow-dockerized",
    "fix_commit": "087481ac12bfa5dd715f3630f0b1697be94f7e88",
    "related_commits": [
      "087481ac12bfa5dd715f3630f0b1697be94f7e88",
      "087481ac12bfa5dd715f3630f0b1697be94f7e88"
    ],
    "patch_url": "https://github.com/mailcow/mailcow-dockerized/commit/087481ac12bfa5dd715f3630f0b1697be94f7e88.patch",
    "fix_commit_details": {
      "sha": "087481ac12bfa5dd715f3630f0b1697be94f7e88",
      "commit_date": "2024-02-02T13:33:01Z",
      "author": {
        "login": "FreddleSpl0it",
        "type": "User",
        "stats": {
          "total_commits": 345,
          "average_weekly_commits": 0.8136792452830188,
          "total_additions": 406219,
          "total_deletions": 346069,
          "weeks_active": 80
        }
      },
      "commit_message": {
        "title": "Merge pull request #5696 from mailcow/fix/netfilter",
        "length": 108,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 372,
        "additions": 314,
        "deletions": 58
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@ data/conf/dovecot/acl_anyone\n data/conf/dovecot/dovecot-master.passwd\n data/conf/dovecot/dovecot-master.userdb\n data/conf/dovecot/extra.conf\n+data/conf/dovecot/mail_replica.conf\n data/conf/dovecot/global_sieve_*\n data/conf/dovecot/last_login\n data/conf/dovecot/lua"
        },
        {
          "filename": "data/Dockerfiles/dovecot/docker-entrypoint.sh",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -335,6 +335,15 @@ sys.exit()\n EOF\n fi\n \n+# Set mail_replica for HA setups\n+if [[ -n ${MAILCOW_REPLICA_IP} && -n ${DOVEADM_REPLICA_PORT} ]]; then\n+  cat <<EOF > /etc/dovecot/mail_replica.conf\n+# Autogenerated by mailcow\n+mail_replica = tcp:${MAILCOW_REPLICA_IP}:${DOVEADM_REPLICA_PORT}\n+EOF\n+fi\n+\n+\n # 401 is user dovecot\n if [[ ! -s /mail_crypt/ecprivkey.pem || ! -s /mail_crypt/ecpubkey.pem ]]; then\n \topenssl ecparam -name prime256v1 -genkey | openssl pkey -out /mail_crypt/ecprivkey.pem"
        },
        {
          "filename": "data/Dockerfiles/netfilter/main.py",
          "status": "modified",
          "additions": 74,
          "deletions": 47,
          "patch": "@@ -21,47 +21,17 @@\n from modules.NFTables import NFTables\r\n \r\n \r\n-# connect to redis\r\n-while True:\r\n-  try:\r\n-    redis_slaveof_ip = os.getenv('REDIS_SLAVEOF_IP', '')\r\n-    redis_slaveof_port = os.getenv('REDIS_SLAVEOF_PORT', '')\r\n-    if \"\".__eq__(redis_slaveof_ip):\r\n-      r = redis.StrictRedis(host=os.getenv('IPV4_NETWORK', '172.22.1') + '.249', decode_responses=True, port=6379, db=0)\r\n-    else:\r\n-      r = redis.StrictRedis(host=redis_slaveof_ip, decode_responses=True, port=redis_slaveof_port, db=0)\r\n-    r.ping()\r\n-  except Exception as ex:\r\n-    print('%s - trying again in 3 seconds'  % (ex))\r\n-    time.sleep(3)\r\n-  else:\r\n-    break\r\n-pubsub = r.pubsub()\r\n-\r\n-# rename fail2ban to netfilter\r\n-if r.exists('F2B_LOG'):\r\n-  r.rename('F2B_LOG', 'NETFILTER_LOG')\r\n-\r\n-\r\n # globals\r\n WHITELIST = []\r\n BLACKLIST= []\r\n bans = {}\r\n quit_now = False\r\n exit_code = 0\r\n lock = Lock()\r\n-\r\n-\r\n-# init Logger\r\n-logger = Logger(r)\r\n-# init backend\r\n-backend = sys.argv[1]\r\n-if backend == \"nftables\":\r\n-  logger.logInfo('Using NFTables backend')\r\n-  tables = NFTables(\"MAILCOW\", logger)\r\n-else:\r\n-  logger.logInfo('Using IPTables backend')\r\n-  tables = IPTables(\"MAILCOW\", logger)\r\n+chain_name = \"MAILCOW\"\r\n+r = None\r\n+pubsub = None\r\n+clear_before_quit = False\r\n \r\n \r\n def refreshF2boptions():\r\n@@ -250,17 +220,21 @@ def clear():\n   with lock:\r\n     tables.clearIPv4Table()\r\n     tables.clearIPv6Table()\r\n-    r.delete('F2B_ACTIVE_BANS')\r\n-    r.delete('F2B_PERM_BANS')\r\n-    pubsub.unsubscribe()\r\n+    try:\r\n+      if r is not None:\r\n+        r.delete('F2B_ACTIVE_BANS')\r\n+        r.delete('F2B_PERM_BANS')\r\n+    except Exception as ex:\r\n+      logger.logWarn('Error clearing redis keys F2B_ACTIVE_BANS and F2B_PERM_BANS: %s' % ex)\r\n \r\n def watch():\r\n-  logger.logInfo('Watching Redis channel F2B_CHANNEL')\r\n-  pubsub.subscribe('F2B_CHANNEL')\r\n-\r\n+  global pubsub\r\n   global quit_now\r\n   global exit_code\r\n \r\n+  logger.logInfo('Watching Redis channel F2B_CHANNEL')\r\n+  pubsub.subscribe('F2B_CHANNEL')\r\n+\r\n   while not quit_now:\r\n     try:\r\n       for item in pubsub.listen():\r\n@@ -280,6 +254,7 @@ def watch():\n               ban(addr)\r\n     except Exception as ex:\r\n       logger.logWarn('Error reading log line from pubsub: %s' % ex)\r\n+      pubsub = None\r\n       quit_now = True\r\n       exit_code = 2\r\n \r\n@@ -403,21 +378,76 @@ def blacklistUpdate():\n           permBan(net=net, unban=True)\r\n     time.sleep(60.0 - ((time.time() - start_time) % 60.0))\r\n \r\n-def quit(signum, frame):\r\n-  global quit_now\r\n-  quit_now = True\r\n+def sigterm_quit(signum, frame):\r\n+  global clear_before_quit\r\n+  clear_before_quit = True\r\n+  sys.exit(exit_code)\r\n+\r\n+def berfore_quit():\r\n+  if clear_before_quit:\r\n+    clear()\r\n+  if pubsub is not None:\r\n+    pubsub.unsubscribe()\r\n \r\n \r\n if __name__ == '__main__':\r\n-  refreshF2boptions()\r\n+  atexit.register(berfore_quit)\r\n+  signal.signal(signal.SIGTERM, sigterm_quit)\r\n+\r\n+  # init Logger\r\n+  logger = Logger(None)\r\n+\r\n+  # init backend\r\n+  backend = sys.argv[1]\r\n+  if backend == \"nftables\":\r\n+    logger.logInfo('Using NFTables backend')\r\n+    tables = NFTables(chain_name, logger)\r\n+  else:\r\n+    logger.logInfo('Using IPTables backend')\r\n+    tables = IPTables(chain_name, logger)\r\n+\r\n   # In case a previous session was killed without cleanup\r\n   clear()\r\n+\r\n   # Reinit MAILCOW chain\r\n   # Is called before threads start, no locking\r\n   logger.logInfo(\"Initializing mailcow netfilter chain\")\r\n   tables.initChainIPv4()\r\n   tables.initChainIPv6()\r\n \r\n+  if os.getenv(\"DISABLE_NETFILTER_ISOLATION_RULE\").lower() in (\"y\", \"yes\"):\r\n+    logger.logInfo(f\"Skipping {chain_name} isolation\")\r\n+  else:\r\n+    logger.logInfo(f\"Setting {chain_name} isolation\")\r\n+    tables.create_mailcow_isolation_rule(\"br-mailcow\", [3306, 6379, 8983, 12345], os.getenv(\"MAILCOW_REPLICA_IP\"))\r\n+\r\n+  # connect to redis\r\n+  while True:\r\n+    try:\r\n+      redis_slaveof_ip = os.getenv('REDIS_SLAVEOF_IP', '')\r\n+      redis_slaveof_port = os.getenv('REDIS_SLAVEOF_PORT', '')\r\n+      if \"\".__eq__(redis_slaveof_ip):\r\n+        r = redis.StrictRedis(host=os.getenv('IPV4_NETWORK', '172.22.1') + '.249', decode_responses=True, port=6379, db=0)\r\n+      else:\r\n+        r = redis.StrictRedis(host=redis_slaveof_ip, decode_responses=True, port=redis_slaveof_port, db=0)\r\n+      r.ping()\r\n+      pubsub = r.pubsub()\r\n+    except Exception as ex:\r\n+      print('%s - trying again in 3 seconds'  % (ex))\r\n+      time.sleep(3)\r\n+    else:\r\n+      break\r\n+  Logger.r = r\r\n+\r\n+  # rename fail2ban to netfilter\r\n+  if r.exists('F2B_LOG'):\r\n+    r.rename('F2B_LOG', 'NETFILTER_LOG')\r\n+  # clear bans in redis\r\n+  r.delete('F2B_ACTIVE_BANS')\r\n+  r.delete('F2B_PERM_BANS')\r\n+  \r\n+  refreshF2boptions()\r\n+\r\n   watch_thread = Thread(target=watch)\r\n   watch_thread.daemon = True\r\n   watch_thread.start()\r\n@@ -460,9 +490,6 @@ def quit(signum, frame):\n   whitelistupdate_thread.daemon = True\r\n   whitelistupdate_thread.start()\r\n \r\n-  signal.signal(signal.SIGTERM, quit)\r\n-  atexit.register(clear)\r\n-\r\n   while not quit_now:\r\n     time.sleep(0.5)\r\n \r"
        },
        {
          "filename": "data/Dockerfiles/netfilter/modules/IPTables.py",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -1,5 +1,6 @@\n import iptc\n import time\n+import os\n \n class IPTables:\n   def __init__(self, chain_name, logger):\n@@ -211,3 +212,41 @@ def getSnat6Rule(self, snat_target, source):\n     target = rule.create_target(\"SNAT\")\n     target.to_source = snat_target\n     return rule\n+\n+  def create_mailcow_isolation_rule(self, _interface:str, _dports:list, _allow:str = \"\"):\n+    try:\n+      chain = iptc.Chain(iptc.Table(iptc.Table.FILTER), self.chain_name)\n+\n+      # insert mailcow isolation rule\n+      rule = iptc.Rule()\n+      rule.in_interface = f'! {_interface}'\n+      rule.out_interface = _interface\n+      rule.protocol = 'tcp'\n+      rule.create_target(\"DROP\")\n+      match = rule.create_match(\"multiport\")\n+      match.dports = ','.join(map(str, _dports))\n+\n+      if rule in chain.rules:\n+        chain.delete_rule(rule)\n+      chain.insert_rule(rule, position=0)\n+\n+      # insert mailcow isolation exception rule\n+      if _allow != \"\":\n+        rule = iptc.Rule()\n+        rule.src = _allow\n+        rule.in_interface = f'! {_interface}'\n+        rule.out_interface = _interface\n+        rule.protocol = 'tcp'\n+        rule.create_target(\"ACCEPT\")\n+        match = rule.create_match(\"multiport\")\n+        match.dports = ','.join(map(str, _dports))\n+\n+        if rule in chain.rules:\n+          chain.delete_rule(rule)\n+        chain.insert_rule(rule, position=0)\n+\n+\n+      return True\n+    except Exception as e:\n+      self.logger.logCrit(f\"Error adding {self.chain_name} isolation: {e}\")\n+      return False\n\\ No newline at end of file"
        },
        {
          "filename": "data/Dockerfiles/netfilter/modules/Logger.py",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -10,7 +10,8 @@ def log(self, priority, message):\n     tolog['time'] = int(round(time.time()))\n     tolog['priority'] = priority\n     tolog['message'] = message\n-    self.r.lpush('NETFILTER_LOG', json.dumps(tolog, ensure_ascii=False))\n+    if self.r:\n+      self.r.lpush('NETFILTER_LOG', json.dumps(tolog, ensure_ascii=False))\n     print(message)\n \n   def logWarn(self, message):"
        },
        {
          "filename": "data/Dockerfiles/netfilter/modules/NFTables.py",
          "status": "modified",
          "additions": 163,
          "deletions": 2,
          "patch": "@@ -1,5 +1,6 @@\n import nftables\n import ipaddress\n+import os\n \n class NFTables:\n   def __init__(self, chain_name, logger):\n@@ -266,6 +267,17 @@ def delete_nat_rule(self, _family:str, _chain: str, _handle:str):\n \n     return self.nft_exec_dict(delete_command)\n \n+  def delete_filter_rule(self, _family:str, _chain: str, _handle:str):\n+    delete_command = self.get_base_dict()\n+    _rule_opts = {'family': _family,\n+                  'table': 'filter',\n+                  'chain': _chain,\n+                  'handle': _handle  }\n+    _delete = {'delete': {'rule': _rule_opts} }\n+    delete_command[\"nftables\"].append(_delete)\n+\n+    return self.nft_exec_dict(delete_command)\n+\n   def snat_rule(self, _family: str, snat_target: str, source_address: str):\n     chain_name = self.nft_chain_names[_family]['nat']['postrouting']\n \n@@ -381,7 +393,7 @@ def get_chain_handle(self, _family: str, _table: str, chain_name: str):\n           break\n     return chain_handle\n \n-  def get_rules_handle(self, _family: str, _table: str, chain_name: str):\n+  def get_rules_handle(self, _family: str, _table: str, chain_name: str, _comment_filter = \"mailcow\"):\n     rule_handle = []\n     # Command: 'nft list chain {family} {table} {chain_name}'\n     _chain_opts = {'family': _family, 'table': _table, 'name': chain_name}\n@@ -397,7 +409,7 @@ def get_rules_handle(self, _family: str, _table: str, chain_name: str):\n \n         rule = _object[\"rule\"]\n         if rule[\"family\"] == _family and rule[\"table\"] == _table and rule[\"chain\"] == chain_name:\n-          if rule.get(\"comment\") and rule[\"comment\"] == \"mailcow\":\n+          if rule.get(\"comment\") and rule[\"comment\"] == _comment_filter:\n             rule_handle.append(rule[\"handle\"])\n     return rule_handle\n \n@@ -493,3 +505,152 @@ def check_mailcow_chains(self, family: str, chain: str):\n         position+=1\n \n     return position if rule_found else False\n+\n+  def create_mailcow_isolation_rule(self, _interface:str, _dports:list, _allow:str = \"\"):\n+    family = \"ip\"\n+    table = \"filter\"\n+    comment_filter_drop = \"mailcow isolation\"\n+    comment_filter_allow = \"mailcow isolation allow\"\n+    json_command = self.get_base_dict()\n+\n+    # Delete old mailcow isolation rules\n+    handles = self.get_rules_handle(family, table, self.chain_name, comment_filter_drop)\n+    for handle in handles:\n+      self.delete_filter_rule(family, self.chain_name, handle)\n+    handles = self.get_rules_handle(family, table, self.chain_name, comment_filter_allow)\n+    for handle in handles:\n+      self.delete_filter_rule(family, self.chain_name, handle)\n+\n+    # insert mailcow isolation rule\n+    _match_dict_drop = [\n+      {\n+        \"match\": {\n+          \"op\": \"!=\",\n+          \"left\": {\n+            \"meta\": {\n+              \"key\": \"iifname\"\n+            }\n+          },\n+          \"right\": _interface\n+        }\n+      },\n+      {\n+        \"match\": {\n+          \"op\": \"==\",\n+          \"left\": {\n+            \"meta\": {\n+              \"key\": \"oifname\"\n+            }\n+          },\n+          \"right\": _interface\n+        }\n+      },\n+      {\n+        \"match\": {\n+          \"op\": \"==\",\n+          \"left\": {\n+            \"payload\": {\n+              \"protocol\": \"tcp\",\n+              \"field\": \"dport\"\n+            }\n+          },\n+          \"right\": {\n+            \"set\": _dports\n+          }\n+        }\n+      },\n+      {\n+        \"counter\": {\n+          \"packets\": 0,\n+          \"bytes\": 0\n+        }\n+      },\n+      {\n+        \"drop\": None\n+      }\n+    ]\n+    rule_drop = { \"insert\": { \"rule\": {\n+      \"family\": family,\n+      \"table\": table,\n+      \"chain\": self.chain_name,\n+      \"comment\": comment_filter_drop,\n+      \"expr\": _match_dict_drop\n+    }}}\n+    json_command[\"nftables\"].append(rule_drop)\n+\n+    # insert mailcow isolation allow rule\n+    if _allow != \"\":\n+      _match_dict_allow = [\n+        {\n+          \"match\": {\n+            \"op\": \"==\",\n+            \"left\": {\n+              \"payload\": {\n+                \"protocol\": \"ip\",\n+                \"field\": \"saddr\"\n+              }\n+            },\n+            \"right\": _allow\n+          }\n+        },\n+        {\n+          \"match\": {\n+            \"op\": \"!=\",\n+            \"left\": {\n+              \"meta\": {\n+                \"key\": \"iifname\"\n+              }\n+            },\n+            \"right\": _interface\n+          }\n+        },\n+        {\n+          \"match\": {\n+            \"op\": \"==\",\n+            \"left\": {\n+              \"meta\": {\n+                \"key\": \"oifname\"\n+              }\n+            },\n+            \"right\": _interface\n+          }\n+        },\n+        {\n+          \"match\": {\n+            \"op\": \"==\",\n+            \"left\": {\n+              \"payload\": {\n+                \"protocol\": \"tcp\",\n+                \"field\": \"dport\"\n+              }\n+            },\n+            \"right\": {\n+              \"set\": _dports\n+            }\n+          }\n+        },\n+        {\n+          \"counter\": {\n+            \"packets\": 0,\n+            \"bytes\": 0\n+          }\n+        },\n+        {\n+          \"accept\": None\n+        }\n+      ]\n+      rule_allow = { \"insert\": { \"rule\": {\n+        \"family\": family,\n+        \"table\": table,\n+        \"chain\": self.chain_name,\n+        \"comment\": comment_filter_allow,\n+        \"expr\": _match_dict_allow\n+      }}}\n+      json_command[\"nftables\"].append(rule_allow)\n+\n+    success = self.nft_exec_dict(json_command)\n+    if success == False:\n+      self.logger.logCrit(f\"Error adding {self.chain_name} isolation\")\n+      return False\n+\n+    return True\n\\ No newline at end of file"
        },
        {
          "filename": "data/conf/dovecot/dovecot.conf",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -247,6 +247,9 @@ plugin {\n   mail_log_events = delete undelete expunge copy mailbox_delete mailbox_rename\n   mail_log_fields = uid box msgid size\n   mail_log_cached_only = yes\n+\n+  # Try set mail_replica\n+  !include_try /etc/dovecot/mail_replica.conf\n }\n service quota-warning {\n   executable = script /usr/local/bin/quota_notify.py"
        },
        {
          "filename": "docker-compose.yml",
          "status": "modified",
          "additions": 12,
          "deletions": 8,
          "patch": "@@ -21,6 +21,7 @@ services:\n       image: mariadb:10.5\n       depends_on:\n         - unbound-mailcow\n+        - netfilter-mailcow\n       stop_grace_period: 45s\n       volumes:\n         - mysql-vol-1:/var/lib/mysql/\n@@ -46,6 +47,8 @@ services:\n       volumes:\n         - redis-vol-1:/data/\n       restart: always\n+      depends_on:\n+        - netfilter-mailcow\n       ports:\n         - \"${REDIS_PORT:-127.0.0.1:7654}:6379\"\n       environment:\n@@ -219,9 +222,10 @@ services:\n             - sogo\n \n     dovecot-mailcow:\n-      image: mailcow/dovecot:1.27\n+      image: mailcow/dovecot:1.28\n       depends_on:\n         - mysql-mailcow\n+        - netfilter-mailcow\n       dns:\n         - ${IPV4_NETWORK:-172.22.1}.254\n       cap_add:\n@@ -242,6 +246,8 @@ services:\n       environment:\n         - DOVECOT_MASTER_USER=${DOVECOT_MASTER_USER:-}\n         - DOVECOT_MASTER_PASS=${DOVECOT_MASTER_PASS:-}\n+        - MAILCOW_REPLICA_IP=${MAILCOW_REPLICA_IP:-}\n+        - DOVEADM_REPLICA_PORT=${DOVEADM_REPLICA_PORT:-}\n         - LOG_LINES=${LOG_LINES:-9999}\n         - DBNAME=${DBNAME}\n         - DBUSER=${DBUSER}\n@@ -435,14 +441,8 @@ services:\n             - acme\n \n     netfilter-mailcow:\n-      image: mailcow/netfilter:1.55\n+      image: mailcow/netfilter:1.56\n       stop_grace_period: 30s\n-      depends_on:\n-        - dovecot-mailcow\n-        - postfix-mailcow\n-        - sogo-mailcow\n-        - php-fpm-mailcow\n-        - redis-mailcow\n       restart: always\n       privileged: true\n       environment:\n@@ -453,6 +453,8 @@ services:\n         - SNAT6_TO_SOURCE=${SNAT6_TO_SOURCE:-n}\n         - REDIS_SLAVEOF_IP=${REDIS_SLAVEOF_IP:-}\n         - REDIS_SLAVEOF_PORT=${REDIS_SLAVEOF_PORT:-}\n+        - MAILCOW_REPLICA_IP=${MAILCOW_REPLICA_IP:-}\n+        - DISABLE_NETFILTER_ISOLATION_RULE=${DISABLE_NETFILTER_ISOLATION_RULE:-n}\n       network_mode: \"host\"\n       volumes:\n         - /lib/modules:/lib/modules:ro\n@@ -553,6 +555,8 @@ services:\n     solr-mailcow:\n       image: mailcow/solr:1.8.2\n       restart: always\n+      depends_on:\n+        - netfilter-mailcow\n       volumes:\n         - solr-vol-1:/opt/solr/server/solr/dovecot-fts/data\n       ports:"
        },
        {
          "filename": "generate_config.sh",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -494,6 +494,9 @@ WEBAUTHN_ONLY_TRUSTED_VENDORS=n\n # Otherwise it will work normally.\n SPAMHAUS_DQS_KEY=\n \n+# Prevent netfilter from setting an iptables/nftables rule to isolate the mailcow docker network - y/n\n+# CAUTION: Disabling this may expose container ports to other neighbors on the same subnet, even if the ports are bound to localhost\n+DISABLE_NETFILTER_ISOLATION_RULE=n\n EOF\n \n mkdir -p data/assets/ssl"
        },
        {
          "filename": "update.sh",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -481,6 +481,7 @@ CONFIG_ARRAY=(\n   \"WEBAUTHN_ONLY_TRUSTED_VENDORS\"\n   \"SPAMHAUS_DQS_KEY\"\n   \"SKIP_UNBOUND_HEALTHCHECK\"\n+  \"DISABLE_NETFILTER_ISOLATION_RULE\"\n )\n \n detect_bad_asn\n@@ -754,6 +755,13 @@ for option in ${CONFIG_ARRAY[@]}; do\n       echo '# Skip Unbound (DNS Resolver) Healthchecks (NOT Recommended!) - y/n' >> mailcow.conf\n       echo 'SKIP_UNBOUND_HEALTHCHECK=n' >> mailcow.conf\n     fi\n+  elif [[ ${option} == \"DISABLE_NETFILTER_ISOLATION_RULE\" ]]; then\n+    if ! grep -q ${option} mailcow.conf; then\n+      echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n+      echo '# Prevent netfilter from setting an iptables/nftables rule to isolate the mailcow docker network - y/n' >> mailcow.conf\n+      echo '# CAUTION: Disabling this may expose container ports to other neighbors on the same subnet, even if the ports are bound to localhost' >> mailcow.conf\n+      echo 'DISABLE_NETFILTER_ISOLATION_RULE=n' >> mailcow.conf\n+    fi \n   elif ! grep -q ${option} mailcow.conf; then\n     echo \"Adding new option \\\"${option}\\\" to mailcow.conf\"\n     echo \"${option}=n\" >> mailcow.conf"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bd9f4ba0a57a159939760ecd319f2d44abf6b27a",
            "date": "2024-11-15T15:21:17Z",
            "author_login": "DerLinkman"
          },
          {
            "sha": "d10d64dd9216ca0d0f70280a3c7a4c12bbc463dc",
            "date": "2024-11-15T15:07:18Z",
            "author_login": "DerLinkman"
          },
          {
            "sha": "6d1f7482edae6927fa1b2b540d5ef11fa8e2bcb2",
            "date": "2024-11-13T09:42:38Z",
            "author_login": "FreddleSpl0it"
          },
          {
            "sha": "b9f52df3f10e43c1fc9364ff0ef5a6008d959a40",
            "date": "2024-11-13T11:04:49Z",
            "author_login": "FreddleSpl0it"
          },
          {
            "sha": "4d688c55007216e50434060398ee91b2755e25d6",
            "date": "2024-11-12T14:57:17Z",
            "author_login": "DerLinkman"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-610",
    "description": "mailcow is a dockerized email package, with multiple containers linked in one bridged network. A security vulnerability has been identified in mailcow affecting versions < 2024-01c. This vulnerability potentially allows attackers on the same subnet to connect to exposed ports of a Docker container, even when the port is bound to 127.0.0.1. The vulnerability has been addressed by implementing additional iptables/nftables rules. These rules drop packets for Docker containers on ports 3306, 6379, 8983, and 12345, where the input interface is not `br-mailcow` and the output interface is `br-mailcow`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-02T16:15:56.163",
    "last_modified": "2024-11-21T08:59:38.663",
    "fix_date": "2024-02-02T13:33:01Z"
  },
  "references": [
    {
      "url": "https://github.com/mailcow/mailcow-dockerized/commit/087481ac12bfa5dd715f3630f0b1697be94f7e88",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/mailcow/mailcow-dockerized/security/advisories/GHSA-gmpj-5xcm-xxx6",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/mailcow/mailcow-dockerized/commit/087481ac12bfa5dd715f3630f0b1697be94f7e88",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/mailcow/mailcow-dockerized/security/advisories/GHSA-gmpj-5xcm-xxx6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.580904",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "mailcow-dockerized",
    "owner": "mailcow",
    "created_at": "2016-12-09T19:38:35Z",
    "updated_at": "2025-01-13T23:53:22Z",
    "pushed_at": "2025-01-14T11:18:29Z",
    "size": 48668,
    "stars": 9437,
    "forks": 1223,
    "open_issues": 392,
    "watchers": 9437,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "staging"
    ],
    "languages": {
      "JavaScript": 1405369,
      "PHP": 1135521,
      "Twig": 591918,
      "CSS": 352712,
      "Shell": 306925,
      "Python": 113018,
      "Lua": 36105,
      "Dockerfile": 18443,
      "Perl": 5763,
      "HTML": 5479,
      "Smarty": 5136,
      "Ruby": 943,
      "C++": 891,
      "BitBake": 708,
      "Sieve": 296
    },
    "commit_activity": {
      "total_commits_last_year": 213,
      "avg_commits_per_week": 4.096153846153846,
      "days_active_last_year": 100
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T13:27:01.167324"
  }
}