{
  "cve_id": "CVE-2024-24825",
  "github_data": {
    "repository": "DIRACGrid/DIRAC",
    "fix_commit": "f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
    "related_commits": [
      "f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
      "f9ddab755b9a69acb85e14d2db851d8ac0c9648c"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
      "commit_date": "2024-02-07T16:16:16Z",
      "author": {
        "login": "chrisburr",
        "type": "User",
        "stats": {
          "total_commits": 1012,
          "average_weekly_commits": 1.094054054054054,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 184
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-59qj-jcjv-662j",
        "length": 91,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 42,
        "additions": 6,
        "deletions": 36
      },
      "files": [
        {
          "filename": "src/DIRAC/FrameworkSystem/Service/TokenManagerHandler.py",
          "status": "modified",
          "additions": 6,
          "deletions": 36,
          "patch": "@@ -16,17 +16,16 @@\n .. image:: /_static/Systems/FS/TokenManager_getToken.png\n     :alt: https://dirac.readthedocs.io/en/integration/_images/TokenManager_getToken.png (source https://github.com/TaykYoku/DIRACIMGS/raw/main/TokenManagerService_getToken.ai)\n \n-The service and its client have a mechanism for caching the received tokens.\n+The client has a mechanism for caching the received tokens.\n This helps reduce the number of requests to both the service and the Identity Provider (IdP).\n \n If the client has a valid **access token** in the cache, it is used until it expires.\n After that you need to update. The client can update it independently if on the server where it is in ``dirac.cfg``\n ``client_id`` and ``client_secret`` of the Identity Provider client are registered.\n \n Otherwise, the client makes an RPC call to the **TornadoManager** service.\n-It in turn checks the cache and if the ``access token`` is already invalid tries to update it using a ``refresh token``.\n-If the required token is not in the cache, then the ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`\n-is taken and the **exchange token** request to Identity Provider is made. The received tokens are cached.\n+The ``refresh token`` from :py:class:`TokenDB <DIRAC.FrameworkSystem.DB.TokenDB.TokenDB>`\n+is taken and the **exchange token** request to Identity Provider is made.\n \"\"\"\n \n import pprint\n@@ -42,16 +41,11 @@\n from DIRAC.FrameworkSystem.Utilities.TokenManagementUtilities import (\n     getIdProviderClient,\n     getCachedKey,\n-    getCachedToken,\n     DEFAULT_RT_EXPIRATION_TIME,\n     DEFAULT_AT_EXPIRATION_TIME,\n )\n \n \n-# Used to synchronize the cache with user tokens\n-gTokensSync = ThreadSafe.Synchronizer()\n-\n-\n class TokenManagerHandler(TornadoService):\n     DEFAULT_AUTHORIZATION = [\"authenticated\"]\n \n@@ -61,8 +55,6 @@ def initializeHandler(cls, *args):\n \n         :return: S_OK()/S_ERROR()\n         \"\"\"\n-        # Cache containing tokens from scope requested by the client\n-        cls.__tokensCache = DictCache()\n \n         # The service plays an important OAuth 2.0 role, namely it is an Identity Provider client.\n         # This allows you to manage tokens without the involvement of their owners.\n@@ -181,7 +173,6 @@ def __checkProperties(self, requestedUserDN: str, requestedUserGroup: str):\n         # Not authorized!\n         return S_ERROR(\"You can't get tokens!\")\n \n-    @gTokensSync\n     def export_getToken(\n         self,\n         username: str = None,\n@@ -213,12 +204,8 @@ def export_getToken(\n             return result\n         idpObj = result[\"Value\"]\n \n-        # Search for an existing token in tokensCache\n-        cachedKey = getCachedKey(idpObj, username, userGroup, scope, audience)\n-        result = getCachedToken(self.__tokensCache, cachedKey, requiredTimeLeft)\n-        if result[\"OK\"]:\n-            # A valid token has been found and is returned\n-            return result\n+        # getCachedKey is just used here to resolve the default scopes\n+        _, scope, *_ = getCachedKey(idpObj, username, userGroup, scope, audience)\n \n         # A client token is requested\n         if not username:\n@@ -227,19 +214,8 @@ def export_getToken(\n                 return result\n \n             # Get the client token with requested scope and audience\n-            scope = cachedKey[1]\n-            audience = cachedKey[2]\n             result = idpObj.fetchToken(grant_type=\"client_credentials\", scope=scope, audience=audience)\n-            if not result[\"OK\"]:\n-                return result\n-            token = result[\"Value\"]\n-\n-            # Caching new token: only get an access token (no refresh token in this context)\n-            self.__tokensCache.add(\n-                cachedKey,\n-                result[\"Value\"].get_claim(\"exp\", \"access_token\") or DEFAULT_AT_EXPIRATION_TIME,\n-                token,\n-            )\n+\n             return result\n \n         # A user token is requested\n@@ -262,12 +238,6 @@ def export_getToken(\n                         # refresh token with requested scope\n                         result = idpObj.refreshToken(tokens.get(\"refresh_token\"), group=userGroup, scope=scope)\n                         if result[\"OK\"]:\n-                            # caching new tokens\n-                            self.__tokensCache.add(\n-                                cachedKey,\n-                                result[\"Value\"].get_claim(\"exp\", \"refresh_token\") or DEFAULT_RT_EXPIRATION_TIME,\n-                                result[\"Value\"],\n-                            )\n                             return result\n                 # Did not find any token associated with the found user ID\n                 err.append(result.get(\"Message\", f\"No token found for {uid}\"))"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "97d11c12a5ceaf2dfa0c7dbfbdff9d0e04d86ed7",
            "date": "2025-01-22T14:29:15Z",
            "author_login": "chrisburr"
          },
          {
            "sha": "6e2247a91d6020733e495d6651e59d2ff1142454",
            "date": "2025-01-21T15:20:51Z",
            "author_login": "fstagni"
          },
          {
            "sha": "dcf2fa805873b97026205a5814ac3582170f78cf",
            "date": "2025-01-21T10:41:54Z",
            "author_login": "fstagni"
          },
          {
            "sha": "bfe4a833f743285a85c5e0067eb798695b7843be",
            "date": "2025-01-17T15:45:55Z",
            "author_login": "fstagni"
          },
          {
            "sha": "d89cc446d33569164974e27496f8205dd3ef078f",
            "date": "2025-01-17T15:45:42Z",
            "author_login": "fstagni"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-200",
    "description": "DIRAC is a distributed resource framework. In affected versions any user could get a token that has been requested by another user/agent. This may expose resources to unintended parties. This issue has been addressed in release version 8.0.37. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-09T00:15:08.903",
    "last_modified": "2024-11-21T08:59:47.790",
    "fix_date": "2024-02-07T16:16:16Z"
  },
  "references": [
    {
      "url": "https://github.com/DIRACGrid/DIRAC/commit/f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/DIRACGrid/DIRAC/security/advisories/GHSA-59qj-jcjv-662j",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/DIRACGrid/DIRAC/commit/f9ddab755b9a69acb85e14d2db851d8ac0c9648c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/DIRACGrid/DIRAC/security/advisories/GHSA-59qj-jcjv-662j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:05.603946",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "DIRAC",
    "owner": "DIRACGrid",
    "created_at": "2011-04-06T11:47:53Z",
    "updated_at": "2025-01-22T14:29:20Z",
    "pushed_at": "2025-01-22T14:29:58Z",
    "size": 89433,
    "stars": 113,
    "forks": 176,
    "open_issues": 80,
    "watchers": 113,
    "has_security_policy": false,
    "default_branch": "integration",
    "protected_branches": [
      "integration",
      "rel-v6r0",
      "rel-v6r1",
      "rel-v6r2",
      "rel-v6r3",
      "rel-v6r4",
      "rel-v6r5",
      "rel-v6r6",
      "rel-v6r7",
      "rel-v6r8",
      "rel-v6r9",
      "rel-v6r10",
      "rel-v6r11",
      "rel-v6r12",
      "rel-v6r13",
      "rel-v6r14",
      "rel-v6r15",
      "rel-v6r16",
      "rel-v6r17",
      "rel-v6r18",
      "rel-v6r19",
      "rel-v6r20",
      "rel-v6r21",
      "rel-v6r22"
    ],
    "languages": {
      "Python": 9782742,
      "Shell": 108531
    },
    "commit_activity": {
      "total_commits_last_year": 565,
      "avg_commits_per_week": 10.865384615384615,
      "days_active_last_year": 156
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-26T07:35:56.834270"
  }
}