{
  "cve_id": "CVE-2024-25110",
  "github_data": {
    "repository": "Azure/azure-uamqp-c",
    "fix_commit": "30865c9ccedaa32ddb036e87a8ebb52c3f18f695",
    "related_commits": [
      "30865c9ccedaa32ddb036e87a8ebb52c3f18f695",
      "30865c9ccedaa32ddb036e87a8ebb52c3f18f695"
    ],
    "patch_url": "https://github.com/Azure/azure-uamqp-c/commit/30865c9ccedaa32ddb036e87a8ebb52c3f18f695.patch",
    "fix_commit_details": {
      "sha": "30865c9ccedaa32ddb036e87a8ebb52c3f18f695",
      "commit_date": "2024-02-02T00:37:53Z",
      "author": {
        "login": "ewertons",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Use safe math in message.c (#452)",
        "length": 33,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 208,
        "additions": 127,
        "deletions": 81
      },
      "files": [
        {
          "filename": "src/message.c",
          "status": "modified",
          "additions": 127,
          "deletions": 81,
          "patch": "@@ -7,6 +7,7 @@\n #include \"azure_macro_utils/macro_utils.h\"\n #include \"azure_c_shared_utility/gballoc.h\"\n #include \"azure_c_shared_utility/xlogging.h\"\n+#include \"azure_c_shared_utility/safe_math.h\"\n #include \"azure_uamqp_c/amqp_definitions.h\"\n #include \"azure_uamqp_c/message.h\"\n #include \"azure_uamqp_c/amqpvalue.h\"\n@@ -232,78 +233,100 @@ MESSAGE_HANDLE message_clone(MESSAGE_HANDLE source_message)\n \n             if ((result != NULL) && (source_message->body_amqp_data_count > 0))\n             {\n-                size_t i;\n+                size_t calloc_size = safe_multiply_size_t(source_message->body_amqp_data_count, sizeof(BODY_AMQP_DATA));\n \n-                result->body_amqp_data_items = (BODY_AMQP_DATA*)calloc(1, (source_message->body_amqp_data_count * sizeof(BODY_AMQP_DATA)));\n-                if (result->body_amqp_data_items == NULL)\n+                if (calloc_size == SIZE_MAX)\n                 {\n-                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n-                    LogError(\"Cannot allocate memory for body data sections\");\n-                    message_destroy(result);\n+                    LogError(\"Invalid size for body_amqp_data_items\");\n                     result = NULL;\n                 }\n                 else\n                 {\n-                    for (i = 0; i < source_message->body_amqp_data_count; i++)\n+                    result->body_amqp_data_items = (BODY_AMQP_DATA*)calloc(1, calloc_size);\n+\n+                    if (result->body_amqp_data_items == NULL)\n                     {\n-                        result->body_amqp_data_items[i].body_data_section_length = source_message->body_amqp_data_items[i].body_data_section_length;\n+                        /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n+                        LogError(\"Cannot allocate memory for body data sections\");\n+                        message_destroy(result);\n+                        result = NULL;\n+                    }\n+                    else\n+                    {\n+                        size_t i;\n \n-                        /* Codes_SRS_MESSAGE_01_011: [If an AMQP data has been set as message body on the source message it shall be cloned by allocating memory for the binary payload.] */\n-                        result->body_amqp_data_items[i].body_data_section_bytes = (unsigned char*)malloc(source_message->body_amqp_data_items[i].body_data_section_length);\n-                        if (result->body_amqp_data_items[i].body_data_section_bytes == NULL)\n+                        for (i = 0; i < source_message->body_amqp_data_count; i++)\n                         {\n-                            LogError(\"Cannot allocate memory for body data section %u\", (unsigned int)i);\n-                            break;\n+                            result->body_amqp_data_items[i].body_data_section_length = source_message->body_amqp_data_items[i].body_data_section_length;\n+\n+                            /* Codes_SRS_MESSAGE_01_011: [If an AMQP data has been set as message body on the source message it shall be cloned by allocating memory for the binary payload.] */\n+                            result->body_amqp_data_items[i].body_data_section_bytes = (unsigned char*)malloc(source_message->body_amqp_data_items[i].body_data_section_length);\n+                            if (result->body_amqp_data_items[i].body_data_section_bytes == NULL)\n+                            {\n+                                LogError(\"Cannot allocate memory for body data section %u\", (unsigned int)i);\n+                                break;\n+                            }\n+                            else\n+                            {\n+                                (void)memcpy(result->body_amqp_data_items[i].body_data_section_bytes, source_message->body_amqp_data_items[i].body_data_section_bytes, result->body_amqp_data_items[i].body_data_section_length);\n+                            }\n                         }\n-                        else\n+\n+                        result->body_amqp_data_count = i;\n+                        if (i < source_message->body_amqp_data_count)\n                         {\n-                            (void)memcpy(result->body_amqp_data_items[i].body_data_section_bytes, source_message->body_amqp_data_items[i].body_data_section_bytes, result->body_amqp_data_items[i].body_data_section_length);\n+                            /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n+                            message_destroy(result);\n+                            result = NULL;\n                         }\n                     }\n-\n-                    result->body_amqp_data_count = i;\n-                    if (i < source_message->body_amqp_data_count)\n-                    {\n-                        /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n-                        message_destroy(result);\n-                        result = NULL;\n-                    }\n                 }\n             }\n \n             if ((result != NULL) && (source_message->body_amqp_sequence_count > 0))\n             {\n-                size_t i;\n+                size_t calloc_size = safe_multiply_size_t(source_message->body_amqp_sequence_count, sizeof(AMQP_VALUE));\n \n-                result->body_amqp_sequence_items = (AMQP_VALUE*)calloc(1, (source_message->body_amqp_sequence_count * sizeof(AMQP_VALUE)));\n-                if (result->body_amqp_sequence_items == NULL)\n+                if (calloc_size == SIZE_MAX)\n                 {\n-                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n-                    LogError(\"Cannot allocate memory for body AMQP sequences\");\n+                    LogError(\"Invalid size for body_amqp_sequence_items\");\n                     message_destroy(result);\n                     result = NULL;\n                 }\n                 else\n                 {\n-                    for (i = 0; i < source_message->body_amqp_sequence_count; i++)\n-                    {\n-                        /* Codes_SRS_MESSAGE_01_160: [ If AMQP sequences are set as AMQP body they shall be cloned by calling `amqpvalue_clone`. ] */\n-                        result->body_amqp_sequence_items[i] = amqpvalue_clone(source_message->body_amqp_sequence_items[i]);\n-                        if (result->body_amqp_sequence_items[i] == NULL)\n-                        {\n-                            LogError(\"Cannot clone AMQP sequence %u\", (unsigned int)i);\n-                            break;\n-                        }\n-                    }\n-\n-                    result->body_amqp_sequence_count = i;\n-                    if (i < source_message->body_amqp_sequence_count)\n+                    result->body_amqp_sequence_items = (AMQP_VALUE*)calloc(1, calloc_size);\n+                    if (result->body_amqp_sequence_items == NULL)\n                     {\n                         /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n+                        LogError(\"Cannot allocate memory for body AMQP sequences\");\n                         message_destroy(result);\n                         result = NULL;\n                     }\n-                }\n+                    else\n+                    {\n+                        size_t i;\n+\n+                        for (i = 0; i < source_message->body_amqp_sequence_count; i++)\n+                        {\n+                            /* Codes_SRS_MESSAGE_01_160: [ If AMQP sequences are set as AMQP body they shall be cloned by calling `amqpvalue_clone`. ] */\n+                            result->body_amqp_sequence_items[i] = amqpvalue_clone(source_message->body_amqp_sequence_items[i]);\n+                            if (result->body_amqp_sequence_items[i] == NULL)\n+                            {\n+                                LogError(\"Cannot clone AMQP sequence %u\", (unsigned int)i);\n+                                break;\n+                            }\n+                        }\n+\n+                        result->body_amqp_sequence_count = i;\n+                        if (i < source_message->body_amqp_sequence_count)\n+                        {\n+                            /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n+                            message_destroy(result);\n+                            result = NULL;\n+                        }\n+                    }\n+\t\t\t\t}\n             }\n \n             if ((result != NULL) && (source_message->body_amqp_value != NULL))\n@@ -1017,45 +1040,56 @@ int message_add_body_amqp_data(MESSAGE_HANDLE message, BINARY_DATA amqp_data)\n         }\n         else\n         {\n-            /* Codes_SRS_MESSAGE_01_086: [ `message_add_body_amqp_data` shall add the contents of `amqp_data` to the list of AMQP data values for the body of the message identified by `message`. ]*/\n-            BODY_AMQP_DATA* new_body_amqp_data_items = (BODY_AMQP_DATA*)realloc(message->body_amqp_data_items, sizeof(BODY_AMQP_DATA) * (message->body_amqp_data_count + 1));\n-            if (new_body_amqp_data_items == NULL)\n+            size_t realloc_size = safe_add_size_t(message->body_amqp_data_count, 1);\n+            realloc_size = safe_multiply_size_t(sizeof(BODY_AMQP_DATA), realloc_size);\n+\n+            if (realloc_size == SIZE_MAX)\n             {\n-                /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n-                LogError(\"Cannot allocate memory for body AMQP data items\");\n+                LogError(\"Invalid size for new_body_amqp_data_items\");\n                 result = MU_FAILURE;\n             }\n             else\n             {\n-                message->body_amqp_data_items = new_body_amqp_data_items;\n-\n-                if (amqp_data.length == 0)\n+                /* Codes_SRS_MESSAGE_01_086: [ `message_add_body_amqp_data` shall add the contents of `amqp_data` to the list of AMQP data values for the body of the message identified by `message`. ]*/\n+                BODY_AMQP_DATA* new_body_amqp_data_items = (BODY_AMQP_DATA*)realloc(message->body_amqp_data_items, realloc_size);\n+                if (new_body_amqp_data_items == NULL)\n                 {\n-                    message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = NULL;\n-                    message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = 0;\n-                    message->body_amqp_data_count++;\n-\n-                    /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0. ]*/\n-                    result = 0;\n+                    /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n+                    LogError(\"Cannot allocate memory for body AMQP data items\");\n+                    result = MU_FAILURE;\n                 }\n                 else\n                 {\n-                    message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = (unsigned char*)malloc(amqp_data.length);\n-                    if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes == NULL)\n-                    {\n-                        /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n-                        LogError(\"Cannot allocate memory for body AMQP data to be added\");\n-                        result = MU_FAILURE;\n-                    }\n-                    else\n+                    message->body_amqp_data_items = new_body_amqp_data_items;\n+\n+                    if (amqp_data.length == 0)\n                     {\n-                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = amqp_data.length;\n-                        (void)memcpy(message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes, amqp_data.bytes, amqp_data.length);\n+                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = NULL;\n+                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = 0;\n                         message->body_amqp_data_count++;\n \n                         /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0. ]*/\n                         result = 0;\n                     }\n+                    else\n+                    {\n+                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = (unsigned char*)malloc(amqp_data.length);\n+                        if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes == NULL)\n+                        {\n+                            /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n+                            LogError(\"Cannot allocate memory for body AMQP data to be added\");\n+                            result = MU_FAILURE;\n+                        }\n+                        else\n+                        {\n+                            message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = amqp_data.length;\n+                            (void)memcpy(message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes, amqp_data.bytes, amqp_data.length);\n+                            message->body_amqp_data_count++;\n+\n+                            /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0. ]*/\n+                            result = 0;\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -1250,33 +1284,45 @@ int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_l\n         }\n         else\n         {\n-            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n-            if (new_body_amqp_sequence_items == NULL)\n+            size_t realloc_size = safe_add_size_t(message->body_amqp_sequence_count, 1);\n+            realloc_size = safe_multiply_size_t(sizeof(AMQP_VALUE), realloc_size);\n+\n+            if (realloc_size == SIZE_MAX)\n             {\n-                /* Codes_SRS_MESSAGE_01_158: [ If allocating memory in order to store the sequence fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n-                LogError(\"Cannot allocate enough memory for sequence items\");\n+                LogError(\"Invalid size for new_body_amqp_sequence_items\");\n                 result = MU_FAILURE;\n             }\n             else\n             {\n-                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n+                AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, realloc_size);\n \n-                /* Codes_SRS_MESSAGE_01_110: [ `message_add_body_amqp_sequence` shall add the contents of `sequence` to the list of AMQP sequences for the body of the message identified by `message`. ]*/\n-                /* Codes_SRS_MESSAGE_01_156: [ The AMQP sequence shall be cloned by calling `amqpvalue_clone`. ]*/\n-                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n-                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n+                if (new_body_amqp_sequence_items == NULL)\n                 {\n-                    /* Codes_SRS_MESSAGE_01_157: [ If `amqpvalue_clone` fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n-                    LogError(\"Cloning sequence failed\");\n+                    /* Codes_SRS_MESSAGE_01_158: [ If allocating memory in order to store the sequence fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n+                    LogError(\"Cannot allocate enough memory for sequence items\");\n                     result = MU_FAILURE;\n                 }\n                 else\n                 {\n-                    /* Codes_SRS_MESSAGE_01_114: [ If adding the AMQP sequence fails, the previous value shall be preserved. ]*/\n-                    message->body_amqp_sequence_count++;\n+                    message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n \n-                    /* Codes_SRS_MESSAGE_01_111: [ On success it shall return 0. ]*/\n-                    result = 0;\n+                    /* Codes_SRS_MESSAGE_01_110: [ `message_add_body_amqp_sequence` shall add the contents of `sequence` to the list of AMQP sequences for the body of the message identified by `message`. ]*/\n+                    /* Codes_SRS_MESSAGE_01_156: [ The AMQP sequence shall be cloned by calling `amqpvalue_clone`. ]*/\n+                    message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n+                    if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n+                    {\n+                        /* Codes_SRS_MESSAGE_01_157: [ If `amqpvalue_clone` fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n+                        LogError(\"Cloning sequence failed\");\n+                        result = MU_FAILURE;\n+                    }\n+                    else\n+                    {\n+                        /* Codes_SRS_MESSAGE_01_114: [ If adding the AMQP sequence fails, the previous value shall be preserved. ]*/\n+                        message->body_amqp_sequence_count++;\n+\n+                        /* Codes_SRS_MESSAGE_01_111: [ On success it shall return 0. ]*/\n+                        result = 0;\n+                    }\n                 }\n             }\n         }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "09e08d1611397e3e542d0f42340165c5dd7196df",
            "date": "2025-01-06T22:25:06Z",
            "author_login": "ewertons"
          },
          {
            "sha": "96d7179f60e558b2c350194ea0061c725377f7e0",
            "date": "2024-08-09T20:44:28Z",
            "author_login": "ewertons"
          },
          {
            "sha": "997e40ec9b8f9176319e0aee9c971f4590c32f74",
            "date": "2024-07-18T17:35:21Z",
            "author_login": "ericwolz"
          },
          {
            "sha": "9107c28dfd790479898f0b018742ccf078ec9ffc",
            "date": "2024-06-26T17:12:33Z",
            "author_login": "ewertons"
          },
          {
            "sha": "6a150b07352304acacdde2e446643f8f6de0ea3a",
            "date": "2024-06-19T15:54:32Z",
            "author_login": "ewertons"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-94",
    "description": "The UAMQP is a general purpose C library for AMQP 1.0. During a call to open_get_offered_capabilities, a memory allocation may fail causing a use-after-free issue and if a client called it during connection communication it may cause a remote code execution. Users are advised to update the submodule with commit `30865c9c`. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-12T20:15:08.803",
    "last_modified": "2024-11-22T14:48:36.047",
    "fix_date": "2024-02-02T00:37:53Z"
  },
  "references": [
    {
      "url": "https://github.com/Azure/azure-uamqp-c/commit/30865c9ccedaa32ddb036e87a8ebb52c3f18f695",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Azure/azure-uamqp-c/security/advisories/GHSA-c646-4whf-r67v",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/Azure/azure-uamqp-c/commit/30865c9ccedaa32ddb036e87a8ebb52c3f18f695",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Azure/azure-uamqp-c/security/advisories/GHSA-c646-4whf-r67v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.114453",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "azure-uamqp-c",
    "owner": "Azure",
    "created_at": "2015-11-20T06:13:31Z",
    "updated_at": "2025-01-06T22:25:11Z",
    "pushed_at": "2025-01-06T22:25:08Z",
    "size": 4441,
    "stars": 58,
    "forks": 64,
    "open_issues": 45,
    "watchers": 58,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "lts_01_2018",
      "lts_02_2020",
      "lts_07_2019",
      "lts_07_2020",
      "master",
      "release_2018_06_08",
      "release_2018_06_15",
      "release_2018_06_26",
      "release_2018_06_27",
      "release_2018_07_11",
      "release_2018_10_03",
      "release_2018_11_20"
    ],
    "languages": {
      "C": 3974550,
      "C#": 195090,
      "C++": 112788,
      "CMake": 23848,
      "Batchfile": 16001,
      "Shell": 10586,
      "Makefile": 1093
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:29:30.935197"
  }
}