{
  "cve_id": "CVE-2024-25124",
  "github_data": {
    "repository": "gofiber/fiber",
    "fix_commit": "f0cd3b44b086544a37886232d0530601f2406c23",
    "related_commits": [
      "f0cd3b44b086544a37886232d0530601f2406c23",
      "f0cd3b44b086544a37886232d0530601f2406c23"
    ],
    "patch_url": "https://github.com/gofiber/fiber/commit/f0cd3b44b086544a37886232d0530601f2406c23.patch",
    "fix_commit_details": {
      "sha": "f0cd3b44b086544a37886232d0530601f2406c23",
      "commit_date": "2024-02-21T13:47:33Z",
      "author": {
        "login": "gaby",
        "type": "User",
        "stats": {
          "total_commits": 90,
          "average_weekly_commits": 0.3409090909090909,
          "total_additions": 23739,
          "total_deletions": 25607,
          "weeks_active": 43
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-fmg4-x8pw-hjhg",
        "length": 331,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 490,
        "additions": 402,
        "deletions": 88
      },
      "files": [
        {
          "filename": "docs/api/middleware/cors.md",
          "status": "modified",
          "additions": 21,
          "deletions": 10,
          "patch": "@@ -10,6 +10,8 @@ The middleware conforms to the `access-control-allow-origin` specification by pa\n \n For more control, `AllowOriginsFunc` can be used to programatically determine if an origin is allowed. If no match was found in `AllowOrigins` and if `AllowOriginsFunc` returns true then the 'access-control-allow-origin' response header is set to the 'origin' request header.\n \n+When defining your Origins make sure they are properly formatted. The middleware validates and normalizes the provided origins, ensuring they're in the correct format by checking for valid schemes (http or https), and removing any trailing slashes.\n+\n ## Signatures\n \n ```go\n@@ -56,18 +58,27 @@ app.Use(cors.New(cors.Config{\n }))\n ```\n \n+**Note: The following configuration is considered insecure and will result in a panic.**\n+\n+```go\n+app.Use(cors.New(cors.Config{\n+    AllowOrigins: \"*\",\n+    AllowCredentials: true,\n+}))\n+```\n+\n ## Config\n \n-| Property         | Type                       | Description                                                                                                                                                                                                                                                                                                           | Default                            |\n-|:-----------------|:---------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------|\n-| Next             | `func(*fiber.Ctx) bool`    | Next defines a function to skip this middleware when returned true.                                                                                                                                                                                                                                                   | `nil`                              |\n-| AllowOriginsFunc | `func(origin string) bool` | AllowOriginsFunc defines a function that will set the 'access-control-allow-origin' response header to the 'origin' request header when returned true.                                                                                                                                                                | `nil`                              |\n-| AllowOrigins     | `string`                   | AllowOrigin defines a comma separated list of origins that may access the resource.                                                                                                                                                                                                                                   | `\"*\"`                              |\n-| AllowMethods     | `string`                   | AllowMethods defines a list of methods allowed when accessing the resource. This is used in response to a preflight request.                                                                                                                                                                                          | `\"GET,POST,HEAD,PUT,DELETE,PATCH\"` |\n-| AllowHeaders     | `string`                   | AllowHeaders defines a list of request headers that can be used when making the actual request. This is in response to a preflight request.                                                                                                                                                                           | `\"\"`                               |\n-| AllowCredentials | `bool`                     | AllowCredentials indicates whether or not the response to the request can be exposed when the credentials flag is true.                                                                                                                                                                                               | `false`                            |\n-| ExposeHeaders    | `string`                   | ExposeHeaders defines a whitelist headers that clients are allowed to access.                                                                                                                                                                                                                                         | `\"\"`                               |\n-| MaxAge           | `int`                      | MaxAge indicates how long (in seconds) the results of a preflight request can be cached. If you pass MaxAge 0, Access-Control-Max-Age header will not be added and browser will use 5 seconds by default. To disable caching completely, pass MaxAge value negative. It will set the Access-Control-Max-Age header 0. | `0`                                |\n+| Property         | Type                       | Description                                                                                                                                                                                                                                                                                                                                                        | Default                            |\n+|:-----------------|:---------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------|\n+| Next             | `func(*fiber.Ctx) bool`    | Next defines a function to skip this middleware when returned true.                                                                                                                                                                                                                                                                                                | `nil`                              |\n+| AllowOriginsFunc | `func(origin string) bool` | AllowOriginsFunc defines a function that will set the 'access-control-allow-origin' response header to the 'origin' request header when returned true. This allows for dynamic evaluation of allowed origins. Note if AllowCredentials is true, wildcard origins will be not have the 'access-control-allow-credentials' header set to 'true'.                     | `nil`                              |\n+| AllowOrigins     | `string`                   | AllowOrigin defines a comma separated list of origins that may access the resource.                                                                                                                                                                                                                                                                                | `\"*\"`                              |\n+| AllowMethods     | `string`                   | AllowMethods defines a list of methods allowed when accessing the resource. This is used in response to a preflight request.                                                                                                                                                                                                                                       | `\"GET,POST,HEAD,PUT,DELETE,PATCH\"` |\n+| AllowHeaders     | `string`                   | AllowHeaders defines a list of request headers that can be used when making the actual request. This is in response to a preflight request.                                                                                                                                                                                                                        | `\"\"`                               |\n+| AllowCredentials | `bool`                     | AllowCredentials indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note: If true, AllowOrigins cannot be set to a wildcard (\"*\") to prevent security vulnerabilities. | `false`                            |\n+| ExposeHeaders    | `string`                   | ExposeHeaders defines a whitelist headers that clients are allowed to access.                                                                                                                                                                                                                                                                                      | `\"\"`                               |\n+| MaxAge           | `int`                      | MaxAge indicates how long (in seconds) the results of a preflight request can be cached. If you pass MaxAge 0, Access-Control-Max-Age header will not be added and browser will use 5 seconds by default. To disable caching completely, pass MaxAge value negative. It will set the Access-Control-Max-Age header 0.                                              | `0`                                |\n \n ## Default Config\n "
        },
        {
          "filename": "middleware/cors/cors.go",
          "status": "modified",
          "additions": 44,
          "deletions": 17,
          "patch": "@@ -16,12 +16,14 @@ type Config struct {\n \tNext func(c *fiber.Ctx) bool\n \n \t// AllowOriginsFunc defines a function that will set the 'access-control-allow-origin'\n-\t// response header to the 'origin' request header when returned true.\n+\t// response header to the 'origin' request header when returned true. This allows for\n+\t// dynamic evaluation of allowed origins. Note if AllowCredentials is true, wildcard origins\n+\t// will be not have the 'access-control-allow-credentials' header set to 'true'.\n \t//\n \t// Optional. Default: nil\n \tAllowOriginsFunc func(origin string) bool\n \n-\t// AllowOrigin defines a list of origins that may access the resource.\n+\t// AllowOrigin defines a comma separated list of origins that may access the resource.\n \t//\n \t// Optional. Default value \"*\"\n \tAllowOrigins string\n@@ -41,7 +43,8 @@ type Config struct {\n \t// AllowCredentials indicates whether or not the response to the request\n \t// can be exposed when the credentials flag is true. When used as part of\n \t// a response to a preflight request, this indicates whether or not the\n-\t// actual request can be made using credentials.\n+\t// actual request can be made using credentials. Note: If true, AllowOrigins\n+\t// cannot be set to a wildcard (\"*\") to prevent security vulnerabilities.\n \t//\n \t// Optional. Default value false.\n \tAllowCredentials bool\n@@ -105,6 +108,26 @@ func New(config ...Config) fiber.Handler {\n \t\tlog.Warn(\"[CORS] Both 'AllowOrigins' and 'AllowOriginsFunc' have been defined.\")\n \t}\n \n+\t// Validate CORS credentials configuration\n+\tif cfg.AllowCredentials && cfg.AllowOrigins == \"*\" {\n+\t\tpanic(\"[CORS] Insecure setup, 'AllowCredentials' is set to true, and 'AllowOrigins' is set to a wildcard.\")\n+\t}\n+\n+\t// Validate and normalize static AllowOrigins if not using AllowOriginsFunc\n+\tif cfg.AllowOriginsFunc == nil && cfg.AllowOrigins != \"\" && cfg.AllowOrigins != \"*\" {\n+\t\tvalidatedOrigins := []string{}\n+\t\tfor _, origin := range strings.Split(cfg.AllowOrigins, \",\") {\n+\t\t\tisValid, normalizedOrigin := normalizeOrigin(origin)\n+\t\t\tif isValid {\n+\t\t\t\tvalidatedOrigins = append(validatedOrigins, normalizedOrigin)\n+\t\t\t} else {\n+\t\t\t\tlog.Warnf(\"[CORS] Invalid origin format in configuration: %s\", origin)\n+\t\t\t\tpanic(\"[CORS] Invalid origin provided in configuration\")\n+\t\t\t}\n+\t\t}\n+\t\tcfg.AllowOrigins = strings.Join(validatedOrigins, \",\")\n+\t}\n+\n \t// Convert string to slice\n \tallowOrigins := strings.Split(strings.ReplaceAll(cfg.AllowOrigins, \" \", \"\"), \",\")\n \n@@ -123,22 +146,18 @@ func New(config ...Config) fiber.Handler {\n \t\t\treturn c.Next()\n \t\t}\n \n-\t\t// Get origin header\n-\t\torigin := c.Get(fiber.HeaderOrigin)\n+\t\t// Get originHeader header\n+\t\toriginHeader := c.Get(fiber.HeaderOrigin)\n \t\tallowOrigin := \"\"\n \n \t\t// Check allowed origins\n-\t\tfor _, o := range allowOrigins {\n-\t\t\tif o == \"*\" {\n+\t\tfor _, origin := range allowOrigins {\n+\t\t\tif origin == \"*\" {\n \t\t\t\tallowOrigin = \"*\"\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif o == origin {\n-\t\t\t\tallowOrigin = o\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif matchSubdomain(origin, o) {\n-\t\t\t\tallowOrigin = origin\n+\t\t\tif validateDomain(originHeader, origin) {\n+\t\t\t\tallowOrigin = originHeader\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -147,8 +166,8 @@ func New(config ...Config) fiber.Handler {\n \t\t// handling the value in 'AllowOrigins' does\n \t\t// not result in allowOrigin being set.\n \t\tif allowOrigin == \"\" && cfg.AllowOriginsFunc != nil {\n-\t\t\tif cfg.AllowOriginsFunc(origin) {\n-\t\t\t\tallowOrigin = origin\n+\t\t\tif cfg.AllowOriginsFunc(originHeader) {\n+\t\t\t\tallowOrigin = originHeader\n \t\t\t}\n \t\t}\n \n@@ -173,9 +192,17 @@ func New(config ...Config) fiber.Handler {\n \t\tc.Set(fiber.HeaderAccessControlAllowOrigin, allowOrigin)\n \t\tc.Set(fiber.HeaderAccessControlAllowMethods, allowMethods)\n \n-\t\t// Set Allow-Credentials if set to true\n \t\tif cfg.AllowCredentials {\n-\t\t\tc.Set(fiber.HeaderAccessControlAllowCredentials, \"true\")\n+\t\t\t// When AllowCredentials is true, set the Access-Control-Allow-Origin to the specific origin instead of '*'\n+\t\t\tif allowOrigin != \"*\" && allowOrigin != \"\" {\n+\t\t\t\tc.Set(fiber.HeaderAccessControlAllowOrigin, allowOrigin)\n+\t\t\t\tc.Set(fiber.HeaderAccessControlAllowCredentials, \"true\")\n+\t\t\t} else if allowOrigin == \"*\" {\n+\t\t\t\tlog.Warn(\"[CORS] 'AllowCredentials' is true, but 'AllowOrigins' cannot be set to '*'.\")\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// For non-credential requests, it's safe to set to '*' or specific origins\n+\t\t\tc.Set(fiber.HeaderAccessControlAllowOrigin, allowOrigin)\n \t\t}\n \n \t\t// Set Allow-Headers if not empty"
        },
        {
          "filename": "middleware/cors/cors_test.go",
          "status": "modified",
          "additions": 129,
          "deletions": 25,
          "patch": "@@ -35,7 +35,7 @@ func Test_CORS_Negative_MaxAge(t *testing.T) {\n \n \tctx := &fasthttp.RequestCtx{}\n \tctx.Request.Header.SetMethod(fiber.MethodOptions)\n-\tctx.Request.Header.Set(fiber.HeaderOrigin, \"localhost\")\n+\tctx.Request.Header.Set(fiber.HeaderOrigin, \"http://localhost\")\n \tapp.Handler()(ctx)\n \n \tutils.AssertEqual(t, \"0\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlMaxAge)))\n@@ -72,7 +72,46 @@ func Test_CORS_Wildcard(t *testing.T) {\n \tapp := fiber.New()\n \t// OPTIONS (preflight) response headers when AllowOrigins is *\n \tapp.Use(New(Config{\n-\t\tAllowOrigins:     \"*\",\n+\t\tAllowOrigins:  \"*\",\n+\t\tMaxAge:        3600,\n+\t\tExposeHeaders: \"X-Request-ID\",\n+\t\tAllowHeaders:  \"Authentication\",\n+\t}))\n+\t// Get handler pointer\n+\thandler := app.Handler()\n+\n+\t// Make request\n+\tctx := &fasthttp.RequestCtx{}\n+\tctx.Request.SetRequestURI(\"/\")\n+\tctx.Request.Header.Set(fiber.HeaderOrigin, \"http://localhost\")\n+\tctx.Request.Header.SetMethod(fiber.MethodOptions)\n+\n+\t// Perform request\n+\thandler(ctx)\n+\n+\t// Check result\n+\tutils.AssertEqual(t, \"*\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowOrigin))) // Validates request is not reflecting origin in the response\n+\tutils.AssertEqual(t, \"\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowCredentials)))\n+\tutils.AssertEqual(t, \"3600\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlMaxAge)))\n+\tutils.AssertEqual(t, \"Authentication\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowHeaders)))\n+\n+\t// Test non OPTIONS (preflight) response headers\n+\tctx = &fasthttp.RequestCtx{}\n+\tctx.Request.Header.SetMethod(fiber.MethodGet)\n+\thandler(ctx)\n+\n+\tutils.AssertEqual(t, \"\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowCredentials)))\n+\tutils.AssertEqual(t, \"X-Request-ID\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlExposeHeaders)))\n+}\n+\n+// go test -run -v Test_CORS_Origin_AllowCredentials\n+func Test_CORS_Origin_AllowCredentials(t *testing.T) {\n+\tt.Parallel()\n+\t// New fiber instance\n+\tapp := fiber.New()\n+\t// OPTIONS (preflight) response headers when AllowOrigins is *\n+\tapp.Use(New(Config{\n+\t\tAllowOrigins:     \"http://localhost\",\n \t\tAllowCredentials: true,\n \t\tMaxAge:           3600,\n \t\tExposeHeaders:    \"X-Request-ID\",\n@@ -84,14 +123,14 @@ func Test_CORS_Wildcard(t *testing.T) {\n \t// Make request\n \tctx := &fasthttp.RequestCtx{}\n \tctx.Request.SetRequestURI(\"/\")\n-\tctx.Request.Header.Set(fiber.HeaderOrigin, \"localhost\")\n+\tctx.Request.Header.Set(fiber.HeaderOrigin, \"http://localhost\")\n \tctx.Request.Header.SetMethod(fiber.MethodOptions)\n \n \t// Perform request\n \thandler(ctx)\n \n \t// Check result\n-\tutils.AssertEqual(t, \"*\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowOrigin)))\n+\tutils.AssertEqual(t, \"http://localhost\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowOrigin)))\n \tutils.AssertEqual(t, \"true\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowCredentials)))\n \tutils.AssertEqual(t, \"3600\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlMaxAge)))\n \tutils.AssertEqual(t, \"Authentication\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowHeaders)))\n@@ -105,6 +144,57 @@ func Test_CORS_Wildcard(t *testing.T) {\n \tutils.AssertEqual(t, \"X-Request-ID\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlExposeHeaders)))\n }\n \n+// go test -run -v Test_CORS_Wildcard_AllowCredentials_Panic\n+// Test for fiber-ghsa-fmg4-x8pw-hjhg\n+func Test_CORS_Wildcard_AllowCredentials_Panic(t *testing.T) {\n+\tt.Parallel()\n+\t// New fiber instance\n+\tapp := fiber.New()\n+\n+\tdidPanic := false\n+\tfunc() {\n+\t\tdefer func() {\n+\t\t\tif r := recover(); r != nil {\n+\t\t\t\tdidPanic = true\n+\t\t\t}\n+\t\t}()\n+\n+\t\tapp.Use(New(Config{\n+\t\t\tAllowOrigins:     \"*\",\n+\t\t\tAllowCredentials: true,\n+\t\t}))\n+\t}()\n+\n+\tif !didPanic {\n+\t\tt.Errorf(\"Expected a panic when AllowOrigins is '*' and AllowCredentials is true\")\n+\t}\n+}\n+\n+// go test -run -v Test_CORS_Invalid_Origin_Panic\n+func Test_CORS_Invalid_Origin_Panic(t *testing.T) {\n+\tt.Parallel()\n+\t// New fiber instance\n+\tapp := fiber.New()\n+\n+\tdidPanic := false\n+\tfunc() {\n+\t\tdefer func() {\n+\t\t\tif r := recover(); r != nil {\n+\t\t\t\tdidPanic = true\n+\t\t\t}\n+\t\t}()\n+\n+\t\tapp.Use(New(Config{\n+\t\t\tAllowOrigins:     \"localhost\",\n+\t\t\tAllowCredentials: true,\n+\t\t}))\n+\t}()\n+\n+\tif !didPanic {\n+\t\tt.Errorf(\"Expected a panic when Origin is missing scheme\")\n+\t}\n+}\n+\n // go test -run -v Test_CORS_Subdomain\n func Test_CORS_Subdomain(t *testing.T) {\n \tt.Parallel()\n@@ -193,12 +283,9 @@ func Test_CORS_AllowOriginScheme(t *testing.T) {\n \t\t\tshouldAllowOrigin: false,\n \t\t},\n \t\t{\n-\t\t\tpattern: \"http://*.example.com\",\n-\t\t\treqOrigin: `http://1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890\\\n-\t\t  .1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890\\\n-\t\t  .1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890\\\n-\t\t\t.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.example.com`,\n-\t\t\tshouldAllowOrigin: false,\n+\t\t\tpattern:           \"http://*.example.com\",\n+\t\t\treqOrigin:         \"http://1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.1234567890.example.com\",\n+\t\t\tshouldAllowOrigin: true,\n \t\t},\n \t\t{\n \t\t\tpattern:           \"http://example.com\",\n@@ -471,12 +558,13 @@ func Test_CORS_AllowOriginsAndAllowOriginsFunc_AllUseCases(t *testing.T) {\n }\n \n // The fix for issue #2422\n-func Test_CORS_AllowCredetials(t *testing.T) {\n+func Test_CORS_AllowCredentials(t *testing.T) {\n \ttestCases := []struct {\n-\t\tName           string\n-\t\tConfig         Config\n-\t\tRequestOrigin  string\n-\t\tResponseOrigin string\n+\t\tName                string\n+\t\tConfig              Config\n+\t\tRequestOrigin       string\n+\t\tResponseOrigin      string\n+\t\tResponseCredentials string\n \t}{\n \t\t{\n \t\t\tName: \"AllowOriginsFuncDefined\",\n@@ -488,37 +576,55 @@ func Test_CORS_AllowCredetials(t *testing.T) {\n \t\t\t},\n \t\t\tRequestOrigin: \"http://aaa.com\",\n \t\t\t// The AllowOriginsFunc config was defined, should use the real origin of the function\n-\t\t\tResponseOrigin: \"http://aaa.com\",\n+\t\t\tResponseOrigin:      \"http://aaa.com\",\n+\t\t\tResponseCredentials: \"true\",\n \t\t},\n \t\t{\n-\t\t\tName: \"AllowOriginsFuncNotDefined\",\n+\t\t\tName: \"fiber-ghsa-fmg4-x8pw-hjhg-wildcard-credentials\",\n \t\t\tConfig: Config{\n \t\t\t\tAllowCredentials: true,\n+\t\t\t\tAllowOriginsFunc: func(origin string) bool {\n+\t\t\t\t\treturn true\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tRequestOrigin:  \"*\",\n+\t\t\tResponseOrigin: \"*\",\n+\t\t\t// Middleware will validate that wildcard wont set credentials to true\n+\t\t\tResponseCredentials: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tName: \"AllowOriginsFuncNotDefined\",\n+\t\t\tConfig: Config{\n+\t\t\t\t// Setting this to true will cause the middleware to panic since default AllowOrigins is \"*\"\n+\t\t\t\tAllowCredentials: false,\n \t\t\t},\n \t\t\tRequestOrigin: \"http://aaa.com\",\n \t\t\t// None of the AllowOrigins or AllowOriginsFunc config was defined, should use the default origin of \"*\"\n \t\t\t// which will cause the CORS error in the client:\n \t\t\t// The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*'\n \t\t\t// when the request's credentials mode is 'include'.\n-\t\t\tResponseOrigin: \"*\",\n+\t\t\tResponseOrigin:      \"*\",\n+\t\t\tResponseCredentials: \"\",\n \t\t},\n \t\t{\n \t\t\tName: \"AllowOriginsDefined\",\n \t\t\tConfig: Config{\n \t\t\t\tAllowCredentials: true,\n \t\t\t\tAllowOrigins:     \"http://aaa.com\",\n \t\t\t},\n-\t\t\tRequestOrigin:  \"http://aaa.com\",\n-\t\t\tResponseOrigin: \"http://aaa.com\",\n+\t\t\tRequestOrigin:       \"http://aaa.com\",\n+\t\t\tResponseOrigin:      \"http://aaa.com\",\n+\t\t\tResponseCredentials: \"true\",\n \t\t},\n \t\t{\n \t\t\tName: \"AllowOriginsDefined/UnallowedOrigin\",\n \t\t\tConfig: Config{\n \t\t\t\tAllowCredentials: true,\n \t\t\t\tAllowOrigins:     \"http://aaa.com\",\n \t\t\t},\n-\t\t\tRequestOrigin:  \"http://bbb.com\",\n-\t\t\tResponseOrigin: \"\",\n+\t\t\tRequestOrigin:       \"http://bbb.com\",\n+\t\t\tResponseOrigin:      \"\",\n+\t\t\tResponseCredentials: \"\",\n \t\t},\n \t}\n \n@@ -536,9 +642,7 @@ func Test_CORS_AllowCredetials(t *testing.T) {\n \n \t\t\thandler(ctx)\n \n-\t\t\tif tc.Config.AllowCredentials {\n-\t\t\t\tutils.AssertEqual(t, \"true\", string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowCredentials)))\n-\t\t\t}\n+\t\t\tutils.AssertEqual(t, tc.ResponseCredentials, string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowCredentials)))\n \t\t\tutils.AssertEqual(t, tc.ResponseOrigin, string(ctx.Response.Header.Peek(fiber.HeaderAccessControlAllowOrigin)))\n \t\t})\n \t}"
        },
        {
          "filename": "middleware/cors/utils.go",
          "status": "modified",
          "additions": 63,
          "deletions": 36,
          "patch": "@@ -1,56 +1,83 @@\n package cors\n \n import (\n+\t\"net/url\"\n \t\"strings\"\n )\n \n+// matchScheme compares the scheme of the domain and pattern\n func matchScheme(domain, pattern string) bool {\n \tdidx := strings.Index(domain, \":\")\n \tpidx := strings.Index(pattern, \":\")\n \treturn didx != -1 && pidx != -1 && domain[:didx] == pattern[:pidx]\n }\n \n-// matchSubdomain compares authority with wildcard\n-func matchSubdomain(domain, pattern string) bool {\n-\tif !matchScheme(domain, pattern) {\n-\t\treturn false\n+// validateDomain checks if the domain matches the pattern\n+func validateDomain(domain, pattern string) bool {\n+\t// Directly compare the domain and pattern for an exact match.\n+\tif domain == pattern {\n+\t\treturn true\n \t}\n-\tdidx := strings.Index(domain, \"://\")\n-\tpidx := strings.Index(pattern, \"://\")\n-\tif didx == -1 || pidx == -1 {\n-\t\treturn false\n+\n+\t// Normalize domain and pattern to exclude schemes and ports for matching purposes\n+\tnormalizedDomain := normalizeDomain(domain)\n+\tnormalizedPattern := normalizeDomain(pattern)\n+\n+\t// Handling the case where pattern is a wildcard subdomain pattern.\n+\tif strings.HasPrefix(normalizedPattern, \"*.\") {\n+\t\t// Trim leading \"*.\" from pattern for comparison.\n+\t\ttrimmedPattern := normalizedPattern[2:]\n+\n+\t\t// Check if the domain ends with the trimmed pattern.\n+\t\tif strings.HasSuffix(normalizedDomain, trimmedPattern) {\n+\t\t\t// Ensure that the domain is not exactly the base domain.\n+\t\t\tif normalizedDomain != trimmedPattern {\n+\t\t\t\t// Special handling to prevent \"example.com\" matching \"*.example.com\".\n+\t\t\t\tif strings.TrimSuffix(normalizedDomain, trimmedPattern) != \"\" {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n-\tdomAuth := domain[didx+3:]\n-\t// to avoid long loop by invalid long domain\n-\tconst maxDomainLen = 253\n-\tif len(domAuth) > maxDomainLen {\n-\t\treturn false\n+\n+\treturn false\n+}\n+\n+// normalizeDomain removes the scheme and port from the input domain\n+func normalizeDomain(input string) string {\n+\t// Remove scheme\n+\tinput = strings.TrimPrefix(strings.TrimPrefix(input, \"http://\"), \"https://\")\n+\n+\t// Find and remove port, if present\n+\tif portIndex := strings.Index(input, \":\"); portIndex != -1 {\n+\t\tinput = input[:portIndex]\n \t}\n-\tpatAuth := pattern[pidx+3:]\n-\n-\tdomComp := strings.Split(domAuth, \".\")\n-\tpatComp := strings.Split(patAuth, \".\")\n-\tconst divHalf = 2\n-\tfor i := len(domComp)/divHalf - 1; i >= 0; i-- {\n-\t\topp := len(domComp) - 1 - i\n-\t\tdomComp[i], domComp[opp] = domComp[opp], domComp[i]\n+\n+\treturn input\n+}\n+\n+// normalizeOrigin checks if the provided origin is in a correct format\n+// and normalizes it by removing any path or trailing slash.\n+// It returns a boolean indicating whether the origin is valid\n+// and the normalized origin.\n+func normalizeOrigin(origin string) (bool, string) {\n+\tparsedOrigin, err := url.Parse(origin)\n+\tif err != nil {\n+\t\treturn false, \"\"\n \t}\n-\tfor i := len(patComp)/divHalf - 1; i >= 0; i-- {\n-\t\topp := len(patComp) - 1 - i\n-\t\tpatComp[i], patComp[opp] = patComp[opp], patComp[i]\n+\n+\t// Validate the scheme is either http or https\n+\tif parsedOrigin.Scheme != \"http\" && parsedOrigin.Scheme != \"https\" {\n+\t\treturn false, \"\"\n \t}\n \n-\tfor i, v := range domComp {\n-\t\tif len(patComp) <= i {\n-\t\t\treturn false\n-\t\t}\n-\t\tp := patComp[i]\n-\t\tif p == \"*\" {\n-\t\t\treturn true\n-\t\t}\n-\t\tif p != v {\n-\t\t\treturn false\n-\t\t}\n+\t// Validate there is a host present. The presence of a path, query, or fragment components\n+\t// is checked, but a trailing \"/\" (indicative of the root) is allowed for the path and will be normalized\n+\tif parsedOrigin.Host == \"\" || (parsedOrigin.Path != \"\" && parsedOrigin.Path != \"/\") || parsedOrigin.RawQuery != \"\" || parsedOrigin.Fragment != \"\" {\n+\t\treturn false, \"\"\n \t}\n-\treturn false\n+\n+\t// Normalize the origin by constructing it from the scheme and host.\n+\t// The path or trailing slash is not included in the normalized origin.\n+\treturn true, strings.ToLower(parsedOrigin.Scheme) + \"://\" + strings.ToLower(parsedOrigin.Host)\n }"
        },
        {
          "filename": "middleware/cors/utils_test.go",
          "status": "added",
          "additions": 145,
          "deletions": 0,
          "patch": "@@ -0,0 +1,145 @@\n+package cors\n+\n+import (\n+\t\"testing\"\n+)\n+\n+// go test -run -v Test_normalizeOrigin\n+func Test_normalizeOrigin(t *testing.T) {\n+\ttestCases := []struct {\n+\t\torigin         string\n+\t\texpectedValid  bool\n+\t\texpectedOrigin string\n+\t}{\n+\t\t{\"http://example.com\", true, \"http://example.com\"},            // Simple case should work.\n+\t\t{\"http://example.com/\", true, \"http://example.com\"},           // Trailing slash should be removed.\n+\t\t{\"http://example.com:3000\", true, \"http://example.com:3000\"},  // Port should be preserved.\n+\t\t{\"http://example.com:3000/\", true, \"http://example.com:3000\"}, // Trailing slash should be removed.\n+\t\t{\"http://\", false, \"\"},                                                   // Invalid origin should not be accepted.\n+\t\t{\"http://example.com/path\", false, \"\"},                                   // Path should not be accepted.\n+\t\t{\"http://example.com?query=123\", false, \"\"},                              // Query should not be accepted.\n+\t\t{\"http://example.com#fragment\", false, \"\"},                               // Fragment should not be accepted.\n+\t\t{\"http://localhost\", true, \"http://localhost\"},                           // Localhost should be accepted.\n+\t\t{\"http://127.0.0.1\", true, \"http://127.0.0.1\"},                           // IPv4 address should be accepted.\n+\t\t{\"http://[::1]\", true, \"http://[::1]\"},                                   // IPv6 address should be accepted.\n+\t\t{\"http://[::1]:8080\", true, \"http://[::1]:8080\"},                         // IPv6 address with port should be accepted.\n+\t\t{\"http://[::1]:8080/\", true, \"http://[::1]:8080\"},                        // IPv6 address with port and trailing slash should be accepted.\n+\t\t{\"http://[::1]:8080/path\", false, \"\"},                                    // IPv6 address with port and path should not be accepted.\n+\t\t{\"http://[::1]:8080?query=123\", false, \"\"},                               // IPv6 address with port and query should not be accepted.\n+\t\t{\"http://[::1]:8080#fragment\", false, \"\"},                                // IPv6 address with port and fragment should not be accepted.\n+\t\t{\"http://[::1]:8080/path?query=123#fragment\", false, \"\"},                 // IPv6 address with port, path, query, and fragment should not be accepted.\n+\t\t{\"http://[::1]:8080/path?query=123#fragment/\", false, \"\"},                // IPv6 address with port, path, query, fragment, and trailing slash should not be accepted.\n+\t\t{\"http://[::1]:8080/path?query=123#fragment/invalid\", false, \"\"},         // IPv6 address with port, path, query, fragment, trailing slash, and invalid segment should not be accepted.\n+\t\t{\"http://[::1]:8080/path?query=123#fragment/invalid/\", false, \"\"},        // IPv6 address with port, path, query, fragment, trailing slash, and invalid segment with trailing slash should not be accepted.\n+\t\t{\"http://[::1]:8080/path?query=123#fragment/invalid/segment\", false, \"\"}, // IPv6 address with port, path, query, fragment, trailing slash, and invalid segment with additional segment should not be accepted.\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tvalid, normalizedOrigin := normalizeOrigin(tc.origin)\n+\n+\t\tif valid != tc.expectedValid {\n+\t\t\tt.Errorf(\"Expected origin '%s' to be valid: %v, but got: %v\", tc.origin, tc.expectedValid, valid)\n+\t\t}\n+\n+\t\tif normalizedOrigin != tc.expectedOrigin {\n+\t\t\tt.Errorf(\"Expected normalized origin '%s' for origin '%s', but got: '%s'\", tc.expectedOrigin, tc.origin, normalizedOrigin)\n+\t\t}\n+\t}\n+}\n+\n+// go test -run -v Test_matchScheme\n+func Test_matchScheme(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tdomain   string\n+\t\tpattern  string\n+\t\texpected bool\n+\t}{\n+\t\t{\"http://example.com\", \"http://example.com\", true},           // Exact match should work.\n+\t\t{\"https://example.com\", \"http://example.com\", false},         // Scheme mismatch should matter.\n+\t\t{\"http://example.com\", \"https://example.com\", false},         // Scheme mismatch should matter.\n+\t\t{\"http://example.com\", \"http://example.org\", true},           // Different domains should not matter.\n+\t\t{\"http://example.com\", \"http://example.com:8080\", true},      // Port should not matter.\n+\t\t{\"http://example.com:8080\", \"http://example.com\", true},      // Port should not matter.\n+\t\t{\"http://example.com:8080\", \"http://example.com:8081\", true}, // Different ports should not matter.\n+\t\t{\"http://localhost\", \"http://localhost\", true},               // Localhost should match.\n+\t\t{\"http://127.0.0.1\", \"http://127.0.0.1\", true},               // IPv4 address should match.\n+\t\t{\"http://[::1]\", \"http://[::1]\", true},                       // IPv6 address should match.\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tresult := matchScheme(tc.domain, tc.pattern)\n+\n+\t\tif result != tc.expected {\n+\t\t\tt.Errorf(\"Expected matchScheme('%s', '%s') to be %v, but got %v\", tc.domain, tc.pattern, tc.expected, result)\n+\t\t}\n+\t}\n+}\n+\n+// go test -run -v Test_validateOrigin\n+func Test_validateOrigin(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tdomain   string\n+\t\tpattern  string\n+\t\texpected bool\n+\t}{\n+\t\t{\"http://example.com\", \"http://example.com\", true},            // Exact match should work.\n+\t\t{\"https://example.com\", \"http://example.com\", false},          // Scheme mismatch should matter in CORS context.\n+\t\t{\"http://example.com\", \"https://example.com\", false},          // Scheme mismatch should matter in CORS context.\n+\t\t{\"http://example.com\", \"http://example.org\", false},           // Different domains should not match.\n+\t\t{\"http://example.com\", \"http://example.com:8080\", false},      // Port mismatch should matter.\n+\t\t{\"http://example.com:8080\", \"http://example.com\", false},      // Port mismatch should matter.\n+\t\t{\"http://example.com:8080\", \"http://example.com:8081\", false}, // Different ports should not match.\n+\t\t{\"example.com\", \"example.com\", true},                          // Simplified form, assuming scheme and port are not considered here, but in practice, they are part of the origin.\n+\t\t{\"sub.example.com\", \"example.com\", false},                     // Subdomain should not match the base domain directly.\n+\t\t{\"sub.example.com\", \"*.example.com\", true},                    // Correct assumption for wildcard subdomain matching.\n+\t\t{\"example.com\", \"*.example.com\", false},                       // Base domain should not match its wildcard subdomain pattern.\n+\t\t{\"sub.example.com\", \"*.com\", true},                            // Technically correct for pattern matching, but broad wildcard use like this is not recommended for CORS.\n+\t\t{\"sub.sub.example.com\", \"*.example.com\", true},                // Nested subdomain should match the wildcard pattern.\n+\t\t{\"example.com\", \"*.org\", false},                               // Different TLDs should not match.\n+\t\t{\"example.com\", \"example.org\", false},                         // Different domains should not match.\n+\t\t{\"example.com:8080\", \"*.example.com\", false},                  // Different ports mean different origins.\n+\t\t{\"example.com\", \"sub.example.net\", false},                     // Different domains should not match.\n+\t\t{\"http://localhost\", \"http://localhost\", true},                // Localhost should match.\n+\t\t{\"http://127.0.0.1\", \"http://127.0.0.1\", true},                // IPv4 address should match.\n+\t\t{\"http://[::1]\", \"http://[::1]\", true},                        // IPv6 address should match.\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tresult := validateDomain(tc.domain, tc.pattern)\n+\n+\t\tif result != tc.expected {\n+\t\t\tt.Errorf(\"Expected validateOrigin('%s', '%s') to be %v, but got %v\", tc.domain, tc.pattern, tc.expected, result)\n+\t\t}\n+\t}\n+}\n+\n+// go test -run -v Test_normalizeDomain\n+func Test_normalizeDomain(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tinput          string\n+\t\texpectedOutput string\n+\t}{\n+\t\t{\"http://example.com\", \"example.com\"},                     // Simple case with http scheme.\n+\t\t{\"https://example.com\", \"example.com\"},                    // Simple case with https scheme.\n+\t\t{\"http://example.com:3000\", \"example.com\"},                // Case with port.\n+\t\t{\"https://example.com:3000\", \"example.com\"},               // Case with port and https scheme.\n+\t\t{\"http://example.com/path\", \"example.com/path\"},           // Case with path.\n+\t\t{\"http://example.com?query=123\", \"example.com?query=123\"}, // Case with query.\n+\t\t{\"http://example.com#fragment\", \"example.com#fragment\"},   // Case with fragment.\n+\t\t{\"example.com\", \"example.com\"},                            // Case without scheme.\n+\t\t{\"example.com:8080\", \"example.com\"},                       // Case without scheme but with port.\n+\t\t{\"sub.example.com\", \"sub.example.com\"},                    // Case with subdomain.\n+\t\t{\"sub.sub.example.com\", \"sub.sub.example.com\"},            // Case with nested subdomain.\n+\t\t{\"http://localhost\", \"localhost\"},                         // Case with localhost.\n+\t\t{\"http://127.0.0.1\", \"127.0.0.1\"},                         // Case with IPv4 address.\n+\t\t{\"http://[::1]\", \"[::1]\"},                                 // Case with IPv6 address.\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\toutput := normalizeDomain(tc.input)\n+\n+\t\tif output != tc.expectedOutput {\n+\t\t\tt.Errorf(\"Expected normalized domain '%s' for input '%s', but got: '%s'\", tc.expectedOutput, tc.input, output)\n+\t\t}\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "44b971ace579437b8792025ec14e972630386b90",
            "date": "2025-01-14T02:37:29Z",
            "author_login": "gaby"
          },
          {
            "sha": "4e5fea1d7a830a52cbe736d2da88660a2e959549",
            "date": "2025-01-13T13:18:03Z",
            "author_login": "grivera64"
          },
          {
            "sha": "6c7473b842148a0a59bc2c0d511f330373fa3fde",
            "date": "2025-01-10T12:46:21Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "bc37f209bfef66d8ff84dc7d13dc066107eb3d9c",
            "date": "2025-01-08T07:19:20Z",
            "author_login": "ReneWerner87"
          },
          {
            "sha": "86d72bbba8b5998bb4583f3bff110ede1391d795",
            "date": "2025-01-07T18:20:53Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L",
    "cwe_id": "CWE-346",
    "description": "Fiber is a web framework written in go. Prior to version 2.52.1, the CORS middleware allows for insecure configurations that could potentially expose the application to multiple CORS-related vulnerabilities. Specifically, it allows setting the Access-Control-Allow-Origin header to a wildcard (`*`) while also having the Access-Control-Allow-Credentials set to true, which goes against recommended security best practices. The impact of this misconfiguration is high as it can lead to unauthorized access to sensitive user data and expose the system to various types of attacks listed in the PortSwigger article linked in the references. Version 2.52.1 contains a patch for this issue. As a workaround, users may manually validate the CORS configurations in their implementation to ensure that they do not allow a wildcard origin when credentials are enabled. The browser fetch api, as well as browsers and utilities that enforce CORS policies, are not affected by this.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-21T21:15:09.250",
    "last_modified": "2024-11-21T09:00:18.337",
    "fix_date": "2024-02-21T13:47:33Z"
  },
  "references": [
    {
      "url": "http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://codeql.github.com/codeql-query-help/javascript/js-cors-misconfiguration-for-credentials",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSNotSupportingCredentials",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://fetch.spec.whatwg.org/#cors-protocol-and-credentials",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/commit/f0cd3b44b086544a37886232d0530601f2406c23",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/releases/tag/v2.52.1",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/security/advisories/GHSA-fmg4-x8pw-hjhg",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://saturncloud.io/blog/cors-cannot-use-wildcard-in-accesscontrolalloworigin-when-credentials-flag-is-true",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://codeql.github.com/codeql-query-help/javascript/js-cors-misconfiguration-for-credentials",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSNotSupportingCredentials",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://fetch.spec.whatwg.org/#cors-protocol-and-credentials",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/commit/f0cd3b44b086544a37886232d0530601f2406c23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/releases/tag/v2.52.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/security/advisories/GHSA-fmg4-x8pw-hjhg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://saturncloud.io/blog/cors-cannot-use-wildcard-in-accesscontrolalloworigin-when-credentials-flag-is-true",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.146140",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fiber",
    "owner": "gofiber",
    "created_at": "2020-01-16T03:59:20Z",
    "updated_at": "2025-01-14T12:32:36Z",
    "pushed_at": "2025-01-14T02:37:36Z",
    "size": 229934,
    "stars": 34637,
    "forks": 1696,
    "open_issues": 100,
    "watchers": 34637,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v2"
    ],
    "languages": {
      "Go": 1562365,
      "Makefile": 1868
    },
    "commit_activity": {
      "total_commits_last_year": 253,
      "avg_commits_per_week": 4.865384615384615,
      "days_active_last_year": 141
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:42:58.049694"
  }
}