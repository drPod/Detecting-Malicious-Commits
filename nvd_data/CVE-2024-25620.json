{
  "cve_id": "CVE-2024-25620",
  "github_data": {
    "repository": "helm/helm",
    "fix_commit": "0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503",
    "related_commits": [
      "0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503",
      "0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503"
    ],
    "patch_url": "https://github.com/helm/helm/commit/0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503.patch",
    "fix_commit_details": {
      "sha": "0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503",
      "commit_date": "2024-02-14T19:55:14Z",
      "author": {
        "login": "mattfarina",
        "type": "User",
        "stats": {
          "total_commits": 181,
          "average_weekly_commits": 0.3762993762993763,
          "total_additions": 9691,
          "total_deletions": 10129,
          "weeks_active": 111
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-v53g-5gjp-272r",
        "length": 59,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 112,
        "additions": 112,
        "deletions": 0
      },
      "files": [
        {
          "filename": "pkg/chart/metadata.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -16,6 +16,7 @@ limitations under the License.\n package chart\n \n import (\n+\t\"path/filepath\"\n \t\"strings\"\n \t\"unicode\"\n \n@@ -110,6 +111,11 @@ func (md *Metadata) Validate() error {\n \tif md.Name == \"\" {\n \t\treturn ValidationError(\"chart.metadata.name is required\")\n \t}\n+\n+\tif md.Name != filepath.Base(md.Name) {\n+\t\treturn ValidationErrorf(\"chart.metadata.name %q is invalid\", md.Name)\n+\t}\n+\n \tif md.Version == \"\" {\n \t\treturn ValidationError(\"chart.metadata.version is required\")\n \t}"
        },
        {
          "filename": "pkg/chart/metadata_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -40,6 +40,11 @@ func TestValidate(t *testing.T) {\n \t\t\t&Metadata{APIVersion: \"v2\", Version: \"1.0\"},\n \t\t\tValidationError(\"chart.metadata.name is required\"),\n \t\t},\n+\t\t{\n+\t\t\t\"chart without name\",\n+\t\t\t&Metadata{Name: \"../../test\", APIVersion: \"v2\", Version: \"1.0\"},\n+\t\t\tValidationError(\"chart.metadata.name \\\"../../test\\\" is invalid\"),\n+\t\t},\n \t\t{\n \t\t\t\"chart without version\",\n \t\t\t&Metadata{Name: \"test\", APIVersion: \"v2\"},"
        },
        {
          "filename": "pkg/chartutil/errors.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -33,3 +33,11 @@ type ErrNoValue struct {\n }\n \n func (e ErrNoValue) Error() string { return fmt.Sprintf(\"%q is not a value\", e.Key) }\n+\n+type ErrInvalidChartName struct {\n+\tName string\n+}\n+\n+func (e ErrInvalidChartName) Error() string {\n+\treturn fmt.Sprintf(\"%q is not a valid chart name\", e.Name)\n+}"
        },
        {
          "filename": "pkg/chartutil/save.go",
          "status": "modified",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -39,6 +39,10 @@ var headerBytes = []byte(\"+aHR0cHM6Ly95b3V0dS5iZS96OVV6MWljandyTQo=\")\n // directory, writing the chart's contents to that subdirectory.\n func SaveDir(c *chart.Chart, dest string) error {\n \t// Create the chart directory\n+\terr := validateName(c.Name())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \toutdir := filepath.Join(dest, c.Name())\n \tif fi, err := os.Stat(outdir); err == nil && !fi.IsDir() {\n \t\treturn errors.Errorf(\"file %s already exists and is not a directory\", outdir)\n@@ -149,6 +153,10 @@ func Save(c *chart.Chart, outDir string) (string, error) {\n }\n \n func writeTarContents(out *tar.Writer, c *chart.Chart, prefix string) error {\n+\terr := validateName(c.Name())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tbase := filepath.Join(prefix, c.Name())\n \n \t// Pull out the dependencies of a v1 Chart, since there's no way\n@@ -242,3 +250,15 @@ func writeToTar(out *tar.Writer, name string, body []byte) error {\n \t_, err := out.Write(body)\n \treturn err\n }\n+\n+// If the name has directory name has characters which would change the location\n+// they need to be removed.\n+func validateName(name string) error {\n+\tnname := filepath.Base(name)\n+\n+\tif nname != name {\n+\t\treturn ErrInvalidChartName{name}\n+\t}\n+\n+\treturn nil\n+}"
        },
        {
          "filename": "pkg/chartutil/save_test.go",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -106,6 +106,24 @@ func TestSave(t *testing.T) {\n \t\t\t}\n \t\t})\n \t}\n+\n+\tc := &chart.Chart{\n+\t\tMetadata: &chart.Metadata{\n+\t\t\tAPIVersion: chart.APIVersionV1,\n+\t\t\tName:       \"../ahab\",\n+\t\t\tVersion:    \"1.2.3\",\n+\t\t},\n+\t\tLock: &chart.Lock{\n+\t\t\tDigest: \"testdigest\",\n+\t\t},\n+\t\tFiles: []*chart.File{\n+\t\t\t{Name: \"scheherazade/shahryar.txt\", Data: []byte(\"1,001 Nights\")},\n+\t\t},\n+\t}\n+\t_, err := Save(c, tmp)\n+\tif err == nil {\n+\t\tt.Fatal(\"Expected error saving chart with invalid name\")\n+\t}\n }\n \n // Creates a copy with a different schema; does not modify anything.\n@@ -232,4 +250,15 @@ func TestSaveDir(t *testing.T) {\n \tif len(c2.Files) != 1 || c2.Files[0].Name != c.Files[0].Name {\n \t\tt.Fatal(\"Files data did not match\")\n \t}\n+\n+\ttmp2 := t.TempDir()\n+\tc.Metadata.Name = \"../ahab\"\n+\tpth := filepath.Join(tmp2, \"tmpcharts\")\n+\tif err := os.MkdirAll(filepath.Join(pth), 0755); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif err := SaveDir(c, pth); err.Error() != \"\\\"../ahab\\\" is not a valid chart name\" {\n+\t\tt.Fatalf(\"Did not get expected error for chart named %q\", c.Name())\n+\t}\n }"
        },
        {
          "filename": "pkg/downloader/manager_test.go",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -262,6 +262,32 @@ func TestDownloadAll(t *testing.T) {\n \tif _, err := os.Stat(filepath.Join(chartPath, \"charts\", \"signtest-0.1.0.tgz\")); os.IsNotExist(err) {\n \t\tt.Error(err)\n \t}\n+\n+\t// A chart with a bad name like this cannot be loaded and saved. Handling in\n+\t// the loading and saving will return an error about the invalid name. In\n+\t// this case, the chart needs to be created directly.\n+\tbadchartyaml := `apiVersion: v2\n+description: A Helm chart for Kubernetes\n+name: ../bad-local-subchart\n+version: 0.1.0`\n+\tif err := os.MkdirAll(filepath.Join(chartPath, \"testdata\", \"bad-local-subchart\"), 0755); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\terr = os.WriteFile(filepath.Join(chartPath, \"testdata\", \"bad-local-subchart\", \"Chart.yaml\"), []byte(badchartyaml), 0644)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tbadLocalDep := &chart.Dependency{\n+\t\tName:       \"../bad-local-subchart\",\n+\t\tRepository: \"file://./testdata/bad-local-subchart\",\n+\t\tVersion:    \"0.1.0\",\n+\t}\n+\n+\terr = m.downloadAll([]*chart.Dependency{badLocalDep})\n+\tif err == nil {\n+\t\tt.Fatal(\"Expected error for bad dependency name\")\n+\t}\n }\n \n func TestUpdateBeforeBuild(t *testing.T) {"
        },
        {
          "filename": "pkg/lint/rules/chartfile.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -106,6 +106,10 @@ func validateChartName(cf *chart.Metadata) error {\n \tif cf.Name == \"\" {\n \t\treturn errors.New(\"name is required\")\n \t}\n+\tname := filepath.Base(cf.Name)\n+\tif name != cf.Name {\n+\t\treturn fmt.Errorf(\"chart name %q is invalid\", cf.Name)\n+\t}\n \treturn nil\n }\n "
        },
        {
          "filename": "pkg/lint/rules/chartfile_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -30,16 +30,19 @@ import (\n )\n \n const (\n+\tbadCharNametDir    = \"testdata/badchartname\"\n \tbadChartDir        = \"testdata/badchartfile\"\n \tanotherBadChartDir = \"testdata/anotherbadchartfile\"\n )\n \n var (\n+\tbadChartNamePath         = filepath.Join(badCharNametDir, \"Chart.yaml\")\n \tbadChartFilePath         = filepath.Join(badChartDir, \"Chart.yaml\")\n \tnonExistingChartFilePath = filepath.Join(os.TempDir(), \"Chart.yaml\")\n )\n \n var badChart, _ = chartutil.LoadChartfile(badChartFilePath)\n+var badChartName, _ = chartutil.LoadChartfile(badChartNamePath)\n \n // Validation functions Test\n func TestValidateChartYamlNotDirectory(t *testing.T) {\n@@ -69,6 +72,11 @@ func TestValidateChartName(t *testing.T) {\n \tif err == nil {\n \t\tt.Errorf(\"validateChartName to return a linter error, got no error\")\n \t}\n+\n+\terr = validateChartName(badChartName)\n+\tif err == nil {\n+\t\tt.Error(\"expected validateChartName to return a linter error for an invalid name, got no error\")\n+\t}\n }\n \n func TestValidateChartVersion(t *testing.T) {"
        },
        {
          "filename": "pkg/lint/rules/testdata/badchartname/Chart.yaml",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+apiVersion: v2\n+description: A Helm chart for Kubernetes\n+version: 0.1.0\n+name: \"../badchartname\"\n+type: application"
        },
        {
          "filename": "pkg/lint/rules/testdata/badchartname/values.yaml",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+# Default values for badchartfile."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 6,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fb54996b001697513cdb1ffa5915c0ba90149fff",
            "date": "2025-01-14T02:16:44Z",
            "author_login": "sabre1041"
          },
          {
            "sha": "7dac0157a78e5ba6ad607cf1b1fc598b98ef5dfd",
            "date": "2025-01-13T18:01:22Z",
            "author_login": "robertsirc"
          },
          {
            "sha": "6d42a2973d108a28bff46e38f2afe6a9e98918af",
            "date": "2025-01-11T18:41:47Z",
            "author_login": "shahbazaamir"
          },
          {
            "sha": "bd897c96fbaf7546d6a5c57be009f16f9d38d6de",
            "date": "2025-01-09T00:46:19Z",
            "author_login": "gjenkins8"
          },
          {
            "sha": "ad9768402951f48f61e1ecbea0c1894456d63a2a",
            "date": "2025-01-07T17:09:02Z",
            "author_login": "mattfarina"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-22",
    "description": "Helm is a tool for managing Charts. Charts are packages of pre-configured Kubernetes resources. When either the Helm client or SDK is used to save a chart whose name within the `Chart.yaml` file includes a relative path change, the chart would be saved outside its expected directory based on the changes in the relative path. The validation and linting did not detect the path changes in the name. This issue has been resolved in Helm v3.14.1. Users unable to upgrade should check all charts used by Helm for path changes in their name as found in the `Chart.yaml` file. This includes dependencies.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-15T00:15:45.347",
    "last_modified": "2025-01-09T13:55:40.353",
    "fix_date": "2024-02-14T19:55:14Z"
  },
  "references": [
    {
      "url": "https://github.com/helm/helm/commit/0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/helm/helm/security/advisories/GHSA-v53g-5gjp-272r",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/helm/helm/commit/0d0f91d1ce277b2c8766cdc4c7aa04dbafbf2503",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/helm/helm/security/advisories/GHSA-v53g-5gjp-272r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.126942",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "helm",
    "owner": "helm",
    "created_at": "2015-10-06T01:07:32Z",
    "updated_at": "2025-01-14T12:24:26Z",
    "pushed_at": "2025-01-14T02:16:52Z",
    "size": 22466,
    "stars": 27310,
    "forks": 7159,
    "open_issues": 777,
    "watchers": 27310,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "feat-v3/event-emitter-lua",
      "kube-update-test",
      "main",
      "release-2.0",
      "release-2.1",
      "release-2.2",
      "release-2.3",
      "release-2.4",
      "release-2.5",
      "release-2.6",
      "release-2.7",
      "release-2.8",
      "release-2.9"
    ],
    "languages": {
      "Go": 1934648,
      "Shell": 31103,
      "Makefile": 8742
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:57:31.645568"
  }
}