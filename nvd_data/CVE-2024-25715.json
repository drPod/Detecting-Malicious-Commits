{
  "cve_id": "CVE-2024-25715",
  "github_data": {
    "repository": "babelouest/glewlwyd",
    "fix_commit": "59239381a88c505ab38fe64fdd92f846defa5754",
    "related_commits": [
      "59239381a88c505ab38fe64fdd92f846defa5754",
      "c91c0155f2393274cc18efe77e06c6846e404c75",
      "59239381a88c505ab38fe64fdd92f846defa5754",
      "c91c0155f2393274cc18efe77e06c6846e404c75"
    ],
    "patch_url": "https://github.com/babelouest/glewlwyd/commit/59239381a88c505ab38fe64fdd92f846defa5754.patch",
    "fix_commit_details": {
      "sha": "59239381a88c505ab38fe64fdd92f846defa5754",
      "commit_date": "2024-01-26T19:41:23Z",
      "author": {
        "login": "babelouest",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix PKCE downgrade and open redirection issues",
        "length": 77,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 112,
        "additions": 44,
        "deletions": 68
      },
      "files": [
        {
          "filename": "src/plugin/protocol_oauth2.c",
          "status": "modified",
          "additions": 44,
          "deletions": 68,
          "patch": "@@ -696,7 +696,7 @@ static int is_authorization_type_enabled(struct _oauth2_config * config, uint au\n \n static json_t * check_client_valid(struct _oauth2_config * config, const char * client_id, const char * client_header_login, const char * client_header_password, const char * redirect_uri, unsigned short authorization_type, int implicit_flow, const char * ip_source) {\n   json_t * j_client, * j_element = NULL, * j_return;\n-  int uri_found, authorization_type_enabled;\n+  int uri_found = 0, authorization_type_enabled;\n   size_t index = 0;\n \n   if (client_id == NULL) {\n@@ -707,20 +707,17 @@ static json_t * check_client_valid(struct _oauth2_config * config, const char *\n     return json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n   }\n   j_client = config->glewlwyd_config->glewlwyd_callback_check_client_valid(config->glewlwyd_config, client_id, client_header_password);\n-  if (check_result_value(j_client, G_OK)) {\n+  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n     if (!implicit_flow && client_header_password == NULL && json_object_get(json_object_get(j_client, \"client\"), \"confidential\") == json_true()) {\n       y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error, confidential client must be authentified with its password, origin: %s\", ip_source);\n       j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n     } else {\n       if (redirect_uri != NULL) {\n-        uri_found = 0;\n         json_array_foreach(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), index, j_element) {\n           if (0 == o_strcmp(json_string_value(j_element), redirect_uri)) {\n             uri_found = 1;\n           }\n         }\n-      } else {\n-        uri_found = 1;\n       }\n \n       authorization_type_enabled = 0;\n@@ -938,13 +935,23 @@ static int is_pkce_char_valid(const char * code_challenge) {\n   }\n }\n \n-static int validate_code_challenge(json_t * j_result_code, const char * code_verifier) {\n+static int validate_code_challenge(struct _oauth2_config * config, json_t * j_result_code, const char * code_verifier) {\n   int ret;\n   unsigned char code_verifier_hash[32] = {0}, code_verifier_hash_b64[64] = {0};\n   size_t code_verifier_hash_len = 32, code_verifier_hash_b64_len = 0;\n   gnutls_datum_t key_data;\n \n-  if (!json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) {\n+  if (json_object_get(config->j_params, \"pkce-allowed\") != json_true()) {\n+    if (o_strnullempty(code_verifier)) {\n+      ret = G_OK;\n+    } else {\n+      y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - code_verifier unauthorized\");\n+      ret = G_ERROR_UNAUTHORIZED;\n+    }\n+  } else if ((!o_strnullempty(code_verifier) && json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) || (o_strnullempty(code_verifier) && !json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\")))) {\n+    y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge or code_verifier\");\n+    ret = G_ERROR_UNAUTHORIZED;\n+  } else {\n     if (is_pkce_char_valid(code_verifier)) {\n       if (0 == o_strncmp(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX, json_string_value(json_object_get(j_result_code, \"code_challenge\")), o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX))) {\n         key_data.data = (unsigned char *)code_verifier;\n@@ -955,28 +962,29 @@ static int validate_code_challenge(json_t * j_result_code, const char * code_ver\n             if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\"))+o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX), (const char *)code_verifier_hash_b64)) {\n               ret = G_OK;\n             } else {\n+              y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge value\");\n               ret = G_ERROR_UNAUTHORIZED;\n             }\n           } else {\n-            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error o_base64url_encode\");\n+            y_log_message(Y_LOG_LEVEL_ERROR, \"oidc validate_code_challenge - Error o_base64url_encode\");\n             ret = G_ERROR;\n           }\n         } else {\n-          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error gnutls_fingerprint\");\n+          y_log_message(Y_LOG_LEVEL_ERROR, \"oidc validate_code_challenge - Error gnutls_fingerprint\");\n           ret = G_ERROR;\n         }\n       } else {\n         if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\")), code_verifier)) {\n           ret = G_OK;\n         } else {\n-          ret = G_ERROR_PARAM;\n+          y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge value\");\n+          ret = G_ERROR_UNAUTHORIZED;\n         }\n       }\n     } else {\n-      ret = G_ERROR_PARAM;\n+      y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge character set\");\n+      ret = G_ERROR_UNAUTHORIZED;\n     }\n-  } else {\n-    ret = G_OK;\n   }\n   return ret;\n }\n@@ -1079,7 +1087,7 @@ static json_t * validate_authorization_code(struct _oauth2_config * config, cons\n     if (res == H_OK) {\n       if (json_array_size(j_result)) {\n         if (json_integer_value(json_object_get(json_array_get(j_result, 0), \"enabled\"))) {\n-          if ((res = validate_code_challenge(json_array_get(j_result, 0), code_verifier)) == G_OK) {\n+          if ((res = validate_code_challenge(config, json_array_get(j_result, 0), code_verifier)) == G_OK) {\n             j_query = json_pack(\"{sss[s]s{sO}}\",\n                                 \"table\",\n                                 GLEWLWYD_PLUGIN_OAUTH2_TABLE_CODE_SCOPE,\n@@ -2444,8 +2452,8 @@ static int check_auth_type_auth_code_grant (const struct _u_request * request, s\n   // Check if client is allowed to perform this request\n   if (check_result_value(j_client, G_OK)) {\n     // Client is allowed to use auth_code grant with this redirection_uri\n-    if (u_map_has_key(request->map_url, \"g_continue\")) {\n-      if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n+    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n+      if (u_map_has_key(request->map_url, \"g_continue\")) {\n         j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n         if (check_result_value(j_session, G_OK)) {\n           if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n@@ -2526,26 +2534,20 @@ static int check_auth_type_auth_code_grant (const struct _u_request * request, s\n         }\n         json_decref(j_session);\n       } else {\n-        // Scope is not allowed for this user\n-        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n-        response->status = 302;\n-        redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n+        // Redirect to login page\n+        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n         ulfius_add_header_to_response(response, \"Location\", redirect_url);\n         o_free(redirect_url);\n+        response->status = 302;\n       }\n     } else {\n-      // Redirect to login page\n-      redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n-      ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-      o_free(redirect_url);\n-      response->status = 302;\n+      // Scope is not allowed for this user\n+      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n+      response->status = 403;\n     }\n   } else {\n     // client is not authorized\n-    response->status = 302;\n-    redirect_url = msprintf(\"%s%serror=unauthorized_client%s%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), (u_map_get(request->map_url, \"state\")!=NULL?\"&state=\":\"\"), (u_map_get(request->map_url, \"state\")!=NULL?u_map_get(request->map_url, \"state\"):\"\"));\n-    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-    o_free(redirect_url);\n+    response->status = 403;\n     config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n   }\n   o_free(state_param);\n@@ -2707,8 +2709,8 @@ static int check_auth_type_implicit_grant (const struct _u_request * request, st\n   // Check if client is allowed to perform this request\n   if (check_result_value(j_client, G_OK)) {\n     // Client is allowed to use auth_code grant with this redirection_uri\n-    if (u_map_has_key(request->map_url, \"g_continue\")) {\n-      if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n+    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n+      if (u_map_has_key(request->map_url, \"g_continue\")) {\n         j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n         if (check_result_value(j_session, G_OK)) {\n           if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n@@ -2791,25 +2793,19 @@ static int check_auth_type_implicit_grant (const struct _u_request * request, st\n         }\n         json_decref(j_session);\n       } else {\n-        // Empty scope is not allowed\n-        response->status = 302;\n-        redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n+        // Redirect to login page\n+        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n         ulfius_add_header_to_response(response, \"Location\", redirect_url);\n         o_free(redirect_url);\n+        response->status = 302;\n       }\n     } else {\n-      // Redirect to login page\n-      redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n-      ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-      o_free(redirect_url);\n-      response->status = 302;\n+      // Empty scope is not allowed\n+      response->status = 403;\n     }\n   } else {\n     // client is not authorized\n-    response->status = 302;\n-    redirect_url = msprintf(\"%s%serror=unauthorized_client%s%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), (u_map_get(request->map_url, \"state\")!=NULL?\"&state=\":\"\"), (u_map_get(request->map_url, \"state\")!=NULL?u_map_get(request->map_url, \"state\"):\"\"));\n-    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-    o_free(redirect_url);\n+    response->status = 403;\n   }\n   o_free(state_param);\n   json_decref(j_client);\n@@ -3313,7 +3309,7 @@ static int callback_check_glewlwyd_session_or_token(const struct _u_request * re\n static int callback_oauth2_authorization(const struct _u_request * request, struct _u_response * response, void * user_data) {\n   const char * response_type = u_map_get(request->map_url, \"response_type\");\n   int result = U_CALLBACK_CONTINUE;\n-  char * redirect_url, * state_encoded = NULL, * state_param = NULL;\n+  char * state_encoded = NULL, * state_param = NULL;\n \n   u_map_put(response->map_header, \"Cache-Control\", \"no-store\");\n   u_map_put(response->map_header, \"Pragma\", \"no-cache\");\n@@ -3326,41 +3322,21 @@ static int callback_oauth2_authorization(const struct _u_request * request, stru\n   } else {\n     state_param = o_strdup(\"\");\n   }\n+\n   if (0 == o_strcmp(\"code\", response_type)) {\n     if (is_authorization_type_enabled((struct _oauth2_config *)user_data, GLEWLWYD_AUTHORIZATION_TYPE_AUTHORIZATION_CODE) && u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n       result = check_auth_type_auth_code_grant(request, response, user_data);\n     } else {\n-      if (u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n-        response->status = 302;\n-        redirect_url = msprintf(\"%s#error=unsupported_response_type%s\", u_map_get(request->map_url, \"redirect_uri\"), state_param);\n-        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-        o_free(redirect_url);\n-      } else {\n-        response->status = 403;\n-      }\n+      response->status = 403;\n     }\n   } else if (0 == o_strcmp(\"token\", response_type)) {\n     if (is_authorization_type_enabled((struct _oauth2_config *)user_data, GLEWLWYD_AUTHORIZATION_TYPE_IMPLICIT) && u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n       result = check_auth_type_implicit_grant(request, response, user_data);\n-    } else {\n-      if (u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n-        response->status = 302;\n-        redirect_url = msprintf(\"%s#error=unsupported_response_type%s\", u_map_get(request->map_url, \"redirect_uri\"), state_param);\n-        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-        o_free(redirect_url);\n-      } else {\n-        response->status = 403;\n-      }\n-    }\n-  } else {\n-    if (u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n-      response->status = 302;\n-      redirect_url = msprintf(\"%s#error=unsupported_response_type%s\", u_map_get(request->map_url, \"redirect_uri\"), state_param);\n-      ulfius_add_header_to_response(response, \"Location\", redirect_url);\n-      o_free(redirect_url);\n     } else {\n       response->status = 403;\n     }\n+  } else {\n+    response->status = 403;\n   }\n   o_free(state_param);\n "
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0219fa08044c1594d8b014903165e53754291605",
            "date": "2024-10-20T17:15:13Z",
            "author_login": "babelouest"
          },
          {
            "sha": "a1ba826cab672bd3b409de687c83cf6cf4b816c8",
            "date": "2024-10-20T17:14:00Z",
            "author_login": "babelouest"
          },
          {
            "sha": "110930c922fc4aea3b8157b41fa775201e259417",
            "date": "2024-05-06T11:26:40Z",
            "author_login": "babelouest"
          },
          {
            "sha": "7f68cbcfdb10c3c0cbe2727d7fed927e53fb6843",
            "date": "2024-05-02T11:25:51Z",
            "author_login": "babelouest"
          },
          {
            "sha": "fcc9e97fc2d6f8c99dd305c8459f358acacc4c4f",
            "date": "2024-05-01T13:20:44Z",
            "author_login": "babelouest"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-601",
    "description": "Glewlwyd SSO server 2.x through 2.7.6 allows open redirection via redirect_uri.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-11T03:15:09.453",
    "last_modified": "2024-11-21T09:01:16.017",
    "fix_date": "2024-01-26T19:41:23Z"
  },
  "references": [
    {
      "url": "https://github.com/babelouest/glewlwyd/commit/59239381a88c505ab38fe64fdd92f846defa5754",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/babelouest/glewlwyd/commit/c91c0155f2393274cc18efe77e06c6846e404c75",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/babelouest/glewlwyd/commit/59239381a88c505ab38fe64fdd92f846defa5754",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/babelouest/glewlwyd/commit/c91c0155f2393274cc18efe77e06c6846e404c75",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.112035",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "glewlwyd",
    "owner": "babelouest",
    "created_at": "2016-11-30T04:26:49Z",
    "updated_at": "2024-12-31T15:15:29Z",
    "pushed_at": "2024-10-20T17:15:18Z",
    "size": 29732,
    "stars": 428,
    "forks": 80,
    "open_issues": 6,
    "watchers": 428,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 8431516,
      "JavaScript": 1254100,
      "CSS": 112372,
      "HTML": 76882,
      "CMake": 68128,
      "Makefile": 31438,
      "Shell": 18468,
      "Dockerfile": 3556
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:26:49.165020"
  }
}