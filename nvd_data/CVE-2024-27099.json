{
  "cve_id": "CVE-2024-27099",
  "github_data": {
    "repository": "Azure/azure-uamqp-c",
    "fix_commit": "2ca42b6e4e098af2d17e487814a91d05f6ae4987",
    "related_commits": [
      "2ca42b6e4e098af2d17e487814a91d05f6ae4987",
      "2ca42b6e4e098af2d17e487814a91d05f6ae4987"
    ],
    "patch_url": "https://github.com/Azure/azure-uamqp-c/commit/2ca42b6e4e098af2d17e487814a91d05f6ae4987.patch",
    "fix_commit_details": {
      "sha": "2ca42b6e4e098af2d17e487814a91d05f6ae4987",
      "commit_date": "2024-02-09T21:35:18Z",
      "author": {
        "login": "ewertons",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix potential double free in link.c (#456)",
        "length": 244,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 511,
        "additions": 509,
        "deletions": 2
      },
      "files": [
        {
          "filename": "src/link.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -404,9 +404,9 @@ static void link_frame_received(void* context, AMQP_VALUE performative, uint32_t\n                     }\n                 }\n             }\n-        }\n \n-        flow_destroy(flow_handle);\n+            flow_destroy(flow_handle);\n+        }\n     }\n     else if (is_transfer_type_by_descriptor(descriptor))\n     {"
        },
        {
          "filename": "tests/CMakeLists.txt",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@ add_subdirectory(cbs_ut)\n add_subdirectory(connection_ut)\n add_subdirectory(frame_codec_ut)\n add_subdirectory(header_detect_io_ut)\n+add_subdirectory(link_ut)\n add_subdirectory(message_ut)\n add_subdirectory(sasl_anonymous_ut)\n add_subdirectory(sasl_frame_codec_ut)"
        },
        {
          "filename": "tests/link_ut/CMakeLists.txt",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+#Copyright (c) Microsoft. All rights reserved.\n+#Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+set(theseTestsName link_ut)\n+set(${theseTestsName}_test_files\n+${theseTestsName}.c\n+)\n+\n+set(${theseTestsName}_c_files\n+../../src/link.c\n+)\n+\n+set(${theseTestsName}_h_files\n+)\n+\n+build_c_test_artifacts(${theseTestsName} ON \"tests/uamqp_tests\")\n+\n+compile_c_test_artifacts_as(${theseTestsName} C99)"
        },
        {
          "filename": "tests/link_ut/link_ut.c",
          "status": "added",
          "additions": 477,
          "deletions": 0,
          "patch": "@@ -0,0 +1,477 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#ifdef __cplusplus\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstdint>\n+#else\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdint.h>\n+#include <stdbool.h>\n+#endif\n+\n+#include \"azure_macro_utils/macro_utils.h\"\n+#include \"testrunnerswitcher.h\"\n+#include \"umock_c/umock_c.h\"\n+#include \"umock_c/umock_c_negative_tests.h\"\n+#include \"umock_c/umocktypes_bool.h\"\n+\n+static void* my_gballoc_malloc(size_t size)\n+{\n+    return malloc(size);\n+}\n+\n+static void* my_gballoc_calloc(size_t nmemb, size_t size)\n+{\n+    return calloc(nmemb, size);\n+}\n+\n+static void* my_gballoc_realloc(void* ptr, size_t size)\n+{\n+    return realloc(ptr, size);\n+}\n+\n+static void my_gballoc_free(void* ptr)\n+{\n+    free(ptr);\n+}\n+\n+#define ENABLE_MOCKS\n+\n+#include \"azure_c_shared_utility/gballoc.h\"\n+#include \"azure_c_shared_utility/singlylinkedlist.h\"\n+#include \"azure_c_shared_utility/tickcounter.h\"\n+#include \"azure_uamqp_c/session.h\"\n+#include \"azure_uamqp_c/amqpvalue.h\"\n+#include \"azure_uamqp_c/amqp_definitions.h\"\n+#include \"azure_uamqp_c/amqp_frame_codec.h\"\n+#include \"azure_uamqp_c/async_operation.h\"\n+\n+#undef ENABLE_MOCKS\n+\n+#include \"azure_uamqp_c/link.h\"\n+\n+static SESSION_HANDLE TEST_SESSION_HANDLE = (SESSION_HANDLE)0x4000;\n+const char* TEST_LINK_NAME_1 = \"test_link_name_1\";\n+static TICK_COUNTER_HANDLE TEST_TICK_COUNTER_HANDLE = (TICK_COUNTER_HANDLE)0x4001;\n+static SINGLYLINKEDLIST_HANDLE TEST_SINGLYLINKEDLIST_HANDLE = (SINGLYLINKEDLIST_HANDLE)0x4002;\n+static LINK_ENDPOINT_HANDLE TEST_LINK_ENDPOINT = (LINK_ENDPOINT_HANDLE)0x4003;\n+const AMQP_VALUE TEST_LINK_SOURCE = (AMQP_VALUE)0x4004;\n+const AMQP_VALUE TEST_LINK_TARGET = (AMQP_VALUE)0x4005;\n+\n+static TEST_MUTEX_HANDLE g_testByTest;\n+\n+MU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)\n+\n+static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n+{\n+    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n+}\n+\n+static int umocktypes_copy_bool_ptr(bool** destination, const bool** source)\n+{\n+    int result;\n+\n+    *destination = (bool*)my_gballoc_malloc(sizeof(bool));\n+    if (*destination == NULL)\n+    {\n+        result = MU_FAILURE;\n+    }\n+    else\n+    {\n+        *(*destination) = *(*source);\n+\n+        result = 0;\n+    }\n+\n+    return result;\n+}\n+\n+static void umocktypes_free_bool_ptr(bool** value)\n+{\n+    if (*value != NULL)\n+    {\n+        my_gballoc_free(*value);\n+    }\n+}\n+\n+static char* umocktypes_stringify_bool_ptr(const bool** value)\n+{\n+    char* result;\n+\n+    result = (char*)my_gballoc_malloc(8);\n+    if (result != NULL)\n+    {\n+        if (*value == NULL)\n+        {\n+            (void)strcpy(result, \"{NULL}\");\n+        }\n+        else if (*(*value) == true)\n+        {\n+            (void)strcpy(result, \"{true}\");\n+        }\n+        else\n+        {\n+            (void)strcpy(result, \"{false}\");\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+static int umocktypes_are_equal_bool_ptr(bool** left, bool** right)\n+{\n+    int result;\n+\n+    if (*left == *right)\n+    {\n+        result = 1;\n+    }\n+    else\n+    {\n+        if (*(*left) == *(*right))\n+        {\n+            result = 1;\n+        }\n+        else\n+        {\n+            result = 0;\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE* source)\n+{\n+    int result = 0;\n+\n+    *(destination) = *(source);\n+\n+    return result;\n+}\n+\n+static void umocktypes_free_FLOW_HANDLE(FLOW_HANDLE* value)\n+{\n+    (void)value;\n+}\n+\n+static char* umocktypes_stringify_FLOW_HANDLE(const FLOW_HANDLE* value)\n+{\n+    char temp_buffer[32];\n+    char* result;\n+    size_t length = sprintf(temp_buffer, \"%p\", (void*)*value);\n+    if (length < 0)\n+    {\n+        result = NULL;\n+    }\n+    else\n+    {\n+        result = (char*)malloc(length + 1);\n+        if (result != NULL)\n+        {\n+            (void)memcpy(result, temp_buffer, length + 1);\n+        }\n+    }\n+    return result;\n+}\n+\n+static int umocktypes_are_equal_FLOW_HANDLE(FLOW_HANDLE* left, FLOW_HANDLE* right)\n+{\n+    int result;\n+\n+    if (*left == *right)\n+    {\n+        result = 1;\n+    }\n+    else\n+    {\n+        result = 0;\n+    }\n+\n+    return result;\n+}\n+\n+static TRANSFER_HANDLE test_on_transfer_received_transfer;\n+static uint32_t test_on_transfer_received_payload_size;\n+static unsigned char test_on_transfer_received_payload_bytes[2048];\n+static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n+{\n+    (void)context;\n+    test_on_transfer_received_transfer = transfer;\n+    test_on_transfer_received_payload_size = payload_size;\n+    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n+\n+    return (AMQP_VALUE)0x6000;\n+}\n+\n+static LINK_STATE test_on_link_state_changed_new_link_state;\n+LINK_STATE test_on_link_state_changed_previous_link_state;\n+static void test_on_link_state_changed(void* context, LINK_STATE new_link_state, LINK_STATE previous_link_state)\n+{\n+    (void)context;\n+    test_on_link_state_changed_new_link_state = new_link_state;\n+    test_on_link_state_changed_previous_link_state = previous_link_state;\n+}\n+\n+static void test_on_link_flow_on(void* context)\n+{\n+    (void)context;\n+}\n+\n+static LINK_HANDLE create_link(role link_role)\n+{\n+    umock_c_reset_all_calls();\n+\n+    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));\n+    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n+    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n+    STRICT_EXPECTED_CALL(tickcounter_create());\n+    STRICT_EXPECTED_CALL(singlylinkedlist_create());\n+    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));\n+    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));\n+    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG));\n+\n+    return link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, link_role, TEST_LINK_SOURCE, TEST_LINK_TARGET);\n+}\n+\n+static int attach_link(LINK_HANDLE link, ON_ENDPOINT_FRAME_RECEIVED* on_frame_received)\n+{\n+    umock_c_reset_all_calls();\n+\n+    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));\n+    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))\n+        .CaptureArgumentValue_frame_received_callback(on_frame_received);\n+\n+    return link_attach(link, test_on_transfer_received, test_on_link_state_changed, test_on_link_flow_on, NULL);\n+}\n+\n+BEGIN_TEST_SUITE(link_ut)\n+\n+TEST_SUITE_INITIALIZE(suite_init)\n+{\n+    int result;\n+\n+    g_testByTest = TEST_MUTEX_CREATE();\n+    ASSERT_IS_NOT_NULL(g_testByTest);\n+\n+    umock_c_init(on_umock_c_error);\n+\n+    result = umocktypes_bool_register_types();\n+    ASSERT_ARE_EQUAL(int, 0, result, \"Failed registering bool types\");\n+\n+    REGISTER_GLOBAL_MOCK_HOOK(gballoc_malloc, my_gballoc_malloc);\n+    REGISTER_GLOBAL_MOCK_HOOK(gballoc_calloc, my_gballoc_calloc);\n+    REGISTER_GLOBAL_MOCK_HOOK(gballoc_realloc, my_gballoc_realloc);\n+    REGISTER_GLOBAL_MOCK_HOOK(gballoc_free, my_gballoc_free);\n+    REGISTER_UMOCK_ALIAS_TYPE(AMQP_VALUE, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(TICK_COUNTER_HANDLE, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(SINGLYLINKEDLIST_HANDLE, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(SESSION_HANDLE, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(LINK_ENDPOINT_HANDLE, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_LINK_ENDPOINT_DESTROYED_CALLBACK, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_ENDPOINT_FRAME_RECEIVED, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_TRANSFER_RECEIVED, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_LINK_STATE_CHANGED, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_LINK_FLOW_ON, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_SESSION_STATE_CHANGED, void*);\n+    REGISTER_UMOCK_ALIAS_TYPE(ON_SESSION_FLOW_ON, void*);\n+\n+    REGISTER_GLOBAL_MOCK_RETURNS(tickcounter_create, TEST_TICK_COUNTER_HANDLE, NULL);\n+    REGISTER_GLOBAL_MOCK_RETURNS(singlylinkedlist_create, TEST_SINGLYLINKEDLIST_HANDLE, NULL);\n+    REGISTER_GLOBAL_MOCK_RETURNS(session_create_link_endpoint, TEST_LINK_ENDPOINT, NULL);\n+    REGISTER_GLOBAL_MOCK_RETURNS(session_start_link_endpoint, 0, 1);\n+\n+    REGISTER_TYPE(FLOW_HANDLE, FLOW_HANDLE);\n+    REGISTER_TYPE(bool*, bool_ptr);\n+}\n+\n+TEST_SUITE_CLEANUP(suite_cleanup)\n+{\n+    umock_c_deinit();\n+\n+    TEST_MUTEX_DESTROY(g_testByTest);\n+}\n+\n+TEST_FUNCTION_INITIALIZE(test_init)\n+{\n+    if (TEST_MUTEX_ACQUIRE(g_testByTest))\n+    {\n+        ASSERT_FAIL(\"our mutex is ABANDONED. Failure in test framework\");\n+    }\n+\n+    umock_c_reset_all_calls();\n+}\n+\n+TEST_FUNCTION_CLEANUP(test_cleanup)\n+{\n+    TEST_MUTEX_RELEASE(g_testByTest);\n+}\n+\n+TEST_FUNCTION(link_create_succeeds)\n+{\n+    // arrange\n+    AMQP_VALUE link_source = TEST_LINK_SOURCE;\n+    AMQP_VALUE link_target = TEST_LINK_TARGET;\n+\n+    umock_c_reset_all_calls();\n+\n+    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));\n+    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n+    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n+    STRICT_EXPECTED_CALL(tickcounter_create());\n+    STRICT_EXPECTED_CALL(singlylinkedlist_create());\n+    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));\n+    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));\n+    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG));\n+\n+    // act\n+    LINK_HANDLE link = link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, role_receiver, link_source, link_target);\n+\n+    // assert\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+    ASSERT_IS_NOT_NULL(link);\n+\n+    // cleanup\n+    link_destroy(link);\n+}\n+\n+TEST_FUNCTION(link_attach_succeeds)\n+{\n+    // arrange\n+    LINK_HANDLE link = create_link(role_receiver);\n+    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;\n+\n+    umock_c_reset_all_calls();\n+\n+    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));\n+    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))\n+        .CaptureArgumentValue_frame_received_callback(&on_frame_received);\n+\n+    // act\n+    int result = link_attach(link, test_on_transfer_received, test_on_link_state_changed, test_on_link_flow_on, NULL);\n+\n+    // assert\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+    ASSERT_ARE_EQUAL(int, 0, result);\n+    ASSERT_IS_NOT_NULL(on_frame_received);\n+\n+    // cleanup\n+    link_destroy(link);\n+}\n+\n+TEST_FUNCTION(link_receiver_frame_received_succeeds)\n+{\n+    // arrange\n+    LINK_HANDLE link = create_link(role_receiver);\n+    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;\n+    int attach_result = attach_link(link, &on_frame_received);\n+    ASSERT_ARE_EQUAL(int, 0, attach_result);\n+\n+    AMQP_VALUE performative = (AMQP_VALUE)0x5000;\n+    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;\n+    FLOW_HANDLE flow = (FLOW_HANDLE)0x5002;\n+    uint32_t frame_payload_size = 30;\n+    const unsigned char payload_bytes[30] = { 0 };\n+\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))\n+        .SetReturn(descriptor);\n+    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))\n+        .SetReturn(false);\n+    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))\n+        .SetReturn(1);\n+    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))\n+        .CopyOutArgumentBuffer(2, &flow, sizeof(flow));\n+    STRICT_EXPECTED_CALL(flow_destroy(IGNORED_PTR_ARG));\n+\n+    // act\n+    on_frame_received(link, performative, frame_payload_size, payload_bytes);\n+\n+    // assert\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    // cleanup\n+    link_destroy(link);\n+}\n+\n+TEST_FUNCTION(link_sender_frame_received_succeeds)\n+{\n+    // arrange\n+    LINK_HANDLE link = create_link(role_sender);\n+    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;\n+    int attach_result = attach_link(link, &on_frame_received);\n+    ASSERT_ARE_EQUAL(int, 0, attach_result);\n+\n+    AMQP_VALUE performative = (AMQP_VALUE)0x5000;\n+    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;\n+    FLOW_HANDLE flow = (FLOW_HANDLE)0x5002;\n+    uint32_t frame_payload_size = 30;\n+    const unsigned char payload_bytes[30] = { 0 };\n+    uint32_t link_credit_value = 700;\n+    uint32_t delivery_count_value = 300;\n+\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))\n+        .SetReturn(descriptor);\n+    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))\n+        .SetReturn(false);\n+    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))\n+        .SetReturn(1);\n+    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))\n+        .CopyOutArgumentBuffer(2, &flow, sizeof(flow));\n+    STRICT_EXPECTED_CALL(flow_get_link_credit(IGNORED_PTR_ARG, IGNORED_PTR_ARG))\n+        .CopyOutArgumentBuffer(2, &link_credit_value, sizeof(link_credit_value));\n+    STRICT_EXPECTED_CALL(flow_get_delivery_count(IGNORED_PTR_ARG, IGNORED_PTR_ARG))\n+        .CopyOutArgumentBuffer(2, &delivery_count_value, sizeof(delivery_count_value));\n+    STRICT_EXPECTED_CALL(flow_destroy(IGNORED_PTR_ARG));\n+\n+    // act\n+    on_frame_received(link, performative, frame_payload_size, payload_bytes);\n+\n+    // assert\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    // cleanup\n+    link_destroy(link);\n+}\n+\n+TEST_FUNCTION(link_receiver_frame_received_get_flow_fails_no_double_free_fails)\n+{\n+    // arrange\n+    LINK_HANDLE link = create_link(role_receiver);\n+    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;\n+    int attach_result = attach_link(link, &on_frame_received);\n+    ASSERT_ARE_EQUAL(int, 0, attach_result);\n+\n+    AMQP_VALUE performative = (AMQP_VALUE)0x5000;\n+    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;\n+    FLOW_HANDLE flow = NULL;\n+    uint32_t frame_payload_size = 30;\n+    const unsigned char payload_bytes[30] = { 0 };\n+\n+    umock_c_reset_all_calls();\n+    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))\n+        .SetReturn(descriptor);\n+    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))\n+        .SetReturn(false);\n+    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))\n+        .SetReturn(1);\n+    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))\n+        .CopyOutArgumentBuffer(2, &flow, sizeof(flow))\n+        .SetReturn(1);\n+\n+    // act\n+    on_frame_received(link, performative, frame_payload_size, payload_bytes);\n+\n+    // assert\n+    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\n+\n+    // cleanup\n+    link_destroy(link);\n+}\n+\n+\n+END_TEST_SUITE(link_ut)"
        },
        {
          "filename": "tests/link_ut/main.c",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+// Copyright (c) Microsoft. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+#include \"testrunnerswitcher.h\"\n+\n+int main(void)\n+{\n+    size_t failedTestCount = 0;\n+    RUN_TEST_SUITE(link_ut, failedTestCount);\n+    return (int)failedTestCount;\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "09e08d1611397e3e542d0f42340165c5dd7196df",
            "date": "2025-01-06T22:25:06Z",
            "author_login": "ewertons"
          },
          {
            "sha": "96d7179f60e558b2c350194ea0061c725377f7e0",
            "date": "2024-08-09T20:44:28Z",
            "author_login": "ewertons"
          },
          {
            "sha": "997e40ec9b8f9176319e0aee9c971f4590c32f74",
            "date": "2024-07-18T17:35:21Z",
            "author_login": "ericwolz"
          },
          {
            "sha": "9107c28dfd790479898f0b018742ccf078ec9ffc",
            "date": "2024-06-26T17:12:33Z",
            "author_login": "ewertons"
          },
          {
            "sha": "6a150b07352304acacdde2e446643f8f6de0ea3a",
            "date": "2024-06-19T15:54:32Z",
            "author_login": "ewertons"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-415",
    "description": "The uAMQP is a C library for AMQP 1.0 communication to Azure Cloud Services. When processing an incorrect `AMQP_VALUE` failed state, may cause a double free problem. This may cause a RCE. Update submodule with commit 2ca42b6e4e098af2d17e487814a91d05f6ae4987.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-27T19:04:07.603",
    "last_modified": "2024-11-21T09:03:51.437",
    "fix_date": "2024-02-09T21:35:18Z"
  },
  "references": [
    {
      "url": "https://github.com/Azure/azure-uamqp-c/commit/2ca42b6e4e098af2d17e487814a91d05f6ae4987",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/Azure/azure-uamqp-c/security/advisories/GHSA-6rh4-fj44-v4jj",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/Azure/azure-uamqp-c/commit/2ca42b6e4e098af2d17e487814a91d05f6ae4987",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/Azure/azure-uamqp-c/security/advisories/GHSA-6rh4-fj44-v4jj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.168379",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "azure-uamqp-c",
    "owner": "Azure",
    "created_at": "2015-11-20T06:13:31Z",
    "updated_at": "2025-01-06T22:25:11Z",
    "pushed_at": "2025-01-06T22:25:08Z",
    "size": 4441,
    "stars": 58,
    "forks": 64,
    "open_issues": 45,
    "watchers": 58,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "lts_01_2018",
      "lts_02_2020",
      "lts_07_2019",
      "lts_07_2020",
      "master",
      "release_2018_06_08",
      "release_2018_06_15",
      "release_2018_06_26",
      "release_2018_06_27",
      "release_2018_07_11",
      "release_2018_10_03",
      "release_2018_11_20"
    ],
    "languages": {
      "C": 3974550,
      "C#": 195090,
      "C++": 112788,
      "CMake": 23848,
      "Batchfile": 16001,
      "Shell": 10586,
      "Makefile": 1093
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:29:30.935197"
  }
}