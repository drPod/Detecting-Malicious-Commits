{
  "cve_id": "CVE-2024-27102",
  "github_data": {
    "repository": "pterodactyl/wings",
    "fix_commit": "d1c0ca526007113a0f74f56eba99511b4e989287",
    "related_commits": [
      "d1c0ca526007113a0f74f56eba99511b4e989287",
      "d1c0ca526007113a0f74f56eba99511b4e989287"
    ],
    "patch_url": "https://github.com/pterodactyl/wings/commit/d1c0ca526007113a0f74f56eba99511b4e989287.patch",
    "fix_commit_details": {
      "sha": "d1c0ca526007113a0f74f56eba99511b4e989287",
      "commit_date": "2024-03-13T03:44:55Z",
      "author": {
        "login": "matthewpi",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "server(filesystem): rebuild everything imaginable",
        "length": 427,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 4827,
        "additions": 3648,
        "deletions": 1179
      },
      "files": [
        {
          "filename": "config/config.go",
          "status": "modified",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -12,6 +12,7 @@ import (\n \t\"regexp\"\n \t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\"\n \t\"text/template\"\n \t\"time\"\n \n@@ -20,6 +21,7 @@ import (\n \t\"github.com/apex/log\"\n \t\"github.com/creasty/defaults\"\n \t\"github.com/gbrlsnchs/jwt/v3\"\n+\t\"golang.org/x/sys/unix\"\n \t\"gopkg.in/yaml.v2\"\n \n \t\"github.com/pterodactyl/wings/system\"\n@@ -209,6 +211,8 @@ type SystemConfiguration struct {\n \tBackups Backups `yaml:\"backups\"`\n \n \tTransfers Transfers `yaml:\"transfers\"`\n+\n+\tOpenatMode string `default:\"auto\" yaml:\"openat_mode\"`\n }\n \n type CrashDetection struct {\n@@ -671,3 +675,34 @@ func getSystemName() (string, error) {\n \t}\n \treturn release[\"ID\"], nil\n }\n+\n+var openat2 atomic.Bool\n+var openat2Set atomic.Bool\n+\n+func UseOpenat2() bool {\n+\tif openat2Set.Load() {\n+\t\treturn openat2.Load()\n+\t}\n+\tdefer openat2Set.Store(true)\n+\n+\tc := Get()\n+\topenatMode := c.System.OpenatMode\n+\tswitch openatMode {\n+\tcase \"openat2\":\n+\t\topenat2.Store(true)\n+\t\treturn true\n+\tcase \"openat\":\n+\t\topenat2.Store(false)\n+\t\treturn false\n+\tdefault:\n+\t\tfd, err := unix.Openat2(unix.AT_FDCWD, \"/\", &unix.OpenHow{})\n+\t\tif err != nil {\n+\t\t\tlog.WithError(err).Warn(\"error occurred while checking for openat2 support, falling back to openat\")\n+\t\t\topenat2.Store(false)\n+\t\t\treturn false\n+\t\t}\n+\t\t_ = unix.Close(fd)\n+\t\topenat2.Store(true)\n+\t\treturn true\n+\t}\n+}"
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -30,7 +30,7 @@ require (\n \tgithub.com/iancoleman/strcase v0.3.0\n \tgithub.com/icza/dyno v0.0.0-20230330125955-09f820a8d9c0\n \tgithub.com/juju/ratelimit v1.0.2\n-\tgithub.com/karrick/godirwalk v1.17.0\n+\tgithub.com/klauspost/compress v1.17.7\n \tgithub.com/klauspost/pgzip v1.2.6\n \tgithub.com/magiconair/properties v1.8.7\n \tgithub.com/mattn/go-colorable v0.1.13\n@@ -43,6 +43,7 @@ require (\n \tgithub.com/stretchr/testify v1.9.0\n \tgolang.org/x/crypto v0.21.0\n \tgolang.org/x/sync v0.6.0\n+\tgolang.org/x/sys v0.18.0\n \tgopkg.in/ini.v1 v1.67.0\n \tgopkg.in/yaml.v2 v2.4.0\n \tgopkg.in/yaml.v3 v3.0.1\n@@ -83,7 +84,6 @@ require (\n \tgithub.com/jinzhu/now v1.1.5 // indirect\n \tgithub.com/json-iterator/go v1.1.12 // indirect\n \tgithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect\n-\tgithub.com/klauspost/compress v1.17.7 // indirect\n \tgithub.com/klauspost/cpuid/v2 v2.2.7 // indirect\n \tgithub.com/kr/fs v0.1.0 // indirect\n \tgithub.com/leodido/go-urn v1.4.0 // indirect\n@@ -122,7 +122,6 @@ require (\n \tgolang.org/x/arch v0.7.0 // indirect\n \tgolang.org/x/mod v0.16.0 // indirect\n \tgolang.org/x/net v0.22.0 // indirect\n-\tgolang.org/x/sys v0.18.0 // indirect\n \tgolang.org/x/term v0.18.0 // indirect\n \tgolang.org/x/text v0.14.0 // indirect\n \tgolang.org/x/time v0.0.0-20220922220347-f3bd1da661af // indirect"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -219,8 +219,6 @@ github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1\n github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\n github.com/juju/ratelimit v1.0.2 h1:sRxmtRiajbvrcLQT7S+JbqU0ntsb9W2yhSdNN8tWfaI=\n github.com/juju/ratelimit v1.0.2/go.mod h1:qapgC/Gy+xNh9UxzV13HGGl/6UXNN+ct+vwSgWNm/qk=\n-github.com/karrick/godirwalk v1.17.0 h1:b4kY7nqDdioR/6qnbHQyDvmA17u5G1cZ6J+CZXwSWoI=\n-github.com/karrick/godirwalk v1.17.0/go.mod h1:j4mkqPuvaLI8mp1DroR3P6ad7cyYd4c1qeJ3RV7ULlk=\n github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=\n github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\n github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8="
        },
        {
          "filename": "internal/ufs/LICENSE",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+MIT License\n+\n+Copyright (c) 2024 Matthew Penner\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
        },
        {
          "filename": "internal/ufs/README.md",
          "status": "added",
          "additions": 17,
          "deletions": 0,
          "patch": "@@ -0,0 +1,17 @@\n+# Filesystem\n+\n+## Licensing\n+\n+Most code in this package is licensed under `MIT` with some exceptions.\n+\n+The following files are licensed under `BSD-3-Clause` due to them being copied\n+verbatim or derived from [Go](https://go.dev)'s source code.\n+\n+- [`file_posix.go`](./file_posix.go)\n+- [`mkdir_unix.go`](./mkdir_unix.go)\n+- [`path_unix.go`](./path_unix.go)\n+- [`removeall_unix.go`](./removeall_unix.go)\n+- [`stat_unix.go`](./stat_unix.go) \n+- [`walk.go`](./walk.go)\n+\n+These changes are not associated with nor endorsed by The Go Authors."
        },
        {
          "filename": "internal/ufs/doc.go",
          "status": "added",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -0,0 +1,12 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+// Package ufs provides an abstraction layer for performing I/O on filesystems.\n+// This package is designed to be used in-place of standard `os` package I/O\n+// calls, and is not designed to be used as a generic filesystem abstraction\n+// like the `io/fs` package.\n+//\n+// The primary use-case of this package was to provide a \"chroot-like\" `os`\n+// wrapper, so we can safely sandbox I/O operations within a directory and\n+// use untrusted arbitrary paths.\n+package ufs"
        },
        {
          "filename": "internal/ufs/error.go",
          "status": "added",
          "additions": 120,
          "deletions": 0,
          "patch": "@@ -0,0 +1,120 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+package ufs\n+\n+import (\n+\t\"errors\"\n+\tiofs \"io/fs\"\n+\t\"os\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+var (\n+\t// ErrIsDirectory is an error for when an operation that operates only on\n+\t// files is given a path to a directory.\n+\tErrIsDirectory = errors.New(\"is a directory\")\n+\t// ErrNotDirectory is an error for when an operation that operates only on\n+\t// directories is given a path to a file.\n+\tErrNotDirectory = errors.New(\"not a directory\")\n+\t// ErrBadPathResolution is an error for when a sand-boxed filesystem\n+\t// resolves a given path to a forbidden location.\n+\tErrBadPathResolution = errors.New(\"bad path resolution\")\n+\t// ErrNotRegular is an error for when an operation that operates only on\n+\t// regular files is passed something other than a regular file.\n+\tErrNotRegular = errors.New(\"not a regular file\")\n+\n+\t// ErrClosed is an error for when an entry was accessed after being closed.\n+\tErrClosed = iofs.ErrClosed\n+\t// ErrInvalid is an error for when an invalid argument was used.\n+\tErrInvalid = iofs.ErrInvalid\n+\t// ErrExist is an error for when an entry already exists.\n+\tErrExist = iofs.ErrExist\n+\t// ErrNotExist is an error for when an entry does not exist.\n+\tErrNotExist = iofs.ErrNotExist\n+\t// ErrPermission is an error for when the required permissions to perform an\n+\t// operation are missing.\n+\tErrPermission = iofs.ErrPermission\n+)\n+\n+// LinkError records an error during a link or symlink or rename\n+// system call and the paths that caused it.\n+type LinkError = os.LinkError\n+\n+// PathError records an error and the operation and file path that caused it.\n+type PathError = iofs.PathError\n+\n+// SyscallError records an error from a specific system call.\n+type SyscallError = os.SyscallError\n+\n+// NewSyscallError returns, as an error, a new SyscallError\n+// with the given system call name and error details.\n+// As a convenience, if err is nil, NewSyscallError returns nil.\n+func NewSyscallError(syscall string, err error) error {\n+\treturn os.NewSyscallError(syscall, err)\n+}\n+\n+// convertErrorType converts errors into our custom errors to ensure consistent\n+// error values.\n+func convertErrorType(err error) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\tvar pErr *PathError\n+\tswitch {\n+\tcase errors.As(err, &pErr):\n+\t\tswitch {\n+\t\t// File exists\n+\t\tcase errors.Is(pErr.Err, unix.EEXIST):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrExist,\n+\t\t\t}\n+\t\t// Is a directory\n+\t\tcase errors.Is(pErr.Err, unix.EISDIR):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrIsDirectory,\n+\t\t\t}\n+\t\t// Not a directory\n+\t\tcase errors.Is(pErr.Err, unix.ENOTDIR):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrNotDirectory,\n+\t\t\t}\n+\t\t// No such file or directory\n+\t\tcase errors.Is(pErr.Err, unix.ENOENT):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrNotExist,\n+\t\t\t}\n+\t\t// Operation not permitted\n+\t\tcase errors.Is(pErr.Err, unix.EPERM):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrPermission,\n+\t\t\t}\n+\t\t// Invalid cross-device link\n+\t\tcase errors.Is(pErr.Err, unix.EXDEV):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrBadPathResolution,\n+\t\t\t}\n+\t\t// Too many levels of symbolic links\n+\t\tcase errors.Is(pErr.Err, unix.ELOOP):\n+\t\t\treturn &PathError{\n+\t\t\t\tOp:   pErr.Op,\n+\t\t\t\tPath: pErr.Path,\n+\t\t\t\tErr:  ErrBadPathResolution,\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn err\n+}"
        },
        {
          "filename": "internal/ufs/file.go",
          "status": "added",
          "additions": 179,
          "deletions": 0,
          "patch": "@@ -0,0 +1,179 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+package ufs\n+\n+import (\n+\t\"io\"\n+\tiofs \"io/fs\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+// DirEntry is an entry read from a directory.\n+type DirEntry = iofs.DirEntry\n+\n+// File describes readable and/or writable file from a Filesystem.\n+type File interface {\n+\t// Name returns the base name of the file.\n+\tName() string\n+\n+\t// Stat returns the FileInfo structure describing the file.\n+\t// If there is an error, it will be of type *PathError.\n+\tStat() (FileInfo, error)\n+\n+\t// ReadDir reads the contents of the directory associated with the file f\n+\t// and returns a slice of DirEntry values in directory order.\n+\t// Subsequent calls on the same file will yield later DirEntry records in the directory.\n+\t//\n+\t// If n > 0, ReadDir returns at most n DirEntry records.\n+\t// In this case, if ReadDir returns an empty slice, it will return an error explaining why.\n+\t// At the end of a directory, the error is io.EOF.\n+\t//\n+\t// If n <= 0, ReadDir returns all the DirEntry records remaining in the directory.\n+\t// When it succeeds, it returns a nil error (not io.EOF).\n+\tReadDir(n int) ([]DirEntry, error)\n+\n+\t// Readdirnames reads the contents of the directory associated with file\n+\t// and returns a slice of up to n names of files in the directory,\n+\t// in directory order. Subsequent calls on the same file will yield\n+\t// further names.\n+\t//\n+\t// If n > 0, Readdirnames returns at most n names. In this case, if\n+\t// Readdirnames returns an empty slice, it will return a non-nil error\n+\t// explaining why. At the end of a directory, the error is io.EOF.\n+\t//\n+\t// If n <= 0, Readdirnames returns all the names from the directory in\n+\t// a single slice. In this case, if Readdirnames succeeds (reads all\n+\t// the way to the end of the directory), it returns the slice and a\n+\t// nil error. If it encounters an error before the end of the\n+\t// directory, Readdirnames returns the names read until that point and\n+\t// a non-nil error.\n+\tReaddirnames(n int) (names []string, err error)\n+\n+\t// Fd returns the integer Unix file descriptor referencing the open file.\n+\t// If f is closed, the file descriptor becomes invalid.\n+\t// If f is garbage collected, a finalizer may close the file descriptor,\n+\t// making it invalid; see runtime.SetFinalizer for more information on when\n+\t// a finalizer might be run. On Unix systems this will cause the SetDeadline\n+\t// methods to stop working.\n+\t// Because file descriptors can be reused, the returned file descriptor may\n+\t// only be closed through the Close method of f, or by its finalizer during\n+\t// garbage collection. Otherwise, during garbage collection the finalizer\n+\t// may close an unrelated file descriptor with the same (reused) number.\n+\t//\n+\t// As an alternative, see the f.SyscallConn method.\n+\tFd() uintptr\n+\n+\t// Truncate changes the size of the file.\n+\t// It does not change the I/O offset.\n+\t// If there is an error, it will be of type *PathError.\n+\tTruncate(size int64) error\n+\n+\tio.Closer\n+\n+\tio.Reader\n+\tio.ReaderAt\n+\tio.ReaderFrom\n+\n+\tio.Writer\n+\tio.WriterAt\n+\n+\tio.Seeker\n+}\n+\n+// FileInfo describes a file and is returned by Stat and Lstat.\n+type FileInfo = iofs.FileInfo\n+\n+// FileMode represents a file's mode and permission bits.\n+// The bits have the same definition on all systems, so that\n+// information about files can be moved from one system\n+// to another portably. Not all bits apply to all systems.\n+// The only required bit is ModeDir for directories.\n+type FileMode = iofs.FileMode\n+\n+// The defined file mode bits are the most significant bits of the FileMode.\n+// The nine least-significant bits are the standard Unix rwxrwxrwx permissions.\n+// The values of these bits should be considered part of the public API and\n+// may be used in wire protocols or disk representations: they must not be\n+// changed, although new bits might be added.\n+const (\n+\t// ModeDir represents a directory.\n+\t// d: is a directory\n+\tModeDir = iofs.ModeDir\n+\t// ModeAppend represents an append-only file.\n+\t// a: append-only\n+\tModeAppend = iofs.ModeAppend\n+\t// ModeExclusive represents an exclusive file.\n+\t// l: exclusive use\n+\tModeExclusive = iofs.ModeExclusive\n+\t// ModeTemporary .\n+\t// T: temporary file; Plan 9 only.\n+\tModeTemporary = iofs.ModeTemporary\n+\t// ModeSymlink .\n+\t// L: symbolic link.\n+\tModeSymlink = iofs.ModeSymlink\n+\t// ModeDevice .\n+\t// D: device file.\n+\tModeDevice = iofs.ModeDevice\n+\t// ModeNamedPipe .\n+\t// p: named pipe (FIFO)\n+\tModeNamedPipe = iofs.ModeNamedPipe\n+\t// ModeSocket .\n+\t// S: Unix domain socket.\n+\tModeSocket = iofs.ModeSocket\n+\t// ModeSetuid .\n+\t// u: setuid\n+\tModeSetuid = iofs.ModeSetuid\n+\t// ModeSetgid .\n+\t// g: setgid\n+\tModeSetgid = iofs.ModeSetgid\n+\t// ModeCharDevice .\n+\t// c: Unix character device, when ModeDevice is set\n+\tModeCharDevice = iofs.ModeCharDevice\n+\t// ModeSticky .\n+\t// t: sticky\n+\tModeSticky = iofs.ModeSticky\n+\t// ModeIrregular .\n+\t// ?: non-regular file; nothing else is known about this file.\n+\tModeIrregular = iofs.ModeIrregular\n+\n+\t// ModeType .\n+\tModeType = iofs.ModeType\n+\n+\t// ModePerm .\n+\t// Unix permission bits, 0o777.\n+\tModePerm = iofs.ModePerm\n+)\n+\n+const (\n+\t// O_RDONLY opens the file read-only.\n+\tO_RDONLY = unix.O_RDONLY\n+\t// O_WRONLY opens the file write-only.\n+\tO_WRONLY = unix.O_WRONLY\n+\t// O_RDWR opens the file read-write.\n+\tO_RDWR = unix.O_RDWR\n+\t// O_APPEND appends data to the file when writing.\n+\tO_APPEND = unix.O_APPEND\n+\t// O_CREATE creates a new file if it doesn't exist.\n+\tO_CREATE = unix.O_CREAT\n+\t// O_EXCL is used with O_CREATE, file must not exist.\n+\tO_EXCL = unix.O_EXCL\n+\t// O_SYNC open for synchronous I/O.\n+\tO_SYNC = unix.O_SYNC\n+\t// O_TRUNC truncates regular writable file when opened.\n+\tO_TRUNC = unix.O_TRUNC\n+\t// O_DIRECTORY opens a directory only. If the entry is not a directory an\n+\t// error will be returned.\n+\tO_DIRECTORY = unix.O_DIRECTORY\n+\t// O_NOFOLLOW opens the exact path given without following symlinks.\n+\tO_NOFOLLOW  = unix.O_NOFOLLOW\n+\tO_CLOEXEC   = unix.O_CLOEXEC\n+\tO_LARGEFILE = unix.O_LARGEFILE\n+)\n+\n+const (\n+\tAT_SYMLINK_NOFOLLOW = unix.AT_SYMLINK_NOFOLLOW\n+\tAT_REMOVEDIR        = unix.AT_REMOVEDIR\n+\tAT_EMPTY_PATH       = unix.AT_EMPTY_PATH\n+)"
        },
        {
          "filename": "internal/ufs/file_posix.go",
          "status": "added",
          "additions": 49,
          "deletions": 0,
          "patch": "@@ -0,0 +1,49 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+// Code in this file was copied from `go/src/os/file_posix.go`.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the `go.LICENSE` file.\n+\n+//go:build unix || (js && wasm) || wasip1 || windows\n+\n+package ufs\n+\n+import (\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+// ignoringEINTR makes a function call and repeats it if it returns an\n+// EINTR error. This appears to be required even though we install all\n+// signal handlers with SA_RESTART: see https://go.dev/issue/22838,\n+// https://go.dev/issue/38033, https://go.dev/issue/38836,\n+// https://go.dev/issue/40846. Also, https://go.dev/issue/20400 and\n+// https://go.dev/issue/36644 are issues in which a signal handler is\n+// installed without setting SA_RESTART. None of these are the common case,\n+// but there are enough of them that it seems that we can't avoid\n+// an EINTR loop.\n+func ignoringEINTR(fn func() error) error {\n+\tfor {\n+\t\terr := fn()\n+\t\tif err != unix.EINTR {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+}\n+\n+// syscallMode returns the syscall-specific mode bits from Go's portable mode bits.\n+func syscallMode(i FileMode) (o FileMode) {\n+\to |= i.Perm()\n+\tif i&ModeSetuid != 0 {\n+\t\to |= unix.S_ISUID\n+\t}\n+\tif i&ModeSetgid != 0 {\n+\t\to |= unix.S_ISGID\n+\t}\n+\tif i&ModeSticky != 0 {\n+\t\to |= unix.S_ISVTX\n+\t}\n+\t// No mapping for Go's ModeTemporary (plan9 only).\n+\treturn\n+}"
        },
        {
          "filename": "internal/ufs/filesystem.go",
          "status": "added",
          "additions": 168,
          "deletions": 0,
          "patch": "@@ -0,0 +1,168 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+package ufs\n+\n+import (\n+\t\"time\"\n+)\n+\n+// Filesystem represents a filesystem capable of performing I/O operations.\n+type Filesystem interface {\n+\t// Chmod changes the mode of the named file to mode.\n+\t//\n+\t// If the file is a symbolic link, it changes the mode of the link's target.\n+\t// If there is an error, it will be of type *PathError.\n+\t//\n+\t// A different subset of the mode bits are used, depending on the\n+\t// operating system.\n+\t//\n+\t// On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\n+\t// ModeSticky are used.\n+\t//\n+\t// On Windows, only the 0200 bit (owner writable) of mode is used; it\n+\t// controls whether the file's read-only attribute is set or cleared.\n+\t// The other bits are currently unused. For compatibility with Go 1.12\n+\t// and earlier, use a non-zero mode. Use mode 0400 for a read-only\n+\t// file and 0600 for a readable+writable file.\n+\t//\n+\t// On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\n+\t// and ModeTemporary are used.\n+\tChmod(name string, mode FileMode) error\n+\n+\t// Chown changes the numeric uid and gid of the named file.\n+\t//\n+\t// If the file is a symbolic link, it changes the uid and gid of the link's target.\n+\t// A uid or gid of -1 means to not change that value.\n+\t// If there is an error, it will be of type *PathError.\n+\t//\n+\t// On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\n+\t// EPLAN9 error, wrapped in *PathError.\n+\tChown(name string, uid, gid int) error\n+\n+\t// Lchown changes the numeric uid and gid of the named file.\n+\t//\n+\t// If the file is a symbolic link, it changes the uid and gid of the link itself.\n+\t// If there is an error, it will be of type *PathError.\n+\t//\n+\t// On Windows, it always returns the syscall.EWINDOWS error, wrapped\n+\t// in *PathError.\n+\tLchown(name string, uid, gid int) error\n+\n+\t// Chtimes changes the access and modification times of the named\n+\t// file, similar to the Unix utime() or utimes() functions.\n+\t//\n+\t// The underlying filesystem may truncate or round the values to a\n+\t// less precise time unit.\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tChtimes(name string, atime, mtime time.Time) error\n+\n+\t// Create creates or truncates the named file. If the file already exists,\n+\t// it is truncated.\n+\t//\n+\t// If the file does not exist, it is created with mode 0666\n+\t// (before umask). If successful, methods on the returned File can\n+\t// be used for I/O; the associated file descriptor has mode O_RDWR.\n+\t// If there is an error, it will be of type *PathError.\n+\tCreate(name string) (File, error)\n+\n+\t// Mkdir creates a new directory with the specified name and permission\n+\t// bits (before umask).\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tMkdir(name string, perm FileMode) error\n+\n+\t// MkdirAll creates a directory named path, along with any necessary\n+\t// parents, and returns nil, or else returns an error.\n+\t//\n+\t// The permission bits perm (before umask) are used for all\n+\t// directories that MkdirAll creates.\n+\t// If path is already a directory, MkdirAll does nothing\n+\t// and returns nil.\n+\tMkdirAll(path string, perm FileMode) error\n+\n+\t// Open opens the named file for reading.\n+\t//\n+\t// If successful, methods on the returned file can be used for reading; the\n+\t// associated file descriptor has mode O_RDONLY.\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tOpen(name string) (File, error)\n+\n+\t// OpenFile is the generalized open call; most users will use Open\n+\t// or Create instead. It opens the named file with specified flag\n+\t// (O_RDONLY etc.).\n+\t//\n+\t// If the file does not exist, and the O_CREATE flag\n+\t// is passed, it is created with mode perm (before umask). If successful,\n+\t// methods on the returned File can be used for I/O.\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tOpenFile(name string, flag int, perm FileMode) (File, error)\n+\n+\t// ReadDir reads the named directory,\n+\t//\n+\t// returning all its directory entries sorted by filename.\n+\t// If an error occurs reading the directory, ReadDir returns the entries it\n+\t// was able to read before the error, along with the error.\n+\tReadDir(name string) ([]DirEntry, error)\n+\n+\t// Remove removes the named file or (empty) directory.\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tRemove(name string) error\n+\n+\t// RemoveAll removes path and any children it contains.\n+\t//\n+\t// It removes everything it can but returns the first error\n+\t// it encounters. If the path does not exist, RemoveAll\n+\t// returns nil (no error).\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tRemoveAll(path string) error\n+\n+\t// Rename renames (moves) oldpath to newpath.\n+\t//\n+\t// If newpath already exists and is not a directory, Rename replaces it.\n+\t// OS-specific restrictions may apply when oldpath and newpath are in different directories.\n+\t// Even within the same directory, on non-Unix platforms Rename is not an atomic operation.\n+\t//\n+\t// If there is an error, it will be of type *LinkError.\n+\tRename(oldname, newname string) error\n+\n+\t// Stat returns a FileInfo describing the named file.\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tStat(name string) (FileInfo, error)\n+\n+\t// Lstat returns a FileInfo describing the named file.\n+\t//\n+\t// If the file is a symbolic link, the returned FileInfo\n+\t// describes the symbolic link. Lstat makes no attempt to follow the link.\n+\t//\n+\t// If there is an error, it will be of type *PathError.\n+\tLstat(name string) (FileInfo, error)\n+\n+\t// Symlink creates newname as a symbolic link to oldname.\n+\t//\n+\t// On Windows, a symlink to a non-existent oldname creates a file symlink;\n+\t// if oldname is later created as a directory the symlink will not work.\n+\t//\n+\t// If there is an error, it will be of type *LinkError.\n+\tSymlink(oldname, newname string) error\n+\n+\t// WalkDir walks the file tree rooted at root, calling fn for each file or\n+\t// directory in the tree, including root.\n+\t//\n+\t// All errors that arise visiting files and directories are filtered by fn:\n+\t// see the [WalkDirFunc] documentation for details.\n+\t//\n+\t// The files are walked in lexical order, which makes the output deterministic\n+\t// but requires WalkDir to read an entire directory into memory before proceeding\n+\t// to walk that directory.\n+\t//\n+\t// WalkDir does not follow symbolic links found in directories,\n+\t// but if root itself is a symbolic link, its target will be walked.\n+\tWalkDir(root string, fn WalkDirFunc) error\n+}"
        },
        {
          "filename": "internal/ufs/fs_quota.go",
          "status": "added",
          "additions": 159,
          "deletions": 0,
          "patch": "@@ -0,0 +1,159 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+package ufs\n+\n+import (\n+\t\"sync/atomic\"\n+)\n+\n+type Quota struct {\n+\t// fs is the underlying filesystem that runs the actual I/O operations.\n+\t*UnixFS\n+\n+\t// limit is the size limit of the filesystem.\n+\t//\n+\t// limit is atomic to allow the limit to be safely changed after the\n+\t// filesystem was created.\n+\t//\n+\t// A limit of `-1` disables any write operation from being performed.\n+\t// A limit of `0` disables any limit checking.\n+\tlimit atomic.Int64\n+\n+\t// usage is the current usage of the filesystem.\n+\t//\n+\t// If usage is set to `-1`, it hasn't been calculated yet.\n+\tusage atomic.Int64\n+}\n+\n+func NewQuota(fs *UnixFS, limit int64) *Quota {\n+\tqfs := Quota{UnixFS: fs}\n+\tqfs.limit.Store(limit)\n+\treturn &qfs\n+}\n+\n+// Close closes the filesystem.\n+func (fs *Quota) Close() (err error) {\n+\terr = fs.UnixFS.Close()\n+\treturn\n+}\n+\n+// Limit returns the limit of the filesystem.\n+func (fs *Quota) Limit() int64 {\n+\treturn fs.limit.Load()\n+}\n+\n+// SetLimit returns the limit of the filesystem.\n+func (fs *Quota) SetLimit(newLimit int64) int64 {\n+\treturn fs.limit.Swap(newLimit)\n+}\n+\n+// Usage returns the current usage of the filesystem.\n+func (fs *Quota) Usage() int64 {\n+\treturn fs.usage.Load()\n+}\n+\n+// SetUsage updates the total usage of the filesystem.\n+func (fs *Quota) SetUsage(newUsage int64) int64 {\n+\treturn fs.usage.Swap(newUsage)\n+}\n+\n+// Add adds `i` to the tracked usage total.\n+func (fs *Quota) Add(i int64) int64 {\n+\tusage := fs.Usage()\n+\n+\t// If adding `i` to the usage will put us below 0, cap it. (`i` can be negative)\n+\tif usage+i < 0 {\n+\t\tfs.usage.Store(0)\n+\t\treturn 0\n+\t}\n+\treturn fs.usage.Add(i)\n+}\n+\n+// CanFit checks if the given size can fit in the filesystem without exceeding\n+// the limit of the filesystem.\n+func (fs *Quota) CanFit(size int64) bool {\n+\t// Get the size limit of the filesystem.\n+\tlimit := fs.Limit()\n+\tswitch limit {\n+\tcase -1:\n+\t\t// A limit of -1 means no write operations are allowed.\n+\t\treturn false\n+\tcase 0:\n+\t\t// A limit of 0 means unlimited.\n+\t\treturn true\n+\t}\n+\n+\t// Any other limit is a value we need to check.\n+\tusage := fs.Usage()\n+\tif usage == -1 {\n+\t\t// We don't know what the current usage is yet.\n+\t\treturn true\n+\t}\n+\n+\t// If the current usage + the requested size are under the limit of the\n+\t// filesystem, allow it.\n+\tif usage+size <= limit {\n+\t\treturn true\n+\t}\n+\n+\t// Welp, the size would exceed the limit of the filesystem, deny it.\n+\treturn false\n+}\n+\n+func (fs *Quota) Remove(name string) error {\n+\t// For information on why this interface is used here, check its\n+\t// documentation.\n+\ts, err := fs.RemoveStat(name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Don't reduce the quota's usage as `name` is not a regular file.\n+\tif !s.Mode().IsRegular() {\n+\t\treturn nil\n+\t}\n+\n+\t// Remove the size of the deleted file from the quota usage.\n+\tfs.Add(-s.Size())\n+\treturn nil\n+}\n+\n+// RemoveAll removes path and any children it contains.\n+//\n+// It removes everything it can but returns the first error\n+// it encounters. If the path does not exist, RemoveAll\n+// returns nil (no error).\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *Quota) RemoveAll(name string) error {\n+\tname, err := fs.unsafePath(name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t// While removeAll internally checks this, I want to make sure we check it\n+\t// and return the proper error so our tests can ensure that this will never\n+\t// be a possibility.\n+\tif name == \".\" {\n+\t\treturn &PathError{\n+\t\t\tOp:   \"removeall\",\n+\t\t\tPath: name,\n+\t\t\tErr:  ErrBadPathResolution,\n+\t\t}\n+\t}\n+\treturn fs.removeAll(name)\n+}\n+\n+func (fs *Quota) removeAll(path string) error {\n+\treturn removeAll(fs, path)\n+}\n+\n+func (fs *Quota) unlinkat(dirfd int, name string, flags int) error {\n+\tif flags == 0 {\n+\t\ts, err := fs.Lstatat(dirfd, name)\n+\t\tif err == nil && s.Mode().IsRegular() {\n+\t\t\tfs.Add(-s.Size())\n+\t\t}\n+\t}\n+\treturn fs.UnixFS.unlinkat(dirfd, name, flags)\n+}"
        },
        {
          "filename": "internal/ufs/fs_unix.go",
          "status": "added",
          "additions": 825,
          "deletions": 0,
          "patch": "@@ -0,0 +1,825 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+//go:build unix\n+\n+package ufs\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync/atomic\"\n+\t\"time\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+// UnixFS is a filesystem that uses the unix package to make io calls.\n+//\n+// This is used for proper sand-boxing and full control over the exact syscalls\n+// being performed.\n+type UnixFS struct {\n+\t// basePath is the base path for file operations to take place in.\n+\tbasePath string\n+\n+\t// dirfd holds the file descriptor of BasePath and is used to ensure\n+\t// operations are restricted into descendants of BasePath.\n+\tdirfd atomic.Int64\n+\n+\t// useOpenat2 controls whether the `openat2` syscall is used instead of the\n+\t// older `openat` syscall.\n+\tuseOpenat2 bool\n+}\n+\n+// NewUnixFS creates a new sandboxed unix filesystem. BasePath is used as the\n+// sandbox path, operations on BasePath itself are not allowed, but any\n+// operations on its descendants are. Symlinks pointing outside BasePath are\n+// checked and prevented from enabling an escape in a non-raceable manor.\n+func NewUnixFS(basePath string, useOpenat2 bool) (*UnixFS, error) {\n+\tbasePath = strings.TrimSuffix(basePath, \"/\")\n+\t// We don't need Openat2, if we are given a basePath that is already unsafe\n+\t// I give up on trying to sandbox it.\n+\tdirfd, err := unix.Openat(AT_EMPTY_PATH, basePath, O_DIRECTORY|O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn nil, convertErrorType(err)\n+\t}\n+\n+\tfs := &UnixFS{\n+\t\tbasePath:   basePath,\n+\t\tuseOpenat2: useOpenat2,\n+\t}\n+\tfs.dirfd.Store(int64(dirfd))\n+\treturn fs, nil\n+}\n+\n+// BasePath returns the base path of the UnixFS sandbox, file operations\n+// pointing outside this path are prohibited and will be blocked by all\n+// operations implemented by UnixFS.\n+func (fs *UnixFS) BasePath() string {\n+\treturn fs.basePath\n+}\n+\n+// Close releases the file descriptor used to sandbox operations within the\n+// base path of the filesystem.\n+func (fs *UnixFS) Close() error {\n+\t// Once closed, change dirfd to something invalid to detect when it has been\n+\t// closed.\n+\tdefer func() {\n+\t\tfs.dirfd.Store(-1)\n+\t}()\n+\treturn unix.Close(int(fs.dirfd.Load()))\n+}\n+\n+// Chmod changes the mode of the named file to mode.\n+//\n+// If the file is a symbolic link, it changes the mode of the link's target.\n+// If there is an error, it will be of type *PathError.\n+//\n+// A different subset of the mode bits are used, depending on the\n+// operating system.\n+//\n+// On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\n+// ModeSticky are used.\n+//\n+// On Windows, only the 0200 bit (owner writable) of mode is used; it\n+// controls whether the file's read-only attribute is set or cleared.\n+// The other bits are currently unused. For compatibility with Go 1.12\n+// and earlier, use a non-zero mode. Use mode 0400 for a read-only\n+// file and 0600 for a readable+writable file.\n+//\n+// On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\n+// and ModeTemporary are used.\n+func (fs *UnixFS) Chmod(name string, mode FileMode) error {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn convertErrorType(unix.Fchmodat(dirfd, name, uint32(mode), 0))\n+}\n+\n+// Chown changes the numeric uid and gid of the named file.\n+//\n+// If the file is a symbolic link, it changes the uid and gid of the link's target.\n+// A uid or gid of -1 means to not change that value.\n+// If there is an error, it will be of type *PathError.\n+//\n+// On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\n+// EPLAN9 error, wrapped in *PathError.\n+func (fs *UnixFS) Chown(name string, uid, gid int) error {\n+\treturn fs.fchown(name, uid, gid, 0)\n+}\n+\n+// Lchown changes the numeric uid and gid of the named file.\n+//\n+// If the file is a symbolic link, it changes the uid and gid of the link itself.\n+// If there is an error, it will be of type *PathError.\n+//\n+// On Windows, it always returns the syscall.EWINDOWS error, wrapped\n+// in *PathError.\n+func (fs *UnixFS) Lchown(name string, uid, gid int) error {\n+\t// With AT_SYMLINK_NOFOLLOW, Fchownat acts like Lchown but allows us to\n+\t// pass a dirfd.\n+\treturn fs.fchown(name, uid, gid, AT_SYMLINK_NOFOLLOW)\n+}\n+\n+// fchown is a re-usable Fchownat syscall used by Chown and Lchown.\n+func (fs *UnixFS) fchown(name string, uid, gid, flags int) error {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn convertErrorType(unix.Fchownat(dirfd, name, uid, gid, flags))\n+}\n+\n+// Chownat is like Chown but allows passing an existing directory file\n+// descriptor rather than needing to resolve one.\n+func (fs *UnixFS) Chownat(dirfd int, name string, uid, gid int) error {\n+\treturn convertErrorType(unix.Fchownat(dirfd, name, uid, gid, 0))\n+}\n+\n+// Lchownat is like Lchown but allows passing an existing directory file\n+// descriptor rather than needing to resolve one.\n+func (fs *UnixFS) Lchownat(dirfd int, name string, uid, gid int) error {\n+\treturn convertErrorType(unix.Fchownat(dirfd, name, uid, gid, AT_SYMLINK_NOFOLLOW))\n+}\n+\n+// Chtimes changes the access and modification times of the named\n+// file, similar to the Unix utime() or utimes() functions.\n+//\n+// The underlying filesystem may truncate or round the values to a\n+// less precise time unit.\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Chtimes(name string, atime, mtime time.Time) error {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn fs.Chtimesat(dirfd, name, atime, mtime)\n+}\n+\n+// Chtimesat is like Chtimes but allows passing an existing directory file\n+// descriptor rather than needing to resolve one.\n+func (fs *UnixFS) Chtimesat(dirfd int, name string, atime, mtime time.Time) error {\n+\tvar utimes [2]unix.Timespec\n+\tset := func(i int, t time.Time) {\n+\t\tif t.IsZero() {\n+\t\t\tutimes[i] = unix.Timespec{Sec: unix.UTIME_OMIT, Nsec: unix.UTIME_OMIT}\n+\t\t} else {\n+\t\t\tutimes[i] = unix.NsecToTimespec(t.UnixNano())\n+\t\t}\n+\t}\n+\tset(0, atime)\n+\tset(1, mtime)\n+\t// This does support `AT_SYMLINK_NOFOLLOW` as well if needed.\n+\tif err := unix.UtimesNanoAt(dirfd, name, utimes[0:], 0); err != nil {\n+\t\treturn convertErrorType(&PathError{Op: \"chtimes\", Path: name, Err: err})\n+\t}\n+\treturn nil\n+}\n+\n+// Create creates or truncates the named file. If the file already exists,\n+// it is truncated.\n+//\n+// If the file does not exist, it is created with mode 0666\n+// (before umask). If successful, methods on the returned File can\n+// be used for I/O; the associated file descriptor has mode O_RDWR.\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Create(name string) (File, error) {\n+\treturn fs.OpenFile(name, O_CREATE|O_WRONLY|O_TRUNC, 0o644)\n+}\n+\n+// Mkdir creates a new directory with the specified name and permission\n+// bits (before umask).\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Mkdir(name string, mode FileMode) error {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn fs.Mkdirat(dirfd, name, mode)\n+}\n+\n+func (fs *UnixFS) Mkdirat(dirfd int, name string, mode FileMode) error {\n+\treturn convertErrorType(unix.Mkdirat(dirfd, name, uint32(mode)))\n+}\n+\n+// MkdirAll creates a directory named path, along with any necessary\n+// parents, and returns nil, or else returns an error.\n+//\n+// The permission bits perm (before umask) are used for all\n+// directories that MkdirAll creates.\n+// If path is already a directory, MkdirAll does nothing\n+// and returns nil.\n+func (fs *UnixFS) MkdirAll(name string, mode FileMode) error {\n+\t// Ensure name is somewhat clean before continuing.\n+\tname, err := fs.unsafePath(name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn fs.mkdirAll(name, mode)\n+}\n+\n+// Open opens the named file for reading.\n+//\n+// If successful, methods on the returned file can be used for reading; the\n+// associated file descriptor has mode O_RDONLY.\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Open(name string) (File, error) {\n+\treturn fs.OpenFile(name, O_RDONLY, 0)\n+}\n+\n+// OpenFile is the generalized open call; most users will use Open\n+// or Create instead. It opens the named file with specified flag\n+// (O_RDONLY etc.).\n+//\n+// If the file does not exist, and the O_CREATE flag\n+// is passed, it is created with mode perm (before umask). If successful,\n+// methods on the returned File can be used for I/O.\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) OpenFile(name string, flag int, mode FileMode) (File, error) {\n+\tfd, err := fs.openFile(name, flag, mode)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// Do not close `fd` here, it is passed to a file that needs the fd, the\n+\t// caller of this function is responsible for calling Close() on the File\n+\t// to release the file descriptor.\n+\treturn os.NewFile(uintptr(fd), name), nil\n+}\n+\n+func (fs *UnixFS) openFile(name string, flag int, mode FileMode) (int, error) {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn fs.openat(dirfd, name, flag, mode)\n+}\n+\n+func (fs *UnixFS) OpenFileat(dirfd int, name string, flag int, mode FileMode) (File, error) {\n+\tfd, err := fs.openat(dirfd, name, flag, mode)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// Do not close `fd` here, it is passed to a file that needs the fd, the\n+\t// caller of this function is responsible for calling Close() on the File\n+\t// to release the file descriptor.\n+\treturn os.NewFile(uintptr(fd), name), nil\n+}\n+\n+// ReadDir reads the named directory,\n+//\n+// returning all its directory entries sorted by filename.\n+// If an error occurs reading the directory, ReadDir returns the entries it\n+// was able to read before the error, along with the error.\n+func (fs *UnixFS) ReadDir(path string) ([]DirEntry, error) {\n+\tdirfd, name, closeFd, err := fs.safePath(path)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfd, err := fs.openat(dirfd, name, O_DIRECTORY|O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unix.Close(fd)\n+\treturn fs.readDir(fd, name, nil)\n+}\n+\n+// RemoveStat is a combination of Stat and Remove, it is used to more\n+// efficiently remove a file when the caller needs to stat it before\n+// removing it.\n+//\n+// This optimized function exists for our QuotaFS abstraction, which needs\n+// to track writes to a filesystem. When removing a file, the QuotaFS needs\n+// to know if the entry is a file and if so, how large it is. Because we\n+// need to Stat a file in order to get its mode and size, we will already\n+// know if the entry needs to be removed by using Unlink or Rmdir. The\n+// standard `Remove` method just tries both Unlink and Rmdir (in that order)\n+// as it ends up usually being faster and more efficient than calling Stat +\n+// the proper operation in the first place.\n+func (fs *UnixFS) RemoveStat(name string) (FileInfo, error) {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Lstat name, we use Lstat as Unlink doesn't care about symlinks.\n+\ts, err := fs.Lstatat(dirfd, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif s.IsDir() {\n+\t\terr = fs.unlinkat(dirfd, name, AT_REMOVEDIR) // Rmdir\n+\t} else {\n+\t\terr = fs.unlinkat(dirfd, name, 0)\n+\t}\n+\tif err != nil {\n+\t\treturn s, convertErrorType(&PathError{Op: \"remove\", Path: name, Err: err})\n+\t}\n+\treturn s, nil\n+}\n+\n+// Remove removes the named file or (empty) directory.\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Remove(name string) error {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Prevent trying to Remove the base directory.\n+\tif name == \".\" {\n+\t\treturn &PathError{\n+\t\t\tOp:   \"remove\",\n+\t\t\tPath: name,\n+\t\t\tErr:  ErrBadPathResolution,\n+\t\t}\n+\t}\n+\n+\t// System call interface forces us to know\n+\t// whether name is a file or directory.\n+\t// Try both: it is cheaper on average than\n+\t// doing a Stat plus the right one.\n+\terr = fs.unlinkat(dirfd, name, 0)\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\terr1 := fs.unlinkat(dirfd, name, AT_REMOVEDIR) // Rmdir\n+\tif err1 == nil {\n+\t\treturn nil\n+\t}\n+\n+\t// Both failed: figure out which error to return.\n+\t// OS X and Linux differ on whether unlink(dir)\n+\t// returns EISDIR, so can't use that. However,\n+\t// both agree that rmdir(file) returns ENOTDIR,\n+\t// so we can use that to decide which error is real.\n+\t// Rmdir might also return ENOTDIR if given a bad\n+\t// file path, like /etc/passwd/foo, but in that case,\n+\t// both errors will be ENOTDIR, so it's okay to\n+\t// use the error from unlink.\n+\tif err1 != unix.ENOTDIR {\n+\t\terr = err1\n+\t}\n+\treturn convertErrorType(&PathError{Op: \"remove\", Path: name, Err: err})\n+}\n+\n+// RemoveAll removes path and any children it contains.\n+//\n+// It removes everything it can but returns the first error\n+// it encounters. If the path does not exist, RemoveAll\n+// returns nil (no error).\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) RemoveAll(name string) error {\n+\tname, err := fs.unsafePath(name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t// While removeAll internally checks this, I want to make sure we check it\n+\t// and return the proper error so our tests can ensure that this will never\n+\t// be a possibility.\n+\tif name == \".\" {\n+\t\treturn &PathError{\n+\t\t\tOp:   \"removeall\",\n+\t\t\tPath: name,\n+\t\t\tErr:  ErrBadPathResolution,\n+\t\t}\n+\t}\n+\treturn fs.removeAll(name)\n+}\n+\n+func (fs *UnixFS) unlinkat(dirfd int, name string, flags int) error {\n+\treturn ignoringEINTR(func() error {\n+\t\treturn unix.Unlinkat(dirfd, name, flags)\n+\t})\n+}\n+\n+// Rename renames (moves) oldpath to newpath.\n+//\n+// If newpath already exists and is not a directory, Rename replaces it.\n+// OS-specific restrictions may apply when oldpath and newpath are in different directories.\n+// Even within the same directory, on non-Unix platforms Rename is not an atomic operation.\n+//\n+// If there is an error, it will be of type *LinkError.\n+func (fs *UnixFS) Rename(oldpath, newpath string) error {\n+\t// Simple case: both paths are the same.\n+\tif oldpath == newpath {\n+\t\treturn nil\n+\t}\n+\n+\tolddirfd, oldname, closeFd, err := fs.safePath(oldpath)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t// Ensure that we are not trying to rename the base directory itself.\n+\t// While unix.Renameat ends up throwing a \"device or resource busy\" error,\n+\t// that doesn't mean we are protecting the system properly.\n+\tif oldname == \".\" {\n+\t\treturn convertErrorType(&PathError{\n+\t\t\tOp:   \"rename\",\n+\t\t\tPath: oldname,\n+\t\t\tErr:  ErrBadPathResolution,\n+\t\t})\n+\t}\n+\t// Stat the old target to return proper errors.\n+\tif _, err := fs.Lstatat(olddirfd, oldname); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tnewdirfd, newname, closeFd2, err := fs.safePath(newpath)\n+\tif err != nil {\n+\t\tcloseFd2()\n+\t\tif !errors.Is(err, ErrNotExist) {\n+\t\t\treturn convertErrorType(err)\n+\t\t}\n+\t\tvar pathErr *PathError\n+\t\tif !errors.As(err, &pathErr) {\n+\t\t\treturn convertErrorType(err)\n+\t\t}\n+\t\tif err := fs.MkdirAll(pathErr.Path, 0o755); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tnewdirfd, newname, closeFd2, err = fs.safePath(newpath)\n+\t\tdefer closeFd2()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t} else {\n+\t\tdefer closeFd2()\n+\t}\n+\n+\t// Ensure that we are not trying to rename the base directory itself.\n+\t// While unix.Renameat ends up throwing a \"device or resource busy\" error,\n+\t// that doesn't mean we are protecting the system properly.\n+\tif newname == \".\" {\n+\t\treturn convertErrorType(&PathError{\n+\t\t\tOp:   \"rename\",\n+\t\t\tPath: newname,\n+\t\t\tErr:  ErrBadPathResolution,\n+\t\t})\n+\t}\n+\t// Stat the new target to return proper errors.\n+\t_, err = fs.Lstatat(newdirfd, newname)\n+\tswitch {\n+\tcase err == nil:\n+\t\treturn convertErrorType(&PathError{\n+\t\t\tOp:   \"rename\",\n+\t\t\tPath: newname,\n+\t\t\tErr:  ErrExist,\n+\t\t})\n+\tcase !errors.Is(err, ErrNotExist):\n+\t\treturn err\n+\t}\n+\treturn unix.Renameat(olddirfd, oldname, newdirfd, newname)\n+}\n+\n+// Stat returns a FileInfo describing the named file.\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Stat(name string) (FileInfo, error) {\n+\treturn fs.fstat(name, 0)\n+}\n+\n+// Statat is like Stat but allows passing an existing directory file\n+// descriptor rather than needing to resolve one.\n+func (fs *UnixFS) Statat(dirfd int, name string) (FileInfo, error) {\n+\treturn fs.fstatat(dirfd, name, 0)\n+}\n+\n+// Lstat returns a FileInfo describing the named file.\n+//\n+// If the file is a symbolic link, the returned FileInfo\n+// describes the symbolic link. Lstat makes no attempt to follow the link.\n+//\n+// If there is an error, it will be of type *PathError.\n+func (fs *UnixFS) Lstat(name string) (FileInfo, error) {\n+\treturn fs.fstat(name, AT_SYMLINK_NOFOLLOW)\n+}\n+\n+// Lstatat is like Lstat but allows passing an existing directory file\n+// descriptor rather than needing to resolve one.\n+func (fs *UnixFS) Lstatat(dirfd int, name string) (FileInfo, error) {\n+\treturn fs.fstatat(dirfd, name, AT_SYMLINK_NOFOLLOW)\n+}\n+\n+func (fs *UnixFS) fstat(name string, flags int) (FileInfo, error) {\n+\tdirfd, name, closeFd, err := fs.safePath(name)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn fs.fstatat(dirfd, name, flags)\n+}\n+\n+func (fs *UnixFS) fstatat(dirfd int, name string, flags int) (FileInfo, error) {\n+\tvar s fileStat\n+\tif err := ignoringEINTR(func() error {\n+\t\treturn unix.Fstatat(dirfd, name, &s.sys, flags)\n+\t}); err != nil {\n+\t\treturn nil, &PathError{Op: \"stat\", Path: name, Err: err}\n+\t}\n+\tfillFileStatFromSys(&s, name)\n+\treturn &s, nil\n+}\n+\n+// Symlink creates newname as a symbolic link to oldname.\n+//\n+// On Windows, a symlink to a non-existent oldname creates a file symlink;\n+// if oldname is later created as a directory the symlink will not work.\n+//\n+// If there is an error, it will be of type *LinkError.\n+func (fs *UnixFS) Symlink(oldpath, newpath string) error {\n+\tdirfd, newpath, closeFd, err := fs.safePath(newpath)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif err := ignoringEINTR(func() error {\n+\t\t// We aren't concerned with oldpath here as a symlink can point anywhere\n+\t\t// it wants.\n+\t\treturn unix.Symlinkat(oldpath, dirfd, newpath)\n+\t}); err != nil {\n+\t\treturn &LinkError{Op: \"symlink\", Old: oldpath, New: newpath, Err: err}\n+\t}\n+\treturn nil\n+}\n+\n+// Touch will attempt to open a file for reading and/or writing. If the file\n+// does not exist it will be created, and any missing parent directories will\n+// also be created. The opened file may be truncated, only if `flag` has\n+// O_TRUNC set.\n+func (fs *UnixFS) Touch(path string, flag int, mode FileMode) (File, error) {\n+\tif flag&O_CREATE == 0 {\n+\t\tflag |= O_CREATE\n+\t}\n+\tdirfd, name, closeFd, err := fs.safePath(path)\n+\tdefer closeFd()\n+\tif err == nil {\n+\t\treturn fs.OpenFileat(dirfd, name, flag, mode)\n+\t}\n+\tif !errors.Is(err, ErrNotExist) {\n+\t\treturn nil, err\n+\t}\n+\tvar pathErr *PathError\n+\tif !errors.As(err, &pathErr) {\n+\t\treturn nil, err\n+\t}\n+\tif err := fs.MkdirAll(pathErr.Path, 0o755); err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// Try to open the file one more time after creating its parent directories.\n+\treturn fs.OpenFile(path, flag, mode)\n+}\n+\n+// WalkDir walks the file tree rooted at root, calling fn for each file or\n+// directory in the tree, including root.\n+//\n+// All errors that arise visiting files and directories are filtered by fn:\n+// see the [WalkDirFunc] documentation for details.\n+//\n+// The files are walked in lexical order, which makes the output deterministic\n+// but requires WalkDir to read an entire directory into memory before proceeding\n+// to walk that directory.\n+//\n+// WalkDir does not follow symbolic links found in directories,\n+// but if root itself is a symbolic link, its target will be walked.\n+func (fs *UnixFS) WalkDir(root string, fn WalkDirFunc) error {\n+\treturn WalkDir(fs, root, fn)\n+}\n+\n+// openat is a wrapper around both unix.Openat and unix.Openat2. If the UnixFS\n+// was configured to enable openat2 support, unix.Openat2 will be used instead\n+// of unix.Openat due to having better security properties for our use-case.\n+func (fs *UnixFS) openat(dirfd int, name string, flag int, mode FileMode) (int, error) {\n+\tif flag&O_NOFOLLOW == 0 {\n+\t\tflag |= O_NOFOLLOW\n+\t}\n+\n+\tvar fd int\n+\tfor {\n+\t\tvar err error\n+\t\tif fs.useOpenat2 {\n+\t\t\tfd, err = fs._openat2(dirfd, name, uint64(flag), uint64(syscallMode(mode)))\n+\t\t} else {\n+\t\t\tfd, err = fs._openat(dirfd, name, flag, uint32(syscallMode(mode)))\n+\t\t}\n+\t\tif err == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\t// We have to check EINTR here, per issues https://go.dev/issue/11180 and https://go.dev/issue/39237.\n+\t\tif err == unix.EINTR {\n+\t\t\tcontinue\n+\t\t}\n+\t\treturn 0, convertErrorType(err)\n+\t}\n+\n+\t// If we are not using openat2, do additional path checking. This assumes\n+\t// that openat2 is using `RESOLVE_BENEATH` to avoid the same security\n+\t// issue.\n+\tif !fs.useOpenat2 {\n+\t\tvar finalPath string\n+\t\tfinalPath, err := filepath.EvalSymlinks(filepath.Join(\"/proc/self/fd/\", strconv.Itoa(dirfd)))\n+\t\tif err != nil {\n+\t\t\treturn fd, convertErrorType(err)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tif !errors.Is(err, ErrNotExist) {\n+\t\t\t\treturn fd, fmt.Errorf(\"failed to evaluate symlink: %w\", convertErrorType(err))\n+\t\t\t}\n+\n+\t\t\t// The target of one of the symlinks (EvalSymlinks is recursive)\n+\t\t\t// does not exist. So get the path that does not exist and use\n+\t\t\t// that for further validation instead.\n+\t\t\tvar pErr *PathError\n+\t\t\tif ok := errors.As(err, &pErr); !ok {\n+\t\t\t\treturn fd, fmt.Errorf(\"failed to evaluate symlink: %w\", convertErrorType(err))\n+\t\t\t}\n+\t\t\tfinalPath = pErr.Path\n+\t\t}\n+\n+\t\t// Check if the path is within our root.\n+\t\tif !fs.unsafeIsPathInsideOfBase(finalPath) {\n+\t\t\treturn fd, convertErrorType(&PathError{\n+\t\t\t\tOp:   \"openat\",\n+\t\t\t\tPath: name,\n+\t\t\t\tErr:  ErrBadPathResolution,\n+\t\t\t})\n+\t\t}\n+\t}\n+\treturn fd, nil\n+}\n+\n+// _openat is a wrapper around unix.Openat. This method should never be directly\n+// called, use `openat` instead.\n+func (fs *UnixFS) _openat(dirfd int, name string, flag int, mode uint32) (int, error) {\n+\t// Ensure the O_CLOEXEC flag is set.\n+\t// Go sets this in the os package, but since we are directly using unix\n+\t// we need to set it ourselves.\n+\tif flag&O_CLOEXEC == 0 {\n+\t\tflag |= O_CLOEXEC\n+\t}\n+\t// O_LARGEFILE is set by Openat for us automatically.\n+\tfd, err := unix.Openat(dirfd, name, flag, mode)\n+\tswitch {\n+\tcase err == nil:\n+\t\treturn fd, nil\n+\tcase err == unix.EINTR:\n+\t\treturn 0, err\n+\tcase err == unix.EAGAIN:\n+\t\treturn 0, err\n+\tdefault:\n+\t\treturn 0, &PathError{Op: \"openat\", Path: name, Err: err}\n+\t}\n+}\n+\n+// _openat2 is a wonderful syscall that supersedes the `openat` syscall. It has\n+// improved validation and security characteristics that weren't available or\n+// considered when `openat` was originally implemented. As such, it is only\n+// present in Kernel 5.6 and above.\n+//\n+// This method should never be directly called, use `openat` instead.\n+func (fs *UnixFS) _openat2(dirfd int, name string, flag uint64, mode uint64) (int, error) {\n+\t// Ensure the O_CLOEXEC flag is set.\n+\t// Go sets this when using the os package, but since we are directly using\n+\t// the unix package we need to set it ourselves.\n+\tif flag&O_CLOEXEC == 0 {\n+\t\tflag |= O_CLOEXEC\n+\t}\n+\t// Ensure the O_LARGEFILE flag is set.\n+\t// Go sets this for unix.Open, unix.Openat, but not unix.Openat2.\n+\tif flag&O_LARGEFILE == 0 {\n+\t\tflag |= O_LARGEFILE\n+\t}\n+\tfd, err := unix.Openat2(dirfd, name, &unix.OpenHow{\n+\t\tFlags: flag,\n+\t\tMode:  mode,\n+\t\t// This is the bread and butter of preventing a symlink escape, without\n+\t\t// this option, we have to handle path validation fully on our own.\n+\t\t//\n+\t\t// This is why using Openat2 over Openat is preferred if available.\n+\t\tResolve: unix.RESOLVE_BENEATH,\n+\t})\n+\tswitch {\n+\tcase err == nil:\n+\t\treturn fd, nil\n+\tcase err == unix.EINTR:\n+\t\treturn 0, err\n+\tcase err == unix.EAGAIN:\n+\t\treturn 0, err\n+\tdefault:\n+\t\treturn 0, &PathError{Op: \"openat2\", Path: name, Err: err}\n+\t}\n+}\n+\n+func (fs *UnixFS) SafePath(path string) (int, string, func(), error) {\n+\treturn fs.safePath(path)\n+}\n+\n+func (fs *UnixFS) safePath(path string) (dirfd int, file string, closeFd func(), err error) {\n+\t// Default closeFd to a NO-OP.\n+\tcloseFd = func() {}\n+\n+\t// Use unsafePath to clean the path and strip BasePath if path is absolute.\n+\tvar name string\n+\tname, err = fs.unsafePath(path)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t// Check if dirfd was closed, this will happen if (*UnixFS).Close()\n+\t// was called.\n+\tfsDirfd := int(fs.dirfd.Load())\n+\tif fsDirfd == -1 {\n+\t\terr = ErrClosed\n+\t\treturn\n+\t}\n+\n+\t// Split the parent from the last element in the path, this gives us the\n+\t// \"file name\" and the full path to its parent.\n+\tvar dir string\n+\tdir, file = filepath.Split(name)\n+\t// If dir is empty then name is not nested.\n+\tif dir == \"\" {\n+\t\t// We don't need to set closeFd here as it will default to a NO-OP and\n+\t\t// `fs.dirfd` is re-used until the filesystem is no-longer needed.\n+\t\tdirfd = fsDirfd\n+\n+\t\t// Return dirfd, name, an empty closeFd func, and no error\n+\t\treturn\n+\t}\n+\n+\t// Dir will usually contain a trailing slash as filepath.Split doesn't\n+\t// trim slashes.\n+\tdir = strings.TrimSuffix(dir, \"/\")\n+\tdirfd, err = fs.openat(fsDirfd, dir, O_DIRECTORY|O_RDONLY, 0)\n+\tif dirfd != 0 {\n+\t\t// Set closeFd to close the newly opened directory file descriptor.\n+\t\tcloseFd = func() { _ = unix.Close(dirfd) }\n+\t}\n+\n+\t// Return dirfd, name, the closeFd func, and err\n+\treturn\n+}\n+\n+// unsafePath prefixes the given path and prefixes it with the filesystem's\n+// base path, cleaning the result. The path returned by this function may not\n+// be inside the filesystem's base path, additional checks are required to\n+// safely use paths returned by this function.\n+func (fs *UnixFS) unsafePath(path string) (string, error) {\n+\t// Calling filepath.Clean on the joined directory will resolve it to the\n+\t// absolute path, removing any ../ type of resolution arguments, and leaving\n+\t// us with a direct path link.\n+\t//\n+\t// This will also trim the existing root path off the beginning of the path\n+\t// passed to the function since that can get a bit messy.\n+\tr := filepath.Clean(filepath.Join(fs.basePath, strings.TrimPrefix(path, fs.basePath)))\n+\n+\tif fs.unsafeIsPathInsideOfBase(r) {\n+\t\t// This is kinda ironic isn't it.\n+\t\t// We do this as we are operating with dirfds and `*at` syscalls which\n+\t\t// behave differently if given an absolute path.\n+\t\t//\n+\t\t// First trim the BasePath, then trim any leading slashes.\n+\t\tr = strings.TrimPrefix(strings.TrimPrefix(r, fs.basePath), \"/\")\n+\t\t// If the path is empty then return \".\" as the path is pointing to the\n+\t\t// root.\n+\t\tif r == \"\" {\n+\t\t\treturn \".\", nil\n+\t\t}\n+\t\treturn r, nil\n+\t}\n+\n+\treturn \"\", &PathError{\n+\t\tOp:   \"safePath\",\n+\t\tPath: path,\n+\t\tErr:  ErrBadPathResolution,\n+\t}\n+}\n+\n+// unsafeIsPathInsideOfBase checks if the given path is inside the filesystem's\n+// base path.\n+func (fs *UnixFS) unsafeIsPathInsideOfBase(path string) bool {\n+\treturn strings.HasPrefix(\n+\t\tstrings.TrimSuffix(path, \"/\")+\"/\",\n+\t\tfs.basePath+\"/\",\n+\t)\n+}"
        },
        {
          "filename": "internal/ufs/fs_unix_test.go",
          "status": "added",
          "additions": 255,
          "deletions": 0,
          "patch": "@@ -0,0 +1,255 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+//go:build unix\n+\n+package ufs_test\n+\n+import (\n+\t\"errors\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n+)\n+\n+type testUnixFS struct {\n+\t*ufs.UnixFS\n+\n+\tTmpDir string\n+\tRoot   string\n+}\n+\n+func (fs *testUnixFS) Cleanup() {\n+\t_ = fs.Close()\n+\t_ = os.RemoveAll(fs.TmpDir)\n+}\n+\n+func newTestUnixFS() (*testUnixFS, error) {\n+\ttmpDir, err := os.MkdirTemp(os.TempDir(), \"ufs\")\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\troot := filepath.Join(tmpDir, \"root\")\n+\tif err := os.Mkdir(root, 0o755); err != nil {\n+\t\treturn nil, err\n+\t}\n+\t// TODO: test both disabled and enabled.\n+\tfs, err := ufs.NewUnixFS(root, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\ttfs := &testUnixFS{\n+\t\tUnixFS: fs,\n+\t\tTmpDir: tmpDir,\n+\t\tRoot:   root,\n+\t}\n+\treturn tfs, nil\n+}\n+\n+func TestUnixFS_Remove(t *testing.T) {\n+\tt.Parallel()\n+\tfs, err := newTestUnixFS()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t\treturn\n+\t}\n+\tdefer fs.Cleanup()\n+\n+\tt.Run(\"base directory\", func(t *testing.T) {\n+\t\t// Try to remove the base directory.\n+\t\tif err := fs.Remove(\"\"); !errors.Is(err, ufs.ErrBadPathResolution) {\n+\t\t\tt.Errorf(\"expected an a bad path resolution error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"path traversal\", func(t *testing.T) {\n+\t\t// Try to remove the base directory.\n+\t\tif err := fs.RemoveAll(\"../root\"); !errors.Is(err, ufs.ErrBadPathResolution) {\n+\t\t\tt.Errorf(\"expected an a bad path resolution error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+}\n+\n+func TestUnixFS_RemoveAll(t *testing.T) {\n+\tt.Parallel()\n+\tfs, err := newTestUnixFS()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t\treturn\n+\t}\n+\tdefer fs.Cleanup()\n+\n+\tt.Run(\"base directory\", func(t *testing.T) {\n+\t\t// Try to remove the base directory.\n+\t\tif err := fs.RemoveAll(\"\"); !errors.Is(err, ufs.ErrBadPathResolution) {\n+\t\t\tt.Errorf(\"expected an a bad path resolution error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"path traversal\", func(t *testing.T) {\n+\t\t// Try to remove the base directory.\n+\t\tif err := fs.RemoveAll(\"../root\"); !errors.Is(err, ufs.ErrBadPathResolution) {\n+\t\t\tt.Errorf(\"expected an a bad path resolution error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+}\n+\n+func TestUnixFS_Rename(t *testing.T) {\n+\tt.Parallel()\n+\tfs, err := newTestUnixFS()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t\treturn\n+\t}\n+\tdefer fs.Cleanup()\n+\n+\tt.Run(\"rename base directory\", func(t *testing.T) {\n+\t\t// Try to rename the base directory.\n+\t\tif err := fs.Rename(\"\", \"yeet\"); !errors.Is(err, ufs.ErrBadPathResolution) {\n+\t\t\tt.Errorf(\"expected an a bad path resolution error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"rename over base directory\", func(t *testing.T) {\n+\t\t// Create a directory that we are going to try and move over top of the\n+\t\t// existing base directory.\n+\t\tif err := fs.Mkdir(\"overwrite_dir\", 0o755); err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Try to rename over the base directory.\n+\t\tif err := fs.Rename(\"overwrite_dir\", \"\"); !errors.Is(err, ufs.ErrBadPathResolution) {\n+\t\t\tt.Errorf(\"expected an a bad path resolution error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"directory rename\", func(t *testing.T) {\n+\t\t// Create a directory to rename to something else.\n+\t\tif err := fs.Mkdir(\"test_directory\", 0o755); err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Try to rename \"test_directory\" to \"directory\".\n+\t\tif err := fs.Rename(\"test_directory\", \"directory\"); err != nil {\n+\t\t\tt.Errorf(\"expected no error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Sanity check\n+\t\tif _, err := os.Lstat(filepath.Join(fs.Root, \"directory\")); err != nil {\n+\t\t\tt.Errorf(\"Lstat errored when performing sanity check: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"file rename\", func(t *testing.T) {\n+\t\t// Create a directory to rename to something else.\n+\t\tif f, err := fs.Create(\"test_file\"); err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t} else {\n+\t\t\t_ = f.Close()\n+\t\t}\n+\n+\t\t// Try to rename \"test_file\" to \"file\".\n+\t\tif err := fs.Rename(\"test_file\", \"file\"); err != nil {\n+\t\t\tt.Errorf(\"expected no error, but got: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Sanity check\n+\t\tif _, err := os.Lstat(filepath.Join(fs.Root, \"file\")); err != nil {\n+\t\t\tt.Errorf(\"Lstat errored when performing sanity check: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+}\n+\n+func TestUnixFS_Touch(t *testing.T) {\n+\tt.Parallel()\n+\tfs, err := newTestUnixFS()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t\treturn\n+\t}\n+\tdefer fs.Cleanup()\n+\n+\tt.Run(\"base directory\", func(t *testing.T) {\n+\t\tpath := \"i_touched_a_file\"\n+\t\tf, err := fs.Touch(path, ufs.O_RDWR, 0o644)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\t_ = f.Close()\n+\n+\t\t// Sanity check\n+\t\tif _, err := os.Lstat(filepath.Join(fs.Root, path)); err != nil {\n+\t\t\tt.Errorf(\"Lstat errored when performing sanity check: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"existing parent directory\", func(t *testing.T) {\n+\t\tdir := \"some_parent_directory\"\n+\t\tif err := fs.Mkdir(dir, 0o755); err != nil {\n+\t\t\tt.Errorf(\"error creating parent directory: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tpath := filepath.Join(dir, \"i_touched_a_file\")\n+\t\tf, err := fs.Touch(path, ufs.O_RDWR, 0o644)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error touching file: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\t_ = f.Close()\n+\n+\t\t// Sanity check\n+\t\tif _, err := os.Lstat(filepath.Join(fs.Root, path)); err != nil {\n+\t\t\tt.Errorf(\"Lstat errored when performing sanity check: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"non-existent parent directory\", func(t *testing.T) {\n+\t\tpath := \"some_other_directory/i_touched_a_file\"\n+\t\tf, err := fs.Touch(path, ufs.O_RDWR, 0o644)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error touching file: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\t_ = f.Close()\n+\n+\t\t// Sanity check\n+\t\tif _, err := os.Lstat(filepath.Join(fs.Root, path)); err != nil {\n+\t\t\tt.Errorf(\"Lstat errored when performing sanity check: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\n+\tt.Run(\"non-existent parent directories\", func(t *testing.T) {\n+\t\tpath := \"some_other_directory/some_directory/i_touched_a_file\"\n+\t\tf, err := fs.Touch(path, ufs.O_RDWR, 0o644)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error touching file: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\t_ = f.Close()\n+\n+\t\t// Sanity check\n+\t\tif _, err := os.Lstat(filepath.Join(fs.Root, path)); err != nil {\n+\t\t\tt.Errorf(\"Lstat errored when performing sanity check: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t})\n+}"
        },
        {
          "filename": "internal/ufs/go.LICENSE",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+Copyright (c) 2009 The Go Authors. All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+   * Redistributions of source code must retain the above copyright\n+notice, this list of conditions and the following disclaimer.\n+   * Redistributions in binary form must reproduce the above\n+copyright notice, this list of conditions and the following disclaimer\n+in the documentation and/or other materials provided with the\n+distribution.\n+   * Neither the name of Google Inc. nor the names of its\n+contributors may be used to endorse or promote products derived from\n+this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "filename": "internal/ufs/mkdir_unix.go",
          "status": "added",
          "additions": 67,
          "deletions": 0,
          "patch": "@@ -0,0 +1,67 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+// Code in this file was derived from `go/src/os/path.go`.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the `go.LICENSE` file.\n+\n+//go:build unix\n+\n+package ufs\n+\n+import (\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+// mkdirAll is a recursive Mkdir implementation that properly handles symlinks.\n+func (fs *UnixFS) mkdirAll(name string, mode FileMode) error {\n+\t// Fast path: if we can tell whether path is a directory or file, stop with success or error.\n+\tdir, err := fs.Lstat(name)\n+\tif err == nil {\n+\t\tif dir.Mode()&ModeSymlink != 0 {\n+\t\t\t// If the final path is a symlink, resolve its target and use that\n+\t\t\t// to check instead.\n+\t\t\tdir, err = fs.Stat(name)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\tif dir.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn convertErrorType(&PathError{Op: \"mkdir\", Path: name, Err: unix.ENOTDIR})\n+\t}\n+\n+\t// Slow path: make sure parent exists and then call Mkdir for path.\n+\ti := len(name)\n+\tfor i > 0 && name[i-1] == '/' { // Skip trailing path separator.\n+\t\ti--\n+\t}\n+\n+\tj := i\n+\tfor j > 0 && name[j-1] != '/' { // Scan backward over element.\n+\t\tj--\n+\t}\n+\n+\tif j > 1 {\n+\t\t// Create parent.\n+\t\terr = fs.mkdirAll(name[:j-1], mode)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// Parent now exists; invoke Mkdir and use its result.\n+\terr = fs.Mkdir(name, mode)\n+\tif err != nil {\n+\t\t// Handle arguments like \"foo/.\" by\n+\t\t// double-checking that directory doesn't exist.\n+\t\tdir, err1 := fs.Lstat(name)\n+\t\tif err1 == nil && dir.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn err\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "internal/ufs/path_unix.go",
          "status": "added",
          "additions": 80,
          "deletions": 0,
          "patch": "@@ -0,0 +1,80 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+// Code in this file was copied from `go/src/os/path.go`\n+// and `go/src/os/path_unix.go`.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the `go.LICENSE` file.\n+\n+//go:build unix\n+\n+package ufs\n+\n+import (\n+\t\"os\"\n+)\n+\n+// basename removes trailing slashes and the leading directory name from path name.\n+func basename(name string) string {\n+\ti := len(name) - 1\n+\t// Remove trailing slashes\n+\tfor ; i > 0 && name[i] == '/'; i-- {\n+\t\tname = name[:i]\n+\t}\n+\t// Remove leading directory name\n+\tfor i--; i >= 0; i-- {\n+\t\tif name[i] == '/' {\n+\t\t\tname = name[i+1:]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn name\n+}\n+\n+// endsWithDot reports whether the final component of path is \".\".\n+func endsWithDot(path string) bool {\n+\tif path == \".\" {\n+\t\treturn true\n+\t}\n+\tif len(path) >= 2 && path[len(path)-1] == '.' && os.IsPathSeparator(path[len(path)-2]) {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// splitPath returns the base name and parent directory.\n+func splitPath(path string) (string, string) {\n+\t// if no better parent is found, the path is relative from \"here\"\n+\tdirname := \".\"\n+\n+\t// Remove all but one leading slash.\n+\tfor len(path) > 1 && path[0] == '/' && path[1] == '/' {\n+\t\tpath = path[1:]\n+\t}\n+\n+\ti := len(path) - 1\n+\n+\t// Remove trailing slashes.\n+\tfor ; i > 0 && path[i] == '/'; i-- {\n+\t\tpath = path[:i]\n+\t}\n+\n+\t// if no slashes in path, base is path\n+\tbasename := path\n+\n+\t// Remove leading directory path\n+\tfor i--; i >= 0; i-- {\n+\t\tif path[i] == '/' {\n+\t\t\tif i == 0 {\n+\t\t\t\tdirname = path[:1]\n+\t\t\t} else {\n+\t\t\t\tdirname = path[:i]\n+\t\t\t}\n+\t\t\tbasename = path[i+1:]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn dirname, basename\n+}"
        },
        {
          "filename": "internal/ufs/quota_writer.go",
          "status": "added",
          "additions": 117,
          "deletions": 0,
          "patch": "@@ -0,0 +1,117 @@\n+// SPDX-License-Identifier: MIT\n+// SPDX-FileCopyrightText: Copyright (c) 2024 Matthew Penner\n+\n+package ufs\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"sync/atomic\"\n+)\n+\n+// CountedWriter is a writer that counts the amount of data written to the\n+// underlying writer.\n+type CountedWriter struct {\n+\tFile\n+\n+\tcounter atomic.Int64\n+\terr     error\n+}\n+\n+// NewCountedWriter returns a new countedWriter that counts the amount of bytes\n+// written to the underlying writer.\n+func NewCountedWriter(f File) *CountedWriter {\n+\treturn &CountedWriter{File: f}\n+}\n+\n+// BytesWritten returns the amount of bytes that have been written to the\n+// underlying writer.\n+func (w *CountedWriter) BytesWritten() int64 {\n+\treturn w.counter.Load()\n+}\n+\n+// Error returns the error from the writer if any. If the error is an EOF, nil\n+// will be returned.\n+func (w *CountedWriter) Error() error {\n+\tif errors.Is(w.err, io.EOF) {\n+\t\treturn nil\n+\t}\n+\treturn w.err\n+}\n+\n+// Write writes bytes to the underlying writer while tracking the total amount\n+// of bytes written.\n+func (w *CountedWriter) Write(p []byte) (int, error) {\n+\tif w.err != nil {\n+\t\treturn 0, io.EOF\n+\t}\n+\n+\t// Write is a very simple operation for us to handle.\n+\tn, err := w.File.Write(p)\n+\tw.counter.Add(int64(n))\n+\tw.err = err\n+\n+\t// TODO: is this how we actually want to handle errors with this?\n+\tif err == io.EOF {\n+\t\treturn n, io.EOF\n+\t} else {\n+\t\treturn n, nil\n+\t}\n+}\n+\n+func (w *CountedWriter) ReadFrom(r io.Reader) (n int64, err error) {\n+\tcr := NewCountedReader(r)\n+\tn, err = w.File.ReadFrom(cr)\n+\tw.counter.Add(n)\n+\treturn\n+}\n+\n+// CountedReader is a reader that counts the amount of data read from the\n+// underlying reader.\n+type CountedReader struct {\n+\treader io.Reader\n+\n+\tcounter atomic.Int64\n+\terr     error\n+}\n+\n+var _ io.Reader = (*CountedReader)(nil)\n+\n+// NewCountedReader returns a new countedReader that counts the amount of bytes\n+// read from the underlying reader.\n+func NewCountedReader(r io.Reader) *CountedReader {\n+\treturn &CountedReader{reader: r}\n+}\n+\n+// BytesRead returns the amount of bytes that have been read from the underlying\n+// reader.\n+func (r *CountedReader) BytesRead() int64 {\n+\treturn r.counter.Load()\n+}\n+\n+// Error returns the error from the reader if any. If the error is an EOF, nil\n+// will be returned.\n+func (r *CountedReader) Error() error {\n+\tif errors.Is(r.err, io.EOF) {\n+\t\treturn nil\n+\t}\n+\treturn r.err\n+}\n+\n+// Read reads bytes from the underlying reader while tracking the total amount\n+// of bytes read.\n+func (r *CountedReader) Read(p []byte) (int, error) {\n+\tif r.err != nil {\n+\t\treturn 0, io.EOF\n+\t}\n+\n+\tn, err := r.reader.Read(p)\n+\tr.counter.Add(int64(n))\n+\tr.err = err\n+\n+\tif err == io.EOF {\n+\t\treturn n, io.EOF\n+\t} else {\n+\t\treturn n, nil\n+\t}\n+}"
        },
        {
          "filename": "internal/ufs/removeall_unix.go",
          "status": "added",
          "additions": 207,
          "deletions": 0,
          "patch": "@@ -0,0 +1,207 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+// Code in this file was derived from `go/src/os/removeall_at.go`.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the `go.LICENSE` file.\n+\n+//go:build unix\n+\n+package ufs\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"os\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+type unixFS interface {\n+\tOpen(name string) (File, error)\n+\tRemove(name string) error\n+\tunlinkat(dirfd int, path string, flags int) error\n+}\n+\n+func (fs *UnixFS) removeAll(path string) error {\n+\treturn removeAll(fs, path)\n+}\n+\n+func removeAll(fs unixFS, path string) error {\n+\tif path == \"\" {\n+\t\t// fail silently to retain compatibility with previous behavior\n+\t\t// of RemoveAll. See issue https://go.dev/issue/28830.\n+\t\treturn nil\n+\t}\n+\n+\t// The rmdir system call does not permit removing \".\",\n+\t// so we don't permit it either.\n+\tif endsWithDot(path) {\n+\t\treturn &PathError{Op: \"removeall\", Path: path, Err: unix.EINVAL}\n+\t}\n+\n+\t// Simple case: if Remove works, we're done.\n+\terr := fs.Remove(path)\n+\tif err == nil || errors.Is(err, ErrNotExist) {\n+\t\treturn nil\n+\t}\n+\n+\t// RemoveAll recurses by deleting the path base from\n+\t// its parent directory\n+\tparentDir, base := splitPath(path)\n+\n+\tparent, err := fs.Open(parentDir)\n+\tif errors.Is(err, ErrNotExist) {\n+\t\t// If parent does not exist, base cannot exist. Fail silently\n+\t\treturn nil\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer parent.Close()\n+\n+\tif err := removeAllFrom(fs, parent, base); err != nil {\n+\t\tif pathErr, ok := err.(*PathError); ok {\n+\t\t\tpathErr.Path = parentDir + string(os.PathSeparator) + pathErr.Path\n+\t\t\terr = pathErr\n+\t\t}\n+\t\treturn convertErrorType(err)\n+\t}\n+\treturn nil\n+}\n+\n+func removeAllFrom(fs unixFS, parent File, base string) error {\n+\tparentFd := int(parent.Fd())\n+\t// Simple case: if Unlink (aka remove) works, we're done.\n+\terr := fs.unlinkat(parentFd, base, 0)\n+\tif err == nil || errors.Is(err, ErrNotExist) {\n+\t\treturn nil\n+\t}\n+\n+\t// EISDIR means that we have a directory, and we need to\n+\t// remove its contents.\n+\t// EPERM or EACCES means that we don't have write permission on\n+\t// the parent directory, but this entry might still be a directory\n+\t// whose contents need to be removed.\n+\t// Otherwise, just return the error.\n+\tif err != unix.EISDIR && err != unix.EPERM && err != unix.EACCES {\n+\t\treturn &PathError{Op: \"unlinkat\", Path: base, Err: err}\n+\t}\n+\n+\t// Is this a directory we need to recurse into?\n+\tvar statInfo unix.Stat_t\n+\tstatErr := ignoringEINTR(func() error {\n+\t\treturn unix.Fstatat(parentFd, base, &statInfo, AT_SYMLINK_NOFOLLOW)\n+\t})\n+\tif statErr != nil {\n+\t\tif errors.Is(statErr, ErrNotExist) {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn &PathError{Op: \"fstatat\", Path: base, Err: statErr}\n+\t}\n+\tif statInfo.Mode&unix.S_IFMT != unix.S_IFDIR {\n+\t\t// Not a directory; return the error from the unix.Unlinkat.\n+\t\treturn &PathError{Op: \"unlinkat\", Path: base, Err: err}\n+\t}\n+\n+\t// Remove the directory's entries.\n+\tvar recurseErr error\n+\tfor {\n+\t\tconst reqSize = 1024\n+\t\tvar respSize int\n+\n+\t\t// Open the directory to recurse into\n+\t\tfile, err := openFdAt(parentFd, base)\n+\t\tif err != nil {\n+\t\t\tif errors.Is(err, ErrNotExist) {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\trecurseErr = &PathError{Op: \"openfdat\", Path: base, Err: err}\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tfor {\n+\t\t\tnumErr := 0\n+\n+\t\t\tnames, readErr := file.Readdirnames(reqSize)\n+\t\t\t// Errors other than EOF should stop us from continuing.\n+\t\t\tif readErr != nil && readErr != io.EOF {\n+\t\t\t\t_ = file.Close()\n+\t\t\t\tif errors.Is(readErr, ErrNotExist) {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\treturn &PathError{Op: \"readdirnames\", Path: base, Err: readErr}\n+\t\t\t}\n+\n+\t\t\trespSize = len(names)\n+\t\t\tfor _, name := range names {\n+\t\t\t\terr := removeAllFrom(fs, file, name)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif pathErr, ok := err.(*PathError); ok {\n+\t\t\t\t\t\tpathErr.Path = base + string(os.PathSeparator) + pathErr.Path\n+\t\t\t\t\t}\n+\t\t\t\t\tnumErr++\n+\t\t\t\t\tif recurseErr == nil {\n+\t\t\t\t\t\trecurseErr = err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// If we can delete any entry, break to start new iteration.\n+\t\t\t// Otherwise, we discard current names, get next entries and try deleting them.\n+\t\t\tif numErr != reqSize {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Removing files from the directory may have caused\n+\t\t// the OS to reshuffle it. Simply calling Readdirnames\n+\t\t// again may skip some entries. The only reliable way\n+\t\t// to avoid this is to close and re-open the\n+\t\t// directory. See issue https://go.dev/issue/20841.\n+\t\t_ = file.Close()\n+\n+\t\t// Finish when the end of the directory is reached\n+\t\tif respSize < reqSize {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// Remove the directory itself.\n+\tunlinkErr := fs.unlinkat(parentFd, base, AT_REMOVEDIR)\n+\tif unlinkErr == nil || errors.Is(unlinkErr, ErrNotExist) {\n+\t\treturn nil\n+\t}\n+\n+\tif recurseErr != nil {\n+\t\treturn recurseErr\n+\t}\n+\treturn &PathError{Op: \"unlinkat\", Path: base, Err: unlinkErr}\n+}\n+\n+// openFdAt opens path relative to the directory in fd.\n+// Other than that this should act like openFileNolog.\n+// This acts like openFileNolog rather than OpenFile because\n+// we are going to (try to) remove the file.\n+// The contents of this file are not relevant for test caching.\n+func openFdAt(dirfd int, name string) (File, error) {\n+\tvar fd int\n+\tfor {\n+\t\tvar err error\n+\t\tfd, err = unix.Openat(dirfd, name, O_RDONLY|O_CLOEXEC|O_NOFOLLOW, 0)\n+\t\tif err == nil {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\t// See comment in openFileNolog.\n+\t\tif err == unix.EINTR {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treturn nil, err\n+\t}\n+\t// This is stupid, os.NewFile immediately casts `fd` to an `int`, but wants\n+\t// it to be passed as a `uintptr`.\n+\treturn os.NewFile(uintptr(fd), name), nil\n+}"
        },
        {
          "filename": "internal/ufs/stat_unix.go",
          "status": "added",
          "additions": 67,
          "deletions": 0,
          "patch": "@@ -0,0 +1,67 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+// Code in this file was copied from `go/src/os/stat_linux.go`\n+// and `go/src/os/types_unix.go`.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the `go.LICENSE` file.\n+\n+//go:build unix\n+\n+package ufs\n+\n+import (\n+\t\"time\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+type fileStat struct {\n+\tname    string\n+\tsize    int64\n+\tmode    FileMode\n+\tmodTime time.Time\n+\tsys     unix.Stat_t\n+}\n+\n+var _ FileInfo = (*fileStat)(nil)\n+\n+func (fs *fileStat) Size() int64        { return fs.size }\n+func (fs *fileStat) Mode() FileMode     { return fs.mode }\n+func (fs *fileStat) ModTime() time.Time { return fs.modTime }\n+func (fs *fileStat) Sys() any           { return &fs.sys }\n+func (fs *fileStat) Name() string       { return fs.name }\n+func (fs *fileStat) IsDir() bool        { return fs.Mode().IsDir() }\n+\n+func fillFileStatFromSys(fs *fileStat, name string) {\n+\tfs.name = basename(name)\n+\tfs.size = fs.sys.Size\n+\tfs.modTime = time.Unix(fs.sys.Mtim.Unix())\n+\tfs.mode = FileMode(fs.sys.Mode & 0o777)\n+\tswitch fs.sys.Mode & unix.S_IFMT {\n+\tcase unix.S_IFBLK:\n+\t\tfs.mode |= ModeDevice\n+\tcase unix.S_IFCHR:\n+\t\tfs.mode |= ModeDevice | ModeCharDevice\n+\tcase unix.S_IFDIR:\n+\t\tfs.mode |= ModeDir\n+\tcase unix.S_IFIFO:\n+\t\tfs.mode |= ModeNamedPipe\n+\tcase unix.S_IFLNK:\n+\t\tfs.mode |= ModeSymlink\n+\tcase unix.S_IFREG:\n+\t\t// nothing to do\n+\tcase unix.S_IFSOCK:\n+\t\tfs.mode |= ModeSocket\n+\t}\n+\tif fs.sys.Mode&unix.S_ISGID != 0 {\n+\t\tfs.mode |= ModeSetgid\n+\t}\n+\tif fs.sys.Mode&unix.S_ISUID != 0 {\n+\t\tfs.mode |= ModeSetuid\n+\t}\n+\tif fs.sys.Mode&unix.S_ISVTX != 0 {\n+\t\tfs.mode |= ModeSticky\n+\t}\n+}"
        },
        {
          "filename": "internal/ufs/walk.go",
          "status": "added",
          "additions": 123,
          "deletions": 0,
          "patch": "@@ -0,0 +1,123 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+\n+// Code in this file was derived from `go/src/io/fs/walk.go`.\n+\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the `go.LICENSE` file.\n+\n+package ufs\n+\n+import (\n+\tiofs \"io/fs\"\n+\t\"path\"\n+)\n+\n+// SkipDir is used as a return value from [WalkDirFunc] to indicate that\n+// the directory named in the call is to be skipped. It is not returned\n+// as an error by any function.\n+var SkipDir = iofs.SkipDir\n+\n+// SkipAll is used as a return value from [WalkDirFunc] to indicate that\n+// all remaining files and directories are to be skipped. It is not returned\n+// as an error by any function.\n+var SkipAll = iofs.SkipAll\n+\n+// WalkDirFunc is the type of the function called by [WalkDir] to visit\n+// each file or directory.\n+//\n+// The path argument contains the argument to [WalkDir] as a prefix.\n+// That is, if WalkDir is called with root argument \"dir\" and finds a file\n+// named \"a\" in that directory, the walk function will be called with\n+// argument \"dir/a\".\n+//\n+// The d argument is the [DirEntry] for the named path.\n+//\n+// The error result returned by the function controls how [WalkDir]\n+// continues. If the function returns the special value [SkipDir], WalkDir\n+// skips the current directory (path if d.IsDir() is true, otherwise\n+// path's parent directory). If the function returns the special value\n+// [SkipAll], WalkDir skips all remaining files and directories. Otherwise,\n+// if the function returns a non-nil error, WalkDir stops entirely and\n+// returns that error.\n+//\n+// The err argument reports an error related to path, signaling that\n+// [WalkDir] will not walk into that directory. The function can decide how\n+// to handle that error; as described earlier, returning the error will\n+// cause WalkDir to stop walking the entire tree.\n+//\n+// [WalkDir] calls the function with a non-nil err argument in two cases.\n+//\n+// First, if the initial [Stat] on the root directory fails, WalkDir\n+// calls the function with path set to root, d set to nil, and err set to\n+// the error from [fs.Stat].\n+//\n+// Second, if a directory's ReadDir method (see [ReadDirFile]) fails, WalkDir calls the\n+// function with path set to the directory's path, d set to an\n+// [DirEntry] describing the directory, and err set to the error from\n+// ReadDir. In this second case, the function is called twice with the\n+// path of the directory: the first call is before the directory read is\n+// attempted and has err set to nil, giving the function a chance to\n+// return [SkipDir] or [SkipAll] and avoid the ReadDir entirely. The second call\n+// is after a failed ReadDir and reports the error from ReadDir.\n+// (If ReadDir succeeds, there is no second call.)\n+type WalkDirFunc func(path string, d DirEntry, err error) error\n+\n+// WalkDir walks the file tree rooted at root, calling fn for each file or\n+// directory in the tree, including root.\n+//\n+// All errors that arise visiting files and directories are filtered by fn:\n+// see the [WalkDirFunc] documentation for details.\n+//\n+// The files are walked in lexical order, which makes the output deterministic\n+// but requires WalkDir to read an entire directory into memory before proceeding\n+// to walk that directory.\n+//\n+// WalkDir does not follow symbolic links found in directories,\n+// but if root itself is a symbolic link, its target will be walked.\n+func WalkDir(fs Filesystem, root string, fn WalkDirFunc) error {\n+\tinfo, err := fs.Stat(root)\n+\tif err != nil {\n+\t\terr = fn(root, nil, err)\n+\t} else {\n+\t\terr = walkDir(fs, root, iofs.FileInfoToDirEntry(info), fn)\n+\t}\n+\tif err == SkipDir || err == SkipAll {\n+\t\treturn nil\n+\t}\n+\treturn err\n+}\n+\n+// walkDir recursively descends path, calling walkDirFn.\n+func walkDir(fs Filesystem, name string, d DirEntry, walkDirFn WalkDirFunc) error {\n+\tif err := walkDirFn(name, d, nil); err != nil || !d.IsDir() {\n+\t\tif err == SkipDir && d.IsDir() {\n+\t\t\t// Successfully skipped directory.\n+\t\t\terr = nil\n+\t\t}\n+\t\treturn err\n+\t}\n+\n+\tdirs, err := fs.ReadDir(name)\n+\tif err != nil {\n+\t\t// Second call, to report ReadDir error.\n+\t\terr = walkDirFn(name, d, err)\n+\t\tif err != nil {\n+\t\t\tif err == SkipDir && d.IsDir() {\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tfor _, d1 := range dirs {\n+\t\tname1 := path.Join(name, d1.Name())\n+\t\tif err := walkDir(fs, name1, d1, walkDirFn); err != nil {\n+\t\t\tif err == SkipDir {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "internal/ufs/walk_unix.go",
          "status": "added",
          "additions": 291,
          "deletions": 0,
          "patch": "@@ -0,0 +1,291 @@\n+// SPDX-License-Identifier: BSD-2-Clause\n+\n+// Some code in this file was derived from https://github.com/karrick/godirwalk.\n+\n+//go:build unix\n+\n+package ufs\n+\n+import (\n+\t\"bytes\"\n+\tiofs \"io/fs\"\n+\t\"os\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"unsafe\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+type WalkDiratFunc func(dirfd int, name, relative string, d DirEntry, err error) error\n+\n+func (fs *UnixFS) WalkDirat(dirfd int, name string, fn WalkDiratFunc) error {\n+\tif dirfd == 0 {\n+\t\t// TODO: proper validation, ideally a dedicated function.\n+\t\tdirfd = int(fs.dirfd.Load())\n+\t}\n+\tinfo, err := fs.Lstatat(dirfd, name)\n+\tif err != nil {\n+\t\terr = fn(dirfd, name, name, nil, err)\n+\t} else {\n+\t\tb := newScratchBuffer()\n+\t\terr = fs.walkDir(b, dirfd, name, name, iofs.FileInfoToDirEntry(info), fn)\n+\t}\n+\tif err == SkipDir || err == SkipAll {\n+\t\treturn nil\n+\t}\n+\treturn err\n+}\n+\n+func (fs *UnixFS) walkDir(b []byte, parentfd int, name, relative string, d DirEntry, walkDirFn WalkDiratFunc) error {\n+\tif err := walkDirFn(parentfd, name, relative, d, nil); err != nil || !d.IsDir() {\n+\t\tif err == SkipDir && d.IsDir() {\n+\t\t\t// Successfully skipped directory.\n+\t\t\terr = nil\n+\t\t}\n+\t\treturn err\n+\t}\n+\n+\tdirfd, err := fs.openat(parentfd, name, O_DIRECTORY|O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer unix.Close(dirfd)\n+\n+\tdirs, err := fs.readDir(dirfd, name, b)\n+\tif err != nil {\n+\t\t// Second call, to report ReadDir error.\n+\t\terr = walkDirFn(dirfd, name, relative, d, err)\n+\t\tif err != nil {\n+\t\t\tif err == SkipDir && d.IsDir() {\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tfor _, d1 := range dirs {\n+\t\tif err := fs.walkDir(b, dirfd, d1.Name(), path.Join(relative, d1.Name()), d1, walkDirFn); err != nil {\n+\t\t\tif err == SkipDir {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// ReadDirMap .\n+// TODO: document\n+func ReadDirMap[T any](fs *UnixFS, path string, fn func(DirEntry) (T, error)) ([]T, error) {\n+\tdirfd, name, closeFd, err := fs.safePath(path)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfd, err := fs.openat(dirfd, name, O_DIRECTORY|O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer unix.Close(fd)\n+\n+\tentries, err := fs.readDir(fd, \".\", nil)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tout := make([]T, len(entries))\n+\tfor i, e := range entries {\n+\t\tidx := i\n+\t\te := e\n+\t\tv, err := fn(e)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tout[idx] = v\n+\t}\n+\treturn out, nil\n+}\n+\n+// nameOffset is a compile time constant\n+const nameOffset = int(unsafe.Offsetof(unix.Dirent{}.Name))\n+\n+func nameFromDirent(de *unix.Dirent) (name []byte) {\n+\t// Because this GOOS' syscall.Dirent does not provide a field that specifies\n+\t// the name length, this function must first calculate the max possible name\n+\t// length, and then search for the NULL byte.\n+\tml := int(de.Reclen) - nameOffset\n+\n+\t// Convert syscall.Dirent.Name, which is array of int8, to []byte, by\n+\t// overwriting Cap, Len, and Data slice header fields to the max possible\n+\t// name length computed above, and finding the terminating NULL byte.\n+\t//\n+\t// TODO: is there an alternative to the deprecated SliceHeader?\n+\t// SliceHeader was mainly deprecated due to it being misused for avoiding\n+\t// allocations when converting a byte slice to a string, ref;\n+\t// https://go.dev/issue/53003\n+\tsh := (*reflect.SliceHeader)(unsafe.Pointer(&name))\n+\tsh.Cap = ml\n+\tsh.Len = ml\n+\tsh.Data = uintptr(unsafe.Pointer(&de.Name[0]))\n+\n+\tif index := bytes.IndexByte(name, 0); index >= 0 {\n+\t\t// Found NULL byte; set slice's cap and len accordingly.\n+\t\tsh.Cap = index\n+\t\tsh.Len = index\n+\t\treturn\n+\t}\n+\n+\t// NOTE: This branch is not expected, but included for defensive\n+\t// programming, and provides a hard stop on the name based on the structure\n+\t// field array size.\n+\tsh.Cap = len(de.Name)\n+\tsh.Len = sh.Cap\n+\treturn\n+}\n+\n+// modeTypeFromDirent converts a syscall defined constant, which is in purview\n+// of OS, to a constant defined by Go, assumed by this project to be stable.\n+//\n+// When the syscall constant is not recognized, this function falls back to a\n+// Stat on the file system.\n+func (fs *UnixFS) modeTypeFromDirent(fd int, de *unix.Dirent, osDirname, osBasename string) (FileMode, error) {\n+\tswitch de.Type {\n+\tcase unix.DT_REG:\n+\t\treturn 0, nil\n+\tcase unix.DT_DIR:\n+\t\treturn ModeDir, nil\n+\tcase unix.DT_LNK:\n+\t\treturn ModeSymlink, nil\n+\tcase unix.DT_CHR:\n+\t\treturn ModeDevice | ModeCharDevice, nil\n+\tcase unix.DT_BLK:\n+\t\treturn ModeDevice, nil\n+\tcase unix.DT_FIFO:\n+\t\treturn ModeNamedPipe, nil\n+\tcase unix.DT_SOCK:\n+\t\treturn ModeSocket, nil\n+\tdefault:\n+\t\t// If syscall returned unknown type (e.g., DT_UNKNOWN, DT_WHT), then\n+\t\t// resolve actual mode by reading file information.\n+\t\treturn fs.modeType(fd, filepath.Join(osDirname, osBasename))\n+\t}\n+}\n+\n+// modeType returns the mode type of the file system entry identified by\n+// osPathname by calling os.LStat function, to intentionally not follow symbolic\n+// links.\n+//\n+// Even though os.LStat provides all file mode bits, we want to ensure same\n+// values returned to caller regardless of whether we obtained file mode bits\n+// from syscall or stat call. Therefore, mask out the additional file mode bits\n+// that are provided by stat but not by the syscall, so users can rely on their\n+// values.\n+func (fs *UnixFS) modeType(dirfd int, name string) (os.FileMode, error) {\n+\tfi, err := fs.Lstatat(dirfd, name)\n+\tif err == nil {\n+\t\treturn fi.Mode() & ModeType, nil\n+\t}\n+\treturn 0, err\n+}\n+\n+var minimumScratchBufferSize = os.Getpagesize()\n+\n+func newScratchBuffer() []byte {\n+\treturn make([]byte, minimumScratchBufferSize)\n+}\n+\n+func (fs *UnixFS) readDir(fd int, name string, b []byte) ([]DirEntry, error) {\n+\tscratchBuffer := b\n+\tif scratchBuffer == nil || len(scratchBuffer) < minimumScratchBufferSize {\n+\t\tscratchBuffer = newScratchBuffer()\n+\t}\n+\n+\tvar entries []DirEntry\n+\tvar workBuffer []byte\n+\n+\tvar sde unix.Dirent\n+\tfor {\n+\t\tif len(workBuffer) == 0 {\n+\t\t\tn, err := unix.Getdents(fd, scratchBuffer)\n+\t\t\tif err != nil {\n+\t\t\t\tif err == unix.EINTR {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\treturn nil, convertErrorType(err)\n+\t\t\t}\n+\t\t\tif n <= 0 {\n+\t\t\t\t// end of directory: normal exit\n+\t\t\t\treturn entries, nil\n+\t\t\t}\n+\t\t\tworkBuffer = scratchBuffer[:n] // trim work buffer to number of bytes read\n+\t\t}\n+\n+\t\t// \"Go is like C, except that you just put `unsafe` all over the place\".\n+\t\tcopy((*[unsafe.Sizeof(unix.Dirent{})]byte)(unsafe.Pointer(&sde))[:], workBuffer)\n+\t\tworkBuffer = workBuffer[sde.Reclen:] // advance buffer for next iteration through loop\n+\n+\t\tif sde.Ino == 0 {\n+\t\t\tcontinue // inode set to 0 indicates an entry that was marked as deleted\n+\t\t}\n+\n+\t\tnameSlice := nameFromDirent(&sde)\n+\t\tnameLength := len(nameSlice)\n+\n+\t\tif nameLength == 0 || (nameSlice[0] == '.' && (nameLength == 1 || (nameLength == 2 && nameSlice[1] == '.'))) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchildName := string(nameSlice)\n+\t\tmt, err := fs.modeTypeFromDirent(fd, &sde, name, childName)\n+\t\tif err != nil {\n+\t\t\treturn nil, convertErrorType(err)\n+\t\t}\n+\t\tentries = append(entries, &dirent{name: childName, path: name, modeType: mt, dirfd: fd, fs: fs})\n+\t}\n+}\n+\n+// dirent stores the name and file system mode type of discovered file system\n+// entries.\n+type dirent struct {\n+\tname     string\n+\tpath     string\n+\tmodeType FileMode\n+\n+\tdirfd int\n+\tfs    *UnixFS\n+}\n+\n+func (de dirent) Name() string {\n+\treturn de.name\n+}\n+\n+func (de dirent) IsDir() bool {\n+\treturn de.modeType&ModeDir != 0\n+}\n+\n+func (de dirent) Type() FileMode {\n+\treturn de.modeType\n+}\n+\n+func (de dirent) Info() (FileInfo, error) {\n+\tif de.fs == nil {\n+\t\treturn nil, nil\n+\t}\n+\treturn de.fs.Lstatat(de.dirfd, de.name)\n+}\n+\n+func (de dirent) Open() (File, error) {\n+\tif de.fs == nil {\n+\t\treturn nil, nil\n+\t}\n+\treturn de.fs.OpenFileat(de.dirfd, de.name, O_RDONLY, 0)\n+}\n+\n+// reset releases memory held by entry err and name, and resets mode type to 0.\n+func (de *dirent) reset() {\n+\tde.name = \"\"\n+\tde.path = \"\"\n+\tde.modeType = 0\n+}"
        },
        {
          "filename": "parser/helpers.go",
          "status": "modified",
          "additions": 3,
          "deletions": 15,
          "patch": "@@ -2,8 +2,6 @@ package parser\n \n import (\n \t\"bytes\"\n-\t\"io\"\n-\t\"os\"\n \t\"regexp\"\n \t\"strconv\"\n \t\"strings\"\n@@ -29,24 +27,14 @@ var configMatchRegex = regexp.MustCompile(`{{\\s?config\\.([\\w.-]+)\\s?}}`)\n // matching:\n //\n // <Root>\n-//   <Property value=\"testing\"/>\n+//\n+//\t<Property value=\"testing\"/>\n+//\n // </Root>\n //\n // noinspection RegExpRedundantEscape\n var xmlValueMatchRegex = regexp.MustCompile(`^\\[([\\w]+)='(.*)'\\]$`)\n \n-// Gets the []byte representation of a configuration file to be passed through to other\n-// handler functions. If the file does not currently exist, it will be created.\n-func readFileBytes(path string) ([]byte, error) {\n-\tfile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer file.Close()\n-\n-\treturn io.ReadAll(file)\n-}\n-\n // Gets the value of a key based on the value type defined.\n func (cfr *ConfigurationFileReplacement) getKeyValue(value string) interface{} {\n \tif cfr.ReplaceWith.Type() == jsonparser.Boolean {"
        },
        {
          "filename": "parser/parser.go",
          "status": "modified",
          "additions": 130,
          "deletions": 116,
          "patch": "@@ -2,8 +2,8 @@ package parser\n \n import (\n \t\"bufio\"\n-\t\"os\"\n-\t\"path/filepath\"\n+\t\"bytes\"\n+\t\"io\"\n \t\"strconv\"\n \t\"strings\"\n \n@@ -18,6 +18,7 @@ import (\n \t\"gopkg.in/yaml.v3\"\n \n \t\"github.com/pterodactyl/wings/config\"\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n // The file parsing options that are available for a server configuration file.\n@@ -74,6 +75,26 @@ func (cv *ReplaceValue) String() string {\n \t}\n }\n \n+func (cv *ReplaceValue) Bytes() []byte {\n+\tswitch cv.Type() {\n+\tcase jsonparser.String:\n+\t\tvar stackbuf [64]byte\n+\t\tbU, err := jsonparser.Unescape(cv.value, stackbuf[:])\n+\t\tif err != nil {\n+\t\t\tpanic(errors.Wrap(err, \"parser: could not parse value\"))\n+\t\t}\n+\t\treturn bU\n+\tcase jsonparser.Null:\n+\t\treturn []byte(\"<nil>\")\n+\tcase jsonparser.Boolean:\n+\t\treturn cv.value\n+\tcase jsonparser.Number:\n+\t\treturn cv.value\n+\tdefault:\n+\t\treturn []byte(\"<invalid>\")\n+\t}\n+}\n+\n type ConfigurationParser string\n \n func (cp ConfigurationParser) String() string {\n@@ -167,11 +188,12 @@ func (cfr *ConfigurationFileReplacement) UnmarshalJSON(data []byte) error {\n \treturn nil\n }\n \n-// Parses a given configuration file and updates all of the values within as defined\n-// in the API response from the Panel.\n-func (f *ConfigurationFile) Parse(path string, internal bool) error {\n-\tlog.WithField(\"path\", path).WithField(\"parser\", f.Parser.String()).Debug(\"parsing server configuration file\")\n+// Parse parses a given configuration file and updates all the values within\n+// as defined in the API response from the Panel.\n+func (f *ConfigurationFile) Parse(file ufs.File) error {\n+\t//log.WithField(\"path\", path).WithField(\"parser\", f.Parser.String()).Debug(\"parsing server configuration file\")\n \n+\t// What the fuck is going on here?\n \tif mb, err := json.Marshal(config.Get()); err != nil {\n \t\treturn err\n \t} else {\n@@ -182,56 +204,24 @@ func (f *ConfigurationFile) Parse(path string, internal bool) error {\n \n \tswitch f.Parser {\n \tcase Properties:\n-\t\terr = f.parsePropertiesFile(path)\n-\t\tbreak\n+\t\terr = f.parsePropertiesFile(file)\n \tcase File:\n-\t\terr = f.parseTextFile(path)\n-\t\tbreak\n+\t\terr = f.parseTextFile(file)\n \tcase Yaml, \"yml\":\n-\t\terr = f.parseYamlFile(path)\n-\t\tbreak\n+\t\terr = f.parseYamlFile(file)\n \tcase Json:\n-\t\terr = f.parseJsonFile(path)\n-\t\tbreak\n+\t\terr = f.parseJsonFile(file)\n \tcase Ini:\n-\t\terr = f.parseIniFile(path)\n-\t\tbreak\n+\t\terr = f.parseIniFile(file)\n \tcase Xml:\n-\t\terr = f.parseXmlFile(path)\n-\t\tbreak\n+\t\terr = f.parseXmlFile(file)\n \t}\n-\n-\tif errors.Is(err, os.ErrNotExist) {\n-\t\t// File doesn't exist, we tried creating it, and same error is returned? Pretty\n-\t\t// sure this pathway is impossible, but if not, abort here.\n-\t\tif internal {\n-\t\t\treturn nil\n-\t\t}\n-\n-\t\tb := strings.TrimSuffix(path, filepath.Base(path))\n-\t\tif err := os.MkdirAll(b, 0o755); err != nil {\n-\t\t\treturn errors.WithMessage(err, \"failed to create base directory for missing configuration file\")\n-\t\t} else {\n-\t\t\tif _, err := os.Create(path); err != nil {\n-\t\t\t\treturn errors.WithMessage(err, \"failed to create missing configuration file\")\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn f.Parse(path, true)\n-\t}\n-\n \treturn err\n }\n \n // Parses an xml file.\n-func (f *ConfigurationFile) parseXmlFile(path string) error {\n+func (f *ConfigurationFile) parseXmlFile(file ufs.File) error {\n \tdoc := etree.NewDocument()\n-\tfile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer file.Close()\n-\n \tif _, err := doc.ReadFrom(file); err != nil {\n \t\treturn err\n \t}\n@@ -291,41 +281,27 @@ func (f *ConfigurationFile) parseXmlFile(path string) error {\n \t\t}\n \t}\n \n-\t// If you don't truncate the file you'll end up duplicating the data in there (or just appending\n-\t// to the end of the file. We don't want to do that.\n+\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n+\t\treturn err\n+\t}\n \tif err := file.Truncate(0); err != nil {\n \t\treturn err\n \t}\n \n-\t// Move the cursor to the start of the file to avoid weird spacing issues.\n-\tfile.Seek(0, 0)\n-\n \t// Ensure the XML is indented properly.\n \tdoc.Indent(2)\n \n-\t// Truncate the file before attempting to write the changes.\n-\tif err := os.Truncate(path, 0); err != nil {\n+\t// Write the XML to the file.\n+\tif _, err := doc.WriteTo(file); err != nil {\n \t\treturn err\n \t}\n-\n-\t// Write the XML to the file.\n-\t_, err = doc.WriteTo(file)\n-\n-\treturn err\n+\treturn nil\n }\n \n // Parses an ini file.\n-func (f *ConfigurationFile) parseIniFile(path string) error {\n-\t// Ini package can't handle a non-existent file, so handle that automatically here\n-\t// by creating it if not exists. Then, immediately close the file since we will use\n-\t// other methods to write the new contents.\n-\tfile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tfile.Close()\n-\n-\tcfg, err := ini.Load(path)\n+func (f *ConfigurationFile) parseIniFile(file ufs.File) error {\n+\t// Wrap the file in a NopCloser so the ini package doesn't close the file.\n+\tcfg, err := ini.Load(io.NopCloser(file))\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -388,14 +364,24 @@ func (f *ConfigurationFile) parseIniFile(path string) error {\n \t\t}\n \t}\n \n-\treturn cfg.SaveTo(path)\n+\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := file.Truncate(0); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif _, err := cfg.WriteTo(file); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n }\n \n // Parses a json file updating any matching key/value pairs. If a match is not found, the\n // value is set regardless in the file. See the commentary in parseYamlFile for more details\n // about what is happening during this process.\n-func (f *ConfigurationFile) parseJsonFile(path string) error {\n-\tb, err := readFileBytes(path)\n+func (f *ConfigurationFile) parseJsonFile(file ufs.File) error {\n+\tb, err := io.ReadAll(file)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -405,14 +391,24 @@ func (f *ConfigurationFile) parseJsonFile(path string) error {\n \t\treturn err\n \t}\n \n-\toutput := []byte(data.StringIndent(\"\", \"    \"))\n-\treturn os.WriteFile(path, output, 0o644)\n+\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := file.Truncate(0); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Write the data to the file.\n+\tif _, err := io.Copy(file, bytes.NewReader(data.BytesIndent(\"\", \"    \"))); err != nil {\n+\t\treturn errors.Wrap(err, \"parser: failed to write properties file to disk\")\n+\t}\n+\treturn nil\n }\n \n // Parses a yaml file and updates any matching key/value pairs before persisting\n // it back to the disk.\n-func (f *ConfigurationFile) parseYamlFile(path string) error {\n-\tb, err := readFileBytes(path)\n+func (f *ConfigurationFile) parseYamlFile(file ufs.File) error {\n+\tb, err := io.ReadAll(file)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -443,35 +439,56 @@ func (f *ConfigurationFile) parseYamlFile(path string) error {\n \t\treturn err\n \t}\n \n-\treturn os.WriteFile(path, marshaled, 0o644)\n+\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := file.Truncate(0); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Write the data to the file.\n+\tif _, err := io.Copy(file, bytes.NewReader(marshaled)); err != nil {\n+\t\treturn errors.Wrap(err, \"parser: failed to write properties file to disk\")\n+\t}\n+\treturn nil\n }\n \n // Parses a text file using basic find and replace. This is a highly inefficient method of\n // scanning a file and performing a replacement. You should attempt to use anything other\n // than this function where possible.\n-func (f *ConfigurationFile) parseTextFile(path string) error {\n-\tinput, err := os.ReadFile(path)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tlines := strings.Split(string(input), \"\\n\")\n-\tfor i, line := range lines {\n+func (f *ConfigurationFile) parseTextFile(file ufs.File) error {\n+\tb := bytes.NewBuffer(nil)\n+\ts := bufio.NewScanner(file)\n+\tvar replaced bool\n+\tfor s.Scan() {\n+\t\tline := s.Bytes()\n+\t\treplaced = false\n \t\tfor _, replace := range f.Replace {\n \t\t\t// If this line doesn't match what we expect for the replacement, move on to the next\n \t\t\t// line. Otherwise, update the line to have the replacement value.\n-\t\t\tif !strings.HasPrefix(line, replace.Match) {\n+\t\t\tif !bytes.HasPrefix(line, []byte(replace.Match)) {\n \t\t\t\tcontinue\n \t\t\t}\n-\n-\t\t\tlines[i] = replace.ReplaceWith.String()\n+\t\t\tb.Write(replace.ReplaceWith.Bytes())\n+\t\t\treplaced = true\n \t\t}\n+\t\tif !replaced {\n+\t\t\tb.Write(line)\n+\t\t}\n+\t\tb.WriteByte('\\n')\n \t}\n \n-\tif err := os.WriteFile(path, []byte(strings.Join(lines, \"\\n\")), 0o644); err != nil {\n+\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := file.Truncate(0); err != nil {\n \t\treturn err\n \t}\n \n+\t// Write the data to the file.\n+\tif _, err := io.Copy(file, b); err != nil {\n+\t\treturn errors.Wrap(err, \"parser: failed to write properties file to disk\")\n+\t}\n \treturn nil\n }\n \n@@ -501,31 +518,29 @@ func (f *ConfigurationFile) parseTextFile(path string) error {\n //\n // @see https://github.com/pterodactyl/panel/issues/2308 (original)\n // @see https://github.com/pterodactyl/panel/issues/3009 (\"bug\" introduced as result)\n-func (f *ConfigurationFile) parsePropertiesFile(path string) error {\n-\tvar s strings.Builder\n-\t// Open the file and attempt to load any comments that currenty exist at the start\n-\t// of the file. This is kind of a hack, but should work for a majority of users for\n-\t// the time being.\n-\tif fd, err := os.Open(path); err != nil {\n-\t\treturn errors.Wrap(err, \"parser: could not open file for reading\")\n-\t} else {\n-\t\tscanner := bufio.NewScanner(fd)\n-\t\t// Scan until we hit a line that is not a comment that actually has content\n-\t\t// on it. Keep appending the comments until that time.\n-\t\tfor scanner.Scan() {\n-\t\t\ttext := scanner.Text()\n-\t\t\tif len(text) > 0 && text[0] != '#' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ts.WriteString(text + \"\\n\")\n-\t\t}\n-\t\t_ = fd.Close()\n-\t\tif err := scanner.Err(); err != nil {\n-\t\t\treturn errors.WithStackIf(err)\n+func (f *ConfigurationFile) parsePropertiesFile(file ufs.File) error {\n+\tb, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\ts := bytes.NewBuffer(nil)\n+\tscanner := bufio.NewScanner(bytes.NewReader(b))\n+\t// Scan until we hit a line that is not a comment that actually has content\n+\t// on it. Keep appending the comments until that time.\n+\tfor scanner.Scan() {\n+\t\ttext := scanner.Bytes()\n+\t\tif len(text) > 0 && text[0] != '#' {\n+\t\t\tbreak\n \t\t}\n+\t\ts.Write(text)\n+\t\ts.WriteByte('\\n')\n+\t}\n+\tif err := scanner.Err(); err != nil {\n+\t\treturn errors.WithStackIf(err)\n \t}\n \n-\tp, err := properties.LoadFile(path, properties.UTF8)\n+\tp, err := properties.Load(b, properties.UTF8)\n \tif err != nil {\n \t\treturn errors.Wrap(err, \"parser: could not load properties file for configuration update\")\n \t}\n@@ -563,17 +578,16 @@ func (f *ConfigurationFile) parsePropertiesFile(path string) error {\n \t\ts.WriteString(key + \"=\" + strings.Trim(strconv.QuoteToASCII(value), \"\\\"\") + \"\\n\")\n \t}\n \n-\t// Open the file for writing.\n-\tw, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)\n-\tif err != nil {\n+\tif _, err := file.Seek(0, io.SeekStart); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := file.Truncate(0); err != nil {\n \t\treturn err\n \t}\n-\tdefer w.Close()\n \n \t// Write the data to the file.\n-\tif _, err := w.Write([]byte(s.String())); err != nil {\n+\tif _, err := io.Copy(file, s); err != nil {\n \t\treturn errors.Wrap(err, \"parser: failed to write properties file to disk\")\n \t}\n-\n \treturn nil\n }"
        },
        {
          "filename": "router/downloader/downloader.go",
          "status": "modified",
          "additions": 5,
          "deletions": 8,
          "patch": "@@ -167,13 +167,8 @@ func (dl *Download) Execute() error {\n \t\treturn errors.New(\"downloader: got bad response status from endpoint: \" + res.Status)\n \t}\n \n-\t// If there is a Content-Length header on this request go ahead and check that we can\n-\t// even write the whole file before beginning this process. If there is no header present\n-\t// we'll just have to give it a spin and see how it goes.\n-\tif res.ContentLength > 0 {\n-\t\tif err := dl.server.Filesystem().HasSpaceFor(res.ContentLength); err != nil {\n-\t\t\treturn errors.WrapIf(err, \"downloader: failed to write file: not enough space\")\n-\t\t}\n+\tif res.ContentLength < 1 {\n+\t\treturn errors.New(\"downloader: request is missing ContentLength\")\n \t}\n \n \tif dl.req.UseHeader {\n@@ -200,8 +195,10 @@ func (dl *Download) Execute() error {\n \tp := dl.Path()\n \tdl.server.Log().WithField(\"path\", p).Debug(\"writing remote file to disk\")\n \n+\t// Write the file while tracking the progress, Write will check that the\n+\t// size of the file won't exceed the disk limit.\n \tr := io.TeeReader(res.Body, dl.counter(res.ContentLength))\n-\tif err := dl.server.Filesystem().Writefile(p, r); err != nil {\n+\tif err := dl.server.Filesystem().Write(p, r, res.ContentLength, 0o644); err != nil {\n \t\treturn errors.WrapIf(err, \"downloader: failed to write file to server directory\")\n \t}\n \treturn nil"
        },
        {
          "filename": "router/router_download.go",
          "status": "modified",
          "additions": 6,
          "deletions": 12,
          "patch": "@@ -45,6 +45,8 @@ func getDownloadBackup(c *gin.Context) {\n \t\treturn\n \t}\n \n+\t// The use of `os` here is safe as backups are not stored within server\n+\t// accessible directories.\n \tf, err := os.Open(b.Path())\n \tif err != nil {\n \t\tmiddleware.CaptureAndAbort(c, err)\n@@ -76,27 +78,19 @@ func getDownloadFile(c *gin.Context) {\n \t\treturn\n \t}\n \n-\tp, _ := s.Filesystem().SafePath(token.FilePath)\n-\tst, err := os.Stat(p)\n-\t// If there is an error or we're somehow trying to download a directory, just\n-\t// respond with the appropriate error.\n+\tf, st, err := s.Filesystem().File(token.FilePath)\n \tif err != nil {\n \t\tmiddleware.CaptureAndAbort(c, err)\n \t\treturn\n-\t} else if st.IsDir() {\n+\t}\n+\tdefer f.Close()\n+\tif st.IsDir() {\n \t\tc.AbortWithStatusJSON(http.StatusNotFound, gin.H{\n \t\t\t\"error\": \"The requested resource was not found on this server.\",\n \t\t})\n \t\treturn\n \t}\n \n-\tf, err := os.Open(p)\n-\tif err != nil {\n-\t\tmiddleware.CaptureAndAbort(c, err)\n-\t\treturn\n-\t}\n-\tdefer f.Close()\n-\n \tc.Header(\"Content-Length\", strconv.Itoa(int(st.Size())))\n \tc.Header(\"Content-Disposition\", \"attachment; filename=\"+strconv.Quote(st.Name()))\n \tc.Header(\"Content-Type\", \"application/octet-stream\")"
        },
        {
          "filename": "router/router_server.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -228,6 +228,7 @@ func deleteServer(c *gin.Context) {\n \t// In addition, servers with large amounts of files can take some time to finish deleting,\n \t// so we don't want to block the HTTP call while waiting on this.\n \tgo func(p string) {\n+\t\t_ = s.Filesystem().UnixFS().Close()\n \t\tif err := os.RemoveAll(p); err != nil {\n \t\t\tlog.WithFields(log.Fields{\"path\": p, \"error\": err}).Warn(\"failed to remove server files during deletion process\")\n \t\t}"
        },
        {
          "filename": "router/router_server_files.go",
          "status": "modified",
          "additions": 13,
          "deletions": 11,
          "patch": "@@ -30,7 +30,7 @@ import (\n // getServerFileContents returns the contents of a file on the server.\n func getServerFileContents(c *gin.Context) {\n \ts := middleware.ExtractServer(c)\n-\tp := \"/\" + strings.TrimLeft(c.Query(\"file\"), \"/\")\n+\tp := strings.TrimLeft(c.Query(\"file\"), \"/\")\n \tf, st, err := s.Filesystem().File(p)\n \tif err != nil {\n \t\tmiddleware.CaptureAndAbort(c, err)\n@@ -129,7 +129,6 @@ func putServerRenameFiles(c *gin.Context) {\n \t\t\t\t}\n \t\t\t\tif err := fs.Rename(pf, pt); err != nil {\n \t\t\t\t\t// Return nil if the error is an is not exists.\n-\t\t\t\t\t// NOTE: os.IsNotExist() does not work if the error is wrapped.\n \t\t\t\t\tif errors.Is(err, os.ErrNotExist) {\n \t\t\t\t\t\ts.Log().WithField(\"error\", err).\n \t\t\t\t\t\t\tWithField(\"from_path\", pf).\n@@ -239,7 +238,15 @@ func postServerWriteFile(c *gin.Context) {\n \t\tmiddleware.CaptureAndAbort(c, err)\n \t\treturn\n \t}\n-\tif err := s.Filesystem().Writefile(f, c.Request.Body); err != nil {\n+\n+\tif c.Request.ContentLength < 1 {\n+\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\n+\t\t\t\"error\": \"Missing Content-Length\",\n+\t\t})\n+\t\treturn\n+\t}\n+\n+\tif err := s.Filesystem().Write(f, c.Request.Body, c.Request.ContentLength, 0o644); err != nil {\n \t\tif filesystem.IsErrorCode(err, filesystem.ErrCodeIsDirectory) {\n \t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\n \t\t\t\t\"error\": \"Cannot write file, name conflicts with an existing directory by the same name.\",\n@@ -589,15 +596,9 @@ func postServerUploadFiles(c *gin.Context) {\n \t}\n \n \tfor _, header := range headers {\n-\t\tp, err := s.Filesystem().SafePath(filepath.Join(directory, header.Filename))\n-\t\tif err != nil {\n-\t\t\tmiddleware.CaptureAndAbort(c, err)\n-\t\t\treturn\n-\t\t}\n-\n \t\t// We run this in a different method so I can use defer without any of\n \t\t// the consequences caused by calling it in a loop.\n-\t\tif err := handleFileUpload(p, s, header); err != nil {\n+\t\tif err := handleFileUpload(filepath.Join(directory, header.Filename), s, header); err != nil {\n \t\t\tmiddleware.CaptureAndAbort(c, err)\n \t\t\treturn\n \t\t} else {\n@@ -619,7 +620,8 @@ func handleFileUpload(p string, s *server.Server, header *multipart.FileHeader)\n \tif err := s.Filesystem().IsIgnored(p); err != nil {\n \t\treturn err\n \t}\n-\tif err := s.Filesystem().Writefile(p, file); err != nil {\n+\n+\tif err := s.Filesystem().Write(p, file, header.Size, 0o644); err != nil {\n \t\treturn err\n \t}\n \treturn nil"
        },
        {
          "filename": "router/router_transfer.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -106,6 +106,7 @@ func postTransfers(c *gin.Context) {\n \t\t\tif !successful && err != nil {\n \t\t\t\t// Delete all extracted files.\n \t\t\t\tgo func(trnsfr *transfer.Transfer) {\n+\t\t\t\t\t_ = trnsfr.Server.Filesystem().UnixFS().Close()\n \t\t\t\t\tif err := os.RemoveAll(trnsfr.Server.Filesystem().Path()); err != nil && !os.IsNotExist(err) {\n \t\t\t\t\t\ttrnsfr.Log().WithError(err).Warn(\"failed to delete local server files\")\n \t\t\t\t\t}"
        },
        {
          "filename": "server/backup.go",
          "status": "modified",
          "additions": 6,
          "deletions": 9,
          "patch": "@@ -67,7 +67,7 @@ func (s *Server) Backup(b backup.BackupInterface) error {\n \t\t}\n \t}\n \n-\tad, err := b.Generate(s.Context(), s.Filesystem().Path(), ignored)\n+\tad, err := b.Generate(s.Context(), s.Filesystem(), ignored)\n \tif err != nil {\n \t\tif err := s.notifyPanelOfBackup(b.Identifier(), &backup.ArchiveDetails{}, false); err != nil {\n \t\t\ts.Log().WithFields(log.Fields{\n@@ -154,17 +154,14 @@ func (s *Server) RestoreBackup(b backup.BackupInterface, reader io.ReadCloser) (\n \terr = b.Restore(s.Context(), reader, func(file string, info fs.FileInfo, r io.ReadCloser) error {\n \t\tdefer r.Close()\n \t\ts.Events().Publish(DaemonMessageEvent, \"(restoring): \"+file)\n-\n-\t\tif err := s.Filesystem().Writefile(file, r); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif err := s.Filesystem().Chmod(file, info.Mode()); err != nil {\n+\t\t// TODO: since this will be called a lot, it may be worth adding an optimized\n+\t\t// Write with Chtimes method to the UnixFS that is able to re-use the\n+\t\t// same dirfd and file name.\n+\t\tif err := s.Filesystem().Write(file, r, info.Size(), info.Mode()); err != nil {\n \t\t\treturn err\n \t\t}\n-\n \t\tatime := info.ModTime()\n-\t\tmtime := atime\n-\t\treturn s.Filesystem().Chtimes(file, atime, mtime)\n+\t\treturn s.Filesystem().Chtimes(file, atime, atime)\n \t})\n \n \treturn errors.WithStackIf(err)"
        },
        {
          "filename": "server/backup/backup.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -16,6 +16,7 @@ import (\n \n \t\"github.com/pterodactyl/wings/config\"\n \t\"github.com/pterodactyl/wings/remote\"\n+\t\"github.com/pterodactyl/wings/server/filesystem\"\n )\n \n var format = archiver.CompressedArchive{\n@@ -46,7 +47,7 @@ type BackupInterface interface {\n \tWithLogContext(map[string]interface{})\n \t// Generate creates a backup in whatever the configured source for the\n \t// specific implementation is.\n-\tGenerate(context.Context, string, string) (*ArchiveDetails, error)\n+\tGenerate(context.Context, *filesystem.Filesystem, string) (*ArchiveDetails, error)\n \t// Ignored returns the ignored files for this backup instance.\n \tIgnored() string\n \t// Checksum returns a SHA1 checksum for the generated backup."
        },
        {
          "filename": "server/backup/backup_local.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -59,10 +59,10 @@ func (b *LocalBackup) WithLogContext(c map[string]interface{}) {\n \n // Generate generates a backup of the selected files and pushes it to the\n // defined location for this instance.\n-func (b *LocalBackup) Generate(ctx context.Context, basePath, ignore string) (*ArchiveDetails, error) {\n+func (b *LocalBackup) Generate(ctx context.Context, fsys *filesystem.Filesystem, ignore string) (*ArchiveDetails, error) {\n \ta := &filesystem.Archive{\n-\t\tBasePath: basePath,\n-\t\tIgnore:   ignore,\n+\t\tFilesystem: fsys,\n+\t\tIgnore:     ignore,\n \t}\n \n \tb.log().WithField(\"path\", b.Path()).Info(\"creating backup for server\")"
        },
        {
          "filename": "server/backup/backup_s3.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -48,12 +48,12 @@ func (s *S3Backup) WithLogContext(c map[string]interface{}) {\n \n // Generate creates a new backup on the disk, moves it into the S3 bucket via\n // the provided presigned URL, and then deletes the backup from the disk.\n-func (s *S3Backup) Generate(ctx context.Context, basePath, ignore string) (*ArchiveDetails, error) {\n+func (s *S3Backup) Generate(ctx context.Context, fsys *filesystem.Filesystem, ignore string) (*ArchiveDetails, error) {\n \tdefer s.Remove()\n \n \ta := &filesystem.Archive{\n-\t\tBasePath: basePath,\n-\t\tIgnore:   ignore,\n+\t\tFilesystem: fsys,\n+\t\tIgnore:     ignore,\n \t}\n \n \ts.log().WithField(\"path\", s.Path()).Info(\"creating backup for server\")"
        },
        {
          "filename": "server/config_parser.go",
          "status": "modified",
          "additions": 8,
          "deletions": 6,
          "patch": "@@ -4,9 +4,11 @@ import (\n \t\"runtime\"\n \n \t\"github.com/gammazero/workerpool\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n-// UpdateConfigurationFiles updates all of the defined configuration files for\n+// UpdateConfigurationFiles updates all the defined configuration files for\n // a server automatically to ensure that they always use the specified values.\n func (s *Server) UpdateConfigurationFiles() {\n \tpool := workerpool.New(runtime.NumCPU())\n@@ -18,18 +20,18 @@ func (s *Server) UpdateConfigurationFiles() {\n \t\tf := cf\n \n \t\tpool.Submit(func() {\n-\t\t\tp, err := s.Filesystem().SafePath(f.FileName)\n+\t\t\tfile, err := s.Filesystem().UnixFS().Touch(f.FileName, ufs.O_RDWR|ufs.O_CREATE, 0o644)\n \t\t\tif err != nil {\n-\t\t\t\ts.Log().WithField(\"error\", err).Error(\"failed to generate safe path for configuration file\")\n-\n+\t\t\t\ts.Log().WithField(\"file_name\", f.FileName).WithField(\"error\", err).Error(\"failed to open file for configuration\")\n \t\t\t\treturn\n \t\t\t}\n+\t\t\tdefer file.Close()\n \n-\t\t\tif err := f.Parse(p, false); err != nil {\n+\t\t\tif err := f.Parse(file); err != nil {\n \t\t\t\ts.Log().WithField(\"error\", err).Error(\"failed to parse and update server configuration file\")\n \t\t\t}\n \n-\t\t\ts.Log().WithField(\"path\", f.FileName).Debug(\"finished processing server configuration file\")\n+\t\t\ts.Log().WithField(\"file_name\", f.FileName).Debug(\"finished processing server configuration file\")\n \t\t})\n \t}\n "
        },
        {
          "filename": "server/filesystem/archive.go",
          "status": "modified",
          "additions": 63,
          "deletions": 58,
          "patch": "@@ -3,7 +3,6 @@ package filesystem\n import (\n \t\"archive/tar\"\n \t\"context\"\n-\t\"fmt\"\n \t\"io\"\n \t\"io/fs\"\n \t\"os\"\n@@ -14,12 +13,12 @@ import (\n \t\"emperror.dev/errors\"\n \t\"github.com/apex/log\"\n \t\"github.com/juju/ratelimit\"\n-\t\"github.com/karrick/godirwalk\"\n \t\"github.com/klauspost/pgzip\"\n \tignore \"github.com/sabhiram/go-gitignore\"\n \n \t\"github.com/pterodactyl/wings/config\"\n \t\"github.com/pterodactyl/wings/internal/progress\"\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n const memory = 4 * 1024\n@@ -57,14 +56,16 @@ func (p *TarProgress) Write(v []byte) (int, error) {\n }\n \n type Archive struct {\n-\t// BasePath is the absolute path to create the archive from where Files and Ignore are\n-\t// relative to.\n-\tBasePath string\n+\t// Filesystem to create the archive with.\n+\tFilesystem *Filesystem\n \n \t// Ignore is a gitignore string (most likely read from a file) of files to ignore\n \t// from the archive.\n \tIgnore string\n \n+\t// BaseDirectory .\n+\tBaseDirectory string\n+\n \t// Files specifies the files to archive, this takes priority over the Ignore option, if\n \t// unspecified, all files in the BasePath will be archived unless Ignore is set.\n \t//\n@@ -73,11 +74,18 @@ type Archive struct {\n \n \t// Progress wraps the writer of the archive to pass through the progress tracker.\n \tProgress *progress.Progress\n+\n+\tw *TarProgress\n }\n \n // Create creates an archive at dst with all the files defined in the\n // included Files array.\n+//\n+// THIS IS UNSAFE TO USE IF `dst` IS PROVIDED BY A USER! ONLY USE THIS WITH\n+// CONTROLLED PATHS!\n func (a *Archive) Create(ctx context.Context, dst string) error {\n+\t// Using os.OpenFile here is expected, as long as `dst` is not a user\n+\t// provided path.\n \tf, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o600)\n \tif err != nil {\n \t\treturn err\n@@ -98,14 +106,19 @@ func (a *Archive) Create(ctx context.Context, dst string) error {\n \treturn a.Stream(ctx, writer)\n }\n \n-// Stream .\n+type walkFunc func(dirfd int, name, relative string, d ufs.DirEntry) error\n+\n+// Stream streams the creation of the archive to the given writer.\n func (a *Archive) Stream(ctx context.Context, w io.Writer) error {\n-\tfor _, f := range a.Files {\n-\t\tif strings.HasPrefix(f, a.BasePath) {\n+\tif a.Filesystem == nil {\n+\t\treturn errors.New(\"filesystem: archive.Filesystem is unset\")\n+\t}\n+\n+\tfor i, f := range a.Files {\n+\t\tif !strings.HasPrefix(f, a.Filesystem.Path()) {\n \t\t\tcontinue\n \t\t}\n-\n-\t\treturn fmt.Errorf(\"archive: all entries in Files must be absolute and within BasePath: %s\\n\", f)\n+\t\ta.Files[i] = strings.TrimPrefix(strings.TrimPrefix(f, a.Filesystem.Path()), \"/\")\n \t}\n \n \t// Choose which compression level to use based on the compression_level configuration option\n@@ -130,107 +143,100 @@ func (a *Archive) Stream(ctx context.Context, w io.Writer) error {\n \ttw := tar.NewWriter(gw)\n \tdefer tw.Close()\n \n-\tpw := NewTarProgress(tw, a.Progress)\n+\ta.w = NewTarProgress(tw, a.Progress)\n \n-\t// Configure godirwalk.\n-\toptions := &godirwalk.Options{\n-\t\tFollowSymbolicLinks: false,\n-\t\tUnsorted:            true,\n-\t}\n+\tfs := a.Filesystem.unixFS\n \n \t// If we're specifically looking for only certain files, or have requested\n \t// that certain files be ignored we'll update the callback function to reflect\n \t// that request.\n-\tvar callback godirwalk.WalkFunc\n+\tvar callback walkFunc\n \tif len(a.Files) == 0 && len(a.Ignore) > 0 {\n \t\ti := ignore.CompileIgnoreLines(strings.Split(a.Ignore, \"\\n\")...)\n-\n-\t\tcallback = a.callback(pw, func(_ string, rp string) error {\n-\t\t\tif i.MatchesPath(rp) {\n-\t\t\t\treturn godirwalk.SkipThis\n+\t\tcallback = a.callback(func(_ int, _, relative string, _ ufs.DirEntry) error {\n+\t\t\tif i.MatchesPath(relative) {\n+\t\t\t\treturn ufs.SkipDir\n \t\t\t}\n-\n \t\t\treturn nil\n \t\t})\n \t} else if len(a.Files) > 0 {\n-\t\tcallback = a.withFilesCallback(pw)\n+\t\tcallback = a.withFilesCallback()\n \t} else {\n-\t\tcallback = a.callback(pw)\n+\t\tcallback = a.callback()\n \t}\n \n-\t// Set the callback function, wrapped with support for context cancellation.\n-\toptions.Callback = func(path string, de *godirwalk.Dirent) error {\n+\tdirfd, name, closeFd, err := fs.SafePath(a.BaseDirectory)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn fs.WalkDirat(dirfd, name, func(dirfd int, name, relative string, d ufs.DirEntry, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\tselect {\n \t\tcase <-ctx.Done():\n \t\t\treturn ctx.Err()\n \t\tdefault:\n-\t\t\treturn callback(path, de)\n+\t\t\treturn callback(dirfd, name, relative, d)\n \t\t}\n-\t}\n-\n-\t// Recursively walk the path we are archiving.\n-\treturn godirwalk.Walk(a.BasePath, options)\n+\t})\n }\n \n // Callback function used to determine if a given file should be included in the archive\n // being generated.\n-func (a *Archive) callback(tw *TarProgress, opts ...func(path string, relative string) error) func(path string, de *godirwalk.Dirent) error {\n-\treturn func(path string, de *godirwalk.Dirent) error {\n+func (a *Archive) callback(opts ...walkFunc) walkFunc {\n+\treturn func(dirfd int, name, relative string, d ufs.DirEntry) error {\n \t\t// Skip directories because we are walking them recursively.\n-\t\tif de.IsDir() {\n+\t\tif d.IsDir() {\n \t\t\treturn nil\n \t\t}\n \n-\t\trelative := filepath.ToSlash(strings.TrimPrefix(path, a.BasePath+string(filepath.Separator)))\n-\n \t\t// Call the additional options passed to this callback function. If any of them return\n \t\t// a non-nil error we will exit immediately.\n \t\tfor _, opt := range opts {\n-\t\t\tif err := opt(path, relative); err != nil {\n+\t\t\tif err := opt(dirfd, name, relative, d); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \n \t\t// Add the file to the archive, if it is nested in a directory,\n \t\t// the directory will be automatically \"created\" in the archive.\n-\t\treturn a.addToArchive(path, relative, tw)\n+\t\treturn a.addToArchive(dirfd, name, relative, d)\n \t}\n }\n \n // Pushes only files defined in the Files key to the final archive.\n-func (a *Archive) withFilesCallback(tw *TarProgress) func(path string, de *godirwalk.Dirent) error {\n-\treturn a.callback(tw, func(p string, rp string) error {\n+func (a *Archive) withFilesCallback() walkFunc {\n+\treturn a.callback(func(_ int, _, relative string, _ ufs.DirEntry) error {\n \t\tfor _, f := range a.Files {\n \t\t\t// Allow exact file matches, otherwise check if file is within a parent directory.\n \t\t\t//\n \t\t\t// The slashes are added in the prefix checks to prevent partial name matches from being\n \t\t\t// included in the archive.\n-\t\t\tif f != p && !strings.HasPrefix(strings.TrimSuffix(p, \"/\")+\"/\", strings.TrimSuffix(f, \"/\")+\"/\") {\n+\t\t\tif f != relative && !strings.HasPrefix(strings.TrimSuffix(relative, \"/\")+\"/\", strings.TrimSuffix(f, \"/\")+\"/\") {\n \t\t\t\tcontinue\n \t\t\t}\n \n \t\t\t// Once we have a match return a nil value here so that the loop stops and the\n \t\t\t// call to this function will correctly include the file in the archive. If there\n \t\t\t// are no matches we'll never make it to this line, and the final error returned\n-\t\t\t// will be the godirwalk.SkipThis error.\n+\t\t\t// will be the ufs.SkipDir error.\n \t\t\treturn nil\n \t\t}\n \n-\t\treturn godirwalk.SkipThis\n+\t\treturn ufs.SkipDir\n \t})\n }\n \n // Adds a given file path to the final archive being created.\n-func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {\n-\t// Lstat the file, this will give us the same information as Stat except that it will not\n-\t// follow a symlink to its target automatically. This is important to avoid including\n-\t// files that exist outside the server root unintentionally in the backup.\n-\ts, err := os.Lstat(p)\n+func (a *Archive) addToArchive(dirfd int, name, relative string, entry ufs.DirEntry) error {\n+\ts, err := entry.Info()\n \tif err != nil {\n-\t\tif os.IsNotExist(err) {\n+\t\tif errors.Is(err, ufs.ErrNotExist) {\n \t\t\treturn nil\n \t\t}\n-\t\treturn errors.WrapIff(err, \"failed executing os.Lstat on '%s'\", rp)\n+\t\treturn errors.WrapIff(err, \"failed executing os.Lstat on '%s'\", name)\n \t}\n \n \t// Skip socket files as they are unsupported by archive/tar.\n@@ -250,7 +256,7 @@ func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {\n \t\tif err != nil {\n \t\t\t// Ignore the not exist errors specifically, since there is nothing important about that.\n \t\t\tif !os.IsNotExist(err) {\n-\t\t\t\tlog.WithField(\"path\", rp).WithField(\"readlink_err\", err.Error()).Warn(\"failed reading symlink for target path; skipping...\")\n+\t\t\t\tlog.WithField(\"name\", name).WithField(\"readlink_err\", err.Error()).Warn(\"failed reading symlink for target path; skipping...\")\n \t\t\t}\n \t\t\treturn nil\n \t\t}\n@@ -259,17 +265,17 @@ func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {\n \t// Get the tar FileInfoHeader in order to add the file to the archive.\n \theader, err := tar.FileInfoHeader(s, filepath.ToSlash(target))\n \tif err != nil {\n-\t\treturn errors.WrapIff(err, \"failed to get tar#FileInfoHeader for '%s'\", rp)\n+\t\treturn errors.WrapIff(err, \"failed to get tar#FileInfoHeader for '%s'\", name)\n \t}\n \n \t// Fix the header name if the file is not a symlink.\n \tif s.Mode()&fs.ModeSymlink == 0 {\n-\t\theader.Name = rp\n+\t\theader.Name = relative\n \t}\n \n \t// Write the tar FileInfoHeader to the archive.\n-\tif err := w.WriteHeader(header); err != nil {\n-\t\treturn errors.WrapIff(err, \"failed to write tar#FileInfoHeader for '%s'\", rp)\n+\tif err := a.w.WriteHeader(header); err != nil {\n+\t\treturn errors.WrapIff(err, \"failed to write tar#FileInfoHeader for '%s'\", name)\n \t}\n \n \t// If the size of the file is less than 1 (most likely for symlinks), skip writing the file.\n@@ -291,7 +297,7 @@ func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {\n \t}\n \n \t// Open the file.\n-\tf, err := os.Open(p)\n+\tf, err := a.Filesystem.unixFS.OpenFileat(dirfd, name, ufs.O_RDONLY, 0)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n \t\t\treturn nil\n@@ -301,9 +307,8 @@ func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {\n \tdefer f.Close()\n \n \t// Copy the file's contents to the archive using our buffer.\n-\tif _, err := io.CopyBuffer(w, io.LimitReader(f, header.Size), buf); err != nil {\n+\tif _, err := io.CopyBuffer(a.w, io.LimitReader(f, header.Size), buf); err != nil {\n \t\treturn errors.WrapIff(err, \"failed to copy '%s' to archive\", header.Name)\n \t}\n-\n \treturn nil\n }"
        },
        {
          "filename": "server/filesystem/archive_test.go",
          "status": "modified",
          "additions": 13,
          "deletions": 22,
          "patch": "@@ -20,43 +20,34 @@ func TestArchive_Stream(t *testing.T) {\n \tg.Describe(\"Archive\", func() {\n \t\tg.AfterEach(func() {\n \t\t\t// Reset the filesystem after each run.\n-\t\t\trfs.reset()\n-\t\t})\n-\n-\t\tg.It(\"throws an error when passed invalid file paths\", func() {\n-\t\t\ta := &Archive{\n-\t\t\t\tBasePath: fs.Path(),\n-\t\t\t\tFiles: []string{\n-\t\t\t\t\t// To use the archiver properly, this needs to be filepath.Join(BasePath, \"yeet\")\n-\t\t\t\t\t// However, this test tests that we actually validate that behavior.\n-\t\t\t\t\t\"yeet\",\n-\t\t\t\t},\n-\t\t\t}\n-\n-\t\t\tg.Assert(a.Create(context.Background(), \"\")).IsNotNil()\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \n \t\tg.It(\"creates archive with intended files\", func() {\n \t\t\tg.Assert(fs.CreateDirectory(\"test\", \"/\")).IsNil()\n \t\t\tg.Assert(fs.CreateDirectory(\"test2\", \"/\")).IsNil()\n \n-\t\t\terr := fs.Writefile(\"test/file.txt\", strings.NewReader(\"hello, world!\\n\"))\n+\t\t\tr := strings.NewReader(\"hello, world!\\n\")\n+\t\t\terr := fs.Write(\"test/file.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n-\t\t\terr = fs.Writefile(\"test2/file.txt\", strings.NewReader(\"hello, world!\\n\"))\n+\t\t\tr = strings.NewReader(\"hello, world!\\n\")\n+\t\t\terr = fs.Write(\"test2/file.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n-\t\t\terr = fs.Writefile(\"test_file.txt\", strings.NewReader(\"hello, world!\\n\"))\n+\t\t\tr = strings.NewReader(\"hello, world!\\n\")\n+\t\t\terr = fs.Write(\"test_file.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n-\t\t\terr = fs.Writefile(\"test_file.txt.old\", strings.NewReader(\"hello, world!\\n\"))\n+\t\t\tr = strings.NewReader(\"hello, world!\\n\")\n+\t\t\terr = fs.Write(\"test_file.txt.old\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\ta := &Archive{\n-\t\t\t\tBasePath: fs.Path(),\n+\t\t\t\tFilesystem: fs,\n \t\t\t\tFiles: []string{\n-\t\t\t\t\tfilepath.Join(fs.Path(), \"test\"),\n-\t\t\t\t\tfilepath.Join(fs.Path(), \"test_file.txt\"),\n+\t\t\t\t\t\"test\",\n+\t\t\t\t\t\"test_file.txt\",\n \t\t\t\t},\n \t\t\t}\n \n@@ -119,7 +110,7 @@ func getFiles(f iofs.ReadDirFS, name string) ([]string, error) {\n \t\t\tif files == nil {\n \t\t\t\treturn nil, nil\n \t\t\t}\n-\t\t\t\n+\n \t\t\tv = append(v, files...)\n \t\t\tcontinue\n \t\t}"
        },
        {
          "filename": "server/filesystem/compress.go",
          "status": "modified",
          "additions": 77,
          "deletions": 81,
          "patch": "@@ -5,15 +5,17 @@ import (\n \t\"fmt\"\n \t\"io\"\n \tiofs \"io/fs\"\n-\t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync/atomic\"\n \t\"time\"\n \n \t\"emperror.dev/errors\"\n+\t\"github.com/klauspost/compress/zip\"\n \t\"github.com/mholt/archiver/v4\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n // CompressFiles compresses all the files matching the given paths in the\n@@ -25,46 +27,69 @@ import (\n // All paths are relative to the dir that is passed in as the first argument,\n // and the compressed file will be placed at that location named\n // `archive-{date}.tar.gz`.\n-func (fs *Filesystem) CompressFiles(dir string, paths []string) (os.FileInfo, error) {\n-\tcleanedRootDir, err := fs.SafePath(dir)\n+func (fs *Filesystem) CompressFiles(dir string, paths []string) (ufs.FileInfo, error) {\n+\ta := &Archive{Filesystem: fs, BaseDirectory: dir, Files: paths}\n+\td := path.Join(\n+\t\tdir,\n+\t\tfmt.Sprintf(\"archive-%s.tar.gz\", strings.ReplaceAll(time.Now().Format(time.RFC3339), \":\", \"\")),\n+\t)\n+\tf, err := fs.unixFS.OpenFile(d, ufs.O_WRONLY|ufs.O_CREATE, 0o644)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n-\t// Take all the paths passed in and merge them together with the root directory we've gotten.\n-\tfor i, p := range paths {\n-\t\tpaths[i] = filepath.Join(cleanedRootDir, p)\n+\tdefer f.Close()\n+\tcw := ufs.NewCountedWriter(f)\n+\tif err := a.Stream(context.Background(), cw); err != nil {\n+\t\treturn nil, err\n \t}\n+\tif !fs.unixFS.CanFit(cw.BytesWritten()) {\n+\t\t_ = fs.unixFS.Remove(d)\n+\t\treturn nil, newFilesystemError(ErrCodeDiskSpace, nil)\n+\t}\n+\tfs.unixFS.Add(cw.BytesWritten())\n+\treturn f.Stat()\n+}\n \n-\tcleaned, err := fs.ParallelSafePath(paths)\n+func (fs *Filesystem) archiverFileSystem(ctx context.Context, p string) (iofs.FS, error) {\n+\tf, err := fs.unixFS.Open(p)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\t// Do not use defer to close `f`, it will likely be used later.\n \n-\ta := &Archive{BasePath: cleanedRootDir, Files: cleaned}\n-\td := path.Join(\n-\t\tcleanedRootDir,\n-\t\tfmt.Sprintf(\"archive-%s.tar.gz\", strings.ReplaceAll(time.Now().Format(time.RFC3339), \":\", \"\")),\n-\t)\n-\n-\tif err := a.Create(context.Background(), d); err != nil {\n+\tformat, _, err := archiver.Identify(filepath.Base(p), f)\n+\tif err != nil && !errors.Is(err, archiver.ErrNoMatch) {\n+\t\t_ = f.Close()\n \t\treturn nil, err\n \t}\n \n-\tf, err := os.Stat(d)\n-\tif err != nil {\n-\t\t_ = os.Remove(d)\n+\t// Reset the file reader.\n+\tif _, err := f.Seek(0, io.SeekStart); err != nil {\n+\t\t_ = f.Close()\n \t\treturn nil, err\n \t}\n \n-\tif err := fs.HasSpaceFor(f.Size()); err != nil {\n-\t\t_ = os.Remove(d)\n+\tinfo, err := f.Stat()\n+\tif err != nil {\n+\t\t_ = f.Close()\n \t\treturn nil, err\n \t}\n \n-\tfs.addDisk(f.Size())\n+\tif format != nil {\n+\t\tswitch ff := format.(type) {\n+\t\tcase archiver.Zip:\n+\t\t\t// zip.Reader is more performant than ArchiveFS, because zip.Reader caches content information\n+\t\t\t// and zip.Reader can open several content files concurrently because of io.ReaderAt requirement\n+\t\t\t// while ArchiveFS can't.\n+\t\t\t// zip.Reader doesn't suffer from issue #330 and #310 according to local test (but they should be fixed anyway)\n+\t\t\treturn zip.NewReader(f, info.Size())\n+\t\tcase archiver.Archival:\n+\t\t\treturn archiver.ArchiveFS{Stream: io.NewSectionReader(f, 0, info.Size()), Format: ff, Context: ctx}, nil\n+\t\t}\n+\t}\n \n-\treturn f, nil\n+\t_ = f.Close()\n+\treturn nil, nil\n }\n \n // SpaceAvailableForDecompression looks through a given archive and determines\n@@ -76,24 +101,15 @@ func (fs *Filesystem) SpaceAvailableForDecompression(ctx context.Context, dir st\n \t\treturn nil\n \t}\n \n-\tsource, err := fs.SafePath(filepath.Join(dir, file))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\t// Get the cached size in a parallel process so that if it is not cached we are not\n-\t// waiting an unnecessary amount of time on this call.\n-\tdirSize, err := fs.DiskUsage(false)\n-\n-\tfsys, err := archiver.FileSystem(ctx, source)\n+\tfsys, err := fs.archiverFileSystem(ctx, filepath.Join(dir, file))\n \tif err != nil {\n \t\tif errors.Is(err, archiver.ErrNoMatch) {\n \t\t\treturn newFilesystemError(ErrCodeUnknownArchive, err)\n \t\t}\n \t\treturn err\n \t}\n \n-\tvar size int64\n+\tvar size atomic.Int64\n \treturn iofs.WalkDir(fsys, \".\", func(path string, d iofs.DirEntry, err error) error {\n \t\tif err != nil {\n \t\t\treturn err\n@@ -108,7 +124,7 @@ func (fs *Filesystem) SpaceAvailableForDecompression(ctx context.Context, dir st\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tif atomic.AddInt64(&size, info.Size())+dirSize > fs.MaxDisk() {\n+\t\t\tif !fs.unixFS.CanFit(size.Add(info.Size())) {\n \t\t\t\treturn newFilesystemError(ErrCodeDiskSpace, nil)\n \t\t\t}\n \t\t\treturn nil\n@@ -122,23 +138,7 @@ func (fs *Filesystem) SpaceAvailableForDecompression(ctx context.Context, dir st\n // zip-slip attack being attempted by validating that the final path is within\n // the server data directory.\n func (fs *Filesystem) DecompressFile(ctx context.Context, dir string, file string) error {\n-\tsource, err := fs.SafePath(filepath.Join(dir, file))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn fs.DecompressFileUnsafe(ctx, dir, source)\n-}\n-\n-// DecompressFileUnsafe will decompress any file on the local disk without checking\n-// if it is owned by the server.  The file will be SAFELY decompressed and extracted\n-// into the server's directory.\n-func (fs *Filesystem) DecompressFileUnsafe(ctx context.Context, dir string, file string) error {\n-\t// Ensure that the archive actually exists on the system.\n-\tif _, err := os.Stat(file); err != nil {\n-\t\treturn errors.WithStack(err)\n-\t}\n-\n-\tf, err := os.Open(file)\n+\tf, err := fs.unixFS.Open(filepath.Join(dir, file))\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -169,7 +169,6 @@ func (fs *Filesystem) ExtractStreamUnsafe(ctx context.Context, dir string, r io.\n \t\t}\n \t\treturn err\n \t}\n-\n \treturn fs.extractStream(ctx, extractStreamOptions{\n \t\tDirectory: dir,\n \t\tFormat:    format,\n@@ -190,34 +189,31 @@ type extractStreamOptions struct {\n \n func (fs *Filesystem) extractStream(ctx context.Context, opts extractStreamOptions) error {\n \t// Decompress and extract archive\n-\tif ex, ok := opts.Format.(archiver.Extractor); ok {\n-\t\treturn ex.Extract(ctx, opts.Reader, nil, func(ctx context.Context, f archiver.File) error {\n-\t\t\tif f.IsDir() {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tp := filepath.Join(opts.Directory, f.NameInArchive)\n-\t\t\t// If it is ignored, just don't do anything with the file and skip over it.\n-\t\t\tif err := fs.IsIgnored(p); err != nil {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tr, err := f.Open()\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tdefer r.Close()\n-\t\t\tif err := fs.Writefile(p, r); err != nil {\n-\t\t\t\treturn wrapError(err, opts.FileName)\n-\t\t\t}\n-\t\t\t// Update the file permissions to the one set in the archive.\n-\t\t\tif err := fs.Chmod(p, f.Mode()); err != nil {\n-\t\t\t\treturn wrapError(err, opts.FileName)\n-\t\t\t}\n-\t\t\t// Update the file modification time to the one set in the archive.\n-\t\t\tif err := fs.Chtimes(p, f.ModTime(), f.ModTime()); err != nil {\n-\t\t\t\treturn wrapError(err, opts.FileName)\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t})\n+\tex, ok := opts.Format.(archiver.Extractor)\n+\tif !ok {\n+\t\treturn nil\n \t}\n-\treturn nil\n+\treturn ex.Extract(ctx, opts.Reader, nil, func(ctx context.Context, f archiver.File) error {\n+\t\tif f.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tp := filepath.Join(opts.Directory, f.NameInArchive)\n+\t\t// If it is ignored, just don't do anything with the file and skip over it.\n+\t\tif err := fs.IsIgnored(p); err != nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tr, err := f.Open()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tdefer r.Close()\n+\t\tif err := fs.Write(p, r, f.Size(), f.Mode()); err != nil {\n+\t\t\treturn wrapError(err, opts.FileName)\n+\t\t}\n+\t\t// Update the file modification time to the one set in the archive.\n+\t\tif err := fs.Chtimes(p, f.ModTime(), f.ModTime()); err != nil {\n+\t\t\treturn wrapError(err, opts.FileName)\n+\t\t}\n+\t\treturn nil\n+\t})\n }"
        },
        {
          "filename": "server/filesystem/compress_test.go",
          "status": "modified",
          "additions": 3,
          "deletions": 4,
          "patch": "@@ -3,17 +3,18 @@ package filesystem\n import (\n \t\"context\"\n \t\"os\"\n-\t\"sync/atomic\"\n \t\"testing\"\n \n \t. \"github.com/franela/goblin\"\n )\n \n // Given an archive named test.{ext}, with the following file structure:\n+//\n //\ttest/\n //\t|\u2500\u2500inside/\n //\t|\u2500\u2500\u2500\u2500finside.txt\n //\t|\u2500\u2500outside.txt\n+//\n // this test will ensure that it's being decompressed as expected\n func TestFilesystem_DecompressFile(t *testing.T) {\n \tg := Goblin(t)\n@@ -47,9 +48,7 @@ func TestFilesystem_DecompressFile(t *testing.T) {\n \t\t}\n \n \t\tg.AfterEach(func() {\n-\t\t\trfs.reset()\n-\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n-\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }"
        },
        {
          "filename": "server/filesystem/disk_space.go",
          "status": "modified",
          "additions": 40,
          "deletions": 74,
          "patch": "@@ -3,24 +3,25 @@ package filesystem\n import (\n \t\"sync\"\n \t\"sync/atomic\"\n-\t\"syscall\"\n \t\"time\"\n \n \t\"emperror.dev/errors\"\n \t\"github.com/apex/log\"\n-\t\"github.com/karrick/godirwalk\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n type SpaceCheckingOpts struct {\n \tAllowStaleResponse bool\n }\n \n+// TODO: can this be replaced with some sort of atomic? Like atomic.Pointer?\n type usageLookupTime struct {\n \tsync.RWMutex\n \tvalue time.Time\n }\n \n-// Update the last time that a disk space lookup was performed.\n+// Set sets the last time that a disk space lookup was performed.\n func (ult *usageLookupTime) Set(t time.Time) {\n \tult.Lock()\n \tult.value = t\n@@ -35,14 +36,15 @@ func (ult *usageLookupTime) Get() time.Time {\n \treturn ult.value\n }\n \n-// Returns the maximum amount of disk space that this Filesystem instance is allowed to use.\n+// MaxDisk returns the maximum amount of disk space that this Filesystem\n+// instance is allowed to use.\n func (fs *Filesystem) MaxDisk() int64 {\n-\treturn atomic.LoadInt64(&fs.diskLimit)\n+\treturn fs.unixFS.Limit()\n }\n \n-// Sets the disk space limit for this Filesystem instance.\n+// SetDiskLimit sets the disk space limit for this Filesystem instance.\n func (fs *Filesystem) SetDiskLimit(i int64) {\n-\tatomic.SwapInt64(&fs.diskLimit, i)\n+\tfs.unixFS.SetLimit(i)\n }\n \n // The same concept as HasSpaceAvailable however this will return an error if there is\n@@ -65,7 +67,7 @@ func (fs *Filesystem) HasSpaceErr(allowStaleValue bool) error {\n func (fs *Filesystem) HasSpaceAvailable(allowStaleValue bool) bool {\n \tsize, err := fs.DiskUsage(allowStaleValue)\n \tif err != nil {\n-\t\tlog.WithField(\"root\", fs.root).WithField(\"error\", err).Warn(\"failed to determine root fs directory size\")\n+\t\tlog.WithField(\"root\", fs.Path()).WithField(\"error\", err).Warn(\"failed to determine root fs directory size\")\n \t}\n \n \t// If space is -1 or 0 just return true, means they're allowed unlimited.\n@@ -84,7 +86,7 @@ func (fs *Filesystem) HasSpaceAvailable(allowStaleValue bool) bool {\n // function for critical logical checks. It should only be used in areas where the actual disk usage\n // does not need to be perfect, e.g. API responses for server resource usage.\n func (fs *Filesystem) CachedUsage() int64 {\n-\treturn atomic.LoadInt64(&fs.diskUsed)\n+\treturn fs.unixFS.Usage()\n }\n \n // Internal helper function to allow other parts of the codebase to check the total used disk space\n@@ -114,14 +116,14 @@ func (fs *Filesystem) DiskUsage(allowStaleValue bool) (int64, error) {\n \t\t\t// currently performing a lookup, just do the disk usage calculation in the background.\n \t\t\tgo func(fs *Filesystem) {\n \t\t\t\tif _, err := fs.updateCachedDiskUsage(); err != nil {\n-\t\t\t\t\tlog.WithField(\"root\", fs.root).WithField(\"error\", err).Warn(\"failed to update fs disk usage from within routine\")\n+\t\t\t\t\tlog.WithField(\"root\", fs.Path()).WithField(\"error\", err).Warn(\"failed to update fs disk usage from within routine\")\n \t\t\t\t}\n \t\t\t}(fs)\n \t\t}\n \t}\n \n \t// Return the currently cached value back to the calling function.\n-\treturn atomic.LoadInt64(&fs.diskUsed), nil\n+\treturn fs.unixFS.Usage(), nil\n }\n \n // Updates the currently used disk space for a server.\n@@ -149,88 +151,52 @@ func (fs *Filesystem) updateCachedDiskUsage() (int64, error) {\n \t// error encountered.\n \tfs.lastLookupTime.Set(time.Now())\n \n-\tatomic.StoreInt64(&fs.diskUsed, size)\n+\tfs.unixFS.SetUsage(size)\n \n \treturn size, err\n }\n \n-// Determines the directory size of a given location by running parallel tasks to iterate\n-// through all of the folders. Returns the size in bytes. This can be a fairly taxing operation\n-// on locations with tons of files, so it is recommended that you cache the output.\n-func (fs *Filesystem) DirectorySize(dir string) (int64, error) {\n-\td, err := fs.SafePath(dir)\n+// DirectorySize calculates the size of a directory and its descendants.\n+func (fs *Filesystem) DirectorySize(root string) (int64, error) {\n+\tdirfd, name, closeFd, err := fs.unixFS.SafePath(root)\n+\tdefer closeFd()\n \tif err != nil {\n \t\treturn 0, err\n \t}\n \n-\tvar size int64\n-\tvar st syscall.Stat_t\n-\n-\terr = godirwalk.Walk(d, &godirwalk.Options{\n-\t\tUnsorted: true,\n-\t\tCallback: func(p string, e *godirwalk.Dirent) error {\n-\t\t\t// If this is a symlink then resolve the final destination of it before trying to continue walking\n-\t\t\t// over its contents. If it resolves outside the server data directory just skip everything else for\n-\t\t\t// it. Otherwise, allow it to continue.\n-\t\t\tif e.IsSymlink() {\n-\t\t\t\tif _, err := fs.SafePath(p); err != nil {\n-\t\t\t\t\tif IsErrorCode(err, ErrCodePathResolution) {\n-\t\t\t\t\t\treturn godirwalk.SkipThis\n-\t\t\t\t\t}\n-\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif !e.IsDir() {\n-\t\t\t\t_ = syscall.Lstat(p, &st)\n-\t\t\t\tatomic.AddInt64(&size, st.Size)\n-\t\t\t}\n+\tvar size atomic.Int64\n+\terr = fs.unixFS.WalkDirat(dirfd, name, func(dirfd int, name, _ string, d ufs.DirEntry, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn errors.Wrap(err, \"walkdirat err\")\n+\t\t}\n \n+\t\t// Only calculate the size of regular files.\n+\t\tif !d.Type().IsRegular() {\n \t\t\treturn nil\n-\t\t},\n-\t})\n+\t\t}\n \n-\treturn size, errors.WrapIf(err, \"server/filesystem: directorysize: failed to walk directory\")\n+\t\tinfo, err := fs.unixFS.Lstatat(dirfd, name)\n+\t\tif err != nil {\n+\t\t\treturn errors.Wrap(err, \"lstatat err\")\n+\t\t}\n+\n+\t\t// TODO: detect if info is a hard-link and de-duplicate it.\n+\t\t// ref; https://github.com/pterodactyl/wings/pull/181/files\n+\n+\t\tsize.Add(info.Size())\n+\t\treturn nil\n+\t})\n+\treturn size.Load(), errors.WrapIf(err, \"server/filesystem: directorysize: failed to walk directory\")\n }\n \n-// Helper function to determine if a server has space available for a file of a given size.\n-// If space is available, no error will be returned, otherwise an ErrNotEnoughSpace error\n-// will be raised.\n func (fs *Filesystem) HasSpaceFor(size int64) error {\n-\tif fs.MaxDisk() == 0 {\n-\t\treturn nil\n-\t}\n-\ts, err := fs.DiskUsage(true)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif (s + size) > fs.MaxDisk() {\n+\tif !fs.unixFS.CanFit(size) {\n \t\treturn newFilesystemError(ErrCodeDiskSpace, nil)\n \t}\n \treturn nil\n }\n \n // Updates the disk usage for the Filesystem instance.\n func (fs *Filesystem) addDisk(i int64) int64 {\n-\tsize := atomic.LoadInt64(&fs.diskUsed)\n-\n-\t// Sorry go gods. This is ugly but the best approach I can come up with for right\n-\t// now without completely re-evaluating the logic we use for determining disk space.\n-\t//\n-\t// Normally I would just be using the atomic load right below, but I'm not sure about\n-\t// the scenarios where it is 0 because nothing has run that would trigger a disk size\n-\t// calculation?\n-\t//\n-\t// Perhaps that isn't even a concern for the sake of this?\n-\tif !fs.isTest {\n-\t\tsize, _ = fs.DiskUsage(true)\n-\t}\n-\n-\t// If we're dropping below 0 somehow just cap it to 0.\n-\tif (size + i) < 0 {\n-\t\treturn atomic.SwapInt64(&fs.diskUsed, 0)\n-\t}\n-\n-\treturn atomic.AddInt64(&fs.diskUsed, i)\n+\treturn fs.unixFS.Add(i)\n }"
        },
        {
          "filename": "server/filesystem/errors.go",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -2,11 +2,12 @@ package filesystem\n \n import (\n \t\"fmt\"\n-\t\"os\"\n \t\"path/filepath\"\n \n \t\"emperror.dev/errors\"\n \t\"github.com/apex/log\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n type ErrorCode string\n@@ -86,15 +87,15 @@ func (e *Error) Unwrap() error {\n \n // Generates an error logger instance with some basic information.\n func (fs *Filesystem) error(err error) *log.Entry {\n-\treturn log.WithField(\"subsystem\", \"filesystem\").WithField(\"root\", fs.root).WithField(\"error\", err)\n+\treturn log.WithField(\"subsystem\", \"filesystem\").WithField(\"root\", fs.Path()).WithField(\"error\", err)\n }\n \n // Handle errors encountered when walking through directories.\n //\n // If there is a path resolution error just skip the item entirely. Only return this for a\n // directory, otherwise return nil. Returning this error for a file will stop the walking\n-// for the remainder of the directory. This is assuming an os.FileInfo struct was even returned.\n-func (fs *Filesystem) handleWalkerError(err error, f os.FileInfo) error {\n+// for the remainder of the directory. This is assuming an FileInfo struct was even returned.\n+func (fs *Filesystem) handleWalkerError(err error, f ufs.FileInfo) error {\n \tif !IsErrorCode(err, ErrCodePathResolution) {\n \t\treturn err\n \t}"
        },
        {
          "filename": "server/filesystem/filesystem.go",
          "status": "modified",
          "additions": 277,
          "deletions": 373,
          "patch": "@@ -1,291 +1,264 @@\n package filesystem\n \n import (\n-\t\"bufio\"\n+\t\"fmt\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n-\t\"sort\"\n+\t\"slices\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n \t\"sync/atomic\"\n \t\"time\"\n \n \t\"emperror.dev/errors\"\n+\t\"github.com/apex/log\"\n \t\"github.com/gabriel-vasile/mimetype\"\n-\t\"github.com/karrick/godirwalk\"\n \tignore \"github.com/sabhiram/go-gitignore\"\n \n \t\"github.com/pterodactyl/wings/config\"\n-\t\"github.com/pterodactyl/wings/system\"\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n+// TODO: detect and enable\n+var useOpenat2 = true\n+\n type Filesystem struct {\n+\tunixFS *ufs.Quota\n+\n \tmu                sync.RWMutex\n \tlastLookupTime    *usageLookupTime\n-\tlookupInProgress  *system.AtomicBool\n-\tdiskUsed          int64\n+\tlookupInProgress  atomic.Bool\n \tdiskCheckInterval time.Duration\n \tdenylist          *ignore.GitIgnore\n \n-\t// The maximum amount of disk space (in bytes) that this Filesystem instance can use.\n-\tdiskLimit int64\n-\n-\t// The root data directory path for this Filesystem instance.\n-\troot string\n-\n \tisTest bool\n }\n \n // New creates a new Filesystem instance for a given server.\n-func New(root string, size int64, denylist []string) *Filesystem {\n+func New(root string, size int64, denylist []string) (*Filesystem, error) {\n+\tif err := os.MkdirAll(root, 0o755); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tunixFS, err := ufs.NewUnixFS(root, config.UseOpenat2())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tquota := ufs.NewQuota(unixFS, size)\n+\n \treturn &Filesystem{\n-\t\troot:              root,\n-\t\tdiskLimit:         size,\n+\t\tunixFS: quota,\n+\n \t\tdiskCheckInterval: time.Duration(config.Get().System.DiskCheckInterval),\n \t\tlastLookupTime:    &usageLookupTime{},\n-\t\tlookupInProgress:  system.NewAtomicBool(false),\n \t\tdenylist:          ignore.CompileIgnoreLines(denylist...),\n-\t}\n+\t}, nil\n }\n \n // Path returns the root path for the Filesystem instance.\n func (fs *Filesystem) Path() string {\n-\treturn fs.root\n+\treturn fs.unixFS.BasePath()\n+}\n+\n+// ReadDir reads directory entries.\n+func (fs *Filesystem) ReadDir(path string) ([]ufs.DirEntry, error) {\n+\treturn fs.unixFS.ReadDir(path)\n+}\n+\n+// ReadDirStat is like ReadDir except that it returns FileInfo for each entry\n+// instead of just a DirEntry.\n+func (fs *Filesystem) ReadDirStat(path string) ([]ufs.FileInfo, error) {\n+\treturn ufs.ReadDirMap(fs.unixFS.UnixFS, path, func(e ufs.DirEntry) (ufs.FileInfo, error) {\n+\t\treturn e.Info()\n+\t})\n }\n \n // File returns a reader for a file instance as well as the stat information.\n-func (fs *Filesystem) File(p string) (*os.File, Stat, error) {\n-\tcleaned, err := fs.SafePath(p)\n+func (fs *Filesystem) File(p string) (ufs.File, Stat, error) {\n+\tf, err := fs.unixFS.Open(p)\n \tif err != nil {\n-\t\treturn nil, Stat{}, errors.WithStackIf(err)\n+\t\treturn nil, Stat{}, err\n \t}\n-\tst, err := fs.Stat(cleaned)\n+\tst, err := statFromFile(f)\n \tif err != nil {\n-\t\tif errors.Is(err, os.ErrNotExist) {\n-\t\t\treturn nil, Stat{}, newFilesystemError(ErrNotExist, err)\n-\t\t}\n-\t\treturn nil, Stat{}, errors.WithStackIf(err)\n-\t}\n-\tif st.IsDir() {\n-\t\treturn nil, Stat{}, newFilesystemError(ErrCodeIsDirectory, nil)\n-\t}\n-\tf, err := os.Open(cleaned)\n-\tif err != nil {\n-\t\treturn nil, Stat{}, errors.WithStackIf(err)\n+\t\t_ = f.Close()\n+\t\treturn nil, Stat{}, err\n \t}\n \treturn f, st, nil\n }\n \n+func (fs *Filesystem) UnixFS() *ufs.UnixFS {\n+\treturn fs.unixFS.UnixFS\n+}\n+\n // Touch acts by creating the given file and path on the disk if it is not present\n // already. If  it is present, the file is opened using the defaults which will truncate\n // the contents. The opened file is then returned to the caller.\n-func (fs *Filesystem) Touch(p string, flag int) (*os.File, error) {\n-\tcleaned, err := fs.SafePath(p)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tf, err := os.OpenFile(cleaned, flag, 0o644)\n-\tif err == nil {\n-\t\treturn f, nil\n-\t}\n-\tif f != nil {\n-\t\t_ = f.Close()\n-\t}\n-\t// If the error is not because it doesn't exist then we just need to bail at this point.\n-\tif !errors.Is(err, os.ErrNotExist) {\n-\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file handle\")\n-\t}\n-\t// Only create and chown the directory if it doesn't exist.\n-\tif _, err := os.Stat(filepath.Dir(cleaned)); errors.Is(err, os.ErrNotExist) {\n-\t\t// Create the path leading up to the file we're trying to create, setting the final perms\n-\t\t// on it as we go.\n-\t\tif err := os.MkdirAll(filepath.Dir(cleaned), 0o755); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to create directory tree\")\n-\t\t}\n-\t\tif err := fs.Chown(filepath.Dir(cleaned)); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\to := &fileOpener{}\n-\t// Try to open the file now that we have created the pathing necessary for it, and then\n-\t// Chown that file so that the permissions don't mess with things.\n-\tf, err = o.open(cleaned, flag, 0o644)\n-\tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file with wait\")\n-\t}\n-\t_ = fs.Chown(cleaned)\n-\treturn f, nil\n+func (fs *Filesystem) Touch(p string, flag int) (ufs.File, error) {\n+\treturn fs.unixFS.Touch(p, flag, 0o644)\n }\n \n // Writefile writes a file to the system. If the file does not already exist one\n // will be created. This will also properly recalculate the disk space used by\n // the server when writing new files or modifying existing ones.\n+//\n+// DEPRECATED: use `Write` instead.\n func (fs *Filesystem) Writefile(p string, r io.Reader) error {\n-\tcleaned, err := fs.SafePath(p)\n+\tvar currentSize int64\n+\tst, err := fs.unixFS.Stat(p)\n+\tif err != nil && !errors.Is(err, ufs.ErrNotExist) {\n+\t\treturn errors.Wrap(err, \"server/filesystem: writefile: failed to stat file\")\n+\t} else if err == nil {\n+\t\tif st.IsDir() {\n+\t\t\t// TODO: resolved\n+\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: \"\"})\n+\t\t}\n+\t\tcurrentSize = st.Size()\n+\t}\n+\n+\t// Touch the file and return the handle to it at this point. This will\n+\t// create or truncate the file, and create any necessary parent directories\n+\t// if they are missing.\n+\tfile, err := fs.unixFS.Touch(p, ufs.O_RDWR|ufs.O_TRUNC, 0o644)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"error touching file: %w\", err)\n \t}\n+\tdefer file.Close()\n \n+\t// Do not use CopyBuffer here, it is wasteful as the file implements\n+\t// io.ReaderFrom, which causes it to not use the buffer anyways.\n+\tn, err := io.Copy(file, r)\n+\n+\t// Adjust the disk usage to account for the old size and the new size of the file.\n+\tfs.unixFS.Add(n - currentSize)\n+\n+\tif err := fs.chownFile(p); err != nil {\n+\t\treturn fmt.Errorf(\"error chowning file: %w\", err)\n+\t}\n+\t// Return the error from io.Copy.\n+\treturn err\n+}\n+\n+func (fs *Filesystem) Write(p string, r io.Reader, newSize int64, mode ufs.FileMode) error {\n \tvar currentSize int64\n-\t// If the file does not exist on the system already go ahead and create the pathway\n-\t// to it and an empty file. We'll then write to it later on after this completes.\n-\tstat, err := os.Stat(cleaned)\n-\tif err != nil && !os.IsNotExist(err) {\n+\tst, err := fs.unixFS.Stat(p)\n+\tif err != nil && !errors.Is(err, ufs.ErrNotExist) {\n \t\treturn errors.Wrap(err, \"server/filesystem: writefile: failed to stat file\")\n \t} else if err == nil {\n-\t\tif stat.IsDir() {\n-\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: cleaned})\n+\t\tif st.IsDir() {\n+\t\t\t// TODO: resolved\n+\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: \"\"})\n \t\t}\n-\t\tcurrentSize = stat.Size()\n+\t\tcurrentSize = st.Size()\n \t}\n \n-\tbr := bufio.NewReader(r)\n \t// Check that the new size we're writing to the disk can fit. If there is currently\n \t// a file we'll subtract that current file size from the size of the buffer to determine\n \t// the amount of new data we're writing (or amount we're removing if smaller).\n-\tif err := fs.HasSpaceFor(int64(br.Size()) - currentSize); err != nil {\n+\tif err := fs.HasSpaceFor(newSize - currentSize); err != nil {\n \t\treturn err\n \t}\n \n-\t// Touch the file and return the handle to it at this point. This will create the file,\n-\t// any necessary directories, and set the proper owner of the file.\n-\tfile, err := fs.Touch(cleaned, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n+\t// Touch the file and return the handle to it at this point. This will\n+\t// create or truncate the file, and create any necessary parent directories\n+\t// if they are missing.\n+\tfile, err := fs.unixFS.Touch(p, ufs.O_RDWR|ufs.O_TRUNC, mode)\n \tif err != nil {\n \t\treturn err\n \t}\n \tdefer file.Close()\n \n-\tbuf := make([]byte, 1024*4)\n-\tsz, err := io.CopyBuffer(file, r, buf)\n+\t// Do not use CopyBuffer here, it is wasteful as the file implements\n+\t// io.ReaderFrom, which causes it to not use the buffer anyways.\n+\tn, err := io.Copy(file, io.LimitReader(r, newSize))\n \n \t// Adjust the disk usage to account for the old size and the new size of the file.\n-\tfs.addDisk(sz - currentSize)\n+\tfs.unixFS.Add(n - currentSize)\n \n-\treturn fs.unsafeChown(cleaned)\n-}\n-\n-// Creates a new directory (name) at a specified path (p) for the server.\n-func (fs *Filesystem) CreateDirectory(name string, p string) error {\n-\tcleaned, err := fs.SafePath(path.Join(p, name))\n-\tif err != nil {\n+\tif err := fs.chownFile(p); err != nil {\n \t\treturn err\n \t}\n-\treturn os.MkdirAll(cleaned, 0o755)\n+\t// Return the error from io.Copy.\n+\treturn err\n }\n \n-// Rename moves (or renames) a file or directory.\n-func (fs *Filesystem) Rename(from string, to string) error {\n-\tcleanedFrom, err := fs.SafePath(from)\n-\tif err != nil {\n-\t\treturn errors.WithStack(err)\n-\t}\n-\n-\tcleanedTo, err := fs.SafePath(to)\n-\tif err != nil {\n-\t\treturn errors.WithStack(err)\n-\t}\n+// CreateDirectory creates a new directory (name) at a specified path (p) for\n+// the server.\n+func (fs *Filesystem) CreateDirectory(name string, p string) error {\n+\treturn fs.unixFS.MkdirAll(filepath.Join(p, name), 0o755)\n+}\n \n-\t// If the target file or directory already exists the rename function will fail, so just\n-\t// bail out now.\n-\tif _, err := os.Stat(cleanedTo); err == nil {\n-\t\treturn os.ErrExist\n-\t}\n+func (fs *Filesystem) Rename(oldpath, newpath string) error {\n+\treturn fs.unixFS.Rename(oldpath, newpath)\n+}\n \n-\tif cleanedTo == fs.Path() {\n-\t\treturn errors.New(\"attempting to rename into an invalid directory space\")\n-\t}\n+func (fs *Filesystem) Symlink(oldpath, newpath string) error {\n+\treturn fs.unixFS.Symlink(oldpath, newpath)\n+}\n \n-\td := strings.TrimSuffix(cleanedTo, path.Base(cleanedTo))\n-\t// Ensure that the directory we're moving into exists correctly on the system. Only do this if\n-\t// we're not at the root directory level.\n-\tif d != fs.Path() {\n-\t\tif mkerr := os.MkdirAll(d, 0o755); mkerr != nil {\n-\t\t\treturn errors.WithMessage(mkerr, \"failed to create directory structure for file rename\")\n-\t\t}\n+func (fs *Filesystem) chownFile(name string) error {\n+\tif fs.isTest {\n+\t\treturn nil\n \t}\n \n-\tif err := os.Rename(cleanedFrom, cleanedTo); err != nil {\n-\t\treturn errors.WithStack(err)\n-\t}\n-\treturn nil\n+\tuid := config.Get().System.User.Uid\n+\tgid := config.Get().System.User.Gid\n+\treturn fs.unixFS.Lchown(name, uid, gid)\n }\n \n-// Recursively iterates over a file or directory and sets the permissions on all of the\n+// Chown recursively iterates over a file or directory and sets the permissions on all of the\n // underlying files. Iterate over all of the files and directories. If it is a file just\n // go ahead and perform the chown operation. Otherwise dig deeper into the directory until\n // we've run out of directories to dig into.\n-func (fs *Filesystem) Chown(path string) error {\n-\tcleaned, err := fs.SafePath(path)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\treturn fs.unsafeChown(cleaned)\n-}\n-\n-// unsafeChown chowns the given path, without checking if the path is safe. This should only be used\n-// when the path has already been checked.\n-func (fs *Filesystem) unsafeChown(path string) error {\n+func (fs *Filesystem) Chown(p string) error {\n \tif fs.isTest {\n \t\treturn nil\n \t}\n \n \tuid := config.Get().System.User.Uid\n \tgid := config.Get().System.User.Gid\n \n+\tdirfd, name, closeFd, err := fs.unixFS.SafePath(p)\n+\tdefer closeFd()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \t// Start by just chowning the initial path that we received.\n-\tif err := os.Chown(path, uid, gid); err != nil {\n+\tif err := fs.unixFS.Lchownat(dirfd, name, uid, gid); err != nil {\n \t\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown path\")\n \t}\n \n \t// If this is not a directory we can now return from the function, there is nothing\n \t// left that we need to do.\n-\tif st, err := os.Stat(path); err != nil || !st.IsDir() {\n+\tif st, err := fs.unixFS.Lstatat(dirfd, name); err != nil || !st.IsDir() {\n \t\treturn nil\n \t}\n \n-\t// If this was a directory, begin walking over its contents recursively and ensure that all\n-\t// of the subfiles and directories get their permissions updated as well.\n-\terr := godirwalk.Walk(path, &godirwalk.Options{\n-\t\tUnsorted: true,\n-\t\tCallback: func(p string, e *godirwalk.Dirent) error {\n-\t\t\t// Do not attempt to chown a symlink. Go's os.Chown function will affect the symlink\n-\t\t\t// so if it points to a location outside the data directory the user would be able to\n-\t\t\t// (un)intentionally modify that files permissions.\n-\t\t\tif e.IsSymlink() {\n-\t\t\t\tif e.IsDir() {\n-\t\t\t\t\treturn godirwalk.SkipThis\n-\t\t\t\t}\n-\n-\t\t\t\treturn nil\n-\t\t\t}\n-\n-\t\t\treturn os.Chown(p, uid, gid)\n-\t\t},\n-\t})\n-\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown during walk function\")\n-}\n-\n-func (fs *Filesystem) Chmod(path string, mode os.FileMode) error {\n-\tcleaned, err := fs.SafePath(path)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif fs.isTest {\n+\t// This walker is probably some of the most efficient code in Wings. It has\n+\t// an internally re-used buffer for listing directory entries and doesn't\n+\t// need to check if every individual path it touches is safe as the code\n+\t// doesn't traverse symlinks, is immune to symlink timing attacks, and\n+\t// gives us a dirfd and file name to make a direct syscall with.\n+\tif err := fs.unixFS.WalkDirat(dirfd, name, func(dirfd int, name, _ string, info ufs.DirEntry, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := fs.unixFS.Lchownat(dirfd, name, uid, gid); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\treturn nil\n+\t}); err != nil {\n+\t\treturn fmt.Errorf(\"server/filesystem: chown: failed to chown during walk function: %w\", err)\n \t}\n-\n-\tif err := os.Chmod(cleaned, mode); err != nil {\n-\t\treturn err\n-\t}\n-\n \treturn nil\n }\n \n+func (fs *Filesystem) Chmod(path string, mode ufs.FileMode) error {\n+\treturn fs.unixFS.Chmod(path, mode)\n+}\n+\n // Begin looping up to 50 times to try and create a unique copy file name. This will take\n // an input of \"file.txt\" and generate \"file copy.txt\". If that name is already taken, it will\n // then try to write \"file copy 2.txt\" and so on, until reaching 50 loops. At that point we\n@@ -294,7 +267,7 @@ func (fs *Filesystem) Chmod(path string, mode os.FileMode) error {\n // Could probably make this more efficient by checking if there are any files matching the copy\n // pattern, and trying to find the highest number and then incrementing it by one rather than\n // looping endlessly.\n-func (fs *Filesystem) findCopySuffix(dir string, name string, extension string) (string, error) {\n+func (fs *Filesystem) findCopySuffix(dirfd int, name, extension string) (string, error) {\n \tvar i int\n \tsuffix := \" copy\"\n \n@@ -306,11 +279,10 @@ func (fs *Filesystem) findCopySuffix(dir string, name string, extension string)\n \t\tn := name + suffix + extension\n \t\t// If we stat the file and it does not exist that means we're good to create the copy. If it\n \t\t// does exist, we'll just continue to the next loop and try again.\n-\t\tif _, err := fs.Stat(path.Join(dir, n)); err != nil {\n-\t\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\tif _, err := fs.unixFS.Lstatat(dirfd, n); err != nil {\n+\t\t\tif !errors.Is(err, ufs.ErrNotExist) {\n \t\t\t\treturn \"\", err\n \t\t\t}\n-\n \t\t\tbreak\n \t\t}\n \n@@ -322,53 +294,68 @@ func (fs *Filesystem) findCopySuffix(dir string, name string, extension string)\n \treturn name + suffix + extension, nil\n }\n \n-// Copies a given file to the same location and appends a suffix to the file to indicate that\n-// it has been copied.\n+// Copy copies a given file to the same location and appends a suffix to the\n+// file to indicate that it has been copied.\n func (fs *Filesystem) Copy(p string) error {\n-\tcleaned, err := fs.SafePath(p)\n+\tdirfd, name, closeFd, err := fs.unixFS.SafePath(p)\n+\tdefer closeFd()\n \tif err != nil {\n \t\treturn err\n \t}\n-\n-\ts, err := os.Stat(cleaned)\n+\tsource, err := fs.unixFS.OpenFileat(dirfd, name, ufs.O_RDONLY, 0)\n \tif err != nil {\n \t\treturn err\n-\t} else if s.IsDir() || !s.Mode().IsRegular() {\n+\t}\n+\tdefer source.Close()\n+\tinfo, err := source.Stat()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif info.IsDir() || !info.Mode().IsRegular() {\n \t\t// If this is a directory or not a regular file, just throw a not-exist error\n \t\t// since anything calling this function should understand what that means.\n-\t\treturn os.ErrNotExist\n+\t\treturn ufs.ErrNotExist\n \t}\n+\tcurrentSize := info.Size()\n \n \t// Check that copying this file wouldn't put the server over its limit.\n-\tif err := fs.HasSpaceFor(s.Size()); err != nil {\n+\tif err := fs.HasSpaceFor(currentSize); err != nil {\n \t\treturn err\n \t}\n \n-\tbase := filepath.Base(cleaned)\n-\trelative := strings.TrimSuffix(strings.TrimPrefix(cleaned, fs.Path()), base)\n+\tbase := info.Name()\n \textension := filepath.Ext(base)\n-\tname := strings.TrimSuffix(base, extension)\n+\tbaseName := strings.TrimSuffix(base, extension)\n \n \t// Ensure that \".tar\" is also counted as apart of the file extension.\n \t// There might be a better way to handle this for other double file extensions,\n \t// but this is a good workaround for now.\n-\tif strings.HasSuffix(name, \".tar\") {\n+\tif strings.HasSuffix(baseName, \".tar\") {\n \t\textension = \".tar\" + extension\n-\t\tname = strings.TrimSuffix(name, \".tar\")\n+\t\tbaseName = strings.TrimSuffix(baseName, \".tar\")\n \t}\n \n-\tsource, err := os.Open(cleaned)\n+\tnewName, err := fs.findCopySuffix(dirfd, baseName, extension)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tdefer source.Close()\n-\n-\tn, err := fs.findCopySuffix(relative, name, extension)\n+\tdst, err := fs.unixFS.OpenFileat(dirfd, newName, ufs.O_WRONLY|ufs.O_CREATE, info.Mode())\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\treturn fs.Writefile(path.Join(relative, n), source)\n+\t// Do not use CopyBuffer here, it is wasteful as the file implements\n+\t// io.ReaderFrom, which causes it to not use the buffer anyways.\n+\tn, err := io.Copy(dst, io.LimitReader(source, currentSize))\n+\tfs.unixFS.Add(n)\n+\n+\tif !fs.isTest {\n+\t\tif err := fs.unixFS.Lchownat(dirfd, newName, config.Get().System.User.Uid, config.Get().System.User.Gid); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\t// Return the error from io.Copy.\n+\treturn err\n }\n \n // TruncateRootDirectory removes _all_ files and directories from a server's\n@@ -380,211 +367,128 @@ func (fs *Filesystem) TruncateRootDirectory() error {\n \tif err := os.Mkdir(fs.Path(), 0o755); err != nil {\n \t\treturn err\n \t}\n-\tatomic.StoreInt64(&fs.diskUsed, 0)\n+\t_ = fs.unixFS.Close()\n+\tunixFS, err := ufs.NewUnixFS(fs.Path(), config.UseOpenat2())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvar limit int64\n+\tif fs.isTest {\n+\t\tlimit = 0\n+\t} else {\n+\t\tlimit = fs.unixFS.Limit()\n+\t}\n+\tfs.unixFS = ufs.NewQuota(unixFS, limit)\n \treturn nil\n }\n \n // Delete removes a file or folder from the system. Prevents the user from\n // accidentally (or maliciously) removing their root server data directory.\n func (fs *Filesystem) Delete(p string) error {\n-\t// This is one of the few (only?) places in the codebase where we're explicitly not using\n-\t// the SafePath functionality when working with user provided input. If we did, you would\n-\t// not be able to delete a file that is a symlink pointing to a location outside the data\n-\t// directory.\n-\t//\n-\t// We also want to avoid resolving a symlink that points _within_ the data directory and thus\n-\t// deleting the actual source file for the symlink rather than the symlink itself. For these\n-\t// purposes just resolve the actual file path using filepath.Join() and confirm that the path\n-\t// exists within the data directory.\n-\tresolved := fs.unsafeFilePath(p)\n-\tif !fs.unsafeIsInDataDirectory(resolved) {\n-\t\treturn NewBadPathResolution(p, resolved)\n-\t}\n-\n-\t// Block any whoopsies.\n-\tif resolved == fs.Path() {\n-\t\treturn errors.New(\"cannot delete root server directory\")\n-\t}\n-\n-\tst, err := os.Lstat(resolved)\n-\tif err != nil {\n-\t\tif !os.IsNotExist(err) {\n-\t\t\tfs.error(err).Warn(\"error while attempting to stat file before deletion\")\n-\t\t\treturn err\n-\t\t}\n-\n-\t\t// The following logic is used to handle a case where a user attempts to\n-\t\t// delete a file that does not exist through a directory symlink.\n-\t\t// We don't want to reveal that the file does not exist, so we validate\n-\t\t// the path of the symlink and return a bad path error if it is invalid.\n-\n-\t\t// The requested file or directory doesn't exist, so at this point we\n-\t\t// need to iterate up the path chain until we hit a directory that\n-\t\t// _does_ exist and can be validated.\n-\t\tparts := strings.Split(filepath.Dir(resolved), \"/\")\n-\n-\t\t// Range over all the path parts and form directory paths from the end\n-\t\t// moving up until we have a valid resolution, or we run out of paths to\n-\t\t// try.\n-\t\tfor k := range parts {\n-\t\t\ttry := strings.Join(parts[:(len(parts)-k)], \"/\")\n-\t\t\tif !fs.unsafeIsInDataDirectory(try) {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tt, err := filepath.EvalSymlinks(try)\n-\t\t\tif err == nil {\n-\t\t\t\tif !fs.unsafeIsInDataDirectory(t) {\n-\t\t\t\t\treturn NewBadPathResolution(p, t)\n-\t\t\t\t}\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n+\treturn fs.unixFS.RemoveAll(p)\n+}\n \n-\t\t// Always return early if the file does not exist.\n-\t\treturn nil\n-\t}\n+//type fileOpener struct {\n+//\tfs   *Filesystem\n+//\tbusy uint\n+//}\n+//\n+//// Attempts to open a given file up to \"attempts\" number of times, using a backoff. If the file\n+//// cannot be opened because of a \"text file busy\" error, we will attempt until the number of attempts\n+//// has been exhaused, at which point we will abort with an error.\n+//func (fo *fileOpener) open(path string, flags int, perm ufs.FileMode) (ufs.File, error) {\n+//\tfor {\n+//\t\tf, err := fo.fs.unixFS.OpenFile(path, flags, perm)\n+//\n+//\t\t// If there is an error because the text file is busy, go ahead and sleep for a few\n+//\t\t// hundred milliseconds and then try again up to three times before just returning the\n+//\t\t// error back to the caller.\n+//\t\t//\n+//\t\t// Based on code from: https://github.com/golang/go/issues/22220#issuecomment-336458122\n+//\t\tif err != nil && fo.busy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n+//\t\t\ttime.Sleep(100 * time.Millisecond << fo.busy)\n+//\t\t\tfo.busy++\n+//\t\t\tcontinue\n+//\t\t}\n+//\n+//\t\treturn f, err\n+//\t}\n+//}\n \n-\t// If the file is not a symlink, we need to check that it is not within a\n-\t// symlinked directory that points outside the data directory.\n-\tif st.Mode()&os.ModeSymlink == 0 {\n-\t\tep, err := filepath.EvalSymlinks(resolved)\n+// ListDirectory lists the contents of a given directory and returns stat\n+// information about each file and folder within it.\n+func (fs *Filesystem) ListDirectory(p string) ([]Stat, error) {\n+\t// Read entries from the path on the filesystem, using the mapped reader, so\n+\t// we can map the DirEntry slice into a Stat slice with mimetype information.\n+\tout, err := ufs.ReadDirMap(fs.unixFS.UnixFS, p, func(e ufs.DirEntry) (Stat, error) {\n+\t\tinfo, err := e.Info()\n \t\tif err != nil {\n-\t\t\tif !os.IsNotExist(err) {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t} else if !fs.unsafeIsInDataDirectory(ep) {\n-\t\t\treturn NewBadPathResolution(p, ep)\n+\t\t\treturn Stat{}, err\n \t\t}\n-\t}\n \n-\tif st.IsDir() {\n-\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n-\t\t\tfs.addDisk(-s)\n+\t\tvar d string\n+\t\tif e.Type().IsDir() {\n+\t\t\td = \"inode/directory\"\n+\t\t} else {\n+\t\t\td = \"application/octet-stream\"\n \t\t}\n-\t} else {\n-\t\tfs.addDisk(-st.Size())\n-\t}\n-\n-\treturn os.RemoveAll(resolved)\n-}\n-\n-type fileOpener struct {\n-\tbusy uint\n-}\n-\n-// Attempts to open a given file up to \"attempts\" number of times, using a backoff. If the file\n-// cannot be opened because of a \"text file busy\" error, we will attempt until the number of attempts\n-// has been exhaused, at which point we will abort with an error.\n-func (fo *fileOpener) open(path string, flags int, perm os.FileMode) (*os.File, error) {\n-\tfor {\n-\t\tf, err := os.OpenFile(path, flags, perm)\n-\n-\t\t// If there is an error because the text file is busy, go ahead and sleep for a few\n-\t\t// hundred milliseconds and then try again up to three times before just returning the\n-\t\t// error back to the caller.\n-\t\t//\n-\t\t// Based on code from: https://github.com/golang/go/issues/22220#issuecomment-336458122\n-\t\tif err != nil && fo.busy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n-\t\t\ttime.Sleep(100 * time.Millisecond << fo.busy)\n-\t\t\tfo.busy++\n-\t\t\tcontinue\n+\t\tvar m *mimetype.MIME\n+\t\tif e.Type().IsRegular() {\n+\t\t\t// TODO: I should probably find a better way to do this.\n+\t\t\teO := e.(interface {\n+\t\t\t\tOpen() (ufs.File, error)\n+\t\t\t})\n+\t\t\tf, err := eO.Open()\n+\t\t\tif err != nil {\n+\t\t\t\treturn Stat{}, err\n+\t\t\t}\n+\t\t\tm, err = mimetype.DetectReader(f)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Error(err.Error())\n+\t\t\t}\n+\t\t\t_ = f.Close()\n \t\t}\n \n-\t\treturn f, err\n-\t}\n-}\n-\n-// ListDirectory lists the contents of a given directory and returns stat\n-// information about each file and folder within it.\n-func (fs *Filesystem) ListDirectory(p string) ([]Stat, error) {\n-\tcleaned, err := fs.SafePath(p)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfiles, err := ioutil.ReadDir(cleaned)\n+\t\tst := Stat{FileInfo: info, Mimetype: d}\n+\t\tif m != nil {\n+\t\t\tst.Mimetype = m.String()\n+\t\t}\n+\t\treturn st, nil\n+\t})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar wg sync.WaitGroup\n-\n-\t// You must initialize the output of this directory as a non-nil value otherwise\n-\t// when it is marshaled into a JSON object you'll just get 'null' back, which will\n-\t// break the panel badly.\n-\tout := make([]Stat, len(files))\n-\n-\t// Iterate over all of the files and directories returned and perform an async process\n-\t// to get the mime-type for them all.\n-\tfor i, file := range files {\n-\t\twg.Add(1)\n-\n-\t\tgo func(idx int, f os.FileInfo) {\n-\t\t\tdefer wg.Done()\n-\n-\t\t\tvar m *mimetype.MIME\n-\t\t\td := \"inode/directory\"\n-\t\t\tif !f.IsDir() {\n-\t\t\t\tcleanedp := filepath.Join(cleaned, f.Name())\n-\t\t\t\tif f.Mode()&os.ModeSymlink != 0 {\n-\t\t\t\t\tcleanedp, _ = fs.SafePath(filepath.Join(cleaned, f.Name()))\n-\t\t\t\t}\n-\n-\t\t\t\t// Don't try to detect the type on a pipe \u2014 this will just hang the application and\n-\t\t\t\t// you'll never get a response back.\n-\t\t\t\t//\n-\t\t\t\t// @see https://github.com/pterodactyl/panel/issues/4059\n-\t\t\t\tif cleanedp != \"\" && f.Mode()&os.ModeNamedPipe == 0 {\n-\t\t\t\t\tm, _ = mimetype.DetectFile(filepath.Join(cleaned, f.Name()))\n-\t\t\t\t} else {\n-\t\t\t\t\t// Just pass this for an unknown type because the file could not safely be resolved within\n-\t\t\t\t\t// the server data path.\n-\t\t\t\t\td = \"application/octet-stream\"\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tst := Stat{FileInfo: f, Mimetype: d}\n-\t\t\tif m != nil {\n-\t\t\t\tst.Mimetype = m.String()\n-\t\t\t}\n-\t\t\tout[idx] = st\n-\t\t}(i, file)\n-\t}\n-\n-\twg.Wait()\n-\n-\t// Sort the output alphabetically to begin with since we've run the output\n-\t// through an asynchronous process and the order is gonna be very random.\n-\tsort.SliceStable(out, func(i, j int) bool {\n-\t\tif out[i].Name() == out[j].Name() || out[i].Name() > out[j].Name() {\n-\t\t\treturn true\n+\t// Sort entries alphabetically.\n+\tslices.SortStableFunc(out, func(a, b Stat) int {\n+\t\tswitch {\n+\t\tcase a.Name() == b.Name():\n+\t\t\treturn 0\n+\t\tcase a.Name() > b.Name():\n+\t\t\treturn 1\n+\t\tdefault:\n+\t\t\treturn -1\n \t\t}\n-\t\treturn false\n \t})\n \n-\t// Then, sort it so that directories are listed first in the output. Everything\n-\t// will continue to be alphabetized at this point.\n-\tsort.SliceStable(out, func(i, j int) bool {\n-\t\treturn out[i].IsDir()\n+\t// Sort folders before other file types.\n+\tslices.SortStableFunc(out, func(a, b Stat) int {\n+\t\tswitch {\n+\t\tcase a.IsDir() && b.IsDir():\n+\t\t\treturn 0\n+\t\tcase a.IsDir():\n+\t\t\treturn 1\n+\t\tdefault:\n+\t\t\treturn -1\n+\t\t}\n \t})\n \n \treturn out, nil\n }\n \n func (fs *Filesystem) Chtimes(path string, atime, mtime time.Time) error {\n-\tcleaned, err := fs.SafePath(path)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n \tif fs.isTest {\n \t\treturn nil\n \t}\n-\n-\tif err := os.Chtimes(cleaned, atime, mtime); err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn nil\n+\treturn fs.unixFS.Chtimes(path, atime, mtime)\n }"
        },
        {
          "filename": "server/filesystem/filesystem_test.go",
          "status": "modified",
          "additions": 70,
          "deletions": 81,
          "patch": "@@ -7,12 +7,13 @@ import (\n \t\"math/rand\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"sync/atomic\"\n \t\"testing\"\n \t\"unicode/utf8\"\n \n \t. \"github.com/franela/goblin\"\n \n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n+\n \t\"github.com/pterodactyl/wings/config\"\n )\n \n@@ -28,15 +29,23 @@ func NewFs() (*Filesystem, *rootFs) {\n \ttmpDir, err := os.MkdirTemp(os.TempDir(), \"pterodactyl\")\n \tif err != nil {\n \t\tpanic(err)\n+\t\treturn nil, nil\n \t}\n-\t// defer os.RemoveAll(tmpDir)\n \n \trfs := rootFs{root: tmpDir}\n \n-\trfs.reset()\n+\tp := filepath.Join(tmpDir, \"server\")\n+\tif err := os.Mkdir(p, 0o755); err != nil {\n+\t\tpanic(err)\n+\t\treturn nil, nil\n+\t}\n \n-\tfs := New(filepath.Join(tmpDir, \"/server\"), 0, []string{})\n+\tfs, _ := New(p, 0, []string{})\n \tfs.isTest = true\n+\tif err := fs.TruncateRootDirectory(); err != nil {\n+\t\tpanic(err)\n+\t\treturn nil, nil\n+\t}\n \n \treturn fs, &rfs\n }\n@@ -45,7 +54,7 @@ type rootFs struct {\n \troot string\n }\n \n-func getFileContent(file *os.File) string {\n+func getFileContent(file ufs.File) string {\n \tvar w bytes.Buffer\n \tif _, err := bufio.NewReader(file).WriteTo(&w); err != nil {\n \t\tpanic(err)\n@@ -54,11 +63,11 @@ func getFileContent(file *os.File) string {\n }\n \n func (rfs *rootFs) CreateServerFile(p string, c []byte) error {\n-\tf, err := os.Create(filepath.Join(rfs.root, \"/server\", p))\n+\tf, err := os.Create(filepath.Join(rfs.root, \"server\", p))\n \n \tif err == nil {\n-\t\tf.Write(c)\n-\t\tf.Close()\n+\t\t_, _ = f.Write(c)\n+\t\t_ = f.Close()\n \t}\n \n \treturn err\n@@ -69,19 +78,7 @@ func (rfs *rootFs) CreateServerFileFromString(p string, c string) error {\n }\n \n func (rfs *rootFs) StatServerFile(p string) (os.FileInfo, error) {\n-\treturn os.Stat(filepath.Join(rfs.root, \"/server\", p))\n-}\n-\n-func (rfs *rootFs) reset() {\n-\tif err := os.RemoveAll(filepath.Join(rfs.root, \"/server\")); err != nil {\n-\t\tif !os.IsNotExist(err) {\n-\t\t\tpanic(err)\n-\t\t}\n-\t}\n-\n-\tif err := os.Mkdir(filepath.Join(rfs.root, \"/server\"), 0o755); err != nil {\n-\t\tpanic(err)\n-\t}\n+\treturn os.Stat(filepath.Join(rfs.root, \"server\", p))\n }\n \n func TestFilesystem_Openfile(t *testing.T) {\n@@ -93,7 +90,8 @@ func TestFilesystem_Openfile(t *testing.T) {\n \t\t\t_, _, err := fs.File(\"foo/bar.txt\")\n \n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrNotExist)).IsTrue()\n+\t\t\t// TODO\n+\t\t\t//g.Assert(IsErrorCode(err, ErrNotExist)).IsTrue()\n \t\t})\n \n \t\tg.It(\"returns file stat information\", func() {\n@@ -108,14 +106,14 @@ func TestFilesystem_Openfile(t *testing.T) {\n \t\t})\n \n \t\tg.AfterEach(func() {\n-\t\t\trfs.reset()\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }\n \n func TestFilesystem_Writefile(t *testing.T) {\n \tg := Goblin(t)\n-\tfs, rfs := NewFs()\n+\tfs, _ := NewFs()\n \n \tg.Describe(\"Open and WriteFile\", func() {\n \t\tbuf := &bytes.Buffer{}\n@@ -125,22 +123,22 @@ func TestFilesystem_Writefile(t *testing.T) {\n \t\tg.It(\"can create a new file\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n \n-\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n+\t\t\tg.Assert(fs.CachedUsage()).Equal(int64(0))\n \n-\t\t\terr := fs.Writefile(\"test.txt\", r)\n+\t\t\terr := fs.Write(\"test.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\tf, _, err := fs.File(\"test.txt\")\n \t\t\tg.Assert(err).IsNil()\n \t\t\tdefer f.Close()\n \t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n-\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(r.Size())\n+\t\t\tg.Assert(fs.CachedUsage()).Equal(r.Size())\n \t\t})\n \n \t\tg.It(\"can create a new file inside a nested directory with leading slash\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n \n-\t\t\terr := fs.Writefile(\"/some/nested/test.txt\", r)\n+\t\t\terr := fs.Write(\"/some/nested/test.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\tf, _, err := fs.File(\"/some/nested/test.txt\")\n@@ -152,7 +150,7 @@ func TestFilesystem_Writefile(t *testing.T) {\n \t\tg.It(\"can create a new file inside a nested directory without a trailing slash\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n \n-\t\t\terr := fs.Writefile(\"some/../foo/bar/test.txt\", r)\n+\t\t\terr := fs.Write(\"some/../foo/bar/test.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\tf, _, err := fs.File(\"foo/bar/test.txt\")\n@@ -164,32 +162,32 @@ func TestFilesystem_Writefile(t *testing.T) {\n \t\tg.It(\"cannot create a file outside the root directory\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n \n-\t\t\terr := fs.Writefile(\"/some/../foo/../../test.txt\", r)\n+\t\t\terr := fs.Write(\"/some/../foo/../../test.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"cannot write a file that exceeds the disk limits\", func() {\n-\t\t\tatomic.StoreInt64(&fs.diskLimit, 1024)\n+\t\t\tfs.SetDiskLimit(1024)\n \n \t\t\tb := make([]byte, 1025)\n \t\t\t_, err := rand.Read(b)\n \t\t\tg.Assert(err).IsNil()\n \t\t\tg.Assert(len(b)).Equal(1025)\n \n \t\t\tr := bytes.NewReader(b)\n-\t\t\terr = fs.Writefile(\"test.txt\", r)\n+\t\t\terr = fs.Write(\"test.txt\", r, int64(len(b)), 0o644)\n \t\t\tg.Assert(err).IsNotNil()\n \t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue()\n \t\t})\n \n \t\tg.It(\"truncates the file when writing new contents\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"original data\"))\n-\t\t\terr := fs.Writefile(\"test.txt\", r)\n+\t\t\terr := fs.Write(\"test.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\tr = bytes.NewReader([]byte(\"new data\"))\n-\t\t\terr = fs.Writefile(\"test.txt\", r)\n+\t\t\terr = fs.Write(\"test.txt\", r, r.Size(), 0o644)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\tf, _, err := fs.File(\"test.txt\")\n@@ -200,10 +198,7 @@ func TestFilesystem_Writefile(t *testing.T) {\n \n \t\tg.AfterEach(func() {\n \t\t\tbuf.Truncate(0)\n-\t\t\trfs.reset()\n-\n-\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n-\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }\n@@ -236,17 +231,17 @@ func TestFilesystem_CreateDirectory(t *testing.T) {\n \t\tg.It(\"should not allow the creation of directories outside the root\", func() {\n \t\t\terr := fs.CreateDirectory(\"test\", \"e/../../something\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"should not increment the disk usage\", func() {\n \t\t\terr := fs.CreateDirectory(\"test\", \"/\")\n \t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n+\t\t\tg.Assert(fs.CachedUsage()).Equal(int64(0))\n \t\t})\n \n \t\tg.AfterEach(func() {\n-\t\t\trfs.reset()\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }\n@@ -268,33 +263,33 @@ func TestFilesystem_Rename(t *testing.T) {\n \n \t\t\terr = fs.Rename(\"source.txt\", \"target.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrExist)).IsTrue(\"err is not ErrExist\")\n \t\t})\n \n \t\tg.It(\"returns an error if the final destination is the root directory\", func() {\n \t\t\terr := fs.Rename(\"source.txt\", \"/\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"returns an error if the source destination is the root directory\", func() {\n-\t\t\terr := fs.Rename(\"source.txt\", \"/\")\n+\t\t\terr := fs.Rename(\"/\", \"target.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"does not allow renaming to a location outside the root\", func() {\n \t\t\terr := fs.Rename(\"source.txt\", \"../target.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"does not allow renaming from a location outside the root\", func() {\n \t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"taget content\")\n \n \t\t\terr = fs.Rename(\"/../ext-source.txt\", \"target.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"allows a file to be renamed\", func() {\n@@ -303,7 +298,7 @@ func TestFilesystem_Rename(t *testing.T) {\n \n \t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \n \t\t\tst, err := rfs.StatServerFile(\"target.txt\")\n \t\t\tg.Assert(err).IsNil()\n@@ -320,7 +315,7 @@ func TestFilesystem_Rename(t *testing.T) {\n \n \t\t\t_, err = rfs.StatServerFile(\"source_dir\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \n \t\t\tst, err := rfs.StatServerFile(\"target_dir\")\n \t\t\tg.Assert(err).IsNil()\n@@ -330,7 +325,7 @@ func TestFilesystem_Rename(t *testing.T) {\n \t\tg.It(\"returns an error if the source does not exist\", func() {\n \t\t\terr := fs.Rename(\"missing.txt\", \"target.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \t\t})\n \n \t\tg.It(\"creates directories if they are missing\", func() {\n@@ -343,7 +338,7 @@ func TestFilesystem_Rename(t *testing.T) {\n \t\t})\n \n \t\tg.AfterEach(func() {\n-\t\t\trfs.reset()\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }\n@@ -358,54 +353,54 @@ func TestFilesystem_Copy(t *testing.T) {\n \t\t\t\tpanic(err)\n \t\t\t}\n \n-\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")))\n+\t\t\tfs.unixFS.SetUsage(int64(utf8.RuneCountInString(\"test content\")))\n \t\t})\n \n \t\tg.It(\"should return an error if the source does not exist\", func() {\n \t\t\terr := fs.Copy(\"foo.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \t\t})\n \n \t\tg.It(\"should return an error if the source is outside the root\", func() {\n \t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"text content\")\n \n \t\t\terr = fs.Copy(\"../ext-source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"should return an error if the source directory is outside the root\", func() {\n-\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/nested/in/dir\"), 0o755)\n+\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"nested/in/dir\"), 0o755)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\terr = rfs.CreateServerFileFromString(\"/../nested/in/dir/ext-source.txt\", \"external content\")\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\terr = fs.Copy(\"../nested/in/dir/ext-source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \n \t\t\terr = fs.Copy(\"nested/in/../../../nested/in/dir/ext-source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"should return an error if the source is a directory\", func() {\n-\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"/server/dir\"), 0o755)\n+\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"server/dir\"), 0o755)\n \t\t\tg.Assert(err).IsNil()\n \n \t\t\terr = fs.Copy(\"dir\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \t\t})\n \n \t\tg.It(\"should return an error if there is not space to copy the file\", func() {\n-\t\t\tatomic.StoreInt64(&fs.diskLimit, 2)\n+\t\t\tfs.SetDiskLimit(2)\n \n \t\t\terr := fs.Copy(\"source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue()\n+\t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue(\"err is not ErrCodeDiskSpace\")\n \t\t})\n \n \t\tg.It(\"should create a copy of the file and increment the disk used\", func() {\n@@ -433,7 +428,7 @@ func TestFilesystem_Copy(t *testing.T) {\n \t\t\t\tg.Assert(err).IsNil()\n \t\t\t}\n \n-\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(utf8.RuneCountInString(\"test content\")) * 3)\n+\t\t\tg.Assert(fs.CachedUsage()).Equal(int64(utf8.RuneCountInString(\"test content\")) * 3)\n \t\t})\n \n \t\tg.It(\"should create a copy inside of a directory\", func() {\n@@ -454,10 +449,7 @@ func TestFilesystem_Copy(t *testing.T) {\n \t\t})\n \n \t\tg.AfterEach(func() {\n-\t\t\trfs.reset()\n-\n-\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n-\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }\n@@ -472,21 +464,21 @@ func TestFilesystem_Delete(t *testing.T) {\n \t\t\t\tpanic(err)\n \t\t\t}\n \n-\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")))\n+\t\t\tfs.unixFS.SetUsage(int64(utf8.RuneCountInString(\"test content\")))\n \t\t})\n \n \t\tg.It(\"does not delete files outside the root directory\", func() {\n \t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"external content\")\n \n \t\t\terr = fs.Delete(\"../ext-source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"does not allow the deletion of the root directory\", func() {\n \t\t\terr := fs.Delete(\"/\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(err.Error()).Equal(\"cannot delete root server directory\")\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"does not return an error if the target does not exist\", func() {\n@@ -504,9 +496,9 @@ func TestFilesystem_Delete(t *testing.T) {\n \n \t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \n-\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n+\t\t\tg.Assert(fs.CachedUsage()).Equal(int64(0))\n \t\t})\n \n \t\tg.It(\"deletes all items inside a directory if the directory is deleted\", func() {\n@@ -524,16 +516,16 @@ func TestFilesystem_Delete(t *testing.T) {\n \t\t\t\tg.Assert(err).IsNil()\n \t\t\t}\n \n-\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")*3))\n+\t\t\tfs.unixFS.SetUsage(int64(utf8.RuneCountInString(\"test content\") * 3))\n \n \t\t\terr = fs.Delete(\"foo\")\n \t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n+\t\t\tg.Assert(fs.unixFS.Usage()).Equal(int64(0))\n \n \t\t\tfor _, s := range sources {\n \t\t\t\t_, err = rfs.StatServerFile(s)\n \t\t\t\tg.Assert(err).IsNotNil()\n-\t\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \t\t\t}\n \t\t})\n \n@@ -589,7 +581,7 @@ func TestFilesystem_Delete(t *testing.T) {\n \t\t\t// Delete a file inside the symlinked directory.\n \t\t\terr = fs.Delete(\"symlink/source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \n \t\t\t// Ensure the file outside the root directory still exists.\n \t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"foo/source.txt\"))\n@@ -608,14 +600,11 @@ func TestFilesystem_Delete(t *testing.T) {\n \t\t\t// Delete a file inside the symlinked directory.\n \t\t\terr = fs.Delete(\"symlink/source.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.AfterEach(func() {\n-\t\t\trfs.reset()\n-\n-\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n-\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n+\t\t\t_ = fs.TruncateRootDirectory()\n \t\t})\n \t})\n }"
        },
        {
          "filename": "server/filesystem/path.go",
          "status": "modified",
          "additions": 7,
          "deletions": 98,
          "patch": "@@ -1,71 +1,28 @@\n package filesystem\n \n import (\n-\t\"context\"\n-\tiofs \"io/fs\"\n-\t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n-\t\"sync\"\n \n \t\"emperror.dev/errors\"\n-\t\"golang.org/x/sync/errgroup\"\n )\n \n // Checks if the given file or path is in the server's file denylist. If so, an Error\n // is returned, otherwise nil is returned.\n func (fs *Filesystem) IsIgnored(paths ...string) error {\n \tfor _, p := range paths {\n-\t\tsp, err := fs.SafePath(p)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif fs.denylist.MatchesPath(sp) {\n-\t\t\treturn errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: sp})\n+\t\t//sp, err := fs.SafePath(p)\n+\t\t//if err != nil {\n+\t\t//\treturn err\n+\t\t//}\n+\t\t// TODO: update logic to use unixFS\n+\t\tif fs.denylist.MatchesPath(p) {\n+\t\t\treturn errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: p})\n \t\t}\n \t}\n \treturn nil\n }\n \n-// Normalizes a directory being passed in to ensure the user is not able to escape\n-// from their data directory. After normalization if the directory is still within their home\n-// path it is returned. If they managed to \"escape\" an error will be returned.\n-//\n-// This logic is actually copied over from the SFTP server code. Ideally that eventually\n-// either gets ported into this application, or is able to make use of this package.\n-func (fs *Filesystem) SafePath(p string) (string, error) {\n-\t// Start with a cleaned up path before checking the more complex bits.\n-\tr := fs.unsafeFilePath(p)\n-\n-\t// At the same time, evaluate the symlink status and determine where this file or folder\n-\t// is truly pointing to.\n-\tep, err := filepath.EvalSymlinks(r)\n-\tif err != nil && !os.IsNotExist(err) {\n-\t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")\n-\t} else if os.IsNotExist(err) {\n-\t\t// The target of one of the symlinks (EvalSymlinks is recursive) does not exist.\n-\t\t// So we get what target path does not exist and check if it's within the data\n-\t\t// directory. If it is, we return the original path, otherwise we return an error.\n-\t\tpErr, ok := err.(*iofs.PathError)\n-\t\tif !ok {\n-\t\t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")\n-\t\t}\n-\t\tep = pErr.Path\n-\t}\n-\n-\t// If the requested directory from EvalSymlinks begins with the server root directory go\n-\t// ahead and return it. If not we'll return an error which will block any further action\n-\t// on the file.\n-\tif fs.unsafeIsInDataDirectory(ep) {\n-\t\t// Returning the original path here instead of the resolved path ensures that\n-\t\t// whatever the user is trying to do will work as expected. If we returned the\n-\t\t// resolved path, the user would be unable to know that it is in fact a symlink.\n-\t\treturn r, nil\n-\t}\n-\n-\treturn \"\", NewBadPathResolution(p, r)\n-}\n-\n // Generate a path to the file by cleaning it up and appending the root server path to it. This\n // DOES NOT guarantee that the file resolves within the server data directory. You'll want to use\n // the fs.unsafeIsInDataDirectory(p) function to confirm.\n@@ -84,51 +41,3 @@ func (fs *Filesystem) unsafeFilePath(p string) string {\n func (fs *Filesystem) unsafeIsInDataDirectory(p string) bool {\n \treturn strings.HasPrefix(strings.TrimSuffix(p, \"/\")+\"/\", strings.TrimSuffix(fs.Path(), \"/\")+\"/\")\n }\n-\n-// Executes the fs.SafePath function in parallel against an array of paths. If any of the calls\n-// fails an error will be returned.\n-func (fs *Filesystem) ParallelSafePath(paths []string) ([]string, error) {\n-\tvar cleaned []string\n-\n-\t// Simple locker function to avoid racy appends to the array of cleaned paths.\n-\tm := new(sync.Mutex)\n-\tpush := func(c string) {\n-\t\tm.Lock()\n-\t\tcleaned = append(cleaned, c)\n-\t\tm.Unlock()\n-\t}\n-\n-\t// Create an error group that we can use to run processes in parallel while retaining\n-\t// the ability to cancel the entire process immediately should any of it fail.\n-\tg, ctx := errgroup.WithContext(context.Background())\n-\n-\t// Iterate over all of the paths and generate a cleaned path, if there is an error for any\n-\t// of the files, abort the process.\n-\tfor _, p := range paths {\n-\t\t// Create copy so we can use it within the goroutine correctly.\n-\t\tpi := p\n-\n-\t\t// Recursively call this function to continue digging through the directory tree within\n-\t\t// a separate goroutine. If the context is canceled abort this process.\n-\t\tg.Go(func() error {\n-\t\t\tselect {\n-\t\t\tcase <-ctx.Done():\n-\t\t\t\treturn ctx.Err()\n-\t\t\tdefault:\n-\t\t\t\t// If the callback returns true, go ahead and keep walking deeper. This allows\n-\t\t\t\t// us to programmatically continue deeper into directories, or stop digging\n-\t\t\t\t// if that pathway knows it needs nothing else.\n-\t\t\t\tif c, err := fs.SafePath(pi); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t} else {\n-\t\t\t\t\tpush(c)\n-\t\t\t\t}\n-\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t})\n-\t}\n-\n-\t// Block until all of the routines finish and have returned a value.\n-\treturn cleaned, g.Wait()\n-}"
        },
        {
          "filename": "server/filesystem/path_test.go",
          "status": "modified",
          "additions": 35,
          "deletions": 108,
          "patch": "@@ -8,6 +8,8 @@ import (\n \n \t\"emperror.dev/errors\"\n \t. \"github.com/franela/goblin\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n func TestFilesystem_Path(t *testing.T) {\n@@ -21,80 +23,6 @@ func TestFilesystem_Path(t *testing.T) {\n \t})\n }\n \n-func TestFilesystem_SafePath(t *testing.T) {\n-\tg := Goblin(t)\n-\tfs, rfs := NewFs()\n-\tprefix := filepath.Join(rfs.root, \"/server\")\n-\n-\tg.Describe(\"SafePath\", func() {\n-\t\tg.It(\"returns a cleaned path to a given file\", func() {\n-\t\t\tp, err := fs.SafePath(\"test.txt\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n-\n-\t\t\tp, err = fs.SafePath(\"/test.txt\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n-\n-\t\t\tp, err = fs.SafePath(\"./test.txt\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n-\n-\t\t\tp, err = fs.SafePath(\"/foo/../test.txt\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n-\n-\t\t\tp, err = fs.SafePath(\"/foo/bar\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar\")\n-\t\t})\n-\n-\t\tg.It(\"handles root directory access\", func() {\n-\t\t\tp, err := fs.SafePath(\"/\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix)\n-\n-\t\t\tp, err = fs.SafePath(\"\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix)\n-\t\t})\n-\n-\t\tg.It(\"removes trailing slashes from paths\", func() {\n-\t\t\tp, err := fs.SafePath(\"/foo/bar/\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar\")\n-\t\t})\n-\n-\t\tg.It(\"handles deeply nested directories that do not exist\", func() {\n-\t\t\tp, err := fs.SafePath(\"/foo/bar/baz/quaz/../../ducks/testing.txt\")\n-\t\t\tg.Assert(err).IsNil()\n-\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar/ducks/testing.txt\")\n-\t\t})\n-\n-\t\tg.It(\"blocks access to files outside the root directory\", func() {\n-\t\t\tp, err := fs.SafePath(\"../test.txt\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n-\t\t\tg.Assert(p).Equal(\"\")\n-\n-\t\t\tp, err = fs.SafePath(\"/../test.txt\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n-\t\t\tg.Assert(p).Equal(\"\")\n-\n-\t\t\tp, err = fs.SafePath(\"./foo/../../test.txt\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n-\t\t\tg.Assert(p).Equal(\"\")\n-\n-\t\t\tp, err = fs.SafePath(\"..\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n-\t\t\tg.Assert(p).Equal(\"\")\n-\t\t})\n-\t})\n-}\n-\n // We test against accessing files outside the root directory in the tests, however it\n // is still possible for someone to mess up and not properly use this safe path call. In\n // order to truly confirm this, we'll try to pass in a symlinked malicious file to all of\n@@ -133,95 +61,94 @@ func TestFilesystem_Blocks_Symlinks(t *testing.T) {\n \n \t\t\terr := fs.Writefile(\"symlinked.txt\", r)\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"cannot write to a non-existent file symlinked outside the root\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"testing what the fuck\"))\n \n \t\t\terr := fs.Writefile(\"symlinked_does_not_exist.txt\", r)\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"cannot write to chained symlinks with target that does not exist outside the root\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"testing what the fuck\"))\n \n \t\t\terr := fs.Writefile(\"symlinked_does_not_exist2.txt\", r)\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrBadPathResolution)).IsTrue(\"err is not ErrBadPathResolution\")\n \t\t})\n \n \t\tg.It(\"cannot write a file to a directory symlinked outside the root\", func() {\n \t\t\tr := bytes.NewReader([]byte(\"testing\"))\n \n \t\t\terr := fs.Writefile(\"external_dir/foo.txt\", r)\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotDirectory)).IsTrue(\"err is not ErrNotDirectory\")\n \t\t})\n \t})\n \n \tg.Describe(\"CreateDirectory\", func() {\n \t\tg.It(\"cannot create a directory outside the root\", func() {\n \t\t\terr := fs.CreateDirectory(\"my_dir\", \"external_dir\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotDirectory)).IsTrue(\"err is not ErrNotDirectory\")\n \t\t})\n \n \t\tg.It(\"cannot create a nested directory outside the root\", func() {\n \t\t\terr := fs.CreateDirectory(\"my/nested/dir\", \"external_dir/foo/bar\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotDirectory)).IsTrue(\"err is not ErrNotDirectory\")\n \t\t})\n \n \t\tg.It(\"cannot create a nested directory outside the root\", func() {\n \t\t\terr := fs.CreateDirectory(\"my/nested/dir\", \"external_dir/server\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotDirectory)).IsTrue(\"err is not ErrNotDirectory\")\n \t\t})\n \t})\n \n \tg.Describe(\"Rename\", func() {\n-\t\tg.It(\"cannot rename a file symlinked outside the directory root\", func() {\n-\t\t\terr := fs.Rename(\"symlinked.txt\", \"foo.txt\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\tg.It(\"can rename a file symlinked outside the directory root\", func() {\n+\t\t\t_, err := os.Lstat(filepath.Join(rfs.root, \"server\", \"symlinked.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n+\t\t\terr = fs.Rename(\"symlinked.txt\", \"foo.txt\")\n+\t\t\tg.Assert(err).IsNil()\n+\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"server\", \"foo.txt\"))\n+\t\t\tg.Assert(err).IsNil()\n \t\t})\n \n-\t\tg.It(\"cannot rename a symlinked directory outside the root\", func() {\n-\t\t\terr := fs.Rename(\"external_dir\", \"foo\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\tg.It(\"can rename a symlinked directory outside the root\", func() {\n+\t\t\t_, err := os.Lstat(filepath.Join(rfs.root, \"server\", \"external_dir\"))\n+\t\t\tg.Assert(err).IsNil()\n+\t\t\terr = fs.Rename(\"external_dir\", \"foo\")\n+\t\t\tg.Assert(err).IsNil()\n+\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"server\", \"foo\"))\n+\t\t\tg.Assert(err).IsNil()\n \t\t})\n \n \t\tg.It(\"cannot rename a file to a location outside the directory root\", func() {\n-\t\t\trfs.CreateServerFileFromString(\"my_file.txt\", \"internal content\")\n+\t\t\t_ = rfs.CreateServerFileFromString(\"my_file.txt\", \"internal content\")\n+\t\t\tt.Log(rfs.root)\n \n-\t\t\terr := fs.Rename(\"my_file.txt\", \"external_dir/my_file.txt\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n-\t\t})\n-\t})\n+\t\t\tst, err := os.Lstat(filepath.Join(rfs.root, \"server\", \"foo\"))\n+\t\t\tg.Assert(err).IsNil()\n+\t\t\tg.Assert(st.Mode()&ufs.ModeSymlink != 0).IsTrue()\n \n-\tg.Describe(\"Chown\", func() {\n-\t\tg.It(\"cannot chown a file symlinked outside the directory root\", func() {\n-\t\t\terr := fs.Chown(\"symlinked.txt\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n-\t\t})\n+\t\t\terr = fs.Rename(\"my_file.txt\", \"foo/my_file.txt\")\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotDirectory)).IsTrue()\n \n-\t\tg.It(\"cannot chown a directory symlinked outside the directory root\", func() {\n-\t\t\terr := fs.Chown(\"external_dir\")\n-\t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tst, err = os.Lstat(filepath.Join(rfs.root, \"malicious_dir\", \"my_file.txt\"))\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue()\n \t\t})\n \t})\n \n \tg.Describe(\"Copy\", func() {\n \t\tg.It(\"cannot copy a file symlinked outside the directory root\", func() {\n \t\t\terr := fs.Copy(\"symlinked.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \t\t})\n \t})\n \n@@ -235,9 +162,9 @@ func TestFilesystem_Blocks_Symlinks(t *testing.T) {\n \n \t\t\t_, err = rfs.StatServerFile(\"symlinked.txt\")\n \t\t\tg.Assert(err).IsNotNil()\n-\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n+\t\t\tg.Assert(errors.Is(err, ufs.ErrNotExist)).IsTrue(\"err is not ErrNotExist\")\n \t\t})\n \t})\n \n-\trfs.reset()\n+\t_ = fs.TruncateRootDirectory()\n }"
        },
        {
          "filename": "server/filesystem/stat.go",
          "status": "modified",
          "additions": 28,
          "deletions": 21,
          "patch": "@@ -1,16 +1,18 @@\n package filesystem\n \n import (\n-\t\"os\"\n+\t\"encoding/json\"\n+\t\"io\"\n \t\"strconv\"\n \t\"time\"\n \n \t\"github.com/gabriel-vasile/mimetype\"\n-\t\"github.com/goccy/go-json\"\n+\n+\t\"github.com/pterodactyl/wings/internal/ufs\"\n )\n \n type Stat struct {\n-\tos.FileInfo\n+\tufs.FileInfo\n \tMimetype string\n }\n \n@@ -31,47 +33,52 @@ func (s *Stat) MarshalJSON() ([]byte, error) {\n \t\tCreated:  s.CTime().Format(time.RFC3339),\n \t\tModified: s.ModTime().Format(time.RFC3339),\n \t\tMode:     s.Mode().String(),\n-\t\t// Using `&os.ModePerm` on the file's mode will cause the mode to only have the permission values, and nothing else.\n-\t\tModeBits:  strconv.FormatUint(uint64(s.Mode()&os.ModePerm), 8),\n+\t\t// Using `&ModePerm` on the file's mode will cause the mode to only have the permission values, and nothing else.\n+\t\tModeBits:  strconv.FormatUint(uint64(s.Mode()&ufs.ModePerm), 8),\n \t\tSize:      s.Size(),\n \t\tDirectory: s.IsDir(),\n \t\tFile:      !s.IsDir(),\n-\t\tSymlink:   s.Mode().Perm()&os.ModeSymlink != 0,\n+\t\tSymlink:   s.Mode().Perm()&ufs.ModeSymlink != 0,\n \t\tMime:      s.Mimetype,\n \t})\n }\n \n-// Stat stats a file or folder and returns the base stat object from go along\n-// with the MIME data that can be used for editing files.\n-func (fs *Filesystem) Stat(p string) (Stat, error) {\n-\tcleaned, err := fs.SafePath(p)\n-\tif err != nil {\n-\t\treturn Stat{}, err\n-\t}\n-\treturn fs.unsafeStat(cleaned)\n-}\n-\n-func (fs *Filesystem) unsafeStat(p string) (Stat, error) {\n-\ts, err := os.Stat(p)\n+func statFromFile(f ufs.File) (Stat, error) {\n+\ts, err := f.Stat()\n \tif err != nil {\n \t\treturn Stat{}, err\n \t}\n-\n \tvar m *mimetype.MIME\n \tif !s.IsDir() {\n-\t\tm, err = mimetype.DetectFile(p)\n+\t\tm, err = mimetype.DetectReader(f)\n \t\tif err != nil {\n \t\t\treturn Stat{}, err\n \t\t}\n+\t\tif _, err := f.Seek(0, io.SeekStart); err != nil {\n+\t\t\treturn Stat{}, err\n+\t\t}\n \t}\n-\n \tst := Stat{\n \t\tFileInfo: s,\n \t\tMimetype: \"inode/directory\",\n \t}\n \tif m != nil {\n \t\tst.Mimetype = m.String()\n \t}\n+\treturn st, nil\n+}\n \n+// Stat stats a file or folder and returns the base stat object from go along\n+// with the MIME data that can be used for editing files.\n+func (fs *Filesystem) Stat(p string) (Stat, error) {\n+\tf, err := fs.unixFS.Open(p)\n+\tif err != nil {\n+\t\treturn Stat{}, err\n+\t}\n+\tdefer f.Close()\n+\tst, err := statFromFile(f)\n+\tif err != nil {\n+\t\treturn Stat{}, err\n+\t}\n \treturn st, nil\n }"
        },
        {
          "filename": "server/filesystem/stat_darwin.go",
          "status": "removed",
          "additions": 0,
          "deletions": 13,
          "patch": "@@ -1,13 +0,0 @@\n-package filesystem\n-\n-import (\n-\t\"syscall\"\n-\t\"time\"\n-)\n-\n-// CTime returns the time that the file/folder was created.\n-func (s *Stat) CTime() time.Time {\n-\tst := s.Sys().(*syscall.Stat_t)\n-\n-\treturn time.Unix(st.Ctimespec.Sec, st.Ctimespec.Nsec)\n-}"
        },
        {
          "filename": "server/filesystem/stat_linux.go",
          "status": "modified",
          "additions": 15,
          "deletions": 5,
          "patch": "@@ -3,12 +3,22 @@ package filesystem\n import (\n \t\"syscall\"\n \t\"time\"\n+\n+\t\"golang.org/x/sys/unix\"\n )\n \n-// Returns the time that the file/folder was created.\n+// CTime returns the time that the file/folder was created.\n+//\n+// TODO: remove. Ctim is not actually ever been correct and doesn't actually\n+// return the creation time.\n func (s *Stat) CTime() time.Time {\n-\tst := s.Sys().(*syscall.Stat_t)\n-\n-\t// Do not remove these \"redundant\" type-casts, they are required for 32-bit builds to work.\n-\treturn time.Unix(int64(st.Ctim.Sec), int64(st.Ctim.Nsec))\n+\tif st, ok := s.Sys().(*unix.Stat_t); ok {\n+\t\t// Do not remove these \"redundant\" type-casts, they are required for 32-bit builds to work.\n+\t\treturn time.Unix(int64(st.Ctim.Sec), int64(st.Ctim.Nsec))\n+\t}\n+\tif st, ok := s.Sys().(*syscall.Stat_t); ok {\n+\t\t// Do not remove these \"redundant\" type-casts, they are required for 32-bit builds to work.\n+\t\treturn time.Unix(int64(st.Ctim.Sec), int64(st.Ctim.Nsec))\n+\t}\n+\treturn time.Time{}\n }"
        },
        {
          "filename": "server/filesystem/stat_windows.go",
          "status": "removed",
          "additions": 0,
          "deletions": 12,
          "patch": "@@ -1,12 +0,0 @@\n-package filesystem\n-\n-import (\n-\t\"time\"\n-)\n-\n-// On linux systems this will return the time that the file was created.\n-// However, I have no idea how to do this on windows, so we're skipping it\n-// for right now.\n-func (s *Stat) CTime() time.Time {\n-\treturn s.ModTime()\n-}"
        },
        {
          "filename": "server/install.go",
          "status": "modified",
          "additions": 2,
          "deletions": 15,
          "patch": "@@ -2,7 +2,6 @@ package server\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"context\"\n \t\"html/template\"\n \t\"io\"\n@@ -218,30 +217,18 @@ func (ip *InstallationProcess) tempDir() string {\n // can be properly mounted into the installation container and then executed.\n func (ip *InstallationProcess) writeScriptToDisk() error {\n \t// Make sure the temp directory root exists before trying to make a directory within it. The\n-\t// ioutil.TempDir call expects this base to exist, it won't create it for you.\n+\t// os.TempDir call expects this base to exist, it won't create it for you.\n \tif err := os.MkdirAll(ip.tempDir(), 0o700); err != nil {\n \t\treturn errors.WithMessage(err, \"could not create temporary directory for install process\")\n \t}\n-\n \tf, err := os.OpenFile(filepath.Join(ip.tempDir(), \"install.sh\"), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o644)\n \tif err != nil {\n \t\treturn errors.WithMessage(err, \"failed to write server installation script to disk before mount\")\n \t}\n \tdefer f.Close()\n-\n-\tw := bufio.NewWriter(f)\n-\n-\tscanner := bufio.NewScanner(bytes.NewReader([]byte(ip.Script.Script)))\n-\tfor scanner.Scan() {\n-\t\tw.WriteString(scanner.Text() + \"\\n\")\n-\t}\n-\n-\tif err := scanner.Err(); err != nil {\n+\tif _, err := io.Copy(f, strings.NewReader(strings.ReplaceAll(ip.Script.Script, \"\\r\\n\", \"\\n\"))); err != nil {\n \t\treturn err\n \t}\n-\n-\tw.Flush()\n-\n \treturn nil\n }\n "
        },
        {
          "filename": "server/manager.go",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -196,7 +196,10 @@ func (m *Manager) InitServer(data remote.ServerConfigurationResponse) (*Server,\n \t\treturn nil, errors.WithStackIf(err)\n \t}\n \n-\ts.fs = filesystem.New(filepath.Join(config.Get().System.Data, s.ID()), s.DiskSpace(), s.Config().Egg.FileDenylist)\n+\ts.fs, err = filesystem.New(filepath.Join(config.Get().System.Data, s.ID()), s.DiskSpace(), s.Config().Egg.FileDenylist)\n+\tif err != nil {\n+\t\treturn nil, errors.WithStackIf(err)\n+\t}\n \n \t// Right now we only support a Docker based environment, so I'm going to hard code\n \t// this logic in. When we're ready to support other environment we'll need to make"
        },
        {
          "filename": "server/transfer/archive.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -35,8 +35,8 @@ type Archive struct {\n func NewArchive(t *Transfer, size uint64) *Archive {\n \treturn &Archive{\n \t\tarchive: &filesystem.Archive{\n-\t\t\tBasePath: t.Server.Filesystem().Path(),\n-\t\t\tProgress: progress.NewProgress(size),\n+\t\t\tFilesystem: t.Server.Filesystem(),\n+\t\t\tProgress:   progress.NewProgress(size),\n \t\t},\n \t}\n }"
        },
        {
          "filename": "sftp/handler.go",
          "status": "modified",
          "additions": 5,
          "deletions": 18,
          "patch": "@@ -2,7 +2,6 @@ package sftp\n \n import (\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n@@ -122,7 +121,7 @@ func (h *Handler) Filewrite(request *sftp.Request) (io.WriterAt, error) {\n \tif !h.can(permission) {\n \t\treturn nil, sftp.ErrSSHFxPermissionDenied\n \t}\n-\tf, err := h.fs.Touch(request.Filepath, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n+\tf, err := h.fs.Touch(request.Filepath, os.O_RDWR|os.O_TRUNC)\n \tif err != nil {\n \t\tl.WithField(\"flags\", request.Flags).WithField(\"error\", err).Error(\"failed to open existing file on system\")\n \t\treturn nil, sftp.ErrSSHFxFailure\n@@ -220,16 +219,8 @@ func (h *Handler) Filecmd(request *sftp.Request) error {\n \t\tif !h.can(PermissionFileCreate) {\n \t\t\treturn sftp.ErrSSHFxPermissionDenied\n \t\t}\n-\t\tsource, err := h.fs.SafePath(request.Filepath)\n-\t\tif err != nil {\n-\t\t\treturn sftp.ErrSSHFxNoSuchFile\n-\t\t}\n-\t\ttarget, err := h.fs.SafePath(request.Target)\n-\t\tif err != nil {\n-\t\t\treturn sftp.ErrSSHFxNoSuchFile\n-\t\t}\n-\t\tif err := os.Symlink(source, target); err != nil {\n-\t\t\tl.WithField(\"target\", target).WithField(\"error\", err).Error(\"failed to create symlink\")\n+\t\tif err := h.fs.Symlink(request.Filepath, request.Target); err != nil {\n+\t\t\tl.WithField(\"target\", request.Target).WithField(\"error\", err).Error(\"failed to create symlink\")\n \t\t\treturn sftp.ErrSSHFxFailure\n \t\t}\n \t\tbreak\n@@ -274,16 +265,12 @@ func (h *Handler) Filelist(request *sftp.Request) (sftp.ListerAt, error) {\n \n \tswitch request.Method {\n \tcase \"List\":\n-\t\tp, err := h.fs.SafePath(request.Filepath)\n-\t\tif err != nil {\n-\t\t\treturn nil, sftp.ErrSSHFxNoSuchFile\n-\t\t}\n-\t\tfiles, err := ioutil.ReadDir(p)\n+\t\tentries, err := h.fs.ReadDirStat(request.Filepath)\n \t\tif err != nil {\n \t\t\th.logger.WithField(\"source\", request.Filepath).WithField(\"error\", err).Error(\"error while listing directory\")\n \t\t\treturn nil, sftp.ErrSSHFxFailure\n \t\t}\n-\t\treturn ListerAt(files), nil\n+\t\treturn ListerAt(entries), nil\n \tcase \"Stat\":\n \t\tst, err := h.fs.Stat(request.Filepath)\n \t\tif err != nil {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 11,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c6c235dbc07341d5f50606819624a2e4770648a7",
            "date": "2025-01-12T22:28:46Z",
            "author_login": "matthewpi"
          },
          {
            "sha": "a55277da471a7b559e7fa45bb07024b7629e7ba2",
            "date": "2025-01-12T21:45:16Z",
            "author_login": "matthewpi"
          },
          {
            "sha": "76a9f6dc5a3396a8e3b71fa1ebe2dcfa3ad93b3c",
            "date": "2025-01-12T21:25:34Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0e96ef3edffe9978a13553b907899fdfe30d80c6",
            "date": "2025-01-12T21:25:19Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1dee350268f632045203cf892f186e9c45f55a84",
            "date": "2025-01-12T21:22:18Z",
            "author_login": "matthewpi"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-22",
    "description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-13T21:15:59.590",
    "last_modified": "2024-11-21T09:03:51.810",
    "fix_date": "2024-03-13T03:44:55Z"
  },
  "references": [
    {
      "url": "https://github.com/pterodactyl/wings/commit/d1c0ca526007113a0f74f56eba99511b4e989287",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/commit/d1c0ca526007113a0f74f56eba99511b4e989287",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:38.492809",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wings",
    "owner": "pterodactyl",
    "created_at": "2017-05-17T10:49:28Z",
    "updated_at": "2025-01-13T06:01:10Z",
    "pushed_at": "2025-01-12T22:32:13Z",
    "size": 3463,
    "stars": 769,
    "forks": 335,
    "open_issues": 18,
    "watchers": 769,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "Go": 651888,
      "Nix": 1270,
      "Makefile": 963,
      "Dockerfile": 697,
      "Shell": 10
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:17:48.763579"
  }
}