{
  "cve_id": "CVE-2024-27318",
  "github_data": {
    "repository": "onnx/onnx",
    "fix_commit": "66b7fb630903fdcf3e83b6b6d56d82e904264a20",
    "related_commits": [
      "66b7fb630903fdcf3e83b6b6d56d82e904264a20",
      "66b7fb630903fdcf3e83b6b6d56d82e904264a20"
    ],
    "patch_url": "https://github.com/onnx/onnx/commit/66b7fb630903fdcf3e83b6b6d56d82e904264a20.patch",
    "fix_commit_details": {
      "sha": "66b7fb630903fdcf3e83b6b6d56d82e904264a20",
      "commit_date": "2024-02-19T19:12:40Z",
      "author": {
        "login": "liqunfu",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix path sanitization bypass leading to arbitrary read (#5917)",
        "length": 226,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 258,
        "additions": 162,
        "deletions": 96
      },
      "files": [
        {
          "filename": "onnx/checker.cc",
          "status": "modified",
          "additions": 88,
          "deletions": 80,
          "patch": "@@ -13,7 +13,6 @@\n #include <vector>\n \n #include \"onnx/common/file_utils.h\"\n-#include \"onnx/common/path.h\"\n #include \"onnx/defs/schema.h\"\n #include \"onnx/defs/tensor_proto_util.h\"\n #include \"onnx/proto_utils.h\"\n@@ -128,85 +127,7 @@ void check_tensor(const TensorProto& tensor, const CheckerContext& ctx) {\n     for (const StringStringEntryProto& entry : tensor.external_data()) {\n       if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n         has_location = true;\n-#ifdef _WIN32\n-        auto file_path = std::filesystem::path(utf8str_to_wstring(entry.value()));\n-        if (file_path.is_absolute()) {\n-          fail_check(\n-              \"Location of external TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be a relative path, but it is an absolute path: \",\n-              entry.value());\n-        }\n-        auto relative_path = file_path.lexically_normal().make_preferred().wstring();\n-        // Check that normalized relative path contains \"..\" on Windows.\n-        if (relative_path.find(L\"..\", 0) != std::string::npos) {\n-          fail_check(\n-              \"Data of TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be file inside the \",\n-              ctx.get_model_dir(),\n-              \", but the '\",\n-              entry.value(),\n-              \"' points outside the directory\");\n-        }\n-        std::wstring data_path = path_join(utf8str_to_wstring(ctx.get_model_dir()), relative_path);\n-        struct _stat64 buff;\n-        if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {\n-          fail_check(\n-              \"Data of TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be stored in \",\n-              entry.value(),\n-              \", but it doesn't exist or is not accessible.\");\n-        }\n-#else // POSIX\n-        if (entry.value().empty()) {\n-          fail_check(\"Location of external TensorProto ( tensor name: \", tensor.name(), \") should not be empty.\");\n-        } else if (entry.value()[0] == '/') {\n-          fail_check(\n-              \"Location of external TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be a relative path, but it is an absolute path: \",\n-              entry.value());\n-        }\n-        std::string relative_path = clean_relative_path(entry.value());\n-        // Check that normalized relative path contains \"..\" on POSIX\n-        if (relative_path.find(\"..\", 0) != std::string::npos) {\n-          fail_check(\n-              \"Data of TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be file inside the \",\n-              ctx.get_model_dir(),\n-              \", but the '\",\n-              entry.value(),\n-              \"' points outside the directory\");\n-        }\n-        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n-        // use stat64 to check whether the file exists\n-#if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)\n-        struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64\n-        if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {\n-#else\n-        struct stat64 buffer; // All POSIX under glibc except APPLE and wasm have stat64\n-        if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {\n-#endif\n-          fail_check(\n-              \"Data of TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be stored in \",\n-              data_path,\n-              \", but it doesn't exist or is not accessible.\");\n-        }\n-        // Do not allow symlinks or directories.\n-        if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {\n-          fail_check(\n-              \"Data of TensorProto ( tensor name: \",\n-              tensor.name(),\n-              \") should be stored in \",\n-              data_path,\n-              \", but it is not regular file.\");\n-        }\n-#endif\n+        resolve_external_data_location(ctx.get_model_dir(), entry.value(), tensor.name());\n       }\n     }\n     if (!has_location) {\n@@ -1049,6 +970,93 @@ void check_model(const ModelProto& model, bool full_check, bool skip_opset_compa\n   }\n }\n \n+std::string resolve_external_data_location(\n+    const std::string& base_dir,\n+    const std::string& location,\n+    const std::string& tensor_name) {\n+#ifdef _WIN32\n+  auto file_path = std::filesystem::path(utf8str_to_wstring(location));\n+  if (file_path.is_absolute()) {\n+    fail_check(\n+        \"Location of external TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be a relative path, but it is an absolute path: \",\n+        location);\n+  }\n+  auto relative_path = file_path.lexically_normal().make_preferred().wstring();\n+  // Check that normalized relative path contains \"..\" on Windows.\n+  if (relative_path.find(L\"..\", 0) != std::string::npos) {\n+    fail_check(\n+        \"Data of TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be file inside the \",\n+        base_dir,\n+        \", but the '\",\n+        location,\n+        \"' points outside the directory\");\n+  }\n+  std::wstring data_path = path_join(utf8str_to_wstring(base_dir), relative_path);\n+  struct _stat64 buff;\n+  if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {\n+    fail_check(\n+        \"Data of TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be stored in \",\n+        location,\n+        \", but it doesn't exist or is not accessible.\");\n+  }\n+  return wstring_to_utf8str(data_path);\n+#else // POSIX\n+  if (location.empty()) {\n+    fail_check(\"Location of external TensorProto ( tensor name: \", tensor_name, \") should not be empty.\");\n+  } else if (location[0] == '/') {\n+    fail_check(\n+        \"Location of external TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be a relative path, but it is an absolute path: \",\n+        location);\n+  }\n+  std::string relative_path = clean_relative_path(location);\n+  // Check that normalized relative path contains \"..\" on POSIX\n+  if (relative_path.find(\"..\", 0) != std::string::npos) {\n+    fail_check(\n+        \"Data of TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be file inside the \",\n+        base_dir,\n+        \", but the '\",\n+        location,\n+        \"' points outside the directory\");\n+  }\n+  std::string data_path = path_join(base_dir, relative_path);\n+  // use stat64 to check whether the file exists\n+#if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)\n+  struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64\n+  if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {\n+#else\n+  struct stat64 buffer; // All POSIX under glibc except APPLE and wasm have stat64\n+  if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {\n+#endif\n+    fail_check(\n+        \"Data of TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be stored in \",\n+        data_path,\n+        \", but it doesn't exist or is not accessible.\");\n+  }\n+  // Do not allow symlinks or directories.\n+  if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {\n+    fail_check(\n+        \"Data of TensorProto ( tensor name: \",\n+        tensor_name,\n+        \") should be stored in \",\n+        data_path,\n+        \", but it is not regular file.\");\n+  }\n+  return data_path;\n+#endif\n+}\n+\n std::set<std::string> experimental_ops = {\n     \"ATen\",\n     \"Affine\","
        },
        {
          "filename": "onnx/checker.h",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -160,7 +160,10 @@ void check_model_local_functions(\n \n void check_model(const ModelProto& model, bool full_check = false, bool skip_opset_compatibility_check = false);\n void check_model(const std::string& model_path, bool full_check = false, bool skip_opset_compatibility_check = false);\n-\n+std::string resolve_external_data_location(\n+    const std::string& base_dir,\n+    const std::string& location,\n+    const std::string& tensor_name);\n bool check_is_experimental_op(const NodeProto& node);\n \n } // namespace checker"
        },
        {
          "filename": "onnx/common/path.h",
          "status": "modified",
          "additions": 13,
          "deletions": 2,
          "patch": "@@ -36,11 +36,22 @@ inline std::wstring utf8str_to_wstring(const std::string& utf8str) {\n   if (utf8str.size() > INT_MAX) {\n     fail_check(\"utf8str_to_wstring: string is too long for converting to wstring.\");\n   }\n-  int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), (int)utf8str.size(), NULL, 0);\n+  int size_required = MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), NULL, 0);\n   std::wstring ws_str(size_required, 0);\n-  MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), (int)utf8str.size(), &ws_str[0], size_required);\n+  MultiByteToWideChar(CP_UTF8, 0, utf8str.c_str(), static_cast<int>(utf8str.size()), &ws_str[0], size_required);\n   return ws_str;\n }\n+inline std::string wstring_to_utf8str(const std::wstring& ws_str) {\n+  if (ws_str.size() > INT_MAX) {\n+    fail_check(\"wstring_to_utf8str: string is too long for converting to UTF-8.\");\n+  }\n+  int size_required =\n+      WideCharToMultiByte(CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), NULL, 0, NULL, NULL);\n+  std::string utf8str(size_required, 0);\n+  WideCharToMultiByte(\n+      CP_UTF8, 0, ws_str.c_str(), static_cast<int>(ws_str.size()), &utf8str[0], size_required, NULL, NULL);\n+  return utf8str;\n+}\n \n #else\n std::string path_join(const std::string& origin, const std::string& append);"
        },
        {
          "filename": "onnx/cpp2py_export.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -535,6 +535,8 @@ PYBIND11_MODULE(onnx_cpp2py_export, onnx_cpp2py_export) {\n       \"full_check\"_a = false,\n       \"skip_opset_compatibility_check\"_a = false);\n \n+  checker.def(\"_resolve_external_data_location\", &checker::resolve_external_data_location);\n+\n   // Submodule `version_converter`\n   auto version_converter = onnx_cpp2py_export.def_submodule(\"version_converter\");\n   version_converter.doc() = \"VersionConverter submodule\";"
        },
        {
          "filename": "onnx/external_data_helper.py",
          "status": "modified",
          "additions": 4,
          "deletions": 11,
          "patch": "@@ -8,6 +8,7 @@\n from itertools import chain\n from typing import Callable, Iterable, Optional\n \n+import onnx.onnx_cpp2py_export.checker as c_checker\n from onnx.onnx_pb import AttributeProto, GraphProto, ModelProto, TensorProto\n \n \n@@ -38,9 +39,9 @@ def load_external_data_for_tensor(tensor: TensorProto, base_dir: str) -> None:\n         base_dir: directory that contains the external data.\n     \"\"\"\n     info = ExternalDataInfo(tensor)\n-    file_location = _sanitize_path(info.location)\n-    external_data_file_path = os.path.join(base_dir, file_location)\n-\n+    external_data_file_path = c_checker._resolve_external_data_location(  # type: ignore[attr-defined]\n+        base_dir, info.location, tensor.name\n+    )\n     with open(external_data_file_path, \"rb\") as data_file:\n         if info.offset:\n             data_file.seek(info.offset)\n@@ -254,14 +255,6 @@ def _get_attribute_tensors(onnx_model_proto: ModelProto) -> Iterable[TensorProto\n     yield from _get_attribute_tensors_from_graph(onnx_model_proto.graph)\n \n \n-def _sanitize_path(path: str) -> str:\n-    \"\"\"Remove path components which would allow traversing up a directory tree from a base path.\n-\n-    Note: This method is currently very basic and should be expanded.\n-    \"\"\"\n-    return path.lstrip(\"/.\")\n-\n-\n def _is_valid_filename(filename: str) -> bool:\n     \"\"\"Utility to check whether the provided filename is valid.\"\"\"\n     exp = re.compile('^[^<>:;,?\"*|/]+$')"
        },
        {
          "filename": "onnx/model_container.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -15,6 +15,7 @@\n import onnx\n import onnx.external_data_helper as ext_data\n import onnx.helper\n+import onnx.onnx_cpp2py_export.checker as c_checker\n \n \n def _set_external_data(\n@@ -288,8 +289,9 @@ def _load_large_initializers(self, file_path):\n                 continue\n \n             info = ext_data.ExternalDataInfo(tensor)\n-            file_location = ext_data._sanitize_path(info.location)\n-            external_data_file_path = os.path.join(base_dir, file_location)\n+            external_data_file_path = c_checker._resolve_external_data_location(  # type: ignore[attr-defined]\n+                base_dir, info.location, tensor.name\n+            )\n             key = f\"#t{i}\"\n             _set_external_data(tensor, location=key)\n "
        },
        {
          "filename": "onnx/test/test_external_data.py",
          "status": "modified",
          "additions": 47,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@\n # SPDX-License-Identifier: Apache-2.0\n from __future__ import annotations\n \n+import itertools\n import os\n import pathlib\n import tempfile\n@@ -204,6 +205,52 @@ def test_save_external_single_file_data(self) -> None:\n         attribute_tensor = new_model.graph.node[0].attribute[0].t\n         np.testing.assert_allclose(to_array(attribute_tensor), self.attribute_value)\n \n+    @parameterized.parameterized.expand(itertools.product((True, False), (True, False)))\n+    def test_save_external_invalid_single_file_data_and_check(\n+        self, use_absolute_path: bool, use_model_path: bool\n+    ) -> None:\n+        model = onnx.load_model(self.model_filename, self.serialization_format)\n+\n+        model_dir = os.path.join(self.temp_dir, \"save_copy\")\n+        os.mkdir(model_dir)\n+\n+        traversal_external_data_dir = os.path.join(\n+            self.temp_dir, \"invlid_external_data\"\n+        )\n+        os.mkdir(traversal_external_data_dir)\n+\n+        if use_absolute_path:\n+            traversal_external_data_location = os.path.join(\n+                traversal_external_data_dir, \"tensors.bin\"\n+            )\n+        else:\n+            traversal_external_data_location = \"../invlid_external_data/tensors.bin\"\n+\n+        external_data_dir = os.path.join(self.temp_dir, \"external_data\")\n+        os.mkdir(external_data_dir)\n+        new_model_filepath = os.path.join(model_dir, \"model.onnx\")\n+\n+        def convert_model_to_external_data_no_check(model: ModelProto, location: str):\n+            for tensor in model.graph.initializer:\n+                if tensor.HasField(\"raw_data\"):\n+                    set_external_data(tensor, location)\n+\n+        convert_model_to_external_data_no_check(\n+            model,\n+            location=traversal_external_data_location,\n+        )\n+\n+        onnx.save_model(model, new_model_filepath, self.serialization_format)\n+        if use_model_path:\n+            with self.assertRaises(onnx.checker.ValidationError):\n+                _ = onnx.load_model(new_model_filepath, self.serialization_format)\n+        else:\n+            onnx_model = onnx.load_model(\n+                new_model_filepath, self.serialization_format, load_external_data=False\n+            )\n+            with self.assertRaises(onnx.checker.ValidationError):\n+                load_external_data_for_model(onnx_model, external_data_dir)\n+\n \n @parameterized.parameterized_class(\n     ["
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5ab1e4239221dd75c3bb0b1965edda35c956b18e",
            "date": "2025-01-10T15:57:27Z",
            "author_login": "justinchuby"
          },
          {
            "sha": "621e0d08d67bb04056e5eecd2069ca2d7d40c1fe",
            "date": "2025-01-10T00:09:56Z",
            "author_login": "justinchuby"
          },
          {
            "sha": "7f92d9cb779917a65518edbb20a4223526297b8e",
            "date": "2025-01-08T07:34:36Z",
            "author_login": "justinchuby"
          },
          {
            "sha": "f2e98bd1f80925e11d8b092a78feecbc4465f3f0",
            "date": "2025-01-08T07:33:31Z",
            "author_login": "cyyever"
          },
          {
            "sha": "19778a22e6e48b64e0c2d4497a7f152a486844da",
            "date": "2025-01-07T02:46:17Z",
            "author_login": "justinchuby"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-22",
    "description": "Versions of the package onnx before and including 1.15.0 are vulnerable to Directory Traversal as the external_data field of the tensor proto can have a path to the file which is outside the model current directory or user-provided directory. The vulnerability occurs as a bypass for the patch added for CVE-2022-25882.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-02-23T18:15:50.767",
    "last_modified": "2024-11-21T09:04:19.373",
    "fix_date": "2024-02-19T19:12:40Z"
  },
  "references": [
    {
      "url": "https://github.com/onnx/onnx/commit/66b7fb630903fdcf3e83b6b6d56d82e904264a20",
      "source": "6f8de1f0-f67e-45a6-b68f-98777fdb759c",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FGTBH5ZYL2LGYHIJDHN2MAUURIR5E7PY/",
      "source": "6f8de1f0-f67e-45a6-b68f-98777fdb759c",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TFJJID2IZDOLFDMWVYTBDI75ZJQC6JOL/",
      "source": "6f8de1f0-f67e-45a6-b68f-98777fdb759c",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-PYTHON-ONNX-2395479",
      "source": "6f8de1f0-f67e-45a6-b68f-98777fdb759c",
      "tags": []
    },
    {
      "url": "https://github.com/onnx/onnx/commit/66b7fb630903fdcf3e83b6b6d56d82e904264a20",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FGTBH5ZYL2LGYHIJDHN2MAUURIR5E7PY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TFJJID2IZDOLFDMWVYTBDI75ZJQC6JOL/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.snyk.io/vuln/SNYK-PYTHON-ONNX-2395479",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:28.155229",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "onnx",
    "owner": "onnx",
    "created_at": "2017-09-07T04:53:45Z",
    "updated_at": "2025-01-14T13:40:10Z",
    "pushed_at": "2025-01-13T21:55:38Z",
    "size": 34736,
    "stars": 18247,
    "forks": 3695,
    "open_issues": 343,
    "watchers": 18247,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 3156676,
      "C++": 2633184,
      "CMake": 36741,
      "Shell": 2176,
      "C": 2062,
      "PowerShell": 1265,
      "Batchfile": 547
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:30:21.405219"
  }
}