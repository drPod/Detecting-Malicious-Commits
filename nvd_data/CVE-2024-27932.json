{
  "cve_id": "CVE-2024-27932",
  "github_data": {
    "repository": "denoland/deno",
    "fix_commit": "de23e3b60b066481cc390f459497d5bef42a899b",
    "related_commits": [
      "de23e3b60b066481cc390f459497d5bef42a899b",
      "de23e3b60b066481cc390f459497d5bef42a899b"
    ],
    "patch_url": "https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b.patch",
    "fix_commit_details": {
      "sha": "de23e3b60b066481cc390f459497d5bef42a899b",
      "commit_date": "2024-02-06T18:45:40Z",
      "author": {
        "login": "mmastrac",
        "type": "User",
        "stats": {
          "total_commits": 347,
          "average_weekly_commits": 0.994269340974212,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 60
        }
      },
      "commit_message": {
        "title": "fix(cli): Add IP address support to DENO_AUTH_TOKEN (#22297)",
        "length": 514,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 166,
        "additions": 158,
        "deletions": 8
      },
      "files": [
        {
          "filename": "cli/auth_tokens.rs",
          "status": "modified",
          "additions": 158,
          "deletions": 8,
          "patch": "@@ -5,7 +5,13 @@ use base64::Engine;\n use deno_core::ModuleSpecifier;\n use log::debug;\n use log::error;\n+use std::borrow::Cow;\n use std::fmt;\n+use std::net::IpAddr;\n+use std::net::Ipv4Addr;\n+use std::net::Ipv6Addr;\n+use std::net::SocketAddr;\n+use std::str::FromStr;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum AuthTokenData {\n@@ -15,7 +21,7 @@ pub enum AuthTokenData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct AuthToken {\n-  host: String,\n+  host: AuthDomain,\n   token: AuthTokenData,\n }\n \n@@ -37,6 +43,78 @@ impl fmt::Display for AuthToken {\n #[derive(Debug, Clone)]\n pub struct AuthTokens(Vec<AuthToken>);\n \n+/// An authorization domain, either an exact or suffix match.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum AuthDomain {\n+  Ip(IpAddr),\n+  IpPort(SocketAddr),\n+  /// Suffix match, no dot. May include a port.\n+  Suffix(Cow<'static, str>),\n+}\n+\n+impl<T: ToString> From<T> for AuthDomain {\n+  fn from(value: T) -> Self {\n+    let s = value.to_string().to_lowercase();\n+    if let Ok(ip) = SocketAddr::from_str(&s) {\n+      return AuthDomain::IpPort(ip);\n+    };\n+    if s.starts_with('[') && s.ends_with(']') {\n+      if let Ok(ip) = Ipv6Addr::from_str(&s[1..s.len() - 1]) {\n+        return AuthDomain::Ip(ip.into());\n+      }\n+    } else if let Ok(ip) = Ipv4Addr::from_str(&s) {\n+      return AuthDomain::Ip(ip.into());\n+    }\n+    if let Some(s) = s.strip_prefix('.') {\n+      AuthDomain::Suffix(Cow::Owned(s.to_owned()))\n+    } else {\n+      AuthDomain::Suffix(Cow::Owned(s))\n+    }\n+  }\n+}\n+\n+impl AuthDomain {\n+  pub fn matches(&self, specifier: &ModuleSpecifier) -> bool {\n+    let Some(host) = specifier.host_str() else {\n+      return false;\n+    };\n+    match *self {\n+      Self::Ip(ip) => {\n+        let AuthDomain::Ip(parsed) = AuthDomain::from(host) else {\n+          return false;\n+        };\n+        ip == parsed && specifier.port().is_none()\n+      }\n+      Self::IpPort(ip) => {\n+        let AuthDomain::Ip(parsed) = AuthDomain::from(host) else {\n+          return false;\n+        };\n+        ip.ip() == parsed && specifier.port() == Some(ip.port())\n+      }\n+      Self::Suffix(ref suffix) => {\n+        let hostname = if let Some(port) = specifier.port() {\n+          Cow::Owned(format!(\"{}:{}\", host, port))\n+        } else {\n+          Cow::Borrowed(host)\n+        };\n+\n+        if suffix.len() == hostname.len() {\n+          return suffix == &hostname;\n+        }\n+\n+        // If it's a suffix match, ensure a dot\n+        if hostname.ends_with(suffix.as_ref())\n+          && hostname.ends_with(&format!(\".{suffix}\"))\n+        {\n+          return true;\n+        }\n+\n+        false\n+      }\n+    }\n+  }\n+}\n+\n impl AuthTokens {\n   /// Create a new set of tokens based on the provided string. It is intended\n   /// that the string be the value of an environment variable and the string is\n@@ -49,7 +127,7 @@ impl AuthTokens {\n         if token_str.contains('@') {\n           let pair: Vec<&str> = token_str.rsplitn(2, '@').collect();\n           let token = pair[1];\n-          let host = pair[0].to_lowercase();\n+          let host = AuthDomain::from(pair[0]);\n           if token.contains(':') {\n             let pair: Vec<&str> = token.rsplitn(2, ':').collect();\n             let username = pair[1].to_string();\n@@ -81,12 +159,7 @@ impl AuthTokens {\n   /// matching is case insensitive.\n   pub fn get(&self, specifier: &ModuleSpecifier) -> Option<AuthToken> {\n     self.0.iter().find_map(|t| {\n-      let hostname = if let Some(port) = specifier.port() {\n-        format!(\"{}:{}\", specifier.host_str()?, port)\n-      } else {\n-        specifier.host_str()?.to_string()\n-      };\n-      if hostname.to_lowercase().ends_with(&t.host) {\n+      if t.host.matches(specifier) {\n         Some(t.clone())\n       } else {\n         None\n@@ -182,4 +255,81 @@ mod tests {\n     let fixture = resolve_url(\"https://deno.land:8080/x/mod.ts\").unwrap();\n     assert_eq!(auth_tokens.get(&fixture), None);\n   }\n+\n+  #[test]\n+  fn test_parse_ip() {\n+    let ip = AuthDomain::from(\"[2001:db8:a::123]\");\n+    assert_eq!(\"Ip(2001:db8:a::123)\", format!(\"{ip:?}\"));\n+    let ip = AuthDomain::from(\"[2001:db8:a::123]:8080\");\n+    assert_eq!(\"IpPort([2001:db8:a::123]:8080)\", format!(\"{ip:?}\"));\n+    let ip = AuthDomain::from(\"1.1.1.1\");\n+    assert_eq!(\"Ip(1.1.1.1)\", format!(\"{ip:?}\"));\n+  }\n+\n+  #[test]\n+  fn test_case_insensitive() {\n+    let domain = AuthDomain::from(\"EXAMPLE.com\");\n+    assert!(\n+      domain.matches(&ModuleSpecifier::parse(\"http://example.com\").unwrap())\n+    );\n+    assert!(\n+      domain.matches(&ModuleSpecifier::parse(\"http://example.COM\").unwrap())\n+    );\n+  }\n+\n+  #[test]\n+  fn test_matches() {\n+    let candidates = [\n+      \"example.com\",\n+      \"www.example.com\",\n+      \"1.1.1.1\",\n+      \"[2001:db8:a::123]\",\n+      // These will never match\n+      \"example.com.evil.com\",\n+      \"1.1.1.1.evil.com\",\n+      \"notexample.com\",\n+      \"www.notexample.com\",\n+    ];\n+    let domains = [\n+      (\"example.com\", vec![\"example.com\", \"www.example.com\"]),\n+      (\".example.com\", vec![\"example.com\", \"www.example.com\"]),\n+      (\"www.example.com\", vec![\"www.example.com\"]),\n+      (\"1.1.1.1\", vec![\"1.1.1.1\"]),\n+      (\"[2001:db8:a::123]\", vec![\"[2001:db8:a::123]\"]),\n+    ];\n+    let url = |c: &str| ModuleSpecifier::parse(&format!(\"http://{c}\")).unwrap();\n+    let url_port =\n+      |c: &str| ModuleSpecifier::parse(&format!(\"http://{c}:8080\")).unwrap();\n+\n+    // Generate each candidate with and without a port\n+    let candidates = candidates\n+      .into_iter()\n+      .flat_map(|c| [url(c), url_port(c)])\n+      .collect::<Vec<_>>();\n+\n+    for (domain, expected_domain) in domains {\n+      // Test without a port -- all candidates return without a port\n+      let auth_domain = AuthDomain::from(domain);\n+      let actual = candidates\n+        .iter()\n+        .filter(|c| auth_domain.matches(c))\n+        .cloned()\n+        .collect::<Vec<_>>();\n+      let expected = expected_domain.iter().map(|u| url(u)).collect::<Vec<_>>();\n+      assert_eq!(actual, expected);\n+\n+      // Test with a port, all candidates return with a port\n+      let auth_domain = AuthDomain::from(&format!(\"{domain}:8080\"));\n+      let actual = candidates\n+        .iter()\n+        .filter(|c| auth_domain.matches(c))\n+        .cloned()\n+        .collect::<Vec<_>>();\n+      let expected = expected_domain\n+        .iter()\n+        .map(|u| url_port(u))\n+        .collect::<Vec<_>>();\n+      assert_eq!(actual, expected);\n+    }\n+  }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0b033140c07b5abee231711b0fbc3fa24f5f9eec",
            "date": "2025-01-14T15:01:05Z",
            "author_login": "dsherret"
          },
          {
            "sha": "3fb8fc1ba78ae7ded63dd2c1bb3249338bf14cac",
            "date": "2025-01-14T12:31:02Z",
            "author_login": "marvinhagemeister"
          },
          {
            "sha": "1e95c2056169c9b5de165b58bfd9296d5e5ce98e",
            "date": "2025-01-14T12:00:31Z",
            "author_login": "dsherret"
          },
          {
            "sha": "a1f50a742219f6da78234412fe11a1456bfd3a0d",
            "date": "2025-01-14T09:08:22Z",
            "author_login": "siaeyy"
          },
          {
            "sha": "9cb089f6db5574f091e54e222e8082ddd9ea779f",
            "date": "2025-01-14T09:01:14Z",
            "author_login": "aaron-ang"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-20",
    "description": "Deno is a JavaScript, TypeScript, and WebAssembly runtime. Starting in version 1.8.0 and prior to version 1.40.4, Deno improperly checks that an import specifier's hostname is equal to or a child of a token's hostname, which can cause tokens to be sent to servers they shouldn't be sent to. An auth token intended for `example[.]com` may be sent to `notexample[.]com`. Anyone who uses DENO_AUTH_TOKENS and imports potentially untrusted code is affected. Version 1.40.0 contains a patch for this issue",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-21T02:52:21.953",
    "last_modified": "2025-01-03T19:19:52.197",
    "fix_date": "2024-02-06T18:45:40Z"
  },
  "references": [
    {
      "url": "https://github.com/denoland/deno/blob/3f4639c330a31741b0efda2f93ebbb833f4f95bc/cli/auth_tokens.rs#L89",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/security/advisories/GHSA-5frw-4rwq-xhcr",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/3f4639c330a31741b0efda2f93ebbb833f4f95bc/cli/auth_tokens.rs#L89",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/security/advisories/GHSA-5frw-4rwq-xhcr",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.880742",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "deno",
    "owner": "denoland",
    "created_at": "2018-05-15T01:34:26Z",
    "updated_at": "2025-01-14T12:32:31Z",
    "pushed_at": "2025-01-14T12:49:11Z",
    "size": 154853,
    "stars": 101129,
    "forks": 5467,
    "open_issues": 2139,
    "watchers": 101129,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Rust": 7541487,
      "JavaScript": 5094451,
      "TypeScript": 3402737,
      "CSS": 5811,
      "C": 3937,
      "C++": 1416,
      "HTML": 427,
      "Dockerfile": 267,
      "Python": 214,
      "WebAssembly": 160,
      "Svelte": 133,
      "Astro": 97,
      "Nunjucks": 45
    },
    "commit_activity": {
      "total_commits_last_year": 2665,
      "avg_commits_per_week": 51.25,
      "days_active_last_year": 328
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:18:25.813797"
  }
}