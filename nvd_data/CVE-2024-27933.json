{
  "cve_id": "CVE-2024-27933",
  "github_data": {
    "repository": "denoland/deno",
    "fix_commit": "55fac9f5ead6d30996400e8597c969b675c5a22b",
    "related_commits": [
      "55fac9f5ead6d30996400e8597c969b675c5a22b",
      "5a91a065b882215dde209baf626247e54c21a392",
      "55fac9f5ead6d30996400e8597c969b675c5a22b",
      "5a91a065b882215dde209baf626247e54c21a392"
    ],
    "patch_url": "https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b.patch",
    "fix_commit_details": {
      "sha": "55fac9f5ead6d30996400e8597c969b675c5a22b",
      "commit_date": "2023-12-19T12:37:22Z",
      "author": {
        "login": "littledivy",
        "type": "User",
        "stats": {
          "total_commits": 693,
          "average_weekly_commits": 1.9856733524355301,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 164
        }
      },
      "commit_message": {
        "title": "fix(node): child_process IPC on Windows (#21597)",
        "length": 561,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 351,
        "additions": 258,
        "deletions": 93
      },
      "files": [
        {
          "filename": "Cargo.lock",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -1543,6 +1543,7 @@ dependencies = [\n  \"typenum\",\n  \"url\",\n  \"winapi\",\n+ \"windows-sys 0.48.0\",\n  \"x25519-dalek\",\n  \"x509-parser\",\n ]\n@@ -1635,6 +1636,7 @@ dependencies = [\n  \"uuid\",\n  \"which\",\n  \"winapi\",\n+ \"windows-sys 0.48.0\",\n  \"winres\",\n ]\n "
        },
        {
          "filename": "cli/args/mod.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -917,12 +917,12 @@ impl CliOptions {\n     .map(Some)\n   }\n \n-  pub fn node_ipc_fd(&self) -> Option<i32> {\n+  pub fn node_ipc_fd(&self) -> Option<i64> {\n     let maybe_node_channel_fd = std::env::var(\"DENO_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n       std::env::remove_var(\"DENO_CHANNEL_FD\");\n-      node_channel_fd.parse::<i32>().ok()\n+      node_channel_fd.parse::<i64>().ok()\n     } else {\n       None\n     }"
        },
        {
          "filename": "cli/worker.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -124,7 +124,7 @@ struct SharedWorkerState {\n   maybe_inspector_server: Option<Arc<InspectorServer>>,\n   maybe_lockfile: Option<Arc<Mutex<Lockfile>>>,\n   feature_checker: Arc<FeatureChecker>,\n-  node_ipc: Option<i32>,\n+  node_ipc: Option<i64>,\n }\n \n impl SharedWorkerState {\n@@ -404,7 +404,7 @@ impl CliMainWorkerFactory {\n     maybe_lockfile: Option<Arc<Mutex<Lockfile>>>,\n     feature_checker: Arc<FeatureChecker>,\n     options: CliMainWorkerOptions,\n-    node_ipc: Option<i32>,\n+    node_ipc: Option<i64>,\n   ) -> Self {\n     Self {\n       shared: Arc::new(SharedWorkerState {"
        },
        {
          "filename": "ext/node/Cargo.toml",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -74,3 +74,7 @@ url.workspace = true\n winapi.workspace = true\n x25519-dalek = \"2.0.0\"\n x509-parser = \"0.15.0\"\n+\n+[target.'cfg(windows)'.dependencies]\n+windows-sys.workspace = true\n+winapi = { workspace = true, features = [\"consoleapi\"] }"
        },
        {
          "filename": "ext/node/lib.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -31,6 +31,7 @@ mod polyfill;\n mod resolution;\n \n pub use ops::ipc::ChildPipeFd;\n+pub use ops::ipc::IpcJsonStreamResource;\n pub use ops::v8::VM_CONTEXT_INDEX;\n pub use package_json::PackageJson;\n pub use path::PathClean;\n@@ -307,7 +308,6 @@ deno_core::extension!(deno_node,\n     ops::require::op_require_break_on_next_statement,\n     ops::util::op_node_guess_handle_type,\n     ops::crypto::op_node_create_private_key,\n-    ops::ipc::op_node_ipc_pipe,\n     ops::ipc::op_node_child_ipc_pipe,\n     ops::ipc::op_node_ipc_write,\n     ops::ipc::op_node_ipc_read,"
        },
        {
          "filename": "ext/node/ops/ipc.rs",
          "status": "modified",
          "additions": 110,
          "deletions": 70,
          "patch": "@@ -1,20 +1,17 @@\n // Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n \n-#[cfg(unix)]\n-pub use unix::*;\n+pub use impl_::*;\n \n-#[cfg(windows)]\n-pub use windows::*;\n+pub struct ChildPipeFd(pub i64);\n \n-pub struct ChildPipeFd(pub i32);\n-\n-#[cfg(unix)]\n-mod unix {\n+mod impl_ {\n   use std::cell::RefCell;\n   use std::future::Future;\n   use std::io;\n   use std::mem;\n+  #[cfg(unix)]\n   use std::os::fd::FromRawFd;\n+  #[cfg(unix)]\n   use std::os::fd::RawFd;\n   use std::pin::Pin;\n   use std::rc::Rc;\n@@ -35,18 +32,16 @@ mod unix {\n   use tokio::io::AsyncBufRead;\n   use tokio::io::AsyncWriteExt;\n   use tokio::io::BufReader;\n+\n+  #[cfg(unix)]\n   use tokio::net::unix::OwnedReadHalf;\n+  #[cfg(unix)]\n   use tokio::net::unix::OwnedWriteHalf;\n+  #[cfg(unix)]\n   use tokio::net::UnixStream;\n \n-  #[op2(fast)]\n-  #[smi]\n-  pub fn op_node_ipc_pipe(\n-    state: &mut OpState,\n-    #[smi] fd: i32,\n-  ) -> Result<ResourceId, AnyError> {\n-    Ok(state.resource_table.add(IpcJsonStreamResource::new(fd)?))\n-  }\n+  #[cfg(windows)]\n+  type NamedPipeClient = tokio::net::windows::named_pipe::NamedPipeClient;\n \n   // Open IPC pipe from bootstrap options.\n   #[op2]\n@@ -97,9 +92,12 @@ mod unix {\n     Ok(msgs)\n   }\n \n-  struct IpcJsonStreamResource {\n+  pub struct IpcJsonStreamResource {\n     read_half: AsyncRefCell<IpcJsonStream>,\n+    #[cfg(unix)]\n     write_half: AsyncRefCell<OwnedWriteHalf>,\n+    #[cfg(windows)]\n+    write_half: AsyncRefCell<tokio::io::WriteHalf<NamedPipeClient>>,\n     cancel: Rc<CancelHandle>,\n   }\n \n@@ -109,23 +107,45 @@ mod unix {\n     }\n   }\n \n+  #[cfg(unix)]\n+  fn pipe(stream: RawFd) -> Result<(OwnedReadHalf, OwnedWriteHalf), io::Error> {\n+    // Safety: The fd is part of a pair of connected sockets create by child process\n+    // implementation.\n+    let unix_stream = UnixStream::from_std(unsafe {\n+      std::os::unix::net::UnixStream::from_raw_fd(stream)\n+    })?;\n+    Ok(unix_stream.into_split())\n+  }\n+\n+  #[cfg(windows)]\n+  fn pipe(\n+    handle: i64,\n+  ) -> Result<\n+    (\n+      tokio::io::ReadHalf<NamedPipeClient>,\n+      tokio::io::WriteHalf<NamedPipeClient>,\n+    ),\n+    io::Error,\n+  > {\n+    // Safety: We cannot use `get_osfhandle` because Deno statically links to msvcrt. It is not guaranteed that the\n+    // fd handle map will be the same.\n+    let pipe = unsafe { NamedPipeClient::from_raw_handle(handle as _)? };\n+    Ok(tokio::io::split(pipe))\n+  }\n+\n   impl IpcJsonStreamResource {\n-    fn new(stream: RawFd) -> Result<Self, std::io::Error> {\n-      // Safety: The fd is part of a pair of connected sockets create by child process\n-      // implementation.\n-      let unix_stream = UnixStream::from_std(unsafe {\n-        std::os::unix::net::UnixStream::from_raw_fd(stream)\n-      })?;\n-      let (read_half, write_half) = unix_stream.into_split();\n+    pub fn new(stream: i64) -> Result<Self, std::io::Error> {\n+      let (read_half, write_half) = pipe(stream as _)?;\n       Ok(Self {\n         read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n         write_half: AsyncRefCell::new(write_half),\n         cancel: Default::default(),\n       })\n     }\n \n+    #[cfg(unix)]\n     #[cfg(test)]\n-    fn from_unix_stream(stream: UnixStream) -> Self {\n+    fn from_stream(stream: UnixStream) -> Self {\n       let (read_half, write_half) = stream.into_split();\n       Self {\n         read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n@@ -134,6 +154,17 @@ mod unix {\n       }\n     }\n \n+    #[cfg(windows)]\n+    #[cfg(test)]\n+    fn from_stream(pipe: NamedPipeClient) -> Self {\n+      let (read_half, write_half) = tokio::io::split(pipe);\n+      Self {\n+        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n+        write_half: AsyncRefCell::new(write_half),\n+        cancel: Default::default(),\n+      }\n+    }\n+\n     async fn write_msg(\n       self: Rc<Self>,\n       msg: serde_json::Value,\n@@ -172,18 +203,30 @@ mod unix {\n   //\n   // `\\n` is used as a delimiter between messages.\n   struct IpcJsonStream {\n+    #[cfg(unix)]\n     pipe: BufReader<OwnedReadHalf>,\n+    #[cfg(windows)]\n+    pipe: BufReader<tokio::io::ReadHalf<NamedPipeClient>>,\n     buffer: Vec<u8>,\n   }\n \n   impl IpcJsonStream {\n+    #[cfg(unix)]\n     fn new(pipe: OwnedReadHalf) -> Self {\n       Self {\n         pipe: BufReader::with_capacity(INITIAL_CAPACITY, pipe),\n         buffer: Vec::with_capacity(INITIAL_CAPACITY),\n       }\n     }\n \n+    #[cfg(windows)]\n+    fn new(pipe: tokio::io::ReadHalf<NamedPipeClient>) -> Self {\n+      Self {\n+        pipe: BufReader::with_capacity(INITIAL_CAPACITY, pipe),\n+        buffer: Vec::with_capacity(INITIAL_CAPACITY),\n+      }\n+    }\n+\n     async fn read_msg(&mut self) -> Result<serde_json::Value, AnyError> {\n       let mut json = None;\n       let nread =\n@@ -252,7 +295,6 @@ mod unix {\n           std::task::Poll::Ready(t) => t?,\n           std::task::Poll::Pending => return std::task::Poll::Pending,\n         };\n-\n         if let Some(i) = memchr(b'\\n', available) {\n           if *read == 0 {\n             // Fast path: parse and put into the json slot directly.\n@@ -366,6 +408,35 @@ mod unix {\n     use deno_core::RcRef;\n     use std::rc::Rc;\n \n+    #[cfg(unix)]\n+    pub async fn pair() -> (Rc<IpcJsonStreamResource>, tokio::net::UnixStream) {\n+      let (a, b) = tokio::net::UnixStream::pair().unwrap();\n+\n+      /* Similar to how ops would use the resource */\n+      let a = Rc::new(IpcJsonStreamResource::from_stream(a));\n+      (a, b)\n+    }\n+\n+    #[cfg(windows)]\n+    pub async fn pair() -> (\n+      Rc<IpcJsonStreamResource>,\n+      tokio::net::windows::named_pipe::NamedPipeServer,\n+    ) {\n+      use tokio::net::windows::named_pipe::ClientOptions;\n+      use tokio::net::windows::named_pipe::ServerOptions;\n+\n+      let name =\n+        format!(r\"\\\\.\\pipe\\deno-named-pipe-test-{}\", rand::random::<u32>());\n+\n+      let server = ServerOptions::new().create(name.clone()).unwrap();\n+      let client = ClientOptions::new().open(name).unwrap();\n+\n+      server.connect().await.unwrap();\n+      /* Similar to how ops would use the resource */\n+      let client = Rc::new(IpcJsonStreamResource::from_stream(client));\n+      (client, server)\n+    }\n+\n     #[tokio::test]\n     async fn bench_ipc() -> Result<(), Box<dyn std::error::Error>> {\n       // A simple round trip benchmark for quick dev feedback.\n@@ -375,7 +446,7 @@ mod unix {\n         return Ok(());\n       }\n \n-      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n+      let (ipc, mut fd2) = pair().await;\n       let child = tokio::spawn(async move {\n         use tokio::io::AsyncWriteExt;\n \n@@ -389,8 +460,6 @@ mod unix {\n         Ok::<_, std::io::Error>(())\n       });\n \n-      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n-\n       let start = std::time::Instant::now();\n       let mut bytes = 0;\n \n@@ -416,21 +485,20 @@ mod unix {\n \n     #[tokio::test]\n     async fn unix_ipc_json() -> Result<(), Box<dyn std::error::Error>> {\n-      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n+      let (ipc, mut fd2) = pair().await;\n       let child = tokio::spawn(async move {\n         use tokio::io::AsyncReadExt;\n         use tokio::io::AsyncWriteExt;\n \n-        let mut buf = [0u8; 1024];\n-        let n = fd2.read(&mut buf).await?;\n-        assert_eq!(&buf[..n], b\"\\\"hello\\\"\\n\");\n+        const EXPECTED: &[u8] = b\"\\\"hello\\\"\\n\";\n+        let mut buf = [0u8; EXPECTED.len()];\n+        let n = fd2.read_exact(&mut buf).await?;\n+        assert_eq!(&buf[..n], EXPECTED);\n         fd2.write_all(b\"\\\"world\\\"\\n\").await?;\n+\n         Ok::<_, std::io::Error>(())\n       });\n \n-      /* Similar to how ops would use the resource */\n-      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n-\n       ipc.clone().write_msg(json!(\"hello\")).await?;\n \n       let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n@@ -444,19 +512,19 @@ mod unix {\n \n     #[tokio::test]\n     async fn unix_ipc_json_multi() -> Result<(), Box<dyn std::error::Error>> {\n-      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n+      let (ipc, mut fd2) = pair().await;\n       let child = tokio::spawn(async move {\n         use tokio::io::AsyncReadExt;\n         use tokio::io::AsyncWriteExt;\n \n-        let mut buf = [0u8; 1024];\n-        let n = fd2.read(&mut buf).await?;\n-        assert_eq!(&buf[..n], b\"\\\"hello\\\"\\n\\\"world\\\"\\n\");\n+        const EXPECTED: &[u8] = b\"\\\"hello\\\"\\n\\\"world\\\"\\n\";\n+        let mut buf = [0u8; EXPECTED.len()];\n+        let n = fd2.read_exact(&mut buf).await?;\n+        assert_eq!(&buf[..n], EXPECTED);\n         fd2.write_all(b\"\\\"foo\\\"\\n\\\"bar\\\"\\n\").await?;\n         Ok::<_, std::io::Error>(())\n       });\n \n-      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n       ipc.clone().write_msg(json!(\"hello\")).await?;\n       ipc.clone().write_msg(json!(\"world\")).await?;\n \n@@ -471,13 +539,12 @@ mod unix {\n \n     #[tokio::test]\n     async fn unix_ipc_json_invalid() -> Result<(), Box<dyn std::error::Error>> {\n-      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n+      let (ipc, mut fd2) = pair().await;\n       let child = tokio::spawn(async move {\n         tokio::io::AsyncWriteExt::write_all(&mut fd2, b\"\\n\\n\").await?;\n         Ok::<_, std::io::Error>(())\n       });\n \n-      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n       let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n       let _err = ipc.read_msg().await.unwrap_err();\n \n@@ -499,30 +566,3 @@ mod unix {\n     }\n   }\n }\n-\n-#[cfg(windows)]\n-mod windows {\n-  use deno_core::error::AnyError;\n-  use deno_core::op2;\n-\n-  #[op2(fast)]\n-  pub fn op_node_ipc_pipe() -> Result<(), AnyError> {\n-    Err(deno_core::error::not_supported())\n-  }\n-\n-  #[op2(fast)]\n-  #[smi]\n-  pub fn op_node_child_ipc_pipe() -> Result<i32, AnyError> {\n-    Ok(-1)\n-  }\n-\n-  #[op2(async)]\n-  pub async fn op_node_ipc_write() -> Result<(), AnyError> {\n-    Err(deno_core::error::not_supported())\n-  }\n-\n-  #[op2(async)]\n-  pub async fn op_node_ipc_read() -> Result<(), AnyError> {\n-    Err(deno_core::error::not_supported())\n-  }\n-}"
        },
        {
          "filename": "ext/node/polyfills/internal/child_process.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 4,
          "patch": "@@ -45,7 +45,6 @@ import { getValidatedPath } from \"ext:deno_node/internal/fs/utils.mjs\";\n import process from \"node:process\";\n \n const core = globalThis.__bootstrap.core;\n-const ops = core.ops;\n \n export function mapValues<T, O>(\n   record: Readonly<Record<string, T>>,\n@@ -1069,9 +1068,7 @@ function toDenoArgs(args: string[]): string[] {\n   return denoArgs;\n }\n \n-export function setupChannel(target, channel) {\n-  const ipc = ops.op_node_ipc_pipe(channel);\n-\n+export function setupChannel(target, ipc) {\n   async function readLoop() {\n     try {\n       while (true) {"
        },
        {
          "filename": "runtime/Cargo.toml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -122,6 +122,7 @@ which = \"4.2.5\"\n fwdansi.workspace = true\n winapi = { workspace = true, features = [\"commapi\", \"knownfolders\", \"mswsock\", \"objbase\", \"psapi\", \"shlobj\", \"tlhelp32\", \"winbase\", \"winerror\", \"winuser\", \"winsock2\"] }\n ntapi = \"0.4.0\"\n+windows-sys.workspace = true\n \n [target.'cfg(unix)'.dependencies]\n nix.workspace = true"
        },
        {
          "filename": "runtime/ops/process.rs",
          "status": "modified",
          "additions": 134,
          "deletions": 13,
          "patch": "@@ -141,7 +141,6 @@ pub struct SpawnArgs {\n   uid: Option<u32>,\n   #[cfg(windows)]\n   windows_raw_arguments: bool,\n-  #[cfg(unix)]\n   ipc: Option<i32>,\n \n   #[serde(flatten)]\n@@ -207,12 +206,7 @@ pub struct SpawnOutput {\n   stderr: Option<ToJsBuffer>,\n }\n \n-type CreateCommand = (\n-  std::process::Command,\n-  // TODO(@littledivy): Ideally this would return Option<ResourceId> but we are dealing with file descriptors\n-  // all the way until setupChannel which makes it easier to share code between parent and child fork.\n-  Option<i32>,\n-);\n+type CreateCommand = (std::process::Command, Option<ResourceId>);\n \n fn create_command(\n   state: &mut OpState,\n@@ -337,17 +331,144 @@ fn create_command(\n       });\n \n       /* One end returned to parent process (this) */\n-      let pipe_fd = Some(fd1);\n+      let pipe_rid = Some(\n+        state\n+          .resource_table\n+          .add(deno_node::IpcJsonStreamResource::new(fd1 as _)?),\n+      );\n \n       /* The other end passed to child process via DENO_CHANNEL_FD */\n       command.env(\"DENO_CHANNEL_FD\", format!(\"{}\", ipc));\n \n-      return Ok((command, pipe_fd));\n+      return Ok((command, pipe_rid));\n     }\n \n     Ok((command, None))\n   }\n \n+  #[cfg(windows)]\n+  // Safety: We setup a windows named pipe and pass one end to the child process.\n+  unsafe {\n+    use windows_sys::Win32::Foundation::CloseHandle;\n+    use windows_sys::Win32::Foundation::DuplicateHandle;\n+    use windows_sys::Win32::Foundation::DUPLICATE_SAME_ACCESS;\n+    use windows_sys::Win32::Foundation::ERROR_ACCESS_DENIED;\n+    use windows_sys::Win32::Foundation::ERROR_PIPE_CONNECTED;\n+    use windows_sys::Win32::Foundation::GENERIC_READ;\n+    use windows_sys::Win32::Foundation::GENERIC_WRITE;\n+    use windows_sys::Win32::Foundation::INVALID_HANDLE_VALUE;\n+    use windows_sys::Win32::Security::SECURITY_ATTRIBUTES;\n+    use windows_sys::Win32::Storage::FileSystem::CreateFileW;\n+    use windows_sys::Win32::Storage::FileSystem::FILE_FLAG_FIRST_PIPE_INSTANCE;\n+    use windows_sys::Win32::Storage::FileSystem::FILE_FLAG_OVERLAPPED;\n+    use windows_sys::Win32::Storage::FileSystem::OPEN_EXISTING;\n+    use windows_sys::Win32::Storage::FileSystem::PIPE_ACCESS_DUPLEX;\n+    use windows_sys::Win32::System::Pipes::ConnectNamedPipe;\n+    use windows_sys::Win32::System::Pipes::CreateNamedPipeW;\n+    use windows_sys::Win32::System::Pipes::PIPE_READMODE_BYTE;\n+    use windows_sys::Win32::System::Pipes::PIPE_TYPE_BYTE;\n+    use windows_sys::Win32::System::Threading::GetCurrentProcess;\n+\n+    use std::io;\n+    use std::os::windows::ffi::OsStrExt;\n+    use std::path::Path;\n+    use std::ptr;\n+\n+    if let Some(ipc) = args.ipc {\n+      if ipc < 0 {\n+        return Ok((command, None));\n+      }\n+\n+      let (path, hd1) = loop {\n+        let name = format!(\"\\\\\\\\.\\\\pipe\\\\{}\", uuid::Uuid::new_v4());\n+        let mut path = Path::new(&name)\n+          .as_os_str()\n+          .encode_wide()\n+          .collect::<Vec<_>>();\n+        path.push(0);\n+\n+        let hd1 = CreateNamedPipeW(\n+          path.as_ptr(),\n+          PIPE_ACCESS_DUPLEX\n+            | FILE_FLAG_FIRST_PIPE_INSTANCE\n+            | FILE_FLAG_OVERLAPPED,\n+          PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,\n+          1,\n+          65536,\n+          65536,\n+          0,\n+          std::ptr::null_mut(),\n+        );\n+\n+        if hd1 == INVALID_HANDLE_VALUE {\n+          let err = io::Error::last_os_error();\n+          /* If the pipe name is already in use, try again. */\n+          if err.raw_os_error() == Some(ERROR_ACCESS_DENIED as i32) {\n+            continue;\n+          }\n+\n+          return Err(err.into());\n+        }\n+\n+        break (path, hd1);\n+      };\n+\n+      /* Create child pipe handle. */\n+      let s = SECURITY_ATTRIBUTES {\n+        nLength: std::mem::size_of::<SECURITY_ATTRIBUTES>() as u32,\n+        lpSecurityDescriptor: ptr::null_mut(),\n+        bInheritHandle: 1,\n+      };\n+      let mut hd2 = CreateFileW(\n+        path.as_ptr(),\n+        GENERIC_READ | GENERIC_WRITE,\n+        0,\n+        &s,\n+        OPEN_EXISTING,\n+        FILE_FLAG_OVERLAPPED,\n+        0,\n+      );\n+      if hd2 == INVALID_HANDLE_VALUE {\n+        return Err(io::Error::last_os_error().into());\n+      }\n+\n+      // Will not block because we have create the pair.\n+      if ConnectNamedPipe(hd1, ptr::null_mut()) == 0 {\n+        let err = std::io::Error::last_os_error();\n+        if err.raw_os_error() != Some(ERROR_PIPE_CONNECTED as i32) {\n+          CloseHandle(hd2);\n+          return Err(err.into());\n+        }\n+      }\n+\n+      // Duplicating the handle to allow the child process to use it.\n+      if DuplicateHandle(\n+        GetCurrentProcess(),\n+        hd2,\n+        GetCurrentProcess(),\n+        &mut hd2,\n+        0,\n+        1,\n+        DUPLICATE_SAME_ACCESS,\n+      ) == 0\n+      {\n+        return Err(std::io::Error::last_os_error().into());\n+      }\n+\n+      /* One end returned to parent process (this) */\n+      let pipe_fd = Some(\n+        state\n+          .resource_table\n+          .add(deno_node::IpcJsonStreamResource::new(hd1 as i64)?),\n+      );\n+\n+      /* The other end passed to child process via DENO_CHANNEL_FD */\n+      command.env(\"DENO_CHANNEL_FD\", format!(\"{}\", hd2 as i64));\n+\n+      return Ok((command, pipe_fd));\n+    }\n+  }\n+\n   #[cfg(not(unix))]\n   return Ok((command, None));\n }\n@@ -360,13 +481,13 @@ struct Child {\n   stdin_rid: Option<ResourceId>,\n   stdout_rid: Option<ResourceId>,\n   stderr_rid: Option<ResourceId>,\n-  pipe_fd: Option<i32>,\n+  pipe_fd: Option<ResourceId>,\n }\n \n fn spawn_child(\n   state: &mut OpState,\n   command: std::process::Command,\n-  pipe_fd: Option<i32>,\n+  pipe_fd: Option<ResourceId>,\n ) -> Result<Child, AnyError> {\n   let mut command = tokio::process::Command::from(command);\n   // TODO(@crowlkats): allow detaching processes.\n@@ -459,8 +580,8 @@ fn op_spawn_child(\n   #[serde] args: SpawnArgs,\n   #[string] api_name: String,\n ) -> Result<Child, AnyError> {\n-  let (command, pipe_fd) = create_command(state, args, &api_name)?;\n-  spawn_child(state, command, pipe_fd)\n+  let (command, pipe_rid) = create_command(state, args, &api_name)?;\n+  spawn_child(state, command, pipe_rid)\n }\n \n #[op2(async)]"
        },
        {
          "filename": "runtime/worker_bootstrap.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -59,7 +59,7 @@ pub struct BootstrapOptions {\n   pub inspect: bool,\n   pub has_node_modules_dir: bool,\n   pub maybe_binary_npm_command_name: Option<String>,\n-  pub node_ipc_fd: Option<i32>,\n+  pub node_ipc_fd: Option<i64>,\n }\n \n impl Default for BootstrapOptions {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 2,
        "test_files": 0,
        "unique_directories": 8,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "974e2f44b2660a1cd13f8c901ff28a2f57ed391f",
            "date": "2025-01-14T16:29:36Z",
            "author_login": "bartlomieju"
          },
          {
            "sha": "c943f56949d723ba891b26a0cc4aaaaf7b358d95",
            "date": "2025-01-14T16:00:55Z",
            "author_login": "kt3k"
          },
          {
            "sha": "0b033140c07b5abee231711b0fbc3fa24f5f9eec",
            "date": "2025-01-14T15:01:05Z",
            "author_login": "dsherret"
          },
          {
            "sha": "3fb8fc1ba78ae7ded63dd2c1bb3249338bf14cac",
            "date": "2025-01-14T12:31:02Z",
            "author_login": "marvinhagemeister"
          },
          {
            "sha": "1e95c2056169c9b5de165b58bfd9296d5e5ce98e",
            "date": "2025-01-14T12:00:31Z",
            "author_login": "dsherret"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-863",
    "description": "Deno is a JavaScript, TypeScript, and WebAssembly runtime. In version 1.39.0, use of raw file descriptors in `op_node_ipc_pipe()` leads to premature close of arbitrary file descriptors, allowing standard input to be re-opened as a different resource resulting in permission prompt bypass. Node child_process IPC relies on the JS side to pass the raw IPC file descriptor to `op_node_ipc_pipe()`, which returns a `IpcJsonStreamResource` ID associated with the file descriptor. On closing the resource, the raw file descriptor is closed together.\n\nUse of raw file descriptors in `op_node_ipc_pipe()` leads to premature close of arbitrary file descriptors. This allow standard input (fd 0) to be closed and re-opened for a different resource, which allows a silent permission prompt bypass. This is exploitable by an attacker controlling the code executed inside a Deno runtime to obtain arbitrary code execution on the host machine regardless of permissions.\n\nThis bug is known to be exploitable. There is a working exploit that achieves arbitrary code execution by bypassing prompts from zero permissions, additionally abusing the fact that Cache API lacks filesystem permission checks. The attack can be conducted silently as stderr can also be closed, suppressing all prompt outputs.\n\nVersion 1.39.1 fixes the bug.\n",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-21T02:52:22.197",
    "last_modified": "2025-01-03T19:23:04.357",
    "fix_date": "2023-12-19T12:37:22Z"
  },
  "references": [
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L214",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L220",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L225",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L241",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L256",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L265",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L99",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/5a91a065b882215dde209baf626247e54c21a392",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/security/advisories/GHSA-6q4w-9x56-rmwq",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L214",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L220",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L225",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L241",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L256",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L265",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L99",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/5a91a065b882215dde209baf626247e54c21a392",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/security/advisories/GHSA-6q4w-9x56-rmwq",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.880926",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "deno",
    "owner": "denoland",
    "created_at": "2018-05-15T01:34:26Z",
    "updated_at": "2025-01-14T12:32:31Z",
    "pushed_at": "2025-01-14T12:49:11Z",
    "size": 154853,
    "stars": 101129,
    "forks": 5467,
    "open_issues": 2139,
    "watchers": 101129,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Rust": 7541487,
      "JavaScript": 5094451,
      "TypeScript": 3402737,
      "CSS": 5811,
      "C": 3937,
      "C++": 1416,
      "HTML": 427,
      "Dockerfile": 267,
      "Python": 214,
      "WebAssembly": 160,
      "Svelte": 133,
      "Astro": 97,
      "Nunjucks": 45
    },
    "commit_activity": {
      "total_commits_last_year": 2665,
      "avg_commits_per_week": 51.25,
      "days_active_last_year": 328
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:18:25.813797"
  }
}