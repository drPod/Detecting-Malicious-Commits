{
  "cve_id": "CVE-2024-27935",
  "github_data": {
    "repository": "denoland/deno",
    "fix_commit": "3e9fb8aafd9834ebacd27734cea4310caaf794c6",
    "related_commits": [
      "3e9fb8aafd9834ebacd27734cea4310caaf794c6",
      "3e9fb8aafd9834ebacd27734cea4310caaf794c6"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "3e9fb8aafd9834ebacd27734cea4310caaf794c6",
      "commit_date": "2023-08-22T14:45:10Z",
      "author": {
        "login": "mmastrac",
        "type": "User",
        "stats": {
          "total_commits": 347,
          "average_weekly_commits": 0.9886039886039886,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 60
        }
      },
      "commit_message": {
        "title": "fix(ext/node): simultaneous reads can leak into each other (#20223)",
        "length": 175,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 145,
        "additions": 105,
        "deletions": 40
      },
      "files": [
        {
          "filename": "cli/tests/unit_node/net_test.ts",
          "status": "modified",
          "additions": 57,
          "deletions": 0,
          "patch": "@@ -130,3 +130,60 @@ Deno.test(\"[node/net] connection event has socket value\", async () => {\n \n   await Promise.all([p, p2]);\n });\n+\n+// https://github.com/denoland/deno/issues/20188\n+Deno.test(\"[node/net] multiple Sockets should get correct server data\", async () => {\n+  const p = deferred();\n+  const p2 = deferred();\n+\n+  const dataReceived1 = deferred();\n+  const dataReceived2 = deferred();\n+\n+  const events1: string[] = [];\n+  const events2: string[] = [];\n+\n+  const server = net.createServer();\n+  server.on(\"connection\", (socket) => {\n+    assert(socket !== undefined);\n+    socket.on(\"data\", (data) => {\n+      socket.write(new TextDecoder().decode(data));\n+    });\n+  });\n+\n+  server.listen(async () => {\n+    // deno-lint-ignore no-explicit-any\n+    const { port } = server.address() as any;\n+\n+    const socket1 = net.createConnection(port);\n+    const socket2 = net.createConnection(port);\n+\n+    socket1.on(\"data\", (data) => {\n+      events1.push(new TextDecoder().decode(data));\n+      dataReceived1.resolve();\n+    });\n+\n+    socket2.on(\"data\", (data) => {\n+      events2.push(new TextDecoder().decode(data));\n+      dataReceived2.resolve();\n+    });\n+\n+    socket1.write(\"111\");\n+    socket2.write(\"222\");\n+\n+    await Promise.all([dataReceived1, dataReceived2]);\n+\n+    socket1.end();\n+    socket2.end();\n+\n+    server.close(() => {\n+      p.resolve();\n+    });\n+\n+    p2.resolve();\n+  });\n+\n+  await Promise.all([p, p2]);\n+\n+  assertEquals(events1, [\"111\"]);\n+  assertEquals(events2, [\"222\"]);\n+});"
        },
        {
          "filename": "ext/node/polyfills/internal_binding/stream_wrap.ts",
          "status": "modified",
          "additions": 48,
          "deletions": 40,
          "patch": "@@ -311,56 +311,61 @@ export class LibuvStreamWrap extends HandleWrap {\n \n   /** Internal method for reading from the attached stream. */\n   async #read() {\n-    let buf = BUF;\n-\n-    let nread: number | null;\n-    const ridBefore = this[kStreamBaseField]!.rid;\n+    const isOwnedBuf = bufLocked;\n+    let buf = bufLocked ? new Uint8Array(SUGGESTED_SIZE) : BUF;\n+    bufLocked = true;\n     try {\n-      nread = await this[kStreamBaseField]!.read(buf);\n-    } catch (e) {\n-      // Try to read again if the underlying stream resource\n-      // changed. This can happen during TLS upgrades (eg. STARTTLS)\n-      if (ridBefore != this[kStreamBaseField]!.rid) {\n-        return this.#read();\n-      }\n+      let nread: number | null;\n+      const ridBefore = this[kStreamBaseField]!.rid;\n+      try {\n+        nread = await this[kStreamBaseField]!.read(buf);\n+      } catch (e) {\n+        // Try to read again if the underlying stream resource\n+        // changed. This can happen during TLS upgrades (eg. STARTTLS)\n+        if (ridBefore != this[kStreamBaseField]!.rid) {\n+          return this.#read();\n+        }\n \n-      if (\n-        e instanceof Deno.errors.Interrupted ||\n-        e instanceof Deno.errors.BadResource\n-      ) {\n-        nread = codeMap.get(\"EOF\")!;\n-      } else if (\n-        e instanceof Deno.errors.ConnectionReset ||\n-        e instanceof Deno.errors.ConnectionAborted\n-      ) {\n-        nread = codeMap.get(\"ECONNRESET\")!;\n-      } else {\n-        nread = codeMap.get(\"UNKNOWN\")!;\n-      }\n+        if (\n+          e instanceof Deno.errors.Interrupted ||\n+          e instanceof Deno.errors.BadResource\n+        ) {\n+          nread = codeMap.get(\"EOF\")!;\n+        } else if (\n+          e instanceof Deno.errors.ConnectionReset ||\n+          e instanceof Deno.errors.ConnectionAborted\n+        ) {\n+          nread = codeMap.get(\"ECONNRESET\")!;\n+        } else {\n+          nread = codeMap.get(\"UNKNOWN\")!;\n+        }\n \n-      buf = new Uint8Array(0);\n-    }\n+        buf = new Uint8Array(0);\n+      }\n \n-    nread ??= codeMap.get(\"EOF\")!;\n+      nread ??= codeMap.get(\"EOF\")!;\n \n-    streamBaseState[kReadBytesOrError] = nread;\n+      streamBaseState[kReadBytesOrError] = nread;\n \n-    if (nread > 0) {\n-      this.bytesRead += nread;\n-    }\n+      if (nread > 0) {\n+        this.bytesRead += nread;\n+      }\n \n-    buf = buf.slice(0, nread);\n+      buf = isOwnedBuf ? buf.subarray(0, nread) : buf.slice(0, nread);\n \n-    streamBaseState[kArrayBufferOffset] = 0;\n+      streamBaseState[kArrayBufferOffset] = 0;\n \n-    try {\n-      this.onread!(buf, nread);\n-    } catch {\n-      // swallow callback errors.\n-    }\n+      try {\n+        this.onread!(buf, nread);\n+      } catch {\n+        // swallow callback errors.\n+      }\n \n-    if (nread >= 0 && this.#reading) {\n-      this.#read();\n+      if (nread >= 0 && this.#reading) {\n+        this.#read();\n+      }\n+    } finally {\n+      bufLocked = false;\n     }\n   }\n \n@@ -423,4 +428,7 @@ export class LibuvStreamWrap extends HandleWrap {\n   }\n }\n \n+// Used in #read above\n const BUF = new Uint8Array(SUGGESTED_SIZE);\n+// We need to ensure that only one inflight read request uses the cached buffer above\n+let bufLocked = false;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "769f748dd9dc81981512131822d49d79a9948b59",
            "date": "2025-01-24T18:05:04Z",
            "author_login": "dsherret"
          },
          {
            "sha": "688060845275468b21be03efe46e2a7e5cd71afa",
            "date": "2025-01-24T16:25:55Z",
            "author_login": "petamoriken"
          },
          {
            "sha": "e47574993546fdc79779d31d3e0240bd61b049dc",
            "date": "2025-01-24T14:50:25Z",
            "author_login": "dsherret"
          },
          {
            "sha": "3d8834f957aaebb1eaaaf41d97b7607679630f96",
            "date": "2025-01-24T12:47:15Z",
            "author_login": "kt3k"
          },
          {
            "sha": "0697578d3e09abc7c0f55eb342d4aa4f20760811",
            "date": "2025-01-24T12:08:36Z",
            "author_login": "bartlomieju"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:L",
    "cwe_id": "CWE-488",
    "description": "Deno is a JavaScript, TypeScript, and WebAssembly runtime. Starting in version 1.35.1 and prior to version 1.36.3, a vulnerability in Deno's Node.js compatibility runtime allows for cross-session data contamination during simultaneous asynchronous reads from Node.js streams sourced from sockets or files. The issue arises from the re-use of a global buffer (BUF) in stream_wrap.ts used as a performance optimization to limit allocations during these asynchronous read operations. This can lead to data intended for one session being received by another session, potentially resulting in data corruption and unexpected behavior. This affects all users of Deno that use the node.js compatibility layer for network communication or other streams, including packages that may require node.js libraries indirectly. Version 1.36.3 contains a patch for this issue.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-21T02:52:22.627",
    "last_modified": "2025-01-03T19:25:19.090",
    "fix_date": "2023-08-22T14:45:10Z"
  },
  "references": [
    {
      "url": "https://github.com/denoland/deno/commit/3e9fb8aafd9834ebacd27734cea4310caaf794c6",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/issues/20188",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/security/advisories/GHSA-wrqv-pf6j-mqjp",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/commit/3e9fb8aafd9834ebacd27734cea4310caaf794c6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/issues/20188",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/denoland/deno/security/advisories/GHSA-wrqv-pf6j-mqjp",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.881285",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "deno",
    "owner": "denoland",
    "created_at": "2018-05-15T01:34:26Z",
    "updated_at": "2025-01-26T07:59:32Z",
    "pushed_at": "2025-01-24T18:05:05Z",
    "size": 154707,
    "stars": 101314,
    "forks": 5473,
    "open_issues": 2184,
    "watchers": 101314,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Rust": 7617584,
      "JavaScript": 5095876,
      "TypeScript": 3409806,
      "CSS": 5811,
      "C": 3937,
      "C++": 1416,
      "HTML": 427,
      "Dockerfile": 267,
      "Python": 214,
      "WebAssembly": 160,
      "Svelte": 133,
      "Astro": 97,
      "Nunjucks": 45
    },
    "commit_activity": {
      "total_commits_last_year": 2573,
      "avg_commits_per_week": 49.48076923076923,
      "days_active_last_year": 326
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:29:12.907667"
  }
}