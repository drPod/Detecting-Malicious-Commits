{
  "cve_id": "CVE-2024-28101",
  "github_data": {
    "repository": "apollographql/router",
    "fix_commit": "9e9527c73c8f34fc8438b09066163cd42520f413",
    "related_commits": [
      "9e9527c73c8f34fc8438b09066163cd42520f413",
      "9e9527c73c8f34fc8438b09066163cd42520f413"
    ],
    "patch_url": "https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413.patch",
    "fix_commit_details": {
      "sha": "9e9527c73c8f34fc8438b09066163cd42520f413",
      "commit_date": "2024-03-06T10:24:32Z",
      "author": {
        "login": "Geal",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "streaming body decompression",
        "length": 137,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 169,
        "additions": 61,
        "deletions": 108
      },
      "files": [
        {
          "filename": "apollo-router/src/axum_factory/axum_http_server_factory.rs",
          "status": "modified",
          "additions": 34,
          "deletions": 13,
          "patch": "@@ -6,6 +6,7 @@ use std::sync::atomic::Ordering;\n use std::sync::Arc;\n use std::time::Instant;\n \n+use axum::error_handling::HandleErrorLayer;\n use axum::extract::Extension;\n use axum::extract::State;\n use axum::http::StatusCode;\n@@ -32,14 +33,15 @@ use tokio::sync::mpsc;\n use tokio_rustls::TlsAcceptor;\n use tower::service_fn;\n use tower::BoxError;\n+use tower::ServiceBuilder;\n use tower::ServiceExt;\n+use tower_http::decompression::DecompressionBody;\n use tower_http::trace::TraceLayer;\n \n use super::listeners::ensure_endpoints_consistency;\n use super::listeners::ensure_listenaddrs_consistency;\n use super::listeners::extra_endpoints;\n use super::listeners::ListenersAndRouters;\n-use super::utils::decompress_request_body;\n use super::utils::PropagatingMakeSpan;\n use super::ListenAddrAndRouter;\n use super::ENDPOINT_CALLBACK;\n@@ -57,6 +59,7 @@ use crate::plugins::traffic_shaping::RateLimited;\n use crate::router::ApolloRouterError;\n use crate::router_factory::Endpoint;\n use crate::router_factory::RouterFactory;\n+use crate::services::http::service::BodyStream;\n use crate::services::router;\n use crate::uplink::license_enforcement::LicenseState;\n use crate::uplink::license_enforcement::APOLLO_ROUTER_LICENSE_EXPIRED;\n@@ -173,11 +176,9 @@ where\n                     tracing::trace!(?health, request = ?req.router_request, \"health check\");\n                     async move {\n                         Ok(router::Response {\n-                            response: http::Response::builder()\n-                                .status(status_code)\n-                                .body::<hyper::Body>(\n-                                    serde_json::to_vec(&health).map_err(BoxError::from)?.into(),\n-                                )?,\n+                            response: http::Response::builder().status(status_code).body::<Body>(\n+                                serde_json::to_vec(&health).map_err(BoxError::from)?.into(),\n+                            )?,\n                             context: req.context,\n                         })\n                     }\n@@ -422,6 +423,10 @@ pub(crate) fn span_mode(configuration: &Configuration) -> SpanMode {\n         .unwrap_or_default()\n }\n \n+async fn decompression_error(_error: BoxError) -> axum::response::Response {\n+    (StatusCode::BAD_REQUEST, \"cannot decompress request body\").into_response()\n+}\n+\n fn main_endpoint<RF>(\n     service_factory: RF,\n     configuration: &Configuration,\n@@ -436,8 +441,16 @@ where\n     })?;\n     let span_mode = span_mode(configuration);\n \n+    let decompression = ServiceBuilder::new()\n+        .layer(HandleErrorLayer::<_, ()>::new(decompression_error))\n+        .layer(\n+            tower_http::decompression::RequestDecompressionLayer::new()\n+                .br(true)\n+                .gzip(true)\n+                .deflate(true),\n+        );\n     let mut main_route = main_router::<RF>(configuration)\n-        .layer(middleware::from_fn(decompress_request_body))\n+        .layer(decompression)\n         .layer(middleware::from_fn_with_state(\n             (license, Instant::now(), Arc::new(AtomicU64::new(0))),\n             license_handler,\n@@ -530,19 +543,21 @@ async fn license_handler<B>(\n     }\n }\n \n-pub(super) fn main_router<RF>(configuration: &Configuration) -> axum::Router\n+pub(super) fn main_router<RF>(\n+    configuration: &Configuration,\n+) -> axum::Router<(), DecompressionBody<Body>>\n where\n     RF: RouterFactory,\n {\n     let mut router = Router::new().route(\n         &configuration.supergraph.sanitized_path(),\n         get({\n-            move |Extension(service): Extension<RF>, request: Request<Body>| {\n+            move |Extension(service): Extension<RF>, request: Request<DecompressionBody<Body>>| {\n                 handle_graphql(service.create().boxed(), request)\n             }\n         })\n         .post({\n-            move |Extension(service): Extension<RF>, request: Request<Body>| {\n+            move |Extension(service): Extension<RF>, request: Request<DecompressionBody<Body>>| {\n                 handle_graphql(service.create().boxed(), request)\n             }\n         }),\n@@ -552,12 +567,14 @@ where\n         router = router.route(\n             \"/\",\n             get({\n-                move |Extension(service): Extension<RF>, request: Request<Body>| {\n+                move |Extension(service): Extension<RF>,\n+                      request: Request<DecompressionBody<Body>>| {\n                     handle_graphql(service.create().boxed(), request)\n                 }\n             })\n             .post({\n-                move |Extension(service): Extension<RF>, request: Request<Body>| {\n+                move |Extension(service): Extension<RF>,\n+                      request: Request<DecompressionBody<Body>>| {\n                     handle_graphql(service.create().boxed(), request)\n                 }\n             }),\n@@ -569,10 +586,14 @@ where\n \n async fn handle_graphql(\n     service: router::BoxService,\n-    http_request: Request<Body>,\n+    http_request: Request<DecompressionBody<Body>>,\n ) -> impl IntoResponse {\n     let _guard = SessionCountGuard::start();\n \n+    let (parts, body) = http_request.into_parts();\n+\n+    let http_request = http::Request::from_parts(parts, Body::wrap_stream(BodyStream::new(body)));\n+\n     let request: router::Request = http_request.into();\n     let context = request.context.clone();\n     let accept_encoding = request"
        },
        {
          "filename": "apollo-router/src/axum_factory/utils.rs",
          "status": "modified",
          "additions": 0,
          "deletions": 88,
          "patch": "@@ -2,19 +2,8 @@\n \n use std::net::SocketAddr;\n \n-use async_compression::tokio::write::BrotliDecoder;\n-use async_compression::tokio::write::GzipDecoder;\n-use async_compression::tokio::write::ZlibDecoder;\n-use axum::http::StatusCode;\n-use axum::middleware::Next;\n-use axum::response::*;\n-use futures::prelude::*;\n-use http::header::CONTENT_ENCODING;\n-use http::Request;\n-use hyper::Body;\n use opentelemetry::global;\n use opentelemetry::trace::TraceContextExt;\n-use tokio::io::AsyncWriteExt;\n use tower_http::trace::MakeSpan;\n use tower_service::Service;\n use tracing::Span;\n@@ -26,83 +15,6 @@ use crate::uplink::license_enforcement::LICENSE_EXPIRED_SHORT_MESSAGE;\n \n pub(crate) const REQUEST_SPAN_NAME: &str = \"request\";\n \n-pub(super) async fn decompress_request_body(\n-    req: Request<Body>,\n-    next: Next<Body>,\n-) -> Result<Response, Response> {\n-    let (parts, body) = req.into_parts();\n-    let content_encoding = parts.headers.get(&CONTENT_ENCODING);\n-    macro_rules! decode_body {\n-        ($decoder: ident, $error_message: expr) => {{\n-            let body_bytes = hyper::body::to_bytes(body)\n-                .map_err(|err| {\n-                    (\n-                        StatusCode::BAD_REQUEST,\n-                        format!(\"cannot read request body: {err}\"),\n-                    )\n-                        .into_response()\n-                })\n-                .await?;\n-            let mut decoder = $decoder::new(Vec::new());\n-            decoder.write_all(&body_bytes).await.map_err(|err| {\n-                (\n-                    StatusCode::BAD_REQUEST,\n-                    format!(\"{}: {err}\", $error_message),\n-                )\n-                    .into_response()\n-            })?;\n-            decoder.shutdown().await.map_err(|err| {\n-                (\n-                    StatusCode::BAD_REQUEST,\n-                    format!(\"{}: {err}\", $error_message),\n-                )\n-                    .into_response()\n-            })?;\n-\n-            Ok(next\n-                .run(Request::from_parts(parts, Body::from(decoder.into_inner())))\n-                .await)\n-        }};\n-    }\n-\n-    match content_encoding {\n-        Some(content_encoding) => match content_encoding.to_str() {\n-            Ok(content_encoding_str) => match content_encoding_str {\n-                \"br\" => decode_body!(BrotliDecoder, \"cannot decompress (brotli) request body\"),\n-                \"gzip\" => decode_body!(GzipDecoder, \"cannot decompress (gzip) request body\"),\n-                \"deflate\" => decode_body!(ZlibDecoder, \"cannot decompress (deflate) request body\"),\n-                \"identity\" => Ok(next.run(Request::from_parts(parts, body)).await),\n-                unknown => {\n-                    let message = format!(\"unknown content-encoding header value {unknown:?}\");\n-                    tracing::error!(message);\n-                    u64_counter!(\n-                        \"apollo_router_http_requests_total\",\n-                        \"Total number of HTTP requests made.\",\n-                        1,\n-                        status = StatusCode::BAD_REQUEST.as_u16() as i64,\n-                        error = message.clone()\n-                    );\n-\n-                    Err((StatusCode::BAD_REQUEST, message).into_response())\n-                }\n-            },\n-\n-            Err(err) => {\n-                let message = format!(\"cannot read content-encoding header: {err}\");\n-                u64_counter!(\n-                    \"apollo_router_http_requests_total\",\n-                    \"Total number of HTTP requests made.\",\n-                    1,\n-                    status = 400,\n-                    error = message.clone()\n-                );\n-                Err((StatusCode::BAD_REQUEST, message).into_response())\n-            }\n-        },\n-        None => Ok(next.run(Request::from_parts(parts, body)).await),\n-    }\n-}\n-\n #[derive(Clone, Default)]\n pub(crate) struct PropagatingMakeSpan {\n     pub(crate) license: LicenseState,"
        },
        {
          "filename": "apollo-router/src/services/http/service.rs",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -391,6 +391,13 @@ pin_project! {\n     }\n }\n \n+impl<B: hyper::body::HttpBody> BodyStream<B> {\n+    /// Create a new `BodyStream`.\n+    pub(crate) fn new(body: DecompressionBody<B>) -> Self {\n+        Self { inner: body }\n+    }\n+}\n+\n impl<B> Stream for BodyStream<B>\n where\n     B: hyper::body::HttpBody,"
        },
        {
          "filename": "apollo-router/src/services/layers/content_negotiation.rs",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -71,6 +71,17 @@ where\n                             .to_string(),\n                         ))\n                         .expect(\"cannot fail\");\n+                    u64_counter!(\n+                        \"apollo_router_http_requests_total\",\n+                        \"Total number of HTTP requests made.\",\n+                        1,\n+                        status = StatusCode::UNSUPPORTED_MEDIA_TYPE.as_u16() as i64,\n+                        error = format!(\n+                            r#\"'content-type' header must be one of: {:?} or {:?}\"#,\n+                            APPLICATION_JSON.essence_str(),\n+                            GRAPHQL_JSON_RESPONSE_HEADER_VALUE,\n+                        )\n+                    );\n \n                     return Ok(ControlFlow::Break(response.into()));\n                 }"
        },
        {
          "filename": "apollo-router/tests/common.rs",
          "status": "modified",
          "additions": 6,
          "deletions": 5,
          "patch": "@@ -10,7 +10,6 @@ use std::time::SystemTime;\n \n use buildstructor::buildstructor;\n use http::header::ACCEPT;\n-use http::header::CONTENT_ENCODING;\n use http::header::CONTENT_TYPE;\n use http::HeaderValue;\n use jsonpath_lib::Selector;\n@@ -378,7 +377,7 @@ impl IntegrationTest {\n     }\n \n     #[allow(dead_code)]\n-    pub fn execute_bad_content_encoding(\n+    pub fn execute_bad_content_type(\n         &self,\n     ) -> impl std::future::Future<Output = (String, reqwest::Response)> {\n         self.execute_query_internal(&json!({\"garbage\":{}}), Some(\"garbage\"))\n@@ -387,7 +386,7 @@ impl IntegrationTest {\n     fn execute_query_internal(\n         &self,\n         query: &Value,\n-        content_encoding: Option<&'static str>,\n+        content_type: Option<&'static str>,\n     ) -> impl std::future::Future<Output = (String, reqwest::Response)> {\n         assert!(\n             self.router.is_some(),\n@@ -404,8 +403,10 @@ impl IntegrationTest {\n \n                 let mut request = client\n                     .post(\"http://localhost:4000\")\n-                    .header(CONTENT_TYPE, APPLICATION_JSON.essence_str())\n-                    .header(CONTENT_ENCODING, content_encoding.unwrap_or(\"identity\"))\n+                    .header(\n+                        CONTENT_TYPE,\n+                        content_type.unwrap_or(APPLICATION_JSON.essence_str()),\n+                    )\n                     .header(\"apollographql-client-name\", \"custom_name\")\n                     .header(\"apollographql-client-version\", \"1.0\")\n                     .header(\"x-my-header\", \"test\")"
        },
        {
          "filename": "apollo-router/tests/telemetry/metrics.rs",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -135,10 +135,11 @@ async fn test_bad_queries() {\n             None,\n         )\n         .await;\n-    router.execute_bad_content_encoding().await;\n+    router.execute_bad_content_type().await;\n+\n     router\n             .assert_metrics_contains(\n-                r#\"apollo_router_http_requests_total{error=\"unknown content-encoding header value \\\"garbage\\\"\",status=\"400\",otel_scope_name=\"apollo/router\"}\"#,\n+                r#\"apollo_router_http_requests_total{error=\"'content-type' header must be one of: \\\"application/json\\\" or \\\"application/graphql-response+json\\\"\",status=\"415\",otel_scope_name=\"apollo/router\"}\"#,\n                 None,\n             )\n             .await;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "4fc63d55104c81c77e6e0a3cca615eac28e39dc3",
            "date": "2025-01-14T14:27:07Z",
            "author_login": "abernix"
          },
          {
            "sha": "553083e8173e3f1da2b4b8f93f20b5dedb4ac0c5",
            "date": "2025-01-10T20:15:11Z",
            "author_login": "shorgi"
          },
          {
            "sha": "a80938d29c6fc26624709b1ce782d8e4a0b9478d",
            "date": "2025-01-10T14:58:50Z",
            "author_login": "SimonSapin"
          },
          {
            "sha": "4dd7df8ad40d2d59476357cc6abfaab0986df925",
            "date": "2025-01-08T17:49:24Z",
            "author_login": "abernix"
          },
          {
            "sha": "c5ee35f4fb9ff2004a5e4c7eb23d01bc24d48287",
            "date": "2025-01-08T17:43:31Z",
            "author_login": "goto-bus-stop"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-409",
    "description": "The Apollo Router is a graph router written in Rust to run a federated supergraph that uses Apollo Federation. Versions 0.9.5 until 1.40.2 are subject to a Denial-of-Service (DoS) type vulnerability. When receiving compressed HTTP payloads, affected versions of the Router evaluate the `limits.http_max_request_bytes` configuration option after the entirety of the compressed payload is decompressed. If affected versions of the Router receive highly compressed payloads, this could result in significant memory consumption while the compressed payload is expanded. Router version 1.40.2 has a fix for the vulnerability. Those who are unable to upgrade may be able to implement mitigations at proxies or load balancers positioned in front of their Router fleet (e.g. Nginx, HAProxy, or cloud-native WAF services) by creating limits on HTTP body upload size. \n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-21T02:52:23.290",
    "last_modified": "2024-11-21T09:05:49.057",
    "fix_date": "2024-03-06T10:24:32Z"
  },
  "references": [
    {
      "url": "https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/apollographql/router/security/advisories/GHSA-cgqf-3cq5-wvcj",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/apollographql/router/security/advisories/GHSA-cgqf-3cq5-wvcj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.881573",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "router",
    "owner": "apollographql",
    "created_at": "2021-11-04T13:05:56Z",
    "updated_at": "2025-01-14T14:27:12Z",
    "pushed_at": "2025-01-14T14:32:18Z",
    "size": 44306,
    "stars": 831,
    "forks": 275,
    "open_issues": 508,
    "watchers": 831,
    "has_security_policy": false,
    "default_branch": "dev",
    "protected_branches": [
      "1.2.2",
      "1.2.3",
      "1.2.3456",
      "1.12.0",
      "1.23.0-alpha.0",
      "1.24.0-alpha.0",
      "1.24.0-alpha.1",
      "1.25.0-alpha.0",
      "1.25.0-alpha.1",
      "1.25.0-alpha.2",
      "1.27.0-alpha.1",
      "1.28.0-alpha.0",
      "1.30.0-alpha.1",
      "1.32.1-alpha.1",
      "1.33.2-alpha.0",
      "1.34.0-alpha.0",
      "1.43.3",
      "1.45.1",
      "1.46.0-rc.0",
      "1.52.2",
      "1.55.1",
      "1.58.1+telemetry-fix",
      "1.123.456"
    ],
    "languages": {
      "Rust": 8602740,
      "TLA": 23302,
      "Shell": 13702,
      "TypeScript": 7544,
      "HTML": 4831,
      "Smarty": 3754,
      "Dockerfile": 3307,
      "Handlebars": 1847,
      "RenderScript": 1
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:36:29.734203"
  }
}