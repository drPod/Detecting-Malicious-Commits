{
  "cve_id": "CVE-2024-28121",
  "github_data": {
    "repository": "stimulusreflex/stimulus_reflex",
    "fix_commit": "538582d240439aab76066c72335ea92096cd0c7f",
    "related_commits": [
      "538582d240439aab76066c72335ea92096cd0c7f",
      "538582d240439aab76066c72335ea92096cd0c7f"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "538582d240439aab76066c72335ea92096cd0c7f",
      "commit_date": "2024-03-12T05:55:07Z",
      "author": {
        "login": "marcoroth",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-f78j-4w3g-4q65",
        "length": 205,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 150,
        "additions": 148,
        "deletions": 2
      },
      "files": [
        {
          "filename": "lib/stimulus_reflex/reflex_factory.rb",
          "status": "modified",
          "additions": 35,
          "deletions": 2,
          "patch": "@@ -3,24 +3,57 @@\n class StimulusReflex::ReflexFactory\n   attr_reader :channel, :data\n \n-  delegate :reflex_name, to: :data\n+  delegate :reflex_name, :method_name, to: :data\n \n   def initialize(channel, data)\n     @channel = channel\n     @data = StimulusReflex::ReflexData.new(data)\n   end\n \n   def call\n+    verify_method_name!\n     reflex_class.new(channel, reflex_data: data)\n   end\n \n   private\n \n+  def verify_method_name!\n+    return if default_reflex?\n+\n+    argument_error = ArgumentError.new(\"Reflex method '#{method_name}' is not defined on class '#{reflex_name}' or on any of its ancestors\")\n+\n+    if reflex_method.nil?\n+      raise argument_error\n+    end\n+\n+    if !safe_ancestors.include?(reflex_method.owner)\n+      raise argument_error\n+    end\n+  end\n+\n   def reflex_class\n-    reflex_name.constantize.tap do |klass|\n+    @reflex_class ||= reflex_name.constantize.tap do |klass|\n       unless klass.ancestors.include?(StimulusReflex::Reflex)\n         raise ArgumentError.new(\"#{reflex_name} is not a StimulusReflex::Reflex\")\n       end\n     end\n   end\n+\n+  def reflex_method\n+    if reflex_class.public_instance_methods.include?(method_name.to_sym)\n+      reflex_class.public_instance_method(method_name)\n+    end\n+  end\n+\n+  def default_reflex?\n+    method_name == \"default_reflex\" && reflex_method.owner == ::StimulusReflex::Reflex\n+  end\n+\n+  def safe_ancestors\n+    # We want to include every class and module up to the `StimulusReflex::Reflex` class,\n+    # but not the StimulusReflex::Reflex itself\n+    reflex_class_index = reflex_class.ancestors.index(StimulusReflex::Reflex) - 1\n+\n+    reflex_class.ancestors.to(reflex_class_index)\n+  end\n end"
        },
        {
          "filename": "test/reflex_factory_test.rb",
          "status": "added",
          "additions": 79,
          "deletions": 0,
          "patch": "@@ -0,0 +1,79 @@\n+# frozen_string_literal: true\n+\n+require_relative \"test_helper\"\n+\n+class StimulusReflex::ReflexFactoryTest < ActionCable::Channel::TestCase\n+  tests StimulusReflex::Channel\n+\n+  test \"reflex class needs to be an ancestor of StimulusReflex::Reflex\" do\n+    exception = assert_raises(NameError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"Object#inspect\"}).call }\n+    assert_equal \"uninitialized constant ObjectReflex\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"NoReflex#no_reflex\"}).call }\n+    assert_equal \"NoReflex is not a StimulusReflex::Reflex\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"No#no_reflex\"}).call }\n+    assert_equal \"NoReflex is not a StimulusReflex::Reflex\", exception.message\n+  end\n+\n+  test \"doesn't raise if owner of method is ancestor of reflex class and descendant of StimulusReflex::Reflex\" do\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"ApplicationReflex#default_reflex\"}).call }\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"ApplicationReflex#application_reflex\"}).call }\n+\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"PostReflex#default_reflex\"}).call }\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"PostReflex#application_reflex\"}).call }\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"PostReflex#post_reflex\"}).call }\n+\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"CounterReflex#default_reflex\"}).call }\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"CounterReflex#application_reflex\"}).call }\n+    assert_nothing_raised { StimulusReflex::ReflexFactory.new(subscribe, {version: StimulusReflex::VERSION, target: \"CounterReflex#increment\"}).call }\n+  end\n+\n+  test \"raises if method is not owned by a descendant of StimulusReflex::Reflex\" do\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"ApplicationReflex#itself\"}).call }\n+    assert_equal \"Reflex method 'itself' is not defined on class 'ApplicationReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"ApplicationReflex#itself\"}).call }\n+    assert_equal \"Reflex method 'itself' is not defined on class 'ApplicationReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#itself\"}).call }\n+    assert_equal \"Reflex method 'itself' is not defined on class 'PostReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#binding\"}).call }\n+    assert_equal \"Reflex method 'binding' is not defined on class 'PostReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#byebug\"}).call }\n+    assert_equal \"Reflex method 'byebug' is not defined on class 'PostReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#debug\"}).call }\n+    assert_equal \"Reflex method 'debug' is not defined on class 'PostReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"ApplicationReflex#post_reflex\"}).call }\n+    assert_equal \"Reflex method 'post_reflex' is not defined on class 'ApplicationReflex' or on any of its ancestors\", exception.message\n+  end\n+\n+  test \"raises if method is a private method\" do\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"ApplicationReflex#private_application_reflex\"}).call }\n+    assert_equal \"Reflex method 'private_application_reflex' is not defined on class 'ApplicationReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#private_application_reflex\"}).call }\n+    assert_equal \"Reflex method 'private_application_reflex' is not defined on class 'PostReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#private_post_reflex\"}).call }\n+    assert_equal \"Reflex method 'private_post_reflex' is not defined on class 'PostReflex' or on any of its ancestors\", exception.message\n+\n+    exception = assert_raises(ArgumentError) { StimulusReflex::ReflexFactory.new(subscribe, {target: \"CounterReflex#private_post_reflex\"}).call }\n+    assert_equal \"Reflex method 'private_post_reflex' is not defined on class 'CounterReflex' or on any of its ancestors\", exception.message\n+  end\n+\n+  test \"safe_ancestors\" do\n+    reflex_factory = StimulusReflex::ReflexFactory.new(subscribe, {target: \"ApplicationReflex#default_reflex\"})\n+    assert_equal [ApplicationReflex, StimulusReflex::CableReadiness], reflex_factory.send(:safe_ancestors)\n+\n+    reflex_factory = StimulusReflex::ReflexFactory.new(subscribe, {target: \"PostReflex#default_reflex\"})\n+    assert_equal [PostReflex, ApplicationReflex, StimulusReflex::CableReadiness], reflex_factory.send(:safe_ancestors)\n+\n+    reflex_factory = StimulusReflex::ReflexFactory.new(subscribe, {target: \"CounterReflex#increment\"})\n+    assert_equal [CounterReflex, CounterConcern, ApplicationReflex, StimulusReflex::CableReadiness], reflex_factory.send(:safe_ancestors)\n+  end\n+end"
        },
        {
          "filename": "test/test_helper.rb",
          "status": "modified",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -50,6 +50,40 @@ def to_gid_param\n   end\n end\n \n+class ApplicationReflex < StimulusReflex::Reflex\n+  def application_reflex\n+  end\n+\n+  private\n+\n+  def private_application_reflex\n+  end\n+end\n+\n+class PostReflex < ApplicationReflex\n+  def post_reflex\n+  end\n+\n+  private\n+\n+  def private_post_reflex\n+  end\n+end\n+\n+class NoReflex\n+  def no_reflex\n+  end\n+end\n+\n+module CounterConcern\n+  def increment\n+  end\n+end\n+\n+class CounterReflex < ApplicationReflex\n+  include CounterConcern\n+end\n+\n module ActionCable\n   module Channel\n     class ConnectionStub"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bfe63bbadcf38cbdd434e15ac57991049db8b7d8",
            "date": "2024-12-15T09:00:52Z",
            "author_login": "marcoroth"
          },
          {
            "sha": "380859db79610d13512e310c6e77ec6e04782176",
            "date": "2024-12-15T08:59:33Z",
            "author_login": "marcoroth"
          },
          {
            "sha": "c363843f720100f203c77e1ffd4b6b0b3eeb059a",
            "date": "2024-12-15T08:47:50Z",
            "author_login": "marcoroth"
          },
          {
            "sha": "6851a630ffa7084fc4eec43599f25a4701ef78f0",
            "date": "2024-12-15T08:42:42Z",
            "author_login": "marcoroth"
          },
          {
            "sha": "4e9be47420974fcc031498a6f9e57c929b2cec71",
            "date": "2024-12-15T08:38:20Z",
            "author_login": "marcoroth"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-470",
    "description": "stimulus_reflex is a system to extend the capabilities of both Rails and Stimulus by intercepting user interactions and passing them to Rails over real-time websockets. In affected versions more methods than expected can be called on reflex instances. Being able to call some of them has security implications. To invoke a reflex a websocket message of the following shape is sent: `\\\"target\\\":\\\"[class_name]#[method_name]\\\",\\\"args\\\":[]`. The server will proceed to instantiate `reflex` using the provided `class_name` as long as it extends `StimulusReflex::Reflex`. It then attempts to call `method_name` on the instance with the provided arguments. This is problematic as `reflex.method method_name` can be more methods that those explicitly specified by the developer in their reflex class. A good example is the instance_variable_set method. This vulnerability has been patched in versions 3.4.2 and 3.5.0.rc4. Users unable to upgrade should: see the backing GHSA advisory for mitigation advice.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-12T20:15:08.313",
    "last_modified": "2024-11-21T09:05:51.707",
    "fix_date": "2024-03-12T05:55:07Z"
  },
  "references": [
    {
      "url": "http://seclists.org/fulldisclosure/2024/Mar/16",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/blob/0211cad7d60fe96838587f159d657e44cee51b9b/app/channels/stimulus_reflex/channel.rb#L83",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/commit/538582d240439aab76066c72335ea92096cd0c7f",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.4.2",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.5.0.rc4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/security/advisories/GHSA-f78j-4w3g-4q65",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "http://seclists.org/fulldisclosure/2024/Mar/16",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/blob/0211cad7d60fe96838587f159d657e44cee51b9b/app/channels/stimulus_reflex/channel.rb#L83",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/commit/538582d240439aab76066c72335ea92096cd0c7f",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.4.2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.5.0.rc4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stimulusreflex/stimulus_reflex/security/advisories/GHSA-f78j-4w3g-4q65",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:38.484094",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "stimulus_reflex",
    "owner": "stimulusreflex",
    "created_at": "2018-10-14T13:19:43Z",
    "updated_at": "2025-01-20T19:36:13Z",
    "pushed_at": "2024-12-15T09:01:28Z",
    "size": 5735,
    "stars": 2300,
    "forks": 175,
    "open_issues": 14,
    "watchers": 2300,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Ruby": 224741,
      "JavaScript": 151769,
      "Shell": 313,
      "HTML": 87
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:36:16.873762"
  }
}