{
  "cve_id": "CVE-2024-28179",
  "github_data": {
    "repository": "jupyterhub/jupyter-server-proxy",
    "fix_commit": "764e499f61a87641916a7a427d4c4b1ac3f321a9",
    "related_commits": [
      "764e499f61a87641916a7a427d4c4b1ac3f321a9",
      "bead903b7c0354b6efd8b4cde94b89afab653e03",
      "764e499f61a87641916a7a427d4c4b1ac3f321a9",
      "bead903b7c0354b6efd8b4cde94b89afab653e03"
    ],
    "patch_url": "https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9.patch",
    "fix_commit_details": {
      "sha": "764e499f61a87641916a7a427d4c4b1ac3f321a9",
      "commit_date": "2024-03-13T08:34:28Z",
      "author": {
        "login": "consideRatio",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-w3vc-fx9p-wp4v",
        "length": 86,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 58,
        "additions": 50,
        "deletions": 8
      },
      "files": [
        {
          "filename": "jupyter_server_proxy/handlers.py",
          "status": "modified",
          "additions": 33,
          "deletions": 3,
          "patch": "@@ -130,6 +130,39 @@ def check_origin(self, origin=None):\n     async def open(self, port, proxied_path):\n         raise NotImplementedError(\"Subclasses of ProxyHandler should implement open\")\n \n+    async def prepare(self, *args, **kwargs):\n+        \"\"\"\n+        Enforce authentication on *all* requests.\n+\n+        This method is called *before* any other method for all requests.\n+        See https://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.prepare.\n+        \"\"\"\n+        # Due to https://github.com/jupyter-server/jupyter_server/issues/1012,\n+        # we can not decorate `prepare` with `@web.authenticated`.\n+        # `super().prepare`, which calls `JupyterHandler.prepare`, *must* be called\n+        # before `@web.authenticated` can work. Since `@web.authenticated` is a decorator\n+        # that relies on the decorated method to get access to request information, we can\n+        # not call it directly. Instead, we create an empty lambda that takes a request_handler,\n+        # decorate that with web.authenticated, and call the decorated function.\n+        # super().prepare became async with jupyter_server v2\n+        _prepared = super().prepare(*args, **kwargs)\n+        if _prepared is not None:\n+            await _prepared\n+\n+        # If this is a GET request that wants to be upgraded to a websocket, users not\n+        # already authenticated gets a straightforward 403. Everything else is dealt\n+        # with by `web.authenticated`, which does a 302 to the appropriate login url.\n+        # Websockets are purely API calls made by JS rather than a direct user facing page,\n+        # so redirects do not make sense for them.\n+        if (\n+            self.request.method == \"GET\"\n+            and self.request.headers.get(\"Upgrade\", \"\").lower() == \"websocket\"\n+        ):\n+            if not self.current_user:\n+                raise web.HTTPError(403)\n+        else:\n+            web.authenticated(lambda request_handler: None)(self)\n+\n     async def http_get(self, host, port, proxy_path=\"\"):\n         \"\"\"Our non-websocket GET.\"\"\"\n         raise NotImplementedError(\n@@ -280,7 +313,6 @@ def _check_host_allowlist(self, host):\n         else:\n             return host in self.host_allowlist\n \n-    @web.authenticated\n     async def proxy(self, host, port, proxied_path):\n         \"\"\"\n         This serverextension handles:\n@@ -682,7 +714,6 @@ def _realize_rendered_template(self, attribute):\n             attribute = call_with_asked_args(attribute, self.process_args)\n         return self._render_template(attribute)\n \n-    @web.authenticated\n     async def proxy(self, port, path):\n         if not path.startswith(\"/\"):\n             path = \"/\" + path\n@@ -866,7 +897,6 @@ async def ensure_process(self):\n                     del self.state[\"proc\"]\n                     raise\n \n-    @web.authenticated\n     async def proxy(self, port, path):\n         await self.ensure_process()\n         return await ensure_async(super().proxy(port, path))"
        },
        {
          "filename": "tests/test_proxies.py",
          "status": "modified",
          "additions": 17,
          "deletions": 5,
          "patch": "@@ -7,6 +7,7 @@\n from urllib.parse import quote\n \n import pytest\n+from tornado.httpclient import HTTPClientError\n from tornado.websocket import websocket_connect\n \n # use ipv4 for CI, etc.\n@@ -334,8 +335,8 @@ def test_server_content_encoding_header(\n async def test_server_proxy_websocket_messages(\n     a_server_port_and_token: Tuple[int, str]\n ) -> None:\n-    PORT = a_server_port_and_token[0]\n-    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/echosocket\"\n+    PORT, TOKEN = a_server_port_and_token\n+    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/echosocket?token={TOKEN}\"\n     conn = await websocket_connect(url)\n     expected_msg = \"Hello, world!\"\n     await conn.write_message(expected_msg)\n@@ -344,8 +345,8 @@ async def test_server_proxy_websocket_messages(\n \n \n async def test_server_proxy_websocket_headers(a_server_port_and_token: Tuple[int, str]):\n-    PORT = a_server_port_and_token[0]\n-    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/headerssocket\"\n+    PORT, TOKEN = a_server_port_and_token\n+    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/headerssocket?token={TOKEN}\"\n     conn = await websocket_connect(url)\n     await conn.write_message(\"Hello\")\n     msg = await conn.read_message()\n@@ -394,7 +395,7 @@ async def test_server_proxy_websocket_subprotocols(\n     proxy_responded,\n ):\n     PORT, TOKEN = a_server_port_and_token\n-    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/subprotocolsocket\"\n+    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/subprotocolsocket?token={TOKEN}\"\n     conn = await websocket_connect(url, subprotocols=client_requested)\n     await conn.write_message(\"Hello, world!\")\n \n@@ -418,6 +419,17 @@ async def test_server_proxy_websocket_subprotocols(\n         assert \"Sec-Websocket-Protocol\" in conn.headers\n \n \n+async def test_websocket_no_auth_failure(\n+    a_server_port_and_token: Tuple[int, str]\n+) -> None:\n+    PORT = a_server_port_and_token[0]\n+    # Intentionally do not pass an appropriate token, which should cause a 403\n+    url = f\"ws://{LOCALHOST}:{PORT}/python-websocket/headerssocket\"\n+\n+    with pytest.raises(HTTPClientError, match=r\".*HTTP 403: Forbidden.*\"):\n+        await websocket_connect(url)\n+\n+\n @pytest.mark.parametrize(\n     \"proxy_path, status\",\n     ["
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "76a98c900605e31a9209e0897d3010d2c6057960",
            "date": "2024-12-04T18:47:43Z",
            "author_login": "ryanlovett"
          },
          {
            "sha": "c985e332b7d97b32e02295018f23b701547e2ebc",
            "date": "2024-11-06T08:31:58Z",
            "author_login": "minrk"
          },
          {
            "sha": "060624421e17bb74355ac7d29661f0ea90b69eb9",
            "date": "2024-11-04T23:16:10Z",
            "author_login": "pre-commit-ci[bot]"
          },
          {
            "sha": "7a491b657204a3e648e5acca96f981500fa03114",
            "date": "2024-11-04T23:15:38Z",
            "author_login": "pre-commit-ci[bot]"
          },
          {
            "sha": "fef3695e682c0b7604e00c87d290ea2a30ceaa53",
            "date": "2024-10-27T17:24:30Z",
            "author_login": "manics"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-306",
    "description": "Jupyter Server Proxy allows users to run arbitrary external processes alongside their Jupyter notebook servers and provides authenticated web access. Prior to versions 3.2.3 and 4.1.1, Jupyter Server Proxy did not check user authentication appropriately when proxying websockets, allowing unauthenticated access to anyone who had network access to the Jupyter server endpoint. This vulnerability can allow unauthenticated remote access to any websocket endpoint set up to be accessible via Jupyter Server Proxy. In many cases, this leads to remote unauthenticated arbitrary code execution, due to how affected instances use websockets. The websocket endpoints exposed by `jupyter_server` itself is not affected. Projects that do not rely on websockets are also not affected. Versions 3.2.3 and 4.1.1 contain a fix for this issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-03-20T20:15:08.680",
    "last_modified": "2024-11-21T09:05:58.083",
    "fix_date": "2024-03-13T08:34:28Z"
  },
  "references": [
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.873178",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jupyter-server-proxy",
    "owner": "jupyterhub",
    "created_at": "2016-10-18T22:02:06Z",
    "updated_at": "2025-01-10T22:21:01Z",
    "pushed_at": "2025-01-07T01:50:45Z",
    "size": 1487,
    "stars": 354,
    "forks": 147,
    "open_issues": 84,
    "watchers": 354,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 109087,
      "TypeScript": 12359,
      "RobotFramework": 4992,
      "JavaScript": 1609,
      "HTML": 109
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T17:44:14.285481"
  }
}