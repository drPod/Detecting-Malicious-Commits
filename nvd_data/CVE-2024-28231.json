{
  "cve_id": "CVE-2024-28231",
  "github_data": {
    "repository": "eProsima/Fast-DDS",
    "fix_commit": "355706386f4af9ce74125eeec3c449b06113112b",
    "related_commits": [
      "355706386f4af9ce74125eeec3c449b06113112b",
      "355706386f4af9ce74125eeec3c449b06113112b"
    ],
    "patch_url": "https://github.com/eProsima/Fast-DDS/commit/355706386f4af9ce74125eeec3c449b06113112b.patch",
    "fix_commit_details": {
      "sha": "355706386f4af9ce74125eeec3c449b06113112b",
      "commit_date": "2024-03-12T08:34:01Z",
      "author": {
        "login": "Desglaneurs",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-9m2j-qw67-ph4w",
        "length": 903,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1715,
        "additions": 1650,
        "deletions": 65
      },
      "files": [
        {
          "filename": "src/cpp/rtps/messages/MessageReceiver.cpp",
          "status": "modified",
          "additions": 14,
          "deletions": 2,
          "patch": "@@ -843,8 +843,20 @@ bool MessageReceiver::proc_Submsg_Data(\n     if (dataFlag || keyFlag)\n     {\n         uint32_t payload_size;\n-        payload_size = smh->submessageLength -\n-                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n+        const uint32_t submsg_no_payload_size =\n+                RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize;\n+\n+        // Prevent integer overflow of variable payload_size\n+        if (smh->submessageLength < submsg_no_payload_size)\n+        {\n+            EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload avoided overflow \"\n+                    \"(\" << smh->submessageLength << \"/\" << submsg_no_payload_size << \")\");\n+            ch.serializedPayload.data = nullptr;\n+            ch.inline_qos.data = nullptr;\n+            return false;\n+        }\n+\n+        payload_size = smh->submessageLength - submsg_no_payload_size;\n \n         if (dataFlag)\n         {"
        },
        {
          "filename": "test/blackbox/CMakeLists.txt",
          "status": "modified",
          "additions": 38,
          "deletions": 32,
          "patch": "@@ -56,28 +56,31 @@ endif()\n \n file(GLOB RTPS_BLACKBOXTESTS_TEST_SOURCE \"common/RTPSBlackboxTests*.cpp\")\n set(RTPS_BLACKBOXTESTS_SOURCE ${RTPS_BLACKBOXTESTS_TEST_SOURCE}\n+    types/Data1mb.cxx\n+    types/Data1mbPubSubTypes.cxx\n+    types/Data1mbv1.cxx\n+    types/Data64kb.cxx\n+    types/Data64kbPubSubTypes.cxx\n+    types/Data64kbv1.cxx\n+    types/FixedSized.cxx\n+    types/FixedSizedPubSubTypes.cxx\n+    types/FixedSizedv1.cxx\n     types/HelloWorld.cxx\n-    types/HelloWorldv1.cxx\n     types/HelloWorldPubSubTypes.cxx\n     types/HelloWorldTypeObject.cxx\n+    types/HelloWorldv1.cxx\n+    types/KeyedData1mb.cxx\n+    types/KeyedData1mbPubSubTypes.cxx\n+    types/KeyedData1mbv1.cxx\n     types/KeyedHelloWorld.cxx\n-    types/KeyedHelloWorldv1.cxx\n     types/KeyedHelloWorldPubSubTypes.cxx\n+    types/KeyedHelloWorldv1.cxx\n     types/StringTest.cxx\n-    types/StringTestv1.cxx\n     types/StringTestPubSubTypes.cxx\n-    types/Data64kb.cxx\n-    types/Data64kbv1.cxx\n-    types/Data64kbPubSubTypes.cxx\n-    types/Data1mb.cxx\n-    types/Data1mbv1.cxx\n-    types/Data1mbPubSubTypes.cxx\n-    types/KeyedData1mb.cxx\n-    types/KeyedData1mbv1.cxx\n-    types/KeyedData1mbPubSubTypes.cxx\n-    types/FixedSized.cxx\n-    types/FixedSizedv1.cxx\n-    types/FixedSizedPubSubTypes.cxx\n+    types/StringTestv1.cxx\n+    types/UnboundedHelloWorld.cxx\n+    types/UnboundedHelloWorldPubSubTypes.cxx\n+    types/UnboundedHelloWorldv1.cxx\n \n     utils/data_generators.cpp\n     utils/lambda_functions.cpp\n@@ -103,35 +106,38 @@ gtest_discover_tests(BlackboxTests_RTPS\n \n file(GLOB BLACKBOXTESTS_TEST_SOURCE \"common/BlackboxTests*.cpp\")\n set(BLACKBOXTESTS_SOURCE ${BLACKBOXTESTS_TEST_SOURCE}\n+    types/Data1mb.cxx\n+    types/Data1mbPubSubTypes.cxx\n+    types/Data1mbv1.cxx\n+    types/Data64kb.cxx\n+    types/Data64kbPubSubTypes.cxx\n+    types/Data64kbv1.cxx\n+    types/FixedSized.cxx\n+    types/FixedSizedPubSubTypes.cxx\n+    types/FixedSizedv1.cxx\n     types/HelloWorld.cxx\n-    types/HelloWorldv1.cxx\n     types/HelloWorldPubSubTypes.cxx\n     types/HelloWorldTypeObject.cxx\n+    types/HelloWorldv1.cxx\n+    types/KeyedData1mb.cxx\n+    types/KeyedData1mbPubSubTypes.cxx\n+    types/KeyedData1mbv1.cxx\n     types/KeyedHelloWorld.cxx\n-    types/KeyedHelloWorldv1.cxx\n     types/KeyedHelloWorldPubSubTypes.cxx\n+    types/KeyedHelloWorldv1.cxx\n     types/StringTest.cxx\n-    types/StringTestv1.cxx\n     types/StringTestPubSubTypes.cxx\n-    types/Data64kb.cxx\n-    types/Data64kbv1.cxx\n-    types/Data64kbPubSubTypes.cxx\n-    types/Data1mb.cxx\n-    types/Data1mbv1.cxx\n-    types/Data1mbPubSubTypes.cxx\n-    types/KeyedData1mb.cxx\n-    types/KeyedData1mbv1.cxx\n-    types/KeyedData1mbPubSubTypes.cxx\n-    types/FixedSized.cxx\n-    types/FixedSizedv1.cxx\n-    types/FixedSizedPubSubTypes.cxx\n+    types/StringTestv1.cxx\n     types/TestIncludeRegression3361.cxx\n-    types/TestIncludeRegression3361v1.cxx\n     types/TestIncludeRegression3361TypeObject.cxx\n+    types/TestIncludeRegression3361v1.cxx\n     types/TestRegression3361.cxx\n-    types/TestRegression3361v1.cxx\n     types/TestRegression3361PubSubTypes.cxx\n     types/TestRegression3361TypeObject.cxx\n+    types/TestRegression3361v1.cxx\n+    types/UnboundedHelloWorld.cxx\n+    types/UnboundedHelloWorldPubSubTypes.cxx\n+    types/UnboundedHelloWorldv1.cxx\n \n     utils/data_generators.cpp\n     utils/lambda_functions.cpp"
        },
        {
          "filename": "test/blackbox/api/fastrtps_deprecated/PubSubReader.hpp",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -333,7 +333,8 @@ class PubSubReader\n \n             if (subscriber_ != nullptr)\n             {\n-                std::cout << \"Created subscriber \" << subscriber_->getGuid() << \" for topic \" <<\n+                subscriber_guid_ = subscriber_->getGuid();\n+                std::cout << \"Created subscriber \" << subscriber_guid_ << \" for topic \" <<\n                     subscriber_attr_.topic.topicName << std::endl;\n \n                 initialized_ = true;\n@@ -1433,6 +1434,11 @@ class PubSubReader\n         return participant_guid_;\n     }\n \n+    const eprosima::fastrtps::rtps::GUID_t& datareader_guid() const\n+    {\n+        return subscriber_guid_;\n+    }\n+\n private:\n \n     void receive_one(\n@@ -1524,6 +1530,7 @@ class PubSubReader\n     eprosima::fastrtps::SubscriberAttributes subscriber_attr_;\n     std::string topic_name_;\n     eprosima::fastrtps::rtps::GUID_t participant_guid_;\n+    eprosima::fastrtps::rtps::GUID_t subscriber_guid_;\n     bool initialized_;\n     std::list<type> total_msgs_;\n     std::mutex mutex_;"
        },
        {
          "filename": "test/blackbox/common/BlackboxTests.hpp",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -31,13 +31,14 @@\n #include <unistd.h>\n #endif // if defined(_WIN32)\n \n-#include \"../types/HelloWorldPubSubTypes.h\"\n+#include \"../types/Data1mbPubSubTypes.h\"\n+#include \"../types/Data64kbPubSubTypes.h\"\n #include \"../types/FixedSizedPubSubTypes.h\"\n+#include \"../types/HelloWorldPubSubTypes.h\"\n+#include \"../types/KeyedData1mbPubSubTypes.h\"\n #include \"../types/KeyedHelloWorldPubSubTypes.h\"\n #include \"../types/StringTestPubSubTypes.h\"\n-#include \"../types/Data64kbPubSubTypes.h\"\n-#include \"../types/Data1mbPubSubTypes.h\"\n-#include \"../types/KeyedData1mbPubSubTypes.h\"\n+#include \"../types/UnboundedHelloWorldPubSubTypes.h\"\n \n #include <algorithm>\n #include <cstddef>\n@@ -170,6 +171,9 @@ std::list<Data1mb> default_data96kb_data300kb_data_generator(\n std::list<KeyedData1mb> default_keyeddata300kb_data_generator(\n         size_t max = 0);\n \n+std::list<UnboundedHelloWorld> default_unbounded_helloworld_data_generator(\n+        size_t max = 0);\n+\n /****** Auxiliary lambda functions  ******/\n extern const std::function<void(const HelloWorld&)>  default_helloworld_print;\n "
        },
        {
          "filename": "test/blackbox/common/BlackboxTestsSecurity.cpp",
          "status": "modified",
          "additions": 1,
          "deletions": 26,
          "patch": "@@ -27,6 +27,7 @@\n #include \"PubSubWriter.hpp\"\n #include \"PubSubWriterReader.hpp\"\n #include \"PubSubParticipant.hpp\"\n+#include \"UDPMessageSender.hpp\"\n \n #include <fastdds/dds/log/Log.hpp>\n #include <fastdds/rtps/common/EntityId_t.hpp>\n@@ -89,32 +90,6 @@ class Security : public testing::TestWithParam<communication_type>\n \n };\n \n-struct UDPMessageSender\n-{\n-    asio::io_service service;\n-    asio::ip::udp::socket socket;\n-\n-    UDPMessageSender()\n-        : service()\n-        , socket(service)\n-    {\n-        socket.open(asio::ip::udp::v4());\n-    }\n-\n-    void send(\n-            const CDRMessage_t& msg,\n-            const Locator_t& destination)\n-    {\n-        std::string addr = IPLocator::toIPv4string(destination);\n-        unsigned short port = static_cast<unsigned short>(destination.port);\n-        auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr), port);\n-        asio::error_code ec;\n-\n-        socket.send_to(asio::buffer(msg.buffer, msg.length), remote, 0, ec);\n-    }\n-\n-};\n-\n class SecurityPkcs : public ::testing::Test\n {\n public:"
        },
        {
          "filename": "test/blackbox/common/BlackboxTestsTransportUDP.cpp",
          "status": "modified",
          "additions": 99,
          "deletions": 0,
          "patch": "@@ -29,6 +29,7 @@\n #include \"DatagramInjectionTransport.hpp\"\n #include \"PubSubReader.hpp\"\n #include \"PubSubWriter.hpp\"\n+#include \"UDPMessageSender.hpp\"\n \n using namespace eprosima::fastrtps;\n using namespace eprosima::fastrtps::rtps;\n@@ -555,6 +556,104 @@ TEST(TransportUDP, DatagramInjection)\n     deliver_datagram_from_file(receivers, \"datagrams/20140.bin\");\n }\n \n+TEST(TransportUDP, MaliciousManipulatedDataOctetsToNextHeaderIgnore)\n+{\n+    // Force using UDP transport\n+    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();\n+\n+    PubSubWriter<UnboundedHelloWorldPubSubType> writer(TEST_TOPIC_NAME);\n+    PubSubReader<UnboundedHelloWorldPubSubType> reader(TEST_TOPIC_NAME);\n+\n+    struct MaliciousManipulatedDataOctetsToNextHeader\n+    {\n+        std::array<char, 4> rtps_id{ {'R', 'T', 'P', 'S'} };\n+        std::array<uint8_t, 2> protocol_version{ {2, 3} };\n+        std::array<uint8_t, 2> vendor_id{ {0x01, 0x0F} };\n+        GuidPrefix_t sender_prefix{};\n+\n+        struct DataSubMsg\n+        {\n+            struct Header\n+            {\n+                uint8_t submessage_id = 0x15;\n+#if FASTDDS_IS_BIG_ENDIAN_TARGET\n+                uint8_t flags = 0x04;\n+#else\n+                uint8_t flags = 0x05;\n+#endif  // FASTDDS_IS_BIG_ENDIAN_TARGET\n+                uint16_t octets_to_next_header = 0x30;\n+                uint16_t extra_flags = 0;\n+                uint16_t octets_to_inline_qos = 0x2d;\n+                EntityId_t reader_id{};\n+                EntityId_t writer_id{};\n+                SequenceNumber_t sn{100};\n+            };\n+\n+            struct SerializedData\n+            {\n+                uint16_t encapsulation;\n+                uint16_t encapsulation_opts;\n+                octet data[24];\n+            };\n+\n+            Header header;\n+            SerializedData payload;\n+        }\n+        data;\n+\n+        uint8_t additional_bytes[8] {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n+\n+    };\n+\n+    UDPMessageSender fake_msg_sender;\n+\n+    // Set common QoS\n+    reader.disable_builtin_transport().add_user_transport_to_pparams(udp_transport)\n+            .history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n+    writer.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n+\n+    // Set custom reader locator so we can send malicious data to a known location\n+    Locator_t reader_locator;\n+    ASSERT_TRUE(IPLocator::setIPv4(reader_locator, \"127.0.0.1\"));\n+    reader_locator.port = 7000;\n+    reader.add_to_unicast_locator_list(\"127.0.0.1\", 7000);\n+\n+    // Initialize and wait for discovery\n+    reader.init();\n+    ASSERT_TRUE(reader.isInitialized());\n+    writer.init();\n+    ASSERT_TRUE(writer.isInitialized());\n+\n+    reader.wait_discovery();\n+    writer.wait_discovery();\n+\n+    auto data = default_unbounded_helloworld_data_generator();\n+    reader.startReception(data);\n+    writer.send(data);\n+    ASSERT_TRUE(data.empty());\n+\n+    // Send malicious data\n+    {\n+        auto writer_guid = writer.datawriter_guid();\n+\n+        MaliciousManipulatedDataOctetsToNextHeader malicious_packet{};\n+        malicious_packet.sender_prefix = writer_guid.guidPrefix;\n+        malicious_packet.data.header.writer_id = writer_guid.entityId;\n+        malicious_packet.data.header.reader_id = reader.datareader_guid().entityId;\n+        malicious_packet.data.payload.encapsulation = CDR_LE;\n+\n+        CDRMessage_t msg(0);\n+        uint32_t msg_len = static_cast<uint32_t>(sizeof(malicious_packet));\n+        msg.init(reinterpret_cast<octet*>(&malicious_packet), msg_len);\n+        msg.length = msg_len;\n+        msg.pos = msg_len;\n+        fake_msg_sender.send(msg, reader_locator);\n+    }\n+\n+    // Block reader until reception finished or timeout.\n+    reader.block_for_all();\n+}\n+\n // Test for ==operator UDPTransportDescriptor is not required as it is an abstract class and in UDPv4 is same method\n // Test for copy UDPTransportDescriptor is not required as it is an abstract class and in UDPv4 is same method\n "
        },
        {
          "filename": "test/blackbox/common/UDPMessageSender.hpp",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+#include <asio/io_service.hpp>\n+#include <asio/ip/udp.hpp>\n+\n+#include <fastdds/rtps/common/CDRMessage_t.h>\n+#include <fastrtps/utils/IPLocator.h>\n+\n+using namespace eprosima::fastrtps;\n+using namespace eprosima::fastrtps::rtps;\n+\n+struct UDPMessageSender\n+{\n+    asio::io_service service;\n+    asio::ip::udp::socket socket;\n+\n+    UDPMessageSender()\n+        : service()\n+        , socket(service)\n+    {\n+        socket.open(asio::ip::udp::v4());\n+    }\n+\n+    void send(\n+            const CDRMessage_t& msg,\n+            const Locator_t& destination)\n+    {\n+        std::string addr = IPLocator::toIPv4string(destination);\n+        unsigned short port = static_cast<unsigned short>(destination.port);\n+        auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr), port);\n+        asio::error_code ec;\n+\n+        socket.send_to(asio::buffer(msg.buffer, msg.length), remote, 0, ec);\n+    }\n+\n+};"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorld.cxx",
          "status": "added",
          "additions": 168,
          "deletions": 0,
          "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorld.cpp\n+ * This source file contains the implementation of the described types in the IDL file.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+#ifdef _WIN32\n+// Remove linker warning LNK4221 on Visual Studio\n+namespace {\n+char dummy;\n+}  // namespace\n+#endif  // _WIN32\n+\n+#include \"UnboundedHelloWorld.h\"\n+\n+#if FASTCDR_VERSION_MAJOR > 1\n+\n+#include <fastcdr/Cdr.h>\n+\n+\n+#include <fastcdr/exceptions/BadParamException.h>\n+using namespace eprosima::fastcdr::exception;\n+\n+#include <utility>\n+\n+\n+\n+\n+UnboundedHelloWorld::UnboundedHelloWorld()\n+{\n+}\n+\n+UnboundedHelloWorld::~UnboundedHelloWorld()\n+{\n+}\n+\n+UnboundedHelloWorld::UnboundedHelloWorld(\n+        const UnboundedHelloWorld& x)\n+{\n+    m_index = x.m_index;\n+    m_message = x.m_message;\n+}\n+\n+UnboundedHelloWorld::UnboundedHelloWorld(\n+        UnboundedHelloWorld&& x) noexcept\n+{\n+    m_index = x.m_index;\n+    m_message = std::move(x.m_message);\n+}\n+\n+UnboundedHelloWorld& UnboundedHelloWorld::operator =(\n+        const UnboundedHelloWorld& x)\n+{\n+\n+    m_index = x.m_index;\n+    m_message = x.m_message;\n+    return *this;\n+}\n+\n+UnboundedHelloWorld& UnboundedHelloWorld::operator =(\n+        UnboundedHelloWorld&& x) noexcept\n+{\n+\n+    m_index = x.m_index;\n+    m_message = std::move(x.m_message);\n+    return *this;\n+}\n+\n+bool UnboundedHelloWorld::operator ==(\n+        const UnboundedHelloWorld& x) const\n+{\n+    return (m_index == x.m_index &&\n+           m_message == x.m_message);\n+}\n+\n+bool UnboundedHelloWorld::operator !=(\n+        const UnboundedHelloWorld& x) const\n+{\n+    return !(*this == x);\n+}\n+\n+/*!\n+ * @brief This function sets a value in member index\n+ * @param _index New value for member index\n+ */\n+void UnboundedHelloWorld::index(\n+        uint16_t _index)\n+{\n+    m_index = _index;\n+}\n+\n+/*!\n+ * @brief This function returns the value of member index\n+ * @return Value of member index\n+ */\n+uint16_t UnboundedHelloWorld::index() const\n+{\n+    return m_index;\n+}\n+\n+/*!\n+ * @brief This function returns a reference to member index\n+ * @return Reference to member index\n+ */\n+uint16_t& UnboundedHelloWorld::index()\n+{\n+    return m_index;\n+}\n+\n+\n+/*!\n+ * @brief This function copies the value in member message\n+ * @param _message New value to be copied in member message\n+ */\n+void UnboundedHelloWorld::message(\n+        const std::string& _message)\n+{\n+    m_message = _message;\n+}\n+\n+/*!\n+ * @brief This function moves the value in member message\n+ * @param _message New value to be moved in member message\n+ */\n+void UnboundedHelloWorld::message(\n+        std::string&& _message)\n+{\n+    m_message = std::move(_message);\n+}\n+\n+/*!\n+ * @brief This function returns a constant reference to member message\n+ * @return Constant reference to member message\n+ */\n+const std::string& UnboundedHelloWorld::message() const\n+{\n+    return m_message;\n+}\n+\n+/*!\n+ * @brief This function returns a reference to member message\n+ * @return Reference to member message\n+ */\n+std::string& UnboundedHelloWorld::message()\n+{\n+    return m_message;\n+}\n+\n+\n+// Include auxiliary functions like for serializing/deserializing.\n+#include \"UnboundedHelloWorldCdrAux.ipp\"\n+\n+#endif // FASTCDR_VERSION_MAJOR > 1"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorld.h",
          "status": "added",
          "additions": 195,
          "deletions": 0,
          "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorld.h\n+ * This header file contains the declaration of the described types in the IDL file.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+#include <fastcdr/config.h>\n+#include \"UnboundedHelloWorldv1.h\"\n+\n+#if FASTCDR_VERSION_MAJOR > 1\n+\n+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_\n+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_\n+\n+#include <array>\n+#include <bitset>\n+#include <cstdint>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+#include <fastcdr/cdr/fixed_size_string.hpp>\n+#include <fastcdr/xcdr/external.hpp>\n+#include <fastcdr/xcdr/optional.hpp>\n+\n+\n+\n+#if defined(_WIN32)\n+#if defined(EPROSIMA_USER_DLL_EXPORT)\n+#define eProsima_user_DllExport __declspec( dllexport )\n+#else\n+#define eProsima_user_DllExport\n+#endif  // EPROSIMA_USER_DLL_EXPORT\n+#else\n+#define eProsima_user_DllExport\n+#endif  // _WIN32\n+\n+#if defined(_WIN32)\n+#if defined(EPROSIMA_USER_DLL_EXPORT)\n+#if defined(UNBOUNDEDHELLOWORLD_SOURCE)\n+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllexport )\n+#else\n+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllimport )\n+#endif // UNBOUNDEDHELLOWORLD_SOURCE\n+#else\n+#define UNBOUNDEDHELLOWORLD_DllAPI\n+#endif  // EPROSIMA_USER_DLL_EXPORT\n+#else\n+#define UNBOUNDEDHELLOWORLD_DllAPI\n+#endif // _WIN32\n+\n+namespace eprosima {\n+namespace fastcdr {\n+class Cdr;\n+class CdrSizeCalculator;\n+} // namespace fastcdr\n+} // namespace eprosima\n+\n+\n+\n+\n+\n+/*!\n+ * @brief This class represents the structure UnboundedHelloWorld defined by the user in the IDL file.\n+ * @ingroup UnboundedHelloWorld\n+ */\n+class UnboundedHelloWorld\n+{\n+public:\n+\n+    /*!\n+     * @brief Default constructor.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld();\n+\n+    /*!\n+     * @brief Default destructor.\n+     */\n+    eProsima_user_DllExport ~UnboundedHelloWorld();\n+\n+    /*!\n+     * @brief Copy constructor.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld(\n+            const UnboundedHelloWorld& x);\n+\n+    /*!\n+     * @brief Move constructor.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld(\n+            UnboundedHelloWorld&& x) noexcept;\n+\n+    /*!\n+     * @brief Copy assignment.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld& operator =(\n+            const UnboundedHelloWorld& x);\n+\n+    /*!\n+     * @brief Move assignment.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld& operator =(\n+            UnboundedHelloWorld&& x) noexcept;\n+\n+    /*!\n+     * @brief Comparison operator.\n+     * @param x UnboundedHelloWorld object to compare.\n+     */\n+    eProsima_user_DllExport bool operator ==(\n+            const UnboundedHelloWorld& x) const;\n+\n+    /*!\n+     * @brief Comparison operator.\n+     * @param x UnboundedHelloWorld object to compare.\n+     */\n+    eProsima_user_DllExport bool operator !=(\n+            const UnboundedHelloWorld& x) const;\n+\n+    /*!\n+     * @brief This function sets a value in member index\n+     * @param _index New value for member index\n+     */\n+    eProsima_user_DllExport void index(\n+            uint16_t _index);\n+\n+    /*!\n+     * @brief This function returns the value of member index\n+     * @return Value of member index\n+     */\n+    eProsima_user_DllExport uint16_t index() const;\n+\n+    /*!\n+     * @brief This function returns a reference to member index\n+     * @return Reference to member index\n+     */\n+    eProsima_user_DllExport uint16_t& index();\n+\n+\n+    /*!\n+     * @brief This function copies the value in member message\n+     * @param _message New value to be copied in member message\n+     */\n+    eProsima_user_DllExport void message(\n+            const std::string& _message);\n+\n+    /*!\n+     * @brief This function moves the value in member message\n+     * @param _message New value to be moved in member message\n+     */\n+    eProsima_user_DllExport void message(\n+            std::string&& _message);\n+\n+    /*!\n+     * @brief This function returns a constant reference to member message\n+     * @return Constant reference to member message\n+     */\n+    eProsima_user_DllExport const std::string& message() const;\n+\n+    /*!\n+     * @brief This function returns a reference to member message\n+     * @return Reference to member message\n+     */\n+    eProsima_user_DllExport std::string& message();\n+\n+private:\n+\n+    uint16_t m_index{0};\n+    std::string m_message;\n+\n+};\n+\n+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_\n+\n+\n+\n+#endif // FASTCDR_VERSION_MAJOR > 1"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorld.idl",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+struct UnboundedHelloWorld\n+{\n+\tunsigned short index;\n+\tstring message;\n+};\n\\ No newline at end of file"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorldCdrAux.hpp",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorldCdrAux.hpp\n+ * This source file contains some definitions of CDR related functions.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_HPP_\n+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_HPP_\n+\n+#include \"UnboundedHelloWorld.h\"\n+\n+constexpr uint32_t UnboundedHelloWorld_max_cdr_typesize {268UL};\n+constexpr uint32_t UnboundedHelloWorld_max_key_cdr_typesize {0UL};\n+\n+\n+namespace eprosima {\n+namespace fastcdr {\n+\n+class Cdr;\n+class CdrSizeCalculator;\n+\n+\n+\n+eProsima_user_DllExport void serialize_key(\n+        eprosima::fastcdr::Cdr& scdr,\n+        const UnboundedHelloWorld& data);\n+\n+\n+} // namespace fastcdr\n+} // namespace eprosima\n+\n+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_HPP_\n+"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorldCdrAux.ipp",
          "status": "added",
          "additions": 128,
          "deletions": 0,
          "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorldCdrAux.ipp\n+ * This source file contains some declarations of CDR related functions.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_IPP_\n+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_IPP_\n+\n+#include \"UnboundedHelloWorldCdrAux.hpp\"\n+\n+#include <fastcdr/Cdr.h>\n+#include <fastcdr/CdrSizeCalculator.hpp>\n+\n+\n+#include <fastcdr/exceptions/BadParamException.h>\n+using namespace eprosima::fastcdr::exception;\n+\n+namespace eprosima {\n+namespace fastcdr {\n+\n+\n+\n+template<>\n+eProsima_user_DllExport size_t calculate_serialized_size(\n+        eprosima::fastcdr::CdrSizeCalculator& calculator,\n+        const UnboundedHelloWorld& data,\n+        size_t& current_alignment)\n+{\n+    static_cast<void>(data);\n+\n+    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();\n+    size_t calculated_size {calculator.begin_calculate_type_serialized_size(\n+                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?\n+                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :\n+                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,\n+                                current_alignment)};\n+\n+\n+        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),\n+                data.index(), current_alignment);\n+\n+        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),\n+                data.message(), current_alignment);\n+\n+\n+    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);\n+\n+    return calculated_size;\n+}\n+\n+template<>\n+eProsima_user_DllExport void serialize(\n+        eprosima::fastcdr::Cdr& scdr,\n+        const UnboundedHelloWorld& data)\n+{\n+    eprosima::fastcdr::Cdr::state current_state(scdr);\n+    scdr.begin_serialize_type(current_state,\n+            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?\n+            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :\n+            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);\n+\n+    scdr\n+        << eprosima::fastcdr::MemberId(0) << data.index()\n+        << eprosima::fastcdr::MemberId(1) << data.message()\n+;\n+    scdr.end_serialize_type(current_state);\n+}\n+\n+template<>\n+eProsima_user_DllExport void deserialize(\n+        eprosima::fastcdr::Cdr& cdr,\n+        UnboundedHelloWorld& data)\n+{\n+    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?\n+            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :\n+            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,\n+            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool\n+            {\n+                bool ret_value = true;\n+                switch (mid.id)\n+                {\n+                                        case 0:\n+                                                dcdr >> data.index();\n+                                            break;\n+\n+                                        case 1:\n+                                                dcdr >> data.message();\n+                                            break;\n+\n+                    default:\n+                        ret_value = false;\n+                        break;\n+                }\n+                return ret_value;\n+            });\n+}\n+\n+void serialize_key(\n+        eprosima::fastcdr::Cdr& scdr,\n+        const UnboundedHelloWorld& data)\n+{\n+    static_cast<void>(scdr);\n+    static_cast<void>(data);\n+}\n+\n+\n+\n+} // namespace fastcdr\n+} // namespace eprosima\n+\n+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLDCDRAUX_IPP_\n+"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorldPubSubTypes.cxx",
          "status": "added",
          "additions": 221,
          "deletions": 0,
          "patch": "@@ -0,0 +1,221 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorldPubSubTypes.cpp\n+ * This header file contains the implementation of the serialization functions.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+\n+#include <fastdds/rtps/common/CdrSerialization.hpp>\n+\n+#include \"UnboundedHelloWorldPubSubTypes.h\"\n+#include \"UnboundedHelloWorldCdrAux.hpp\"\n+\n+using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;\n+using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;\n+using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;\n+\n+\n+\n+UnboundedHelloWorldPubSubType::UnboundedHelloWorldPubSubType()\n+{\n+    setName(\"UnboundedHelloWorld\");\n+    uint32_t type_size =\n+#if FASTCDR_VERSION_MAJOR == 1\n+        static_cast<uint32_t>(UnboundedHelloWorld::getMaxCdrSerializedSize());\n+#else\n+        UnboundedHelloWorld_max_cdr_typesize;\n+#endif\n+    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */\n+    m_typeSize = type_size + 4; /*encapsulation*/\n+    m_isGetKeyDefined = false;\n+    uint32_t keyLength = UnboundedHelloWorld_max_key_cdr_typesize > 16 ? UnboundedHelloWorld_max_key_cdr_typesize : 16;\n+    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));\n+    memset(m_keyBuffer, 0, keyLength);\n+}\n+\n+UnboundedHelloWorldPubSubType::~UnboundedHelloWorldPubSubType()\n+{\n+    if (m_keyBuffer != nullptr)\n+    {\n+        free(m_keyBuffer);\n+    }\n+}\n+\n+bool UnboundedHelloWorldPubSubType::serialize(\n+        void* data,\n+        SerializedPayload_t* payload,\n+        DataRepresentationId_t data_representation)\n+{\n+    UnboundedHelloWorld* p_type = static_cast<UnboundedHelloWorld*>(data);\n+\n+    // Object that manages the raw buffer.\n+    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n+    // Object that serializes the data.\n+    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n+            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?\n+            eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);\n+    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n+#if FASTCDR_VERSION_MAJOR > 1\n+    ser.set_encoding_flag(\n+        data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?\n+        eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :\n+        eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);\n+#endif // FASTCDR_VERSION_MAJOR > 1\n+\n+    try\n+    {\n+        // Serialize encapsulation\n+        ser.serialize_encapsulation();\n+        // Serialize the object.\n+        ser << *p_type;\n+    }\n+    catch (eprosima::fastcdr::exception::Exception& /*exception*/)\n+    {\n+        return false;\n+    }\n+\n+    // Get the serialized length\n+#if FASTCDR_VERSION_MAJOR == 1\n+    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n+#else\n+    payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());\n+#endif // FASTCDR_VERSION_MAJOR == 1\n+    return true;\n+}\n+\n+bool UnboundedHelloWorldPubSubType::deserialize(\n+        SerializedPayload_t* payload,\n+        void* data)\n+{\n+    try\n+    {\n+        // Convert DATA to pointer of your type\n+        UnboundedHelloWorld* p_type = static_cast<UnboundedHelloWorld*>(data);\n+\n+        // Object that manages the raw buffer.\n+        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);\n+\n+        // Object that deserializes the data.\n+        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN\n+#if FASTCDR_VERSION_MAJOR == 1\n+                , eprosima::fastcdr::Cdr::CdrType::DDS_CDR\n+#endif // FASTCDR_VERSION_MAJOR == 1\n+                );\n+\n+        // Deserialize encapsulation.\n+        deser.read_encapsulation();\n+        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n+\n+        // Deserialize the object.\n+        deser >> *p_type;\n+    }\n+    catch (eprosima::fastcdr::exception::Exception& /*exception*/)\n+    {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+std::function<uint32_t()> UnboundedHelloWorldPubSubType::getSerializedSizeProvider(\n+        void* data,\n+        DataRepresentationId_t data_representation)\n+{\n+    return [data, data_representation]() -> uint32_t\n+           {\n+#if FASTCDR_VERSION_MAJOR == 1\n+               static_cast<void>(data_representation);\n+               return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<UnboundedHelloWorld*>(data))) +\n+                      4u /*encapsulation*/;\n+#else\n+               try\n+               {\n+                   eprosima::fastcdr::CdrSizeCalculator calculator(\n+                       data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?\n+                       eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);\n+                   size_t current_alignment {0};\n+                   return static_cast<uint32_t>(calculator.calculate_serialized_size(\n+                               *static_cast<UnboundedHelloWorld*>(data), current_alignment)) +\n+                           4u /*encapsulation*/;\n+               }\n+               catch (eprosima::fastcdr::exception::Exception& /*exception*/)\n+               {\n+                   return 0;\n+               }\n+#endif // FASTCDR_VERSION_MAJOR == 1\n+           };\n+}\n+\n+void* UnboundedHelloWorldPubSubType::createData()\n+{\n+    return reinterpret_cast<void*>(new UnboundedHelloWorld());\n+}\n+\n+void UnboundedHelloWorldPubSubType::deleteData(\n+        void* data)\n+{\n+    delete(reinterpret_cast<UnboundedHelloWorld*>(data));\n+}\n+\n+bool UnboundedHelloWorldPubSubType::getKey(\n+        void* data,\n+        InstanceHandle_t* handle,\n+        bool force_md5)\n+{\n+    if (!m_isGetKeyDefined)\n+    {\n+        return false;\n+    }\n+\n+    UnboundedHelloWorld* p_type = static_cast<UnboundedHelloWorld*>(data);\n+\n+    // Object that manages the raw buffer.\n+    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n+            UnboundedHelloWorld_max_key_cdr_typesize);\n+\n+    // Object that serializes the data.\n+    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);\n+#if FASTCDR_VERSION_MAJOR == 1\n+    p_type->serializeKey(ser);\n+#else\n+    eprosima::fastcdr::serialize_key(ser, *p_type);\n+#endif // FASTCDR_VERSION_MAJOR == 1\n+    if (force_md5 || UnboundedHelloWorld_max_key_cdr_typesize > 16)\n+    {\n+        m_md5.init();\n+#if FASTCDR_VERSION_MAJOR == 1\n+        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n+#else\n+        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));\n+#endif // FASTCDR_VERSION_MAJOR == 1\n+        m_md5.finalize();\n+        for (uint8_t i = 0; i < 16; ++i)\n+        {\n+            handle->value[i] = m_md5.digest[i];\n+        }\n+    }\n+    else\n+    {\n+        for (uint8_t i = 0; i < 16; ++i)\n+        {\n+            handle->value[i] = m_keyBuffer[i];\n+        }\n+    }\n+    return true;\n+}\n+"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorldPubSubTypes.h",
          "status": "added",
          "additions": 132,
          "deletions": 0,
          "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorldPubSubTypes.h\n+ * This header file contains the declaration of the serialization functions.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+\n+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_PUBSUBTYPES_H_\n+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_PUBSUBTYPES_H_\n+\n+#include <fastdds/dds/core/policy/QosPolicies.hpp>\n+#include <fastdds/dds/topic/TopicDataType.hpp>\n+#include <fastdds/rtps/common/InstanceHandle.h>\n+#include <fastdds/rtps/common/SerializedPayload.h>\n+#include <fastrtps/utils/md5.h>\n+\n+#include \"UnboundedHelloWorld.h\"\n+\n+\n+#if !defined(GEN_API_VER) || (GEN_API_VER != 2)\n+#error \\\n+    Generated UnboundedHelloWorld is not compatible with current installed Fast DDS. Please, regenerate it with fastddsgen.\n+#endif  // GEN_API_VER\n+\n+\n+\n+\n+/*!\n+ * @brief This class represents the TopicDataType of the type UnboundedHelloWorld defined by the user in the IDL file.\n+ * @ingroup UnboundedHelloWorld\n+ */\n+class UnboundedHelloWorldPubSubType : public eprosima::fastdds::dds::TopicDataType\n+{\n+public:\n+\n+    typedef UnboundedHelloWorld type;\n+\n+    eProsima_user_DllExport UnboundedHelloWorldPubSubType();\n+\n+    eProsima_user_DllExport ~UnboundedHelloWorldPubSubType() override;\n+\n+    eProsima_user_DllExport bool serialize(\n+            void* data,\n+            eprosima::fastrtps::rtps::SerializedPayload_t* payload) override\n+    {\n+        return serialize(data, payload, eprosima::fastdds::dds::DEFAULT_DATA_REPRESENTATION);\n+    }\n+\n+    eProsima_user_DllExport bool serialize(\n+            void* data,\n+            eprosima::fastrtps::rtps::SerializedPayload_t* payload,\n+            eprosima::fastdds::dds::DataRepresentationId_t data_representation) override;\n+\n+    eProsima_user_DllExport bool deserialize(\n+            eprosima::fastrtps::rtps::SerializedPayload_t* payload,\n+            void* data) override;\n+\n+    eProsima_user_DllExport std::function<uint32_t()> getSerializedSizeProvider(\n+            void* data) override\n+    {\n+        return getSerializedSizeProvider(data, eprosima::fastdds::dds::DEFAULT_DATA_REPRESENTATION);\n+    }\n+\n+    eProsima_user_DllExport std::function<uint32_t()> getSerializedSizeProvider(\n+            void* data,\n+            eprosima::fastdds::dds::DataRepresentationId_t data_representation) override;\n+\n+    eProsima_user_DllExport bool getKey(\n+            void* data,\n+            eprosima::fastrtps::rtps::InstanceHandle_t* ihandle,\n+            bool force_md5 = false) override;\n+\n+    eProsima_user_DllExport void* createData() override;\n+\n+    eProsima_user_DllExport void deleteData(\n+            void* data) override;\n+\n+#ifdef TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED\n+    eProsima_user_DllExport inline bool is_bounded() const override\n+    {\n+        return false;\n+    }\n+\n+#endif  // TOPIC_DATA_TYPE_API_HAS_IS_BOUNDED\n+\n+#ifdef TOPIC_DATA_TYPE_API_HAS_IS_PLAIN\n+    eProsima_user_DllExport inline bool is_plain() const override\n+    {\n+        return false;\n+    }\n+\n+    eProsima_user_DllExport inline bool is_plain(\n+        eprosima::fastdds::dds::DataRepresentationId_t data_representation) const override\n+    {\n+        static_cast<void>(data_representation);\n+        return false;\n+    }\n+\n+#endif  // TOPIC_DATA_TYPE_API_HAS_IS_PLAIN\n+\n+#ifdef TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE\n+    eProsima_user_DllExport inline bool construct_sample(\n+            void* memory) const override\n+    {\n+        static_cast<void>(memory);\n+        return false;\n+    }\n+\n+#endif  // TOPIC_DATA_TYPE_API_HAS_CONSTRUCT_SAMPLE\n+\n+    MD5 m_md5;\n+    unsigned char* m_keyBuffer;\n+\n+};\n+\n+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_PUBSUBTYPES_H_\n+"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorldv1.cxx",
          "status": "added",
          "additions": 286,
          "deletions": 0,
          "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorld.cpp\n+ * This source file contains the implementation of the described types in the IDL file.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+#ifdef _WIN32\n+// Remove linker warning LNK4221 on Visual Studio\n+namespace {\n+char dummy;\n+}  // namespace\n+#endif  // _WIN32\n+\n+#include \"UnboundedHelloWorld.h\"\n+\n+#if FASTCDR_VERSION_MAJOR == 1\n+\n+#include <fastcdr/Cdr.h>\n+\n+\n+#include <fastcdr/exceptions/BadParamException.h>\n+using namespace eprosima::fastcdr::exception;\n+\n+#include <utility>\n+\n+namespace helper { namespace internal {\n+\n+enum class Size {\n+    UInt8,\n+    UInt16,\n+    UInt32,\n+    UInt64,\n+};\n+\n+constexpr Size get_size(int s) {\n+    return (s <= 8 ) ? Size::UInt8:\n+           (s <= 16) ? Size::UInt16:\n+           (s <= 32) ? Size::UInt32: Size::UInt64;\n+}\n+\n+template<Size s>\n+struct FindTypeH;\n+\n+template<>\n+struct FindTypeH<Size::UInt8> {\n+    using type = std::uint8_t;\n+};\n+\n+template<>\n+struct FindTypeH<Size::UInt16> {\n+    using type = std::uint16_t;\n+};\n+\n+template<>\n+struct FindTypeH<Size::UInt32> {\n+    using type = std::uint32_t;\n+};\n+\n+template<>\n+struct FindTypeH<Size::UInt64> {\n+    using type = std::uint64_t;\n+};\n+}\n+\n+template<int S>\n+struct FindType {\n+    using type = typename internal::FindTypeH<internal::get_size(S)>::type;\n+};\n+}\n+\n+#define UnboundedHelloWorld_max_cdr_typesize 268ULL;\n+\n+\n+\n+\n+UnboundedHelloWorld::UnboundedHelloWorld()\n+{\n+    // unsigned short m_index\n+    m_index = 0;\n+    // /type_d() m_message\n+\n+\n+}\n+\n+UnboundedHelloWorld::~UnboundedHelloWorld()\n+{\n+}\n+\n+UnboundedHelloWorld::UnboundedHelloWorld(\n+        const UnboundedHelloWorld& x)\n+{\n+    m_index = x.m_index;\n+\n+\n+    m_message = x.m_message;\n+\n+}\n+\n+UnboundedHelloWorld::UnboundedHelloWorld(\n+        UnboundedHelloWorld&& x) noexcept\n+{\n+    m_index = x.m_index;\n+\n+\n+    m_message = std::move(x.m_message);\n+\n+}\n+\n+UnboundedHelloWorld& UnboundedHelloWorld::operator =(\n+        const UnboundedHelloWorld& x)\n+{\n+    m_index = x.m_index;\n+\n+\n+    m_message = x.m_message;\n+\n+    return *this;\n+}\n+\n+UnboundedHelloWorld& UnboundedHelloWorld::operator =(\n+        UnboundedHelloWorld&& x) noexcept\n+{\n+    m_index = x.m_index;\n+\n+\n+    m_message = std::move(x.m_message);\n+\n+    return *this;\n+}\n+\n+bool UnboundedHelloWorld::operator ==(\n+        const UnboundedHelloWorld& x) const\n+{\n+    return (m_index == x.m_index &&\n+           m_message == x.m_message);\n+}\n+\n+bool UnboundedHelloWorld::operator !=(\n+        const UnboundedHelloWorld& x) const\n+{\n+    return !(*this == x);\n+}\n+\n+size_t UnboundedHelloWorld::getMaxCdrSerializedSize(\n+        size_t current_alignment)\n+{\n+    static_cast<void>(current_alignment);\n+    return UnboundedHelloWorld_max_cdr_typesize;\n+}\n+\n+size_t UnboundedHelloWorld::getCdrSerializedSize(\n+        const UnboundedHelloWorld& data,\n+        size_t current_alignment)\n+{\n+    (void)data;\n+    size_t initial_alignment = current_alignment;\n+\n+    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);\n+\n+\n+    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;\n+\n+\n+    return current_alignment - initial_alignment;\n+}\n+\n+\n+void UnboundedHelloWorld::serialize(\n+        eprosima::fastcdr::Cdr& scdr) const\n+{\n+    scdr << m_index;\n+\n+    scdr << m_message.c_str();\n+\n+}\n+\n+void UnboundedHelloWorld::deserialize(\n+        eprosima::fastcdr::Cdr& dcdr)\n+{\n+    dcdr >> m_index;\n+\n+\n+\n+    dcdr >> m_message;\n+\n+\n+}\n+\n+\n+bool UnboundedHelloWorld::isKeyDefined()\n+{\n+    return false;\n+}\n+\n+void UnboundedHelloWorld::serializeKey(\n+        eprosima::fastcdr::Cdr& scdr) const\n+{\n+    (void) scdr;\n+}\n+\n+/*!\n+ * @brief This function sets a value in member index\n+ * @param _index New value for member index\n+ */\n+void UnboundedHelloWorld::index(\n+        uint16_t _index)\n+{\n+    m_index = _index;\n+}\n+\n+/*!\n+ * @brief This function returns the value of member index\n+ * @return Value of member index\n+ */\n+uint16_t UnboundedHelloWorld::index() const\n+{\n+    return m_index;\n+}\n+\n+/*!\n+ * @brief This function returns a reference to member index\n+ * @return Reference to member index\n+ */\n+uint16_t& UnboundedHelloWorld::index()\n+{\n+    return m_index;\n+}\n+\n+\n+/*!\n+ * @brief This function copies the value in member message\n+ * @param _message New value to be copied in member message\n+ */\n+void UnboundedHelloWorld::message(\n+        const std::string& _message)\n+{\n+    m_message = _message;\n+}\n+\n+/*!\n+ * @brief This function moves the value in member message\n+ * @param _message New value to be moved in member message\n+ */\n+void UnboundedHelloWorld::message(\n+        std::string&& _message)\n+{\n+    m_message = std::move(_message);\n+}\n+\n+/*!\n+ * @brief This function returns a constant reference to member message\n+ * @return Constant reference to member message\n+ */\n+const std::string& UnboundedHelloWorld::message() const\n+{\n+    return m_message;\n+}\n+\n+/*!\n+ * @brief This function returns a reference to member message\n+ * @return Reference to member message\n+ */\n+std::string& UnboundedHelloWorld::message()\n+{\n+    return m_message;\n+}\n+\n+\n+\n+\n+#endif // FASTCDR_VERSION_MAJOR == 1"
        },
        {
          "filename": "test/blackbox/types/UnboundedHelloWorldv1.h",
          "status": "added",
          "additions": 244,
          "deletions": 0,
          "patch": "@@ -0,0 +1,244 @@\n+// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*!\n+ * @file UnboundedHelloWorld.h\n+ * This header file contains the declaration of the described types in the IDL file.\n+ *\n+ * This file was generated by the tool fastddsgen.\n+ */\n+\n+#include <fastcdr/config.h>\n+\n+#if FASTCDR_VERSION_MAJOR == 1\n+\n+#ifndef _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_\n+#define _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_\n+\n+\n+#include <fastrtps/utils/fixed_size_string.hpp>\n+\n+#include <array>\n+#include <bitset>\n+#include <cstdint>\n+#include <map>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+#if defined(_WIN32)\n+#if defined(EPROSIMA_USER_DLL_EXPORT)\n+#define eProsima_user_DllExport __declspec( dllexport )\n+#else\n+#define eProsima_user_DllExport\n+#endif  // EPROSIMA_USER_DLL_EXPORT\n+#else\n+#define eProsima_user_DllExport\n+#endif  // _WIN32\n+\n+#if defined(_WIN32)\n+#if defined(EPROSIMA_USER_DLL_EXPORT)\n+#if defined(UNBOUNDEDHELLOWORLD_SOURCE)\n+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllexport )\n+#else\n+#define UNBOUNDEDHELLOWORLD_DllAPI __declspec( dllimport )\n+#endif // UNBOUNDEDHELLOWORLD_SOURCE\n+#else\n+#define UNBOUNDEDHELLOWORLD_DllAPI\n+#endif  // EPROSIMA_USER_DLL_EXPORT\n+#else\n+#define UNBOUNDEDHELLOWORLD_DllAPI\n+#endif // _WIN32\n+\n+namespace eprosima {\n+namespace fastcdr {\n+class Cdr;\n+} // namespace fastcdr\n+} // namespace eprosima\n+\n+\n+\n+\n+\n+/*!\n+ * @brief This class represents the structure UnboundedHelloWorld defined by the user in the IDL file.\n+ * @ingroup UnboundedHelloWorld\n+ */\n+class UnboundedHelloWorld\n+{\n+public:\n+\n+    /*!\n+     * @brief Default constructor.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld();\n+\n+    /*!\n+     * @brief Default destructor.\n+     */\n+    eProsima_user_DllExport ~UnboundedHelloWorld();\n+\n+    /*!\n+     * @brief Copy constructor.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld(\n+            const UnboundedHelloWorld& x);\n+\n+    /*!\n+     * @brief Move constructor.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld(\n+            UnboundedHelloWorld&& x) noexcept;\n+\n+    /*!\n+     * @brief Copy assignment.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld& operator =(\n+            const UnboundedHelloWorld& x);\n+\n+    /*!\n+     * @brief Move assignment.\n+     * @param x Reference to the object UnboundedHelloWorld that will be copied.\n+     */\n+    eProsima_user_DllExport UnboundedHelloWorld& operator =(\n+            UnboundedHelloWorld&& x) noexcept;\n+\n+    /*!\n+     * @brief Comparison operator.\n+     * @param x UnboundedHelloWorld object to compare.\n+     */\n+    eProsima_user_DllExport bool operator ==(\n+            const UnboundedHelloWorld& x) const;\n+\n+    /*!\n+     * @brief Comparison operator.\n+     * @param x UnboundedHelloWorld object to compare.\n+     */\n+    eProsima_user_DllExport bool operator !=(\n+            const UnboundedHelloWorld& x) const;\n+\n+    /*!\n+     * @brief This function sets a value in member index\n+     * @param _index New value for member index\n+     */\n+    eProsima_user_DllExport void index(\n+            uint16_t _index);\n+\n+    /*!\n+     * @brief This function returns the value of member index\n+     * @return Value of member index\n+     */\n+    eProsima_user_DllExport uint16_t index() const;\n+\n+    /*!\n+     * @brief This function returns a reference to member index\n+     * @return Reference to member index\n+     */\n+    eProsima_user_DllExport uint16_t& index();\n+\n+\n+    /*!\n+     * @brief This function copies the value in member message\n+     * @param _message New value to be copied in member message\n+     */\n+    eProsima_user_DllExport void message(\n+            const std::string& _message);\n+\n+    /*!\n+     * @brief This function moves the value in member message\n+     * @param _message New value to be moved in member message\n+     */\n+    eProsima_user_DllExport void message(\n+            std::string&& _message);\n+\n+    /*!\n+     * @brief This function returns a constant reference to member message\n+     * @return Constant reference to member message\n+     */\n+    eProsima_user_DllExport const std::string& message() const;\n+\n+    /*!\n+     * @brief This function returns a reference to member message\n+     * @return Reference to member message\n+     */\n+    eProsima_user_DllExport std::string& message();\n+\n+\n+    /*!\n+    * @brief This function returns the maximum serialized size of an object\n+    * depending on the buffer alignment.\n+    * @param current_alignment Buffer alignment.\n+    * @return Maximum serialized size.\n+    */\n+    eProsima_user_DllExport static size_t getMaxCdrSerializedSize(\n+            size_t current_alignment = 0);\n+\n+    /*!\n+     * @brief This function returns the serialized size of a data depending on the buffer alignment.\n+     * @param data Data which is calculated its serialized size.\n+     * @param current_alignment Buffer alignment.\n+     * @return Serialized size.\n+     */\n+    eProsima_user_DllExport static size_t getCdrSerializedSize(\n+            const UnboundedHelloWorld& data,\n+            size_t current_alignment = 0);\n+\n+\n+\n+    /*!\n+     * @brief This function serializes an object using CDR serialization.\n+     * @param cdr CDR serialization object.\n+     */\n+    eProsima_user_DllExport void serialize(\n+            eprosima::fastcdr::Cdr& cdr) const;\n+\n+    /*!\n+     * @brief This function deserializes an object using CDR serialization.\n+     * @param cdr CDR serialization object.\n+     */\n+    eProsima_user_DllExport void deserialize(\n+            eprosima::fastcdr::Cdr& cdr);\n+\n+\n+\n+\n+    /*!\n+    * @brief This function tells you if the Key has been defined for this type\n+    */\n+    eProsima_user_DllExport static bool isKeyDefined();\n+\n+    /*!\n+    * @brief This function serializes the key members of an object using CDR serialization.\n+    * @param cdr CDR serialization object.\n+    */\n+    eProsima_user_DllExport void serializeKey(\n+            eprosima::fastcdr::Cdr& cdr) const;\n+\n+\n+private:\n+\n+    uint16_t m_index;\n+    std::string m_message;\n+\n+};\n+\n+\n+#endif // _FAST_DDS_GENERATED_UNBOUNDEDHELLOWORLD_H_\n+\n+\n+\n+#endif // FASTCDR_VERSION_MAJOR == 1"
        },
        {
          "filename": "test/blackbox/utils/data_generators.cpp",
          "status": "modified",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -277,3 +277,24 @@ std::list<KeyedData1mb> default_keyeddata300kb_data_generator(\n \n     return returnedValue;\n }\n+\n+std::list<UnboundedHelloWorld> default_unbounded_helloworld_data_generator(\n+        size_t max)\n+{\n+    uint16_t index = 1;\n+    size_t maximum = max ? max : 10;\n+    std::list<UnboundedHelloWorld> returnedValue(maximum);\n+\n+    std::generate(returnedValue.begin(), returnedValue.end(), [&index]\n+            {\n+                UnboundedHelloWorld hello;\n+                hello.index(index);\n+                std::stringstream ss;\n+                ss << \"HelloWorld \" << index;\n+                hello.message(ss.str());\n+                ++index;\n+                return hello;\n+            });\n+\n+    return returnedValue;\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 16,
        "unique_directories": 6,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "74d8e279a4b18b5b525e64116aad112860dffcb9",
            "date": "2025-01-13T12:01:42Z",
            "author_login": "MiguelCompany"
          },
          {
            "sha": "490e80b0725e9e354726dadf5e5cdd855535f32c",
            "date": "2025-01-13T11:53:00Z",
            "author_login": "MiguelCompany"
          },
          {
            "sha": "25b117fcf5feaea8d4a0529e1a2d6bdded255cfd",
            "date": "2025-01-13T06:30:07Z",
            "author_login": "EugenioCollado"
          },
          {
            "sha": "5fc77861df383a7e94691295f7b07fdaa50f9402",
            "date": "2025-01-10T09:17:41Z",
            "author_login": "EugenioCollado"
          },
          {
            "sha": "b53a3899e035dcb3bc8c39d392a66a3a236bc4bb",
            "date": "2025-01-09T15:14:43Z",
            "author_login": "fujitatomoya"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.6,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-122",
    "description": "eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.14.0, 2.13.4, 2.12.3, 2.10.4, and 2.6.8, manipulated DATA Submessage can cause a heap overflow error in the Fast-DDS process, causing the process to be terminated remotely. Additionally, the payload_size in the DATA Submessage packet is declared as uint32_t. When a negative number, such as -1, is input into this variable, it results in an Integer Overflow (for example, -1 gets converted to 0xFFFFFFFF). This eventually leads to a heap-buffer-overflow, causing the program to terminate. Versions 2.14.0, 2.13.4, 2.12.3, 2.10.4, and 2.6.8 contain a fix for this issue.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-20T20:15:08.893",
    "last_modified": "2024-11-21T09:06:03.257",
    "fix_date": "2024-03-12T08:34:01Z"
  },
  "references": [
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/355706386f4af9ce74125eeec3c449b06113112b",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/security/advisories/GHSA-9m2j-qw67-ph4w",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/commit/355706386f4af9ce74125eeec3c449b06113112b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/eProsima/Fast-DDS/security/advisories/GHSA-9m2j-qw67-ph4w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.873397",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Fast-DDS",
    "owner": "eProsima",
    "created_at": "2014-05-29T14:36:15Z",
    "updated_at": "2025-01-14T10:05:06Z",
    "pushed_at": "2025-01-14T11:56:33Z",
    "size": 136008,
    "stars": 2273,
    "forks": 790,
    "open_issues": 127,
    "watchers": 2273,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "2.6.x"
    ],
    "languages": {
      "C++": 46757167,
      "C": 9849654,
      "CMake": 579263,
      "Python": 224282,
      "CSS": 28054,
      "Shell": 13873,
      "Makefile": 5345,
      "HTML": 2698,
      "Dockerfile": 1683,
      "Batchfile": 1395,
      "PowerShell": 954
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:10:57.643175"
  }
}