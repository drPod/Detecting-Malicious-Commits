{
  "cve_id": "CVE-2024-28867",
  "github_data": {
    "repository": "swift-server/swift-prometheus",
    "fix_commit": "bfcd4bbfabe11aae4b035424ee9724582e288501",
    "related_commits": [
      "bfcd4bbfabe11aae4b035424ee9724582e288501",
      "bfcd4bbfabe11aae4b035424ee9724582e288501"
    ],
    "patch_url": "https://github.com/swift-server/swift-prometheus/commit/bfcd4bbfabe11aae4b035424ee9724582e288501.patch",
    "fix_commit_details": {
      "sha": "bfcd4bbfabe11aae4b035424ee9724582e288501",
      "commit_date": "2024-03-29T07:02:23Z",
      "author": {
        "login": "fabianfett",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-x768-cvr2-345r",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 215,
        "additions": 211,
        "deletions": 4
      },
      "files": [
        {
          "filename": "Sources/Prometheus/PrometheusCollectorRegistry.swift",
          "status": "modified",
          "additions": 116,
          "deletions": 4,
          "patch": "@@ -73,7 +73,8 @@ public final class PrometheusCollectorRegistry: Sendable {\n     /// - Parameter name: A name to identify ``Counter``'s value.\n     /// - Returns: A ``Counter`` that is registered with this ``PrometheusCollectorRegistry``\n     public func makeCounter(name: String) -> Counter {\n-        self.box.withLockedValue { store -> Counter in\n+        let name = name.ensureValidMetricName()\n+        return self.box.withLockedValue { store -> Counter in\n             guard let value = store[name] else {\n                 let counter = Counter(name: name, labels: [])\n                 store[name] = .counter(counter)\n@@ -106,6 +107,9 @@ public final class PrometheusCollectorRegistry: Sendable {\n             return self.makeCounter(name: name)\n         }\n \n+        let name = name.ensureValidMetricName()\n+        let labels = labels.ensureValidLabelNames()\n+\n         return self.box.withLockedValue { store -> Counter in\n             guard let value = store[name] else {\n                 let labelNames = labels.allLabelNames\n@@ -154,7 +158,8 @@ public final class PrometheusCollectorRegistry: Sendable {\n     /// - Parameter name: A name to identify ``Gauge``'s value.\n     /// - Returns: A ``Gauge`` that is registered with this ``PrometheusCollectorRegistry``\n     public func makeGauge(name: String) -> Gauge {\n-        self.box.withLockedValue { store -> Gauge in\n+        let name = name.ensureValidMetricName()\n+        return self.box.withLockedValue { store -> Gauge in\n             guard let value = store[name] else {\n                 let gauge = Gauge(name: name, labels: [])\n                 store[name] = .gauge(gauge)\n@@ -187,6 +192,9 @@ public final class PrometheusCollectorRegistry: Sendable {\n             return self.makeGauge(name: name)\n         }\n \n+        let name = name.ensureValidMetricName()\n+        let labels = labels.ensureValidLabelNames()\n+\n         return self.box.withLockedValue { store -> Gauge in\n             guard let value = store[name] else {\n                 let labelNames = labels.allLabelNames\n@@ -236,7 +244,8 @@ public final class PrometheusCollectorRegistry: Sendable {\n     /// - Parameter buckets: Define the buckets that shall be used within the ``DurationHistogram``\n     /// - Returns: A ``DurationHistogram`` that is registered with this ``PrometheusCollectorRegistry``\n     public func makeDurationHistogram(name: String, buckets: [Duration]) -> DurationHistogram {\n-        self.box.withLockedValue { store -> DurationHistogram in\n+        let name = name.ensureValidMetricName()\n+        return self.box.withLockedValue { store -> DurationHistogram in\n             guard let value = store[name] else {\n                 let gauge = DurationHistogram(name: name, labels: [], buckets: buckets)\n                 store[name] = .durationHistogram(gauge)\n@@ -274,6 +283,9 @@ public final class PrometheusCollectorRegistry: Sendable {\n             return self.makeDurationHistogram(name: name, buckets: buckets)\n         }\n \n+        let name = name.ensureValidMetricName()\n+        let labels = labels.ensureValidLabelNames()\n+\n         return self.box.withLockedValue { store -> DurationHistogram in\n             guard let value = store[name] else {\n                 let labelNames = labels.allLabelNames\n@@ -335,7 +347,8 @@ public final class PrometheusCollectorRegistry: Sendable {\n     /// - Parameter buckets: Define the buckets that shall be used within the ``ValueHistogram``\n     /// - Returns: A ``ValueHistogram`` that is registered with this ``PrometheusCollectorRegistry``\n     public func makeValueHistogram(name: String, buckets: [Double]) -> ValueHistogram {\n-        self.box.withLockedValue { store -> ValueHistogram in\n+        let name = name.ensureValidMetricName()\n+        return self.box.withLockedValue { store -> ValueHistogram in\n             guard let value = store[name] else {\n                 let gauge = ValueHistogram(name: name, labels: [], buckets: buckets)\n                 store[name] = .valueHistogram(gauge)\n@@ -364,6 +377,9 @@ public final class PrometheusCollectorRegistry: Sendable {\n             return self.makeValueHistogram(name: name, buckets: buckets)\n         }\n \n+        let name = name.ensureValidMetricName()\n+        let labels = labels.ensureValidLabelNames()\n+\n         return self.box.withLockedValue { store -> ValueHistogram in\n             guard let value = store[name] else {\n                 let labelNames = labels.allLabelNames\n@@ -560,6 +576,14 @@ extension [(String, String)] {\n         result = result.sorted()\n         return result\n     }\n+\n+    fileprivate func ensureValidLabelNames() -> [(String, String)] {\n+        if self.allSatisfy({ $0.0.isValidLabelName() }) {\n+            return self\n+        } else {\n+            return self.map { ($0.ensureValidLabelName(), $1) }\n+        }\n+    }\n }\n \n extension [UInt8] {\n@@ -595,3 +619,91 @@ extension PrometheusMetric {\n         return prerendered\n     }\n }\n+\n+extension String {\n+    fileprivate func isValidMetricName() -> Bool {\n+        var isFirstCharacter = true\n+        for ascii in self.utf8 {\n+            defer { isFirstCharacter = false }\n+            switch ascii {\n+            case UInt8(ascii: \"A\")...UInt8(ascii: \"Z\"),\n+                 UInt8(ascii: \"a\")...UInt8(ascii: \"z\"),\n+                 UInt8(ascii: \"_\"), UInt8(ascii: \":\"):\n+                continue\n+            case UInt8(ascii: \"0\"), UInt8(ascii: \"9\"):\n+                if isFirstCharacter {\n+                    return false\n+                }\n+                continue\n+            default:\n+                return false\n+            }\n+        }\n+        return true\n+    }\n+\n+    fileprivate func isValidLabelName() -> Bool {\n+        var isFirstCharacter = true\n+        for ascii in self.utf8 {\n+            defer { isFirstCharacter = false }\n+            switch ascii {\n+            case UInt8(ascii: \"A\")...UInt8(ascii: \"Z\"),\n+                 UInt8(ascii: \"a\")...UInt8(ascii: \"z\"),\n+                 UInt8(ascii: \"_\"):\n+                continue\n+            case UInt8(ascii: \"0\"), UInt8(ascii: \"9\"):\n+                if isFirstCharacter {\n+                    return false\n+                }\n+                continue\n+            default:\n+                return false\n+            }\n+        }\n+        return true\n+    }\n+\n+    fileprivate func ensureValidMetricName() -> String {\n+        if self.isValidMetricName() {\n+            return self\n+        } else {\n+            var new = self\n+            new.fixPrometheusName(allowColon: true)\n+            return new\n+        }\n+    }\n+\n+    fileprivate func ensureValidLabelName() -> String {\n+        if self.isValidLabelName() {\n+            return self\n+        } else {\n+            var new = self\n+            new.fixPrometheusName(allowColon: false)\n+            return new\n+        }\n+    }\n+\n+    fileprivate mutating func fixPrometheusName(allowColon: Bool) {\n+        var startIndex = self.startIndex\n+        var isFirstCharacter = true\n+        while let fixIndex = self[startIndex...].firstIndex(where: { character in\n+            defer { isFirstCharacter = false }\n+            switch character {\n+            case \"A\"...\"Z\", \"a\"...\"z\", \"_\":\n+                return false\n+            case \":\":\n+                return !allowColon\n+            case \"0\"...\"9\":\n+                return isFirstCharacter\n+            default:\n+                return true\n+            }\n+        }) {\n+            self.replaceSubrange(fixIndex...fixIndex, with: CollectionOfOne(\"_\"))\n+            startIndex = fixIndex\n+            if startIndex == self.endIndex {\n+                break\n+            }\n+        }\n+    }\n+}"
        },
        {
          "filename": "Tests/PrometheusTests/ValidNamesTests.swift",
          "status": "added",
          "additions": 95,
          "deletions": 0,
          "patch": "@@ -0,0 +1,95 @@\n+//===----------------------------------------------------------------------===//\n+//\n+// This source file is part of the SwiftPrometheus open source project\n+//\n+// Copyright (c) 2024 SwiftPrometheus project authors\n+// Licensed under Apache License v2.0\n+//\n+// See LICENSE.txt for license information\n+// See CONTRIBUTORS.txt for the list of SwiftPrometheus project authors\n+//\n+// SPDX-License-Identifier: Apache-2.0\n+//\n+//===----------------------------------------------------------------------===//\n+\n+import Prometheus\n+import XCTest\n+\n+final class ValidNamesTests: XCTestCase {\n+    func testCounterWithEmoji() {\n+        let client = PrometheusCollectorRegistry()\n+        let counter = client.makeCounter(name: \"coffee\u2615\ufe0f\", labels: [])\n+        counter.increment()\n+\n+        var buffer = [UInt8]()\n+        client.emit(into: &buffer)\n+        XCTAssertEqual(\n+            String(decoding: buffer, as: Unicode.UTF8.self),\n+            \"\"\"\n+            # TYPE coffee_ counter\n+            coffee_ 1\n+\n+            \"\"\"\n+        )\n+    }\n+\n+    func testIllegalMetricNames() async throws {\n+        let registry = PrometheusCollectorRegistry()\n+\n+        /// Notably, newlines must not allow creating whole new metric root\n+        let tests = [\n+            \"name\",\n+            \"\"\"\n+            name{bad=\"haha\"} 121212121\n+            bad_bad 12321323\n+            \"\"\"\n+        ]\n+\n+        for test in tests {\n+            registry.makeCounter(\n+                name: test,\n+                labels: []\n+            ).increment()\n+        }\n+\n+        var buffer = [UInt8]()\n+        registry.emit(into: &buffer)\n+        XCTAssertEqual(\n+            String(decoding: buffer, as: Unicode.UTF8.self).split(separator: \"\\n\").sorted().joined(separator: \"\\n\"),\n+            \"\"\"\n+            # TYPE name counter\n+            # TYPE name_bad__haha___121212121_bad_bad_12321323 counter\n+            name 1\n+            name_bad__haha___121212121_bad_bad_12321323 1\n+            \"\"\"\n+        )\n+    }\n+\n+    func testIllegalLabelNames() async throws {\n+        let registry = PrometheusCollectorRegistry()\n+\n+        let tests = [\n+            \"\"\"\n+            name{bad=\"haha\"} 121212121\n+            bad_bad 12321323\n+            \"\"\"\n+        ]\n+\n+        for test in tests {\n+            registry.makeCounter(\n+                name: \"metric\",\n+                labels: [(test, \"value\")]\n+            ).increment()\n+        }\n+\n+        var buffer = [UInt8]()\n+        registry.emit(into: &buffer)\n+        XCTAssertEqual(\n+            String(decoding: buffer, as: Unicode.UTF8.self).split(separator: \"\\n\").sorted().joined(separator: \"\\n\"),\n+            \"\"\"\n+            # TYPE metric counter\n+            metric{name_bad__haha___121212121_bad_bad_12321323=\"value\"} 1\n+            \"\"\"\n+        )\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e8010f31a08bc634e36ca7afa8360b4ee54da204",
            "date": "2024-12-18T14:04:47Z",
            "author_login": "FranzBusch"
          },
          {
            "sha": "06a06bd3b4a60690cd9cc2c5e47e9860600b68c5",
            "date": "2024-12-12T13:08:07Z",
            "author_login": "czechboy0"
          },
          {
            "sha": "046eada4f6ec2a1f0e488f2416f6abd5cf9b9d02",
            "date": "2024-11-12T11:51:28Z",
            "author_login": "rnro"
          },
          {
            "sha": "a6dc9869b241035e2e6cebc8a81ad5d3840895d4",
            "date": "2024-07-25T12:18:49Z",
            "author_login": "glbrntt"
          },
          {
            "sha": "b50f8779ebd978522d1b26ad3fbe9f07d67696d5",
            "date": "2024-07-25T12:05:32Z",
            "author_login": "glbrntt"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-74",
    "description": "Swift Prometheus is a Swift client for the Prometheus monitoring system, supporting counters, gauges and histograms. In code which applies _un-sanitized string values into metric names or labels_, an attacker could make use of this and send a `?lang` query parameter containing newlines, `}`  or similar characters which can lead to the attacker taking over the exported format -- including creating unbounded numbers of stored metrics, inflating server memory usage, or causing \"bogus\" metrics. This vulnerability is fixed in2.0.0-alpha.2.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-03-29T15:15:11.180",
    "last_modified": "2024-11-21T09:07:04.590",
    "fix_date": "2024-03-29T07:02:23Z"
  },
  "references": [
    {
      "url": "https://github.com/swift-server/swift-prometheus/commit/bfcd4bbfabe11aae4b035424ee9724582e288501",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/swift-server/swift-prometheus/security/advisories/GHSA-x768-cvr2-345r",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/swift-server/swift-prometheus/commit/bfcd4bbfabe11aae4b035424ee9724582e288501",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/swift-server/swift-prometheus/security/advisories/GHSA-x768-cvr2-345r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.930777",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "swift-prometheus",
    "owner": "swift-server",
    "created_at": "2018-11-17T17:29:02Z",
    "updated_at": "2025-01-07T10:24:09Z",
    "pushed_at": "2024-12-18T14:04:48Z",
    "size": 1259,
    "stars": 149,
    "forks": 33,
    "open_issues": 16,
    "watchers": 149,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Swift": 97354
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T19:04:07.088347"
  }
}