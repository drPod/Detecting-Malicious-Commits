{
  "cve_id": "CVE-2024-29068",
  "github_data": {
    "repository": "snapcore/snapd",
    "fix_commit": "b66fee81606a1c05f965a876ccbaf44174194063",
    "related_commits": [
      "b66fee81606a1c05f965a876ccbaf44174194063",
      "b66fee81606a1c05f965a876ccbaf44174194063"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "b66fee81606a1c05f965a876ccbaf44174194063",
      "commit_date": "2023-09-08T06:52:22Z",
      "author": {
        "login": "ZeyadYasser",
        "type": "User",
        "stats": {
          "total_commits": 112,
          "average_weekly_commits": 0.21132075471698114,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 50
        }
      },
      "commit_message": {
        "title": "many: container validation improvements",
        "length": 95,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 907,
        "additions": 801,
        "deletions": 106
      },
      "files": [
        {
          "filename": "snap/container.go",
          "status": "modified",
          "additions": 164,
          "deletions": 9,
          "patch": "@@ -21,6 +21,7 @@ package snap\n \n import (\n \t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -44,6 +45,12 @@ type Container interface {\n \t// ReadFile returns the content of a single file from the snap.\n \tReadFile(relative string) ([]byte, error)\n \n+\t// ReadLink returns the destination of the named symbolic link.\n+\tReadLink(relative string) (string, error)\n+\n+\t// Lstat is like os.Lstat.\n+\tLstat(relative string) (os.FileInfo, error)\n+\n \t// Walk is like filepath.Walk, without the ordering guarantee.\n \tWalk(relative string, walkFn filepath.WalkFunc) error\n \n@@ -78,6 +85,142 @@ var (\n \tErrMissingPaths = errors.New(\"snap is unusable due to missing files\")\n )\n \n+type symlinkInfo struct {\n+\t// target is the furthest target we could evaluate.\n+\ttarget string\n+\t// targetMode is the mode of the final symlink target.\n+\ttargetMode os.FileMode\n+\t// naiveTarget is the first symlink target.\n+\tnaiveTarget string\n+\t// isExternal determines if the symlink is considered external\n+\t// relative to its container.\n+\tisExternal bool\n+}\n+\n+// evalSymlink follows symlinks inside given container and returns\n+// information about it's target.\n+//\n+// The symlink is followed inside the container until we cannot\n+// continue further either due to absolute symlinks or symlinks\n+// that escape the container.\n+//\n+//       max depth reached?<------\n+//               /\\               \\\n+//            yes  no              \\\n+//            /      \\              \\\n+//           V        V              \\\n+//        error      path             \\\n+//                    \u2502                \\\n+//                    V                 \\\n+//                read target            \\\n+//                    \u2502                   \\\n+//                    V                    \\\n+//               is absolute?               \\\n+//                   /\\                      \\\n+//                yes  no                     \\\n+//                /      \\                     \\\n+//               V        V                     \\\n+//       isExternal     eval relative target     \\\n+//           +               \\                    \\\n+//     return target          V                    \\\n+//                     escapes container?           \\\n+//                           /\\                      \\\n+//                        yes  no                     \\\n+//                       /      \\                      |\n+//                      V        V                     |\n+//              isExternal      is symlink?            |\n+//                   +                /\\               |\n+//             return target       yes  no             \u2502\n+//                                /      \\             \u2502\n+//                               V        V            \u2502\n+//                       !isExternal    path = target  \u2502\n+//                            +             \\----------\u2502\n+//                      return target\n+//\n+func evalSymlink(c Container, path string) (symlinkInfo, error) {\n+\tvar naiveTarget string\n+\n+\tconst maxDepth = 10\n+\tcurrentDepth := 0\n+\tfor currentDepth < maxDepth {\n+\t\tcurrentDepth++\n+\t\ttarget, err := c.ReadLink(path)\n+\t\tif err != nil {\n+\t\t\treturn symlinkInfo{}, err\n+\t\t}\n+\t\t// record first symlink target\n+\t\tif currentDepth == 1 {\n+\t\t\tnaiveTarget = target\n+\t\t}\n+\n+\t\ttarget = filepath.Clean(target)\n+\t\t// don't follow absolute targets\n+\t\tif filepath.IsAbs(target) {\n+\t\t\treturn symlinkInfo{target, os.FileMode(0), naiveTarget, true}, nil\n+\t\t}\n+\n+\t\t// evaluate target relative to symlink directory\n+\t\ttarget = filepath.Join(filepath.Dir(path), target)\n+\n+\t\t// target escapes container, cannot evaluate further, let's return\n+\t\tif strings.Split(target, string(os.PathSeparator))[0] == \"..\" {\n+\t\t\treturn symlinkInfo{target, os.FileMode(0), naiveTarget, true}, nil\n+\t\t}\n+\n+\t\tinfo, err := c.Lstat(target)\n+\t\t// cannot follow bad targets\n+\t\tif err != nil {\n+\t\t\treturn symlinkInfo{}, err\n+\t\t}\n+\n+\t\t// non-symlink, let's return\n+\t\tif info.Mode().Type() != os.ModeSymlink {\n+\t\t\treturn symlinkInfo{target, info.Mode(), naiveTarget, false}, nil\n+\t\t}\n+\n+\t\t// we have another symlink\n+\t\tpath = target\n+\t}\n+\n+\treturn symlinkInfo{}, fmt.Errorf(\"too many levels of symbolic links\")\n+}\n+\n+func shouldValidateSymlink(path string) bool {\n+\t// we only check meta directory for now\n+\tpathTokens := strings.Split(path, string(os.PathSeparator))\n+\tif pathTokens[0] == \"meta\" {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func evalAndValidateSymlink(c Container, path string) (symlinkInfo, error) {\n+\tpathTokens := strings.Split(path, string(os.PathSeparator))\n+\t// check if meta directory is a symlink\n+\tif len(pathTokens) == 1 && pathTokens[0] == \"meta\" {\n+\t\treturn symlinkInfo{}, fmt.Errorf(\"meta directory cannot be a symlink\")\n+\t}\n+\n+\tinfo, err := evalSymlink(c, path)\n+\tif err != nil {\n+\t\treturn symlinkInfo{}, err\n+\t}\n+\n+\tif info.isExternal {\n+\t\treturn symlinkInfo{}, fmt.Errorf(\"external symlink found: %s -> %s\", path, info.naiveTarget)\n+\t}\n+\n+\t// symlinks like this don't look innocent\n+\tbadTargets := []string{\".\", \"meta\"}\n+\tfor _, badTarget := range badTargets {\n+\t\tif info.target == badTarget {\n+\t\t\treturn symlinkInfo{}, fmt.Errorf(\"bad symlink found: %s -> %s\", path, info.naiveTarget)\n+\t\t}\n+\t}\n+\n+\treturn info, nil\n+}\n+\n // ValidateComponentContainer does a minimal quick check on a snap component container.\n func ValidateComponentContainer(c Container, contName string, logf func(format string, v ...interface{})) error {\n \tneedsrx := map[string]bool{\n@@ -196,20 +339,32 @@ func validateContainer(c Container, needsrx, needsx, needsr, needsf, noskipd map\n \t\t\treturn nil\n \t\t}\n \n-\t\tif needsrx[path] || mode.IsDir() {\n+\t\tif mode&os.ModeSymlink != 0 && shouldValidateSymlink(path) {\n+\t\t\tsymlinkInfo, err := evalAndValidateSymlink(c, path)\n+\t\t\tif err != nil {\n+\t\t\t\tlogf(\"%s\", err)\n+\t\t\t\thasBadModes = true\n+\t\t\t} else {\n+\t\t\t\t// use target mode for checks below\n+\t\t\t\tmode = symlinkInfo.targetMode\n+\t\t\t}\n+\t\t}\n+\n+\t\tif mode.IsDir() {\n \t\t\tif mode.Perm()&0555 != 0555 {\n \t\t\t\tlogf(\"in %s %q: %q should be world-readable and executable, and isn't: %s\", contType, name, path, mode)\n \t\t\t\thasBadModes = true\n \t\t\t}\n \t\t} else {\n-\t\t\tif needsf[path] {\n-\t\t\t\t// this assumes that if it's a symlink it's OK. Arguably we\n-\t\t\t\t// should instead follow the symlink.  We'd have to expose\n-\t\t\t\t// Lstat(), and guard against loops, and ...  huge can of\n-\t\t\t\t// worms, and as this validator is meant as a developer aid\n-\t\t\t\t// more than anything else, not worth it IMHO (as I can't\n-\t\t\t\t// imagine this happening by accident).\n-\t\t\t\tif mode&(os.ModeDir|os.ModeNamedPipe|os.ModeSocket|os.ModeDevice) != 0 {\n+\t\t\tif needsrx[path] {\n+\t\t\t\tif mode.Perm()&0555 != 0555 {\n+\t\t\t\t\tlogf(\"in snap %q: %q should be world-readable and executable, and isn't: %s\", name, path, mode)\n+\t\t\t\t\thasBadModes = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// XXX: do we need to match other directories?\n+\t\t\tif needsf[path] || strings.HasPrefix(path, \"meta/\") {\n+\t\t\t\tif mode&(os.ModeNamedPipe|os.ModeSocket|os.ModeDevice) != 0 {\n \t\t\t\t\tlogf(\"in %s %q: %q should be a regular file (or a symlink) and isn't\", contType, name, path)\n \t\t\t\t\thasBadModes = true\n \t\t\t\t}"
        },
        {
          "filename": "snap/container_test.go",
          "status": "modified",
          "additions": 375,
          "deletions": 96,
          "patch": "@@ -20,7 +20,7 @@\n package snap_test\n \n import (\n-\t\"io/ioutil\"\n+\t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"syscall\"\n@@ -29,6 +29,7 @@ import (\n \n \t\"github.com/snapcore/snapd/snap\"\n \t\"github.com/snapcore/snapd/snap/snapdir\"\n+\t\"github.com/snapcore/snapd/snap/squashfs\"\n \t\"github.com/snapcore/snapd/testutil\"\n )\n \n@@ -38,13 +39,34 @@ var _ = Suite(&FileSuite{})\n \n type validateSuite struct {\n \ttestutil.BaseTest\n+\n+\tsnapDirPath      string\n+\tsnapSquashfsPath string\n+\tcontainerType    string\n }\n \n-var _ = Suite(&validateSuite{})\n+type dirContainerValidateSuite struct{ validateSuite }\n+type squashfsContainerValidateSuite struct{ validateSuite }\n+\n+var _ = Suite(&dirContainerValidateSuite{validateSuite{containerType: \"dir\"}})\n+var _ = Suite(&squashfsContainerValidateSuite{validateSuite{containerType: \"squashfs\"}})\n \n func discard(string, ...interface{}) {}\n \n+func (s *validateSuite) container() snap.Container {\n+\tif s.containerType == \"squashfs\" {\n+\t\tsnap := squashfs.New(s.snapSquashfsPath)\n+\t\tif err := snap.Build(s.snapDirPath, nil); err != nil {\n+\t\t\tpanic(fmt.Sprintf(\"internal error: couldn't build snap: %s\", err))\n+\t\t}\n+\t\treturn snap\n+\t}\n+\treturn snapdir.New(s.snapDirPath)\n+}\n+\n func (s *validateSuite) SetUpTest(c *C) {\n+\ts.snapDirPath = c.MkDir()\n+\ts.snapSquashfsPath = filepath.Join(c.MkDir(), \"foo.snap\")\n \ts.BaseTest.SetUpTest(c)\n \ts.BaseTest.AddCleanup(snap.MockSanitizePlugsSlots(func(snapInfo *snap.Info) {}))\n }\n@@ -57,154 +79,143 @@ func (s *validateSuite) TestValidateContainerReallyEmptyFails(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := c.MkDir()\n-\t// the snap dir is a 0700 directory with nothing in it\n-\n+\tcontainer := s.container()\n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(snapdir.New(d), info, discard)\n+\terr = snap.ValidateSnapContainer(container, info, discard)\n \tc.Check(err, Equals, snap.ErrMissingPaths)\n \n-\terr = snap.ValidateComponentContainer(snapdir.New(d), \"empty-snap+comp.comp\", discard)\n+\terr = snap.ValidateComponentContainer(container, \"empty-snap+comp.comp\", discard)\n \tc.Check(err, Equals, snap.ErrMissingPaths)\n }\n \n func (s *validateSuite) TestValidateContainerEmptyButBadPermFails(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := c.MkDir()\n-\n-\tstat, err := os.Stat(d)\n+\tstat, err := os.Stat(s.snapDirPath)\n \tc.Assert(err, IsNil)\n \tc.Check(stat.Mode().Perm(), Equals, os.FileMode(0700)) // just to be sure\n \n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d, \"meta\", \"snap.yaml\"), nil, 0444), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"meta\", \"snap.yaml\"), nil, 0444), IsNil)\n \n \t// snapdir has /meta/snap.yaml, but / is 0700\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(snapdir.New(d), info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n func (s *validateSuite) TestValidateComponentContainerEmptyButBadPermFails(c *C) {\n-\td := c.MkDir()\n-\n-\tstat, err := os.Stat(d)\n+\tstat, err := os.Stat(s.snapDirPath)\n \tc.Assert(err, IsNil)\n \tc.Check(stat.Mode().Perm(), Equals, os.FileMode(0700)) // just to be sure\n \n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d, \"meta\", \"component.yaml\"), nil, 0444), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"meta\", \"component.yaml\"), nil, 0444), IsNil)\n \n \t// snapdir has /meta/component.yaml, but / is 0700\n \n-\terr = snap.ValidateComponentContainer(snapdir.New(d), \"empty-snap+comp.comp\", discard)\n+\terr = snap.ValidateComponentContainer(s.container(), \"empty-snap+comp.comp\", discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n func (s *validateSuite) TestValidateContainerMissingSnapYamlFails(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := c.MkDir()\n-\tc.Assert(os.Chmod(d, 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n+\tcontainer := s.container()\n+\tc.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n \n \t// snapdir's / and /meta are 0755 (i.e. OK), but no /meta/snap.yaml\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(snapdir.New(d), info, discard)\n+\terr = snap.ValidateSnapContainer(container, info, discard)\n \tc.Check(err, Equals, snap.ErrMissingPaths)\n \n \t// component's / and /meta are 0755 (i.e. OK), but no /meta/component.yaml\n \n-\terr = snap.ValidateComponentContainer(snapdir.New(d), \"empty-snap+comp.comp\", discard)\n+\terr = snap.ValidateComponentContainer(container, \"empty-snap+comp.comp\", discard)\n \tc.Check(err, Equals, snap.ErrMissingPaths)\n }\n \n func (s *validateSuite) TestValidateContainerSnapYamlBadPermsFails(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := c.MkDir()\n-\tc.Assert(os.Chmod(d, 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d, \"meta\", \"snap.yaml\"), nil, 0), IsNil)\n+\tc.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"meta\", \"snap.yaml\"), nil, 0), IsNil)\n \n \t// snapdir's / and /meta are 0755 (i.e. OK),\n \t// /meta/snap.yaml exists, but isn't readable\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(snapdir.New(d), info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n func (s *validateSuite) TestValidateComponentContainerSnapYamlBadPermsFails(c *C) {\n-\td := c.MkDir()\n-\tc.Assert(os.Chmod(d, 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d, \"meta\", \"component.yaml\"), nil, 0), IsNil)\n+\tc.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"meta\", \"component.yaml\"), nil, 0), IsNil)\n \n \t// components's / and /meta are 0755 (i.e. OK),\n \t// /meta/component.yaml exists, but isn't readable\n \n-\terr := snap.ValidateComponentContainer(snapdir.New(d), \"empty-snap+comp.comp\", discard)\n+\terr := snap.ValidateComponentContainer(s.container(), \"empty-snap+comp.comp\", discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n func (s *validateSuite) TestValidateContainerSnapYamlNonRegularFails(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := c.MkDir()\n-\tc.Assert(os.Chmod(d, 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(syscall.Mkfifo(filepath.Join(d, \"meta\", \"snap.yaml\"), 0444), IsNil)\n+\tc.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\tc.Assert(syscall.Mkfifo(filepath.Join(s.snapDirPath, \"meta\", \"snap.yaml\"), 0444), IsNil)\n \n \t// snapdir's / and /meta are 0755 (i.e. OK),\n \t// /meta/snap.yaml exists, is readable, but isn't a file\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(snapdir.New(d), info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n-// emptyContainer returns a minimal container that passes\n-// ValidateContainer: / and /meta exist and are 0755, and\n-// /meta/snap.yaml is a regular world-readable file.\n-func emptyContainer(c *C) *snapdir.SnapDir {\n-\td := c.MkDir()\n-\tc.Assert(os.Chmod(d, 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d, \"meta\", \"snap.yaml\"), nil, 0444), IsNil)\n-\treturn snapdir.New(d)\n+// bootstrapEmptyContainer creates a minimal container directory under\n+// s.snapDirPath that passes ValidateContainer: / and /meta exist and\n+// are 0755, and /meta/snap.yaml is a regular world-readable file.\n+func (s *validateSuite) bootstrapEmptyContainer(c *C) {\n+\tc.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"meta\", \"snap.yaml\"), nil, 0444), IsNil)\n }\n \n func (s *validateSuite) TestValidateContainerMinimalOKPermWorks(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := emptyContainer(c)\n+\ts.bootstrapEmptyContainer(c)\n \t// snapdir's / and /meta are 0755 (i.e. OK),\n \t// /meta/snap.yaml exists, is readable regular file\n \t// (this could be considered a test of emptyContainer)\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, IsNil)\n }\n \n@@ -215,13 +226,13 @@ apps:\n  foo:\n   command: foo\n `\n-\td := emptyContainer(c)\n+\ts.bootstrapEmptyContainer(c)\n \t// snapdir is empty: no apps\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrMissingPaths)\n }\n \n@@ -232,15 +243,15 @@ apps:\n  foo:\n   command: foo\n `\n-\td := emptyContainer(c)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"foo\"), nil, 0444), IsNil)\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"foo\"), nil, 0444), IsNil)\n \n \t// snapdir contains the app, but the app is not executable\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n@@ -251,16 +262,16 @@ apps:\n  foo:\n   command: apps/foo\n `\n-\td := emptyContainer(c)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"apps\"), 0700), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"apps\", \"foo\"), nil, 0555), IsNil)\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"apps\"), 0700), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"apps\", \"foo\"), nil, 0555), IsNil)\n \n \t// snapdir contains executable app, but path to executable isn't rx\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n@@ -272,16 +283,16 @@ apps:\n   command: svcs/bar\n   daemon: simple\n `\n-\td := emptyContainer(c)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"svcs\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"svcs\", \"bar\"), nil, 0), IsNil)\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"svcs\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"svcs\", \"bar\"), nil, 0), IsNil)\n \n \t// snapdir contains service, but it isn't executable\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n@@ -293,18 +304,18 @@ apps:\n   command: cmds/foo\n   completer: comp/foo.sh\n `\n-\td := emptyContainer(c)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"cmds\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"cmds\", \"foo\"), nil, 0555), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"comp\"), 0755), IsNil)\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"cmds\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"cmds\", \"foo\"), nil, 0555), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"comp\"), 0755), IsNil)\n \n \t// snapdir contains executable app, in a rx path, but refers\n \t// to a completer that doesn't exist\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrMissingPaths)\n }\n \n@@ -316,15 +327,15 @@ apps:\n  foo:\n   command: ../../../bin/echo\n `\n-\td := emptyContainer(c)\n+\ts.bootstrapEmptyContainer(c)\n \n \t// snapdir does not contain the app, but the command is\n \t// \"outside\" so it might be OK\n \n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, IsNil)\n }\n \n@@ -336,8 +347,8 @@ apps:\n  foo:\n   command: foo\n `\n-\td := emptyContainer(c)\n-\tfn := filepath.Join(d.Path(), \"foo\")\n+\ts.bootstrapEmptyContainer(c)\n+\tfn := filepath.Join(s.snapDirPath, \"foo\")\n \tc.Assert(os.WriteFile(fn+\".real\", nil, 0444), IsNil)\n \tc.Assert(os.Symlink(fn+\".real\", fn), IsNil)\n \n@@ -346,7 +357,7 @@ apps:\n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, Equals, snap.ErrBadModes)\n }\n \n@@ -357,8 +368,8 @@ apps:\n  foo:\n   command: foo\n `\n-\td := emptyContainer(c)\n-\tfn := filepath.Join(d.Path(), \"foo\")\n+\ts.bootstrapEmptyContainer(c)\n+\tfn := filepath.Join(s.snapDirPath, \"foo\")\n \tc.Assert(os.WriteFile(fn+\".real\", nil, 0555), IsNil)\n \tc.Assert(os.Symlink(fn+\".real\", fn), IsNil)\n \n@@ -367,10 +378,149 @@ apps:\n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n+\tc.Check(err, IsNil)\n+}\n+\n+func (s *validateSuite) TestValidateContainerSymlinksMetaBadTargetMode(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\texternalSymlink := filepath.Join(s.snapDirPath, \"meta\", \"symlink\")\n+\t// target is has bad mode\n+\tconst mode = os.FileMode(0711)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"target\"), nil, mode), IsNil)\n+\tc.Assert(os.Symlink(\"../target\", externalSymlink), IsNil)\n+\n+\tcontainer := s.container()\n+\n+\tsymlinkInfo, err := snap.EvalAndValidateSymlink(container, \"meta/symlink\")\n+\tc.Check(err, IsNil)\n+\tc.Check(symlinkInfo.Mode(), Equals, mode)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\terr = snap.ValidateSnapContainer(container, info, discard)\n+\tc.Check(err, ErrorMatches, \"snap is unusable due to bad permissions\")\n+}\n+\n+func (s *validateSuite) TestValidateContainerSymlinksMetaBadTargetMode0000(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"meta\"), 0755), IsNil)\n+\texternalSymlink := filepath.Join(s.snapDirPath, \"meta\", \"symlink\")\n+\t// target is has bad mode\n+\tconst mode = os.FileMode(0000)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"target\"), nil, mode), IsNil)\n+\tc.Assert(os.Symlink(\"../target\", externalSymlink), IsNil)\n+\n+\tcontainer := s.container()\n+\n+\tsymlinkInfo, err := snap.EvalAndValidateSymlink(container, \"meta/symlink\")\n+\tc.Check(err, IsNil)\n+\tc.Check(symlinkInfo.Mode(), Equals, mode)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\terr = snap.ValidateSnapContainer(container, info, discard)\n+\tc.Check(err, ErrorMatches, \"snap is unusable due to bad permissions\")\n+}\n+\n+func (s *validateSuite) TestValidateContainerMetaExternalAbsSymlinksFails(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"meta\", \"gui\", \"icons\"), 0755), IsNil)\n+\texternalSymlink := filepath.Join(s.snapDirPath, \"meta\", \"gui\", \"icons\", \"snap.empty-snap.png\")\n+\tc.Assert(os.Symlink(\"/etc/shadow\", externalSymlink), IsNil)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\tmockLogf := func(format string, v ...interface{}) {\n+\t\tmsg := fmt.Sprintf(format, v...)\n+\t\tc.Check(msg, Equals, \"external symlink found: meta/gui/icons/snap.empty-snap.png -> /etc/shadow\")\n+\t}\n+\n+\terr = snap.ValidateSnapContainer(s.container(), info, mockLogf)\n+\tc.Check(err, Equals, snap.ErrBadModes)\n+}\n+\n+func (s *validateSuite) TestValidateContainerMetaExternalRelativeSymlinksFails(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"meta\", \"gui\", \"icons\"), 0755), IsNil)\n+\texternalSymlink := filepath.Join(s.snapDirPath, \"meta\", \"gui\", \"icons\", \"snap.empty-snap.png\")\n+\t// target is cleaned and checked if it escapes beyond path root folder\n+\tc.Assert(os.Symlink(\"1/../../2/../../3/4/../../../../..\", externalSymlink), IsNil)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\tmockLogf := func(format string, v ...interface{}) {\n+\t\tmsg := fmt.Sprintf(format, v...)\n+\t\tc.Check(msg, Equals, \"external symlink found: meta/gui/icons/snap.empty-snap.png -> 1/../../2/../../3/4/../../../../..\")\n+\t}\n+\n+\terr = snap.ValidateSnapContainer(s.container(), info, mockLogf)\n+\tc.Check(err, Equals, snap.ErrBadModes)\n+}\n+\n+func (s *validateSuite) TestValidateContainerMetaExternalRelativeSymlinksOk(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"meta\", \"gui\", \"icons\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"target\"), nil, 0644), IsNil)\n+\texternalSymlink := filepath.Join(s.snapDirPath, \"meta\", \"gui\", \"icons\", \"snap.empty-snap.png\")\n+\t// target is cleaned and checked if it escapes beyond path root folder\n+\tc.Assert(os.Symlink(\"1/../2/../../3/4/../../../../target\", externalSymlink), IsNil)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, IsNil)\n }\n \n+func (s *validateSuite) TestValidateContainerMetaDirectorySymlinksFail(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\tc.Assert(os.Chmod(s.snapDirPath, 0755), IsNil)\n+\t// no need to populate the symlink target with snap.yaml as the validator\n+\t// will fail with ErrMissingPaths even it was added.\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"target\"), 0755), IsNil)\n+\tc.Assert(os.Symlink(\"target\", filepath.Join(s.snapDirPath, \"meta\")), IsNil)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\tmetaDirSymlinkErrFound := false\n+\tmockLogf := func(format string, v ...interface{}) {\n+\t\tmsg := fmt.Sprintf(format, v...)\n+\t\tif msg == \"meta directory cannot be a symlink\" {\n+\t\t\tmetaDirSymlinkErrFound = true\n+\t\t}\n+\t}\n+\n+\terr = snap.ValidateSnapContainer(s.container(), info, mockLogf)\n+\tc.Check(metaDirSymlinkErrFound, Equals, true)\n+\t// the check for missing files precedes check for permission errors, so we\n+\t// check for it instead.\n+\tc.Check(err, Equals, snap.ErrMissingPaths)\n+}\n+\n func (s *validateSuite) TestValidateContainerAppsOK(c *C) {\n \tconst yaml = `name: empty-snap\n version: 1\n@@ -390,18 +540,21 @@ apps:\n   command: comp/foo.sh\n   daemon: simple\n `\n-\td := emptyContainer(c)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"cmds\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"cmds\", \"foo\"), nil, 0555), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"comp\"), 0755), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"comp\", \"foo.sh\"), nil, 0555), IsNil)\n-\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"svcs\"), 0700), IsNil)\n-\tc.Assert(os.WriteFile(filepath.Join(d.Path(), \"svcs\", \"bar\"), nil, 0500), IsNil)\n-\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"garbage\"), 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d.Path(), \"garbage\", \"zero\"), 0), IsNil)\n-\tdefer os.Chmod(filepath.Join(d.Path(), \"garbage\", \"zero\"), 0755)\n+\tif s.containerType == \"squashfs\" {\n+\t\tc.Skip(\"Cannot build snap squashfs with garbge/zero directory permissions\")\n+\t}\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"cmds\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"cmds\", \"foo\"), nil, 0555), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"comp\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"comp\", \"foo.sh\"), nil, 0555), IsNil)\n+\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"svcs\"), 0700), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"svcs\", \"bar\"), nil, 0500), IsNil)\n+\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"garbage\"), 0755), IsNil)\n+\tc.Assert(os.Mkdir(filepath.Join(s.snapDirPath, \"garbage\", \"zero\"), 0), IsNil)\n+\tdefer os.Chmod(filepath.Join(s.snapDirPath, \"garbage\", \"zero\"), 0755)\n \n \t// snapdir contains:\n \t//  * a command that's world-rx, and its directory is\n@@ -421,19 +574,145 @@ apps:\n \tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n \tc.Assert(err, IsNil)\n \n-\terr = snap.ValidateSnapContainer(d, info, discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, IsNil)\n }\n \n-func (s *validateSuite) TestValidateComponentContainer(c *C) {\n-\tconst yaml = `component: empty-snap+test-comp\n+func (s *validateSuite) TestValidateSymlinkLoop(c *C) {\n+\tconst yaml = `name: empty-snap\n+version: 1\n+`\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.Symlink(\"1\", filepath.Join(s.snapDirPath, \"meta\", \"2\")), IsNil)\n+\tc.Assert(os.Symlink(\"2\", filepath.Join(s.snapDirPath, \"meta\", \"3\")), IsNil)\n+\tc.Assert(os.Symlink(\"3\", filepath.Join(s.snapDirPath, \"meta\", \"1\")), IsNil)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n+\n+\tloopFound := false\n+\tmockLogf := func(format string, v ...interface{}) {\n+\t\tmsg := fmt.Sprintf(format, v...)\n+\t\tif msg == \"too many levels of symbolic links\" {\n+\t\t\tloopFound = true\n+\t\t}\n+\t}\n+\n+\terr = snap.ValidateSnapContainer(s.container(), info, mockLogf)\n+\tc.Check(err, Equals, snap.ErrBadModes)\n+\tc.Check(loopFound, Equals, true)\n+}\n+\n+func (s *validateSuite) TestValidateSymlinkOk(c *C) {\n+\tconst yaml = `name: empty-snap\n version: 1\n `\n-\td := c.MkDir()\n-\tc.Assert(os.Chmod(d, 0755), IsNil)\n-\tc.Assert(os.Mkdir(filepath.Join(d, \"meta\"), 0755), IsNil)\n-\tc.Assert(ioutil.WriteFile(filepath.Join(d, \"meta\", \"component.yaml\"), []byte(yaml), 0444), IsNil)\n+\ts.bootstrapEmptyContainer(c)\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"media\", \"sub\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(s.snapDirPath, \"media\", \"icon.png\"), nil, 0644), IsNil)\n+\tc.Assert(os.Symlink(\"../icon.png\", filepath.Join(s.snapDirPath, \"media\", \"sub\", \"symlink-1.png\")), IsNil)\n+\tc.Assert(os.Symlink(\"symlink-1.png\", filepath.Join(s.snapDirPath, \"media\", \"sub\", \"symlink-2.png\")), IsNil)\n+\tc.Assert(os.Symlink(\"../media/sub/symlink-2.png\", filepath.Join(s.snapDirPath, \"meta\", \"icon.png\")), IsNil)\n+\t// all symlinks outside meta directory are allowed\n+\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, \"bin\"), 0755), IsNil)\n+\tc.Assert(os.Symlink(\"/usr/bin/python3\", filepath.Join(s.snapDirPath, \"bin\", \"python3\")), IsNil)\n+\n+\tinfo, err := snap.InfoFromSnapYaml([]byte(yaml))\n+\tc.Assert(err, IsNil)\n \n-\terr := snap.ValidateComponentContainer(snapdir.New(d), \"empty-snap+comp.comp\", discard)\n+\terr = snap.ValidateSnapContainer(s.container(), info, discard)\n \tc.Check(err, IsNil)\n }\n+\n+func (s *validateSuite) TestValidateSymlinkExternal(c *C) {\n+\ttype testcase struct {\n+\t\tpath   string\n+\t\ttarget string\n+\t}\n+\n+\ts.bootstrapEmptyContainer(c)\n+\tfor _, t := range []testcase{\n+\t\t{\"meta/snap.yaml\", \"../..\"},\n+\t\t{\"meta/snap.yaml\", \"../../\"},\n+\t\t{\"meta/snap.yaml\", \"../../rev2\"},\n+\t\t{\"meta/snap.yaml\", \"../../../core/current/meta/snap.yaml\"},\n+\t\t{\"meta/gui/icons/snap.png\", \"../1/../../2/../../3/4/../../../test\"},\n+\t\t{\"meta/gui/icons/snap.png\", \"/etc/shadow\"},\n+\t\t{\"meta/gui/icons/snap.png\", \"/var/snap/other-snap/current/sensitive\"},\n+\t} {\n+\t\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, filepath.Dir(t.path)), 0755), IsNil)\n+\t\tc.Assert(os.RemoveAll(filepath.Join(s.snapDirPath, t.path)), IsNil)\n+\t\tc.Assert(os.Symlink(t.target, filepath.Join(s.snapDirPath, t.path)), IsNil)\n+\n+\t\tcmt := Commentf(fmt.Sprintf(\"path: %s, target: %s\", t.path, t.target))\n+\t\texpectedError := fmt.Sprintf(\"external symlink found: %s -> %s\", t.path, t.target)\n+\t\t_, err := snap.EvalAndValidateSymlink(s.container(), t.path)\n+\t\tc.Check(err, ErrorMatches, expectedError, cmt)\n+\t}\n+}\n+\n+func (s *validateSuite) TestValidateSymlinkSnapMount(c *C) {\n+\ttype testcase struct {\n+\t\tpath   string\n+\t\ttarget string\n+\t}\n+\n+\ts.bootstrapEmptyContainer(c)\n+\tfor _, t := range []testcase{\n+\t\t{\"meta/snap.yaml\", \"..\"},\n+\t\t{\"meta/snap.yaml\", \"../\"},\n+\t\t{\"meta/gui/icons/snap.png\", \"../1/../../2/../../3/4/../..\"},\n+\t} {\n+\t\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, filepath.Dir(t.path)), 0755), IsNil)\n+\t\tc.Assert(os.RemoveAll(filepath.Join(s.snapDirPath, t.path)), IsNil)\n+\t\tc.Assert(os.Symlink(t.target, filepath.Join(s.snapDirPath, t.path)), IsNil)\n+\n+\t\tcmt := Commentf(fmt.Sprintf(\"path: %s, target: %s\", t.path, t.target))\n+\t\texpectedError := fmt.Sprintf(\"bad symlink found: %s -> %s\", t.path, t.target)\n+\t\t_, err := snap.EvalAndValidateSymlink(s.container(), t.path)\n+\t\tc.Check(err, ErrorMatches, expectedError, cmt)\n+\t}\n+}\n+\n+func (s *validateSuite) TestValidateSymlinkMeta(c *C) {\n+\ttype testcase struct {\n+\t\tpath   string\n+\t\ttarget string\n+\t}\n+\n+\ts.bootstrapEmptyContainer(c)\n+\tfor _, t := range []testcase{\n+\t\t{\"meta/snap.yaml\", \".\"},\n+\t\t{\"meta/snap.yaml\", \"../meta\"},\n+\t\t{\"meta/gui/icons/snap.png\", \"../1/../../2/../../3/4/../../meta\"},\n+\t} {\n+\t\tc.Assert(os.MkdirAll(filepath.Join(s.snapDirPath, filepath.Dir(t.path)), 0755), IsNil)\n+\t\tc.Assert(os.RemoveAll(filepath.Join(s.snapDirPath, t.path)), IsNil)\n+\t\tc.Assert(os.Symlink(t.target, filepath.Join(s.snapDirPath, t.path)), IsNil)\n+\n+\t\tcmt := Commentf(fmt.Sprintf(\"path: %s, target: %s\", t.path, t.target))\n+\t\texpectedError := fmt.Sprintf(\"bad symlink found: %s -> %s\", t.path, t.target)\n+\t\t_, err := snap.EvalAndValidateSymlink(s.container(), t.path)\n+\t\tc.Check(err, ErrorMatches, expectedError, cmt)\n+\t}\n+}\n+\n+func (s *validateSuite) TestShouldValidateSymlink(c *C) {\n+\ttype testcase struct {\n+\t\tpath     string\n+\t\texpected bool\n+\t}\n+\n+\tfor _, t := range []testcase{\n+\t\t{\"meta\", true},\n+\t\t{\"meta/snap.yaml\", true},\n+\t\t{\"meta/gui/icons/snap.png\", true},\n+\t\t{\"meta/gui/snap.desktop\", true},\n+\t\t{\"etc\", false},\n+\t\t{\"etc/test\", false},\n+\t\t{\"other\", false},\n+\t} {\n+\t\tcmt := Commentf(fmt.Sprintf(\"path: %s, expected: %t\", t.path, t.expected))\n+\t\tc.Check(snap.ShouldValidateSymlink(t.path), Equals, t.expected, cmt)\n+\t}\n+}"
        },
        {
          "filename": "snap/export_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -19,17 +19,25 @@\n \n package snap\n \n+import \"os\"\n+\n var (\n \tValidateSocketName           = validateSocketName\n \tValidateTitle                = validateTitle\n \tInfoFromSnapYamlWithSideInfo = infoFromSnapYamlWithSideInfo\n \tGetAttribute                 = getAttribute\n+\tEvalAndValidateSymlink       = evalAndValidateSymlink\n+\tShouldValidateSymlink        = shouldValidateSymlink\n )\n \n func (info *Info) ForceRenamePlug(oldName, newName string) {\n \tinfo.forceRenamePlug(oldName, newName)\n }\n \n+func (symlinkInfo *symlinkInfo) Mode() os.FileMode {\n+\treturn symlinkInfo.targetMode\n+}\n+\n func NewScopedTracker() *scopedTracker {\n \treturn new(scopedTracker)\n }"
        },
        {
          "filename": "snap/snapdir/snapdir.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -88,9 +88,18 @@ func (s *SnapDir) ReadFile(file string) (content []byte, err error) {\n \treturn ioutil.ReadFile(filepath.Join(s.path, file))\n }\n \n+func (s *SnapDir) ReadLink(file string) (string, error) {\n+\treturn os.Readlink(filepath.Join(s.path, file))\n+}\n+\n+func (s *SnapDir) Lstat(file string) (os.FileInfo, error) {\n+\treturn os.Lstat(filepath.Join(s.path, file))\n+}\n+\n func littleWalk(dirPath string, dirHandle *os.File, dirstack *[]string, walkFn filepath.WalkFunc) error {\n \tconst numSt = 100\n \n+\t// XXX: check if os.ReadDir is more efficient\n \tsts, err := dirHandle.Readdir(numSt)\n \tif err != nil {\n \t\treturn err"
        },
        {
          "filename": "snap/snapdir/snapdir_test.go",
          "status": "modified",
          "additions": 40,
          "deletions": 0,
          "patch": "@@ -20,6 +20,7 @@\n package snapdir_test\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"math/rand\"\n \t\"os\"\n@@ -70,6 +71,45 @@ func (s *SnapdirTestSuite) TestReadFile(c *C) {\n \tc.Assert(content, DeepEquals, needle)\n }\n \n+func (s *SnapdirTestSuite) TestReadlink(c *C) {\n+\td := c.MkDir()\n+\tc.Assert(os.Symlink(\"target\", filepath.Join(d, \"foo\")), IsNil)\n+\n+\tsn := snapdir.New(d)\n+\ttarget, err := sn.ReadLink(\"foo\")\n+\tc.Assert(err, IsNil)\n+\tc.Assert(target, DeepEquals, \"target\")\n+}\n+\n+func (s *SnapdirTestSuite) TestLstat(c *C) {\n+\td := c.MkDir()\n+\tc.Assert(os.Symlink(\"target\", filepath.Join(d, \"symlink\")), IsNil)\n+\tc.Assert(os.MkdirAll(filepath.Join(d, \"meta\"), 0755), IsNil)\n+\tc.Assert(os.WriteFile(filepath.Join(d, \"meta/snap.yaml\"), nil, 0644), IsNil)\n+\n+\tsn := snapdir.New(d)\n+\tfor _, file := range []string{\n+\t\t\"symlink\",\n+\t\t\"meta\",\n+\t\t\"meta/snap.yaml\",\n+\t} {\n+\t\texpectedInfo, err := os.Lstat(filepath.Join(d, file))\n+\t\tc.Assert(err, IsNil)\n+\t\tinfo, err := sn.Lstat(file)\n+\t\tc.Assert(err, IsNil)\n+\n+\t\tc.Check(info.Name(), Equals, expectedInfo.Name())\n+\t\tc.Check(info.Mode(), Equals, expectedInfo.Mode())\n+\t\tc.Check(info.Size(), Equals, expectedInfo.Size())\n+\t}\n+}\n+\n+func (s *SnapdirTestSuite) TestLstatErrNotExist(c *C) {\n+\tsn := snapdir.New(c.MkDir())\n+\t_, err := sn.Lstat(\"meta/non-existent\")\n+\tc.Check(errors.Is(err, os.ErrNotExist), Equals, true)\n+}\n+\n func (s *SnapdirTestSuite) TestRandomAccessFile(c *C) {\n \td := c.MkDir()\n \tneedle := []byte(`stuff`)"
        },
        {
          "filename": "snap/squashfs/squashfs.go",
          "status": "modified",
          "additions": 40,
          "deletions": 1,
          "patch": "@@ -273,6 +273,41 @@ func (s *Snap) ReadFile(filePath string) (content []byte, err error) {\n \treturn content, nil\n }\n \n+func (s *Snap) ReadLink(filePath string) (string, error) {\n+\t// XXX: This could be optimized by reading a cached version of\n+\t// unsquashfs raw output where the symlink's target is available.\n+\t// Check -> func fromRaw(raw []byte) (*stat, error)\n+\tvar target string\n+\terr := s.withUnpackedFile(filePath, func(p string) (err error) {\n+\t\ttarget, err = os.Readlink(p)\n+\t\treturn err\n+\t})\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn target, nil\n+}\n+\n+func (s *Snap) Lstat(filePath string) (os.FileInfo, error) {\n+\tvar fileInfo os.FileInfo\n+\n+\terr := s.Walk(filePath, func(path string, info os.FileInfo, err error) error {\n+\t\tif filePath == path {\n+\t\t\tfileInfo = info\n+\t\t}\n+\t\treturn err\n+\t})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif fileInfo == nil {\n+\t\treturn nil, os.ErrNotExist\n+\t}\n+\n+\treturn fileInfo, nil\n+}\n+\n // skipper is used to track directories that should be skipped\n //\n // Given sk := make(skipper), if you sk.Add(\"foo/bar\"), then\n@@ -353,10 +388,14 @@ func (s *Snap) Walk(relative string, walkFn filepath.WalkFunc) error {\n \t\t\t\treturn err\n \t\t\t}\n \t\t} else {\n-\t\t\tpath := filepath.Join(relative, st.Path())\n+\t\t\tpath := filepath.Join(\".\", st.Path())\n \t\t\tif skipper.Has(path) {\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\t// skip if path is not under given relative path\n+\t\t\tif relative != \".\" && !strings.HasPrefix(path, relative) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\terr = walkFn(path, st, nil)\n \t\t\tif err != nil {\n \t\t\t\tif err == filepath.SkipDir && st.IsDir() {"
        },
        {
          "filename": "snap/squashfs/squashfs_test.go",
          "status": "modified",
          "additions": 89,
          "deletions": 0,
          "patch": "@@ -76,6 +76,9 @@ func makeSnapContents(c *C, manifest, data string) string {\n \terr = os.MkdirAll(filepath.Join(tmp, \"food\", \"bard\", \"bazd\"), 0755)\n \tc.Assert(err, IsNil)\n \n+\terr = os.Symlink(\"target\", filepath.Join(tmp, \"symlink\"))\n+\tc.Assert(err, IsNil)\n+\n \t// some data\n \terr = os.WriteFile(filepath.Join(tmp, \"data.bin\"), []byte(data), 0644)\n \tc.Assert(err, IsNil)\n@@ -325,6 +328,56 @@ func (s *SquashfsTestSuite) TestReadFileFail(c *C) {\n \tc.Assert(err, ErrorMatches, \"cannot run unsquashfs: boom\")\n }\n \n+func (s *SquashfsTestSuite) TestReadlink(c *C) {\n+\tsn := makeSnap(c, \"name: foo\", \"\")\n+\n+\ttarget, err := sn.ReadLink(\"symlink\")\n+\tc.Assert(err, IsNil)\n+\tc.Assert(target, Equals, \"target\")\n+}\n+\n+func (s *SquashfsTestSuite) TestReadlinkFail(c *C) {\n+\tsn := makeSnap(c, \"name: foo\", \"\")\n+\n+\ttarget, err := sn.ReadLink(\"meta/snap.yaml\")\n+\tc.Assert(err, ErrorMatches, \"readlink .*/meta/snap.yaml: invalid argument\")\n+\tc.Assert(target, Equals, \"\")\n+}\n+\n+func (s *SquashfsTestSuite) TestLstat(c *C) {\n+\tsn := makeSnap(c, \"name: foo\", \"\")\n+\n+\tbase := c.MkDir()\n+\tc.Assert(sn.Unpack(\"*\", base), IsNil)\n+\n+\tfor _, file := range []string{\n+\t\t\"symlink\",\n+\t\t\"meta\",\n+\t\t\"meta/snap.yaml\",\n+\t\t\"meta/hooks/dir\",\n+\t} {\n+\t\texpectedInfo, err := os.Lstat(filepath.Join(base, file))\n+\t\tc.Assert(err, IsNil)\n+\t\tinfo, err := sn.Lstat(file)\n+\t\tc.Assert(err, IsNil)\n+\n+\t\tc.Check(info.Name(), Equals, expectedInfo.Name())\n+\t\tc.Check(info.Mode(), Equals, expectedInfo.Mode())\n+\t\t// sometimes 4096 bytes is the smallest allocation unit for some\n+\t\t// filesystems. let's just skip size check for directories.\n+\t\tif !expectedInfo.IsDir() {\n+\t\t\tc.Check(info.Size(), Equals, expectedInfo.Size())\n+\t\t}\n+\t}\n+}\n+\n+func (s *SquashfsTestSuite) TestLstatErrNotExist(c *C) {\n+\tsn := makeSnap(c, \"name: foo\", \"\")\n+\n+\t_, err := sn.Lstat(\"meta/non-existent\")\n+\tc.Check(errors.Is(err, os.ErrNotExist), Equals, true)\n+}\n+\n func (s *SquashfsTestSuite) TestRandomAccessFile(c *C) {\n \tsn := makeSnap(c, \"name: foo\", \"\")\n \n@@ -415,6 +468,42 @@ func (s *SquashfsTestSuite) TestWalkNative(c *C) {\n \n }\n \n+func (s *SquashfsTestSuite) TestWalkRelativeSingleFile(c *C) {\n+\tsn := makeSnap(c, \"name: foo\", \"\")\n+\n+\tcnt := 0\n+\tfound := false\n+\terr := sn.Walk(\"meta/snap.yaml\", func(path string, info os.FileInfo, err error) error {\n+\t\tif path == \"meta/snap.yaml\" {\n+\t\t\tfound = true\n+\t\t}\n+\t\tcnt++\n+\t\treturn nil\n+\t})\n+\tc.Assert(err, IsNil)\n+\n+\tc.Check(found, Equals, true)\n+\tc.Check(cnt, Equals, 1)\n+}\n+\n+func (s *SquashfsTestSuite) TestWalkRelativeDirectory(c *C) {\n+\tsn := makeSnap(c, \"name: foo\", \"\")\n+\n+\tcnt := 0\n+\tfound := map[string]bool{}\n+\terr := sn.Walk(\"food\", func(path string, info os.FileInfo, err error) error {\n+\t\tfound[path] = true\n+\t\tcnt++\n+\t\treturn nil\n+\t})\n+\tc.Assert(err, IsNil)\n+\n+\tc.Check(found[\"food\"], Equals, true)\n+\tc.Check(found[\"food/bard\"], Equals, true)\n+\tc.Check(found[\"food/bard/bazd\"], Equals, true)\n+\tc.Check(cnt, Equals, 3)\n+}\n+\n func (s *SquashfsTestSuite) testWalkMockedUnsquashfs(c *C) {\n \texpectingNames := []string{\n \t\t\".\","
        },
        {
          "filename": "tests/main/bad-meta-file-types/task.yaml",
          "status": "added",
          "additions": 72,
          "deletions": 0,
          "patch": "@@ -0,0 +1,72 @@\n+summary: Check that bad file types under meta directory are detected\n+\n+details: |\n+  Check that a malicious snap that has non-regular (e.g. pipe/symlink)\n+  files disguised under meta directory are detected and cause \"snap pack\"\n+  and \"snap install\" to fail.\n+\n+execute: |\n+    # pipe desktop files\n+    mkdir -p test-bad-file-types/meta/gui/\n+    mkfifo test-bad-file-types/meta/gui/test-bad-file-types.desktop\n+    # snap pack should fail\n+    echo \"Packing snap with pipe disguised as a desktop file should fail\"\n+    not snap pack test-bad-file-types > pack.out 2>&1\n+    MATCH \"\\\"meta/gui/test-bad-file-types.desktop\\\" should be a regular file \\(or a symlink\\) and isn't\" < pack.out\n+    # snap install should also fail\n+    echo \"Installing snap with pipe disguised as a desktop file should fail\"\n+    mksquashfs test-bad-file-types test-bad-file-types.snap\n+    not snap install --dangerous test-bad-file-types.snap\n+    journalctl -u snapd | MATCH \"\\\"meta/gui/test-bad-file-types.desktop\\\" should be a regular file \\(or a symlink\\) and isn't\"\n+    # clean up\n+    rm test-bad-file-types.snap\n+    rm test-bad-file-types/meta/gui/test-bad-file-types.desktop\n+\n+    # symlink desktop files\n+    ln -s /etc/shadow test-bad-file-types/meta/gui/test-bad-file-types.desktop\n+    # snap pack should fail\n+    echo \"Packing snap with symlink disguised as a desktop file should fail\"\n+    not snap pack test-bad-file-types > pack.out 2>&1\n+    MATCH \"external symlink found: meta/gui/test-bad-file-types.desktop -> /etc/shadow\" < pack.out\n+    # snap install should also fail\n+    echo \"Installing snap with symlink disguised as a desktop file should fail\"\n+    mksquashfs test-bad-file-types test-bad-file-types.snap\n+    not snap install --dangerous test-bad-file-types.snap\n+    journalctl -u snapd | MATCH \"external symlink found: meta/gui/test-bad-file-types.desktop -> /etc/shadow\"\n+    # clean up\n+    rm test-bad-file-types.snap\n+    rm test-bad-file-types/meta/gui/test-bad-file-types.desktop\n+\n+    # pipe icon files\n+    mkdir -p test-bad-file-types/meta/gui/icons\n+    mkfifo test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png\n+    # snap pack should fail\n+    echo \"Packing snap with pipe disguised as an icon file should fail\"\n+    not snap pack test-bad-file-types > pack.out 2>&1\n+    MATCH \"\\\"meta/gui/icons/snap.test-bad-file-types.png\\\" should be a regular file \\(or a symlink\\) and isn't\" < pack.out\n+    # snap install should also fail\n+    echo \"Installing snap with pipe disguised as an icon file should fail\"\n+    mksquashfs test-bad-file-types test-bad-file-types.snap\n+    not snap install --dangerous test-bad-file-types.snap\n+    journalctl -u snapd | MATCH \"\\\"meta/gui/icons/snap.test-bad-file-types.png\\\" should be a regular file \\(or a symlink\\) and isn't\"\n+    # clean up\n+    rm test-bad-file-types.snap\n+    rm test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png\n+\n+    # symlink icon files\n+    mkdir -p test-bad-file-types/meta/gui/icons\n+    ln -s /etc/shadow test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png\n+    # snap pack should fail\n+    echo \"Packing snap with symlink disguised as an icon file should fail\"\n+    not snap pack test-bad-file-types > pack.out 2>&1\n+    MATCH \"external symlink found: meta/gui/icons/snap.test-bad-file-types.png -> /etc/shadow\" < pack.out\n+    # snap install should also fail\n+    echo \"Installing snap with symlink disguised as an icon file should fail\"\n+    mksquashfs test-bad-file-types test-bad-file-types.snap\n+    not snap install --dangerous test-bad-file-types.snap\n+    journalctl -u snapd | MATCH \"external symlink found: meta/gui/icons/snap.test-bad-file-types.png -> /etc/shadow\"\n+    # clean up\n+    rm test-bad-file-types.snap\n+    rm test-bad-file-types/meta/gui/icons/snap.test-bad-file-types.png\n+\n+    # TODO: Test other files that can be placed under meta directory like polkit policies and udev files"
        },
        {
          "filename": "tests/main/bad-meta-file-types/test-bad-file-types/meta/snap.yaml",
          "status": "added",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -0,0 +1,4 @@\n+name: test-bad-file-types\n+base: none\n+version: 1.0\n+summary: A bad test snap that has non-regular files disguised under meta directory"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 6,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2cbce28fd7f4da74e9d3aea568cd074e649dfe36",
            "date": "2025-01-25T04:20:30Z",
            "author_login": "olivercalder"
          },
          {
            "sha": "386592cb49c13dbf30c76e90b51010322800a9e5",
            "date": "2025-01-24T22:17:12Z",
            "author_login": "olivercalder"
          },
          {
            "sha": "7adb9b7931ac64245898dfba8b7035c4379dfe2e",
            "date": "2025-01-24T21:14:05Z",
            "author_login": "andrewphelpsj"
          },
          {
            "sha": "525eaf9aab96dc7c247d126219f90c28e45cc641",
            "date": "2025-01-24T20:01:30Z",
            "author_login": "olivercalder"
          },
          {
            "sha": "e2ee2068d87f9564505d0a4d1c4d2fdb950ab98a",
            "date": "2025-01-24T19:55:31Z",
            "author_login": "olivercalder"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:H/I:N/A:H",
    "cwe_id": "CWE-20",
    "description": "In snapd versions prior to 2.62, snapd failed to properly check the file\ntype when extracting a snap. The snap format is a squashfs file-system\nimage and so can contain files that are non-regular files (such as pipes \nor sockets etc). Various file entries within the snap squashfs image\n(such as icons etc) are directly read by snapd when it is extracted. An \nattacker who could convince a user to install a malicious snap which\ncontained non-regular files at these paths could then cause snapd to block\nindefinitely trying to read from such files and cause a denial of service.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-25T20:15:04.280",
    "last_modified": "2024-11-21T09:07:29.217",
    "fix_date": "2023-09-08T06:52:22Z"
  },
  "references": [
    {
      "url": "https://github.com/snapcore/snapd/commit/b66fee81606a1c05f965a876ccbaf44174194063",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/snapcore/snapd/pull/13682",
      "source": "security@ubuntu.com",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/snapcore/snapd/commit/b66fee81606a1c05f965a876ccbaf44174194063",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/snapcore/snapd/pull/13682",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.520108",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "snapd",
    "owner": "snapcore",
    "created_at": "2015-10-21T11:51:46Z",
    "updated_at": "2025-01-25T04:20:36Z",
    "pushed_at": "2025-01-25T04:20:30Z",
    "size": 161855,
    "stars": 1918,
    "forks": 595,
    "open_issues": 150,
    "watchers": 1918,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "fde-manager-features",
      "master",
      "release/2.16",
      "release/2.17",
      "release/2.17.1",
      "release/2.18",
      "release/2.18.1",
      "release/2.19.1",
      "release/2.20",
      "release/2.20.1",
      "release/2.21",
      "release/2.22",
      "release/2.23",
      "release/2.24",
      "release/2.25",
      "release/2.26",
      "release/2.27"
    ],
    "languages": {
      "Go": 27215781,
      "C": 807343,
      "Shell": 617445,
      "Python": 226099,
      "Makefile": 104474,
      "M4": 13227,
      "Tcl": 1269,
      "HTML": 980,
      "Meson": 295,
      "Roff": 12
    },
    "commit_activity": {
      "total_commits_last_year": 1618,
      "avg_commits_per_week": 31.115384615384617,
      "days_active_last_year": 246
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-26T08:18:55.795938"
  }
}