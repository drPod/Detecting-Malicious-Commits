{
  "cve_id": "CVE-2024-29893",
  "github_data": {
    "repository": "argoproj/argo-cd",
    "fix_commit": "14f681e3ee7c38731943b98f92277e88a3db109d",
    "related_commits": [
      "14f681e3ee7c38731943b98f92277e88a3db109d",
      "36b8a12a38f8d92d55bffc81deed44389bf6eb59",
      "3e5a878f6e30d935fa149723ea2a2e93748fcddd",
      "14f681e3ee7c38731943b98f92277e88a3db109d",
      "36b8a12a38f8d92d55bffc81deed44389bf6eb59",
      "3e5a878f6e30d935fa149723ea2a2e93748fcddd"
    ],
    "patch_url": "https://github.com/argoproj/argo-cd/commit/14f681e3ee7c38731943b98f92277e88a3db109d.patch",
    "fix_commit_details": {
      "sha": "14f681e3ee7c38731943b98f92277e88a3db109d",
      "commit_date": "2024-03-28T12:38:03Z",
      "author": {
        "login": "pasha-codefresh",
        "type": "User",
        "stats": {
          "total_commits": 261,
          "average_weekly_commits": 0.7209944751381215,
          "total_additions": 223909,
          "total_deletions": 165744,
          "weeks_active": 88
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-jhwx-mhww-rgc3",
        "length": 360,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 41,
        "additions": 27,
        "deletions": 14
      },
      "files": [
        {
          "filename": "cmd/argocd-repo-server/commands/argocd_repo_server.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -66,6 +66,7 @@ func NewCommand() *cobra.Command {\n \t\tstreamedManifestMaxTarSize        string\n \t\tstreamedManifestMaxExtractedSize  string\n \t\thelmManifestMaxExtractedSize      string\n+\t\thelmRegistryMaxIndexSize          string\n \t\tdisableManifestMaxExtractedSize   bool\n \t)\n \tvar command = cobra.Command{\n@@ -108,6 +109,9 @@ func NewCommand() *cobra.Command {\n \t\t\thelmManifestMaxExtractedSizeQuantity, err := resource.ParseQuantity(helmManifestMaxExtractedSize)\n \t\t\terrors.CheckError(err)\n \n+\t\t\thelmRegistryMaxIndexSizeQuantity, err := resource.ParseQuantity(helmRegistryMaxIndexSize)\n+\t\t\terrors.CheckError(err)\n+\n \t\t\taskPassServer := askpass.NewServer()\n \t\t\tmetricsServer := metrics.NewMetricsServer()\n \t\t\tcacheutil.CollectMetrics(redisClient, metricsServer)\n@@ -123,6 +127,7 @@ func NewCommand() *cobra.Command {\n \t\t\t\tStreamedManifestMaxExtractedSize:             streamedManifestMaxExtractedSizeQuantity.ToDec().Value(),\n \t\t\t\tStreamedManifestMaxTarSize:                   streamedManifestMaxTarSizeQuantity.ToDec().Value(),\n \t\t\t\tHelmManifestMaxExtractedSize:                 helmManifestMaxExtractedSizeQuantity.ToDec().Value(),\n+\t\t\t\tHelmRegistryMaxIndexSize:                     helmRegistryMaxIndexSizeQuantity.ToDec().Value(),\n \t\t\t}, askPassServer)\n \t\t\terrors.CheckError(err)\n \n@@ -204,6 +209,7 @@ func NewCommand() *cobra.Command {\n \tcommand.Flags().StringVar(&streamedManifestMaxTarSize, \"streamed-manifest-max-tar-size\", env.StringFromEnv(\"ARGOCD_REPO_SERVER_STREAMED_MANIFEST_MAX_TAR_SIZE\", \"100M\"), \"Maximum size of streamed manifest archives\")\n \tcommand.Flags().StringVar(&streamedManifestMaxExtractedSize, \"streamed-manifest-max-extracted-size\", env.StringFromEnv(\"ARGOCD_REPO_SERVER_STREAMED_MANIFEST_MAX_EXTRACTED_SIZE\", \"1G\"), \"Maximum size of streamed manifest archives when extracted\")\n \tcommand.Flags().StringVar(&helmManifestMaxExtractedSize, \"helm-manifest-max-extracted-size\", env.StringFromEnv(\"ARGOCD_REPO_SERVER_HELM_MANIFEST_MAX_EXTRACTED_SIZE\", \"1G\"), \"Maximum size of helm manifest archives when extracted\")\n+\tcommand.Flags().StringVar(&helmRegistryMaxIndexSize, \"helm-registry-max-index-size\", env.StringFromEnv(\"ARGOCD_REPO_SERVER_HELM_MANIFEST_MAX_INDEX_SIZE\", \"1G\"), \"Maximum size of registry index file\")\n \tcommand.Flags().BoolVar(&disableManifestMaxExtractedSize, \"disable-helm-manifest-max-extracted-size\", env.ParseBoolFromEnv(\"ARGOCD_REPO_SERVER_DISABLE_HELM_MANIFEST_MAX_EXTRACTED_SIZE\", false), \"Disable maximum size of helm manifest archives when extracted\")\n \ttlsConfigCustomizerSrc = tls.AddTLSFlagsToCmd(&command)\n \tcacheSrc = reposervercache.AddCacheFlagsToCmd(&command, func(client *redis.Client) {"
        },
        {
          "filename": "reposerver/repository/repository.go",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -107,6 +107,7 @@ type RepoServerInitConstants struct {\n \tStreamedManifestMaxExtractedSize             int64\n \tStreamedManifestMaxTarSize                   int64\n \tHelmManifestMaxExtractedSize                 int64\n+\tHelmRegistryMaxIndexSize                     int64\n \tDisableHelmManifestMaxExtractedSize          bool\n }\n \n@@ -2345,7 +2346,7 @@ func (s *Service) newHelmClientResolveRevision(repo *v1alpha1.Repository, revisi\n \t\treturn helmClient, version.String(), nil\n \t}\n \n-\tindex, err := helmClient.GetIndex(noRevisionCache)\n+\tindex, err := helmClient.GetIndex(noRevisionCache, s.initConstants.HelmRegistryMaxIndexSize)\n \tif err != nil {\n \t\treturn nil, \"\", err\n \t}\n@@ -2423,7 +2424,7 @@ func checkoutRevision(gitClient git.Client, revision string, submoduleEnabled bo\n }\n \n func (s *Service) GetHelmCharts(ctx context.Context, q *apiclient.HelmChartsRequest) (*apiclient.HelmChartsResponse, error) {\n-\tindex, err := s.newHelmClient(q.Repo.Repo, q.Repo.GetHelmCreds(), q.Repo.EnableOCI, q.Repo.Proxy, helm.WithChartPaths(s.chartPaths)).GetIndex(true)\n+\tindex, err := s.newHelmClient(q.Repo.Repo, q.Repo.GetHelmCreds(), q.Repo.EnableOCI, q.Repo.Proxy, helm.WithChartPaths(s.chartPaths)).GetIndex(true, s.initConstants.HelmRegistryMaxIndexSize)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -2458,7 +2459,7 @@ func (s *Service) TestRepository(ctx context.Context, q *apiclient.TestRepositor\n \t\t\t\t_, err := helm.NewClient(repo.Repo, repo.GetHelmCreds(), repo.EnableOCI, repo.Proxy).TestHelmOCI()\n \t\t\t\treturn err\n \t\t\t} else {\n-\t\t\t\t_, err := helm.NewClient(repo.Repo, repo.GetHelmCreds(), repo.EnableOCI, repo.Proxy).GetIndex(false)\n+\t\t\t\t_, err := helm.NewClient(repo.Repo, repo.GetHelmCreds(), repo.EnableOCI, repo.Proxy).GetIndex(false, s.initConstants.HelmRegistryMaxIndexSize)\n \t\t\t\treturn err\n \t\t\t}\n \t\t},"
        },
        {
          "filename": "reposerver/repository/repository_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -113,7 +113,7 @@ func newServiceWithMocks(t *testing.T, root string, signed bool) (*Service, *git\n \t\tchart := \"my-chart\"\n \t\toobChart := \"out-of-bounds-chart\"\n \t\tversion := \"1.1.0\"\n-\t\thelmClient.On(\"GetIndex\", mock.AnythingOfType(\"bool\")).Return(&helm.Index{Entries: map[string]helm.Entries{\n+\t\thelmClient.On(\"GetIndex\", mock.AnythingOfType(\"bool\"), mock.Anything).Return(&helm.Index{Entries: map[string]helm.Entries{\n \t\t\tchart:    {{Version: \"1.0.0\"}, {Version: version}},\n \t\t\toobChart: {{Version: \"1.0.0\"}, {Version: version}},\n \t\t}}, nil)"
        },
        {
          "filename": "util/helm/client.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -56,7 +56,7 @@ type indexCache interface {\n type Client interface {\n \tCleanChartCache(chart string, version string) error\n \tExtractChart(chart string, version string, passCredentials bool, manifestMaxExtractedSize int64, disableManifestMaxExtractedSize bool) (string, argoio.Closer, error)\n-\tGetIndex(noCache bool) (*Index, error)\n+\tGetIndex(noCache bool, maxIndexSize int64) (*Index, error)\n \tGetTags(chart string, noCache bool) (*TagsList, error)\n \tTestHelmOCI() (bool, error)\n }\n@@ -230,7 +230,7 @@ func (c *nativeHelmChart) ExtractChart(chart string, version string, passCredent\n \t}), nil\n }\n \n-func (c *nativeHelmChart) GetIndex(noCache bool) (*Index, error) {\n+func (c *nativeHelmChart) GetIndex(noCache bool, maxIndexSize int64) (*Index, error) {\n \tindexLock.Lock(c.repoURL)\n \tdefer indexLock.Unlock(c.repoURL)\n \n@@ -244,7 +244,7 @@ func (c *nativeHelmChart) GetIndex(noCache bool) (*Index, error) {\n \tif len(data) == 0 {\n \t\tstart := time.Now()\n \t\tvar err error\n-\t\tdata, err = c.loadRepoIndex()\n+\t\tdata, err = c.loadRepoIndex(maxIndexSize)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -297,7 +297,7 @@ func (c *nativeHelmChart) TestHelmOCI() (bool, error) {\n \treturn true, nil\n }\n \n-func (c *nativeHelmChart) loadRepoIndex() ([]byte, error) {\n+func (c *nativeHelmChart) loadRepoIndex(maxIndexSize int64) ([]byte, error) {\n \tindexURL, err := getIndexURL(c.repoURL)\n \tif err != nil {\n \t\treturn nil, err\n@@ -332,7 +332,7 @@ func (c *nativeHelmChart) loadRepoIndex() ([]byte, error) {\n \tif resp.StatusCode != http.StatusOK {\n \t\treturn nil, errors.New(\"failed to get index: \" + resp.Status)\n \t}\n-\treturn io.ReadAll(resp.Body)\n+\treturn io.ReadAll(io.LimitReader(resp.Body, maxIndexSize))\n }\n \n func newTLSConfig(creds Creds) (*tls.Config, error) {"
        },
        {
          "filename": "util/helm/client_test.go",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -37,12 +37,12 @@ func (f *fakeIndexCache) GetHelmIndex(_ string, indexData *[]byte) error {\n func TestIndex(t *testing.T) {\n \tt.Run(\"Invalid\", func(t *testing.T) {\n \t\tclient := NewClient(\"\", Creds{}, false, \"\")\n-\t\t_, err := client.GetIndex(false)\n+\t\t_, err := client.GetIndex(false, 10000)\n \t\tassert.Error(t, err)\n \t})\n \tt.Run(\"Stable\", func(t *testing.T) {\n \t\tclient := NewClient(\"https://argoproj.github.io/argo-helm\", Creds{}, false, \"\")\n-\t\tindex, err := client.GetIndex(false)\n+\t\tindex, err := client.GetIndex(false, 10000)\n \t\tassert.NoError(t, err)\n \t\tassert.NotNil(t, index)\n \t})\n@@ -51,7 +51,7 @@ func TestIndex(t *testing.T) {\n \t\t\tUsername: \"my-password\",\n \t\t\tPassword: \"my-username\",\n \t\t}, false, \"\")\n-\t\tindex, err := client.GetIndex(false)\n+\t\tindex, err := client.GetIndex(false, 10000)\n \t\tassert.NoError(t, err)\n \t\tassert.NotNil(t, index)\n \t})\n@@ -63,12 +63,18 @@ func TestIndex(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\tclient := NewClient(\"https://argoproj.github.io/argo-helm\", Creds{}, false, \"\", WithIndexCache(&fakeIndexCache{data: data.Bytes()}))\n-\t\tindex, err := client.GetIndex(false)\n+\t\tindex, err := client.GetIndex(false, 10000)\n \n \t\tassert.NoError(t, err)\n \t\tassert.Equal(t, fakeIndex, *index)\n \t})\n \n+\tt.Run(\"Limited\", func(t *testing.T) {\n+\t\tclient := NewClient(\"https://argoproj.github.io/argo-helm\", Creds{}, false, \"\")\n+\t\t_, err := client.GetIndex(false, 100)\n+\n+\t\tassert.ErrorContains(t, err, \"unexpected end of stream\")\n+\t})\n }\n \n func Test_nativeHelmChart_ExtractChart(t *testing.T) {"
        },
        {
          "filename": "util/helm/mocks/Client.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -59,7 +59,7 @@ func (_m *Client) ExtractChart(chart string, version string, passCredentials boo\n }\n \n // GetIndex provides a mock function with given fields: noCache\n-func (_m *Client) GetIndex(noCache bool) (*helm.Index, error) {\n+func (_m *Client) GetIndex(noCache bool, maxIndexSize int64) (*helm.Index, error) {\n \tret := _m.Called(noCache)\n \n \tvar r0 *helm.Index"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d23e6ac79bb95a911b988551ba33bfc9939c5f18",
            "date": "2025-01-14T16:10:14Z",
            "author_login": "crenshaw-dev"
          },
          {
            "sha": "9a51757049dc028596d4950d7a6c7cd5a446301a",
            "date": "2025-01-14T15:41:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c3600d240a42a4708ec65091ffb23689b4513f85",
            "date": "2025-01-14T12:37:06Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "b77d9d9f5f9cf3862ef75e14a5877a3fcf60fa40",
            "date": "2025-01-14T12:16:41Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "2f579404f68ded0b0156fc25d6e554640c4ad009",
            "date": "2025-01-14T12:12:38Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All versions of ArgoCD starting from v2.4 have a bug where the ArgoCD repo-server component is vulnerable to a Denial-of-Service attack vector. Specifically,  it's possible to crash the repo server component through an out of memory error by pointing it to a malicious Helm registry. The loadRepoIndex() function in the ArgoCD's helm package, does not limit the size nor time while fetching the data. It fetches it and creates a byte slice from the retrieved data in one go. If the registry is implemented to push data continuously, the repo server will keep allocating memory until it runs out of it. A patch for this vulnerability has been released in v2.10.3, v2.9.8, and v2.8.12.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-03-29T15:15:12.740",
    "last_modified": "2025-01-09T14:42:05.183",
    "fix_date": "2024-03-28T12:38:03Z"
  },
  "references": [
    {
      "url": "https://github.com/argoproj/argo-cd/commit/14f681e3ee7c38731943b98f92277e88a3db109d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/36b8a12a38f8d92d55bffc81deed44389bf6eb59",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/3e5a878f6e30d935fa149723ea2a2e93748fcddd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-jhwx-mhww-rgc3",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/14f681e3ee7c38731943b98f92277e88a3db109d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/36b8a12a38f8d92d55bffc81deed44389bf6eb59",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/3e5a878f6e30d935fa149723ea2a2e93748fcddd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-jhwx-mhww-rgc3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:07:52.931593",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "argo-cd",
    "owner": "argoproj",
    "created_at": "2018-02-09T11:12:01Z",
    "updated_at": "2025-01-14T12:37:12Z",
    "pushed_at": "2025-01-14T12:37:08Z",
    "size": 125601,
    "stars": 18420,
    "forks": 5620,
    "open_issues": 3601,
    "watchers": 18420,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 6686751,
      "TypeScript": 1298168,
      "Lua": 199797,
      "SCSS": 92938,
      "Shell": 58329,
      "Makefile": 24983,
      "Dockerfile": 15204,
      "Procfile": 10040,
      "JavaScript": 5975,
      "CSS": 2209,
      "Mustache": 1066,
      "HTML": 895
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:15:10.212233"
  }
}