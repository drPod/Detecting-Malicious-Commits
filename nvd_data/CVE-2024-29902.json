{
  "cve_id": "CVE-2024-29902",
  "github_data": {
    "repository": "sigstore/cosign",
    "fix_commit": "629f5f8fa672973503edde75f84dcd984637629e",
    "related_commits": [
      "629f5f8fa672973503edde75f84dcd984637629e",
      "629f5f8fa672973503edde75f84dcd984637629e"
    ],
    "patch_url": "https://github.com/sigstore/cosign/commit/629f5f8fa672973503edde75f84dcd984637629e.patch",
    "fix_commit_details": {
      "sha": "629f5f8fa672973503edde75f84dcd984637629e",
      "commit_date": "2024-04-10T21:57:21Z",
      "author": {
        "login": "haydentherapper",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixes for GHSA-88jx-383q-w4qc and GHSA-95pr-fxf5-86gv (#3661)",
        "length": 1765,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 664,
        "additions": 657,
        "deletions": 7
      },
      "files": [
        {
          "filename": "cmd/cosign/cli/verify/verify_blob_attestation.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -34,6 +34,7 @@ import (\n \t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/options\"\n \t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/rekor\"\n \tinternal \"github.com/sigstore/cosign/v2/internal/pkg/cosign\"\n+\tpayloadsize \"github.com/sigstore/cosign/v2/internal/pkg/cosign/payload/size\"\n \t\"github.com/sigstore/cosign/v2/internal/pkg/cosign/tsa\"\n \t\"github.com/sigstore/cosign/v2/pkg/blob\"\n \t\"github.com/sigstore/cosign/v2/pkg/cosign\"\n@@ -117,6 +118,14 @@ func (c *VerifyBlobAttestationCommand) Exec(ctx context.Context, artifactPath st\n \t\t\treturn err\n \t\t}\n \t\tdefer f.Close()\n+\t\tfileInfo, err := f.Stat()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\terr = payloadsize.CheckSize(uint64(fileInfo.Size()))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \n \t\tpayload = internal.NewHashReader(f, sha256.New())\n \t\tif _, err := io.ReadAll(&payload); err != nil {"
        },
        {
          "filename": "cmd/cosign/cli/verify/verify_blob_attestation_test.go",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -32,6 +32,7 @@ gZPFIp557+TOoDxf14FODWc+sIPETk0OgCplAk60doVXbCv33IU4rXZHrg==\n const (\n \tblobContents                         = \"some-payload\"\n \tanotherBlobContents                  = \"another-blob\"\n+\thugeBlobContents                     = \"hugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayloadhugepayload\"\n \tblobSLSAProvenanceSignature          = \"eyJwYXlsb2FkVHlwZSI6ImFwcGxpY2F0aW9uL3ZuZC5pbi10b3RvK2pzb24iLCJwYXlsb2FkIjoiZXlKZmRIbHdaU0k2SW1oMGRIQnpPaTh2YVc0dGRHOTBieTVwYnk5VGRHRjBaVzFsYm5RdmRqQXVNU0lzSW5CeVpXUnBZMkYwWlZSNWNHVWlPaUpvZEhSd2N6b3ZMM05zYzJFdVpHVjJMM0J5YjNabGJtRnVZMlV2ZGpBdU1pSXNJbk4xWW1wbFkzUWlPbHQ3SW01aGJXVWlPaUppYkc5aUlpd2laR2xuWlhOMElqcDdJbk5vWVRJMU5pSTZJalkxT0RjNE1XTmtOR1ZrT1dKallUWXdaR0ZqWkRBNVpqZGlZamt4TkdKaU5URTFNREpsT0dJMVpEWXhPV1kxTjJZek9XRXhaRFkxTWpVNU5tTmpNalFpZlgxZExDSndjbVZrYVdOaGRHVWlPbnNpWW5WcGJHUmxjaUk2ZXlKcFpDSTZJaklpZlN3aVluVnBiR1JVZVhCbElqb2llQ0lzSW1sdWRtOWpZWFJwYjI0aU9uc2lZMjl1Wm1sblUyOTFjbU5sSWpwN2ZYMTlmUT09Iiwic2lnbmF0dXJlcyI6W3sia2V5aWQiOiIiLCJzaWciOiJNRVVDSUE4S2pacWtydDkwZnpCb2pTd3d0ajNCcWI0MUU2cnV4UWs5N1RMbnB6ZFlBaUVBek9Bak9Uenl2VEhxYnBGREFuNnpocmc2RVp2N2t4SzVmYVJvVkdZTWgyYz0ifV19\"\n \tdssePredicateEmptySubject            = \"eyJwYXlsb2FkVHlwZSI6ImFwcGxpY2F0aW9uL3ZuZC5pbi10b3RvK2pzb24iLCJwYXlsb2FkIjoiZXlKZmRIbHdaU0k2SW1oMGRIQnpPaTh2YVc0dGRHOTBieTVwYnk5VGRHRjBaVzFsYm5RdmRqQXVNU0lzSW5CeVpXUnBZMkYwWlZSNWNHVWlPaUpvZEhSd2N6b3ZMM05zYzJFdVpHVjJMM0J5YjNabGJtRnVZMlV2ZGpBdU1pSXNJbk4xWW1wbFkzUWlPbHRkTENKd2NtVmthV05oZEdVaU9uc2lZblZwYkdSbGNpSTZleUpwWkNJNklqSWlmU3dpWW5WcGJHUlVlWEJsSWpvaWVDSXNJbWx1ZG05allYUnBiMjRpT25zaVkyOXVabWxuVTI5MWNtTmxJanA3ZlgxOWZRPT0iLCJzaWduYXR1cmVzIjpbeyJrZXlpZCI6IiIsInNpZyI6Ik1FWUNJUUNrTEV2NkhZZ0svZDdUK0N3NTdXbkZGaHFUTC9WalAyVDA5Q2t1dk1nbDRnSWhBT1hBM0lhWWg1M1FscVk1eVU4cWZxRXJma2tGajlEakZnaWovUTQ2NnJSViJ9XX0=\"\n \tdssePredicateMissingSha256           = \"eyJwYXlsb2FkVHlwZSI6ImFwcGxpY2F0aW9uL3ZuZC5pbi10b3RvK2pzb24iLCJwYXlsb2FkIjoiZXlKZmRIbHdaU0k2SW1oMGRIQnpPaTh2YVc0dGRHOTBieTVwYnk5VGRHRjBaVzFsYm5RdmRqQXVNU0lzSW5CeVpXUnBZMkYwWlZSNWNHVWlPaUpvZEhSd2N6b3ZMM05zYzJFdVpHVjJMM0J5YjNabGJtRnVZMlV2ZGpBdU1pSXNJbk4xWW1wbFkzUWlPbHQ3SW01aGJXVWlPaUppYkc5aUlpd2laR2xuWlhOMElqcDdmWDFkTENKd2NtVmthV05oZEdVaU9uc2lZblZwYkdSbGNpSTZleUpwWkNJNklqSWlmU3dpWW5WcGJHUlVlWEJsSWpvaWVDSXNJbWx1ZG05allYUnBiMjRpT25zaVkyOXVabWxuVTI5MWNtTmxJanA3ZlgxOWZRPT0iLCJzaWduYXR1cmVzIjpbeyJrZXlpZCI6IiIsInNpZyI6Ik1FVUNJQysvM2M4RFo1TGFZTEx6SFZGejE3ZmxHUENlZXVNZ2tIKy8wa2s1cFFLUEFpRUFqTStyYnBBRlJybDdpV0I2Vm9BYVZPZ3U3NjRRM0JKdHI1bHk4VEFHczNrPSJ9XX0=\"\n@@ -46,13 +47,15 @@ func TestVerifyBlobAttestation(t *testing.T) {\n \n \tblobPath := writeBlobFile(t, td, blobContents, \"blob\")\n \tanotherBlobPath := writeBlobFile(t, td, anotherBlobContents, \"other-blob\")\n+\thugeBlobPath := writeBlobFile(t, td, hugeBlobContents, \"huge-blob\")\n \tkeyRef := writeBlobFile(t, td, pubkey, \"cosign.pub\")\n \n \ttests := []struct {\n \t\tdescription   string\n \t\tblobPath      string\n \t\tsignature     string\n \t\tpredicateType string\n+\t\tenv           map[string]string\n \t\tshouldErr     bool\n \t}{\n \t\t{\n@@ -98,11 +101,20 @@ func TestVerifyBlobAttestation(t *testing.T) {\n \t\t\tsignature:     dssePredicateMultipleSubjectsInvalid,\n \t\t\tblobPath:      blobPath,\n \t\t\tshouldErr:     true,\n+\t\t}, {\n+\t\t\tdescription: \"override file size limit\",\n+\t\t\tsignature:   blobSLSAProvenanceSignature,\n+\t\t\tblobPath:    hugeBlobPath,\n+\t\t\tenv:         map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"128\"},\n+\t\t\tshouldErr:   true,\n \t\t},\n \t}\n \n \tfor _, test := range tests {\n \t\tt.Run(test.description, func(t *testing.T) {\n+\t\t\tfor k, v := range test.env {\n+\t\t\t\tt.Setenv(k, v)\n+\t\t\t}\n \t\t\tdecodedSig, err := base64.StdEncoding.DecodeString(test.signature)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)"
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -11,6 +11,7 @@ require (\n \tgithub.com/cyberphone/json-canonicalization v0.0.0-20231011164504-785e29786b46\n \tgithub.com/depcheck-test/depcheck-test v0.0.0-20220607135614-199033aaa936\n \tgithub.com/digitorus/timestamp v0.0.0-20231217203849-220c5c2851b7\n+\tgithub.com/dustin/go-humanize v1.0.1\n \tgithub.com/go-openapi/runtime v0.28.0\n \tgithub.com/go-openapi/strfmt v0.23.0\n \tgithub.com/go-openapi/swag v0.23.0"
        },
        {
          "filename": "internal/pkg/cosign/payload/size/errors.go",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2024 The Sigstore Authors.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package payload\n+\n+import \"fmt\"\n+\n+// MaxLayerSizeExceeded is an error indicating that the layer is too big to read into memory and cosign should abort processing it.\n+type MaxLayerSizeExceeded struct {\n+\tvalue   uint64\n+\tmaximum uint64\n+}\n+\n+func NewMaxLayerSizeExceeded(value, maximum uint64) *MaxLayerSizeExceeded {\n+\treturn &MaxLayerSizeExceeded{value, maximum}\n+}\n+\n+func (e *MaxLayerSizeExceeded) Error() string {\n+\treturn fmt.Sprintf(\"size of layer (%d) exceeded the limit (%d)\", e.value, e.maximum)\n+}"
        },
        {
          "filename": "internal/pkg/cosign/payload/size/size.go",
          "status": "added",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2024 The Sigstore Authors.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package payload\n+\n+import (\n+\t\"github.com/dustin/go-humanize\"\n+\t\"github.com/sigstore/cosign/v2/pkg/cosign/env\"\n+)\n+\n+const defaultMaxSize = uint64(134217728) // 128MiB\n+\n+func CheckSize(size uint64) error {\n+\tmaxSize := defaultMaxSize\n+\tmaxSizeOverride, exists := env.LookupEnv(env.VariableMaxAttachmentSize)\n+\tif exists {\n+\t\tvar err error\n+\t\tmaxSize, err = humanize.ParseBytes(maxSizeOverride)\n+\t\tif err != nil {\n+\t\t\tmaxSize = defaultMaxSize\n+\t\t}\n+\t}\n+\tif size > maxSize {\n+\t\treturn NewMaxLayerSizeExceeded(size, maxSize)\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "internal/pkg/cosign/payload/size/size_test.go",
          "status": "added",
          "additions": 110,
          "deletions": 0,
          "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2024 The Sigstore Authors.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package payload\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestCheckSize(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\tinput   uint64\n+\t\tsetting string\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"size is within default limit\",\n+\t\t\tinput:   1000,\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size exceeds default limit\",\n+\t\t\tinput:   200000000,\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size is within overridden limit (bytes)\",\n+\t\t\tinput:   1000,\n+\t\t\tsetting: \"1024\",\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size is exceeds overridden limit (bytes)\",\n+\t\t\tinput:   2000,\n+\t\t\tsetting: \"1024\",\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size is within overridden limit (megabytes, short form)\",\n+\t\t\tinput:   1999999,\n+\t\t\tsetting: \"2M\",\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size exceeds overridden limit (megabytes, short form)\",\n+\t\t\tinput:   2000001,\n+\t\t\tsetting: \"2M\",\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size is within overridden limit (megabytes, long form)\",\n+\t\t\tinput:   1999999,\n+\t\t\tsetting: \"2MB\",\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size exceeds overridden limit (megabytes, long form)\",\n+\t\t\tinput:   2000001,\n+\t\t\tsetting: \"2MB\",\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size is within overridden limit (mebibytes)\",\n+\t\t\tinput:   2097151,\n+\t\t\tsetting: \"2MiB\",\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size exceeds overridden limit (mebibytes)\",\n+\t\t\tinput:   2097153,\n+\t\t\tsetting: \"2MiB\",\n+\t\t\twantErr: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"size is negative results in default\",\n+\t\t\tinput:   5121,\n+\t\t\tsetting: \"-5KiB\",\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"invalid setting results in default\",\n+\t\t\tinput:   5121,\n+\t\t\tsetting: \"five kilobytes\",\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tif test.setting != \"\" {\n+\t\t\t\tt.Setenv(\"COSIGN_MAX_ATTACHMENT_SIZE\", test.setting)\n+\t\t\t}\n+\t\t\tgot := CheckSize(test.input)\n+\t\t\tif (got != nil) != (test.wantErr) {\n+\t\t\t\tt.Errorf(\"CheckSize() = %v, expected %v\", got, test.wantErr)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "pkg/cosign/env/env.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -51,6 +51,7 @@ const (\n \tVariablePKCS11ModulePath        Variable = \"COSIGN_PKCS11_MODULE_PATH\"\n \tVariablePKCS11IgnoreCertificate Variable = \"COSIGN_PKCS11_IGNORE_CERTIFICATE\"\n \tVariableRepository              Variable = \"COSIGN_REPOSITORY\"\n+\tVariableMaxAttachmentSize       Variable = \"COSIGN_MAX_ATTACHMENT_SIZE\"\n \n \t// Sigstore environment variables\n \tVariableSigstoreCTLogPublicKeyFile Variable = \"SIGSTORE_CT_LOG_PUBLIC_KEY_FILE\"\n@@ -113,6 +114,11 @@ var (\n \t\t\tExpects:     \"string with a repository\",\n \t\t\tSensitive:   false,\n \t\t},\n+\t\tVariableMaxAttachmentSize: {\n+\t\t\tDescription: \"maximum attachment size to download (default 128MiB)\",\n+\t\t\tExpects:     \"human-readable unit of memory, e.g. 5120, 20K, 3M, 45MiB, 1GB\",\n+\t\t\tSensitive:   false,\n+\t\t},\n \n \t\tVariableSigstoreCTLogPublicKeyFile: {\n \t\t\tDescription: \"overrides what is used to validate the SCT coming back from Fulcio\","
        },
        {
          "filename": "pkg/oci/errors.go",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2024 The Sigstore Authors.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package oci\n+\n+import \"fmt\"\n+\n+// MaxLayersExceeded is an error indicating that the artifact has too many layers and cosign should abort processing it.\n+type MaxLayersExceeded struct {\n+\tvalue   int64\n+\tmaximum int64\n+}\n+\n+func NewMaxLayersExceeded(value, maximum int64) *MaxLayersExceeded {\n+\treturn &MaxLayersExceeded{value, maximum}\n+}\n+\n+func (e *MaxLayersExceeded) Error() string {\n+\treturn fmt.Sprintf(\"number of layers (%d) exceeded the limit (%d)\", e.value, e.maximum)\n+}"
        },
        {
          "filename": "pkg/oci/internal/signature/layer.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ import (\n \t\"strings\"\n \n \tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n+\tpayloadsize \"github.com/sigstore/cosign/v2/internal/pkg/cosign/payload/size\"\n \t\"github.com/sigstore/cosign/v2/pkg/cosign/bundle\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci\"\n \t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n@@ -58,6 +59,14 @@ func (s *sigLayer) Annotations() (map[string]string, error) {\n \n // Payload implements oci.Signature\n func (s *sigLayer) Payload() ([]byte, error) {\n+\tsize, err := s.Layer.Size()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\terr = payloadsize.CheckSize(uint64(size))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \t// Compressed is a misnomer here, we just want the raw bytes from the registry.\n \tr, err := s.Layer.Compressed()\n \tif err != nil {"
        },
        {
          "filename": "pkg/oci/internal/signature/layer_test.go",
          "status": "modified",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -20,6 +20,8 @@ import (\n \t\"encoding/base64\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n \t\"testing\"\n \n \t\"github.com/google/go-cmp/cmp\"\n@@ -50,6 +52,7 @@ func TestSignature(t *testing.T) {\n \ttests := []struct {\n \t\tname           string\n \t\tl              *sigLayer\n+\t\tenv            map[string]string\n \t\twantPayloadErr error\n \t\twantSig        string\n \t\twantSigErr     error\n@@ -222,10 +225,39 @@ Hr/+CxFvaJWmpYqNkLDGRU+9orzh5hI2RrcuaQ==\n \t\t},\n \t\twantSig:   \"blah\",\n \t\twantChain: 1,\n+\t}, {\n+\t\tname: \"payload size exceeds default limit\",\n+\t\tl: &sigLayer{\n+\t\t\tLayer: &mockLayer{size: 134217728 + 42}, // 128MB + 42 bytes\n+\t\t},\n+\t\twantPayloadErr: errors.New(\"size of layer (134217770) exceeded the limit (134217728)\"),\n+\t}, {\n+\t\tname: \"payload size exceeds overridden limit\",\n+\t\tl: &sigLayer{\n+\t\t\tLayer: &mockLayer{size: 1000000000 + 42}, // 1GB + 42 bytes\n+\t\t},\n+\t\tenv:            map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"1GB\"},\n+\t\twantPayloadErr: errors.New(\"size of layer (1000000042) exceeded the limit (1000000000)\"),\n+\t}, {\n+\t\tname: \"payload size is within overridden limit\",\n+\t\tl: &sigLayer{\n+\t\t\tLayer: layer,\n+\t\t\tdesc: v1.Descriptor{\n+\t\t\t\tDigest: digest,\n+\t\t\t\tAnnotations: map[string]string{\n+\t\t\t\t\tsigkey: \"blah\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\tenv:     map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"5KB\"},\n+\t\twantSig: \"blah\",\n \t}}\n \n \tfor _, test := range tests {\n \t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tfor k, v := range test.env {\n+\t\t\t\tt.Setenv(k, v)\n+\t\t\t}\n \t\t\tb, err := test.l.Payload()\n \t\t\tswitch {\n \t\t\tcase (err != nil) != (test.wantPayloadErr != nil):\n@@ -239,6 +271,9 @@ Hr/+CxFvaJWmpYqNkLDGRU+9orzh5hI2RrcuaQ==\n \t\t\t\t\tt.Errorf(\"v1.SHA256() = %v, wanted %v\", got, want)\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n \n \t\t\tswitch got, err := test.l.Base64Signature(); {\n \t\t\tcase (err != nil) != (test.wantSigErr != nil):\n@@ -453,3 +488,20 @@ func TestSignatureWithTSAAnnotation(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+type mockLayer struct {\n+\tsize int64\n+}\n+\n+func (m *mockLayer) Size() (int64, error) {\n+\treturn m.size, nil\n+}\n+\n+func (m *mockLayer) Compressed() (io.ReadCloser, error) {\n+\treturn io.NopCloser(strings.NewReader(\"data\")), nil\n+}\n+\n+func (m *mockLayer) Digest() (v1.Hash, error)             { panic(\"not implemented\") }\n+func (m *mockLayer) DiffID() (v1.Hash, error)             { panic(\"not implemented\") }\n+func (m *mockLayer) Uncompressed() (io.ReadCloser, error) { panic(\"not implemented\") }\n+func (m *mockLayer) MediaType() (types.MediaType, error)  { panic(\"not implemented\") }"
        },
        {
          "filename": "pkg/oci/layout/signatures.go",
          "status": "modified",
          "additions": 7,
          "deletions": 1,
          "patch": "@@ -21,6 +21,8 @@ import (\n \t\"github.com/sigstore/cosign/v2/pkg/oci/internal/signature\"\n )\n \n+const maxLayers = 1000\n+\n type sigs struct {\n \tv1.Image\n }\n@@ -33,7 +35,11 @@ func (s *sigs) Get() ([]oci.Signature, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tsignatures := make([]oci.Signature, 0, len(manifest.Layers))\n+\tnumLayers := int64(len(manifest.Layers))\n+\tif numLayers > maxLayers {\n+\t\treturn nil, oci.NewMaxLayersExceeded(numLayers, maxLayers)\n+\t}\n+\tsignatures := make([]oci.Signature, 0, numLayers)\n \tfor _, desc := range manifest.Layers {\n \t\tl, err := s.Image.LayerByDigest(desc.Digest)\n \t\tif err != nil {"
        },
        {
          "filename": "pkg/oci/layout/signatures_test.go",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2024 The Sigstore Authors.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package layout\n+\n+import (\n+\t\"errors\"\n+\t\"testing\"\n+\n+\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n+\t\"github.com/google/go-containerregistry/pkg/v1/fake\"\n+)\n+\n+func TestGet(t *testing.T) {\n+\ttests := []struct {\n+\t\tname      string\n+\t\tlayers    int\n+\t\twantError error\n+\t}{\n+\t\t{\n+\t\t\tname:      \"within limit\",\n+\t\t\tlayers:    23,\n+\t\t\twantError: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"exceeds limit\",\n+\t\t\tlayers:    4242,\n+\t\t\twantError: errors.New(\"number of layers (4242) exceeded the limit (1000)\"),\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\ts := sigs{\n+\t\t\t\tImage: &fake.FakeImage{\n+\t\t\t\t\tManifestStub: func() (*v1.Manifest, error) {\n+\t\t\t\t\t\treturn &v1.Manifest{\n+\t\t\t\t\t\t\tLayers: make([]v1.Descriptor, test.layers),\n+\t\t\t\t\t\t}, nil\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\t_, err := s.Get()\n+\t\t\tif test.wantError != nil && test.wantError.Error() != err.Error() {\n+\t\t\t\tt.Fatalf(\"Get() = %v, wanted %v\", err, test.wantError)\n+\t\t\t}\n+\t\t\tif test.wantError == nil && err != nil {\n+\t\t\t\tt.Fatalf(\"Get() = %v, wanted %v\", err, test.wantError)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "pkg/oci/mutate/signatures.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -23,6 +23,8 @@ import (\n \t\"github.com/sigstore/cosign/v2/pkg/oci\"\n )\n \n+const maxLayers = 1000\n+\n // AppendSignatures produces a new oci.Signatures with the provided signatures\n // appended to the provided base signatures.\n func AppendSignatures(base oci.Signatures, recordCreationTimestamp bool, sigs ...oci.Signature) (oci.Signatures, error) {\n@@ -106,5 +108,9 @@ func (sa *sigAppender) Get() ([]oci.Signature, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tsumLayers := int64(len(sl) + len(sa.sigs))\n+\tif sumLayers > maxLayers {\n+\t\treturn nil, oci.NewMaxLayersExceeded(sumLayers, maxLayers)\n+\t}\n \treturn append(sl, sa.sigs...), nil\n }"
        },
        {
          "filename": "pkg/oci/mutate/signatures_test.go",
          "status": "modified",
          "additions": 63,
          "deletions": 0,
          "patch": "@@ -16,8 +16,11 @@\n package mutate\n \n import (\n+\t\"errors\"\n \t\"testing\"\n \n+\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n+\t\"github.com/sigstore/cosign/v2/pkg/oci\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci/empty\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci/static\"\n )\n@@ -83,3 +86,63 @@ func TestAppendSignatures(t *testing.T) {\n \t\tt.Errorf(\"Date of Signature was Zero\")\n \t}\n }\n+\n+func TestGet(t *testing.T) {\n+\ttests := []struct {\n+\t\tname         string\n+\t\tbaseLayers   int\n+\t\tappendLayers int\n+\t\twantError    error\n+\t}{\n+\t\t{\n+\t\t\tname:         \"within limit\",\n+\t\t\tbaseLayers:   1,\n+\t\t\tappendLayers: 1,\n+\t\t\twantError:    nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"base exceeds limit\",\n+\t\t\tbaseLayers:   2000,\n+\t\t\tappendLayers: 1,\n+\t\t\twantError:    errors.New(\"number of layers (2001) exceeded the limit (1000)\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"append exceeds limit\",\n+\t\t\tbaseLayers:   1,\n+\t\t\tappendLayers: 1300,\n+\t\t\twantError:    errors.New(\"number of layers (1301) exceeded the limit (1000)\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"sum exceeds limit\",\n+\t\t\tbaseLayers:   666,\n+\t\t\tappendLayers: 666,\n+\t\t\twantError:    errors.New(\"number of layers (1332) exceeded the limit (1000)\"),\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tsa := sigAppender{\n+\t\t\t\tbase: &mockOCISignatures{\n+\t\t\t\t\tsignatures: make([]oci.Signature, test.baseLayers),\n+\t\t\t\t},\n+\t\t\t\tsigs: make([]oci.Signature, test.appendLayers),\n+\t\t\t}\n+\t\t\t_, err := sa.Get()\n+\t\t\tif test.wantError != nil && test.wantError.Error() != err.Error() {\n+\t\t\t\tt.Fatalf(\"Get() = %v, wanted %v\", err, test.wantError)\n+\t\t\t}\n+\t\t\tif test.wantError == nil && err != nil {\n+\t\t\t\tt.Fatalf(\"Get() = %v, wanted %v\", err, test.wantError)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+type mockOCISignatures struct {\n+\tv1.Image\n+\tsignatures []oci.Signature\n+}\n+\n+func (m *mockOCISignatures) Get() ([]oci.Signature, error) {\n+\treturn m.signatures, nil\n+}"
        },
        {
          "filename": "pkg/oci/remote/remote.go",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -26,6 +26,7 @@ import (\n \t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n \t\"github.com/google/go-containerregistry/pkg/v1/remote/transport\"\n \t\"github.com/google/go-containerregistry/pkg/v1/types\"\n+\tpayloadsize \"github.com/sigstore/cosign/v2/internal/pkg/cosign/payload/size\"\n \tociexperimental \"github.com/sigstore/cosign/v2/internal/pkg/oci/remote\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci\"\n )\n@@ -226,6 +227,15 @@ func (f *attached) FileMediaType() (types.MediaType, error) {\n \n // Payload implements oci.File\n func (f *attached) Payload() ([]byte, error) {\n+\tsize, err := f.layer.Size()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\terr = payloadsize.CheckSize(uint64(size))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \t// remote layers are believed to be stored\n \t// compressed, but we don't compress attachments\n \t// so use \"Compressed\" to access the raw byte"
        },
        {
          "filename": "pkg/oci/remote/remote_test.go",
          "status": "modified",
          "additions": 70,
          "deletions": 0,
          "patch": "@@ -17,11 +17,14 @@ package remote\n \n import (\n \t\"errors\"\n+\t\"io\"\n+\t\"strings\"\n \t\"testing\"\n \n \t\"github.com/google/go-containerregistry/pkg/name\"\n \tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n \t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n+\t\"github.com/google/go-containerregistry/pkg/v1/types\"\n )\n \n func TestTagMethods(t *testing.T) {\n@@ -203,3 +206,70 @@ func TestDockercontentDigest(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestPayload(t *testing.T) {\n+\ttests := []struct {\n+\t\tname      string\n+\t\tsize      int64\n+\t\tenv       map[string]string\n+\t\twantError error\n+\t}{\n+\t\t{\n+\t\t\tname:      \"within default limit\",\n+\t\t\tsize:      1000,\n+\t\t\twantError: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"excceds default limit\",\n+\t\t\tsize:      1073741824,\n+\t\t\twantError: errors.New(\"size of layer (1073741824) exceeded the limit (134217728)\"),\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"exceeds overridden limit\",\n+\t\t\tsize:      5120,\n+\t\t\tenv:       map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"1KB\"},\n+\t\t\twantError: errors.New(\"size of layer (5120) exceeded the limit (1000)\"),\n+\t\t},\n+\t\t{\n+\t\t\tname: \"within overridden limit\",\n+\t\t\tsize: 5120,\n+\t\t\tenv:  map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"10KB\"},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tfor k, v := range test.env {\n+\t\t\t\tt.Setenv(k, v)\n+\t\t\t}\n+\t\t\ta := attached{\n+\t\t\t\tlayer: &mockLayer{\n+\t\t\t\t\tsize: test.size,\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\t_, err := a.Payload()\n+\t\t\tif test.wantError != nil && test.wantError.Error() != err.Error() {\n+\t\t\t\tt.Fatalf(\"Payload() = %v, wanted %v\", err, test.wantError)\n+\t\t\t}\n+\t\t\tif test.wantError == nil && err != nil {\n+\t\t\t\tt.Fatalf(\"Payload() = %v, wanted %v\", err, test.wantError)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+type mockLayer struct {\n+\tsize int64\n+}\n+\n+func (m *mockLayer) Compressed() (io.ReadCloser, error) {\n+\treturn io.NopCloser(strings.NewReader(\"test payload\")), nil\n+}\n+\n+func (m *mockLayer) Size() (int64, error) {\n+\treturn m.size, nil\n+}\n+\n+func (m *mockLayer) Digest() (v1.Hash, error)             { panic(\"not implemented\") }\n+func (m *mockLayer) DiffID() (v1.Hash, error)             { panic(\"not implemented\") }\n+func (m *mockLayer) Uncompressed() (io.ReadCloser, error) { panic(\"not implemented\") }\n+func (m *mockLayer) MediaType() (types.MediaType, error)  { panic(\"not implemented\") }"
        },
        {
          "filename": "pkg/oci/remote/signatures.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -27,6 +27,8 @@ import (\n \t\"github.com/sigstore/cosign/v2/pkg/oci/internal/signature\"\n )\n \n+const maxLayers = 1000\n+\n // Signatures fetches the signatures image represented by the named reference.\n // If the tag is not found, this returns an empty oci.Signatures.\n func Signatures(ref name.Reference, opts ...Option) (oci.Signatures, error) {\n@@ -58,6 +60,10 @@ func (s *sigs) Get() ([]oci.Signature, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tnumLayers := int64(len(m.Layers))\n+\tif numLayers > maxLayers {\n+\t\treturn nil, oci.NewMaxLayersExceeded(numLayers, maxLayers)\n+\t}\n \tsignatures := make([]oci.Signature, 0, len(m.Layers))\n \tfor _, desc := range m.Layers {\n \t\tlayer, err := s.Image.LayerByDigest(desc.Digest)"
        },
        {
          "filename": "pkg/oci/remote/signatures_test.go",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ import (\n \n \t\"github.com/google/go-containerregistry/pkg/name\"\n \tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n+\t\"github.com/google/go-containerregistry/pkg/v1/fake\"\n \t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n \t\"github.com/google/go-containerregistry/pkg/v1/remote/transport\"\n )\n@@ -75,4 +76,25 @@ func TestSignaturesErrors(t *testing.T) {\n \t\t\tt.Fatalf(\"Signatures() = %v, wanted %v\", err, want)\n \t\t}\n \t})\n+\n+\tt.Run(\"too many layers\", func(t *testing.T) {\n+\t\tremoteImage = func(_ name.Reference, _ ...remote.Option) (v1.Image, error) {\n+\t\t\treturn &fake.FakeImage{\n+\t\t\t\tManifestStub: func() (*v1.Manifest, error) {\n+\t\t\t\t\treturn &v1.Manifest{\n+\t\t\t\t\t\tLayers: make([]v1.Descriptor, 10000),\n+\t\t\t\t\t}, nil\n+\t\t\t\t},\n+\t\t\t}, nil\n+\t\t}\n+\t\tsigs, err := Signatures(name.MustParseReference(\"gcr.io/distroless/static:sha256-deadbeef.sig\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Signatures() = %v\", err)\n+\t\t}\n+\t\twant := errors.New(\"number of layers (10000) exceeded the limit (1000)\")\n+\t\t_, err = sigs.Get()\n+\t\tif err == nil || want.Error() != err.Error() {\n+\t\t\tt.Fatalf(\"Get() = %v\", err)\n+\t\t}\n+\t})\n }"
        },
        {
          "filename": "pkg/oci/signature/layer.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -24,6 +24,7 @@ import (\n \t\"strings\"\n \n \tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n+\tpayloadsize \"github.com/sigstore/cosign/v2/internal/pkg/cosign/payload/size\"\n \t\"github.com/sigstore/cosign/v2/pkg/cosign/bundle\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci\"\n \t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n@@ -58,6 +59,14 @@ func (s *sigLayer) Annotations() (map[string]string, error) {\n \n // Payload implements oci.Signature\n func (s *sigLayer) Payload() ([]byte, error) {\n+\tsize, err := s.Layer.Size()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\terr = payloadsize.CheckSize(uint64(size))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \t// Compressed is a misnomer here, we just want the raw bytes from the registry.\n \tr, err := s.Layer.Compressed()\n \tif err != nil {"
        },
        {
          "filename": "pkg/oci/signature/layer_test.go",
          "status": "modified",
          "additions": 52,
          "deletions": 0,
          "patch": "@@ -20,6 +20,8 @@ import (\n \t\"encoding/base64\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n \t\"testing\"\n \n \t\"github.com/google/go-cmp/cmp\"\n@@ -292,6 +294,7 @@ func TestSignatureWithTSAAnnotation(t *testing.T) {\n \ttests := []struct {\n \t\tname           string\n \t\tl              *sigLayer\n+\t\tenv            map[string]string\n \t\twantPayloadErr error\n \t\twantSig        string\n \t\twantSigErr     error\n@@ -397,10 +400,39 @@ func TestSignatureWithTSAAnnotation(t *testing.T) {\n \t\twantBundle: &bundle.RFC3161Timestamp{\n \t\t\tSignedRFC3161Timestamp: mustDecode(\"MEUCIQClUkUqZNf+6dxBc/pxq22JIluTB7Kmip1G0FIF5E0C1wIgLqXm+IM3JYW/P/qjMZSXW+J8bt5EOqNfe3R+0A9ooFE=\"),\n \t\t},\n+\t}, {\n+\t\tname: \"payload size exceeds default limit\",\n+\t\tl: &sigLayer{\n+\t\t\tLayer: &mockLayer{size: 134217728 + 42}, // 128MiB + 42 bytes\n+\t\t},\n+\t\twantPayloadErr: errors.New(\"size of layer (134217770) exceeded the limit (134217728)\"),\n+\t}, {\n+\t\tname: \"payload size exceeds overridden limit\",\n+\t\tl: &sigLayer{\n+\t\t\tLayer: &mockLayer{size: 1000000000 + 42}, // 1GB + 42 bytes\n+\t\t},\n+\t\tenv:            map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"1GB\"},\n+\t\twantPayloadErr: errors.New(\"size of layer (1000000042) exceeded the limit (1000000000)\"),\n+\t}, {\n+\t\tname: \"payload size is within overridden limit\",\n+\t\tl: &sigLayer{\n+\t\t\tLayer: layer,\n+\t\t\tdesc: v1.Descriptor{\n+\t\t\t\tDigest: digest,\n+\t\t\t\tAnnotations: map[string]string{\n+\t\t\t\t\tsigkey: \"blah\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\tenv:     map[string]string{\"COSIGN_MAX_ATTACHMENT_SIZE\": \"5KB\"},\n+\t\twantSig: \"blah\",\n \t}}\n \n \tfor _, test := range tests {\n \t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tfor k, v := range test.env {\n+\t\t\t\tt.Setenv(k, v)\n+\t\t\t}\n \t\t\tb, err := test.l.Payload()\n \t\t\tswitch {\n \t\t\tcase (err != nil) != (test.wantPayloadErr != nil):\n@@ -414,6 +446,9 @@ func TestSignatureWithTSAAnnotation(t *testing.T) {\n \t\t\t\t\tt.Errorf(\"v1.SHA256() = %v, wanted %v\", got, want)\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n \n \t\t\tswitch got, err := test.l.Base64Signature(); {\n \t\t\tcase (err != nil) != (test.wantSigErr != nil):\n@@ -453,3 +488,20 @@ func TestSignatureWithTSAAnnotation(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+type mockLayer struct {\n+\tsize int64\n+}\n+\n+func (m *mockLayer) Size() (int64, error) {\n+\treturn m.size, nil\n+}\n+\n+func (m *mockLayer) Compressed() (io.ReadCloser, error) {\n+\treturn io.NopCloser(strings.NewReader(\"data\")), nil\n+}\n+\n+func (m *mockLayer) Digest() (v1.Hash, error)             { panic(\"not implemented\") }\n+func (m *mockLayer) DiffID() (v1.Hash, error)             { panic(\"not implemented\") }\n+func (m *mockLayer) Uncompressed() (io.ReadCloser, error) { panic(\"not implemented\") }\n+func (m *mockLayer) MediaType() (types.MediaType, error)  { panic(\"not implemented\") }"
        },
        {
          "filename": "pkg/oci/static/file.go",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ import (\n \t\"github.com/google/go-containerregistry/pkg/v1/empty\"\n \t\"github.com/google/go-containerregistry/pkg/v1/mutate\"\n \t\"github.com/google/go-containerregistry/pkg/v1/types\"\n+\tpayloadsize \"github.com/sigstore/cosign/v2/internal/pkg/cosign/payload/size\"\n \t\"github.com/sigstore/cosign/v2/internal/pkg/now\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci\"\n \t\"github.com/sigstore/cosign/v2/pkg/oci/signed\"\n@@ -82,6 +83,14 @@ func (f *file) FileMediaType() (types.MediaType, error) {\n \n // Payload implements oci.File\n func (f *file) Payload() ([]byte, error) {\n+\tsize, err := f.layer.Size()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\terr = payloadsize.CheckSize(uint64(size))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \trc, err := f.layer.Uncompressed()\n \tif err != nil {\n \t\treturn nil, err"
        },
        {
          "filename": "pkg/oci/static/file_test.go",
          "status": "modified",
          "additions": 42,
          "deletions": 6,
          "patch": "@@ -16,6 +16,7 @@\n package static\n \n import (\n+\t\"errors\"\n \t\"io\"\n \t\"strings\"\n \t\"testing\"\n@@ -27,7 +28,7 @@ import (\n \n func TestNewFile(t *testing.T) {\n \tpayload := \"this is the content!\"\n-\tfile, err := NewFile([]byte(payload), WithLayerMediaType(\"foo\"), WithAnnotations(map[string]string{\"foo\": \"bar\"}))\n+\tf, err := NewFile([]byte(payload), WithLayerMediaType(\"foo\"), WithAnnotations(map[string]string{\"foo\": \"bar\"}))\n \tif err != nil {\n \t\tt.Fatalf(\"NewFile() = %v\", err)\n \t}\n@@ -38,7 +39,7 @@ func TestNewFile(t *testing.T) {\n \t\tt.Fatalf(\"NewFile() = %v\", err)\n \t}\n \n-\tlayers, err := file.Layers()\n+\tlayers, err := f.Layers()\n \tif err != nil {\n \t\tt.Fatalf(\"Layers() = %v\", err)\n \t} else if got, want := len(layers), 1; got != want {\n@@ -59,7 +60,7 @@ func TestNewFile(t *testing.T) {\n \n \tt.Run(\"check media type\", func(t *testing.T) {\n \t\twantMT := types.MediaType(\"foo\")\n-\t\tgotMT, err := file.FileMediaType()\n+\t\tgotMT, err := f.FileMediaType()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"MediaType() = %v\", err)\n \t\t}\n@@ -118,7 +119,7 @@ func TestNewFile(t *testing.T) {\n \t\t\tt.Errorf(\"Uncompressed() = %s, wanted %s\", got, want)\n \t\t}\n \n-\t\tgotPayload, err := file.Payload()\n+\t\tgotPayload, err := f.Payload()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Payload() = %v\", err)\n \t\t}\n@@ -128,7 +129,7 @@ func TestNewFile(t *testing.T) {\n \t})\n \n \tt.Run(\"check date\", func(t *testing.T) {\n-\t\tfileCfg, err := file.ConfigFile()\n+\t\tfileCfg, err := f.ConfigFile()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"ConfigFile() = %v\", err)\n \t\t}\n@@ -145,7 +146,7 @@ func TestNewFile(t *testing.T) {\n \t})\n \n \tt.Run(\"check annotations\", func(t *testing.T) {\n-\t\tm, err := file.Manifest()\n+\t\tm, err := f.Manifest()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Manifest() = %v\", err)\n \t\t}\n@@ -154,4 +155,39 @@ func TestNewFile(t *testing.T) {\n \t\t\tt.Errorf(\"Annotations = %s, wanted %s\", got, want)\n \t\t}\n \t})\n+\n+\tt.Run(\"huge file payload\", func(t *testing.T) {\n+\t\t// default limit\n+\t\tf := file{\n+\t\t\tlayer: &mockLayer{200000000},\n+\t\t}\n+\t\twant := errors.New(\"size of layer (200000000) exceeded the limit (134217728)\")\n+\t\t_, err = f.Payload()\n+\t\tif err == nil || want.Error() != err.Error() {\n+\t\t\tt.Errorf(\"Payload() = %v, wanted %v\", err, want)\n+\t\t}\n+\t\t// override limit\n+\t\tt.Setenv(\"COSIGN_MAX_ATTACHMENT_SIZE\", \"512MiB\")\n+\t\t_, err = f.Payload()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Payload() = %v, wanted nil\", err)\n+\t\t}\n+\t})\n }\n+\n+type mockLayer struct {\n+\tsize int64\n+}\n+\n+func (m *mockLayer) Size() (int64, error) {\n+\treturn m.size, nil\n+}\n+\n+func (m *mockLayer) Uncompressed() (io.ReadCloser, error) {\n+\treturn io.NopCloser(strings.NewReader(\"data\")), nil\n+}\n+\n+func (m *mockLayer) Digest() (v1.Hash, error)            { panic(\"not implemented\") }\n+func (m *mockLayer) DiffID() (v1.Hash, error)            { panic(\"not implemented\") }\n+func (m *mockLayer) Compressed() (io.ReadCloser, error)  { panic(\"not implemented\") }\n+func (m *mockLayer) MediaType() (types.MediaType, error) { panic(\"not implemented\") }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 10,
        "unique_directories": 11,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "accc80a840524890790c5c368fee26e22ec60bda",
            "date": "2025-01-13T20:41:02Z",
            "author_login": "codysoyland"
          },
          {
            "sha": "e5aa062fa9e4c8b893cf14e77f07127031395ca9",
            "date": "2025-01-13T17:30:27Z",
            "author_login": "haydentherapper"
          },
          {
            "sha": "d01988ed7edc1d9c67d3383e7a02b988ba7d14fd",
            "date": "2025-01-13T03:54:54Z",
            "author_login": "nianyush"
          },
          {
            "sha": "87c08b00fca8a96a2ef756cee3953372a5783a45",
            "date": "2025-01-10T08:26:43Z",
            "author_login": "cpanato"
          },
          {
            "sha": "342f8d89f88f1de022d35d720b54322cfe7352fb",
            "date": "2025-01-09T16:07:26Z",
            "author_login": "cmurphy"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "Cosign provides code signing and transparency for containers and binaries. Prior to version 2.2.4, a remote image with a malicious attachment can cause denial of service of the host machine running Cosign. This can impact other services on the machine that rely on having memory available such as a Redis database which can result in data loss. It can also impact the availability of other services on the machine that will not be available for the duration of the machine denial. The root cause of this issue is that Cosign reads the attachment from a remote image entirely into memory without checking the size of the attachment first. As such, a large attachment can make Cosign read a large attachment into memory; If the attachments size is larger than the machine has memory available, the machine will be denied of service. The Go runtime will make a SigKill after a few seconds of system-wide denial. This issue can allow a supply-chain escalation from a compromised registry to the Cosign user: If an attacher has compromised a registry or the account of an image vendor, they can include a malicious attachment and hurt the image consumer. Version 2.2.4 contains a patch for the vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-04-10T23:15:06.920",
    "last_modified": "2025-01-09T15:56:50.707",
    "fix_date": "2024-04-10T21:57:21Z"
  },
  "references": [
    {
      "url": "https://github.com/google/go-containerregistry/blob/a0658aa1d0cc7a7f1bcc4a3af9155335b6943f40/pkg/v1/remote/layer.go#L36-L40",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/blob/9bc3ee309bf35d2f6e17f5d23f231a3d8bf580bc/pkg/oci/remote/remote.go#L228-L239",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/commit/629f5f8fa672973503edde75f84dcd984637629e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/releases/tag/v2.2.4",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-88jx-383q-w4qc",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/google/go-containerregistry/blob/a0658aa1d0cc7a7f1bcc4a3af9155335b6943f40/pkg/v1/remote/layer.go#L36-L40",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/blob/9bc3ee309bf35d2f6e17f5d23f231a3d8bf580bc/pkg/oci/remote/remote.go#L228-L239",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/commit/629f5f8fa672973503edde75f84dcd984637629e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/releases/tag/v2.2.4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-88jx-383q-w4qc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.471484",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cosign",
    "owner": "sigstore",
    "created_at": "2021-02-04T12:49:39Z",
    "updated_at": "2025-01-14T13:11:06Z",
    "pushed_at": "2025-01-13T20:41:02Z",
    "size": 22969,
    "stars": 4642,
    "forks": 553,
    "open_issues": 250,
    "watchers": 4642,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.13"
    ],
    "languages": {
      "Go": 1543441,
      "Shell": 15352,
      "Makefile": 8067,
      "PowerShell": 1530
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:36:50.204114"
  }
}