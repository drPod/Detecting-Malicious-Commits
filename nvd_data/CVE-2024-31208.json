{
  "cve_id": "CVE-2024-31208",
  "github_data": {
    "repository": "element-hq/synapse",
    "fix_commit": "55b0aa847a61774b6a3acdc4b177a20dc019f01a",
    "related_commits": [
      "55b0aa847a61774b6a3acdc4b177a20dc019f01a",
      "55b0aa847a61774b6a3acdc4b177a20dc019f01a"
    ],
    "patch_url": "https://github.com/element-hq/synapse/commit/55b0aa847a61774b6a3acdc4b177a20dc019f01a.patch",
    "fix_commit_details": {
      "sha": "55b0aa847a61774b6a3acdc4b177a20dc019f01a",
      "commit_date": "2024-04-23T14:24:08Z",
      "author": {
        "login": "erikjohnston",
        "type": "User",
        "stats": {
          "total_commits": 7906,
          "average_weekly_commits": 14.506422018348625,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 472
        }
      },
      "commit_message": {
        "title": "Fix GHSA-3h7q-rfh9-xm4v",
        "length": 556,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 221,
        "additions": 117,
        "deletions": 104
      },
      "files": [
        {
          "filename": "changelog.d/17044.misc",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Refactor auth chain fetching to reduce duplication."
        },
        {
          "filename": "synapse/storage/databases/main/events.py",
          "status": "modified",
          "additions": 37,
          "deletions": 71,
          "patch": "@@ -19,6 +19,7 @@\n # [This file includes modifications made by New Vector Limited]\n #\n #\n+import collections\n import itertools\n import logging\n from collections import OrderedDict\n@@ -53,6 +54,7 @@\n     LoggingDatabaseConnection,\n     LoggingTransaction,\n )\n+from synapse.storage.databases.main.event_federation import EventFederationStore\n from synapse.storage.databases.main.events_worker import EventCacheEntry\n from synapse.storage.databases.main.search import SearchEntry\n from synapse.storage.engines import PostgresEngine\n@@ -768,40 +770,26 @@ def _add_chain_cover_index(\n         #      that have the same chain ID as the event.\n         #   2. For each retained auth event we:\n         #       a. Add a link from the event's to the auth event's chain\n-        #          ID/sequence number; and\n-        #       b. Add a link from the event to every chain reachable by the\n-        #          auth event.\n+        #          ID/sequence number\n \n         # Step 1, fetch all existing links from all the chains we've seen\n         # referenced.\n         chain_links = _LinkMap()\n-        auth_chain_rows = cast(\n-            List[Tuple[int, int, int, int]],\n-            db_pool.simple_select_many_txn(\n-                txn,\n-                table=\"event_auth_chain_links\",\n-                column=\"origin_chain_id\",\n-                iterable={chain_id for chain_id, _ in chain_map.values()},\n-                keyvalues={},\n-                retcols=(\n-                    \"origin_chain_id\",\n-                    \"origin_sequence_number\",\n-                    \"target_chain_id\",\n-                    \"target_sequence_number\",\n-                ),\n-            ),\n-        )\n-        for (\n-            origin_chain_id,\n-            origin_sequence_number,\n-            target_chain_id,\n-            target_sequence_number,\n-        ) in auth_chain_rows:\n-            chain_links.add_link(\n-                (origin_chain_id, origin_sequence_number),\n-                (target_chain_id, target_sequence_number),\n-                new=False,\n-            )\n+\n+        for links in EventFederationStore._get_chain_links(\n+            txn, {chain_id for chain_id, _ in chain_map.values()}\n+        ):\n+            for origin_chain_id, inner_links in links.items():\n+                for (\n+                    origin_sequence_number,\n+                    target_chain_id,\n+                    target_sequence_number,\n+                ) in inner_links:\n+                    chain_links.add_link(\n+                        (origin_chain_id, origin_sequence_number),\n+                        (target_chain_id, target_sequence_number),\n+                        new=False,\n+                    )\n \n         # We do this in toplogical order to avoid adding redundant links.\n         for event_id in sorted_topologically(\n@@ -836,18 +824,6 @@ def _add_chain_cover_index(\n                     (chain_id, sequence_number), (auth_chain_id, auth_sequence_number)\n                 )\n \n-                # Step 2b, add a link to chains reachable from the auth\n-                # event.\n-                for target_id, target_seq in chain_links.get_links_from(\n-                    (auth_chain_id, auth_sequence_number)\n-                ):\n-                    if target_id == chain_id:\n-                        continue\n-\n-                    chain_links.add_link(\n-                        (chain_id, sequence_number), (target_id, target_seq)\n-                    )\n-\n         db_pool.simple_insert_many_txn(\n             txn,\n             table=\"event_auth_chain_links\",\n@@ -2451,31 +2427,6 @@ def add_link(\n         current_links[src_seq] = target_seq\n         return True\n \n-    def get_links_from(\n-        self, src_tuple: Tuple[int, int]\n-    ) -> Generator[Tuple[int, int], None, None]:\n-        \"\"\"Gets the chains reachable from the given chain/sequence number.\n-\n-        Yields:\n-            The chain ID and sequence number the link points to.\n-        \"\"\"\n-        src_chain, src_seq = src_tuple\n-        for target_id, sequence_numbers in self.maps.get(src_chain, {}).items():\n-            for link_src_seq, target_seq in sequence_numbers.items():\n-                if link_src_seq <= src_seq:\n-                    yield target_id, target_seq\n-\n-    def get_links_between(\n-        self, source_chain: int, target_chain: int\n-    ) -> Generator[Tuple[int, int], None, None]:\n-        \"\"\"Gets the links between two chains.\n-\n-        Yields:\n-            The source and target sequence numbers.\n-        \"\"\"\n-\n-        yield from self.maps.get(source_chain, {}).get(target_chain, {}).items()\n-\n     def get_additions(self) -> Generator[Tuple[int, int, int, int], None, None]:\n         \"\"\"Gets any newly added links.\n \n@@ -2502,9 +2453,24 @@ def exists_path_from(\n         if src_chain == target_chain:\n             return target_seq <= src_seq\n \n-        links = self.get_links_between(src_chain, target_chain)\n-        for link_start_seq, link_end_seq in links:\n-            if link_start_seq <= src_seq and target_seq <= link_end_seq:\n-                return True\n+        # We have to graph traverse the links to check for indirect paths.\n+        visited_chains = collections.Counter()\n+        search = [(src_chain, src_seq)]\n+        while search:\n+            chain, seq = search.pop()\n+            visited_chains[chain] = max(seq, visited_chains[chain])\n+            for tc, links in self.maps.get(chain, {}).items():\n+                for ss, ts in links.items():\n+                    # Don't revisit chains we've already seen, unless the target\n+                    # sequence number is higher than last time.\n+                    if ts <= visited_chains.get(tc, 0):\n+                        continue\n+\n+                    if ss <= seq:\n+                        if tc == target_chain:\n+                            if target_seq <= ts:\n+                                return True\n+                        else:\n+                            search.append((tc, ts))\n \n         return False"
        },
        {
          "filename": "synapse/storage/schema/__init__.py",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -132,12 +132,16 @@\n \n Changes in SCHEMA_VERSION = 83\n     - The event_txn_id is no longer used.\n+\n+Changes in SCHEMA_VERSION = 84\n+    - No longer assumes that `event_auth_chain_links` holds transitive links, and\n+      so read operations must do graph traversal.\n \"\"\"\n \n \n SCHEMA_COMPAT_VERSION = (\n-    # The event_txn_id table and tables from MSC2716 no longer exist.\n-    83\n+    # Transitive links are no longer written to `event_auth_chain_links`\n+    84\n )\n \"\"\"Limit on how far the synapse codebase can be rolled back without breaking db compat\n "
        },
        {
          "filename": "tests/storage/test_event_chain.py",
          "status": "modified",
          "additions": 73,
          "deletions": 31,
          "patch": "@@ -21,6 +21,8 @@\n \n from typing import Dict, List, Set, Tuple, cast\n \n+from parameterized import parameterized\n+\n from twisted.test.proto_helpers import MemoryReactor\n from twisted.trial import unittest\n \n@@ -45,14 +47,16 @@ def prepare(self, reactor: MemoryReactor, clock: Clock, hs: HomeServer) -> None:\n         self.store = hs.get_datastores().main\n         self._next_stream_ordering = 1\n \n-    def test_simple(self) -> None:\n+    @parameterized.expand([(False,), (True,)])\n+    def test_simple(self, batched: bool) -> None:\n         \"\"\"Test that the example in `docs/auth_chain_difference_algorithm.md`\n         works.\n         \"\"\"\n \n         event_factory = self.hs.get_event_builder_factory()\n         bob = \"@creator:test\"\n         alice = \"@alice:test\"\n+        charlie = \"@charlie:test\"\n         room_id = \"!room:test\"\n \n         # Ensure that we have a rooms entry so that we generate the chain index.\n@@ -191,6 +195,26 @@ def test_simple(self) -> None:\n             )\n         )\n \n+        charlie_invite = self.get_success(\n+            event_factory.for_room_version(\n+                RoomVersions.V6,\n+                {\n+                    \"type\": EventTypes.Member,\n+                    \"state_key\": charlie,\n+                    \"sender\": alice,\n+                    \"room_id\": room_id,\n+                    \"content\": {\"tag\": \"charlie_invite\"},\n+                },\n+            ).build(\n+                prev_event_ids=[],\n+                auth_event_ids=[\n+                    create.event_id,\n+                    alice_join2.event_id,\n+                    power_2.event_id,\n+                ],\n+            )\n+        )\n+\n         events = [\n             create,\n             bob_join,\n@@ -200,33 +224,41 @@ def test_simple(self) -> None:\n             bob_join_2,\n             power_2,\n             alice_join2,\n+            charlie_invite,\n         ]\n \n         expected_links = [\n             (bob_join, create),\n-            (power, create),\n             (power, bob_join),\n-            (alice_invite, create),\n             (alice_invite, power),\n-            (alice_invite, bob_join),\n             (bob_join_2, power),\n             (alice_join2, power_2),\n+            (charlie_invite, alice_join2),\n         ]\n \n-        self.persist(events)\n+        # We either persist as a batch or one-by-one depending on test\n+        # parameter.\n+        if batched:\n+            self.persist(events)\n+        else:\n+            for event in events:\n+                self.persist([event])\n+\n         chain_map, link_map = self.fetch_chains(events)\n \n         # Check that the expected links and only the expected links have been\n         # added.\n-        self.assertEqual(len(expected_links), len(list(link_map.get_additions())))\n-\n-        for start, end in expected_links:\n-            start_id, start_seq = chain_map[start.event_id]\n-            end_id, end_seq = chain_map[end.event_id]\n+        event_map = {e.event_id: e for e in events}\n+        reverse_chain_map = {v: event_map[k] for k, v in chain_map.items()}\n \n-            self.assertIn(\n-                (start_seq, end_seq), list(link_map.get_links_between(start_id, end_id))\n-            )\n+        self.maxDiff = None\n+        self.assertCountEqual(\n+            expected_links,\n+            [\n+                (reverse_chain_map[(s1, s2)], reverse_chain_map[(t1, t2)])\n+                for s1, s2, t1, t2 in link_map.get_additions()\n+            ],\n+        )\n \n         # Test that everything can reach the create event, but the create event\n         # can't reach anything.\n@@ -368,24 +400,23 @@ def test_out_of_order_events(self) -> None:\n \n         expected_links = [\n             (bob_join, create),\n-            (power, create),\n             (power, bob_join),\n-            (alice_invite, create),\n             (alice_invite, power),\n-            (alice_invite, bob_join),\n         ]\n \n         # Check that the expected links and only the expected links have been\n         # added.\n-        self.assertEqual(len(expected_links), len(list(link_map.get_additions())))\n+        event_map = {e.event_id: e for e in events}\n+        reverse_chain_map = {v: event_map[k] for k, v in chain_map.items()}\n \n-        for start, end in expected_links:\n-            start_id, start_seq = chain_map[start.event_id]\n-            end_id, end_seq = chain_map[end.event_id]\n-\n-            self.assertIn(\n-                (start_seq, end_seq), list(link_map.get_links_between(start_id, end_id))\n-            )\n+        self.maxDiff = None\n+        self.assertCountEqual(\n+            expected_links,\n+            [\n+                (reverse_chain_map[(s1, s2)], reverse_chain_map[(t1, t2)])\n+                for s1, s2, t1, t2 in link_map.get_additions()\n+            ],\n+        )\n \n     def persist(\n         self,\n@@ -489,8 +520,6 @@ def test_simple(self) -> None:\n         link_map = _LinkMap()\n \n         link_map.add_link((1, 1), (2, 1), new=False)\n-        self.assertCountEqual(link_map.get_links_between(1, 2), [(1, 1)])\n-        self.assertCountEqual(link_map.get_links_from((1, 1)), [(2, 1)])\n         self.assertCountEqual(link_map.get_additions(), [])\n         self.assertTrue(link_map.exists_path_from((1, 5), (2, 1)))\n         self.assertFalse(link_map.exists_path_from((1, 5), (2, 2)))\n@@ -499,18 +528,31 @@ def test_simple(self) -> None:\n \n         # Attempting to add a redundant link is ignored.\n         self.assertFalse(link_map.add_link((1, 4), (2, 1)))\n-        self.assertCountEqual(link_map.get_links_between(1, 2), [(1, 1)])\n+        self.assertCountEqual(link_map.get_additions(), [])\n \n         # Adding new non-redundant links works\n         self.assertTrue(link_map.add_link((1, 3), (2, 3)))\n-        self.assertCountEqual(link_map.get_links_between(1, 2), [(1, 1), (3, 3)])\n+        self.assertCountEqual(link_map.get_additions(), [(1, 3, 2, 3)])\n \n         self.assertTrue(link_map.add_link((2, 5), (1, 3)))\n-        self.assertCountEqual(link_map.get_links_between(2, 1), [(5, 3)])\n-        self.assertCountEqual(link_map.get_links_between(1, 2), [(1, 1), (3, 3)])\n-\n         self.assertCountEqual(link_map.get_additions(), [(1, 3, 2, 3), (2, 5, 1, 3)])\n \n+    def test_exists_path_from(self) -> None:\n+        \"Check that `exists_path_from` can handle non-direct links\"\n+        link_map = _LinkMap()\n+\n+        link_map.add_link((1, 1), (2, 1), new=False)\n+        link_map.add_link((2, 1), (3, 1), new=False)\n+\n+        self.assertTrue(link_map.exists_path_from((1, 4), (3, 1)))\n+        self.assertFalse(link_map.exists_path_from((1, 4), (3, 2)))\n+\n+        link_map.add_link((1, 5), (2, 3), new=False)\n+        link_map.add_link((2, 2), (3, 3), new=False)\n+\n+        self.assertTrue(link_map.exists_path_from((1, 6), (3, 2)))\n+        self.assertFalse(link_map.exists_path_from((1, 4), (3, 2)))\n+\n \n class EventChainBackgroundUpdateTestCase(HomeserverTestCase):\n     servlets = ["
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "39bd6e2c167dd2c8b1b46ea449f34ecf072fd614",
            "date": "2025-01-14T15:41:08Z",
            "author_login": "anoadragon453"
          },
          {
            "sha": "5c736cd2af3eb9e1264d439c274d608f6ffc6a83",
            "date": "2025-01-14T14:23:35Z",
            "author_login": "anoadragon453"
          },
          {
            "sha": "e70e8d132c4f4b58a2eb3203b84dfbc3b1b1a953",
            "date": "2025-01-14T14:20:08Z",
            "author_login": "anoadragon453"
          },
          {
            "sha": "48334fbc40e6ad3f4895ed8b2e3cdf1045d0b534",
            "date": "2025-01-14T14:17:55Z",
            "author_login": "anoadragon453"
          },
          {
            "sha": "b4fd694ce3260eab771bc4646649edeab3b93901",
            "date": "2025-01-14T14:14:23Z",
            "author_login": "anoadragon453"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "Synapse is an open-source Matrix homeserver. A remote Matrix user with malicious intent, sharing a room with Synapse instances before 1.105.1, can dispatch specially crafted events to exploit a weakness in the V2 state resolution algorithm. This can induce high CPU consumption and accumulate excessive data in the database of such instances, resulting in a denial of service. Servers in private federations, or those that do not federate, are not affected. Server administrators should upgrade to 1.105.1 or later. Some workarounds are available. One can ban the malicious users or ACL block servers from the rooms and/or leave the room and purge the room using the admin API.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-23T18:15:14.457",
    "last_modified": "2024-11-21T09:13:02.543",
    "fix_date": "2024-04-23T14:24:08Z"
  },
  "references": [
    {
      "url": "https://github.com/element-hq/synapse/commit/55b0aa847a61774b6a3acdc4b177a20dc019f01a",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/element-hq/synapse/releases/tag/v1.105.1",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/element-hq/synapse/security/advisories/GHSA-3h7q-rfh9-xm4v",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R6FCCO4ODTZ3FDS7TMW76PKOSEL2TQVB/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RR53FNHV446CB37TP45GZ6F6HZLZCK3K/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VSF4NJJSTSQRJQ47PLYYSCFYKJBP7DET/",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/element-hq/synapse/commit/55b0aa847a61774b6a3acdc4b177a20dc019f01a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/element-hq/synapse/releases/tag/v1.105.1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/element-hq/synapse/security/advisories/GHSA-3h7q-rfh9-xm4v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R6FCCO4ODTZ3FDS7TMW76PKOSEL2TQVB/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RR53FNHV446CB37TP45GZ6F6HZLZCK3K/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VSF4NJJSTSQRJQ47PLYYSCFYKJBP7DET/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:07.011353",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "synapse",
    "owner": "element-hq",
    "created_at": "2023-12-13T14:40:43Z",
    "updated_at": "2025-01-14T12:04:59Z",
    "pushed_at": "2025-01-14T14:20:31Z",
    "size": 449381,
    "stars": 1805,
    "forks": 226,
    "open_issues": 1742,
    "watchers": 1805,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "Python": 14153620,
      "Rust": 149319,
      "HTML": 64952,
      "Shell": 59881,
      "Perl": 28191,
      "Nix": 12327,
      "JavaScript": 11988,
      "Dockerfile": 11963,
      "Jinja": 8843,
      "CSS": 6211,
      "Lua": 241,
      "Gherkin": 153
    },
    "commit_activity": {
      "total_commits_last_year": 1228,
      "avg_commits_per_week": 23.615384615384617,
      "days_active_last_year": 199
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T14:23:33.325362"
  }
}