{
  "cve_id": "CVE-2024-31216",
  "github_data": {
    "repository": "fluxcd/source-controller",
    "fix_commit": "915d1a072a4f37dd460ba33079dc094aa6e72fa9",
    "related_commits": [
      "915d1a072a4f37dd460ba33079dc094aa6e72fa9",
      "915d1a072a4f37dd460ba33079dc094aa6e72fa9"
    ],
    "patch_url": "https://github.com/fluxcd/source-controller/commit/915d1a072a4f37dd460ba33079dc094aa6e72fa9.patch",
    "fix_commit_details": {
      "sha": "915d1a072a4f37dd460ba33079dc094aa6e72fa9",
      "commit_date": "2024-04-04T12:54:38Z",
      "author": {
        "login": "stefanprodan",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #1430 from fluxcd/sanitze-bucker-errors",
        "length": 105,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 221,
        "additions": 219,
        "deletions": 2
      },
      "files": [
        {
          "filename": "internal/controller/bucket_controller.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -728,7 +728,7 @@ func fetchEtagIndex(ctx context.Context, provider BucketProvider, obj *bucketv1.\n \tpath := filepath.Join(tempDir, sourceignore.IgnoreFile)\n \tif _, err := provider.FGetObject(ctxTimeout, obj.Spec.BucketName, sourceignore.IgnoreFile, path); err != nil {\n \t\tif !provider.ObjectIsNotFound(err) {\n-\t\t\treturn err\n+\t\t\treturn fmt.Errorf(\"failed to get Etag for '%s' object: %w\", sourceignore.IgnoreFile, serror.SanitizeError(err))\n \t\t}\n \t}\n \tps, err := sourceignore.ReadIgnoreFile(path, nil)\n@@ -792,7 +792,7 @@ func fetchIndexFiles(ctx context.Context, provider BucketProvider, obj *bucketv1\n \t\t\t\t\t\tindex.Delete(k)\n \t\t\t\t\t\treturn nil\n \t\t\t\t\t}\n-\t\t\t\t\treturn fmt.Errorf(\"failed to get '%s' object: %w\", k, err)\n+\t\t\t\t\treturn fmt.Errorf(\"failed to get '%s' object: %w\", k, serror.SanitizeError(err))\n \t\t\t\t}\n \t\t\t\tif t != etag {\n \t\t\t\t\tindex.Add(k, etag)"
        },
        {
          "filename": "internal/error/sanitized.go",
          "status": "added",
          "additions": 76,
          "deletions": 0,
          "patch": "@@ -0,0 +1,76 @@\n+/*\n+Copyright 2024 The Flux authors\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package error\n+\n+import (\n+\t\"fmt\"\n+\t\"net/url\"\n+\t\"regexp\"\n+)\n+\n+type SanitizedError struct {\n+\terr string\n+}\n+\n+func (e SanitizedError) Error() string {\n+\treturn e.err\n+}\n+\n+// SanitizeError extracts all URLs from the error message\n+// and replaces them with the URL without the query string.\n+func SanitizeError(err error) SanitizedError {\n+\terrorMessage := err.Error()\n+\tfor _, u := range extractURLs(errorMessage) {\n+\t\turlWithoutQueryString, err := removeQueryString(u)\n+\t\tif err == nil {\n+\t\t\tre, err := regexp.Compile(fmt.Sprintf(\"%s*\", regexp.QuoteMeta(u)))\n+\t\t\tif err == nil {\n+\t\t\t\terrorMessage = re.ReplaceAllString(errorMessage, urlWithoutQueryString)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn SanitizedError{errorMessage}\n+}\n+\n+// removeQueryString takes a URL string as input and returns the URL without the query string.\n+func removeQueryString(urlStr string) (string, error) {\n+\t// Parse the URL.\n+\tu, err := url.Parse(urlStr)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\t// Rebuild the URL without the query string.\n+\tu.RawQuery = \"\"\n+\treturn u.String(), nil\n+}\n+\n+// extractURLs takes a log message as input and returns the URLs found.\n+func extractURLs(logMessage string) []string {\n+\t// Define a regular expression to match a URL.\n+\t// This is a simple pattern and might need to be adjusted depending on the log message format.\n+\turlRegex := regexp.MustCompile(`https?://[^\\s]+`)\n+\n+\t// Find the first match in the log message.\n+\tmatches := urlRegex.FindAllString(logMessage, -1)\n+\tif len(matches) == 0 {\n+\t\treturn []string{}\n+\t}\n+\n+\treturn matches\n+}"
        },
        {
          "filename": "internal/error/sanitized_test.go",
          "status": "added",
          "additions": 141,
          "deletions": 0,
          "patch": "@@ -0,0 +1,141 @@\n+/*\n+Copyright 2024 The Flux authors\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package error\n+\n+import (\n+\t\"errors\"\n+\t\"testing\"\n+\n+\t. \"github.com/onsi/gomega\"\n+)\n+\n+func Test_extractURLs(t *testing.T) {\n+\n+\ttests := []struct {\n+\t\tname       string\n+\t\tlogMessage string\n+\t\twantUrls   []string\n+\t}{\n+\t\t{\n+\t\t\tname:       \"Log Contains single URL\",\n+\t\t\tlogMessage: \"Get \\\"https://blobstorage.blob.core.windows.net/container/index.yaml?se=2024-05-01T16%3A28%3A26Z&sig=Signature&sp=rl&sr=c&st=2024-02-01T16%3A28%3A26Z&sv=2022-11-02\\\": dial tcp 20.60.53.129:443: connect: connection refused\",\n+\t\t\twantUrls:   []string{\"https://blobstorage.blob.core.windows.net/container/index.yaml?se=2024-05-01T16%3A28%3A26Z&sig=Signature&sp=rl&sr=c&st=2024-02-01T16%3A28%3A26Z&sv=2022-11-02\\\":\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"Log Contains multiple URL\",\n+\t\t\tlogMessage: \"Get \\\"https://blobstorage.blob.core.windows.net/container/index.yaml?abc=es  https://blobstorage1.blob.core.windows.net/container/index.yaml?abc=no : dial tcp 20.60.53.129:443: connect: connection refused\",\n+\t\t\twantUrls: []string{\n+\t\t\t\t\"https://blobstorage.blob.core.windows.net/container/index.yaml?abc=es\",\n+\t\t\t\t\"https://blobstorage1.blob.core.windows.net/container/index.yaml?abc=no\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"Log Contains No URL\",\n+\t\t\tlogMessage: \"Log message without URL\",\n+\t\t\twantUrls:   []string{},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tg := NewWithT(t)\n+\n+\t\t\turls := extractURLs(tt.logMessage)\n+\n+\t\t\tg.Expect(len(urls)).To(Equal(len(tt.wantUrls)))\n+\t\t\tfor i := range tt.wantUrls {\n+\t\t\t\tg.Expect(urls[i]).To(Equal(tt.wantUrls[i]))\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func Test_removeQueryString(t *testing.T) {\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\turlStr  string\n+\t\twantUrl string\n+\t}{\n+\t\t{\n+\t\t\tname:    \"URL with query string\",\n+\t\t\turlStr:  \"https://blobstorage.blob.core.windows.net/container/index.yaml?se=2024-05-01T16%3A28%3A26Z&sig=Signature&sp=rl&sr=c&st=2024-02-01T16%3A28%3A26Z&sv=2022-11-02\",\n+\t\t\twantUrl: \"https://blobstorage.blob.core.windows.net/container/index.yaml\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"URL without query string\",\n+\t\t\turlStr:  \"https://blobstorage.blob.core.windows.net/container/index.yaml\",\n+\t\t\twantUrl: \"https://blobstorage.blob.core.windows.net/container/index.yaml\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"URL with query string and port\",\n+\t\t\turlStr:  \"https://blobstorage.blob.core.windows.net:443/container/index.yaml?se=2024-05-01T16%3A28%3A26Z&sig=Signature&sp=rl&sr=c&st=2024-02-01T16%3A28%3A26Z&sv=2022-11-02\",\n+\t\t\twantUrl: \"https://blobstorage.blob.core.windows.net:443/container/index.yaml\",\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"Invalid URL\",\n+\t\t\turlStr:  \"NoUrl\",\n+\t\t\twantUrl: \"NoUrl\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tg := NewWithT(t)\n+\n+\t\t\turlWithoutQueryString, err := removeQueryString(tt.urlStr)\n+\n+\t\t\tg.Expect(err).To(BeNil())\n+\t\t\tg.Expect(urlWithoutQueryString).To(Equal(tt.wantUrl))\n+\t\t})\n+\t}\n+}\n+\n+func Test_SanitizeError(t *testing.T) {\n+\n+\ttests := []struct {\n+\t\tname           string\n+\t\terrMessage     string\n+\t\twantErrMessage string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"Log message with URL with query string\",\n+\t\t\terrMessage:     \"Get \\\"https://blobstorage.blob.core.windows.net/container/index.yaml?se=2024-05-01T16%3A28%3A26Z&sig=Signature&sp=rl&sr=c&st=2024-02-01T16%3A28%3A26Z&sv=2022-11-02\\\": dial tcp 20.60.53.129:443: connect: connection refused\",\n+\t\t\twantErrMessage: \"Get \\\"https://blobstorage.blob.core.windows.net/container/index.yaml dial tcp 20.60.53.129:443: connect: connection refused\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"Log message without URL\",\n+\t\t\terrMessage:     \"Log message contains no URL\",\n+\t\t\twantErrMessage: \"Log message contains no URL\",\n+\t\t},\n+\n+\t\t{\n+\t\t\tname:           \"Log message with multiple Urls\",\n+\t\t\terrMessage:     \"Get \\\"https://blobstorage.blob.core.windows.net/container/index.yaml?abc=es  https://blobstorage1.blob.core.windows.net/container/index.yaml?abc=no dial tcp 20.60.53.129:443: connect: connection refused\",\n+\t\t\twantErrMessage: \"Get \\\"https://blobstorage.blob.core.windows.net/container/index.yaml  https://blobstorage1.blob.core.windows.net/container/index.yaml dial tcp 20.60.53.129:443: connect: connection refused\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tg := NewWithT(t)\n+\n+\t\t\terr := SanitizeError(errors.New(tt.errMessage))\n+\t\t\tg.Expect(err.Error()).To(Equal(tt.wantErrMessage))\n+\t\t})\n+\t}\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "529eee0ed1afc6063acd9750aa598d90ae3399ed",
            "date": "2025-01-10T13:57:20Z",
            "author_login": "stefanprodan"
          },
          {
            "sha": "615bb912ddf8431464bda24413c9e4c765990d6e",
            "date": "2025-01-10T13:41:27Z",
            "author_login": "matheuscscp"
          },
          {
            "sha": "fe5af75a3a27c10d2c98a38eeb8f86d6903dcc94",
            "date": "2025-01-09T18:20:52Z",
            "author_login": "stefanprodan"
          },
          {
            "sha": "1ed845928bc74b4948c9c1d25a46846eb9b2002f",
            "date": "2024-12-19T21:01:44Z",
            "author_login": "darkowlzz"
          },
          {
            "sha": "9556a639c65a374d6126551cb02ced56aeda5069",
            "date": "2024-10-22T19:26:12Z",
            "author_login": "dipti-pai"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.1,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-532",
    "description": "The source-controller is a Kubernetes operator, specialised in artifacts acquisition from external sources such as Git, OCI, Helm repositories and S3-compatible buckets. The source-controller implements the source.toolkit.fluxcd.io API and is a core component of the GitOps toolkit. Prior to version 1.2.5, when source-controller was configured to use an Azure SAS token when connecting to Azure Blob Storage, the token was logged along with the Azure URL when the controller encountered a connection error. An attacker with access to the source-controller logs could use the token to gain access to the Azure Blob Storage until the token expires. This vulnerability was fixed in source-controller v1.2.5. There is no workaround for this vulnerability except for using a different auth mechanism such as Azure Workload Identity.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-15T16:15:10.097",
    "last_modified": "2024-11-21T09:13:03.663",
    "fix_date": "2024-04-04T12:54:38Z"
  },
  "references": [
    {
      "url": "https://github.com/fluxcd/source-controller/commit/915d1a072a4f37dd460ba33079dc094aa6e72fa9",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/fluxcd/source-controller/pull/1430",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/fluxcd/source-controller/security/advisories/GHSA-v554-xwgw-hc3w",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/fluxcd/source-controller/commit/915d1a072a4f37dd460ba33079dc094aa6e72fa9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/fluxcd/source-controller/pull/1430",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/fluxcd/source-controller/security/advisories/GHSA-v554-xwgw-hc3w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.917261",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "source-controller",
    "owner": "fluxcd",
    "created_at": "2020-04-05T08:55:42Z",
    "updated_at": "2025-01-10T13:57:24Z",
    "pushed_at": "2025-01-10T13:57:22Z",
    "size": 9165,
    "stars": 243,
    "forks": 191,
    "open_issues": 109,
    "watchers": 243,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release/v0.25.x",
      "release/v0.36.x",
      "release/v1.0.x",
      "release/v1.1.x",
      "release/v1.2.x",
      "release/v1.3.x",
      "release/v1.4.x"
    ],
    "languages": {
      "Go": 1581333,
      "Shell": 10378,
      "Makefile": 7834,
      "Smarty": 4946,
      "Dockerfile": 1750,
      "Ruby": 453
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T18:57:49.809339"
  }
}