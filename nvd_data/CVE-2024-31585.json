{
  "cve_id": "CVE-2024-31585",
  "github_data": {
    "repository": "ffmpeg/ffmpeg",
    "fix_commit": "81df787b53eb5c6433731f6eaaf7f2a94d8a8c80",
    "related_commits": [
      "81df787b53eb5c6433731f6eaaf7f2a94d8a8c80",
      "ab0fdaedd1e7224f7e84ea22fcbfaa4ca75a6c06",
      "81df787b53eb5c6433731f6eaaf7f2a94d8a8c80",
      "ab0fdaedd1e7224f7e84ea22fcbfaa4ca75a6c06"
    ],
    "patch_url": "https://github.com/ffmpeg/ffmpeg/commit/81df787b53eb5c6433731f6eaaf7f2a94d8a8c80.patch",
    "fix_commit_details": {
      "sha": "81df787b53eb5c6433731f6eaaf7f2a94d8a8c80",
      "commit_date": "2022-02-14T20:02:03Z",
      "author": {
        "login": "richardpl",
        "type": "User",
        "stats": {
          "total_commits": 5933,
          "average_weekly_commits": 4.727490039840638,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 507
        }
      },
      "commit_message": {
        "title": "avfilter/avf_showspectrum: stop using AVAudioFifo to keep samples",
        "length": 135,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 187,
        "additions": 106,
        "deletions": 81
      },
      "files": [
        {
          "filename": "libavfilter/avf_showspectrum.c",
          "status": "modified",
          "additions": 106,
          "deletions": 81,
          "patch": "@@ -30,7 +30,6 @@\n #include <math.h>\n \n #include \"libavutil/tx.h\"\n-#include \"libavutil/audio_fifo.h\"\n #include \"libavutil/avassert.h\"\n #include \"libavutil/avstring.h\"\n #include \"libavutil/channel_layout.h\"\n@@ -53,13 +52,16 @@ enum ColorMode    { CHANNEL, INTENSITY, RAINBOW, MORELAND, NEBULAE, FIRE, FIERY,\n enum SlideMode    { REPLACE, SCROLL, FULLFRAME, RSCROLL, LREPLACE, NB_SLIDES };\n enum Orientation  { VERTICAL, HORIZONTAL, NB_ORIENTATIONS };\n \n+#define DEFAULT_LENGTH 300\n+\n typedef struct ShowSpectrumContext {\n     const AVClass *class;\n     int w, h;\n     char *rate_str;\n     AVRational auto_frame_rate;\n     AVRational frame_rate;\n     AVFrame *outpicref;\n+    AVFrame *in_frame;\n     int nb_display_channels;\n     int orientation;\n     int channel_width;\n@@ -95,7 +97,6 @@ typedef struct ShowSpectrumContext {\n     int hop_size;\n     float *combine_buffer;      ///< color combining buffer (3 * h items)\n     float **color_buffer;       ///< color buffer (3 * h * ch items)\n-    AVAudioFifo *fifo;\n     int64_t pts;\n     int64_t old_pts;\n     int old_len;\n@@ -104,7 +105,12 @@ typedef struct ShowSpectrumContext {\n     int start_x, start_y;\n     float drange, limit;\n     float dmin, dmax;\n+    uint64_t samples;\n     int (*plot_channel)(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs);\n+\n+    AVFrame **frames;\n+    unsigned int nb_frames;\n+    unsigned int frames_size;\n } ShowSpectrumContext;\n \n #define OFFSET(x) offsetof(ShowSpectrumContext, x)\n@@ -330,12 +336,19 @@ static av_cold void uninit(AVFilterContext *ctx)\n     }\n     av_freep(&s->magnitudes);\n     av_frame_free(&s->outpicref);\n-    av_audio_fifo_free(s->fifo);\n+    av_frame_free(&s->in_frame);\n     if (s->phases) {\n         for (i = 0; i < s->nb_display_channels; i++)\n             av_freep(&s->phases[i]);\n     }\n     av_freep(&s->phases);\n+\n+    while (s->nb_frames > 0) {\n+        av_frame_free(&s->frames[s->nb_frames - 1]);\n+        s->nb_frames--;\n+    }\n+\n+    av_freep(&s->frames);\n }\n \n static int query_formats(AVFilterContext *ctx)\n@@ -380,6 +393,13 @@ static int run_channel_fft(AVFilterContext *ctx, void *arg, int jobnr, int nb_jo\n \n     /* fill FFT input with the number of samples available */\n     const float *p = (float *)fin->extended_data[ch];\n+    float *in_frame = (float *)s->in_frame->extended_data[ch];\n+\n+    memmove(in_frame, in_frame + s->hop_size, (s->fft_size - s->hop_size) * sizeof(float));\n+    memcpy(in_frame + s->fft_size - s->hop_size, p, fin->nb_samples * sizeof(float));\n+\n+    for (int i = fin->nb_samples; i < s->hop_size; i++)\n+        in_frame[i + s->fft_size - s->hop_size] = 0.f;\n \n     if (s->stop) {\n         float theta, phi, psi, a, b, S, c;\n@@ -391,7 +411,7 @@ static int run_channel_fft(AVFilterContext *ctx, void *arg, int jobnr, int nb_jo\n         int M = s->win_size / 2;\n \n         for (n = 0; n < s->win_size; n++) {\n-            s->fft_data[ch][n].re = p[n] * window_func_lut[n];\n+            s->fft_data[ch][n].re = in_frame[n] * window_func_lut[n];\n             s->fft_data[ch][n].im = 0;\n         }\n \n@@ -458,7 +478,7 @@ static int run_channel_fft(AVFilterContext *ctx, void *arg, int jobnr, int nb_jo\n         }\n     } else {\n         for (n = 0; n < s->win_size; n++) {\n-            s->fft_in[ch][n].re = p[n] * window_func_lut[n];\n+            s->fft_in[ch][n].re = in_frame[n] * window_func_lut[n];\n             s->fft_in[ch][n].im = 0;\n         }\n \n@@ -726,7 +746,7 @@ static float get_iscale(AVFilterContext *ctx, int scale, float a)\n     return a;\n }\n \n-static int draw_legend(AVFilterContext *ctx, int samples)\n+static int draw_legend(AVFilterContext *ctx, uint64_t samples)\n {\n     ShowSpectrumContext *s = ctx->priv;\n     AVFilterLink *inlink = ctx->inputs[0];\n@@ -1239,10 +1259,15 @@ static int config_output(AVFilterLink *outlink)\n     av_log(ctx, AV_LOG_VERBOSE, \"s:%dx%d FFT window size:%d\\n\",\n            s->w, s->h, s->win_size);\n \n-    av_audio_fifo_free(s->fifo);\n-    s->fifo = av_audio_fifo_alloc(inlink->format, inlink->channels, s->win_size);\n-    if (!s->fifo)\n+    s->in_frame = ff_get_audio_buffer(inlink, s->win_size);\n+    if (!s->in_frame)\n+        return AVERROR(ENOMEM);\n+\n+    s->frames = av_fast_realloc(NULL, &s->frames_size,\n+                                DEFAULT_LENGTH * sizeof(*(s->frames)));\n+    if (!s->frames)\n         return AVERROR(ENOMEM);\n+\n     return 0;\n }\n \n@@ -1439,7 +1464,7 @@ static int plot_spectrum_column(AVFilterLink *inlink, AVFrame *insamples)\n     }\n \n     if (s->sliding != FULLFRAME || s->xpos == 0)\n-        outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);\n+        s->pts = outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);\n \n     if (s->sliding == LREPLACE) {\n         s->xpos--;\n@@ -1507,65 +1532,40 @@ static int activate(AVFilterContext *ctx)\n     AVFilterLink *inlink = ctx->inputs[0];\n     AVFilterLink *outlink = ctx->outputs[0];\n     ShowSpectrumContext *s = ctx->priv;\n-    int ret;\n+    int ret, status;\n+    int64_t pts;\n \n     FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n \n-    if (av_audio_fifo_size(s->fifo) < s->win_size) {\n-        AVFrame *frame = NULL;\n+    if (s->outpicref) {\n+        AVFrame *fin;\n \n-        ret = ff_inlink_consume_frame(inlink, &frame);\n+        ret = ff_inlink_consume_samples(inlink, s->hop_size, s->hop_size, &fin);\n         if (ret < 0)\n             return ret;\n         if (ret > 0) {\n-            s->pts = frame->pts;\n-            s->consumed = 0;\n+            s->consumed += fin->nb_samples;\n+            ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n \n-            av_audio_fifo_write(s->fifo, (void **)frame->extended_data, frame->nb_samples);\n-            av_frame_free(&frame);\n-        }\n-    }\n+            if (s->data == D_MAGNITUDE)\n+                ff_filter_execute(ctx, calc_channel_magnitudes, NULL, NULL, s->nb_display_channels);\n \n-    if (s->outpicref && (av_audio_fifo_size(s->fifo) >= s->win_size ||\n-        ff_outlink_get_status(inlink))) {\n-        AVFrame *fin = ff_get_audio_buffer(inlink, s->win_size);\n-        if (!fin)\n-            return AVERROR(ENOMEM);\n+            if (s->data == D_PHASE)\n+                ff_filter_execute(ctx, calc_channel_phases, NULL, NULL, s->nb_display_channels);\n \n-        fin->pts = s->pts + s->consumed;\n-        s->consumed += s->hop_size;\n-        ret = av_audio_fifo_peek(s->fifo, (void **)fin->extended_data,\n-                                 FFMIN(s->win_size, av_audio_fifo_size(s->fifo)));\n-        if (ret < 0) {\n+            if (s->data == D_UPHASE)\n+                ff_filter_execute(ctx, calc_channel_uphases, NULL, NULL, s->nb_display_channels);\n+\n+            ret = plot_spectrum_column(inlink, fin);\n             av_frame_free(&fin);\n-            return ret;\n+            if (ret <= 0)\n+                return ret;\n         }\n-\n-        av_assert0(fin->nb_samples == s->win_size);\n-\n-        ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n-\n-        if (s->data == D_MAGNITUDE)\n-            ff_filter_execute(ctx, calc_channel_magnitudes, NULL, NULL, s->nb_display_channels);\n-\n-        if (s->data == D_PHASE)\n-            ff_filter_execute(ctx, calc_channel_phases, NULL, NULL, s->nb_display_channels);\n-\n-        if (s->data == D_UPHASE)\n-            ff_filter_execute(ctx, calc_channel_uphases, NULL, NULL, s->nb_display_channels);\n-\n-        ret = plot_spectrum_column(inlink, fin);\n-\n-        av_frame_free(&fin);\n-        av_audio_fifo_drain(s->fifo, s->hop_size);\n-        if (ret <= 0 && !ff_outlink_get_status(inlink))\n-            return ret;\n     }\n \n     if (ff_outlink_get_status(inlink) == AVERROR_EOF &&\n         s->sliding == FULLFRAME &&\n         s->xpos > 0 && s->outpicref) {\n-        int64_t pts;\n \n         if (s->orientation == VERTICAL) {\n             for (int i = 0; i < outlink->h; i++) {\n@@ -1588,17 +1588,19 @@ static int activate(AVFilterContext *ctx)\n         return 0;\n     }\n \n-    FF_FILTER_FORWARD_STATUS(inlink, outlink);\n-    if (av_audio_fifo_size(s->fifo) >= s->win_size ||\n-        ff_inlink_queued_frames(inlink) > 0 ||\n-        ff_outlink_get_status(inlink) == AVERROR_EOF) {\n+    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n+        if (status == AVERROR_EOF) {\n+            ff_outlink_set_status(outlink, status, s->pts);\n+            return 0;\n+        }\n+    }\n+\n+    if (ff_inlink_queued_samples(inlink) >= s->hop_size) {\n         ff_filter_set_ready(ctx, 10);\n         return 0;\n     }\n \n-    if (ff_outlink_frame_wanted(outlink) && av_audio_fifo_size(s->fifo) < s->win_size &&\n-        ff_inlink_queued_frames(inlink) == 0 &&\n-        ff_outlink_get_status(inlink) != AVERROR_EOF) {\n+    if (ff_outlink_frame_wanted(outlink)) {\n         ff_inlink_request_frame(inlink);\n         return 0;\n     }\n@@ -1691,39 +1693,53 @@ static int showspectrumpic_request_frame(AVFilterLink *outlink)\n     AVFilterContext *ctx = outlink->src;\n     ShowSpectrumContext *s = ctx->priv;\n     AVFilterLink *inlink = ctx->inputs[0];\n-    int ret, samples;\n+    int ret;\n \n     ret = ff_request_frame(inlink);\n-    samples = av_audio_fifo_size(s->fifo);\n-    if (ret == AVERROR_EOF && s->outpicref && samples > 0) {\n+    if (ret == AVERROR_EOF && s->outpicref && s->samples > 0) {\n         int consumed = 0;\n         int x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n+        unsigned int nb_frame = 0;\n         int ch, spf, spb;\n+        int src_offset = 0;\n         AVFrame *fin;\n \n-        spf = s->win_size * (samples / ((s->win_size * sz) * ceil(samples / (float)(s->win_size * sz))));\n+        spf = s->win_size * (s->samples / ((s->win_size * sz) * ceil(s->samples / (float)(s->win_size * sz))));\n         spf = FFMAX(1, spf);\n \n-        spb = (samples / (spf * sz)) * spf;\n+        spb = (s->samples / (spf * sz)) * spf;\n \n-        fin = ff_get_audio_buffer(inlink, s->win_size);\n+        fin = ff_get_audio_buffer(inlink, spf);\n         if (!fin)\n             return AVERROR(ENOMEM);\n \n         while (x < sz) {\n-            ret = av_audio_fifo_peek(s->fifo, (void **)fin->extended_data, s->win_size);\n-            if (ret < 0) {\n-                av_frame_free(&fin);\n-                return ret;\n-            }\n-\n-            av_audio_fifo_drain(s->fifo, spf);\n+            int acc_samples = 0;\n+            int dst_offset = 0;\n+\n+            while (nb_frame <= s->nb_frames) {\n+                AVFrame *cur_frame = s->frames[nb_frame];\n+                int cur_frame_samples = cur_frame->nb_samples;\n+                int nb_samples = 0;\n+\n+                if (acc_samples < spf) {\n+                    nb_samples = FFMIN(spf - acc_samples, cur_frame_samples - src_offset);\n+                    acc_samples += nb_samples;\n+                    av_samples_copy(fin->extended_data, cur_frame->extended_data,\n+                                    dst_offset, src_offset, nb_samples,\n+                                    cur_frame->channels, AV_SAMPLE_FMT_FLTP);\n+                }\n \n-            if (ret < s->win_size) {\n-                for (ch = 0; ch < s->nb_display_channels; ch++) {\n-                    memset(fin->extended_data[ch] + ret * sizeof(float), 0,\n-                           (s->win_size - ret) * sizeof(float));\n+                src_offset += nb_samples;\n+                dst_offset += nb_samples;\n+                if (cur_frame_samples <= src_offset) {\n+                    av_frame_free(&s->frames[nb_frame]);\n+                    nb_frame++;\n+                    src_offset = 0;\n                 }\n+\n+                if (acc_samples == spf)\n+                    break;\n             }\n \n             ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n@@ -1746,7 +1762,7 @@ static int showspectrumpic_request_frame(AVFilterLink *outlink)\n         s->outpicref->pts = 0;\n \n         if (s->legend)\n-            draw_legend(ctx, samples);\n+            draw_legend(ctx, s->samples);\n \n         ret = ff_filter_frame(outlink, s->outpicref);\n         s->outpicref = NULL;\n@@ -1759,11 +1775,20 @@ static int showspectrumpic_filter_frame(AVFilterLink *inlink, AVFrame *insamples\n {\n     AVFilterContext *ctx = inlink->dst;\n     ShowSpectrumContext *s = ctx->priv;\n-    int ret;\n+    void *ptr;\n \n-    ret = av_audio_fifo_write(s->fifo, (void **)insamples->extended_data, insamples->nb_samples);\n-    av_frame_free(&insamples);\n-    return ret;\n+    if (s->nb_frames + 1ULL > s->frames_size / sizeof(*(s->frames))) {\n+        ptr = av_fast_realloc(s->frames, &s->frames_size, s->frames_size * 2);\n+        if (!ptr)\n+            return AVERROR(ENOMEM);\n+        s->frames = ptr;\n+    }\n+\n+    s->frames[s->nb_frames] = insamples;\n+    s->samples += insamples->nb_samples;\n+    s->nb_frames++;\n+\n+    return 0;\n }\n \n static const AVFilterPad showspectrumpic_inputs[] = {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8eb1d76e146a0e557d596a4039efebac746b4d83",
            "date": "2025-01-12T03:34:17Z",
            "author_login": "nuomi2021"
          },
          {
            "sha": "d5873be583ada9e1fb887e2fe8dcfd4b12e0efcd",
            "date": "2025-01-13T20:28:02Z",
            "author_login": "jamrial"
          },
          {
            "sha": "b88fc4e098607bed98c74e6d13ed77b907776685",
            "date": "2025-01-08T11:06:30Z",
            "author_login": "mypopydev"
          },
          {
            "sha": "8ded602edad43227aa5b84ac8041d4b174ec9431",
            "date": "2025-01-08T11:04:12Z",
            "author_login": "mypopydev"
          },
          {
            "sha": "851a84650ef6026871f3b565d1f54c9d7a5397a4",
            "date": "2025-01-07T04:56:11Z",
            "author_login": "cyanreg"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:N/I:N/A:H",
    "cwe_id": "CWE-193",
    "description": "FFmpeg version n5.1 to n6.1 was discovered to contain an Off-by-one Error vulnerability in libavfilter/avf_showspectrum.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted input.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-04-17T19:15:08.007",
    "last_modified": "2024-11-21T09:13:43.997",
    "fix_date": "2022-02-14T20:02:03Z"
  },
  "references": [
    {
      "url": "https://gist.github.com/1047524396/dc2c64ffe0c3934a6176bcd2c5cf5656",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/FFmpeg/FFmpeg/commit/81df787b53eb5c6433731f6eaaf7f2a94d8a8c80",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/ffmpeg/ffmpeg/commit/ab0fdaedd1e7224f7e84ea22fcbfaa4ca75a6c06",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6G7EYH2JAK5OJPVNC6AXYQ5K7YGYNCDN/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IPETICRXUOGRIM4U3BCRTIKE3IZWCSBT/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LE3ASLH6QF2E5OVJI5VA3JSEPJFFFMNY/",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://gist.github.com/1047524396/dc2c64ffe0c3934a6176bcd2c5cf5656",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/FFmpeg/FFmpeg/commit/81df787b53eb5c6433731f6eaaf7f2a94d8a8c80",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/ffmpeg/ffmpeg/commit/ab0fdaedd1e7224f7e84ea22fcbfaa4ca75a6c06",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6G7EYH2JAK5OJPVNC6AXYQ5K7YGYNCDN/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IPETICRXUOGRIM4U3BCRTIKE3IZWCSBT/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LE3ASLH6QF2E5OVJI5VA3JSEPJFFFMNY/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:06.989590",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "FFmpeg",
    "owner": "ffmpeg",
    "created_at": "2011-04-14T14:12:38Z",
    "updated_at": "2025-01-14T12:22:35Z",
    "pushed_at": "2025-01-13T21:15:03Z",
    "size": 431834,
    "stars": 47243,
    "forks": 12316,
    "open_issues": 3,
    "watchers": 47243,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release/0.5",
      "release/0.6",
      "release/0.7",
      "release/0.8",
      "release/0.9",
      "release/0.10",
      "release/0.11",
      "release/1.0",
      "release/1.1",
      "release/1.2",
      "release/2.0",
      "release/2.1",
      "release/2.2",
      "release/2.3",
      "release/2.4",
      "release/2.5",
      "release/2.6",
      "release/2.7",
      "release/2.8",
      "release/3.0",
      "release/3.1",
      "release/3.2",
      "release/3.3",
      "release/3.4",
      "release/4.0",
      "release/4.1",
      "release/4.2",
      "release/4.3"
    ],
    "languages": {
      "C": 65826781,
      "Assembly": 5688727,
      "Makefile": 948271,
      "C++": 141194,
      "Objective-C": 108023,
      "Cuda": 85420,
      "Shell": 59093,
      "Perl": 29093,
      "Metal": 7961,
      "Python": 5992,
      "Awk": 1912,
      "HTML": 1631,
      "Ruby": 1462,
      "Verilog": 729,
      "Roff": 132
    },
    "commit_activity": {
      "total_commits_last_year": 4412,
      "avg_commits_per_week": 84.84615384615384,
      "days_active_last_year": 353
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:21:08.126139"
  }
}