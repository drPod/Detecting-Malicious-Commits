{
  "cve_id": "CVE-2024-31852",
  "github_data": {
    "repository": "llvmbot/llvm-project",
    "fix_commit": "0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2",
    "related_commits": [
      "0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2",
      "0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2"
    ],
    "patch_url": "https://github.com/llvmbot/llvm-project/commit/0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2.patch",
    "fix_commit_details": {
      "sha": "0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2",
      "commit_date": "2024-02-26T12:23:25Z",
      "author": {
        "login": "ostannard",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "[ARM] Update IsRestored for LR based on all returns (#82745)",
        "length": 599,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 49,
        "additions": 27,
        "deletions": 22
      },
      "files": [
        {
          "filename": "llvm/lib/Target/ARM/ARMFrameLowering.cpp",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -2781,10 +2781,7 @@ void ARMFrameLowering::determineCalleeSaves(MachineFunction &MF,\n   AFI->setLRIsSpilled(SavedRegs.test(ARM::LR));\n }\n \n-void ARMFrameLowering::processFunctionBeforeFrameFinalized(\n-    MachineFunction &MF, RegScavenger *RS) const {\n-  TargetFrameLowering::processFunctionBeforeFrameFinalized(MF, RS);\n-\n+void ARMFrameLowering::updateLRRestored(MachineFunction &MF) {\n   MachineFrameInfo &MFI = MF.getFrameInfo();\n   if (!MFI.isCalleeSavedInfoValid())\n     return;\n@@ -2808,6 +2805,12 @@ void ARMFrameLowering::processFunctionBeforeFrameFinalized(\n   }\n }\n \n+void ARMFrameLowering::processFunctionBeforeFrameFinalized(\n+    MachineFunction &MF, RegScavenger *RS) const {\n+  TargetFrameLowering::processFunctionBeforeFrameFinalized(MF, RS);\n+  updateLRRestored(MF);\n+}\n+\n void ARMFrameLowering::getCalleeSaves(const MachineFunction &MF,\n                                       BitVector &SavedRegs) const {\n   TargetFrameLowering::getCalleeSaves(MF, SavedRegs);"
        },
        {
          "filename": "llvm/lib/Target/ARM/ARMFrameLowering.h",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -59,6 +59,10 @@ class ARMFrameLowering : public TargetFrameLowering {\n   void determineCalleeSaves(MachineFunction &MF, BitVector &SavedRegs,\n                             RegScavenger *RS) const override;\n \n+  /// Update the IsRestored flag on LR if it is spilled, based on the return\n+  /// instructions.\n+  static void updateLRRestored(MachineFunction &MF);\n+\n   void processFunctionBeforeFrameFinalized(\n       MachineFunction &MF, RegScavenger *RS = nullptr) const override;\n "
        },
        {
          "filename": "llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp",
          "status": "modified",
          "additions": 10,
          "deletions": 13,
          "patch": "@@ -2062,17 +2062,6 @@ bool ARMLoadStoreOpt::MergeReturnIntoLDM(MachineBasicBlock &MBB) {\n       MO.setReg(ARM::PC);\n       PrevMI.copyImplicitOps(*MBB.getParent(), *MBBI);\n       MBB.erase(MBBI);\n-      // We now restore LR into PC so it is not live-out of the return block\n-      // anymore: Clear the CSI Restored bit.\n-      MachineFrameInfo &MFI = MBB.getParent()->getFrameInfo();\n-      // CSI should be fixed after PrologEpilog Insertion\n-      assert(MFI.isCalleeSavedInfoValid() && \"CSI should be valid\");\n-      for (CalleeSavedInfo &Info : MFI.getCalleeSavedInfo()) {\n-        if (Info.getReg() == ARM::LR) {\n-          Info.setRestored(false);\n-          break;\n-        }\n-      }\n       return true;\n     }\n   }\n@@ -2120,14 +2109,22 @@ bool ARMLoadStoreOpt::runOnMachineFunction(MachineFunction &Fn) {\n   isThumb2 = AFI->isThumb2Function();\n   isThumb1 = AFI->isThumbFunction() && !isThumb2;\n \n-  bool Modified = false;\n+  bool Modified = false, ModifiedLDMReturn = false;\n   for (MachineBasicBlock &MBB : Fn) {\n     Modified |= LoadStoreMultipleOpti(MBB);\n     if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n-      Modified |= MergeReturnIntoLDM(MBB);\n+      ModifiedLDMReturn |= MergeReturnIntoLDM(MBB);\n     if (isThumb1)\n       Modified |= CombineMovBx(MBB);\n   }\n+  Modified |= ModifiedLDMReturn;\n+\n+  // If we merged a BX instruction into an LDM, we need to re-calculate whether\n+  // LR is restored. This check needs to consider the whole function, not just\n+  // the instruction(s) we changed, because there may be other BX returns which\n+  // still need LR to be restored.\n+  if (ModifiedLDMReturn)\n+    ARMFrameLowering::updateLRRestored(Fn);\n \n   Allocator.DestroyAll();\n   return Modified;"
        },
        {
          "filename": "llvm/test/CodeGen/ARM/ldst-opt-lr-restored.ll",
          "status": "modified",
          "additions": 6,
          "deletions": 5,
          "patch": "@@ -10,16 +10,17 @@ define i32 @foo(ptr %ctx) {\n ; CHECK:       @ %bb.0: @ %entry\n ; CHECK-NEXT:    cbz r0, .LBB0_2\n ; CHECK-NEXT:  @ %bb.1: @ %if.end\n+; CHECK-NEXT:    movw r12, :lower16:val2\n+; CHECK-NEXT:    movw r3, :lower16:val1\n ; CHECK-NEXT:    movw r2, :lower16:val0\n ; CHECK-NEXT:    mov r1, r0\n ; CHECK-NEXT:    movs r0, #0\n-; CHECK-NEXT:    movw r12, :lower16:val2\n-; CHECK-NEXT:    movw r3, :lower16:val1\n-; CHECK-NEXT:    movt r2, :upper16:val0\n-; CHECK-NEXT:    add.w lr, r1, #4\n ; CHECK-NEXT:    movt r12, :upper16:val2\n ; CHECK-NEXT:    movt r3, :upper16:val1\n-; CHECK-NEXT:    stm.w lr, {r2, r3, r12}\n+; CHECK-NEXT:    movt r2, :upper16:val0\n+; CHECK-NEXT:    str r2, [r1, #4]\n+; CHECK-NEXT:    str r3, [r1, #8]\n+; CHECK-NEXT:    str.w r12, [r1, #12]\n ; CHECK-NEXT:    str r0, [r1, #16]\n ; CHECK-NEXT:    bx lr\n ; CHECK-NEXT:  .LBB0_2: @ %if.then"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c0c71d8b242a4501d45317bcdc4bd5cc310ca535",
            "date": "2024-01-19T01:31:16Z",
            "author_login": "llvmbot"
          },
          {
            "sha": "f1d75d08adb9841dd9cebad63b76d4823ec2bdac",
            "date": "2024-01-05T21:55:50Z",
            "author_login": "jonathonpenix"
          },
          {
            "sha": "853b13342a131e06d61293ec6e840642054c6c85",
            "date": "2024-01-05T21:41:51Z",
            "author_login": "jansvoboda11"
          },
          {
            "sha": "d9c8edf08afce3d1e563e4521ae847a6809bb993",
            "date": "2024-01-05T21:38:05Z",
            "author_login": "boomanaiden154"
          },
          {
            "sha": "6f4cc1310b12bc59210e4596a895db4cb9ad6075",
            "date": "2024-01-05T21:31:48Z",
            "author_login": "boomanaiden154"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": null,
    "description": "LLVM before 18.1.3 generates code in which the LR register can be overwritten without data being saved to the stack, and thus there can sometimes be an exploitable error in the flow of control. This affects the ARM backend and can be demonstrated with Clang. NOTE: the vendor perspective is \"we don't have strong objections for a CVE to be created ... It does seem that the likelihood of this miscompile enabling an exploit remains very low, because the miscompile resulting in this JOP gadget is such that the function is most likely to crash on most valid inputs to the function. So, if this function is covered by any testing, the miscompile is most likely to be discovered before the binary is shipped to production.\"",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-04-05T15:15:08.270",
    "last_modified": "2024-12-04T21:15:23.467",
    "fix_date": "2024-02-26T12:23:25Z"
  },
  "references": [
    {
      "url": "https://bugs.chromium.org/p/llvm/issues/detail?id=69",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/llvm/llvm-project/issues/80287",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/llvmbot/llvm-project/commit/0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://llvm.org/docs/Security.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://bugs.chromium.org/p/llvm/issues/detail?id=69",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/llvm/llvm-project/issues/80287",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/llvmbot/llvm-project/commit/0e16af8e4cf3a66ad5d078d52744ae2776f9c4b2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://llvm.org/docs/Security.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.432783",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "llvm-project",
    "owner": "llvmbot",
    "created_at": "2020-02-11T21:19:23Z",
    "updated_at": "2024-02-16T05:21:37Z",
    "pushed_at": "2025-01-14T09:40:38Z",
    "size": 1348679,
    "stars": 4,
    "forks": 0,
    "open_issues": 22,
    "watchers": 4,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {},
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0.0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:45:46.604867"
  }
}