{
  "cve_id": "CVE-2024-31990",
  "github_data": {
    "repository": "argoproj/argo-cd",
    "fix_commit": "c514105af739eebedb9dbe89d8a6dd8dfc30bb2c",
    "related_commits": [
      "c514105af739eebedb9dbe89d8a6dd8dfc30bb2c",
      "c5a252c4cc260e240e2074794aedb861d07e9ca5",
      "e0ff56d89fbd7d066e9c862b30337f6520f13f17",
      "c514105af739eebedb9dbe89d8a6dd8dfc30bb2c",
      "c5a252c4cc260e240e2074794aedb861d07e9ca5",
      "e0ff56d89fbd7d066e9c862b30337f6520f13f17"
    ],
    "patch_url": "https://github.com/argoproj/argo-cd/commit/c514105af739eebedb9dbe89d8a6dd8dfc30bb2c.patch",
    "fix_commit_details": {
      "sha": "c514105af739eebedb9dbe89d8a6dd8dfc30bb2c",
      "commit_date": "2024-04-15T07:20:07Z",
      "author": {
        "login": "pasha-codefresh",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-2gvw-w6fj-7m3c",
        "length": 95,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 326,
        "additions": 223,
        "deletions": 103
      },
      "files": [
        {
          "filename": "pkg/apis/application/v1alpha1/app_project_types.go",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -17,6 +17,24 @@ import (\n \t\"k8s.io/apimachinery/pkg/runtime/schema\"\n )\n \n+type ErrApplicationNotAllowedToUseProject struct {\n+\tapplication string\n+\tnamespace   string\n+\tproject     string\n+}\n+\n+func NewErrApplicationNotAllowedToUseProject(application, namespace, project string) error {\n+\treturn &ErrApplicationNotAllowedToUseProject{\n+\t\tapplication: application,\n+\t\tnamespace:   namespace,\n+\t\tproject:     project,\n+\t}\n+}\n+\n+func (err *ErrApplicationNotAllowedToUseProject) Error() string {\n+\treturn fmt.Sprintf(\"application '%s' in namespace '%s' is not allowed to use project %s\", err.application, err.namespace, err.project)\n+}\n+\n // AppProjectList is list of AppProject resources\n // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n type AppProjectList struct {"
        },
        {
          "filename": "server/application/application.go",
          "status": "modified",
          "additions": 89,
          "deletions": 96,
          "patch": "@@ -151,7 +151,7 @@ func NewServer(\n //\n // If the user does provide a \"project,\" we can respond more specifically. If the user does not have access to the given\n // app name in the given project, we return \"permission denied.\" If the app exists, but the project is different from\n-func (s *Server) getAppEnforceRBAC(ctx context.Context, action, project, namespace, name string, getApp func() (*appv1.Application, error)) (*appv1.Application, error) {\n+func (s *Server) getAppEnforceRBAC(ctx context.Context, action, project, namespace, name string, getApp func() (*appv1.Application, error)) (*appv1.Application, *appv1.AppProject, error) {\n \tuser := session.Username(ctx)\n \tif user == \"\" {\n \t\tuser = \"Unknown user\"\n@@ -173,23 +173,23 @@ func (s *Server) getAppEnforceRBAC(ctx context.Context, action, project, namespa\n \t\t\t// but the app is in a different project\" response. We don't want the user inferring the existence of the\n \t\t\t// app from response time.\n \t\t\t_, _ = getApp()\n-\t\t\treturn nil, permissionDeniedErr\n+\t\t\treturn nil, nil, permissionDeniedErr\n \t\t}\n \t}\n \ta, err := getApp()\n \tif err != nil {\n \t\tif apierr.IsNotFound(err) {\n \t\t\tif project != \"\" {\n \t\t\t\t// We know that the user was allowed to get the Application, but the Application does not exist. Return 404.\n-\t\t\t\treturn nil, status.Errorf(codes.NotFound, apierr.NewNotFound(schema.GroupResource{Group: \"argoproj.io\", Resource: \"applications\"}, name).Error())\n+\t\t\t\treturn nil, nil, status.Errorf(codes.NotFound, apierr.NewNotFound(schema.GroupResource{Group: \"argoproj.io\", Resource: \"applications\"}, name).Error())\n \t\t\t}\n \t\t\t// We don't know if the user was allowed to get the Application, and we don't want to leak information about\n \t\t\t// the Application's existence. Return 403.\n \t\t\tlogCtx.Warn(\"application does not exist\")\n-\t\t\treturn nil, permissionDeniedErr\n+\t\t\treturn nil, nil, permissionDeniedErr\n \t\t}\n \t\tlogCtx.Errorf(\"failed to get application: %s\", err)\n-\t\treturn nil, permissionDeniedErr\n+\t\treturn nil, nil, permissionDeniedErr\n \t}\n \t// Even if we performed an initial RBAC check (because the request was fully parameterized), we still need to\n \t// perform a second RBAC check to ensure that the user has access to the actual Application's project (not just the\n@@ -203,11 +203,11 @@ func (s *Server) getAppEnforceRBAC(ctx context.Context, action, project, namespa\n \t\t\t// The user specified a project. We would have returned a 404 if the user had access to the app, but the app\n \t\t\t// did not exist. So we have to return a 404 when the app does exist, but the user does not have access.\n \t\t\t// Otherwise, they could infer that the app exists based on the error code.\n-\t\t\treturn nil, status.Errorf(codes.NotFound, apierr.NewNotFound(schema.GroupResource{Group: \"argoproj.io\", Resource: \"applications\"}, name).Error())\n+\t\t\treturn nil, nil, status.Errorf(codes.NotFound, apierr.NewNotFound(schema.GroupResource{Group: \"argoproj.io\", Resource: \"applications\"}, name).Error())\n \t\t}\n \t\t// The user didn't specify a project. We always return permission denied for both lack of access and lack of\n \t\t// existence.\n-\t\treturn nil, permissionDeniedErr\n+\t\treturn nil, nil, permissionDeniedErr\n \t}\n \teffectiveProject := \"default\"\n \tif a.Spec.Project != \"\" {\n@@ -220,15 +220,20 @@ func (s *Server) getAppEnforceRBAC(ctx context.Context, action, project, namespa\n \t\t}).Warnf(\"user tried to %s application in project %s, but the application is in project %s\", action, project, effectiveProject)\n \t\t// The user has access to the app, but the app is in a different project. Return 404, meaning \"app doesn't\n \t\t// exist in that project\".\n-\t\treturn nil, status.Errorf(codes.NotFound, apierr.NewNotFound(schema.GroupResource{Group: \"argoproj.io\", Resource: \"applications\"}, name).Error())\n+\t\treturn nil, nil, status.Errorf(codes.NotFound, apierr.NewNotFound(schema.GroupResource{Group: \"argoproj.io\", Resource: \"applications\"}, name).Error())\n \t}\n-\treturn a, nil\n+\t// Get the app's associated project, and make sure all project restrictions are enforced.\n+\tproj, err := s.getAppProject(ctx, a, logCtx)\n+\tif err != nil {\n+\t\treturn a, nil, err\n+\t}\n+\treturn a, proj, nil\n }\n \n // getApplicationEnforceRBACInformer uses an informer to get an Application. If the app does not exist, permission is\n // denied, or any other error occurs when getting the app, we return a permission denied error to obscure any sensitive\n // information.\n-func (s *Server) getApplicationEnforceRBACInformer(ctx context.Context, action, project, namespace, name string) (*appv1.Application, error) {\n+func (s *Server) getApplicationEnforceRBACInformer(ctx context.Context, action, project, namespace, name string) (*appv1.Application, *appv1.AppProject, error) {\n \tnamespaceOrDefault := s.appNamespaceOrDefault(namespace)\n \treturn s.getAppEnforceRBAC(ctx, action, project, namespaceOrDefault, name, func() (*appv1.Application, error) {\n \t\treturn s.appLister.Applications(namespaceOrDefault).Get(name)\n@@ -238,7 +243,7 @@ func (s *Server) getApplicationEnforceRBACInformer(ctx context.Context, action,\n // getApplicationEnforceRBACClient uses a client to get an Application. If the app does not exist, permission is denied,\n // or any other error occurs when getting the app, we return a permission denied error to obscure any sensitive\n // information.\n-func (s *Server) getApplicationEnforceRBACClient(ctx context.Context, action, project, namespace, name, resourceVersion string) (*appv1.Application, error) {\n+func (s *Server) getApplicationEnforceRBACClient(ctx context.Context, action, project, namespace, name, resourceVersion string) (*appv1.Application, *appv1.AppProject, error) {\n \tnamespaceOrDefault := s.appNamespaceOrDefault(namespace)\n \treturn s.getAppEnforceRBAC(ctx, action, project, namespaceOrDefault, name, func() (*appv1.Application, error) {\n \t\tif !s.isNamespaceEnabled(namespaceOrDefault) {\n@@ -322,7 +327,13 @@ func (s *Server) Create(ctx context.Context, q *application.ApplicationCreateReq\n \tif q.Validate != nil {\n \t\tvalidate = *q.Validate\n \t}\n-\terr := s.validateAndNormalizeApp(ctx, a, validate)\n+\n+\tproj, err := s.getAppProject(ctx, a, log.WithField(\"application\", a.Name))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\terr = s.validateAndNormalizeApp(ctx, a, proj, validate)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"error while validating and normalizing app: %w\", err)\n \t}\n@@ -378,7 +389,7 @@ func (s *Server) Create(ctx context.Context, q *application.ApplicationCreateReq\n \treturn updated, nil\n }\n \n-func (s *Server) queryRepoServer(ctx context.Context, a *appv1.Application, action func(\n+func (s *Server) queryRepoServer(ctx context.Context, a *appv1.Application, proj *appv1.AppProject, action func(\n \tclient apiclient.RepoServerServiceClient,\n \trepo *appv1.Repository,\n \thelmRepos []*appv1.Repository,\n@@ -405,13 +416,6 @@ func (s *Server) queryRepoServer(ctx context.Context, a *appv1.Application, acti\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error getting kustomize settings options: %w\", err)\n \t}\n-\tproj, err := argo.GetAppProject(a, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\tif apierr.IsNotFound(err) {\n-\t\t\treturn status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", a.Spec.Project)\n-\t\t}\n-\t\treturn fmt.Errorf(\"error getting application's project: %w\", err)\n-\t}\n \n \thelmRepos, err := s.db.ListHelmRepositories(ctx)\n \tif err != nil {\n@@ -446,7 +450,7 @@ func (s *Server) GetManifests(ctx context.Context, q *application.ApplicationMan\n \tif q.Name == nil || *q.Name == \"\" {\n \t\treturn nil, fmt.Errorf(\"invalid request: application name is missing\")\n \t}\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\ta, proj, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -458,7 +462,7 @@ func (s *Server) GetManifests(ctx context.Context, q *application.ApplicationMan\n \t}\n \n \tvar manifestInfo *apiclient.ManifestResponse\n-\terr = s.queryRepoServer(ctx, a, func(\n+\terr = s.queryRepoServer(ctx, a, proj, func(\n \t\tclient apiclient.RepoServerServiceClient, repo *appv1.Repository, helmRepos []*appv1.Repository, helmCreds []*appv1.RepoCreds, helmOptions *appv1.HelmOptions, kustomizeOptions *appv1.KustomizeOptions, enableGenerateManifests map[string]bool) error {\n \t\trevision := source.TargetRevision\n \t\tif q.GetRevision() != \"\" {\n@@ -484,11 +488,6 @@ func (s *Server) GetManifests(ctx context.Context, q *application.ApplicationMan\n \t\t\treturn fmt.Errorf(\"error getting API resources: %w\", err)\n \t\t}\n \n-\t\tproj, err := argo.GetAppProject(a, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"error getting app project: %w\", err)\n-\t\t}\n-\n \t\tmanifestInfo, err = client.GenerateManifest(ctx, &apiclient.ManifestRequest{\n \t\t\tRepo:               repo,\n \t\t\tRevision:           revision,\n@@ -551,13 +550,13 @@ func (s *Server) GetManifestsWithFiles(stream application.ApplicationService_Get\n \t\treturn fmt.Errorf(\"invalid request: application name is missing\")\n \t}\n \n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, query.GetProject(), query.GetAppNamespace(), query.GetName())\n+\ta, proj, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, query.GetProject(), query.GetAppNamespace(), query.GetName())\n \tif err != nil {\n \t\treturn err\n \t}\n \n \tvar manifestInfo *apiclient.ManifestResponse\n-\terr = s.queryRepoServer(ctx, a, func(\n+\terr = s.queryRepoServer(ctx, a, proj, func(\n \t\tclient apiclient.RepoServerServiceClient, repo *appv1.Repository, helmRepos []*appv1.Repository, helmCreds []*appv1.RepoCreds, helmOptions *appv1.HelmOptions, kustomizeOptions *appv1.KustomizeOptions, enableGenerateManifests map[string]bool) error {\n \n \t\tappInstanceLabelKey, err := s.settingsMgr.GetAppInstanceLabelKey()\n@@ -668,7 +667,7 @@ func (s *Server) Get(ctx context.Context, q *application.ApplicationQuery) (*app\n \t// We must use a client Get instead of an informer Get, because it's common to call Get immediately\n \t// following a Watch (which is not yet powered by an informer), and the Get must reflect what was\n \t// previously seen by the client.\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, project, appNs, appName, q.GetResourceVersion())\n+\ta, proj, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, project, appNs, appName, q.GetResourceVersion())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -699,7 +698,7 @@ func (s *Server) Get(ctx context.Context, q *application.ApplicationQuery) (*app\n \n \tif refreshType == appv1.RefreshTypeHard {\n \t\t// force refresh cached application details\n-\t\tif err := s.queryRepoServer(ctx, a, func(\n+\t\tif err := s.queryRepoServer(ctx, a, proj, func(\n \t\t\tclient apiclient.RepoServerServiceClient,\n \t\t\trepo *appv1.Repository,\n \t\t\thelmRepos []*appv1.Repository,\n@@ -751,7 +750,7 @@ func (s *Server) Get(ctx context.Context, q *application.ApplicationQuery) (*app\n \n // ListResourceEvents returns a list of event resources\n func (s *Server) ListResourceEvents(ctx context.Context, q *application.ApplicationResourceEventsQuery) (*v1.EventList, error) {\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\ta, _, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -819,12 +818,12 @@ func (s *Server) validateAndUpdateApp(ctx context.Context, newApp *appv1.Applica\n \ts.projectLock.RLock(newApp.Spec.GetProject())\n \tdefer s.projectLock.RUnlock(newApp.Spec.GetProject())\n \n-\tapp, err := s.getApplicationEnforceRBACClient(ctx, action, currentProject, newApp.Namespace, newApp.Name, \"\")\n+\tapp, proj, err := s.getApplicationEnforceRBACClient(ctx, action, currentProject, newApp.Namespace, newApp.Name, \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\terr = s.validateAndNormalizeApp(ctx, newApp, validate)\n+\terr = s.validateAndNormalizeApp(ctx, newApp, proj, validate)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"error validating and normalizing app: %w\", err)\n \t}\n@@ -923,7 +922,7 @@ func (s *Server) UpdateSpec(ctx context.Context, q *application.ApplicationUpdat\n \tif q.GetSpec() == nil {\n \t\treturn nil, fmt.Errorf(\"error updating application spec: spec is nil in request\")\n \t}\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionUpdate, q.GetProject(), q.GetAppNamespace(), q.GetName(), \"\")\n+\ta, _, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionUpdate, q.GetProject(), q.GetAppNamespace(), q.GetName(), \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -942,7 +941,7 @@ func (s *Server) UpdateSpec(ctx context.Context, q *application.ApplicationUpdat\n \n // Patch patches an application\n func (s *Server) Patch(ctx context.Context, q *application.ApplicationPatchRequest) (*appv1.Application, error) {\n-\tapp, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName(), \"\")\n+\tapp, _, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName(), \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -985,11 +984,35 @@ func (s *Server) Patch(ctx context.Context, q *application.ApplicationPatchReque\n \treturn s.validateAndUpdateApp(ctx, newApp, false, true, rbacpolicy.ActionUpdate, q.GetProject())\n }\n \n+func (s *Server) getAppProject(ctx context.Context, a *appv1.Application, logCtx *log.Entry) (*appv1.AppProject, error) {\n+\tproj, err := argo.GetAppProject(a, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n+\tif err == nil {\n+\t\treturn proj, nil\n+\t}\n+\n+\t// If there's a permission issue or the app doesn't exist, return a vague error to avoid letting the user enumerate project names.\n+\tvagueError := status.Errorf(codes.InvalidArgument, \"app is not allowed in project %q, or the project does not exist\", a.Spec.Project)\n+\n+\tif apierr.IsNotFound(err) {\n+\t\treturn nil, vagueError\n+\t}\n+\n+\tif _, ok := err.(*appv1.ErrApplicationNotAllowedToUseProject); ok {\n+\t\tlogCtx.WithFields(map[string]interface{}{\n+\t\t\t\"project\":                a.Spec.Project,\n+\t\t\targocommon.SecurityField: argocommon.SecurityMedium,\n+\t\t}).Warnf(\"error getting app project: %s\", err)\n+\t\treturn nil, vagueError\n+\t}\n+\n+\treturn nil, vagueError\n+}\n+\n // Delete removes an application and all associated resources\n func (s *Server) Delete(ctx context.Context, q *application.ApplicationDeleteRequest) (*application.ApplicationResponse, error) {\n \tappName := q.GetName()\n \tappNs := s.appNamespaceOrDefault(q.GetAppNamespace())\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, q.GetProject(), appNs, appName, \"\")\n+\ta, _, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, q.GetProject(), appNs, appName, \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1144,16 +1167,7 @@ func (s *Server) Watch(q *application.ApplicationQuery, ws application.Applicati\n \t}\n }\n \n-func (s *Server) validateAndNormalizeApp(ctx context.Context, app *appv1.Application, validate bool) error {\n-\tproj, err := argo.GetAppProject(app, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\tif apierr.IsNotFound(err) {\n-\t\t\t// Offer no hint that the project does not exist.\n-\t\t\tlog.Warnf(\"User attempted to create/update application in non-existent project %q\", app.Spec.Project)\n-\t\t\treturn permissionDeniedErr\n-\t\t}\n-\t\treturn fmt.Errorf(\"error getting application's project: %w\", err)\n-\t}\n+func (s *Server) validateAndNormalizeApp(ctx context.Context, app *appv1.Application, proj *appv1.AppProject, validate bool) error {\n \tif app.GetName() == \"\" {\n \t\treturn fmt.Errorf(\"resource name may not be empty\")\n \t}\n@@ -1257,7 +1271,7 @@ func (s *Server) getAppResources(ctx context.Context, a *appv1.Application) (*ap\n }\n \n func (s *Server) getAppLiveResource(ctx context.Context, action string, q *application.ApplicationResourceRequest) (*appv1.ResourceNode, *rest.Config, *appv1.Application, error) {\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, action, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\ta, _, err := s.getApplicationEnforceRBACInformer(ctx, action, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \tif err != nil {\n \t\treturn nil, nil, nil, err\n \t}\n@@ -1394,7 +1408,7 @@ func (s *Server) DeleteResource(ctx context.Context, q *application.ApplicationR\n }\n \n func (s *Server) ResourceTree(ctx context.Context, q *application.ResourcesQuery) (*appv1.ApplicationTree, error) {\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetApplicationName())\n+\ta, _, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetApplicationName())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1403,7 +1417,7 @@ func (s *Server) ResourceTree(ctx context.Context, q *application.ResourcesQuery\n }\n \n func (s *Server) WatchResourceTree(q *application.ResourcesQuery, ws application.ApplicationService_WatchResourceTreeServer) error {\n-\t_, err := s.getApplicationEnforceRBACInformer(ws.Context(), rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetApplicationName())\n+\t_, _, err := s.getApplicationEnforceRBACInformer(ws.Context(), rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetApplicationName())\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -1420,7 +1434,7 @@ func (s *Server) WatchResourceTree(q *application.ResourcesQuery, ws application\n }\n \n func (s *Server) RevisionMetadata(ctx context.Context, q *application.RevisionMetadataQuery) (*appv1.RevisionMetadata, error) {\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\ta, proj, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1430,12 +1444,6 @@ func (s *Server) RevisionMetadata(ctx context.Context, q *application.RevisionMe\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"error getting repository by URL: %w\", err)\n \t}\n-\t// We need to get some information with the project associated to the app,\n-\t// so we'll know whether GPG signatures are enforced.\n-\tproj, err := argo.GetAppProject(a, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"error getting app project: %w\", err)\n-\t}\n \tconn, repoClient, err := s.repoClientset.NewRepoServerClient()\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"error creating repo server client: %w\", err)\n@@ -1450,7 +1458,7 @@ func (s *Server) RevisionMetadata(ctx context.Context, q *application.RevisionMe\n \n // RevisionChartDetails returns the helm chart metadata, as fetched from the reposerver\n func (s *Server) RevisionChartDetails(ctx context.Context, q *application.RevisionMetadataQuery) (*appv1.ChartDetails, error) {\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\ta, _, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1481,7 +1489,7 @@ func isMatchingResource(q *application.ResourcesQuery, key kube.ResourceKey) boo\n }\n \n func (s *Server) ManagedResources(ctx context.Context, q *application.ResourcesQuery) (*application.ManagedResourcesResponse, error) {\n-\ta, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetApplicationName())\n+\ta, _, err := s.getApplicationEnforceRBACInformer(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetApplicationName())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1538,7 +1546,7 @@ func (s *Server) PodLogs(q *application.ApplicationPodLogsQuery, ws application.\n \t\t}\n \t}\n \n-\ta, err := s.getApplicationEnforceRBACInformer(ws.Context(), rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\ta, _, err := s.getApplicationEnforceRBACInformer(ws.Context(), rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -1730,19 +1738,11 @@ func isTheSelectedOne(currentNode *appv1.ResourceNode, q *application.Applicatio\n \n // Sync syncs an application to its target state\n func (s *Server) Sync(ctx context.Context, syncReq *application.ApplicationSyncRequest) (*appv1.Application, error) {\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, syncReq.GetProject(), syncReq.GetAppNamespace(), syncReq.GetName(), \"\")\n+\ta, proj, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, syncReq.GetProject(), syncReq.GetAppNamespace(), syncReq.GetName(), \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tproj, err := argo.GetAppProject(a, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\tif apierr.IsNotFound(err) {\n-\t\t\treturn a, status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", a.Spec.Project)\n-\t\t}\n-\t\treturn a, fmt.Errorf(\"error getting app project: %w\", err)\n-\t}\n-\n \ts.inferResourcesStatusHealth(a)\n \n \tif !proj.Spec.SyncWindows.Matches(a).CanSync(true) {\n@@ -1839,7 +1839,7 @@ func (s *Server) Sync(ctx context.Context, syncReq *application.ApplicationSyncR\n }\n \n func (s *Server) Rollback(ctx context.Context, rollbackReq *application.ApplicationRollbackRequest) (*appv1.Application, error) {\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionSync, rollbackReq.GetProject(), rollbackReq.GetAppNamespace(), rollbackReq.GetName(), \"\")\n+\ta, _, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionSync, rollbackReq.GetProject(), rollbackReq.GetAppNamespace(), rollbackReq.GetName(), \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1898,7 +1898,7 @@ func (s *Server) Rollback(ctx context.Context, rollbackReq *application.Applicat\n }\n \n func (s *Server) ListLinks(ctx context.Context, req *application.ListAppLinksRequest) (*application.LinksResponse, error) {\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, req.GetProject(), req.GetNamespace(), req.GetName(), \"\")\n+\ta, proj, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, req.GetProject(), req.GetNamespace(), req.GetName(), \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1913,7 +1913,7 @@ func (s *Server) ListLinks(ctx context.Context, req *application.ListAppLinksReq\n \t\treturn nil, fmt.Errorf(\"failed to read application deep links from configmap: %w\", err)\n \t}\n \n-\tclstObj, _, err := s.getObjectsForDeepLinks(ctx, a)\n+\tclstObj, _, err := s.getObjectsForDeepLinks(ctx, a, proj)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1928,12 +1928,7 @@ func (s *Server) ListLinks(ctx context.Context, req *application.ListAppLinksReq\n \treturn finalList, nil\n }\n \n-func (s *Server) getObjectsForDeepLinks(ctx context.Context, app *appv1.Application) (cluster *unstructured.Unstructured, project *unstructured.Unstructured, err error) {\n-\tproj, err := argo.GetAppProject(app, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\treturn nil, nil, fmt.Errorf(\"error getting app project: %w\", err)\n-\t}\n-\n+func (s *Server) getObjectsForDeepLinks(ctx context.Context, app *appv1.Application, proj *appv1.AppProject) (cluster *unstructured.Unstructured, project *unstructured.Unstructured, err error) {\n \t// sanitize project jwt tokens\n \tproj.Status = appv1.AppProjectStatus{}\n \n@@ -1996,7 +1991,12 @@ func (s *Server) ListResourceLinks(ctx context.Context, req *application.Applica\n \t\treturn nil, err\n \t}\n \n-\tclstObj, projObj, err := s.getObjectsForDeepLinks(ctx, app)\n+\tproj, err := s.getAppProject(ctx, app, log.WithField(\"application\", app.GetName()))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tclstObj, projObj, err := s.getObjectsForDeepLinks(ctx, app, proj)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -2052,7 +2052,7 @@ func (s *Server) resolveRevision(ctx context.Context, app *appv1.Application, sy\n func (s *Server) TerminateOperation(ctx context.Context, termOpReq *application.OperationTerminateRequest) (*application.OperationTerminateResponse, error) {\n \tappName := termOpReq.GetName()\n \tappNs := s.appNamespaceOrDefault(termOpReq.GetAppNamespace())\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionSync, termOpReq.GetProject(), appNs, appName, \"\")\n+\ta, _, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionSync, termOpReq.GetProject(), appNs, appName, \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -2125,7 +2125,7 @@ func (s *Server) ListResourceActions(ctx context.Context, q *application.Applica\n \n func (s *Server) getUnstructuredLiveResourceOrApp(ctx context.Context, rbacRequest string, q *application.ApplicationResourceRequest) (obj *unstructured.Unstructured, res *appv1.ResourceNode, app *appv1.Application, config *rest.Config, err error) {\n \tif q.GetKind() == applicationType.ApplicationKind && q.GetGroup() == applicationType.Group && q.GetName() == q.GetResourceName() {\n-\t\tapp, err = s.getApplicationEnforceRBACInformer(ctx, rbacRequest, q.GetProject(), q.GetAppNamespace(), q.GetName())\n+\t\tapp, _, err = s.getApplicationEnforceRBACInformer(ctx, rbacRequest, q.GetProject(), q.GetAppNamespace(), q.GetName())\n \t\tif err != nil {\n \t\t\treturn nil, nil, nil, nil, err\n \t\t}\n@@ -2221,14 +2221,19 @@ func (s *Server) RunResourceAction(ctx context.Context, q *application.ResourceA\n \t\t}\n \t}\n \n+\tproj, err := s.getAppProject(ctx, a, log.WithField(\"application\", a.Name))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \t// First, make sure all the returned resources are permitted, for each operation.\n \t// Also perform create with dry-runs for all create-operation resources.\n \t// This is performed separately to reduce the risk of only some of the resources being successfully created later.\n \t// TODO: when apply/delete operations would be supported for custom actions,\n \t// the dry-run for relevant apply/delete operation would have to be invoked as well.\n \tfor _, impactedResource := range newObjects {\n \t\tnewObj := impactedResource.UnstructuredObj\n-\t\terr := s.verifyResourcePermitted(ctx, app, newObj)\n+\t\terr := s.verifyResourcePermitted(ctx, app, proj, newObj)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -2322,14 +2327,7 @@ func (s *Server) patchResource(ctx context.Context, config *rest.Config, liveObj\n \treturn &application.ApplicationResponse{}, nil\n }\n \n-func (s *Server) verifyResourcePermitted(ctx context.Context, app *appv1.Application, obj *unstructured.Unstructured) error {\n-\tproj, err := argo.GetAppProject(app, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\tif apierr.IsNotFound(err) {\n-\t\t\treturn fmt.Errorf(\"application references project %s which does not exist\", app.Spec.Project)\n-\t\t}\n-\t\treturn fmt.Errorf(\"failed to get project %s: %w\", app.Spec.Project, err)\n-\t}\n+func (s *Server) verifyResourcePermitted(ctx context.Context, app *appv1.Application, proj *appv1.AppProject, obj *unstructured.Unstructured) error {\n \tpermitted, err := proj.IsResourcePermitted(schema.GroupKind{Group: obj.GroupVersionKind().Group, Kind: obj.GroupVersionKind().Kind}, obj.GetNamespace(), app.Spec.Destination, func(project string) ([]*appv1.Cluster, error) {\n \t\tclusters, err := s.db.GetProjectClusters(context.TODO(), project)\n \t\tif err != nil {\n@@ -2389,16 +2387,11 @@ func splitStatusPatch(patch []byte) ([]byte, []byte, error) {\n }\n \n func (s *Server) GetApplicationSyncWindows(ctx context.Context, q *application.ApplicationSyncWindowsQuery) (*application.ApplicationSyncWindowsResponse, error) {\n-\ta, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName(), \"\")\n+\ta, proj, err := s.getApplicationEnforceRBACClient(ctx, rbacpolicy.ActionGet, q.GetProject(), q.GetAppNamespace(), q.GetName(), \"\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tproj, err := argo.GetAppProject(a, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"error getting app project: %w\", err)\n-\t}\n-\n \twindows := proj.Spec.SyncWindows.Matches(a)\n \tsync := windows.CanSync(true)\n "
        },
        {
          "filename": "server/application/application_test.go",
          "status": "modified",
          "additions": 114,
          "deletions": 4,
          "patch": "@@ -1818,7 +1818,7 @@ func TestServer_GetApplicationSyncWindowsState(t *testing.T) {\n \t\tappServer := newTestAppServer(t, testApp)\n \n \t\tactive, err := appServer.GetApplicationSyncWindows(context.Background(), &application.ApplicationSyncWindowsQuery{Name: &testApp.Name})\n-\t\tassert.Contains(t, err.Error(), \"not found\")\n+\t\tassert.Contains(t, err.Error(), \"not exist\")\n \t\tassert.Nil(t, active)\n \t})\n }\n@@ -2428,7 +2428,16 @@ func TestAppNamespaceRestrictions(t *testing.T) {\n \tt.Run(\"Get application in other namespace when allowed\", func(t *testing.T) {\n \t\ttestApp := newTestApp()\n \t\ttestApp.Namespace = \"argocd-1\"\n-\t\tappServer := newTestAppServer(t, testApp)\n+\t\ttestApp.Spec.Project = \"other-ns\"\n+\t\totherNsProj := &appsv1.AppProject{\n+\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"other-ns\", Namespace: \"default\"},\n+\t\t\tSpec: appsv1.AppProjectSpec{\n+\t\t\t\tSourceRepos:      []string{\"*\"},\n+\t\t\t\tDestinations:     []appsv1.ApplicationDestination{{Server: \"*\", Namespace: \"*\"}},\n+\t\t\t\tSourceNamespaces: []string{\"argocd-1\"},\n+\t\t\t},\n+\t\t}\n+\t\tappServer := newTestAppServer(t, testApp, otherNsProj)\n \t\tappServer.enabledNamespaces = []string{\"argocd-1\"}\n \t\tapp, err := appServer.Get(context.TODO(), &application.ApplicationQuery{\n \t\t\tName:         pointer.String(\"test-app\"),\n@@ -2439,6 +2448,28 @@ func TestAppNamespaceRestrictions(t *testing.T) {\n \t\trequire.Equal(t, \"argocd-1\", app.Namespace)\n \t\trequire.Equal(t, \"test-app\", app.Name)\n \t})\n+\tt.Run(\"Get application in other namespace when project is not allowed\", func(t *testing.T) {\n+\t\ttestApp := newTestApp()\n+\t\ttestApp.Namespace = \"argocd-1\"\n+\t\ttestApp.Spec.Project = \"other-ns\"\n+\t\totherNsProj := &appsv1.AppProject{\n+\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"other-ns\", Namespace: \"default\"},\n+\t\t\tSpec: appsv1.AppProjectSpec{\n+\t\t\t\tSourceRepos:      []string{\"*\"},\n+\t\t\t\tDestinations:     []appsv1.ApplicationDestination{{Server: \"*\", Namespace: \"*\"}},\n+\t\t\t\tSourceNamespaces: []string{\"argocd-2\"},\n+\t\t\t},\n+\t\t}\n+\t\tappServer := newTestAppServer(t, testApp, otherNsProj)\n+\t\tappServer.enabledNamespaces = []string{\"argocd-1\"}\n+\t\tapp, err := appServer.Get(context.TODO(), &application.ApplicationQuery{\n+\t\t\tName:         pointer.String(\"test-app\"),\n+\t\t\tAppNamespace: pointer.String(\"argocd-1\"),\n+\t\t})\n+\t\trequire.Error(t, err)\n+\t\trequire.Nil(t, app)\n+\t\trequire.ErrorContains(t, err, \"app is not allowed in project\")\n+\t})\n \tt.Run(\"Create application in other namespace when allowed\", func(t *testing.T) {\n \t\ttestApp := newTestApp()\n \t\ttestApp.Namespace = \"argocd-1\"\n@@ -2481,7 +2512,7 @@ func TestAppNamespaceRestrictions(t *testing.T) {\n \t\t})\n \t\trequire.Error(t, err)\n \t\trequire.Nil(t, app)\n-\t\trequire.ErrorContains(t, err, \"not allowed to use project\")\n+\t\trequire.ErrorContains(t, err, \"app is not allowed in project\")\n \t})\n \n \tt.Run(\"Create application in other namespace when not allowed by configuration\", func(t *testing.T) {\n@@ -2505,5 +2536,84 @@ func TestAppNamespaceRestrictions(t *testing.T) {\n \t\trequire.Nil(t, app)\n \t\trequire.ErrorContains(t, err, \"namespace 'argocd-1' is not permitted\")\n \t})\n-\n+\tt.Run(\"Get application sync window in other namespace when project is allowed\", func(t *testing.T) {\n+\t\ttestApp := newTestApp()\n+\t\ttestApp.Namespace = \"argocd-1\"\n+\t\ttestApp.Spec.Project = \"other-ns\"\n+\t\totherNsProj := &appsv1.AppProject{\n+\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"other-ns\", Namespace: \"default\"},\n+\t\t\tSpec: appsv1.AppProjectSpec{\n+\t\t\t\tSourceRepos:      []string{\"*\"},\n+\t\t\t\tDestinations:     []appsv1.ApplicationDestination{{Server: \"*\", Namespace: \"*\"}},\n+\t\t\t\tSourceNamespaces: []string{\"argocd-1\"},\n+\t\t\t},\n+\t\t}\n+\t\tappServer := newTestAppServer(t, testApp, otherNsProj)\n+\t\tappServer.enabledNamespaces = []string{\"argocd-1\"}\n+\t\tactive, err := appServer.GetApplicationSyncWindows(context.TODO(), &application.ApplicationSyncWindowsQuery{Name: &testApp.Name, AppNamespace: &testApp.Namespace})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, 0, len(active.ActiveWindows))\n+\t})\n+\tt.Run(\"Get application sync window in other namespace when project is not allowed\", func(t *testing.T) {\n+\t\ttestApp := newTestApp()\n+\t\ttestApp.Namespace = \"argocd-1\"\n+\t\ttestApp.Spec.Project = \"other-ns\"\n+\t\totherNsProj := &appsv1.AppProject{\n+\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"other-ns\", Namespace: \"default\"},\n+\t\t\tSpec: appsv1.AppProjectSpec{\n+\t\t\t\tSourceRepos:      []string{\"*\"},\n+\t\t\t\tDestinations:     []appsv1.ApplicationDestination{{Server: \"*\", Namespace: \"*\"}},\n+\t\t\t\tSourceNamespaces: []string{\"argocd-2\"},\n+\t\t\t},\n+\t\t}\n+\t\tappServer := newTestAppServer(t, testApp, otherNsProj)\n+\t\tappServer.enabledNamespaces = []string{\"argocd-1\"}\n+\t\tactive, err := appServer.GetApplicationSyncWindows(context.TODO(), &application.ApplicationSyncWindowsQuery{Name: &testApp.Name, AppNamespace: &testApp.Namespace})\n+\t\trequire.Error(t, err)\n+\t\trequire.Nil(t, active)\n+\t\trequire.ErrorContains(t, err, \"app is not allowed in project\")\n+\t})\n+\tt.Run(\"Get list of links in other namespace when project is not allowed\", func(t *testing.T) {\n+\t\ttestApp := newTestApp()\n+\t\ttestApp.Namespace = \"argocd-1\"\n+\t\ttestApp.Spec.Project = \"other-ns\"\n+\t\totherNsProj := &appsv1.AppProject{\n+\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"other-ns\", Namespace: \"default\"},\n+\t\t\tSpec: appsv1.AppProjectSpec{\n+\t\t\t\tSourceRepos:      []string{\"*\"},\n+\t\t\t\tDestinations:     []appsv1.ApplicationDestination{{Server: \"*\", Namespace: \"*\"}},\n+\t\t\t\tSourceNamespaces: []string{\"argocd-2\"},\n+\t\t\t},\n+\t\t}\n+\t\tappServer := newTestAppServer(t, testApp, otherNsProj)\n+\t\tappServer.enabledNamespaces = []string{\"argocd-1\"}\n+\t\tlinks, err := appServer.ListLinks(context.TODO(), &application.ListAppLinksRequest{\n+\t\t\tName:      pointer.String(\"test-app\"),\n+\t\t\tNamespace: pointer.String(\"argocd-1\"),\n+\t\t})\n+\t\trequire.Error(t, err)\n+\t\trequire.Nil(t, links)\n+\t\trequire.ErrorContains(t, err, \"app is not allowed in project\")\n+\t})\n+\tt.Run(\"Get list of links in other namespace when project is allowed\", func(t *testing.T) {\n+\t\ttestApp := newTestApp()\n+\t\ttestApp.Namespace = \"argocd-1\"\n+\t\ttestApp.Spec.Project = \"other-ns\"\n+\t\totherNsProj := &appsv1.AppProject{\n+\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"other-ns\", Namespace: \"default\"},\n+\t\t\tSpec: appsv1.AppProjectSpec{\n+\t\t\t\tSourceRepos:      []string{\"*\"},\n+\t\t\t\tDestinations:     []appsv1.ApplicationDestination{{Server: \"*\", Namespace: \"*\"}},\n+\t\t\t\tSourceNamespaces: []string{\"argocd-1\"},\n+\t\t\t},\n+\t\t}\n+\t\tappServer := newTestAppServer(t, testApp, otherNsProj)\n+\t\tappServer.enabledNamespaces = []string{\"argocd-1\"}\n+\t\tlinks, err := appServer.ListLinks(context.TODO(), &application.ListAppLinksRequest{\n+\t\t\tName:      pointer.String(\"test-app\"),\n+\t\t\tNamespace: pointer.String(\"argocd-1\"),\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, 0, len(links.Items))\n+\t})\n }"
        },
        {
          "filename": "util/argo/argo.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -694,8 +694,7 @@ func GetAppProject(app *argoappv1.Application, projLister applicationsv1.AppProj\n \t\treturn nil, err\n \t}\n \tif !proj.IsAppNamespacePermitted(app, ns) {\n-\t\treturn nil, fmt.Errorf(\"application '%s' in namespace '%s' is not allowed to use project '%s'\",\n-\t\t\tapp.Name, app.Namespace, proj.Name)\n+\t\treturn nil, argoappv1.NewErrApplicationNotAllowedToUseProject(app.Name, app.Namespace, proj.Name)\n \t}\n \treturn proj, nil\n }"
        },
        {
          "filename": "util/session/sessionmanager.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -312,7 +312,7 @@ func expireOldFailedAttempts(maxAge time.Duration, failures map[string]LoginAtte\n \treturn expiredCount\n }\n \n-// Protect admin user from login attempt reset caused by attempts to overflow cache in a brute force attack. Instead remove random non-admin to make room in cache. \n+// Protect admin user from login attempt reset caused by attempts to overflow cache in a brute force attack. Instead remove random non-admin to make room in cache.\n func pickRandomNonAdminLoginFailure(failures map[string]LoginAttempts, username string) *string {\n \tidx := rand.Intn(len(failures) - 1)\n \ti := 0"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d23e6ac79bb95a911b988551ba33bfc9939c5f18",
            "date": "2025-01-14T16:10:14Z",
            "author_login": "crenshaw-dev"
          },
          {
            "sha": "9a51757049dc028596d4950d7a6c7cd5a446301a",
            "date": "2025-01-14T15:41:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c3600d240a42a4708ec65091ffb23689b4513f85",
            "date": "2025-01-14T12:37:06Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "b77d9d9f5f9cf3862ef75e14a5877a3fcf60fa40",
            "date": "2025-01-14T12:16:41Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "2f579404f68ded0b0156fc25d6e554640c4ad009",
            "date": "2025-01-14T12:12:38Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-863",
    "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. The API server does not enforce project sourceNamespaces which allows attackers to use the UI to edit resources which should only be mutable via gitops. This vulenrability is fixed in 2.10.7, 2.9.12, and 2.8.16.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-04-15T20:15:11.127",
    "last_modified": "2025-01-09T17:04:35.590",
    "fix_date": "2024-04-15T07:20:07Z"
  },
  "references": [
    {
      "url": "https://github.com/argoproj/argo-cd/commit/c514105af739eebedb9dbe89d8a6dd8dfc30bb2c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/c5a252c4cc260e240e2074794aedb861d07e9ca5",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/e0ff56d89fbd7d066e9c862b30337f6520f13f17",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-2gvw-w6fj-7m3c",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/c514105af739eebedb9dbe89d8a6dd8dfc30bb2c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/c5a252c4cc260e240e2074794aedb861d07e9ca5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/e0ff56d89fbd7d066e9c862b30337f6520f13f17",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-2gvw-w6fj-7m3c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.488652",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "argo-cd",
    "owner": "argoproj",
    "created_at": "2018-02-09T11:12:01Z",
    "updated_at": "2025-01-14T12:37:12Z",
    "pushed_at": "2025-01-14T12:37:08Z",
    "size": 125601,
    "stars": 18420,
    "forks": 5620,
    "open_issues": 3601,
    "watchers": 18420,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 6686751,
      "TypeScript": 1298168,
      "Lua": 199797,
      "SCSS": 92938,
      "Shell": 58329,
      "Makefile": 24983,
      "Dockerfile": 15204,
      "Procfile": 10040,
      "JavaScript": 5975,
      "CSS": 2209,
      "Mustache": 1066,
      "HTML": 895
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:15:10.212233"
  }
}