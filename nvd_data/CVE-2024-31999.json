{
  "cve_id": "CVE-2024-31999",
  "github_data": {
    "repository": "fastify/fastify-secure-session",
    "fix_commit": "56d66642ecc633cff0606927601e81cdac361370",
    "related_commits": [
      "56d66642ecc633cff0606927601e81cdac361370",
      "56d66642ecc633cff0606927601e81cdac361370"
    ],
    "patch_url": "https://github.com/fastify/fastify-secure-session/commit/56d66642ecc633cff0606927601e81cdac361370.patch",
    "fix_commit_details": {
      "sha": "56d66642ecc633cff0606927601e81cdac361370",
      "commit_date": "2024-04-10T10:47:04Z",
      "author": {
        "login": "mcollina",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-9wwp-q7wq-jx35",
        "length": 688,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 261,
        "additions": 255,
        "deletions": 6
      },
      "files": [
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -53,6 +53,9 @@ fastify.register(require('@fastify/secure-session'), {\n   cookieName: 'my-session-cookie',\n   // adapt this to point to the directory where secret-key is located\n   key: fs.readFileSync(path.join(__dirname, 'secret-key')),\n+  // the amount of time the session is considered valid; this is different from the cookie options\n+  // and based on value wihin the session.\n+  expiry: 24 * 60 * 60, // Default 1 day\n   cookie: {\n     path: '/'\n     // options for setCookie, see https://github.com/fastify/fastify-cookie\n@@ -365,9 +368,12 @@ fastify.get('/', (request, reply) => {\n })\n ```\n \n-## TODO\n+## Security Notice\n \n-- [ ] add an option to just sign, and do not encrypt\n+`@fastify/secure-session` stores the session within a cookie, and as a result an attacker could impersonate a user\n+if the cookie is leaked. The maximum expiration time of the session is set by the `expiry` option, which has default\n+1 day. Adjust this parameter accordingly.\n+Moreover, to protect users from further attacks, all cookies are created as \"http only\" if not specified otherwise.\n \n ## License\n "
        },
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 26,
          "deletions": 4,
          "patch": "@@ -50,8 +50,13 @@ function fastifySecureSession (fastify, options, next) {\n   for (const sessionOptions of options) {\n     const sessionName = sessionOptions.sessionName || 'session'\n     const cookieName = sessionOptions.cookieName || sessionName\n+    const expiry = sessionOptions.expiry || 86401 // 24 hours\n     const cookieOptions = sessionOptions.cookieOptions || sessionOptions.cookie || {}\n \n+    if (cookieOptions.httpOnly === undefined) {\n+      cookieOptions.httpOnly = true\n+    }\n+\n     let key\n     if (sessionOptions.secret) {\n       if (Buffer.byteLength(sessionOptions.secret) < 32) {\n@@ -120,7 +125,8 @@ function fastifySecureSession (fastify, options, next) {\n     sessionNames.set(sessionName, {\n       cookieName,\n       cookieOptions,\n-      key\n+      key,\n+      expiry\n     })\n \n     if (!defaultSessionName) {\n@@ -139,7 +145,7 @@ function fastifySecureSession (fastify, options, next) {\n       throw new Error('Unknown session key.')\n     }\n \n-    const { key } = sessionNames.get(sessionName)\n+    const { key, expiry } = sessionNames.get(sessionName)\n \n     // do not use destructuring or it will deopt\n     const split = cookie.split(';')\n@@ -184,8 +190,15 @@ function fastifySecureSession (fastify, options, next) {\n       return null\n     }\n \n+    const parsed = JSON.parse(msg)\n+    if ((parsed.__ts + expiry) * 1000 - Date.now() <= 0) {\n+      // maximum validity is reached, resetting\n+      log.debug('@fastify/secure-session: expiry reached')\n+      return null\n+    }\n     const session = new Proxy(new Session(JSON.parse(msg)), sessionProxyHandler)\n     session.changed = signingKeyRotated\n+\n     return session\n   })\n \n@@ -228,7 +241,7 @@ function fastifySecureSession (fastify, options, next) {\n         const cookie = request.cookies[cookieName]\n         const result = fastify.decodeSecureSession(cookie, request.log, sessionName)\n \n-        request[sessionName] = new Proxy((result || new Session({})), sessionProxyHandler)\n+        request[sessionName] = result || new Proxy(new Session({}), sessionProxyHandler)\n       }\n \n       next()\n@@ -275,6 +288,10 @@ class Session {\n     this[kCookieOptions] = null\n     this.changed = false\n     this.deleted = false\n+\n+    if (this[kObj].__ts === undefined) {\n+      this[kObj].__ts = Math.round(Date.now() / 1000)\n+    }\n   }\n \n   get (key) {\n@@ -296,7 +313,12 @@ class Session {\n   }\n \n   data () {\n-    return this[kObj]\n+    const copy = {\n+      ...this[kObj]\n+    }\n+\n+    delete copy.__ts\n+    return copy\n   }\n \n   touch () {"
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -32,6 +32,7 @@\n   \"homepage\": \"https://github.com/fastify/fastify-secure-session#readme\",\n   \"devDependencies\": {\n     \"@fastify/pre-commit\": \"^2.0.2\",\n+    \"@sinonjs/fake-timers\": \"^11.2.2\",\n     \"@types/node\": \"^20.1.0\",\n     \"cookie\": \"^0.6.0\",\n     \"fastify\": \"^4.0.0\","
        },
        {
          "filename": "test/anti-reuse-15-min.js",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+'use strict'\n+\n+const t = require('tap')\n+const fastify = require('fastify')({ logger: false })\n+const sodium = require('sodium-native')\n+const FakeTimers = require('@sinonjs/fake-timers')\n+const clock = FakeTimers.install({\n+  shouldAdvanceTime: true,\n+  now: Date.now()\n+})\n+\n+const key = Buffer.alloc(sodium.crypto_secretbox_KEYBYTES)\n+sodium.randombytes_buf(key)\n+\n+fastify.register(require('../'), {\n+  key,\n+  expiry: 15 * 60 // 15 minutes\n+})\n+\n+fastify.post('/', (request, reply) => {\n+  request.session.set('some', request.body.some)\n+  request.session.set('some2', request.body.some2)\n+  reply.send('hello world')\n+})\n+\n+t.teardown(fastify.close.bind(fastify))\n+t.plan(5)\n+\n+fastify.get('/', (request, reply) => {\n+  const some = request.session.get('some')\n+  const some2 = request.session.get('some2')\n+  reply.send({ some, some2 })\n+})\n+\n+fastify.inject({\n+  method: 'POST',\n+  url: '/',\n+  payload: {\n+    some: 'someData',\n+    some2: { a: 1, b: undefined, c: 3 }\n+  }\n+}, (error, response) => {\n+  t.error(error)\n+  t.equal(response.statusCode, 200)\n+  t.ok(response.headers['set-cookie'])\n+\n+  clock.jump('00:15:01') // default validity is 24 hours\n+\n+  fastify.inject({\n+    method: 'GET',\n+    url: '/',\n+    headers: {\n+      cookie: response.headers['set-cookie']\n+    }\n+  }, (error, response) => {\n+    t.error(error)\n+    t.same(JSON.parse(response.payload), {})\n+    clock.reset()\n+    clock.uninstall()\n+    fastify.close()\n+  })\n+})"
        },
        {
          "filename": "test/anti-reuse.js",
          "status": "added",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -0,0 +1,62 @@\n+'use strict'\n+\n+const t = require('tap')\n+const fastify = require('fastify')({ logger: false })\n+const sodium = require('sodium-native')\n+const FakeTimers = require('@sinonjs/fake-timers')\n+const clock = FakeTimers.install({\n+  shouldAdvanceTime: true,\n+  now: Date.now()\n+})\n+\n+const key = Buffer.alloc(sodium.crypto_secretbox_KEYBYTES)\n+\n+sodium.randombytes_buf(key)\n+\n+fastify.register(require('../'), {\n+  key\n+})\n+\n+fastify.post('/', (request, reply) => {\n+  request.session.set('some', request.body.some)\n+  request.session.set('some2', request.body.some2)\n+  reply.send('hello world')\n+})\n+\n+t.teardown(fastify.close.bind(fastify))\n+t.plan(6)\n+\n+fastify.get('/', (request, reply) => {\n+  const some = request.session.get('some')\n+  const some2 = request.session.get('some2')\n+  reply.send({ some, some2 })\n+})\n+\n+fastify.inject({\n+  method: 'POST',\n+  url: '/',\n+  payload: {\n+    some: 'someData',\n+    some2: { a: 1, b: undefined, c: 3 }\n+  }\n+}, (error, response) => {\n+  t.error(error)\n+  t.equal(response.statusCode, 200)\n+  t.ok(response.headers['set-cookie'])\n+  t.equal(response.headers['set-cookie'].split(';')[1].trim(), 'HttpOnly')\n+\n+  clock.jump('24:01:00') // default validity is 24 hours\n+\n+  fastify.inject({\n+    method: 'GET',\n+    url: '/',\n+    headers: {\n+      cookie: response.headers['set-cookie']\n+    }\n+  }, (error, response) => {\n+    t.error(error)\n+    t.same(JSON.parse(response.payload), {})\n+    clock.reset()\n+    clock.uninstall()\n+  })\n+})"
        },
        {
          "filename": "test/http-only.js",
          "status": "added",
          "additions": 96,
          "deletions": 0,
          "patch": "@@ -0,0 +1,96 @@\n+'use strict'\n+\n+const tap = require('tap')\n+const Fastify = require('fastify')\n+const SecureSessionPlugin = require('../')\n+const sodium = require('sodium-native')\n+const key = Buffer.alloc(sodium.crypto_secretbox_KEYBYTES)\n+sodium.randombytes_buf(key)\n+\n+tap.test('http-only override', async t => {\n+  const fastify = Fastify({ logger: false })\n+  t.teardown(fastify.close.bind(fastify))\n+  t.plan(3)\n+\n+  await fastify.register(SecureSessionPlugin, {\n+    key,\n+    cookie: {\n+      path: '/',\n+      httpOnly: false\n+    }\n+  })\n+\n+  fastify.post('/login', (request, reply) => {\n+    request.session.set('user', request.body.email)\n+    reply.send('Welcome back!')\n+  })\n+\n+  const loginResponse = await fastify.inject({\n+    method: 'POST',\n+    url: '/login',\n+    payload: {\n+      email: 'me@here.fine'\n+    }\n+  })\n+\n+  t.equal(loginResponse.statusCode, 200)\n+  t.ok(loginResponse.headers['set-cookie'])\n+  t.not(loginResponse.headers['set-cookie'].split(';')[1].trim(), 'HttpOnly')\n+})\n+\n+tap.test('Override global options does not change httpOnly default', t => {\n+  t.plan(8)\n+  const fastify = Fastify()\n+  fastify.register(SecureSessionPlugin, {\n+    key,\n+    cookieOptions: {\n+      maxAge: 42,\n+      path: '/'\n+    }\n+  })\n+\n+  fastify.post('/', (request, reply) => {\n+    request.session.set('data', request.body)\n+    request.session.options({ maxAge: 1000 * 60 * 60 })\n+    reply.send('hello world')\n+  })\n+\n+  t.teardown(fastify.close.bind(fastify))\n+\n+  fastify.get('/', (request, reply) => {\n+    const data = request.session.get('data')\n+\n+    if (!data) {\n+      reply.code(404).send()\n+      return\n+    }\n+    reply.send(data)\n+  })\n+\n+  fastify.inject({\n+    method: 'POST',\n+    url: '/',\n+    payload: {\n+      some: 'data'\n+    }\n+  }, (error, response) => {\n+    t.error(error)\n+    t.equal(response.statusCode, 200)\n+    t.ok(response.headers['set-cookie'])\n+    const { maxAge, path } = response.cookies[0]\n+    t.equal(maxAge, 1000 * 60 * 60)\n+    t.equal(response.headers['set-cookie'].split(';')[3].trim(), 'HttpOnly')\n+    t.equal(path, '/')\n+\n+    fastify.inject({\n+      method: 'GET',\n+      url: '/',\n+      headers: {\n+        cookie: response.headers['set-cookie']\n+      }\n+    }, (error, response) => {\n+      t.error(error)\n+      t.same(JSON.parse(response.payload), { some: 'data' })\n+    })\n+  })\n+})"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 3,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6a524c4c9234db911e1a605ca5c0ddb7bc8182dc",
            "date": "2025-01-11T12:11:28Z",
            "author_login": "Fdawgs"
          },
          {
            "sha": "9932edbf2aa65e9cffbf72f9c6a4e5213fc1b56c",
            "date": "2025-01-11T08:28:50Z",
            "author_login": "Fdawgs"
          },
          {
            "sha": "1bb4376dc7084197dbce9a7157afa0034c354a3e",
            "date": "2025-01-10T16:17:04Z",
            "author_login": "Fdawgs"
          },
          {
            "sha": "e3a5170156d3fc0f5b5276aa42c9bb157232b903",
            "date": "2025-01-07T18:40:03Z",
            "author_login": "Fdawgs"
          },
          {
            "sha": "ece59c7e89ca8be21ba00afd626f4865e1ad15aa",
            "date": "2024-12-29T19:10:41Z",
            "author_login": "Fdawgs"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-613",
    "description": "@festify/secure-session creates a secure stateless cookie session for Fastify. At the end of the request handling, it will encrypt all data in the session with a secret key and attach the ciphertext as a cookie value with the defined cookie name. After that, the session on the server side is destroyed. When an encrypted cookie with matching session name is provided with subsequent requests, it will decrypt the ciphertext to get the data. The plugin then creates a new session with the data in the ciphertext. Thus theoretically the web instance is still accessing the data from a server-side session, but technically that session is generated solely from a user provided cookie (which is assumed to be non-craftable because it is encrypted with a secret key not known to the user). The issue exists in the session removal process. In the delete function of the code, when the session is deleted, it is marked for deletion. However, if an attacker could gain access to the cookie, they could keep using it forever. Version 7.3.0 contains a patch for the issue. As a workaround, one may include a \"last update\" field in the session, and treat \"old sessions\" as expired.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-10T22:15:07.710",
    "last_modified": "2024-11-21T09:14:18.877",
    "fix_date": "2024-04-10T10:47:04Z"
  },
  "references": [
    {
      "url": "https://github.com/fastify/fastify-secure-session/commit/56d66642ecc633cff0606927601e81cdac361370",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/fastify/fastify-secure-session/security/advisories/GHSA-9wwp-q7wq-jx35",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/fastify/fastify-secure-session/commit/56d66642ecc633cff0606927601e81cdac361370",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/fastify/fastify-secure-session/security/advisories/GHSA-9wwp-q7wq-jx35",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.471327",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fastify-secure-session",
    "owner": "fastify",
    "created_at": "2017-12-03T19:06:10Z",
    "updated_at": "2025-01-11T12:11:38Z",
    "pushed_at": "2025-01-11T12:11:34Z",
    "size": 274,
    "stars": 213,
    "forks": 47,
    "open_issues": 1,
    "watchers": 213,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 69594,
      "TypeScript": 2164
    },
    "commit_activity": {
      "total_commits_last_year": 46,
      "avg_commits_per_week": 0.8846153846153846,
      "days_active_last_year": 31
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:49:19.731652"
  }
}