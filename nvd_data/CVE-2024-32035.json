{
  "cve_id": "CVE-2024-32035",
  "github_data": {
    "repository": "SixLabors/ImageSharp",
    "fix_commit": "b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3",
    "related_commits": [
      "b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3",
      "f21d64188e59ae9464ff462056a5e29d8e618b27",
      "b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3",
      "f21d64188e59ae9464ff462056a5e29d8e618b27"
    ],
    "patch_url": "https://github.com/SixLabors/ImageSharp/commit/b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3.patch",
    "fix_commit_details": {
      "sha": "b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3",
      "commit_date": "2024-04-10T22:16:16Z",
      "author": {
        "login": "antonfirsov",
        "type": "User",
        "stats": {
          "total_commits": 2180,
          "average_weekly_commits": 3.303030303030303,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 169
        }
      },
      "commit_message": {
        "title": "Merge pull request #2706 from SixLabors/af/memlimit-01",
        "length": 113,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 272,
        "additions": 216,
        "deletions": 56
      },
      "files": [
        {
          "filename": "src/ImageSharp/Formats/Png/PngDecoderCore.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -1979,6 +1979,9 @@ private IMemoryOwner<byte> ReadChunkData(int length)\n         }\n \n         // We rent the buffer here to return it afterwards in Decode()\n+        // We don't want to throw a degenerated memory exception here as we want to allow partial decoding\n+        // so limit the length.\n+        length = (int)Math.Min(length, this.currentStream.Length - this.currentStream.Position);\n         IMemoryOwner<byte> buffer = this.configuration.MemoryAllocator.Allocate<byte>(length, AllocationOptions.Clean);\n \n         this.currentStream.Read(buffer.GetSpan(), 0, length);"
        },
        {
          "filename": "src/ImageSharp/Memory/Allocators/Internals/UnmanagedMemoryHandle.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -11,7 +11,7 @@ namespace SixLabors.ImageSharp.Memory.Internals;\n internal struct UnmanagedMemoryHandle : IEquatable<UnmanagedMemoryHandle>\n {\n     // Number of allocation re-attempts when detecting OutOfMemoryException.\n-    private const int MaxAllocationAttempts = 1000;\n+    private const int MaxAllocationAttempts = 10;\n \n     // Track allocations for testing purposes:\n     private static int totalOutstandingHandles;"
        },
        {
          "filename": "src/ImageSharp/Memory/Allocators/MemoryAllocator.cs",
          "status": "modified",
          "additions": 40,
          "deletions": 6,
          "patch": "@@ -2,6 +2,7 @@\n // Licensed under the Six Labors Split License.\n \n using System.Buffers;\n+using System.Runtime.CompilerServices;\n \n namespace SixLabors.ImageSharp.Memory;\n \n@@ -10,6 +11,8 @@ namespace SixLabors.ImageSharp.Memory;\n /// </summary>\n public abstract class MemoryAllocator\n {\n+    private const int OneGigabyte = 1 << 30;\n+\n     /// <summary>\n     /// Gets the default platform-specific global <see cref=\"MemoryAllocator\"/> instance that\n     /// serves as the default value for <see cref=\"Configuration.MemoryAllocator\"/>.\n@@ -20,6 +23,10 @@ public abstract class MemoryAllocator\n     /// </summary>\n     public static MemoryAllocator Default { get; } = Create();\n \n+    internal long MemoryGroupAllocationLimitBytes { get; private set; } = Environment.Is64BitProcess ? 4L * OneGigabyte : OneGigabyte;\n+\n+    internal int SingleBufferAllocationLimitBytes { get; private set; } = OneGigabyte;\n+\n     /// <summary>\n     /// Gets the length of the largest contiguous buffer that can be handled by this allocator instance in bytes.\n     /// </summary>\n@@ -30,16 +37,24 @@ public abstract class MemoryAllocator\n     /// Creates a default instance of a <see cref=\"MemoryAllocator\"/> optimized for the executing platform.\n     /// </summary>\n     /// <returns>The <see cref=\"MemoryAllocator\"/>.</returns>\n-    public static MemoryAllocator Create() =>\n-        new UniformUnmanagedMemoryPoolMemoryAllocator(null);\n+    public static MemoryAllocator Create() => Create(default);\n \n     /// <summary>\n     /// Creates the default <see cref=\"MemoryAllocator\"/> using the provided options.\n     /// </summary>\n     /// <param name=\"options\">The <see cref=\"MemoryAllocatorOptions\"/>.</param>\n     /// <returns>The <see cref=\"MemoryAllocator\"/>.</returns>\n-    public static MemoryAllocator Create(MemoryAllocatorOptions options) =>\n-        new UniformUnmanagedMemoryPoolMemoryAllocator(options.MaximumPoolSizeMegabytes);\n+    public static MemoryAllocator Create(MemoryAllocatorOptions options)\n+    {\n+        UniformUnmanagedMemoryPoolMemoryAllocator allocator = new(options.MaximumPoolSizeMegabytes);\n+        if (options.AllocationLimitMegabytes.HasValue)\n+        {\n+            allocator.MemoryGroupAllocationLimitBytes = options.AllocationLimitMegabytes.Value * 1024 * 1024;\n+            allocator.SingleBufferAllocationLimitBytes = (int)Math.Min(allocator.SingleBufferAllocationLimitBytes, allocator.MemoryGroupAllocationLimitBytes);\n+        }\n+\n+        return allocator;\n+    }\n \n     /// <summary>\n     /// Allocates an <see cref=\"IMemoryOwner{T}\" />, holding a <see cref=\"Memory{T}\"/> of length <paramref name=\"length\"/>.\n@@ -64,15 +79,34 @@ public virtual void ReleaseRetainedResources()\n     /// <summary>\n     /// Allocates a <see cref=\"MemoryGroup{T}\"/>.\n     /// </summary>\n+    /// <typeparam name=\"T\">The type of element to allocate.</typeparam>\n     /// <param name=\"totalLength\">The total length of the buffer.</param>\n     /// <param name=\"bufferAlignment\">The expected alignment (eg. to make sure image rows fit into single buffers).</param>\n     /// <param name=\"options\">The <see cref=\"AllocationOptions\"/>.</param>\n     /// <returns>A new <see cref=\"MemoryGroup{T}\"/>.</returns>\n     /// <exception cref=\"InvalidMemoryOperationException\">Thrown when 'blockAlignment' converted to bytes is greater than the buffer capacity of the allocator.</exception>\n-    internal virtual MemoryGroup<T> AllocateGroup<T>(\n+    internal MemoryGroup<T> AllocateGroup<T>(\n         long totalLength,\n         int bufferAlignment,\n         AllocationOptions options = AllocationOptions.None)\n         where T : struct\n-        => MemoryGroup<T>.Allocate(this, totalLength, bufferAlignment, options);\n+    {\n+        if (totalLength < 0)\n+        {\n+            InvalidMemoryOperationException.ThrowNegativeAllocationException(totalLength);\n+        }\n+\n+        ulong totalLengthInBytes = (ulong)totalLength * (ulong)Unsafe.SizeOf<T>();\n+        if (totalLengthInBytes > (ulong)this.MemoryGroupAllocationLimitBytes)\n+        {\n+            InvalidMemoryOperationException.ThrowAllocationOverLimitException(totalLengthInBytes, this.MemoryGroupAllocationLimitBytes);\n+        }\n+\n+        // Cast to long is safe because we already checked that the total length is within the limit.\n+        return this.AllocateGroupCore<T>(totalLength, (long)totalLengthInBytes, bufferAlignment, options);\n+    }\n+\n+    internal virtual MemoryGroup<T> AllocateGroupCore<T>(long totalLengthInElements, long totalLengthInBytes, int bufferAlignment, AllocationOptions options)\n+        where T : struct\n+        => MemoryGroup<T>.Allocate(this, totalLengthInElements, bufferAlignment, options);\n }"
        },
        {
          "filename": "src/ImageSharp/Memory/Allocators/MemoryAllocatorOptions.cs",
          "status": "modified",
          "additions": 20,
          "deletions": 1,
          "patch": "@@ -1,4 +1,4 @@\n-\ufeff// Copyright (c) Six Labors.\n+// Copyright (c) Six Labors.\n // Licensed under the Six Labors Split License.\n \n namespace SixLabors.ImageSharp.Memory;\n@@ -9,6 +9,7 @@ namespace SixLabors.ImageSharp.Memory;\n public struct MemoryAllocatorOptions\n {\n     private int? maximumPoolSizeMegabytes;\n+    private int? allocationLimitMegabytes;\n \n     /// <summary>\n     /// Gets or sets a value defining the maximum size of the <see cref=\"MemoryAllocator\"/>'s internal memory pool\n@@ -27,4 +28,22 @@ public int? MaximumPoolSizeMegabytes\n             this.maximumPoolSizeMegabytes = value;\n         }\n     }\n+\n+    /// <summary>\n+    /// Gets or sets a value defining the maximum (discontiguous) buffer size that can be allocated by the allocator in Megabytes.\n+    /// <see langword=\"null\"/> means platform default: 1GB on 32-bit processes, 4GB on 64-bit processes.\n+    /// </summary>\n+    public int? AllocationLimitMegabytes\n+    {\n+        get => this.allocationLimitMegabytes;\n+        set\n+        {\n+            if (value.HasValue)\n+            {\n+                Guard.MustBeGreaterThan(value.Value, 0, nameof(this.AllocationLimitMegabytes));\n+            }\n+\n+            this.allocationLimitMegabytes = value;\n+        }\n+    }\n }"
        },
        {
          "filename": "src/ImageSharp/Memory/Allocators/SimpleGcMemoryAllocator.cs",
          "status": "modified",
          "additions": 12,
          "deletions": 2,
          "patch": "@@ -1,7 +1,8 @@\n-\ufeff// Copyright (c) Six Labors.\n+// Copyright (c) Six Labors.\n // Licensed under the Six Labors Split License.\n \n using System.Buffers;\n+using System.Runtime.CompilerServices;\n using SixLabors.ImageSharp.Memory.Internals;\n \n namespace SixLabors.ImageSharp.Memory;\n@@ -17,7 +18,16 @@ public sealed class SimpleGcMemoryAllocator : MemoryAllocator\n     /// <inheritdoc />\n     public override IMemoryOwner<T> Allocate<T>(int length, AllocationOptions options = AllocationOptions.None)\n     {\n-        Guard.MustBeGreaterThanOrEqualTo(length, 0, nameof(length));\n+        if (length < 0)\n+        {\n+            InvalidMemoryOperationException.ThrowNegativeAllocationException(length);\n+        }\n+\n+        ulong lengthInBytes = (ulong)length * (ulong)Unsafe.SizeOf<T>();\n+        if (lengthInBytes > (ulong)this.SingleBufferAllocationLimitBytes)\n+        {\n+            InvalidMemoryOperationException.ThrowAllocationOverLimitException(lengthInBytes, this.SingleBufferAllocationLimitBytes);\n+        }\n \n         return new BasicArrayBuffer<T>(new T[length]);\n     }"
        },
        {
          "filename": "src/ImageSharp/Memory/Allocators/UniformUnmanagedMemoryPoolMemoryAllocator.cs",
          "status": "modified",
          "additions": 19,
          "deletions": 16,
          "patch": "@@ -83,10 +83,18 @@ public override IMemoryOwner<T> Allocate<T>(\n         int length,\n         AllocationOptions options = AllocationOptions.None)\n     {\n-        Guard.MustBeGreaterThanOrEqualTo(length, 0, nameof(length));\n-        int lengthInBytes = length * Unsafe.SizeOf<T>();\n+        if (length < 0)\n+        {\n+            InvalidMemoryOperationException.ThrowNegativeAllocationException(length);\n+        }\n+\n+        ulong lengthInBytes = (ulong)length * (ulong)Unsafe.SizeOf<T>();\n+        if (lengthInBytes > (ulong)this.SingleBufferAllocationLimitBytes)\n+        {\n+            InvalidMemoryOperationException.ThrowAllocationOverLimitException(lengthInBytes, this.SingleBufferAllocationLimitBytes);\n+        }\n \n-        if (lengthInBytes <= this.sharedArrayPoolThresholdInBytes)\n+        if (lengthInBytes <= (ulong)this.sharedArrayPoolThresholdInBytes)\n         {\n             var buffer = new SharedArrayPoolBuffer<T>(length);\n             if (options.Has(AllocationOptions.Clean))\n@@ -97,7 +105,7 @@ public override IMemoryOwner<T> Allocate<T>(\n             return buffer;\n         }\n \n-        if (lengthInBytes <= this.poolBufferSizeInBytes)\n+        if (lengthInBytes <= (ulong)this.poolBufferSizeInBytes)\n         {\n             UnmanagedMemoryHandle mem = this.pool.Rent();\n             if (mem.IsValid)\n@@ -111,20 +119,15 @@ public override IMemoryOwner<T> Allocate<T>(\n     }\n \n     /// <inheritdoc />\n-    internal override MemoryGroup<T> AllocateGroup<T>(\n-        long totalLength,\n+    internal override MemoryGroup<T> AllocateGroupCore<T>(\n+        long totalLengthInElements,\n+        long totalLengthInBytes,\n         int bufferAlignment,\n         AllocationOptions options = AllocationOptions.None)\n     {\n-        long totalLengthInBytes = totalLength * Unsafe.SizeOf<T>();\n-        if (totalLengthInBytes < 0)\n-        {\n-            throw new InvalidMemoryOperationException(\"Attempted to allocate a MemoryGroup of a size that is not representable.\");\n-        }\n-\n         if (totalLengthInBytes <= this.sharedArrayPoolThresholdInBytes)\n         {\n-            var buffer = new SharedArrayPoolBuffer<T>((int)totalLength);\n+            var buffer = new SharedArrayPoolBuffer<T>((int)totalLengthInElements);\n             return MemoryGroup<T>.CreateContiguous(buffer, options.Has(AllocationOptions.Clean));\n         }\n \n@@ -134,18 +137,18 @@ internal override MemoryGroup<T> AllocateGroup<T>(\n             UnmanagedMemoryHandle mem = this.pool.Rent();\n             if (mem.IsValid)\n             {\n-                UnmanagedBuffer<T> buffer = this.pool.CreateGuardedBuffer<T>(mem, (int)totalLength, options.Has(AllocationOptions.Clean));\n+                UnmanagedBuffer<T> buffer = this.pool.CreateGuardedBuffer<T>(mem, (int)totalLengthInElements, options.Has(AllocationOptions.Clean));\n                 return MemoryGroup<T>.CreateContiguous(buffer, options.Has(AllocationOptions.Clean));\n             }\n         }\n \n         // Attempt to rent the whole group from the pool, allocate a group of unmanaged buffers if the attempt fails:\n-        if (MemoryGroup<T>.TryAllocate(this.pool, totalLength, bufferAlignment, options, out MemoryGroup<T>? poolGroup))\n+        if (MemoryGroup<T>.TryAllocate(this.pool, totalLengthInElements, bufferAlignment, options, out MemoryGroup<T>? poolGroup))\n         {\n             return poolGroup;\n         }\n \n-        return MemoryGroup<T>.Allocate(this.nonPoolAllocator, totalLength, bufferAlignment, options);\n+        return MemoryGroup<T>.Allocate(this.nonPoolAllocator, totalLengthInElements, bufferAlignment, options);\n     }\n \n     public override void ReleaseRetainedResources() => this.pool.Release();"
        },
        {
          "filename": "src/ImageSharp/Memory/DiscontiguousBuffers/MemoryGroup{T}.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 6,
          "patch": "@@ -83,15 +83,16 @@ public static MemoryGroup<T> Allocate(\n     {\n         int bufferCapacityInBytes = allocator.GetBufferCapacityInBytes();\n         Guard.NotNull(allocator, nameof(allocator));\n-        Guard.MustBeGreaterThanOrEqualTo(totalLengthInElements, 0, nameof(totalLengthInElements));\n-        Guard.MustBeGreaterThanOrEqualTo(bufferAlignmentInElements, 0, nameof(bufferAlignmentInElements));\n \n-        int blockCapacityInElements = bufferCapacityInBytes / ElementSize;\n+        if (totalLengthInElements < 0)\n+        {\n+            InvalidMemoryOperationException.ThrowNegativeAllocationException(totalLengthInElements);\n+        }\n \n-        if (bufferAlignmentInElements > blockCapacityInElements)\n+        int blockCapacityInElements = bufferCapacityInBytes / ElementSize;\n+        if (bufferAlignmentInElements < 0 || bufferAlignmentInElements > blockCapacityInElements)\n         {\n-            throw new InvalidMemoryOperationException(\n-                $\"The buffer capacity of the provided MemoryAllocator is insufficient for the requested buffer alignment: {bufferAlignmentInElements}.\");\n+            InvalidMemoryOperationException.ThrowInvalidAlignmentException(bufferAlignmentInElements);\n         }\n \n         if (totalLengthInElements == 0)"
        },
        {
          "filename": "src/ImageSharp/Memory/InvalidMemoryOperationException.cs",
          "status": "modified",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -1,6 +1,8 @@\n // Copyright (c) Six Labors.\n // Licensed under the Six Labors Split License.\n \n+using System.Diagnostics.CodeAnalysis;\n+\n namespace SixLabors.ImageSharp.Memory;\n \n /// <summary>\n@@ -24,4 +26,17 @@ public InvalidMemoryOperationException(string message)\n     public InvalidMemoryOperationException()\n     {\n     }\n+\n+    [DoesNotReturn]\n+    internal static void ThrowNegativeAllocationException(long length) =>\n+        throw new InvalidMemoryOperationException($\"Attempted to allocate a buffer of negative length={length}.\");\n+\n+    [DoesNotReturn]\n+    internal static void ThrowInvalidAlignmentException(long alignment) =>\n+        throw new InvalidMemoryOperationException(\n+                $\"The buffer capacity of the provided MemoryAllocator is insufficient for the requested buffer alignment: {alignment}.\");\n+\n+    [DoesNotReturn]\n+    internal static void ThrowAllocationOverLimitException(ulong length, long limit) =>\n+            throw new InvalidMemoryOperationException($\"Attempted to allocate a buffer of length={length} that exceeded the limit {limit}.\");\n }"
        },
        {
          "filename": "tests/ImageSharp.Tests/Formats/Bmp/BmpDecoderTests.cs",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -558,4 +558,16 @@ public void BmpDecoder_CanDecode_Os2BitmapArray<TPixel>(TestImageProvider<TPixel\n         // Compare to reference output instead.\n         image.CompareToReferenceOutput(provider, extension: \"png\");\n     }\n+\n+    [Theory]\n+    [WithFile(Issue2696, PixelTypes.Rgba32)]\n+    public void BmpDecoder_ThrowsException_Issue2696<TPixel>(TestImageProvider<TPixel> provider)\n+        where TPixel : unmanaged, IPixel<TPixel>\n+    {\n+        InvalidImageContentException ex = Assert.Throws<InvalidImageContentException>(() =>\n+            {\n+                using Image<TPixel> image = provider.GetImage(BmpDecoder.Instance);\n+            });\n+        Assert.IsType<InvalidMemoryOperationException>(ex.InnerException);\n+    }\n }"
        },
        {
          "filename": "tests/ImageSharp.Tests/Formats/Jpg/JpegDecoderTests.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 14,
          "patch": "@@ -338,21 +338,11 @@ public void Issue2564_DecodeWorks<TPixel>(TestImageProvider<TPixel> provider)\n     }\n \n     [Theory]\n-    [WithFile(TestImages.Jpeg.Issues.HangBadScan, PixelTypes.L8)]\n-    public void DecodeHang<TPixel>(TestImageProvider<TPixel> provider)\n+    [WithFile(TestImages.Jpeg.Issues.HangBadScan, PixelTypes.Rgb24)]\n+    public void DecodeHang_ThrowsException<TPixel>(TestImageProvider<TPixel> provider)\n         where TPixel : unmanaged, IPixel<TPixel>\n-    {\n-        if (TestEnvironment.IsWindows &&\n-            TestEnvironment.RunsOnCI)\n-        {\n-            // Windows CI runs consistently fail with OOM.\n-            return;\n-        }\n-\n-        using Image<TPixel> image = provider.GetImage(JpegDecoder.Instance);\n-        Assert.Equal(65503, image.Width);\n-        Assert.Equal(65503, image.Height);\n-    }\n+        => Assert.Throws<InvalidImageContentException>(\n+            () => { using Image<TPixel> image = provider.GetImage(JpegDecoder.Instance); });\n \n     // https://github.com/SixLabors/ImageSharp/issues/2517\n     [Theory]"
        },
        {
          "filename": "tests/ImageSharp.Tests/Memory/Allocators/SimpleGcMemoryAllocatorTests.cs",
          "status": "modified",
          "additions": 10,
          "deletions": 6,
          "patch": "@@ -19,13 +19,17 @@ public BufferTests()\n \n     protected SimpleGcMemoryAllocator MemoryAllocator { get; } = new SimpleGcMemoryAllocator();\n \n-    [Theory]\n-    [InlineData(-1)]\n-    public void Allocate_IncorrectAmount_ThrowsCorrect_ArgumentOutOfRangeException(int length)\n+    public static TheoryData<int> InvalidLengths { get; set; } = new()\n     {\n-        ArgumentOutOfRangeException ex = Assert.Throws<ArgumentOutOfRangeException>(() => this.MemoryAllocator.Allocate<BigStruct>(length));\n-        Assert.Equal(\"length\", ex.ParamName);\n-    }\n+        { -1 },\n+        { (1 << 30) + 1 }\n+    };\n+\n+    [Theory]\n+    [MemberData(nameof(InvalidLengths))]\n+    public void Allocate_IncorrectAmount_ThrowsCorrect_InvalidMemoryOperationException(int length)\n+        => Assert.Throws<InvalidMemoryOperationException>(\n+            () => this.MemoryAllocator.Allocate<BigStruct>(length));\n \n     [Fact]\n     public unsafe void Allocate_MemoryIsPinnableMultipleTimes()"
        },
        {
          "filename": "tests/ImageSharp.Tests/Memory/Allocators/UniformUnmanagedPoolMemoryAllocatorTests.cs",
          "status": "modified",
          "additions": 36,
          "deletions": 1,
          "patch": "@@ -111,9 +111,20 @@ public void AllocateGroup_MultipleTimes_ExceedPoolLimit()\n     public void AllocateGroup_SizeInBytesOverLongMaxValue_ThrowsInvalidMemoryOperationException()\n     {\n         var allocator = new UniformUnmanagedMemoryPoolMemoryAllocator(null);\n-        Assert.Throws<InvalidMemoryOperationException>(() => allocator.AllocateGroup<S4>(int.MaxValue * (long)int.MaxValue, int.MaxValue));\n+        Assert.Throws<InvalidMemoryOperationException>(() => allocator.AllocateGroup<byte>(int.MaxValue * (long)int.MaxValue, int.MaxValue));\n     }\n \n+    public static TheoryData<int> InvalidLengths { get; set; } = new()\n+    {\n+        { -1 },\n+        { (1 << 30) + 1 }\n+    };\n+\n+    [Theory]\n+    [MemberData(nameof(InvalidLengths))]\n+    public void Allocate_IncorrectAmount_ThrowsCorrect_InvalidMemoryOperationException(int length)\n+        => Assert.Throws<InvalidMemoryOperationException>(() => new UniformUnmanagedMemoryPoolMemoryAllocator(null).Allocate<S512>(length));\n+\n     [Fact]\n     public unsafe void Allocate_MemoryIsPinnableMultipleTimes()\n     {\n@@ -407,4 +418,28 @@ static void RunTest()\n             _ = MemoryAllocator.Create();\n         }\n     }\n+\n+    [Fact]\n+    public void Allocate_OverLimit_ThrowsInvalidMemoryOperationException()\n+    {\n+        MemoryAllocator allocator = MemoryAllocator.Create(new MemoryAllocatorOptions()\n+        {\n+            AllocationLimitMegabytes = 4\n+        });\n+        const int oneMb = 1 << 20;\n+        allocator.Allocate<byte>(4 * oneMb).Dispose(); // Should work\n+        Assert.Throws<InvalidMemoryOperationException>(() => allocator.Allocate<byte>(5 * oneMb));\n+    }\n+\n+    [Fact]\n+    public void AllocateGroup_OverLimit_ThrowsInvalidMemoryOperationException()\n+    {\n+        MemoryAllocator allocator = MemoryAllocator.Create(new MemoryAllocatorOptions()\n+        {\n+            AllocationLimitMegabytes = 4\n+        });\n+        const int oneMb = 1 << 20;\n+        allocator.AllocateGroup<byte>(4 * oneMb, 1024).Dispose(); // Should work\n+        Assert.Throws<InvalidMemoryOperationException>(() => allocator.AllocateGroup<byte>(5 * oneMb, 1024));\n+    }\n }"
        },
        {
          "filename": "tests/ImageSharp.Tests/Memory/Buffer2DTests.cs",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -4,6 +4,7 @@\n using System.Runtime.CompilerServices;\n using System.Runtime.InteropServices;\n using SixLabors.ImageSharp.Memory;\n+using SixLabors.ImageSharp.PixelFormats;\n \n // ReSharper disable InconsistentNaming\n namespace SixLabors.ImageSharp.Tests.Memory;\n@@ -337,4 +338,26 @@ public void PublicMemoryGroup_IsMemoryGroupView()\n         Assert.False(mgBefore.IsValid);\n         Assert.NotSame(mgBefore, buffer1.MemoryGroup);\n     }\n+\n+    public static TheoryData<Size> InvalidLengths { get; set; } = new()\n+    {\n+        { new(-1, -1) },\n+        { new(32768, 32769) },\n+        { new(32769, 32768) }\n+    };\n+\n+    [Theory]\n+    [MemberData(nameof(InvalidLengths))]\n+    public void Allocate_IncorrectAmount_ThrowsCorrect_InvalidMemoryOperationException(Size size)\n+        => Assert.Throws<InvalidMemoryOperationException>(() => this.MemoryAllocator.Allocate2D<Rgba32>(size.Width, size.Height));\n+\n+    [Theory]\n+    [MemberData(nameof(InvalidLengths))]\n+    public void Allocate_IncorrectAmount_ThrowsCorrect_InvalidMemoryOperationException_Size(Size size)\n+        => Assert.Throws<InvalidMemoryOperationException>(() => this.MemoryAllocator.Allocate2D<Rgba32>(new Size(size)));\n+\n+    [Theory]\n+    [MemberData(nameof(InvalidLengths))]\n+    public void Allocate_IncorrectAmount_ThrowsCorrect_InvalidMemoryOperationException_OverAligned(Size size)\n+        => Assert.Throws<InvalidMemoryOperationException>(() => this.MemoryAllocator.Allocate2DOveraligned<Rgba32>(size.Width, size.Height, 1));\n }"
        },
        {
          "filename": "tests/ImageSharp.Tests/Memory/DiscontiguousBuffers/MemoryGroupTests.Allocate.cs",
          "status": "modified",
          "additions": 9,
          "deletions": 3,
          "patch": "@@ -1,4 +1,4 @@\n-\ufeff// Copyright (c) Six Labors.\n+// Copyright (c) Six Labors.\n // Licensed under the Six Labors Split License.\n \n using System.Runtime.CompilerServices;\n@@ -219,11 +219,17 @@ public void MemoryAllocatorIsUtilizedCorrectly(AllocationOptions allocationOptio\n [StructLayout(LayoutKind.Sequential, Size = 5)]\n internal struct S5\n {\n-    public override string ToString() => \"S5\";\n+    public override readonly string ToString() => nameof(S5);\n }\n \n [StructLayout(LayoutKind.Sequential, Size = 4)]\n internal struct S4\n {\n-    public override string ToString() => \"S4\";\n+    public override readonly string ToString() => nameof(S4);\n+}\n+\n+[StructLayout(LayoutKind.Explicit, Size = 512)]\n+internal struct S512\n+{\n+    public override readonly string ToString() => nameof(S512);\n }"
        },
        {
          "filename": "tests/ImageSharp.Tests/TestImages.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -443,6 +443,8 @@ public static class Bmp\n         public const string Rgba321010102 = \"Bmp/rgba32-1010102.bmp\";\n         public const string RgbaAlphaBitfields = \"Bmp/rgba32abf.bmp\";\n \n+        public const string Issue2696 = \"Bmp/issue-2696.bmp\";\n+\n         public const string BlackWhitePalletDataMatrix = \"Bmp/bit1datamatrix.bmp\";\n \n         public static readonly string[] BitFields ="
        },
        {
          "filename": "tests/Images/Input/Bmp/issue-2696.bmp",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:bc42cda9bac8fc73351ad03bf55214069bb8d31ea5bdd806321a8cc8b56c282e\n+size 126"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 8,
        "unique_directories": 12,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e08651bbf6a8108865b1b2605751faa5cfc44a06",
            "date": "2024-12-18T01:48:59Z",
            "author_login": "JimBobSquarePants"
          },
          {
            "sha": "b38146dfaa2d25ea7fa85847a4012c88caa902f9",
            "date": "2024-12-17T00:37:18Z",
            "author_login": "antonfirsov"
          },
          {
            "sha": "dee312df7e491a5d1448d97cddb06a32aab1ffde",
            "date": "2024-12-16T22:48:24Z",
            "author_login": "antonfirsov"
          },
          {
            "sha": "4be26452b9366b0a4fe67aab91cfcb360916c5ea",
            "date": "2024-12-11T02:34:20Z",
            "author_login": "JimBobSquarePants"
          },
          {
            "sha": "502a35426225e22ebff965ffaa2be31ecc286880",
            "date": "2024-11-27T12:21:39Z",
            "author_login": "JimBobSquarePants"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-789",
    "description": "ImageSharp is a 2D graphics API. A vulnerability discovered in the ImageSharp library, where the processing of specially crafted files can lead to excessive memory usage in image decoders. The vulnerability is triggered when ImageSharp attempts to process image files that are designed to exploit this flaw.  This flaw can be exploited to cause a denial of service (DoS) by depleting process memory, thereby affecting applications and services that rely on ImageSharp for image processing tasks. Users and administrators are advised to update to the latest version of ImageSharp that addresses this vulnerability to mitigate the risk of exploitation. The problem has been patched in v3.1.4 and v2.1.8.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-15T20:15:11.323",
    "last_modified": "2025-01-09T18:35:14.097",
    "fix_date": "2024-04-10T22:16:16Z"
  },
  "references": [
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp.web/processingcommands.html#securing-processing-commands",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp/security.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/f21d64188e59ae9464ff462056a5e29d8e618b27",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/security/advisories/GHSA-g85r-6x2q-45w7",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp.web/processingcommands.html#securing-processing-commands",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp/security.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/b6b08ac3e7cea8da5ac1e90f7c0b67dd254535c3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/f21d64188e59ae9464ff462056a5e29d8e618b27",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/security/advisories/GHSA-g85r-6x2q-45w7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:04.488819",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ImageSharp",
    "owner": "SixLabors",
    "created_at": "2016-10-28T04:46:36Z",
    "updated_at": "2025-01-14T14:21:12Z",
    "pushed_at": "2025-01-06T10:46:24Z",
    "size": 132452,
    "stars": 7554,
    "forks": 853,
    "open_issues": 45,
    "watchers": 7554,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "C#": 10815585,
      "JavaScript": 40805,
      "HTML": 5210,
      "PowerShell": 5178,
      "Batchfile": 121
    },
    "commit_activity": {
      "total_commits_last_year": 390,
      "avg_commits_per_week": 7.5,
      "days_active_last_year": 121
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:51:16.290801"
  }
}