{
  "cve_id": "CVE-2024-32473",
  "github_data": {
    "repository": "moby/moby",
    "fix_commit": "7cef0d9cd1cf221d8c0b7b7aeda69552649e0642",
    "related_commits": [
      "7cef0d9cd1cf221d8c0b7b7aeda69552649e0642",
      "7cef0d9cd1cf221d8c0b7b7aeda69552649e0642"
    ],
    "patch_url": "https://github.com/moby/moby/commit/7cef0d9cd1cf221d8c0b7b7aeda69552649e0642.patch",
    "fix_commit_details": {
      "sha": "7cef0d9cd1cf221d8c0b7b7aeda69552649e0642",
      "commit_date": "2024-04-18T15:50:34Z",
      "author": {
        "login": "thaJeztah",
        "type": "User",
        "stats": {
          "total_commits": 9521,
          "average_weekly_commits": 15.185007974481659,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 506
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-x84c-p2g9-rqv9",
        "length": 115,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 115,
        "additions": 105,
        "deletions": 10
      },
      "files": [
        {
          "filename": "integration/network/ipvlan/ipvlan_test.go",
          "status": "modified",
          "additions": 25,
          "deletions": 1,
          "patch": "@@ -94,6 +94,9 @@ func TestDockerNetworkIpvlan(t *testing.T) {\n \t\t}, {\n \t\t\tname: \"L3Addressing\",\n \t\t\ttest: testIpvlanL3Addressing,\n+\t\t}, {\n+\t\t\tname: \"NoIPv6\",\n+\t\t\ttest: testIpvlanNoIPv6,\n \t\t},\n \t} {\n \n@@ -441,6 +444,28 @@ func testIpvlanL3Addressing(t *testing.T, ctx context.Context, client dclient.AP\n \tassert.Check(t, is.Contains(result.Combined(), \"default dev eth0\"))\n }\n \n+// Check that an ipvlan interface with '--ipv6=false' doesn't get kernel-assigned\n+// IPv6 addresses, but the loopback interface does still have an IPv6 address ('::1').\n+func testIpvlanNoIPv6(t *testing.T, ctx context.Context, client dclient.APIClient) {\n+\tconst netName = \"ipvlannet\"\n+\tnet.CreateNoError(ctx, t, client, netName, net.WithIPvlan(\"\", \"l3\"))\n+\tassert.Check(t, n.IsNetworkAvailable(ctx, client, netName))\n+\n+\tid := container.Run(ctx, t, client, container.WithNetworkMode(netName))\n+\n+\tloRes := container.ExecT(ctx, t, client, id, []string{\"ip\", \"a\", \"show\", \"dev\", \"lo\"})\n+\tassert.Check(t, is.Contains(loRes.Combined(), \" inet \"))\n+\tassert.Check(t, is.Contains(loRes.Combined(), \" inet6 \"))\n+\n+\teth0Res := container.ExecT(ctx, t, client, id, []string{\"ip\", \"a\", \"show\", \"dev\", \"eth0\"})\n+\tassert.Check(t, is.Contains(eth0Res.Combined(), \" inet \"))\n+\tassert.Check(t, !strings.Contains(eth0Res.Combined(), \" inet6 \"),\n+\t\t\"result.Combined(): %s\", eth0Res.Combined())\n+\n+\tsysctlRes := container.ExecT(ctx, t, client, id, []string{\"sysctl\", \"-n\", \"net.ipv6.conf.eth0.disable_ipv6\"})\n+\tassert.Check(t, is.Equal(strings.TrimSpace(sysctlRes.Combined()), \"1\"))\n+}\n+\n // TestIPVlanDNS checks whether DNS is forwarded, for combinations of l2/l3 mode,\n // with/without a parent interface, and with '--internal'. Note that, there's no\n // attempt here to give the ipvlan network external connectivity - when this test\n@@ -452,7 +477,6 @@ func testIpvlanL3Addressing(t *testing.T, ctx context.Context, client dclient.AP\n // https://github.com/moby/moby/issues/47662\n func TestIPVlanDNS(t *testing.T) {\n \tskip.If(t, testEnv.IsRootless, \"rootless mode has different view of network\")\n-\n \tctx := testutil.StartSpan(baseContext, t)\n \n \tnet.StartDaftDNS(t, \"127.0.0.1\")"
        },
        {
          "filename": "integration/network/macvlan/macvlan_test.go",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -77,6 +77,9 @@ func TestDockerNetworkMacvlan(t *testing.T) {\n \t\t}, {\n \t\t\tname: \"Addressing\",\n \t\t\ttest: testMacvlanAddressing,\n+\t\t}, {\n+\t\t\tname: \"NoIPv6\",\n+\t\t\ttest: testMacvlanNoIPv6,\n \t\t},\n \t} {\n \t\ttc := tc\n@@ -298,6 +301,32 @@ func testMacvlanAddressing(t *testing.T, ctx context.Context, client client.APIC\n \tassert.Check(t, strings.Contains(result.Combined(), \"default via 2001:db8:abca::254 dev eth0\"))\n }\n \n+// Check that a macvlan interface with '--ipv6=false' doesn't get kernel-assigned\n+// IPv6 addresses, but the loopback interface does still have an IPv6 address ('::1').\n+func testMacvlanNoIPv6(t *testing.T, ctx context.Context, client client.APIClient) {\n+\tconst netName = \"macvlannet\"\n+\n+\tnet.CreateNoError(ctx, t, client, netName,\n+\t\tnet.WithMacvlan(\"\"),\n+\t\tnet.WithOption(\"macvlan_mode\", \"bridge\"),\n+\t)\n+\tassert.Check(t, n.IsNetworkAvailable(ctx, client, netName))\n+\n+\tid := container.Run(ctx, t, client, container.WithNetworkMode(netName))\n+\n+\tloRes := container.ExecT(ctx, t, client, id, []string{\"ip\", \"a\", \"show\", \"dev\", \"lo\"})\n+\tassert.Check(t, is.Contains(loRes.Combined(), \" inet \"))\n+\tassert.Check(t, is.Contains(loRes.Combined(), \" inet6 \"))\n+\n+\teth0Res := container.ExecT(ctx, t, client, id, []string{\"ip\", \"a\", \"show\", \"dev\", \"eth0\"})\n+\tassert.Check(t, is.Contains(eth0Res.Combined(), \" inet \"))\n+\tassert.Check(t, !strings.Contains(eth0Res.Combined(), \" inet6 \"),\n+\t\t\"result.Combined(): %s\", eth0Res.Combined())\n+\n+\tsysctlRes := container.ExecT(ctx, t, client, id, []string{\"sysctl\", \"-n\", \"net.ipv6.conf.eth0.disable_ipv6\"})\n+\tassert.Check(t, is.Equal(strings.TrimSpace(sysctlRes.Combined()), \"1\"))\n+}\n+\n // TestMACVlanDNS checks whether DNS is forwarded, with/without a parent\n // interface, and with '--internal'. Note that there's no attempt here to give\n // the macvlan network external connectivity - when this test supplies a parent"
        },
        {
          "filename": "integration/networking/bridge_test.go",
          "status": "modified",
          "additions": 37,
          "deletions": 2,
          "patch": "@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"fmt\"\n \t\"regexp\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n@@ -611,8 +612,8 @@ func TestInternalNwConnectivity(t *testing.T) {\n \tassert.Check(t, is.Contains(res.Stderr(), \"Network is unreachable\"))\n }\n \n-// Check that the container's interface has no IPv6 address when IPv6 is\n-// disabled in a container via sysctl.\n+// Check that the container's interfaces have no IPv6 address when IPv6 is\n+// disabled in a container via sysctl (including 'lo').\n func TestDisableIPv6Addrs(t *testing.T) {\n \tskip.If(t, testEnv.DaemonInfo.OSType == \"windows\")\n \n@@ -676,6 +677,40 @@ func TestDisableIPv6Addrs(t *testing.T) {\n \t}\n }\n \n+// Check that an interface to an '--ipv6=false' network has no IPv6\n+// address - either IPAM assigned, or kernel-assigned LL, but the loopback\n+// interface does still have an IPv6 address ('::1').\n+func TestNonIPv6Network(t *testing.T) {\n+\tskip.If(t, testEnv.DaemonInfo.OSType == \"windows\")\n+\n+\tctx := setupTest(t)\n+\td := daemon.New(t)\n+\td.StartWithBusybox(ctx, t)\n+\tdefer d.Stop(t)\n+\n+\tc := d.NewClientT(t)\n+\tdefer c.Close()\n+\n+\tconst netName = \"testnet\"\n+\tnetwork.CreateNoError(ctx, t, c, netName)\n+\tdefer network.RemoveNoError(ctx, t, c, netName)\n+\n+\tid := container.Run(ctx, t, c, container.WithNetworkMode(netName))\n+\tdefer c.ContainerRemove(ctx, id, containertypes.RemoveOptions{Force: true})\n+\n+\tloRes := container.ExecT(ctx, t, c, id, []string{\"ip\", \"a\", \"show\", \"dev\", \"lo\"})\n+\tassert.Check(t, is.Contains(loRes.Combined(), \" inet \"))\n+\tassert.Check(t, is.Contains(loRes.Combined(), \" inet6 \"))\n+\n+\teth0Res := container.ExecT(ctx, t, c, id, []string{\"ip\", \"a\", \"show\", \"dev\", \"eth0\"})\n+\tassert.Check(t, is.Contains(eth0Res.Combined(), \" inet \"))\n+\tassert.Check(t, !strings.Contains(eth0Res.Combined(), \" inet6 \"),\n+\t\t\"result.Combined(): %s\", eth0Res.Combined())\n+\n+\tsysctlRes := container.ExecT(ctx, t, c, id, []string{\"sysctl\", \"-n\", \"net.ipv6.conf.eth0.disable_ipv6\"})\n+\tassert.Check(t, is.Equal(strings.TrimSpace(sysctlRes.Combined()), \"1\"))\n+}\n+\n // Test that it's possible to set a sysctl on an interface in the container.\n // Regression test for https://github.com/moby/moby/issues/47619\n func TestSetInterfaceSysctl(t *testing.T) {"
        },
        {
          "filename": "libnetwork/osl/interface_linux.go",
          "status": "modified",
          "additions": 14,
          "deletions": 7,
          "patch": "@@ -363,17 +363,24 @@ func setInterfaceIP(nlh *netlink.Handle, iface netlink.Link, i *Interface) error\n }\n \n func setInterfaceIPv6(nlh *netlink.Handle, iface netlink.Link, i *Interface) error {\n-\tif i.AddressIPv6() == nil {\n+\taddr := i.AddressIPv6()\n+\t// IPv6 must be enabled on the interface if and only if the network is\n+\t// IPv6-enabled. For an interface on an IPv4-only network, if IPv6 isn't\n+\t// disabled, the interface will be put into IPv6 multicast groups making\n+\t// it unexpectedly susceptible to NDP cache poisoning, route injection, etc.\n+\t// (At present, there will always be a pre-configured IPv6 address if the\n+\t// network is IPv6-enabled.)\n+\tif err := setIPv6(i.ns.path, i.DstName(), addr != nil); err != nil {\n+\t\treturn fmt.Errorf(\"failed to configure ipv6: %v\", err)\n+\t}\n+\tif addr == nil {\n \t\treturn nil\n \t}\n-\tif err := checkRouteConflict(nlh, i.AddressIPv6(), netlink.FAMILY_V6); err != nil {\n+\tif err := checkRouteConflict(nlh, addr, netlink.FAMILY_V6); err != nil {\n \t\treturn err\n \t}\n-\tif err := setIPv6(i.ns.path, i.DstName(), true); err != nil {\n-\t\treturn fmt.Errorf(\"failed to enable ipv6: %v\", err)\n-\t}\n-\tipAddr := &netlink.Addr{IPNet: i.AddressIPv6(), Label: \"\", Flags: syscall.IFA_F_NODAD}\n-\treturn nlh.AddrAdd(iface, ipAddr)\n+\tnlAddr := &netlink.Addr{IPNet: addr, Label: \"\", Flags: syscall.IFA_F_NODAD}\n+\treturn nlh.AddrAdd(iface, nlAddr)\n }\n \n func setInterfaceLinkLocalIPs(nlh *netlink.Handle, iface netlink.Link, i *Interface) error {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2b7e859c49d3603ecd43fd4ccba1976a90064913",
            "date": "2025-01-14T16:30:14Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "04b03cfc0a99f50088ac9c811a9992e5b05463bc",
            "date": "2025-01-14T14:26:28Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "48e6b4e8f7329422a13074c7911f524cac45c165",
            "date": "2025-01-14T09:50:06Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "80d14859a294ed08b8cce92f5f2075e96f677f74",
            "date": "2025-01-14T13:34:18Z",
            "author_login": "thaJeztah"
          },
          {
            "sha": "5b1b62058feeef6717758a29235bca5815bb62ea",
            "date": "2025-01-14T12:58:23Z",
            "author_login": "thaJeztah"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.7,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-668",
    "description": "Moby is an open source container framework that is a key component of Docker Engine, Docker Desktop, and other distributions of container tooling or runtimes. In 26.0.0, IPv6 is not disabled on network interfaces, including those belonging to networks where `--ipv6=false`. An container with an `ipvlan` or `macvlan` interface will normally be configured to share an external network link with the host machine. Because of this direct access, (1) Containers may be able to communicate with other hosts on the local network over link-local IPv6 addresses, (2) if router advertisements are being broadcast over the local network, containers may get SLAAC-assigned addresses, and (3) the interface  will be a member of IPv6 multicast groups. This means interfaces in IPv4-only networks present an unexpectedly and unnecessarily increased attack surface. The issue is patched in 26.0.2. To completely disable IPv6 in a container, use `--sysctl=net.ipv6.conf.all.disable_ipv6=1` in the `docker create` or `docker run` command. Or, in the service configuration of a `compose` file.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-04-18T22:15:10.400",
    "last_modified": "2024-11-21T09:14:59.013",
    "fix_date": "2024-04-18T15:50:34Z"
  },
  "references": [
    {
      "url": "https://github.com/moby/moby/commit/7cef0d9cd1cf221d8c0b7b7aeda69552649e0642",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/moby/moby/security/advisories/GHSA-x84c-p2g9-rqv9",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/moby/moby/commit/7cef0d9cd1cf221d8c0b7b7aeda69552649e0642",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/moby/moby/security/advisories/GHSA-x84c-p2g9-rqv9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:06.996941",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "moby",
    "owner": "moby",
    "created_at": "2013-01-18T18:10:57Z",
    "updated_at": "2025-01-14T12:58:30Z",
    "pushed_at": "2025-01-14T12:58:23Z",
    "size": 224938,
    "stars": 68998,
    "forks": 18677,
    "open_issues": 3533,
    "watchers": 68998,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "1.12.x",
      "1.13.x",
      "17.03.x",
      "17.04.x",
      "17.05.x",
      "19.03",
      "20.10",
      "22.06",
      "23.0",
      "24.0",
      "25.0",
      "26.0",
      "26.1",
      "27.x",
      "master"
    ],
    "languages": {
      "Go": 10171312,
      "Shell": 157078,
      "Dockerfile": 56212,
      "PowerShell": 31839,
      "Makefile": 9923,
      "Python": 7179,
      "C": 4815,
      "HCL": 3897,
      "Assembly": 81
    },
    "commit_activity": {
      "total_commits_last_year": 2581,
      "avg_commits_per_week": 49.63461538461539,
      "days_active_last_year": 295
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:08:15.569963"
  }
}