{
  "cve_id": "CVE-2024-32475",
  "github_data": {
    "repository": "envoyproxy/envoy",
    "fix_commit": "b47fc6648d7c2dfe0093a601d44cb704b7bad382",
    "related_commits": [
      "b47fc6648d7c2dfe0093a601d44cb704b7bad382",
      "b47fc6648d7c2dfe0093a601d44cb704b7bad382"
    ],
    "patch_url": "https://github.com/envoyproxy/envoy/commit/b47fc6648d7c2dfe0093a601d44cb704b7bad382.patch",
    "fix_commit_details": {
      "sha": "b47fc6648d7c2dfe0093a601d44cb704b7bad382",
      "commit_date": "2024-04-18T00:33:22Z",
      "author": {
        "login": "ggreenway",
        "type": "User",
        "stats": {
          "total_commits": 232,
          "average_weekly_commits": 0.5260770975056689,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 138
        }
      },
      "commit_message": {
        "title": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)",
        "length": 441,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 130,
        "additions": 108,
        "deletions": 22
      },
      "files": [
        {
          "filename": "changelogs/current.yaml",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -13,6 +13,11 @@ minor_behavior_changes:\n \n bug_fixes:\n # *Changes expected to improve the state of the world and are unlikely to have negative effects*\n+- area: tls\n+  change: |\n+    Fix a RELEASE_ASSERT when using :ref:`auto_sni <envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.auto_sni>`\n+    if the downstream request ``:authority`` was longer than 255 characters.\n+\n \n removed_config_or_runtime:\n # *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`"
        },
        {
          "filename": "source/common/tls/context_impl.cc",
          "status": "modified",
          "additions": 13,
          "deletions": 4,
          "patch": "@@ -463,7 +463,7 @@ std::vector<uint8_t> ContextImpl::parseAlpnProtocols(const std::string& alpn_pro\n   return out;\n }\n \n-bssl::UniquePtr<SSL>\n+absl::StatusOr<bssl::UniquePtr<SSL>>\n ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n   // We use the first certificate for a new SSL object, later in the\n   // SSL_CTX_set_select_certificate_cb() callback following ClientHello, we replace with the\n@@ -701,16 +701,25 @@ bool ContextImpl::parseAndSetAlpn(const std::vector<std::string>& alpn, SSL& ssl\n   return false;\n }\n \n-bssl::UniquePtr<SSL>\n+absl::StatusOr<bssl::UniquePtr<SSL>>\n ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n-  bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));\n+  absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));\n+  if (!ssl_con_or_status.ok()) {\n+    return ssl_con_or_status;\n+  }\n+\n+  bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());\n \n   const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                  ? options->serverNameOverride().value()\n                                                  : server_name_indication_;\n   if (!server_name_indication.empty()) {\n     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n-    RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));\n+    if (rc != 1) {\n+      return absl::InvalidArgumentError(\n+          absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",\n+                       Utility::getLastCryptoError().value_or(\"unknown\")));\n+    }\n   }\n \n   if (options && !options->verifySubjectAltNameListOverride().empty()) {"
        },
        {
          "filename": "source/common/tls/context_impl.h",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -78,7 +78,8 @@ namespace Tls {\n class ContextImpl : public virtual Envoy::Ssl::Context,\n                     protected Logger::Loggable<Logger::Id::config> {\n public:\n-  virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);\n+  virtual absl::StatusOr<bssl::UniquePtr<SSL>>\n+  newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);\n \n   /**\n    * Logs successful TLS handshake and updates stats.\n@@ -176,7 +177,7 @@ class ClientContextImpl : public ContextImpl, public Envoy::Ssl::ClientContext {\n   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,\n                     Server::Configuration::CommonFactoryContext& factory_context);\n \n-  bssl::UniquePtr<SSL>\n+  absl::StatusOr<bssl::UniquePtr<SSL>>\n   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;\n \n private:"
        },
        {
          "filename": "source/common/tls/ssl_socket.cc",
          "status": "modified",
          "additions": 61,
          "deletions": 13,
          "patch": "@@ -26,13 +26,11 @@ namespace {\n \n constexpr absl::string_view NotReadyReason{\"TLS error: Secret is not supplied by SDS\"};\n \n-// This SslSocket will be used when SSL secret is not fetched from SDS server.\n-class NotReadySslSocket : public Network::TransportSocket {\n+class InvalidSslSocket : public Network::TransportSocket {\n public:\n   // Network::TransportSocket\n   void setTransportSocketCallbacks(Network::TransportSocketCallbacks&) override {}\n   std::string protocol() const override { return EMPTY_STRING; }\n-  absl::string_view failureReason() const override { return NotReadyReason; }\n   bool canFlushClose() override { return true; }\n   void closeSocket(Network::ConnectionEvent) override {}\n   Network::IoResult doRead(Buffer::Instance&) override { return {PostIoAction::Close, 0, false}; }\n@@ -45,21 +43,62 @@ class NotReadySslSocket : public Network::TransportSocket {\n   void configureInitialCongestionWindow(uint64_t, std::chrono::microseconds) override {}\n };\n \n+// This SslSocket will be used when SSL secret is not fetched from SDS server.\n+class NotReadySslSocket : public InvalidSslSocket {\n+public:\n+  // Network::TransportSocket\n+  absl::string_view failureReason() const override { return NotReadyReason; }\n+};\n+\n+class ErrorSslSocket : public InvalidSslSocket {\n+public:\n+  ErrorSslSocket(absl::string_view error) : error_(error) {}\n+\n+  // Network::TransportSocket\n+  absl::string_view failureReason() const override { return error_; }\n+\n+private:\n+  std::string error_;\n+};\n+\n } // namespace\n \n-SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n-                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n-                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n+absl::StatusOr<std::unique_ptr<SslSocket>>\n+SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n+                  const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n+                  Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n+  std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));\n+  auto status = socket->initialize(state, handshaker_factory_cb);\n+  if (status.ok()) {\n+    return socket;\n+  } else {\n+    return status;\n+  }\n+}\n+\n+SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,\n+                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)\n     : transport_socket_options_(transport_socket_options),\n-      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n-      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n-          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n+      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}\n+\n+absl::Status SslSocket::initialize(InitialState state,\n+                                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n+  auto status_or_ssl = ctx_->newSsl(transport_socket_options_);\n+  if (!status_or_ssl.ok()) {\n+    return status_or_ssl.status();\n+  }\n+\n+  info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n+      std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));\n+\n   if (state == InitialState::Client) {\n     SSL_set_connect_state(rawSsl());\n   } else {\n     ASSERT(state == InitialState::Server);\n     SSL_set_accept_state(rawSsl());\n   }\n+\n+  return absl::OkStatus();\n }\n \n void SslSocket::setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) {\n@@ -401,8 +440,13 @@ Network::TransportSocketPtr ClientSslSocketFactory::createTransportSocket(\n     ssl_ctx = ssl_ctx_;\n   }\n   if (ssl_ctx) {\n-    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,\n-                                       transport_socket_options, config_->createHandshaker());\n+    auto status_or_socket =\n+        SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,\n+                          config_->createHandshaker());\n+    if (status_or_socket.ok()) {\n+      return std::move(status_or_socket.value());\n+    }\n+    return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());\n   } else {\n     ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n     stats_.upstream_context_secrets_not_ready_.inc();\n@@ -450,8 +494,12 @@ Network::TransportSocketPtr ServerSslSocketFactory::createDownstreamTransportSoc\n     ssl_ctx = ssl_ctx_;\n   }\n   if (ssl_ctx) {\n-    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,\n-                                       config_->createHandshaker());\n+    auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,\n+                                              config_->createHandshaker());\n+    if (status_or_socket.ok()) {\n+      return std::move(status_or_socket.value());\n+    }\n+    return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());\n   } else {\n     ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n     stats_.downstream_context_secrets_not_ready_.inc();"
        },
        {
          "filename": "source/common/tls/ssl_socket.h",
          "status": "modified",
          "additions": 8,
          "deletions": 3,
          "patch": "@@ -48,9 +48,10 @@ class SslSocket : public Network::TransportSocket,\n                   public Ssl::HandshakeCallbacks,\n                   protected Logger::Loggable<Logger::Id::connection> {\n public:\n-  SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n-            const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n-            Ssl::HandshakerFactoryCb handshaker_factory_cb);\n+  static absl::StatusOr<std::unique_ptr<SslSocket>>\n+  create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n+         const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n+         Ssl::HandshakerFactoryCb handshaker_factory_cb);\n \n   // Network::TransportSocket\n   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;\n@@ -79,6 +80,10 @@ class SslSocket : public Network::TransportSocket,\n   SSL* rawSsl() const { return info_->ssl(); }\n \n private:\n+  SslSocket(Envoy::Ssl::ContextSharedPtr ctx,\n+            const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options);\n+  absl::Status initialize(InitialState state, Ssl::HandshakerFactoryCb handshaker_factory_cb);\n+\n   struct ReadResult {\n     uint64_t bytes_read_{0};\n     absl::optional<int> error_;"
        },
        {
          "filename": "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -602,6 +602,24 @@ TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithIpHost) {\n   checkSimpleRequestSuccess(0, 0, response.get());\n }\n \n+TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {\n+  upstream_tls_ = true;\n+  initializeWithArgs(1024, 1024, \"x-host\");\n+  std::string too_long_sni(300, 'a');\n+  ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.\n+  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n+  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n+                                                       {\":path\", \"/test/long/url\"},\n+                                                       {\":scheme\", \"http\"},\n+                                                       {\":authority\", \"localhost\"},\n+                                                       {\"x-host\", too_long_sni}};\n+\n+  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n+  ASSERT_TRUE(response->waitForEndStream());\n+  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n+  // TODO(ggreenway): validate (in access logs probably) that failure reason is set appropriately.\n+}\n+\n // Verify that auto-SAN verification fails with an incorrect certificate.\n TEST_P(ProxyFilterIntegrationTest, UpstreamTlsInvalidSAN) {\n   upstream_tls_ = true;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c93cf7af47f7e24c83b563d3b956074333bc4bf7",
            "date": "2025-01-14T17:23:07Z",
            "author_login": "phlax"
          },
          {
            "sha": "078dae3549912e632c3776a5e9a4679226093276",
            "date": "2025-01-14T14:27:08Z",
            "author_login": "agrawroh"
          },
          {
            "sha": "7b20933ee263eb9aeaceee6bc309b80b997cbbb2",
            "date": "2025-01-14T14:13:49Z",
            "author_login": "phlax"
          },
          {
            "sha": "03cb8d59f80a2a75d9e1289c909e5979a79ace91",
            "date": "2025-01-13T06:31:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "3487b225f48717dd5a2babb5f921df4353633cee",
            "date": "2025-01-13T06:10:11Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-253",
    "description": "Envoy is a cloud-native, open source edge and service proxy. When an upstream TLS cluster is used with `auto_sni` enabled, a request containing a `host`/`:authority` header longer than 255 characters triggers an abnormal termination of Envoy process. Envoy does not gracefully handle an error when setting SNI for outbound TLS connection. The error can occur when Envoy attempts to use the `host`/`:authority` header value longer than 255 characters as SNI for outbound TLS connection. SNI length is limited to 255 characters per the standard. Envoy always expects this operation to succeed and abnormally aborts the process when it fails. This vulnerability is fixed in 1.30.1, 1.29.4, 1.28.3, and 1.27.5.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-18T15:15:30.670",
    "last_modified": "2024-11-21T09:14:59.277",
    "fix_date": "2024-04-18T00:33:22Z"
  },
  "references": [
    {
      "url": "https://github.com/envoyproxy/envoy/commit/b47fc6648d7c2dfe0093a601d44cb704b7bad382",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-3mh5-6q8v-25wj",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/envoyproxy/envoy/commit/b47fc6648d7c2dfe0093a601d44cb704b7bad382",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-3mh5-6q8v-25wj",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:06.994676",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "envoy",
    "owner": "envoyproxy",
    "created_at": "2016-08-08T15:07:24Z",
    "updated_at": "2025-01-14T12:22:22Z",
    "pushed_at": "2025-01-14T05:36:17Z",
    "size": 240648,
    "stars": 25321,
    "forks": 4848,
    "open_issues": 1639,
    "watchers": 25321,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C++": 48293036,
      "Starlark": 3105942,
      "Java": 1320095,
      "Python": 605206,
      "Assembly": 327095,
      "Kotlin": 309606,
      "Swift": 250537,
      "Shell": 229801,
      "Go": 183281,
      "Rust": 107190,
      "JavaScript": 66339,
      "C": 61597,
      "Objective-C++": 55490,
      "Objective-C": 48840,
      "Jinja": 47798,
      "Smarty": 3528,
      "CSS": 2927,
      "HTML": 1522,
      "Emacs Lisp": 966,
      "Dockerfile": 960,
      "Thrift": 748,
      "PureBasic": 472,
      "Batchfile": 439,
      "Makefile": 303
    },
    "commit_activity": {
      "total_commits_last_year": 3286,
      "avg_commits_per_week": 63.19230769230769,
      "days_active_last_year": 303
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:55:59.245540"
  }
}