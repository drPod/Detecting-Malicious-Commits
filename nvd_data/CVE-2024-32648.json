{
  "cve_id": "CVE-2024-32648",
  "github_data": {
    "repository": "vyperlang/vyper",
    "fix_commit": "93287e5ac184b53b395c907d40701f721daf8177",
    "related_commits": [
      "93287e5ac184b53b395c907d40701f721daf8177",
      "93287e5ac184b53b395c907d40701f721daf8177"
    ],
    "patch_url": "https://github.com/vyperlang/vyper/commit/93287e5ac184b53b395c907d40701f721daf8177.patch",
    "fix_commit_details": {
      "sha": "93287e5ac184b53b395c907d40701f721daf8177",
      "commit_date": "2021-10-03T05:58:47Z",
      "author": {
        "login": "charles-cooper",
        "type": "User",
        "stats": {
          "total_commits": 1087,
          "average_weekly_commits": 2.539719626168224,
          "total_additions": 171904,
          "total_deletions": 132151,
          "weeks_active": 180
        }
      },
      "commit_message": {
        "title": "Merge pull request #2447 from charles-cooper/abi_refactor",
        "length": 94,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 4262,
        "additions": 1832,
        "deletions": 2430
      },
      "files": [
        {
          "filename": "docs/built-in-functions.rst",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -631,7 +631,7 @@ Utilities\n     Once this function has seen more use we provisionally plan to put it into the ``ethereum.abi`` namespace.\n \n     * ``*args``: Arbitrary arguments\n-    * ``ensure_tuple``: If set to True, ensures that even a single argument is encoded as a tuple. In other words, ``bytes`` gets encoded as ``(bytes,)``. This is the calling convention for Vyper and Solidity functions. Except for very specific use cases, this should be set to True. Must be a literal.\n+    * ``ensure_tuple``: If set to True, ensures that even a single argument is encoded as a tuple. In other words, ``bytes`` gets encoded as ``(bytes,)``, and ``(bytes,)`` gets encoded as ``((bytes,),)`` This is the calling convention for Vyper and Solidity functions. Except for very specific use cases, this should be set to True. Must be a literal.\n     * ``method_id``: A literal hex or Bytes[4] value to append to the beginning of the abi-encoded bytestring.\n \n     Returns a bytestring whose max length is determined by the arguments. For example, encoding a ``Bytes[32]`` results in a ``Bytes[64]`` (first word is the length of the bytestring variable)."
        },
        {
          "filename": "setup.py",
          "status": "modified",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -64,7 +64,12 @@\n     packages=find_packages(exclude=(\"tests\", \"docs\")),\n     python_requires=\">=3.6\",\n     py_modules=[\"vyper\"],\n-    install_requires=[\"asttokens==2.0.4\", \"pycryptodome>=3.5.1,<4\", \"semantic-version==2.8.5\"],\n+    install_requires=[\n+        \"asttokens==2.0.4\",\n+        \"pycryptodome>=3.5.1,<4\",\n+        \"semantic-version==2.8.5\",\n+        \"cached-property==1.5.2 ; python_version<'3.8'\",\n+    ],\n     setup_requires=[\"pytest-runner\"],\n     tests_require=extras_require[\"test\"],\n     extras_require=extras_require,"
        },
        {
          "filename": "tests/cli/outputs/test_storage_layout.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -34,5 +34,5 @@ def public_bar():\n             \"slot\": 3,\n         },\n         \"baz\": {\"type\": \"Bytes[65]\", \"location\": \"storage\", \"slot\": 4},\n-        \"bar\": {\"type\": \"uint256\", \"location\": \"storage\", \"slot\": 9},\n+        \"bar\": {\"type\": \"uint256\", \"location\": \"storage\", \"slot\": 8},\n     }"
        },
        {
          "filename": "tests/compiler/test_source_map.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -32,7 +32,7 @@ def test_jump_map():\n     pos_map = source_map[\"pc_pos_map\"]\n     jump_map = source_map[\"pc_jump_map\"]\n \n-    assert len([v for v in jump_map.values() if v == \"o\"]) == 3\n+    assert len([v for v in jump_map.values() if v == \"o\"]) == 1\n     assert len([v for v in jump_map.values() if v == \"i\"]) == 2\n \n     code_lines = [i + \"\\n\" for i in TEST_CODE.split(\"\\n\")]"
        },
        {
          "filename": "tests/conftest.py",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -3,6 +3,7 @@\n \n import pytest\n from eth_tester import EthereumTester\n+from eth_utils import setup_DEBUG2_logging\n from hexbytes import HexBytes\n from web3 import Web3\n from web3.providers.eth_tester import EthereumTesterProvider\n@@ -26,12 +27,14 @@\n \n \n def set_evm_verbose_logging():\n-    logger = logging.getLogger(\"evm\")\n-    logger.setLevel(\"TRACE\")\n+    logger = logging.getLogger(\"eth.vm.computation.Computation\")\n+    setup_DEBUG2_logging()\n+    logger.setLevel(\"DEBUG2\")\n \n \n # Useful options to comment out whilst working:\n # set_evm_verbose_logging()\n+#\n # from vdb import vdb\n # vdb.set_evm_opcode_debugger()\n "
        },
        {
          "filename": "tests/functional/codegen/test_abi_encode.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -31,7 +31,7 @@ def abi_encode(\n     pet_metadata: bytes32,\n     ensure_tuple: bool,\n     include_method_id: bool\n-) -> Bytes[260]:\n+) -> Bytes[548]:\n     human: Human = Human({\n       name: name,\n       pet: Animal({"
        },
        {
          "filename": "tests/functional/codegen/test_struct_return.py",
          "status": "modified",
          "additions": 12,
          "deletions": 16,
          "patch": "@@ -5,33 +5,29 @@ def test_nested_tuple(get_contract):\n     code = \"\"\"\n struct Animal:\n     location: address\n-    fur: uint256\n+    fur: String[32]\n \n struct Human:\n     location: address\n-    height: uint256\n+    animal: Animal\n \n @external\n-def return_nested_tuple() -> (Animal, Human):\n-    animal: Animal = Animal({\n-        location: 0x1234567890123456789012345678901234567890,\n-        fur: 123\n-    })\n-    human: Human = Human({\n-        location: 0x1234567890123456789012345678900000000000,\n-        height: 456\n-    })\n+def modify_nested_tuple(_human: Human) -> Human:\n+    human: Human = _human\n \n     # do stuff, edit the structs\n-    animal.fur += 1\n-    human.height += 1\n+    # (13 is the length of the result)\n+    human.animal.fur = slice(concat(human.animal.fur, \" is great\"), 0, 13)\n \n-    return animal, human\n+    return human\n     \"\"\"\n     c = get_contract(code)\n     addr1 = \"0x1234567890123456789012345678901234567890\"\n     addr2 = \"0x1234567890123456789012345678900000000000\"\n-    assert c.return_nested_tuple() == [(addr1, 124), (addr2, 457)]\n+    # assert c.modify_nested_tuple([addr1, 123], [addr2, 456]) == [[addr1, 124], [addr2, 457]]\n+    assert c.modify_nested_tuple(\n+        {\"location\": addr1, \"animal\": {\"location\": addr2, \"fur\": \"wool\"}}\n+    ) == (addr1, (addr2, \"wool is great\"),)\n \n \n @pytest.mark.parametrize(\"string\", [\"a\", \"abc\", \"abcde\", \"potato\"])\n@@ -61,4 +57,4 @@ def test_values(a: address) -> Person:\n     \"\"\"\n \n     c2 = get_contract(code)\n-    assert c2.test_values(c1.address) == [string, 42]\n+    assert c2.test_values(c1.address) == (string, 42)"
        },
        {
          "filename": "tests/functional/context/types/test_size_in_bytes.py",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -24,8 +24,7 @@ def test_array_value_types(build_node, type_str, location, length, size):\n     node = build_node(f\"{type_str}[{length}]\")\n     type_definition = get_type_from_annotation(node, location)\n \n-    # TODO once storage of bytes is optimized, remove the +32\n-    assert type_definition.size_in_bytes == size + 32\n+    assert type_definition.size_in_bytes == size\n \n \n @pytest.mark.parametrize(\"type_str\", BASE_TYPES)"
        },
        {
          "filename": "tests/functional/test_storage_slots.py",
          "status": "modified",
          "additions": 8,
          "deletions": 8,
          "patch": "@@ -55,18 +55,18 @@ def with_other_lock():\n \n def test_storage_slots(get_contract):\n     c = get_contract(code)\n-    assert c.a() == [\"ok\", [4, 5, 6]]\n+    assert c.a() == (\"ok\", [4, 5, 6])\n     assert [c.b(i) for i in range(2)] == [7, 8]\n     assert c.c() == b\"thisisthirtytwobytesokhowdoyoudo\"\n     assert [c.d(i) for i in range(4)] == [-1, -2, -3, -4]\n     assert c.e() == \"A realllllly long string but we wont use it all\"\n     assert c.f(0) == 33\n-    assert c.g(0) == [b\"hello\", [-66, 420], \"another string\"]\n-    assert c.g(1) == [\n+    assert c.g(0) == (b\"hello\", [-66, 420], \"another string\")\n+    assert c.g(1) == (\n         b\"gbye\",\n         [1337, 888],\n         \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\",\n-    ]\n+    )\n     assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n     assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n     assert c.h(0) == 123456789\n@@ -80,18 +80,18 @@ def test_reentrancy_lock(get_contract):\n     c.with_lock()\n     c.with_other_lock()\n \n-    assert c.a() == [\"ok\", [4, 5, 6]]\n+    assert c.a() == (\"ok\", [4, 5, 6])\n     assert [c.b(i) for i in range(2)] == [7, 8]\n     assert c.c() == b\"thisisthirtytwobytesokhowdoyoudo\"\n     assert [c.d(i) for i in range(4)] == [-1, -2, -3, -4]\n     assert c.e() == \"A realllllly long string but we wont use it all\"\n     assert c.f(0) == 33\n-    assert c.g(0) == [b\"hello\", [-66, 420], \"another string\"]\n-    assert c.g(1) == [\n+    assert c.g(0) == (b\"hello\", [-66, 420], \"another string\")\n+    assert c.g(1) == (\n         b\"gbye\",\n         [1337, 888],\n         \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\",\n-    ]\n+    )\n     assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n     assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n     assert c.h(0) == 123456789"
        },
        {
          "filename": "tests/parser/exceptions/test_argument_exception.py",
          "status": "modified",
          "additions": 0,
          "deletions": 25,
          "patch": "@@ -89,31 +89,6 @@ def foo():\n     for i in range(1, 2, 3, 4):\n         pass\n     \"\"\",\n-    \"\"\"\n-struct Foo:\n-    a: Bytes[32]\n-\n-@external\n-def foo(a: Foo):\n-    pass\n-    \"\"\",\n-    \"\"\"\n-struct Foo:\n-    a: String[32]\n-\n-@external\n-def foo(a: Foo):\n-    pass\n-    \"\"\",\n-    \"\"\"\n-struct Foo:\n-    b: uint256\n-    a: String[32]\n-\n-@external\n-def foo(a: Foo):\n-    pass\n-    \"\"\",\n ]\n \n "
        },
        {
          "filename": "tests/parser/features/decorators/test_private.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -580,7 +580,7 @@ def foo() -> A:\n     return self._foo([1, 2, 3, 4], 5)\n     \"\"\",\n         (),\n-        [[1, 2, 3, 4], 5],\n+        ([1, 2, 3, 4], 5),\n     ),\n     (\n         \"\"\""
        },
        {
          "filename": "tests/parser/features/external_contracts/test_external_contract_calls.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -829,7 +829,7 @@ def test(addr: address) -> (int128, address):\n     c1 = get_contract_with_gas_estimation(contract_1)\n     c2 = get_contract_with_gas_estimation(contract_2)\n \n-    assert c1.out_literals() == [1, \"0x0000000000000000000000000000000000012345\"]\n+    assert c1.out_literals() == (1, \"0x0000000000000000000000000000000000012345\")\n     assert c2.test(c1.address) == list(c1.out_literals())\n \n \n@@ -862,7 +862,7 @@ def test(addr: address) -> (int128, String[{ln}], Bytes[{ln}]):\n     c1 = get_contract_with_gas_estimation(contract_1)\n     c2 = get_contract_with_gas_estimation(contract_2)\n \n-    assert c1.get_struct_x() == [i, s, bytes(s, \"utf-8\")]\n+    assert c1.get_struct_x() == (i, s, bytes(s, \"utf-8\"))\n     assert c2.test(c1.address) == list(c1.get_struct_x())\n \n "
        },
        {
          "filename": "tests/parser/features/external_contracts/test_self_call_struct.py",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -24,11 +24,11 @@ def wrap_get_my_struct_BROKEN(_e1: decimal) -> MyStruct:\n     return self.get_my_struct(_e1, block.timestamp)\n     \"\"\"\n     c = get_contract(code)\n-    assert c.wrap_get_my_struct_WORKING(Decimal(\"0.1\")) == [\n+    assert c.wrap_get_my_struct_WORKING(Decimal(\"0.1\")) == (\n         Decimal(\"0.1\"),\n         w3.eth.getBlock(w3.eth.blockNumber)[\"timestamp\"],\n-    ]\n-    assert c.wrap_get_my_struct_BROKEN(Decimal(\"0.1\")) == [\n+    )\n+    assert c.wrap_get_my_struct_BROKEN(Decimal(\"0.1\")) == (\n         Decimal(\"0.1\"),\n         w3.eth.getBlock(w3.eth.blockNumber)[\"timestamp\"],\n-    ]\n+    )"
        },
        {
          "filename": "tests/parser/features/iteration/test_repeater.py",
          "status": "modified",
          "additions": 4,
          "deletions": 2,
          "patch": "@@ -106,8 +106,10 @@ def test_return_inside_repeater(get_contract, typ):\n @internal\n def _final(a: {typ}) -> {typ}:\n     for i in range(10):\n-        if i > a:\n-            return i\n+        for j in range(10):\n+            if j > 5:\n+                if i > a:\n+                    return i\n     return 31337\n \n @internal"
        },
        {
          "filename": "tests/parser/features/test_init.py",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -14,9 +14,10 @@ def __init__(a: uint256):\n \n     assert c.val() == 123\n \n-    # Make sure the init signature has no unecessary CALLDATLOAD copy.\n+    # Make sure the init code does not access calldata\n     opcodes = vyper.compile_code(code, [\"opcodes\"])[\"opcodes\"].split(\" \")\n     lll_return_idx = opcodes.index(\"JUMP\")\n \n-    assert \"CALLDATALOAD\" in opcodes\n+    assert \"CALLDATACOPY\" in opcodes\n+    assert \"CALLDATACOPY\" not in opcodes[:lll_return_idx]\n     assert \"CALLDATALOAD\" not in opcodes[:lll_return_idx]"
        },
        {
          "filename": "tests/parser/functions/test_abi.py",
          "status": "modified",
          "additions": 14,
          "deletions": 6,
          "patch": "@@ -75,13 +75,21 @@ def foo(s: MyStruct) -> MyStruct:\n     func_abi = abi[0]\n \n     assert func_abi[\"name\"] == \"foo\"\n-    expected = {\n+\n+    expected_output = [\n+        {\n+            \"type\": \"tuple\",\n+            \"name\": \"\",\n+            \"components\": [{\"type\": \"address\", \"name\": \"a\"}, {\"type\": \"uint256\", \"name\": \"b\"}],\n+        }\n+    ]\n+\n+    assert func_abi[\"outputs\"] == expected_output\n+\n+    expected_input = {\n         \"type\": \"tuple\",\n-        \"name\": \"\",\n+        \"name\": \"s\",\n         \"components\": [{\"type\": \"address\", \"name\": \"a\"}, {\"type\": \"uint256\", \"name\": \"b\"}],\n     }\n \n-    assert func_abi[\"outputs\"] == expected[\"components\"]\n-\n-    expected[\"name\"] = \"s\"\n-    assert func_abi[\"inputs\"][0] == expected\n+    assert func_abi[\"inputs\"][0] == expected_input"
        },
        {
          "filename": "tests/parser/functions/test_return_struct.py",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -24,7 +24,7 @@ def test() -> Voter:\n \n     c = get_contract_with_gas_estimation(code)\n \n-    assert c.test() == [123, True]\n+    assert c.test() == (123, True)\n \n \n def test_struct_return(get_contract_with_gas_estimation):\n@@ -74,13 +74,13 @@ def pub6() -> Foo:\n     foo: Foo = Foo({x: 123, y: 456})\n     return self.return_arg(foo)\n     \"\"\"\n-    foo = [123, 456]\n+    foo = (123, 456)\n \n     c = get_contract_with_gas_estimation(code)\n \n-    assert c.pub1() == [1, 2]\n-    assert c.pub2() == [3, 4]\n-    assert c.pub3() == [5, 6]\n-    assert c.pub4() == [7, 8]\n+    assert c.pub1() == (1, 2)\n+    assert c.pub2() == (3, 4)\n+    assert c.pub3() == (5, 6)\n+    assert c.pub4() == (7, 8)\n     assert c.pub5(foo) == foo\n     assert c.pub6() == foo"
        },
        {
          "filename": "tests/parser/types/numbers/test_constants.py",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -175,11 +175,12 @@ def test_constant_folds(search_for_sublist):\n def test() -> uint256:\n     # calculate some constant which is really unlikely to be randomly\n     # in bytecode\n-    return 2**SOME_CONSTANT * SOME_PRIME\n+    ret: uint256 = 2**SOME_CONSTANT * SOME_PRIME\n+    return ret\n     \"\"\"\n \n     lll = compile_code(code, [\"ir\"])[\"ir\"]\n-    assert search_for_sublist(lll, [\"mstore\", [0], [2 ** 12 * some_prime]])\n+    assert search_for_sublist(lll, [\"mstore\", [320], [2 ** 12 * some_prime]])\n \n \n def test_constant_lists(get_contract):"
        },
        {
          "filename": "tests/parser/types/test_node_types.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -60,8 +60,8 @@ def test_canonicalize_type():\n \n def test_get_size_of_type():\n     assert get_size_of_type(BaseType(\"int128\")) == 1\n-    assert get_size_of_type(ByteArrayType(12)) == 3\n-    assert get_size_of_type(ByteArrayType(33)) == 4\n+    assert get_size_of_type(ByteArrayType(12)) == 2\n+    assert get_size_of_type(ByteArrayType(33)) == 3\n     assert get_size_of_type(ListType(BaseType(\"int128\"), 10)) == 10\n \n     _tuple = TupleType([BaseType(\"int128\"), BaseType(\"decimal\")])"
        },
        {
          "filename": "vyper/ast/signatures/function_signature.py",
          "status": "modified",
          "additions": 97,
          "deletions": 153,
          "patch": "@@ -1,29 +1,29 @@\n import math\n-from collections import Counter\n+from dataclasses import dataclass\n \n from vyper import ast as vy_ast\n-from vyper.exceptions import FunctionDeclarationException, StructureException\n-from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.parser_utils import check_single_exit, getpos\n+from vyper.exceptions import StructureException\n+from vyper.old_codegen.lll_node import Encoding\n from vyper.old_codegen.types import (\n-    ByteArrayLike,\n-    TupleType,\n+    NodeType,\n     canonicalize_type,\n     get_size_of_type,\n     parse_type,\n )\n-from vyper.utils import fourbytes_to_int, keccak256\n+from vyper.utils import cached_property, mkalphanum\n \n \n-# Function argument\n+# Function variable\n+# TODO move to context.py\n+# TODO use dataclass\n class VariableRecord:\n     def __init__(\n         self,\n         name,\n         pos,\n         typ,\n         mutable,\n-        *,\n+        encoding=Encoding.VYPER,\n         location=\"memory\",\n         blockscopes=None,\n         defined_at=None,\n@@ -34,10 +34,16 @@ def __init__(\n         self.typ = typ\n         self.mutable = mutable\n         self.location = location\n+        self.encoding = encoding\n         self.blockscopes = [] if blockscopes is None else blockscopes\n         self.defined_at = defined_at  # source code location variable record was defined.\n         self.is_internal = is_internal\n \n+    def __repr__(self):\n+        ret = vars(self)\n+        ret[\"allocated\"] = self.size * 32\n+        return f\"VariableRecord(f{ret})\"\n+\n     @property\n     def size(self):\n         if hasattr(self.typ, \"size_in_bytes\"):\n@@ -53,131 +59,122 @@ def __init__(self, *args):\n         super(ContractRecord, self).__init__(*args)\n \n \n+@dataclass\n+class FunctionArg:\n+    name: str\n+    typ: NodeType\n+    ast_source: vy_ast.VyperNode\n+\n+\n # Function signature object\n class FunctionSignature:\n     def __init__(\n         self,\n         name,\n         args,\n-        output_type,\n+        return_type,\n         mutability,\n         internal,\n         nonreentrant_key,\n-        sig,\n-        method_id,\n         func_ast_code,\n         is_from_json,\n     ):\n         self.name = name\n         self.args = args\n-        self.output_type = output_type\n+        self.return_type = return_type\n         self.mutability = mutability\n         self.internal = internal\n-        self.sig = sig\n-        self.method_id = method_id\n         self.gas = None\n         self.nonreentrant_key = nonreentrant_key\n         self.func_ast_code = func_ast_code\n         self.is_from_json = is_from_json\n-        self.calculate_arg_totals()\n+\n+        self.set_default_args()\n \n     def __str__(self):\n         input_name = \"def \" + self.name + \"(\" + \",\".join([str(arg.typ) for arg in self.args]) + \")\"\n-        if self.output_type:\n-            return input_name + \" -> \" + str(self.output_type) + \":\"\n+        if self.return_type:\n+            return input_name + \" -> \" + str(self.return_type) + \":\"\n         return input_name + \":\"\n \n-    def calculate_arg_totals(self):\n-        \"\"\" Calculate base arguments, and totals. \"\"\"\n-\n-        code = self.func_ast_code\n-        self.base_args = []\n-        self.total_default_args = 0\n-\n-        if hasattr(code.args, \"defaults\"):\n-            self.total_default_args = len(code.args.defaults)\n-            if self.total_default_args > 0:\n-                # all argument w/o defaults\n-                self.base_args = self.args[: -self.total_default_args]\n-            else:\n-                # No default args, so base_args = args.\n-                self.base_args = self.args\n-            # All default argument name/type definitions.\n-            self.default_args = code.args.args[-self.total_default_args :]  # noqa: E203\n-            # Keep all the value to assign to default parameters.\n-            self.default_values = dict(\n-                zip([arg.arg for arg in self.default_args], code.args.defaults)\n-            )\n-\n-        # Calculate the total sizes in memory the function arguments will take use.\n-        # Total memory size of all arguments (base + default together).\n-        self.max_copy_size = sum(\n-            [\n-                32 if isinstance(arg.typ, ByteArrayLike) else get_size_of_type(arg.typ) * 32\n-                for arg in self.args\n-            ]\n-        )\n-        # Total memory size of base arguments (arguments exclude default parameters).\n-        self.base_copy_size = sum(\n-            [\n-                32 if isinstance(arg.typ, ByteArrayLike) else get_size_of_type(arg.typ) * 32\n-                for arg in self.base_args\n-            ]\n-        )\n+    @cached_property\n+    def _lll_identifier(self) -> str:\n+        # we could do a bit better than this but it just needs to be unique\n+        visibility = \"internal\" if self.internal else \"external\"\n+        argz = \",\".join([str(arg.typ) for arg in self.args])\n+        ret = f\"{visibility} {self.name} ({argz})\"\n+        return mkalphanum(ret)\n+\n+    # calculate the abi signature for a given set of kwargs\n+    def abi_signature_for_kwargs(self, kwargs):\n+        args = self.base_args + kwargs\n+        return self.name + \"(\" + \",\".join([canonicalize_type(arg.typ) for arg in args]) + \")\"\n+\n+    @cached_property\n+    def base_signature(self):\n+        return self.abi_signature_for_kwargs([])\n+\n+    @property\n+    # common entry point for external function with kwargs\n+    def external_function_base_entry_label(self):\n+        assert not self.internal\n+\n+        return self._lll_identifier + \"_common\"\n+\n+    @property\n+    def internal_function_label(self):\n+        assert self.internal, \"why are you doing this\"\n \n-    # Get the canonical function signature\n-    @staticmethod\n-    def get_full_sig(func_name, args, sigs, custom_structs):\n-        def get_type(arg):\n-            if isinstance(arg, LLLnode):\n-                return canonicalize_type(arg.typ)\n-            elif hasattr(arg, \"annotation\"):\n-                return canonicalize_type(\n-                    parse_type(arg.annotation, None, sigs, custom_structs=custom_structs,)\n-                )\n+        return self._lll_identifier\n \n-        return func_name + \"(\" + \",\".join([get_type(arg) for arg in args]) + \")\"\n+    @property\n+    def exit_sequence_label(self):\n+        return self._lll_identifier + \"_cleanup\"\n+\n+    def set_default_args(self):\n+        \"\"\"Split base from kwargs and set member data structures\"\"\"\n+\n+        args = self.func_ast_code.args\n+\n+        defaults = getattr(args, \"defaults\", [])\n+        num_base_args = len(args.args) - len(defaults)\n+\n+        self.base_args = self.args[:num_base_args]\n+        self.default_args = self.args[num_base_args:]\n+\n+        # Keep all the value to assign to default parameters.\n+        self.default_values = dict(zip([arg.name for arg in self.default_args], defaults))\n \n     # Get a signature from a function definition\n     @classmethod\n     def from_definition(\n         cls,\n-        code,\n-        sigs=None,\n+        func_ast,  # vy_ast.FunctionDef\n+        sigs=None,  # TODO replace sigs and custom_structs with GlobalContext?\n         custom_structs=None,\n         interface_def=False,\n-        constant_override=False,\n+        constant_override=False,  # CMC 20210907 what does this do?\n         is_from_json=False,\n     ):\n-        if not custom_structs:\n+        if custom_structs is None:\n             custom_structs = {}\n \n-        name = code.name\n-        mem_pos = 0\n+        name = func_ast.name\n \n-        # Determine the arguments, expects something of the form def foo(arg1:\n-        # int128, arg2: int128 ...\n         args = []\n-        for arg in code.args.args:\n-            # Each arg needs a type specified.\n-            typ = arg.annotation\n-            parsed_type = parse_type(typ, None, sigs, custom_structs=custom_structs,)\n-            args.append(\n-                VariableRecord(arg.arg, mem_pos, parsed_type, False, defined_at=getpos(arg),)\n-            )\n-\n-            if isinstance(parsed_type, ByteArrayLike):\n-                mem_pos += 32\n-            else:\n-                mem_pos += get_size_of_type(parsed_type) * 32\n+        for arg in func_ast.args.args:\n+            argname = arg.arg\n+            argtyp = parse_type(arg.annotation, None, sigs, custom_structs=custom_structs,)\n+\n+            args.append(FunctionArg(argname, argtyp, arg))\n \n         mutability = \"nonpayable\"  # Assume nonpayable by default\n-        nonreentrant_key = \"\"\n-        is_internal = False\n+        nonreentrant_key = None\n+        is_internal = None\n \n         # Update function properties from decorators\n         # NOTE: Can't import enums here because of circular import\n-        for dec in code.decorator_list:\n+        for dec in func_ast.decorator_list:\n             if isinstance(dec, vy_ast.Name) and dec.id in (\"payable\", \"view\", \"pure\"):\n                 mutability = dec.id\n             elif isinstance(dec, vy_ast.Name) and dec.id == \"internal\":\n@@ -199,80 +196,27 @@ def from_definition(\n         # def foo() -> int128: ...\n         # If there is no return type, ie. it's of the form def foo(): ...\n         # and NOT def foo() -> type: ..., then it's null\n-        output_type = None\n-        if code.returns:\n-            output_type = parse_type(code.returns, None, sigs, custom_structs=custom_structs,)\n-            # Output type must be canonicalizable\n-            assert isinstance(output_type, TupleType) or canonicalize_type(output_type)\n-        # Get the canonical function signature\n-        sig = cls.get_full_sig(name, code.args.args, sigs, custom_structs)\n-\n-        # Take the first 4 bytes of the hash of the sig to get the method ID\n-        method_id = fourbytes_to_int(keccak256(bytes(sig, \"utf-8\"))[:4])\n+        return_type = None\n+        if func_ast.returns:\n+            return_type = parse_type(func_ast.returns, None, sigs, custom_structs=custom_structs,)\n+            # sanity check: Output type must be canonicalizable\n+            assert canonicalize_type(return_type)\n+\n         return cls(\n             name,\n             args,\n-            output_type,\n+            return_type,\n             mutability,\n             is_internal,\n             nonreentrant_key,\n-            sig,\n-            method_id,\n-            code,\n+            func_ast,\n             is_from_json,\n         )\n \n-    @classmethod\n-    def lookup_sig(cls, sigs, method_name, expr_args, stmt_or_expr, context):\n-        \"\"\"\n-        Using a list of args, determine the most accurate signature to use from\n-        the given context\n-        \"\"\"\n-\n-        def synonymise(s):\n-            return s.replace(\"int128\", \"num\").replace(\"uint256\", \"num\")\n-\n-        # for sig in sigs['self']\n-        full_sig = cls.get_full_sig(stmt_or_expr.func.attr, expr_args, None, context.structs,)\n-        method_names_dict = dict(Counter([x.split(\"(\")[0] for x in context.sigs[\"self\"]]))\n-        if method_name not in method_names_dict:\n-            raise FunctionDeclarationException(\n-                \"Function not declared yet (reminder: functions cannot \"\n-                f\"call functions later in code than themselves): {method_name}\"\n-            )\n-\n-        if method_names_dict[method_name] == 1:\n-            return next(\n-                sig\n-                for name, sig in context.sigs[\"self\"].items()\n-                if name.split(\"(\")[0] == method_name\n-            )\n-        if full_sig in context.sigs[\"self\"]:\n-            return context.sigs[\"self\"][full_sig]\n-        else:\n-            synonym_sig = synonymise(full_sig)\n-            syn_sigs_test = [synonymise(k) for k in context.sigs.keys()]\n-            if len(syn_sigs_test) != len(set(syn_sigs_test)):\n-                raise Exception(\n-                    \"Incompatible default parameter signature,\"\n-                    \"can not tell the number type of literal\",\n-                    stmt_or_expr,\n-                )\n-            synonym_sigs = [(synonymise(k), v) for k, v in context.sigs[\"self\"].items()]\n-            ssig = [s[1] for s in synonym_sigs if s[0] == synonym_sig]\n-            if len(ssig) == 0:\n-                raise FunctionDeclarationException(\n-                    \"Function not declared yet (reminder: functions cannot \"\n-                    f\"call functions later in code than themselves): {method_name}\"\n-                )\n-            return ssig[0]\n-\n+    @property\n     def is_default_func(self):\n         return self.name == \"__default__\"\n \n-    def is_initializer(self):\n+    @property\n+    def is_init_func(self):\n         return self.name == \"__init__\"\n-\n-    def validate_return_statement_balance(self):\n-        # Run balanced return statement check.\n-        check_single_exit(self.func_ast_code)"
        },
        {
          "filename": "vyper/ast/signatures/interface.py",
          "status": "modified",
          "additions": 14,
          "deletions": 3,
          "patch": "@@ -5,7 +5,6 @@\n \n import vyper.builtin_interfaces\n from vyper import ast as vy_ast\n-from vyper.ast.signatures import sig_utils\n from vyper.ast.signatures.function_signature import FunctionSignature\n from vyper.exceptions import StructureException\n from vyper.old_codegen.global_context import GlobalContext\n@@ -81,7 +80,7 @@ def mk_full_signature_from_json(abi):\n             decorator_list.append(vy_ast.Name(id=\"payable\"))\n \n         sig = FunctionSignature.from_definition(\n-            code=vy_ast.FunctionDef(\n+            func_ast=vy_ast.FunctionDef(\n                 name=func[\"name\"],\n                 args=vy_ast.arguments(args=args),\n                 decorator_list=decorator_list,\n@@ -94,6 +93,18 @@ def mk_full_signature_from_json(abi):\n     return sigs\n \n \n+def _get_external_signatures(global_ctx, sig_formatter=lambda x: x):\n+    ret = []\n+\n+    for code in global_ctx._defs:\n+        sig = FunctionSignature.from_definition(\n+            code, sigs=global_ctx._contracts, custom_structs=global_ctx._structs,\n+        )\n+        if not sig.internal:\n+            ret.append(sig_formatter(sig))\n+    return ret\n+\n+\n def extract_sigs(sig_code, interface_name=None):\n     if sig_code[\"type\"] == \"vyper\":\n         interface_ast = [\n@@ -116,7 +127,7 @@ def extract_sigs(sig_code, interface_name=None):\n             or (isinstance(i, vy_ast.AnnAssign) and i.target.id != \"implements\")\n         ]\n         global_ctx = GlobalContext.get_global_context(interface_ast)\n-        return sig_utils.mk_full_signature(global_ctx, sig_formatter=lambda x: x)\n+        return _get_external_signatures(global_ctx)\n     elif sig_code[\"type\"] == \"json\":\n         return mk_full_signature_from_json(sig_code[\"code\"])\n     else:"
        },
        {
          "filename": "vyper/ast/signatures/sig_utils.py",
          "status": "removed",
          "additions": 0,
          "deletions": 58,
          "patch": "@@ -1,58 +0,0 @@\n-import copy\n-\n-from vyper.ast.signatures.function_signature import FunctionSignature\n-\n-\n-# Generate default argument function signatures.\n-def generate_default_arg_sigs(code, interfaces, global_ctx):\n-    # generate all sigs, and attach.\n-    total_default_args = len(code.args.defaults)\n-    if total_default_args == 0:\n-        return [\n-            FunctionSignature.from_definition(\n-                code, sigs=interfaces, custom_structs=global_ctx._structs,\n-            )\n-        ]\n-    base_args = code.args.args[:-total_default_args]\n-    default_args = code.args.args[-total_default_args:]\n-\n-    # Generate a list of default function combinations.\n-    row = [False] * (total_default_args)\n-    table = [row.copy()]\n-    for i in range(total_default_args):\n-        row[i] = True\n-        table.append(row.copy())\n-\n-    default_sig_strs = []\n-    sig_fun_defs = []\n-    for truth_row in table:\n-        new_code = copy.deepcopy(code)\n-        new_code.args.args = copy.deepcopy(base_args)\n-        new_code.args.default = []\n-        # Add necessary default args.\n-        for idx, val in enumerate(truth_row):\n-            if val is True:\n-                new_code.args.args.append(default_args[idx])\n-        sig = FunctionSignature.from_definition(\n-            new_code, sigs=interfaces, custom_structs=global_ctx._structs,\n-        )\n-        default_sig_strs.append(sig.sig)\n-        sig_fun_defs.append(sig)\n-\n-    return sig_fun_defs\n-\n-\n-# Get ABI signature\n-def mk_full_signature(global_ctx, sig_formatter):\n-    o = []\n-\n-    # Produce function signatures.\n-    for code in global_ctx._defs:\n-        sig = FunctionSignature.from_definition(\n-            code, sigs=global_ctx._contracts, custom_structs=global_ctx._structs,\n-        )\n-        if not sig.internal:\n-            default_sigs = generate_default_arg_sigs(code, global_ctx._contracts, global_ctx)\n-            for s in default_sigs:\n-                o.append(sig_formatter(s))\n-    return o"
        },
        {
          "filename": "vyper/builtin_functions/convert.py",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -7,7 +7,12 @@\n from vyper.evm.opcodes import version_check\n from vyper.exceptions import InvalidLiteral, StructureException, TypeMismatch\n from vyper.old_codegen.arg_clamps import address_clamp, int128_clamp\n-from vyper.old_codegen.parser_utils import LLLnode, byte_array_to_num, getpos\n+from vyper.old_codegen.parser_utils import (\n+    LLLnode,\n+    byte_array_to_num,\n+    getpos,\n+    load_op,\n+)\n from vyper.old_codegen.types import (\n     BaseType,\n     ByteArrayType,\n@@ -325,10 +330,11 @@ def to_bytes32(expr, args, kwargs, context):\n                 f\"Unable to convert bytes[{_len}] to bytes32, max length is too \" \"large.\"\n             )\n \n-        if in_arg.location == \"memory\":\n-            return LLLnode.from_list([\"mload\", [\"add\", in_arg, 32]], typ=BaseType(\"bytes32\"))\n-        elif in_arg.location == \"storage\":\n+        if in_arg.location == \"storage\":\n             return LLLnode.from_list([\"sload\", [\"add\", in_arg, 1]], typ=BaseType(\"bytes32\"))\n+        else:\n+            op = load_op(in_arg.location)\n+            return LLLnode.from_list([op, [\"add\", in_arg, 32]], typ=BaseType(\"bytes32\"))\n \n     else:\n         return LLLnode("
        },
        {
          "filename": "vyper/builtin_functions/functions.py",
          "status": "modified",
          "additions": 71,
          "deletions": 54,
          "patch": "@@ -26,16 +26,17 @@\n     abi_encode,\n     abi_type_of,\n     abi_type_of2,\n-    lll_tuple_from_args,\n )\n from vyper.old_codegen.arg_clamps import int128_clamp\n from vyper.old_codegen.expr import Expr\n from vyper.old_codegen.keccak256_helper import keccak256_helper\n from vyper.old_codegen.parser_utils import (\n     LLLnode,\n-    add_variable_offset,\n     get_bytearray_length,\n+    get_element_ptr,\n     getpos,\n+    lll_tuple_from_args,\n+    load_op,\n     make_byte_array_copier,\n     make_byte_slice_copier,\n     unwrap_location,\n@@ -254,6 +255,7 @@ def fetch_call_return(self, node):\n     def build_LLL(self, expr, args, kwargs, context):\n \n         sub, start, length = args\n+\n         if is_base_type(sub.typ, \"bytes32\"):\n             if (start.typ.is_literal and length.typ.is_literal) and not (\n                 0 <= start.value + length.value <= 32\n@@ -262,12 +264,6 @@ def build_LLL(self, expr, args, kwargs, context):\n                     \"Invalid start / length values needs to be between 0 and 32.\", expr,\n                 )\n             sub_typ_maxlen = 32\n-        elif sub.location == \"calldata\":\n-            # if we are slicing msg.data, the length should\n-            # be a constant, since msg.data can be of dynamic length\n-            # we can't use it's length as the maxlen\n-            assert isinstance(length.value, int)  # sanity check\n-            sub_typ_maxlen = length.value\n         else:\n             sub_typ_maxlen = sub.typ.maxlen\n \n@@ -278,15 +274,19 @@ def build_LLL(self, expr, args, kwargs, context):\n             ReturnType = OldStringType\n \n         # Node representing the position of the output in memory\n+        # CMC 20210917 shouldn't this be a variable with newmaxlen?\n         np = context.new_internal_variable(ReturnType(maxlen=sub_typ_maxlen + 32))\n+        # TODO deallocate np\n         placeholder_node = LLLnode.from_list(np, typ=sub.typ, location=\"memory\")\n         placeholder_plus_32_node = LLLnode.from_list(np + 32, typ=sub.typ, location=\"memory\")\n-        # Copies over bytearray data\n-        if sub.location == \"storage\":\n-            adj_sub = LLLnode.from_list(\n-                [\"add\", sub, [\"add\", [\"div\", \"_start\", 32], 1]], typ=sub.typ, location=sub.location,\n-            )\n-        elif sub.location == \"calldata\":\n+\n+        # special handling for slice(msg.data)\n+        if sub.location == \"calldata\" and sub.value == 0:\n+            assert expr.args[0].value.id == \"msg\" and expr.args[0].attr == \"data\"\n+            # if we are slicing msg.data, the length should\n+            # be a constant, since msg.data can be of dynamic length\n+            # we can't use its length as the maxlen\n+            assert isinstance(length.value, int)  # sanity check\n             node = [\n                 \"seq\",\n                 [\"assert\", [\"le\", [\"add\", start, length], \"calldatasize\"]],  # runtime bounds check\n@@ -295,6 +295,14 @@ def build_LLL(self, expr, args, kwargs, context):\n                 np,\n             ]\n             return LLLnode.from_list(node, typ=ByteArrayType(length.value), location=\"memory\")\n+\n+        # Copy over bytearray data\n+        # CMC 20210917 how does this routine work?\n+\n+        if sub.location == \"storage\":\n+            adj_sub = LLLnode.from_list(\n+                [\"add\", sub, [\"add\", [\"div\", \"_start\", 32], 1]], typ=sub.typ, location=sub.location,\n+            )\n         else:\n             adj_sub = LLLnode.from_list(\n                 [\"add\", sub, [\"add\", [\"sub\", \"_start\", [\"mod\", \"_start\", 32]], 32]],\n@@ -308,16 +316,17 @@ def build_LLL(self, expr, args, kwargs, context):\n         copier = make_byte_slice_copier(\n             placeholder_plus_32_node,\n             adj_sub,\n-            [\"add\", \"_length\", 32],\n+            [\"add\", \"_length\", 32],  # CMC 20210917 shouldn't this just be _length\n             sub_typ_maxlen,\n             pos=getpos(expr),\n         )\n+\n         # New maximum length in the type of the result\n         newmaxlen = length.value if not len(length.args) else sub_typ_maxlen\n         if is_base_type(sub.typ, \"bytes32\"):\n             maxlen = 32\n         else:\n-            maxlen = [\"mload\", Expr(sub, context=context).lll_node]  # Retrieve length of the bytes.\n+            maxlen = get_bytearray_length(sub)\n \n         out = [\n             \"with\",\n@@ -465,8 +474,10 @@ def build_LLL(self, expr, context):\n                 if arg.typ.maxlen == 0:\n                     continue\n                 # Get the length of the current argument\n-                if arg.location == \"memory\":\n-                    length = LLLnode.from_list([\"mload\", \"_arg\"], typ=BaseType(\"int128\"))\n+                if arg.location in (\"memory\", \"calldata\", \"code\"):\n+                    length = LLLnode.from_list(\n+                        [load_op(arg.location), \"_arg\"], typ=BaseType(\"int128\")\n+                    )\n                     argstart = LLLnode.from_list(\n                         [\"add\", \"_arg\", 32], typ=arg.typ, location=arg.location,\n                     )\n@@ -602,24 +613,18 @@ def build_LLL(self, expr, args, kwargs, context):\n                 add_gas_estimate=SHA256_BASE_GAS + 1 * SHA256_PER_WORD_GAS,\n             )\n         # bytearay-like input\n-        if sub.location == \"storage\":\n-            # Copy storage to memory\n-            placeholder = context.new_internal_variable(sub.typ)\n-            placeholder_node = LLLnode.from_list(placeholder, typ=sub.typ, location=\"memory\")\n-            copier = make_byte_array_copier(\n-                placeholder_node, LLLnode.from_list(\"_sub\", typ=sub.typ, location=sub.location),\n-            )\n+        # special case if it's already in memory\n+        if sub.location == \"memory\":\n             return LLLnode.from_list(\n                 [\n                     \"with\",\n                     \"_sub\",\n                     sub,\n                     [\n                         \"seq\",\n-                        copier,\n                         _make_sha256_call(\n-                            inp_start=[\"add\", placeholder, 32],\n-                            inp_len=[\"mload\", placeholder],\n+                            inp_start=[\"add\", \"_sub\", 32],\n+                            inp_len=[\"mload\", \"_sub\"],\n                             out_start=MemoryPositions.FREE_VAR_SPACE,\n                             out_len=32,\n                         ),\n@@ -630,17 +635,24 @@ def build_LLL(self, expr, args, kwargs, context):\n                 pos=getpos(expr),\n                 add_gas_estimate=SHA256_BASE_GAS + sub.typ.maxlen * SHA256_PER_WORD_GAS,\n             )\n-        elif sub.location == \"memory\":\n+        else:\n+            # otherwise, copy it to memory and then call the precompile\n+            placeholder = context.new_internal_variable(sub.typ)\n+            placeholder_node = LLLnode.from_list(placeholder, typ=sub.typ, location=\"memory\")\n+            copier = make_byte_array_copier(\n+                placeholder_node, LLLnode.from_list(\"_sub\", typ=sub.typ, location=sub.location),\n+            )\n             return LLLnode.from_list(\n                 [\n                     \"with\",\n                     \"_sub\",\n                     sub,\n                     [\n                         \"seq\",\n+                        copier,\n                         _make_sha256_call(\n-                            inp_start=[\"add\", \"_sub\", 32],\n-                            inp_len=[\"mload\", \"_sub\"],\n+                            inp_start=[\"add\", placeholder, 32],\n+                            inp_len=[\"mload\", placeholder],\n                             out_start=MemoryPositions.FREE_VAR_SPACE,\n                             out_len=32,\n                         ),\n@@ -651,9 +663,6 @@ def build_LLL(self, expr, args, kwargs, context):\n                 pos=getpos(expr),\n                 add_gas_estimate=SHA256_BASE_GAS + sub.typ.maxlen * SHA256_PER_WORD_GAS,\n             )\n-        else:\n-            # This should never happen, but just left here for future compiler-writers.\n-            raise Exception(f\"Unsupported location: {sub.location}\")  # pragma: no test\n \n \n class MethodID:\n@@ -742,8 +751,8 @@ def build_LLL(self, expr, args, kwargs, context):\n         )\n \n \n-def avo(arg, ind, pos):\n-    return unwrap_location(add_variable_offset(arg, LLLnode.from_list(ind, \"int128\"), pos=pos))\n+def _getelem(arg, ind, pos):\n+    return unwrap_location(get_element_ptr(arg, LLLnode.from_list(ind, \"int128\"), pos=pos))\n \n \n class ECAdd(_SimpleBuiltinFunction):\n@@ -766,10 +775,10 @@ def build_LLL(self, expr, args, kwargs, context):\n         o = LLLnode.from_list(\n             [\n                 \"seq\",\n-                [\"mstore\", placeholder_node, avo(args[0], 0, pos)],\n-                [\"mstore\", [\"add\", placeholder_node, 32], avo(args[0], 1, pos)],\n-                [\"mstore\", [\"add\", placeholder_node, 64], avo(args[1], 0, pos)],\n-                [\"mstore\", [\"add\", placeholder_node, 96], avo(args[1], 1, pos)],\n+                [\"mstore\", placeholder_node, _getelem(args[0], 0, pos)],\n+                [\"mstore\", [\"add\", placeholder_node, 32], _getelem(args[0], 1, pos)],\n+                [\"mstore\", [\"add\", placeholder_node, 64], _getelem(args[1], 0, pos)],\n+                [\"mstore\", [\"add\", placeholder_node, 96], _getelem(args[1], 1, pos)],\n                 [\"assert\", [\"staticcall\", [\"gas\"], 6, placeholder_node, 128, placeholder_node, 64]],\n                 placeholder_node,\n             ],\n@@ -797,8 +806,8 @@ def build_LLL(self, expr, args, kwargs, context):\n         o = LLLnode.from_list(\n             [\n                 \"seq\",\n-                [\"mstore\", placeholder_node, avo(args[0], 0, pos)],\n-                [\"mstore\", [\"add\", placeholder_node, 32], avo(args[0], 1, pos)],\n+                [\"mstore\", placeholder_node, _getelem(args[0], 0, pos)],\n+                [\"mstore\", [\"add\", placeholder_node, 32], _getelem(args[0], 1, pos)],\n                 [\"mstore\", [\"add\", placeholder_node, 64], args[1]],\n                 [\"assert\", [\"staticcall\", [\"gas\"], 7, placeholder_node, 96, placeholder_node, 64]],\n                 placeholder_node,\n@@ -810,10 +819,13 @@ def build_LLL(self, expr, args, kwargs, context):\n         return o\n \n \n-def _memory_element_getter(index):\n-    return LLLnode.from_list(\n-        [\"mload\", [\"add\", \"_sub\", [\"add\", 32, [\"mul\", 32, index]]]], typ=BaseType(\"int128\"),\n-    )\n+def _generic_element_getter(op):\n+    def f(index):\n+        return LLLnode.from_list(\n+            [op, [\"add\", \"_sub\", [\"add\", 32, [\"mul\", 32, index]]]], typ=BaseType(\"int128\"),\n+        )\n+\n+    return f\n \n \n def _storage_element_getter(index):\n@@ -845,14 +857,14 @@ def build_LLL(self, expr, args, kwargs, context):\n         sub, index = args\n         ret_type = kwargs[\"output_type\"]\n         # Get length and specific element\n-        if sub.location == \"memory\":\n-            lengetter = LLLnode.from_list([\"mload\", \"_sub\"], typ=BaseType(\"int128\"))\n-            elementgetter = _memory_element_getter\n-        elif sub.location == \"storage\":\n+        if sub.location == \"storage\":\n             lengetter = LLLnode.from_list([\"sload\", \"_sub\"], typ=BaseType(\"int128\"))\n             elementgetter = _storage_element_getter\n-        # TODO: unclosed if/elif clause.  Undefined behavior if `sub.location`\n-        # isn't one of `memory`/`storage`\n+\n+        else:\n+            op = load_op(sub.location)\n+            lengetter = LLLnode.from_list([op, \"_sub\"], typ=BaseType(\"int128\"))\n+            elementgetter = _generic_element_getter(op)\n \n         # Special case: index known to be a multiple of 32\n         if isinstance(index.value, int) and not index.value % 32:\n@@ -1492,7 +1504,7 @@ def build_LLL(self, expr, context):\n \n \n def get_create_forwarder_to_bytecode():\n-    # FLAG cyclic import?\n+    # NOTE cyclic import?\n     from vyper.lll.compile_lll import assembly_to_evm\n \n     loader_asm = [\n@@ -1757,7 +1769,8 @@ class ABIEncode(_SimpleBuiltinFunction):\n     # to handle varargs.)\n     # explanation of ensure_tuple:\n     # default is to force even a single value into a tuple,\n-    # e.g. _abi_encode(bytes) -> abi_encode((bytes,))\n+    # e.g. _abi_encode(bytes) -> _abi_encode((bytes,))\n+    #      _abi_encode((bytes,)) -> _abi_encode(((bytes,),))\n     # this follows the encoding convention for functions:\n     # ://docs.soliditylang.org/en/v0.8.6/abi-spec.html#function-selector-and-argument-encoding\n     # if this is turned off, then bytes will be encoded as bytes.\n@@ -1828,6 +1841,7 @@ def fetch_call_return(self, node):\n         maxlen = arg_abi_t.size_bound()\n \n         if self._method_id(node) is not None:\n+            # the output includes 4 bytes for the method_id.\n             maxlen += 4\n \n         ret = BytesArrayDefinition()\n@@ -1851,6 +1865,8 @@ def build_LLL(self, expr, context):\n \n         input_abi_t = abi_type_of(encode_input.typ)\n         maxlen = input_abi_t.size_bound()\n+        if method_id is not None:\n+            maxlen += 4\n \n         buf_t = ByteArrayType(maxlen=maxlen)\n         buf = context.new_internal_variable(buf_t)\n@@ -1859,6 +1875,7 @@ def build_LLL(self, expr, context):\n \n         ret = [\"seq\"]\n         if method_id is not None:\n+            # <32 bytes length> | <4 bytes method_id> | <everything else>\n             # write the unaligned method_id first, then we will\n             # overwrite the 28 bytes of zeros with the bytestring length\n             ret += [[\"mstore\", buf + 4, method_id]]"
        },
        {
          "filename": "vyper/evm/opcodes.py",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -209,7 +209,6 @@\n     \"NE\": (None, 2, 1, 6),\n     \"DEBUGGER\": (None, 0, 0, 0),\n     \"LABEL\": (None, 1, 0, 1),\n-    \"GOTO\": (None, 1, 0, 8),\n }\n \n COMB_OPCODES: OpcodeMap = {**OPCODES, **PSEUDO_OPCODES}"
        },
        {
          "filename": "vyper/lll/compile_lll.py",
          "status": "modified",
          "additions": 56,
          "deletions": 10,
          "patch": "@@ -493,9 +493,13 @@ def _compile_to_assembly(code, withargs=None, existing_labels=None, break_dest=N\n             break_dest,\n             height,\n         )\n-    # # jump to a symbol\n+    # # jump to a symbol, and push variable arguments onto stack\n     elif code.value == \"goto\":\n-        return [\"_sym_\" + str(code.args[0]), \"JUMP\"]\n+        o = []\n+        for i, c in enumerate(reversed(code.args[1:])):\n+            o.extend(_compile_to_assembly(c, withargs, existing_labels, break_dest, height + i))\n+        o.extend([\"_sym_\" + str(code.args[0]), \"JUMP\"])\n+        return o\n     elif isinstance(code.value, str) and is_symbol(code.value):\n         return [code.value]\n     # set a symbol as a location.\n@@ -557,6 +561,22 @@ def _prune_unreachable_code(assembly):\n             i += 1\n \n \n+def _prune_inefficient_jumps(assembly):\n+    # prune sequences `_sym_x JUMP _sym_x JUMPDEST` to `_sym_x JUMPDEST`\n+    i = 0\n+    while i < len(assembly) - 4:\n+        if (\n+            is_symbol(assembly[i])\n+            and assembly[i + 1] == \"JUMP\"\n+            and assembly[i] == assembly[i + 2]\n+            and assembly[i + 3] == \"JUMPDEST\"\n+        ):\n+            # delete _sym_x JUMP\n+            del assembly[i : i + 2]  # noqa: E203\n+        else:\n+            i += 1\n+\n+\n def _merge_jumpdests(assembly):\n     # When a nested subroutine finishes and is the final action within it's\n     # parent subroutine, we end up with multiple simultaneous JUMPDEST\n@@ -593,13 +613,35 @@ def _merge_iszero(assembly):\n             i += 1\n \n \n-# Assembles assembly into EVM\n-def assembly_to_evm(assembly, start_pos=0):\n-    _prune_unreachable_code(assembly)\n+def _prune_unused_jumpdests(assembly):\n+    used_jumpdests = set()\n \n-    _merge_iszero(assembly)\n+    # find all used jumpdests\n+    for i in range(len(assembly) - 1):\n+        if is_symbol(assembly[i]) and assembly[i + 1] != \"JUMPDEST\":\n+            used_jumpdests.add(assembly[i])\n+\n+    # delete jumpdests that aren't used\n+    i = 0\n+    while i < len(assembly) - 2:\n+        if is_symbol(assembly[i]) and assembly[i] not in used_jumpdests:\n+            del assembly[i : i + 2]  # noqa: E203\n+        else:\n+            i += 1\n \n+\n+# optimize assembly, in place\n+def _optimize_assembly(assembly):\n+    _prune_unreachable_code(assembly)\n+    _merge_iszero(assembly)\n     _merge_jumpdests(assembly)\n+    _prune_inefficient_jumps(assembly)\n+    _prune_unused_jumpdests(assembly)\n+\n+\n+# Assembles assembly into EVM\n+def assembly_to_evm(assembly, start_pos=0):\n+    _optimize_assembly(assembly)\n \n     line_number_map = {\n         \"breakpoints\": set(),\n@@ -622,11 +664,15 @@ def assembly_to_evm(assembly, start_pos=0):\n \n         if item == \"JUMP\":\n             last = assembly[i - 1]\n-            if last == \"MLOAD\":\n-                line_number_map[\"pc_jump_map\"][pos] = \"o\"\n-            elif is_symbol(last) and \"_priv_\" in last:\n-                line_number_map[\"pc_jump_map\"][pos] = \"i\"\n+            if is_symbol(last) and last.startswith(\"_sym_internal\"):\n+                if last.endswith(\"cleanup\"):\n+                    # exit an internal function\n+                    line_number_map[\"pc_jump_map\"][pos] = \"o\"\n+                else:\n+                    # enter an internal function\n+                    line_number_map[\"pc_jump_map\"][pos] = \"i\"\n             else:\n+                # everything else\n                 line_number_map[\"pc_jump_map\"][pos] = \"-\"\n         elif item in (\"JUMPI\", \"JUMPDEST\"):\n             line_number_map[\"pc_jump_map\"][pos] = \"-\""
        },
        {
          "filename": "vyper/lll/optimizer.py",
          "status": "modified",
          "additions": 1,
          "deletions": 18,
          "patch": "@@ -1,5 +1,5 @@\n import operator\n-from typing import Any, List, Optional\n+from typing import List, Optional\n \n from vyper.old_codegen.parser_utils import LLLnode\n from vyper.utils import LOADED_LIMITS\n@@ -191,23 +191,6 @@ def apply_general_optimizations(node: LLLnode) -> LLLnode:\n             annotation=node.annotation,\n             # let from_list handle valency and gas_estimate\n         )\n-    elif node.value == \"seq\":\n-        xs: List[Any] = []\n-        for arg in argz:\n-            if arg.value == \"seq\":\n-                xs.extend(arg.args)\n-            else:\n-                xs.append(arg)\n-        return LLLnode(\n-            node.value,\n-            xs,\n-            node.typ,\n-            node.location,\n-            node.pos,\n-            node.annotation,\n-            add_gas_estimate=node.add_gas_estimate,\n-            valency=node.valency,\n-        )\n     elif node.total_gas is not None:\n         o = LLLnode(\n             node.value,"
        },
        {
          "filename": "vyper/old_codegen/abi.py",
          "status": "modified",
          "additions": 106,
          "deletions": 87,
          "patch": "@@ -1,8 +1,10 @@\n import vyper.semantics.types as vy\n from vyper.exceptions import CompilerPanic\n-from vyper.old_codegen.lll_node import LLLnode\n+from vyper.old_codegen.lll_node import Encoding, LLLnode\n from vyper.old_codegen.parser_utils import (\n-    add_variable_offset,\n+    _needs_clamp,\n+    clamp_basetype,\n+    get_element_ptr,\n     make_setter,\n     unwrap_location,\n     zero_pad,\n@@ -14,7 +16,6 @@\n     ListType,\n     StringType,\n     TupleLike,\n-    TupleType,\n )\n from vyper.utils import ceil32\n \n@@ -26,30 +27,55 @@ def is_dynamic(self):\n         raise NotImplementedError(\"ABIType.is_dynamic\")\n \n     # size (in bytes) in the static section (aka 'head')\n-    # when embedded in a tuple.\n+    # when embedded in a complex type.\n     def embedded_static_size(self):\n         return 32 if self.is_dynamic() else self.static_size()\n \n+    # size bound in the dynamic section (aka 'tail')\n+    # when embedded in a complex type.\n+    def embedded_dynamic_size_bound(self):\n+        if not self.is_dynamic():\n+            return 0\n+        return self.size_bound()\n+\n+    def embedded_min_dynamic_size(self):\n+        if not self.is_dynamic():\n+            return 0\n+        return self.min_size()\n+\n     # size (in bytes) of the static section\n     def static_size(self):\n         raise NotImplementedError(\"ABIType.static_size\")\n \n     # max size (in bytes) in the dynamic section (aka 'tail')\n     def dynamic_size_bound(self):\n-        return 0\n+        if not self.is_dynamic():\n+            return 0\n+        raise NotImplementedError(\"ABIType.dynamic_size_bound\")\n \n     def size_bound(self):\n         return self.static_size() + self.dynamic_size_bound()\n \n+    def min_size(self):\n+        return self.static_size() + self.min_dynamic_size()\n+\n+    def min_dynamic_size(self):\n+        if not self.is_dynamic():\n+            return 0\n+        raise NotImplementedError(\"ABIType.min_dynamic_size\")\n+\n     # The canonical name of the type for calculating the function selector\n     def selector_name(self):\n         raise NotImplementedError(\"ABIType.selector_name\")\n \n     # Whether the type is a tuple at the ABI level.\n     # (This is important because if it does, it needs an offset.\n     #   Compare the difference in encoding between `bytes` and `(bytes,)`.)\n-    def is_tuple(self):\n-        raise NotImplementedError(\"ABIType.is_tuple\")\n+    def is_complex_type(self):\n+        raise NotImplementedError(\"ABIType.is_complex_type\")\n+\n+    def __repr__(self):\n+        return str({type(self).__name__: vars(self)})\n \n \n # uint<M>: unsigned integer type of M bits, 0 < M <= 256, M % 8 == 0. e.g. uint32, uint8, uint256.\n@@ -71,7 +97,7 @@ def static_size(self):\n     def selector_name(self):\n         return (\"\" if self.signed else \"u\") + f\"int{self.m_bits}\"\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return False\n \n \n@@ -122,7 +148,7 @@ def static_size(self):\n     def selector_name(self):\n         return (\"\" if self.signed else \"u\") + \"fixed{self.m_bits}x{self.n_places}\"\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return False\n \n \n@@ -143,7 +169,7 @@ def static_size(self):\n     def selector_name(self):\n         return f\"bytes{self.m_bytes}\"\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return False\n \n \n@@ -173,12 +199,15 @@ def static_size(self):\n         return self.m_elems * self.subtyp.static_size()\n \n     def dynamic_size_bound(self):\n-        return self.m_elems * self.subtyp.dynamic_size_bound()\n+        return self.m_elems * self.subtyp.embedded_dynamic_size_bound()\n+\n+    def min_dynamic_size(self):\n+        return self.m_elems * self.subtyp.embedded_min_dynamic_size()\n \n     def selector_name(self):\n         return f\"{self.subtyp.selector_name()}[{self.m_elems}]\"\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return True\n \n \n@@ -201,10 +230,13 @@ def dynamic_size_bound(self):\n         # length word + data\n         return 32 + ceil32(self.bytes_bound)\n \n+    def min_dynamic_size(self):\n+        return 32\n+\n     def selector_name(self):\n         return \"bytes\"\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return False\n \n \n@@ -228,12 +260,17 @@ def static_size(self):\n         return 32\n \n     def dynamic_size_bound(self):\n-        return self.subtyp.dynamic_size_bound() * self.elems_bound\n+        # TODO double check me\n+        return self.subtyp.embedded_dynamic_size_bound() * self.elems_bound\n+\n+    def min_dynamic_size(self):\n+        # TODO double check me\n+        return 32\n \n     def selector_name(self):\n         return f\"{self.subtyp.selector_name()}[]\"\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return False\n \n \n@@ -248,9 +285,12 @@ def static_size(self):\n         return sum([t.embedded_static_size() for t in self.subtyps])\n \n     def dynamic_size_bound(self):\n-        return sum([t.dynamic_size_bound() for t in self.subtyps])\n+        return sum([t.embedded_dynamic_size_bound() for t in self.subtyps])\n+\n+    def min_dynamic_size(self):\n+        return sum([t.embedded_min_dynamic_size() for t in self.subtyps])\n \n-    def is_tuple(self):\n+    def is_complex_type(self):\n         return True\n \n \n@@ -285,12 +325,6 @@ def abi_type_of(lll_typ):\n         raise CompilerPanic(f\"Unrecognized type {lll_typ}\")\n \n \n-# utility function, constructs an LLL tuple out of a list of LLL nodes\n-def lll_tuple_from_args(args):\n-    typ = TupleType([x.typ for x in args])\n-    return LLLnode.from_list([\"multi\"] + [x for x in args], typ=typ)\n-\n-\n # the new type system\n # TODO consider moving these into properties of the type itself\n def abi_type_of2(t: vy.BasePrimitive) -> ABIType:\n@@ -317,14 +351,6 @@ def abi_type_of2(t: vy.BasePrimitive) -> ABIType:\n     raise CompilerPanic(f\"Unrecognized type {t}\")\n \n \n-# there are a lot of places in the calling convention where a tuple\n-# must be passed, so here's a convenience function for that.\n-def ensure_tuple(abi_typ):\n-    if not abi_typ.is_tuple():\n-        return ABI_Tuple([abi_typ])\n-    return abi_typ\n-\n-\n # turn an lll node into a list, based on its type.\n def o_list(lll_node, pos=None):\n     lll_t = lll_node.typ\n@@ -338,7 +364,7 @@ def o_list(lll_node, pos=None):\n                 else [LLLnode.from_list(i, \"uint256\") for i in range(lll_t.count)]\n             )\n \n-            ret = [add_variable_offset(lll_node, k, pos, array_bounds_check=False) for k in ks]\n+            ret = [get_element_ptr(lll_node, k, pos, array_bounds_check=False) for k in ks]\n         return ret\n     else:\n         return [lll_node]\n@@ -382,16 +408,38 @@ def abi_encode(dst, lll_node, pos=None, bufsz=None, returns_len=False):\n     if bufsz is not None and bufsz < 32 * size_bound:\n         raise CompilerPanic(\"buffer provided to abi_encode not large enough\")\n \n+    # fastpath: if there is no dynamic data, we can optimize the\n+    # encoding by using make_setter, since our memory encoding happens\n+    # to be identical to the ABI encoding.\n+    if not parent_abi_t.is_dynamic():\n+        # cast the output buffer to something that make_setter accepts\n+        dst = LLLnode(dst, typ=lll_node.typ, location=\"memory\")\n+        lll_ret = [\"seq\", make_setter(dst, lll_node, \"memory\", pos)]\n+        if returns_len:\n+            lll_ret.append(parent_abi_t.embedded_static_size())\n+        return LLLnode.from_list(lll_ret, pos=pos, annotation=f\"abi_encode {lll_node.typ}\")\n+\n     lll_ret = [\"seq\"]\n+\n+    # contains some computation, we need to only do it once.\n+    if lll_node.is_complex_lll:\n+        to_encode = LLLnode.from_list(\n+            \"to_encode\", typ=lll_node.typ, location=lll_node.location, encoding=lll_node.encoding\n+        )\n+    else:\n+        to_encode = lll_node\n+\n     dyn_ofst = \"dyn_ofst\"  # current offset in the dynamic section\n     dst_begin = \"dst\"  # pointer to beginning of buffer\n     dst_loc = \"dst_loc\"  # pointer to write location in static section\n-    os = o_list(lll_node, pos=pos)\n+    os = o_list(to_encode, pos=pos)\n \n     for i, o in enumerate(os):\n         abi_t = abi_type_of(o.typ)\n \n-        if parent_abi_t.is_tuple():\n+        if parent_abi_t.is_complex_type():\n+            # TODO optimize: special case where there is only one dynamic\n+            # member, the location is statically known.\n             if abi_t.is_dynamic():\n                 lll_ret.append([\"mstore\", dst_loc, dyn_ofst])\n                 # recurse\n@@ -408,9 +456,11 @@ def abi_encode(dst, lll_node, pos=None, bufsz=None, returns_len=False):\n \n         elif isinstance(o.typ, BaseType):\n             d = LLLnode(dst_loc, typ=o.typ, location=\"memory\")\n+            # call into make_setter routine\n             lll_ret.append(make_setter(d, o, location=d.location, pos=pos))\n         elif isinstance(o.typ, ByteArrayLike):\n             d = LLLnode.from_list(dst_loc, typ=o.typ, location=\"memory\")\n+            # call into make_setter routinme\n             lll_ret.append([\"seq\", make_setter(d, o, location=d.location, pos=pos), zero_pad(d)])\n         else:\n             raise CompilerPanic(f\"unreachable type: {o.typ}\")\n@@ -425,7 +475,7 @@ def abi_encode(dst, lll_node, pos=None, bufsz=None, returns_len=False):\n     if returns_len:\n         if not parent_abi_t.is_dynamic():\n             lll_ret.append(parent_abi_t.embedded_static_size())\n-        elif parent_abi_t.is_tuple():\n+        elif parent_abi_t.is_complex_type():\n             lll_ret.append(\"dyn_ofst\")\n         elif isinstance(lll_node.typ, ByteArrayLike):\n             # for abi purposes, return zero-padded length\n@@ -434,37 +484,53 @@ def abi_encode(dst, lll_node, pos=None, bufsz=None, returns_len=False):\n         else:\n             raise CompilerPanic(\"unknown type {lll_node.typ}\")\n \n-    if not (parent_abi_t.is_dynamic() and parent_abi_t.is_tuple()):\n+    if not (parent_abi_t.is_dynamic() and parent_abi_t.is_complex_type()):\n         pass  # optimize out dyn_ofst allocation if we don't need it\n     else:\n         dyn_section_start = parent_abi_t.static_size()\n         lll_ret = [\"with\", \"dyn_ofst\", dyn_section_start, lll_ret]\n \n     lll_ret = [\"with\", dst_begin, dst, [\"with\", dst_loc, dst_begin, lll_ret]]\n \n-    return LLLnode.from_list(lll_ret, pos=pos)\n+    if lll_node.is_complex_lll:\n+        lll_ret = [\"with\", to_encode, lll_node, lll_ret]\n+\n+    return LLLnode.from_list(lll_ret, pos=pos, annotation=f\"abi_encode {lll_node.typ}\")\n \n \n # lll_node is the destination LLL item, src is the input buffer.\n # recursively copy the buffer items into lll_node, based on its type.\n # src: pointer to beginning of buffer\n # src_loc: pointer to read location in static section\n-def abi_decode(lll_node, src, pos=None):\n+def abi_decode(lll_node, src, clamp=True, pos=None):\n     os = o_list(lll_node, pos=pos)\n     lll_ret = [\"seq\"]\n     parent_abi_t = abi_type_of(lll_node.typ)\n     for i, o in enumerate(os):\n         abi_t = abi_type_of(o.typ)\n         src_loc = LLLnode(\"src_loc\", typ=o.typ, location=src.location)\n-        if parent_abi_t.is_tuple():\n+        if parent_abi_t.is_complex_type():\n             if abi_t.is_dynamic():\n+                # TODO optimize: special case where there is only one dynamic\n+                # member, the location is statically known.\n                 child_loc = [\"add\", \"src\", unwrap_location(src_loc)]\n                 child_loc = LLLnode.from_list(child_loc, typ=o.typ, location=src.location)\n             else:\n                 child_loc = src_loc\n             # descend into the child tuple\n-            lll_ret.append(abi_decode(o, child_loc, pos=pos))\n+            lll_ret.append(abi_decode(o, child_loc, clamp=clamp, pos=pos))\n+\n         else:\n+\n+            if clamp and _needs_clamp(o.typ, Encoding.ABI):\n+                src_loc = LLLnode.from_list(\n+                    [\"with\", \"src_loc\", src_loc, [\"seq\", clamp_basetype(src_loc), src_loc]],\n+                    typ=src_loc.typ,\n+                    location=src_loc.location,\n+                )\n+            else:\n+                pass\n+\n             lll_ret.append(make_setter(o, src_loc, location=o.location, pos=pos))\n \n         if i + 1 == len(os):\n@@ -476,50 +542,3 @@ def abi_decode(lll_node, src, pos=None):\n     lll_ret = [\"with\", \"src\", src, [\"with\", \"src_loc\", \"src\", lll_ret]]\n \n     return lll_ret\n-\n-\n-def _add_ofst(loc, ofst):\n-    if isinstance(loc.value, int):\n-        return LLLnode(loc.value + ofst)\n-    return [\"add\", loc, ofst]\n-\n-\n-# decode a buffer containing abi-encoded data structure in place\n-# for dynamical data, a layer of indirection will be\n-# added for every level of nesting. for instance,\n-# `lazy_abi_decode(<int128>, <320>)`\n-# might return (mload 320),\n-# whereas\n-# `lazy_abi_decode(<(int128,bytes)>, <320>)`\n-# might return\n-# (multi\n-#   (mload 320/*int128*/)\n-#   (mload (add 320/*buf start*/ (mload 352/*ofst loc*/))))\n-# thought of the day: it might be nice to have an argument like `sanitize`\n-# which will add well-formedness checks (clamps) for all inputs.\n-def lazy_abi_decode(typ, src, pos=None):\n-    if isinstance(typ, (ListType, TupleLike)):\n-        if isinstance(typ, TupleLike):\n-            ts = typ.tuple_members()\n-        else:\n-            ts = [typ.subtyp for _ in range(typ.count)]\n-        ofst = 0\n-        os = []\n-        for t in ts:\n-            child_abi_t = abi_type_of(t)\n-            loc = _add_ofst(src, ofst)\n-            if child_abi_t.is_dynamic():\n-                # load the offset word, which is the\n-                # (location-independent) offset from the start of the\n-                # src buffer.\n-                dyn_ofst = unwrap_location(ofst)\n-                loc = _add_ofst(src, dyn_ofst)\n-            os.append(lazy_abi_decode(t, loc, pos))\n-            ofst += child_abi_t.embedded_static_size()\n-\n-        return LLLnode.from_list([\"multi\"] + os, typ=typ, pos=pos)\n-\n-    elif isinstance(typ, (BaseType, ByteArrayLike)):\n-        return unwrap_location(src)\n-    else:\n-        raise CompilerPanic(f\"unknown type for lazy_abi_decode {typ}\")"
        },
        {
          "filename": "vyper/old_codegen/arg_clamps.py",
          "status": "modified",
          "additions": 27,
          "deletions": 141,
          "patch": "@@ -1,155 +1,41 @@\n-import functools\n-import uuid\n-\n from vyper.evm.opcodes import version_check\n-from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.types.types import (\n-    ByteArrayLike,\n-    ListType,\n-    get_size_of_type,\n-    is_base_type,\n-)\n-from vyper.utils import MemoryPositions\n-\n-\n-def _mk_calldatacopy_copier(pos, sz, mempos):\n-    return [\"calldatacopy\", mempos, [\"add\", 4, pos], sz]\n-\n-\n-def _mk_codecopy_copier(pos, sz, mempos):\n-    return [\"codecopy\", mempos, [\"add\", \"~codelen\", pos], sz]\n-\n \n-def make_arg_clamper(datapos, mempos, typ, is_init=False):\n-    \"\"\"\n-    Clamps argument to type limits.\n+# TODO this whole module should be replaced with parser_utils.clamp_basetype\n \n-    Arguments\n-    ---------\n-    datapos : int | LLLnode\n-        Calldata offset of the value being clamped\n-    mempos : int | LLLnode\n-        Memory offset that the value is stored at during clamping\n-    typ : vyper.types.types.BaseType\n-        Type of the value\n-    is_init : bool, optional\n-        Boolean indicating if we are generating init bytecode\n \n-    Returns\n-    -------\n-    LLLnode\n-        Arg clamper LLL\n-    \"\"\"\n-\n-    if not is_init:\n-        data_decl = [\"calldataload\", [\"add\", 4, datapos]]\n-        copier = functools.partial(_mk_calldatacopy_copier, mempos=mempos)\n-    else:\n-        data_decl = [\"codeload\", [\"add\", \"~codelen\", datapos]]\n-        copier = functools.partial(_mk_codecopy_copier, mempos=mempos)\n-    # Numbers: make sure they're in range\n-    if is_base_type(typ, \"int128\"):\n-        return LLLnode.from_list(\n-            int128_clamp(data_decl), typ=typ, annotation=\"checking int128 input\"\n-        )\n-    # Booleans: make sure they're zero or one\n-    elif is_base_type(typ, \"bool\"):\n-        if version_check(begin=\"constantinople\"):\n-            lll = [\"assert\", [\"iszero\", [\"shr\", 1, data_decl]]]\n-        else:\n-            lll = [\"uclamplt\", data_decl, 2]\n-        return LLLnode.from_list(lll, typ=typ, annotation=\"checking bool input\")\n-    # Addresses: make sure they're in range\n-    elif is_base_type(typ, \"address\"):\n-        return LLLnode.from_list(\n-            address_clamp(data_decl), typ=typ, annotation=\"checking address input\"\n-        )\n-    # Bytes: make sure they have the right size\n-    elif isinstance(typ, ByteArrayLike):\n-        return LLLnode.from_list(\n-            [\n-                \"seq\",\n-                copier(data_decl, 32 + typ.maxlen),\n-                [\"assert\", [\"le\", [\"calldataload\", [\"add\", 4, data_decl]], typ.maxlen]],\n-            ],\n-            typ=None,\n-            annotation=\"checking bytearray input\",\n-        )\n-    # Lists: recurse\n-    elif isinstance(typ, ListType):\n-        if typ.count > 5 or (type(datapos) is list and type(mempos) is list):\n-            # find ultimate base type\n-            subtype = typ.subtype\n-            while hasattr(subtype, \"subtype\"):\n-                subtype = subtype.subtype\n-\n-            # make arg clamper for the base type\n-            offset = MemoryPositions.FREE_LOOP_INDEX\n-            clamper = make_arg_clamper(\n-                [\"add\", datapos, [\"mload\", offset]],\n-                [\"add\", mempos, [\"mload\", offset]],\n-                subtype,\n-                is_init,\n-            )\n-            if clamper.value == \"pass\":\n-                # no point looping if the base type doesn't require clamping\n-                return clamper\n+def _shr(x, bits):\n+    if version_check(begin=\"constantinople\"):\n+        return [\"shr\", bits, x]\n+    return [\"div\", x, [\"exp\", 2, bits]]\n \n-            # loop the entire array at once, even if it's multidimensional\n-            type_size = get_size_of_type(typ)\n-            i_incr = get_size_of_type(subtype) * 32\n \n-            mem_to = type_size * 32\n-            loop_label = f\"_check_list_loop_{str(uuid.uuid4())}\"\n+def _sar(x, bits):\n+    if version_check(begin=\"constantinople\"):\n+        return [\"sar\", bits, x]\n \n-            lll_node = [\n-                [\"mstore\", offset, 0],  # init loop\n-                [\"label\", loop_label],\n-                clamper,\n-                [\"mstore\", offset, [\"add\", [\"mload\", offset], i_incr]],\n-                [\"if\", [\"lt\", [\"mload\", offset], mem_to], [\"goto\", loop_label]],\n-            ]\n-        else:\n-            lll_node = []\n-            for i in range(typ.count):\n-                offset = get_size_of_type(typ.subtype) * 32 * i\n-                lll_node.append(\n-                    make_arg_clamper(datapos + offset, mempos + offset, typ.subtype, is_init)\n-                )\n-        return LLLnode.from_list([\"seq\"] + lll_node, typ=None, annotation=\"checking list input\")\n-    # Otherwise don't make any checks\n-    else:\n-        return LLLnode.from_list(\"pass\")\n+    # emulate for older arches. keep in mind note from EIP 145:\n+    # This is not equivalent to PUSH1 2 EXP SDIV, since it rounds\n+    # differently. See SDIV(-1, 2) == 0, while SAR(-1, 1) == -1.\n+    return [\"sdiv\", [\"add\", [\"slt\", x, 0], x], [\"exp\", 2, bits]]\n \n \n def address_clamp(lll_node):\n-    if version_check(begin=\"constantinople\"):\n-        return [\"assert\", [\"iszero\", [\"shr\", 160, lll_node]]]\n-    else:\n-        return [\"uclamplt\", lll_node, [\"mload\", MemoryPositions.ADDRSIZE]]\n+    return [\"assert\", [\"iszero\", _shr(lll_node, 160)]]\n \n \n def int128_clamp(lll_node):\n-    if version_check(begin=\"constantinople\"):\n-        return [\n-            \"with\",\n+    return [\n+        \"with\",\n+        \"_val\",\n+        lll_node,\n+        [\n+            \"seq\",\n+            # if _val is in bounds,\n+            # _val >>> 127 == 0 for positive _val\n+            # _val >>> 127 == -1 for negative _val\n+            # -1 and 0 are the only numbers which are unchanged by sar,\n+            # so sar'ing (_val>>>127) one more bit should leave it unchanged.\n+            [\"assert\", [\"eq\", _sar(\"_val\", 128), _sar(\"_val\", 127)]],\n             \"_val\",\n-            lll_node,\n-            [\n-                \"seq\",\n-                # if _val is in bounds,\n-                # _val >>> 127 == 0 for positive _val\n-                # _val >>> 127 == -1 for negative _val\n-                # -1 and 0 are the only numbers which are unchanged by sar,\n-                # so sar'ing (_val>>>127) one more bit should leave it unchanged.\n-                [\"assert\", [\"eq\", [\"sar\", 128, \"_val\"], [\"sar\", 127, \"_val\"]]],\n-                \"_val\",\n-            ],\n-        ]\n-    else:\n-        return [\n-            \"clamp\",\n-            [\"mload\", MemoryPositions.MIN_INT128],\n-            lll_node,\n-            [\"mload\", MemoryPositions.MAX_INT128],\n-        ]\n+        ],\n+    ]"
        },
        {
          "filename": "vyper/old_codegen/context.py",
          "status": "modified",
          "additions": 60,
          "deletions": 7,
          "patch": "@@ -3,7 +3,7 @@\n \n from vyper.ast import VyperNode\n from vyper.ast.signatures.function_signature import VariableRecord\n-from vyper.exceptions import CompilerPanic\n+from vyper.exceptions import CompilerPanic, FunctionDeclarationException\n from vyper.old_codegen.types import NodeType, get_size_of_type\n \n \n@@ -25,7 +25,7 @@ def __init__(\n         constancy=Constancy.Mutable,\n         is_internal=False,\n         is_payable=False,\n-        method_id=\"\",\n+        # method_id=\"\",\n         sig=None,\n     ):\n         # In-memory variables, in the form (name, memory location, type)\n@@ -52,7 +52,7 @@ def __init__(\n         self.callback_ptr = None\n         self.is_internal = is_internal\n         # method_id of current function\n-        self.method_id = method_id\n+        # self.method_id = method_id\n         # store global context\n         self.global_ctx = global_ctx\n         # full function signature\n@@ -64,13 +64,24 @@ def __init__(\n         # Not intended to be accessed directly\n         self.memory_allocator = memory_allocator\n \n+        self._callee_frame_sizes = []\n+\n         # Intermented values, used for internal IDs\n         self._internal_var_iter = 0\n         self._scope_id_iter = 0\n \n     def is_constant(self):\n         return self.constancy is Constancy.Constant or self.in_assertion or self.in_range_expr\n \n+    def register_callee(self, frame_size):\n+        self._callee_frame_sizes.append(frame_size)\n+\n+    @property\n+    def max_callee_frame_size(self):\n+        if len(self._callee_frame_sizes) == 0:\n+            return 0\n+        return max(self._callee_frame_sizes)\n+\n     #\n     # Context Managers\n     # - Context managers are used to ensure proper wrapping of scopes and context states.\n@@ -128,7 +139,9 @@ def block_scope(self):\n         # Remove block scopes\n         self._scopes.remove(scope_id)\n \n-    def _new_variable(self, name: str, typ: NodeType, var_size: int, is_internal: bool) -> int:\n+    def _new_variable(\n+        self, name: str, typ: NodeType, var_size: int, is_internal: bool, is_mutable: bool = True\n+    ) -> int:\n         if is_internal:\n             var_pos = self.memory_allocator.expand_memory(var_size)\n         else:\n@@ -137,13 +150,15 @@ def _new_variable(self, name: str, typ: NodeType, var_size: int, is_internal: bo\n             name=name,\n             pos=var_pos,\n             typ=typ,\n-            mutable=True,\n+            mutable=is_mutable,\n             blockscopes=self._scopes.copy(),\n             is_internal=is_internal,\n         )\n         return var_pos\n \n-    def new_variable(self, name: str, typ: NodeType, pos: VyperNode = None) -> int:\n+    def new_variable(\n+        self, name: str, typ: NodeType, pos: VyperNode = None, is_mutable: bool = True\n+    ) -> int:\n         \"\"\"\n         Allocate memory for a user-defined variable.\n \n@@ -168,8 +183,9 @@ def new_variable(self, name: str, typ: NodeType, pos: VyperNode = None) -> int:\n             var_size = typ.size_in_bytes  # type: ignore\n         else:\n             var_size = 32 * get_size_of_type(typ)\n-        return self._new_variable(name, typ, var_size, False)\n+        return self._new_variable(name, typ, var_size, False, is_mutable=is_mutable)\n \n+    # do we ever allocate immutable internal variables?\n     def new_internal_variable(self, typ: NodeType) -> int:\n         \"\"\"\n         Allocate memory for an internal variable.\n@@ -199,6 +215,43 @@ def new_internal_variable(self, typ: NodeType) -> int:\n     def parse_type(self, ast_node, location):\n         return self.global_ctx.parse_type(ast_node, location)\n \n+    def lookup_var(self, varname):\n+        return self.vars[varname]\n+\n+    def lookup_internal_function(self, method_name, args_lll):\n+        # TODO is this the right module for me?\n+        \"\"\"\n+        Using a list of args, find the internal method to use, and\n+        the kwargs which need to be filled in by the compiler\n+        \"\"\"\n+\n+        def _check(cond, s=\"Unreachable\"):\n+            if not cond:\n+                raise CompilerPanic(s)\n+\n+        sig = self.sigs[\"self\"].get(method_name, None)\n+        if sig is None:\n+            raise FunctionDeclarationException(\n+                \"Function does not exist or has not been declared yet \"\n+                \"(reminder: functions cannot call functions later in code \"\n+                f\"than themselves): {method_name}\"\n+            )\n+\n+        _check(sig.internal)  # sanity check\n+        # should have been caught during type checking, sanity check anyway\n+        _check(len(sig.base_args) <= len(args_lll) <= len(sig.args))\n+\n+        # more sanity check, that the types match\n+        # _check(all(l.typ == r.typ for (l, r) in zip(args_lll, sig.args))\n+\n+        num_provided_kwargs = len(args_lll) - len(sig.base_args)\n+        num_kwargs = len(sig.default_args)\n+        kwargs_needed = num_kwargs - num_provided_kwargs\n+\n+        kw_vals = list(sig.default_values.values())[:kwargs_needed]\n+\n+        return sig, kw_vals\n+\n     # Pretty print constancy for error messages\n     def pp_constancy(self):\n         if self.in_assertion:"
        },
        {
          "filename": "vyper/old_codegen/events.py",
          "status": "modified",
          "additions": 5,
          "deletions": 2,
          "patch": "@@ -6,12 +6,15 @@\n     abi_encode,\n     abi_type_of,\n     abi_type_of2,\n-    lll_tuple_from_args,\n )\n from vyper.old_codegen.context import Context\n from vyper.old_codegen.keccak256_helper import keccak256_helper\n from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.parser_utils import getpos, unwrap_location\n+from vyper.old_codegen.parser_utils import (\n+    getpos,\n+    lll_tuple_from_args,\n+    unwrap_location,\n+)\n from vyper.old_codegen.types.types import (\n     BaseType,\n     ByteArrayLike,"
        },
        {
          "filename": "vyper/old_codegen/expr.py",
          "status": "modified",
          "additions": 33,
          "deletions": 109,
          "patch": "@@ -15,10 +15,10 @@\n from vyper.old_codegen.keccak256_helper import keccak256_helper\n from vyper.old_codegen.lll_node import LLLnode\n from vyper.old_codegen.parser_utils import (\n-    add_variable_offset,\n+    get_element_ptr,\n     get_number_as_fraction,\n     getpos,\n-    make_byte_array_copier,\n+    load_op,\n     make_setter,\n     unwrap_location,\n )\n@@ -202,7 +202,7 @@ def __init__(self, node, context):\n \n         self.lll_node = fn()\n         if self.lll_node is None:\n-            raise TypeCheckFailure(f\"{type(node).__name__} node did not produce LLL\")\n+            raise TypeCheckFailure(f\"{type(node).__name__} node did not produce LLL. {self.expr}\")\n \n     def parse_Int(self):\n         # Literal (mostly likely) becomes int256\n@@ -298,6 +298,7 @@ def parse_Name(self):\n                 var.pos,\n                 typ=var.typ,\n                 location=var.location,  # either 'memory' or 'calldata' storage is handled above.\n+                encoding=var.encoding,\n                 pos=getpos(self.expr),\n                 annotation=self.expr.id,\n                 mutable=var.mutable,\n@@ -411,42 +412,29 @@ def parse_Attribute(self):\n             if isinstance(sub.typ, InterfaceType):\n                 return sub\n             if isinstance(sub.typ, StructType) and self.expr.attr in sub.typ.members:\n-                return add_variable_offset(sub, self.expr.attr, pos=getpos(self.expr))\n+                return get_element_ptr(sub, self.expr.attr, pos=getpos(self.expr))\n \n     def parse_Subscript(self):\n         sub = Expr.parse_variable_location(self.expr.value, self.context)\n-        if isinstance(sub.typ, (MappingType, ListType)):\n+\n+        if isinstance(sub.typ, MappingType):\n+            # TODO sanity check we are in a self.my_map[i] situation\n             index = Expr.parse_value_expr(self.expr.slice.value, self.context)\n-            if isinstance(index.typ, ByteArrayLike) and index.args[0].location == \"storage\":\n-                # Special case - if the key value is a bytes-array type located in\n-                # storage, we have to copy it to memory prior to calculating the hash\n-                placeholder = self.context.new_internal_variable(index.typ)\n-                placeholder_node = LLLnode.from_list(placeholder, typ=index.typ, location=\"memory\")\n-                copier = make_byte_array_copier(\n-                    placeholder_node,\n-                    LLLnode.from_list(index.args[0], typ=index.typ, location=\"storage\"),\n-                )\n-                return LLLnode.from_list(\n-                    [\n-                        \"seq\",\n-                        copier,\n-                        [\n-                            \"sha3_64\",\n-                            sub,\n-                            [\"sha3\", [\"add\", placeholder, 32], [\"mload\", placeholder]],\n-                        ],\n-                    ],\n-                    typ=sub.typ.valuetype,\n-                    pos=getpos(self.expr),\n-                    location=\"storage\",\n-                )\n+            if isinstance(index.typ, ByteArrayLike):\n+                # special case,\n+                # we have to hash the key to get a storage location\n+                index = keccak256_helper(self.expr.slice.value, index.args, None, self.context)\n+\n+        elif isinstance(sub.typ, ListType):\n+            index = Expr.parse_value_expr(self.expr.slice.value, self.context)\n+\n         elif isinstance(sub.typ, TupleType):\n             index = self.expr.slice.value.n\n             if not 0 <= index < len(sub.typ.members):\n                 return\n         else:\n             return\n-        lll_node = add_variable_offset(sub, index, pos=getpos(self.expr))\n+        lll_node = get_element_ptr(sub, index, pos=getpos(self.expr))\n         lll_node.mutable = sub.mutable\n         return lll_node\n \n@@ -780,7 +768,8 @@ def build_in_comparator(self):\n             # for `not in`, invert the result\n             compare_sequence = [\"iszero\", compare_sequence]\n \n-        return LLLnode.from_list(compare_sequence, typ=\"bool\", annotation=\"in comparator\")\n+        annotation = self.expr.get(\"node_source_code\")\n+        return LLLnode.from_list(compare_sequence, typ=\"bool\", annotation=annotation)\n \n     @staticmethod\n     def _signed_to_unsigned_comparision_op(op):\n@@ -849,10 +838,11 @@ def parse_Compare(self):\n             else:\n \n                 def load_bytearray(side):\n-                    if side.location == \"memory\":\n-                        return [\"mload\", [\"add\", 32, side]]\n-                    elif side.location == \"storage\":\n+                    if side.location == \"storage\":\n                         return [\"sload\", [\"add\", 1, side]]\n+                    else:\n+                        load = load_op(side.location)\n+                        return [load, [\"add\", 32, side]]\n \n                 return LLLnode.from_list(\n                     [op, load_bytearray(left), load_bytearray(right)],\n@@ -978,30 +968,24 @@ def parse_Call(self):\n             and isinstance(self.expr.func.value, vy_ast.Name)\n             and self.expr.func.value.id == \"self\"\n         ):  # noqa: E501\n-            return self_call.make_call(self.expr, self.context)\n+            return self_call.lll_for_self_call(self.expr, self.context)\n         else:\n-            return external_call.make_external_call(self.expr, self.context)\n+            return external_call.lll_for_external_call(self.expr, self.context)\n \n     def parse_List(self):\n-        call_lll, multi_lll = parse_sequence(self.expr, self.expr.elements, self.context)\n+        multi_lll = [Expr(x, self.context).lll_node for x in self.expr.elements]\n+        # TODO this type inference is wrong. instead should use\n+        # parse_type(canonical_type_of(self.expr._metadata[\"type\"]))\n         out_type = next((i.typ for i in multi_lll if not i.typ.is_literal), multi_lll[0].typ)\n         typ = ListType(out_type, len(self.expr.elements), is_literal=True)\n         multi_lll = LLLnode.from_list([\"multi\"] + multi_lll, typ=typ, pos=getpos(self.expr))\n-        if not call_lll:\n-            return multi_lll\n-\n-        lll_node = [\"seq_unchecked\"] + call_lll + [multi_lll]\n-        return LLLnode.from_list(lll_node, typ=typ, pos=getpos(self.expr))\n+        return multi_lll\n \n     def parse_Tuple(self):\n-        call_lll, multi_lll = parse_sequence(self.expr, self.expr.elements, self.context)\n-        typ = TupleType([x.typ for x in multi_lll], is_literal=True)\n-        multi_lll = LLLnode.from_list([\"multi\"] + multi_lll, typ=typ, pos=getpos(self.expr))\n-        if not call_lll:\n-            return multi_lll\n-\n-        lll_node = [\"seq_unchecked\"] + call_lll + [multi_lll]\n-        return LLLnode.from_list(lll_node, typ=typ, pos=getpos(self.expr))\n+        tuple_elements = [Expr(x, self.context).lll_node for x in self.expr.elements]\n+        typ = TupleType([x.typ for x in tuple_elements], is_literal=True)\n+        multi_lll = LLLnode.from_list([\"multi\"] + tuple_elements, typ=typ, pos=getpos(self.expr))\n+        return multi_lll\n \n     @staticmethod\n     def struct_literals(expr, name, context):\n@@ -1033,63 +1017,3 @@ def parse_variable_location(cls, expr, context):\n         if not o.location:\n             raise StructureException(\"Looking for a variable location, instead got a value\", expr)\n         return o\n-\n-\n-def parse_sequence(base_node, elements, context):\n-    \"\"\"\n-    Generate an LLL node from a sequence of Vyper AST nodes, such as values inside a\n-    list/tuple or arguments inside a call.\n-\n-    Arguments\n-    ---------\n-    base_node : VyperNode\n-        Parent node which contains the sequence being parsed.\n-    elements : List[VyperNode]\n-        A list of nodes within the sequence.\n-    context : Context\n-        Currently active local context.\n-\n-    Returns\n-    -------\n-    List[LLLNode]\n-        LLL nodes that must execute prior to generating the actual sequence in order to\n-        avoid memory corruption issues. This list may be empty, depending on the values\n-        within `elements`.\n-    List[LLLNode]\n-        LLL nodes which collectively represent `elements`.\n-    \"\"\"\n-    init_lll = []\n-    sequence_lll = []\n-    for node in elements:\n-        if isinstance(node, vy_ast.List):\n-            # for nested lists, ensure the init LLL is also processed before the values\n-            init, seq = parse_sequence(node, node.elements, context)\n-            init_lll.extend(init)\n-            out_type = next((i.typ for i in seq if not i.typ.is_literal), seq[0].typ)\n-            typ = ListType(out_type, len(node.elements), is_literal=True)\n-            multi_lll = LLLnode.from_list([\"multi\"] + seq, typ=typ, pos=getpos(node))\n-            sequence_lll.append(multi_lll)\n-            continue\n-\n-        lll_node = Expr(node, context).lll_node\n-        if isinstance(node, vy_ast.Call) or (\n-            isinstance(node, vy_ast.Subscript) and isinstance(node.value, vy_ast.Call)\n-        ):\n-            # nodes which potentially create their own internal memory variables, and so must\n-            # be parsed prior to generating the final sequence to avoid memory corruption\n-            target = LLLnode.from_list(\n-                context.new_internal_variable(lll_node.typ),\n-                typ=lll_node.typ,\n-                location=\"memory\",\n-                pos=getpos(base_node),\n-            )\n-            init_lll.append(make_setter(target, lll_node, \"memory\", pos=getpos(base_node)))\n-            sequence_lll.append(\n-                LLLnode.from_list(\n-                    target, typ=lll_node.typ, pos=getpos(base_node), location=\"memory\"\n-                ),\n-            )\n-        else:\n-            sequence_lll.append(lll_node)\n-\n-    return init_lll, sequence_lll"
        },
        {
          "filename": "vyper/old_codegen/external_call.py",
          "status": "modified",
          "additions": 186,
          "deletions": 187,
          "patch": "@@ -1,164 +1,188 @@\n+import vyper.utils as util\n from vyper import ast as vy_ast\n from vyper.exceptions import (\n     StateAccessViolation,\n     StructureException,\n     TypeCheckFailure,\n )\n-from vyper.old_codegen.abi import abi_decode\n-from vyper.old_codegen.lll_node import LLLnode\n+from vyper.old_codegen.abi import abi_encode, abi_type_of\n+from vyper.old_codegen.lll_node import Encoding, LLLnode\n from vyper.old_codegen.parser_utils import (\n+    calculate_type_for_external_return,\n+    get_element_ptr,\n     getpos,\n-    pack_arguments,\n     unwrap_location,\n )\n from vyper.old_codegen.types import (\n-    BaseType,\n-    ByteArrayLike,\n-    ListType,\n-    TupleLike,\n-    get_size_of_type,\n-    get_static_size_of_type,\n-    has_dynamic_data,\n+    TupleType,\n+    canonicalize_type,\n+    get_type_for_exact_size,\n )\n+from vyper.old_codegen.types.check import check_assign\n \n \n-def external_call(node, context, interface_name, contract_address, pos, value=None, gas=None):\n-    from vyper.old_codegen.expr import Expr\n+def _pack_arguments(contract_sig, args, context, pos):\n+    # abi encoding just treats all args as a big tuple\n+    args_tuple_t = TupleType([x.typ for x in args])\n+    args_as_tuple = LLLnode.from_list([\"multi\"] + [x for x in args], typ=args_tuple_t)\n+    args_abi_t = abi_type_of(args_tuple_t)\n+\n+    # sanity typecheck - make sure the arguments can be assigned\n+    dst_tuple_t = TupleType([arg.typ for arg in contract_sig.args][: len(args)])\n+    _tmp = LLLnode(\"fake node\", location=\"memory\", typ=dst_tuple_t)\n+    check_assign(_tmp, args_as_tuple, pos)\n+\n+    if contract_sig.return_type is not None:\n+        return_abi_t = abi_type_of(calculate_type_for_external_return(contract_sig.return_type))\n+\n+        # we use the same buffer for args and returndata,\n+        # so allocate enough space here for the returndata too.\n+        buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\n+    else:\n+        buflen = args_abi_t.size_bound()\n+\n+    buflen += 32  # padding for the method id\n+\n+    buf_t = get_type_for_exact_size(buflen)\n+    buf = context.new_internal_variable(buf_t)\n+\n+    args_ofst = buf + 28\n+    args_len = args_abi_t.size_bound() + 4\n+\n+    abi_signature = contract_sig.name + canonicalize_type(dst_tuple_t)\n+\n+    # layout:\n+    # 32 bytes                 | args\n+    # 0x..00<method_id_4bytes> | args\n+    # the reason for the left padding is just so the alignment is easier.\n+    # if we were only targeting constantinople, we could align\n+    # to buf (and also keep code size small) by using\n+    # (mstore buf (shl signature.method_id 224))\n+    mstore_method_id = [[\"mstore\", buf, util.abi_method_id(abi_signature)]]\n+\n+    if len(args) == 0:\n+        encode_args = [\"pass\"]\n+    else:\n+        encode_args = abi_encode(buf + 32, args_as_tuple, pos)\n+\n+    return buf, mstore_method_id + [encode_args], args_ofst, args_len\n+\n+\n+def _returndata_encoding(contract_sig):\n+    if contract_sig.is_from_json:\n+        return Encoding.JSON_ABI\n+    return Encoding.ABI\n+\n+\n+def _unpack_returndata(buf, contract_sig, context, pos):\n+    return_t = contract_sig.return_type\n+    if return_t is None:\n+        return [\"pass\"], 0, 0\n+\n+    return_t = calculate_type_for_external_return(return_t)\n+    # if the abi signature has a different type than\n+    # the vyper type, we need to wrap and unwrap the type\n+    # so that the ABI decoding works correctly\n+    should_unwrap_abi_tuple = return_t != contract_sig.return_type\n+\n+    abi_return_t = abi_type_of(return_t)\n+\n+    min_return_size = abi_return_t.min_size()\n+    max_return_size = abi_return_t.size_bound()\n+    assert 0 < min_return_size <= max_return_size\n+\n+    ret_ofst = buf\n+    ret_len = max_return_size\n+\n+    # revert when returndatasize is not in bounds\n+    ret = []\n+    # runtime: min_return_size <= returndatasize\n+    # TODO move the -1 optimization to LLL optimizer\n+    ret += [[\"assert\", [\"gt\", \"returndatasize\", min_return_size - 1]]]\n+\n+    # add as the last LLLnode a pointer to the return data structure\n+\n+    # the return type has been wrapped by the calling contract;\n+    # unwrap it so downstream code isn't confused.\n+    # basically this expands to buf+32 if the return type has been wrapped\n+    # in a tuple AND its ABI type is dynamic.\n+    # in most cases, this simply will evaluate to ret.\n+    # in the special case where the return type has been wrapped\n+    # in a tuple AND its ABI type is dynamic, it expands to buf+32.\n+    buf = LLLnode(buf, typ=return_t, encoding=_returndata_encoding(contract_sig), location=\"memory\")\n+\n+    if should_unwrap_abi_tuple:\n+        buf = get_element_ptr(buf, 0, pos=None, array_bounds_check=False)\n+\n+    ret += [buf]\n+\n+    return ret, ret_ofst, ret_len\n+\n+\n+def _external_call_helper(\n+    contract_address, contract_sig, args_lll, context, pos=None, value=None, gas=None\n+):\n \n     if value is None:\n         value = 0\n     if gas is None:\n         gas = \"gas\"\n \n-    method_name = node.func.attr\n-    sig = context.sigs[interface_name][method_name]\n-    inargs, inargsize, _ = pack_arguments(\n-        sig,\n-        [Expr(arg, context).lll_node for arg in node.args],\n-        context,\n-        node.func,\n-        is_external_call=True,\n-    )\n-    output_placeholder, output_size, returner = get_external_call_output(sig, context)\n-    sub = [\"seq\"]\n-    if not output_size:\n-        # if we do not expect return data, check that a contract exists at the target address\n-        # we can omit this when we _do_ expect return data because we later check `returndatasize`\n-        sub.append([\"assert\", [\"extcodesize\", contract_address]])\n-    if context.is_constant() and sig.mutability not in (\"view\", \"pure\"):\n-        # TODO this can probably go\n+    # sanity check\n+    assert len(contract_sig.args) == len(args_lll)\n+\n+    if context.is_constant() and contract_sig.mutability not in (\"view\", \"pure\"):\n+        # TODO is this already done in type checker?\n         raise StateAccessViolation(\n-            f\"May not call state modifying function '{method_name}' \"\n+            f\"May not call state modifying function '{contract_sig.name}' \"\n             f\"within {context.pp_constancy()}.\",\n-            node,\n+            pos,\n         )\n \n-    if context.is_constant() or sig.mutability in (\"view\", \"pure\"):\n-        sub.append(\n-            [\n-                \"assert\",\n-                [\n-                    \"staticcall\",\n-                    gas,\n-                    contract_address,\n-                    inargs,\n-                    inargsize,\n-                    output_placeholder,\n-                    output_size,\n-                ],\n-            ]\n-        )\n-    else:\n-        sub.append(\n-            [\n-                \"assert\",\n-                [\n-                    \"call\",\n-                    gas,\n-                    contract_address,\n-                    value,\n-                    inargs,\n-                    inargsize,\n-                    output_placeholder,\n-                    output_size,\n-                ],\n-            ]\n-        )\n-    if output_size:\n-        # when return data is expected, revert when the length of `returndatasize` is insufficient\n-        output_type = sig.output_type\n-        if not has_dynamic_data(output_type):\n-            static_output_size = get_static_size_of_type(output_type) * 32\n-            sub.append([\"assert\", [\"gt\", \"returndatasize\", static_output_size - 1]])\n-        else:\n-            if isinstance(output_type, ByteArrayLike):\n-                types_list = (output_type,)\n-            elif isinstance(output_type, TupleLike):\n-                types_list = output_type.tuple_members()\n-            else:\n-                raise\n-\n-            dynamic_checks = []\n-            static_offset = output_placeholder\n-            static_output_size = 0\n-            for typ in types_list:\n-                # ensure length of bytes does not exceed max allowable length for type\n-                if isinstance(typ, ByteArrayLike):\n-                    static_output_size += 32\n-                    # do not perform this check on calls to a JSON interface - we don't know\n-                    # for certain how long the expected data is\n-                    if not sig.is_from_json:\n-                        dynamic_checks.append(\n-                            [\n-                                \"assert\",\n-                                [\n-                                    \"lt\",\n-                                    [\n-                                        \"mload\",\n-                                        [\"add\", [\"mload\", static_offset], output_placeholder],\n-                                    ],\n-                                    typ.maxlen + 1,\n-                                ],\n-                            ]\n-                        )\n-                static_offset += get_static_size_of_type(typ) * 32\n-                static_output_size += get_static_size_of_type(typ) * 32\n-\n-            sub.append([\"assert\", [\"gt\", \"returndatasize\", static_output_size - 1]])\n-            sub.extend(dynamic_checks)\n-\n-    sub.extend(returner)\n-\n-    return LLLnode.from_list(sub, typ=sig.output_type, location=\"memory\", pos=getpos(node))\n-\n-\n-def get_external_call_output(sig, context):\n-    if not sig.output_type:\n-        return 0, 0, []\n-    output_placeholder = context.new_internal_variable(typ=sig.output_type)\n-    output_size = get_size_of_type(sig.output_type) * 32\n-    if isinstance(sig.output_type, BaseType):\n-        returner = [0, output_placeholder]\n-    elif isinstance(sig.output_type, ByteArrayLike):\n-        returner = [0, output_placeholder + 32]\n-    elif isinstance(sig.output_type, TupleLike):\n-        # incase of struct we need to decode the output and then return it\n-        returner = [\"seq\"]\n-        decoded_placeholder = context.new_internal_variable(typ=sig.output_type)\n-        decoded_node = LLLnode(decoded_placeholder, typ=sig.output_type, location=\"memory\")\n-        output_node = LLLnode(output_placeholder, typ=sig.output_type, location=\"memory\")\n-        returner.append(abi_decode(decoded_node, output_node))\n-        returner.extend([0, decoded_placeholder])\n-    elif isinstance(sig.output_type, ListType):\n-        returner = [0, output_placeholder]\n+    sub = [\"seq\"]\n+\n+    buf, arg_packer, args_ofst, args_len = _pack_arguments(contract_sig, args_lll, context, pos)\n+\n+    ret_unpacker, ret_ofst, ret_len = _unpack_returndata(buf, contract_sig, context, pos)\n+\n+    sub += arg_packer\n+\n+    if contract_sig.return_type is None:\n+        # if we do not expect return data, check that a contract exists at the\n+        # target address. we must perform this check BEFORE the call because\n+        # the contract might selfdestruct. on the other hand we can omit this\n+        # when we _do_ expect return data because we later check\n+        # `returndatasize` (that check works even if the contract\n+        # selfdestructs).\n+        sub.append([\"assert\", [\"extcodesize\", contract_address]])\n+\n+    if context.is_constant() or contract_sig.mutability in (\"view\", \"pure\"):\n+        call_op = [\"staticcall\", gas, contract_address, args_ofst, args_len, ret_ofst, ret_len]\n     else:\n-        raise TypeCheckFailure(f\"Invalid output type: {sig.output_type}\")\n-    return output_placeholder, output_size, returner\n+        call_op = [\"call\", gas, contract_address, value, args_ofst, args_len, ret_ofst, ret_len]\n \n+    sub.append([\"assert\", call_op])\n \n-def get_external_interface_keywords(stmt_expr, context):\n-    # circular import!\n-    from vyper.old_codegen.expr import Expr\n+    if contract_sig.return_type is not None:\n+        sub += ret_unpacker\n+\n+    ret = LLLnode.from_list(\n+        # set the encoding to ABI here, downstream code will decode and add clampers.\n+        sub,\n+        typ=contract_sig.return_type,\n+        location=\"memory\",\n+        encoding=_returndata_encoding(contract_sig),\n+        pos=pos,\n+    )\n+\n+    return ret\n+\n+\n+# TODO push me up to expr.py\n+def get_gas_and_value(stmt_expr, context):\n+    from vyper.old_codegen.expr import (\n+        Expr,  # TODO rethink this circular import\n+    )\n \n     value, gas = None, None\n     for kw in stmt_expr.keywords:\n@@ -171,60 +195,35 @@ def get_external_interface_keywords(stmt_expr, context):\n     return value, gas\n \n \n-def make_external_call(stmt_expr, context):\n-    # circular import!\n-    from vyper.old_codegen.expr import Expr\n+def lll_for_external_call(stmt_expr, context):\n+    from vyper.old_codegen.expr import (\n+        Expr,  # TODO rethink this circular import\n+    )\n \n-    value, gas = get_external_interface_keywords(stmt_expr, context)\n+    pos = getpos(stmt_expr)\n+    value, gas = get_gas_and_value(stmt_expr, context)\n+    args_lll = [Expr(x, context).lll_node for x in stmt_expr.args]\n \n     if isinstance(stmt_expr.func, vy_ast.Attribute) and isinstance(\n         stmt_expr.func.value, vy_ast.Call\n     ):\n+        # e.g. `Foo(address).bar()`\n+\n+        # sanity check\n+        assert len(stmt_expr.func.value.args) == 1\n         contract_name = stmt_expr.func.value.func.id\n         contract_address = Expr.parse_value_expr(stmt_expr.func.value.args[0], context)\n \n-        return external_call(\n-            stmt_expr,\n-            context,\n-            contract_name,\n-            contract_address,\n-            pos=getpos(stmt_expr),\n-            value=value,\n-            gas=gas,\n-        )\n-\n-    elif (\n-        isinstance(stmt_expr.func.value, vy_ast.Attribute)\n-        and stmt_expr.func.value.attr in context.sigs\n-    ):  # noqa: E501\n-        contract_name = stmt_expr.func.value.attr\n-        type_ = stmt_expr.func.value._metadata[\"type\"]\n-        var = context.globals[stmt_expr.func.value.attr]\n-        contract_address = unwrap_location(\n-            LLLnode.from_list(\n-                type_.position.position,\n-                typ=var.typ,\n-                location=\"storage\",\n-                pos=getpos(stmt_expr),\n-                annotation=\"self.\" + stmt_expr.func.value.attr,\n-            )\n-        )\n-\n-        return external_call(\n-            stmt_expr,\n-            context,\n-            contract_name,\n-            contract_address,\n-            pos=getpos(stmt_expr),\n-            value=value,\n-            gas=gas,\n-        )\n-\n     elif (\n         isinstance(stmt_expr.func.value, vy_ast.Attribute)\n         and stmt_expr.func.value.attr in context.globals\n+        # TODO check for self?\n         and hasattr(context.globals[stmt_expr.func.value.attr].typ, \"name\")\n     ):\n+        # e.g. `self.foo.bar()`\n+\n+        # sanity check\n+        assert stmt_expr.func.value.value.id == \"self\", stmt_expr\n \n         contract_name = context.globals[stmt_expr.func.value.attr].typ.name\n         type_ = stmt_expr.func.value._metadata[\"type\"]\n@@ -234,20 +233,20 @@ def make_external_call(stmt_expr, context):\n                 type_.position.position,\n                 typ=var.typ,\n                 location=\"storage\",\n-                pos=getpos(stmt_expr),\n+                pos=pos,\n                 annotation=\"self.\" + stmt_expr.func.value.attr,\n             )\n         )\n-\n-        return external_call(\n-            stmt_expr,\n-            context,\n-            contract_name,\n-            contract_address,\n-            pos=getpos(stmt_expr),\n-            value=value,\n-            gas=gas,\n-        )\n-\n     else:\n+        # TODO catch this during type checking\n         raise StructureException(\"Unsupported operator.\", stmt_expr)\n+\n+    method_name = stmt_expr.func.attr\n+    contract_sig = context.sigs[contract_name][method_name]\n+\n+    ret = _external_call_helper(\n+        contract_address, contract_sig, args_lll, context, pos, value=value, gas=gas,\n+    )\n+    ret.annotation = stmt_expr.get(\"node_source_code\")\n+\n+    return ret"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/__init__.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,5 +1,5 @@\n-from .parse_function import (  # noqa\n+from .common import (  # noqa\n+    generate_lll_for_function,\n     is_default_func,\n     is_initializer,\n-    parse_function,\n )"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/common.py",
          "status": "added",
          "additions": 107,
          "deletions": 0,
          "patch": "@@ -0,0 +1,107 @@\n+# can't use from [module] import [object] because it breaks mocks in testing\n+import copy\n+from typing import Dict, Optional, Tuple\n+\n+import vyper.ast as vy_ast\n+from vyper.ast.signatures import FunctionSignature, VariableRecord\n+from vyper.old_codegen.context import Constancy, Context\n+from vyper.old_codegen.function_definitions.external_function import (\n+    generate_lll_for_external_function,\n+)\n+from vyper.old_codegen.function_definitions.internal_function import (\n+    generate_lll_for_internal_function,\n+)\n+from vyper.old_codegen.global_context import GlobalContext\n+from vyper.old_codegen.lll_node import LLLnode\n+from vyper.old_codegen.memory_allocator import MemoryAllocator\n+from vyper.old_codegen.parser_utils import check_single_exit\n+from vyper.utils import MemoryPositions, calc_mem_gas\n+\n+\n+# Is a function the initializer?\n+def is_initializer(code: vy_ast.FunctionDef) -> bool:\n+    return code.name == \"__init__\"\n+\n+\n+# Is a function the default function?\n+def is_default_func(code: vy_ast.FunctionDef) -> bool:\n+    return code.name == \"__default__\"\n+\n+\n+def generate_lll_for_function(\n+    code: vy_ast.FunctionDef,\n+    sigs: Dict[str, Dict[str, FunctionSignature]],\n+    global_ctx: GlobalContext,\n+    check_nonpayable: bool,\n+    # CMC 20210921 TODO _vars can probably be removed\n+    _vars: Optional[Dict[str, VariableRecord]] = None,\n+) -> Tuple[LLLnode, int, int]:\n+    \"\"\"\n+    Parse a function and produce LLL code for the function, includes:\n+        - Signature method if statement\n+        - Argument handling\n+        - Clamping and copying of arguments\n+        - Function body\n+    \"\"\"\n+    if _vars is None:\n+        _vars = {}  # noqa: F841\n+    sig = FunctionSignature.from_definition(code, sigs=sigs, custom_structs=global_ctx._structs,)\n+\n+    # Validate return statements.\n+    check_single_exit(code)\n+\n+    # in order to statically allocate function frames,\n+    # we codegen functions in two passes.\n+    # one pass is just called for its side effects on the context/memory\n+    # allocator. once that pass is finished, we inspect the context\n+    # to see what the max frame size of any callee in the function was,\n+    # then we run the codegen again with the max frame size as\n+    # the start of the frame for this function.\n+    def _run_pass(memory_allocator=None):\n+        # Create a local (per function) context.\n+        if memory_allocator is None:\n+            memory_allocator = MemoryAllocator()\n+        nonlocal _vars\n+        _vars = _vars.copy()  # these will get clobbered in called functions\n+        nonlocal sig\n+        sig = copy.deepcopy(sig)  # just in case\n+        context = Context(\n+            vars=_vars,\n+            global_ctx=global_ctx,\n+            sigs=sigs,\n+            memory_allocator=memory_allocator,\n+            return_type=sig.return_type,\n+            constancy=Constancy.Constant\n+            if sig.mutability in (\"view\", \"pure\")\n+            else Constancy.Mutable,\n+            is_payable=sig.mutability == \"payable\",\n+            is_internal=sig.internal,\n+            sig=sig,\n+        )\n+\n+        if sig.internal:\n+            o = generate_lll_for_internal_function(code, sig, context)\n+        else:\n+            o = generate_lll_for_external_function(code, sig, context, check_nonpayable)\n+        return o, context\n+\n+    _, context = _run_pass(memory_allocator=None)\n+\n+    allocate_start = context.max_callee_frame_size\n+    allocate_start += MemoryPositions.RESERVED_MEMORY\n+\n+    o, context = _run_pass(memory_allocator=MemoryAllocator(allocate_start))\n+\n+    frame_size = context.memory_allocator.size_of_mem - MemoryPositions.RESERVED_MEMORY\n+\n+    if not sig.internal:\n+        # frame_size of external function includes all private functions called\n+        o.total_gas = o.gas + calc_mem_gas(frame_size)\n+    else:\n+        # frame size for internal function does not need to be adjusted\n+        # since it is already accounted for by the caller\n+        o.total_gas = o.gas\n+\n+    o.context = context\n+    o.func_name = sig.name\n+    return o, allocate_start, frame_size"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/external_function.py",
          "status": "added",
          "additions": 219,
          "deletions": 0,
          "patch": "@@ -0,0 +1,219 @@\n+from typing import Any, List\n+\n+import vyper.utils as util\n+from vyper.ast.signatures.function_signature import (\n+    FunctionSignature,\n+    VariableRecord,\n+)\n+from vyper.exceptions import CompilerPanic\n+from vyper.old_codegen.context import Context\n+from vyper.old_codegen.expr import Expr\n+from vyper.old_codegen.function_definitions.utils import get_nonreentrant_lock\n+from vyper.old_codegen.lll_node import Encoding, LLLnode\n+from vyper.old_codegen.parser_utils import get_element_ptr, getpos, make_setter\n+from vyper.old_codegen.stmt import parse_body\n+from vyper.old_codegen.types.types import (\n+    BaseType,\n+    ByteArrayLike,\n+    ListType,\n+    TupleLike,\n+    TupleType,\n+)\n+\n+\n+def _should_decode(typ):\n+    # either a basetype which needs to be clamped\n+    # or a complex type which contains something that\n+    # needs to be clamped.\n+    if isinstance(typ, BaseType):\n+        return typ.typ not in (\"int256\", \"uint256\", \"bytes32\")\n+    if isinstance(typ, ByteArrayLike):\n+        return True\n+    if isinstance(typ, ListType):\n+        return _should_decode(typ.subtype)\n+    if isinstance(typ, TupleLike):\n+        return any(_should_decode(t) for t in typ.tuple_members())\n+    raise CompilerPanic(f\"_should_decode({typ})\")\n+\n+\n+# register function args with the local calling context.\n+# also allocate the ones that live in memory (i.e. kwargs)\n+def _register_function_args(context: Context, sig: FunctionSignature) -> List[LLLnode]:\n+    pos = None\n+\n+    ret = []\n+\n+    # the type of the calldata\n+    base_args_t = TupleType([arg.typ for arg in sig.base_args])\n+\n+    # tuple with the abi_encoded args\n+    if sig.is_init_func:\n+        base_args_ofst = LLLnode(\n+            \"~codelen\", location=\"code\", typ=base_args_t, encoding=Encoding.ABI\n+        )\n+    else:\n+        base_args_ofst = LLLnode(4, location=\"calldata\", typ=base_args_t, encoding=Encoding.ABI)\n+\n+    for i, arg in enumerate(sig.base_args):\n+\n+        arg_lll = get_element_ptr(base_args_ofst, i, pos=pos)\n+\n+        if _should_decode(arg.typ):\n+            # allocate a memory slot for it and copy\n+            p = context.new_variable(arg.name, arg.typ, is_mutable=False)\n+            dst = LLLnode(p, typ=arg.typ, location=\"memory\")\n+            ret.append(make_setter(dst, arg_lll, \"memory\", pos=pos))\n+        else:\n+            # leave it in place\n+            context.vars[arg.name] = VariableRecord(\n+                name=arg.name,\n+                pos=arg_lll,\n+                typ=arg.typ,\n+                mutable=False,\n+                location=arg_lll.location,\n+                encoding=Encoding.ABI,\n+            )\n+\n+    return ret\n+\n+\n+def _annotated_method_id(abi_sig):\n+    method_id = util.abi_method_id(abi_sig)\n+    annotation = f\"{hex(method_id)}: {abi_sig}\"\n+    return LLLnode(method_id, annotation=annotation)\n+\n+\n+def _generate_kwarg_handlers(context: Context, sig: FunctionSignature, pos: Any) -> List[Any]:\n+    # generate kwarg handlers.\n+    # since they might come in thru calldata or be default,\n+    # allocate them in memory and then fill it in based on calldata or default,\n+    # depending on the signature\n+    # a kwarg handler looks like\n+    # (if (eq _method_id <method_id>)\n+    #    copy calldata args to memory\n+    #    write default args to memory\n+    #    goto external_function_common_lll\n+\n+    def handler_for(calldata_kwargs, default_kwargs):\n+        calldata_args = sig.base_args + calldata_kwargs\n+        # create a fake type so that get_element_ptr works\n+        calldata_args_t = TupleType(list(arg.typ for arg in calldata_args))\n+\n+        abi_sig = sig.abi_signature_for_kwargs(calldata_kwargs)\n+        method_id = _annotated_method_id(abi_sig)\n+\n+        calldata_kwargs_ofst = LLLnode(\n+            4, location=\"calldata\", typ=calldata_args_t, encoding=Encoding.ABI\n+        )\n+\n+        # a sequence of statements to strictify kwargs into memory\n+        ret = [\"seq\"]\n+\n+        # TODO optimize make_setter by using\n+        # TupleType(list(arg.typ for arg in calldata_kwargs + default_kwargs))\n+        # (must ensure memory area is contiguous)\n+\n+        lhs_location = \"memory\"\n+        n_base_args = len(sig.base_args)\n+\n+        for i, arg_meta in enumerate(calldata_kwargs):\n+            k = n_base_args + i\n+\n+            dst = context.lookup_var(arg_meta.name).pos\n+\n+            lhs = LLLnode(dst, location=\"memory\", typ=arg_meta.typ)\n+            rhs = get_element_ptr(calldata_kwargs_ofst, k, pos=None, array_bounds_check=False)\n+            ret.append(make_setter(lhs, rhs, lhs_location, pos))\n+\n+        for x in default_kwargs:\n+            dst = context.lookup_var(x.name).pos\n+            lhs = LLLnode(dst, location=\"memory\", typ=x.typ)\n+            kw_ast_val = sig.default_values[x.name]  # e.g. `3` in x: int = 3\n+            rhs = Expr(kw_ast_val, context).lll_node\n+            ret.append(make_setter(lhs, rhs, lhs_location, pos))\n+\n+        ret.append([\"goto\", sig.external_function_base_entry_label])\n+\n+        ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]\n+        return ret\n+\n+    ret = [\"seq\"]\n+\n+    keyword_args = sig.default_args\n+\n+    # allocate variable slots in memory\n+    for arg in keyword_args:\n+        context.new_variable(arg.name, arg.typ, is_mutable=False)\n+\n+    for i, _ in enumerate(keyword_args):\n+        calldata_kwargs = keyword_args[:i]\n+        default_kwargs = keyword_args[i:]\n+\n+        ret.append(handler_for(calldata_kwargs, default_kwargs))\n+\n+    ret.append(handler_for(keyword_args, []))\n+\n+    return ret\n+\n+\n+# TODO it would be nice if this returned a data structure which were\n+# amenable to generating a jump table instead of the linear search for\n+# method_id we have now.\n+def generate_lll_for_external_function(code, sig, context, check_nonpayable):\n+    # TODO type hints:\n+    # def generate_lll_for_external_function(\n+    #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,\n+    # ) -> LLLnode:\n+    \"\"\"Return the LLL for an external function. Includes code to inspect the method_id,\n+       enter the function (nonpayable and reentrancy checks), handle kwargs and exit\n+       the function (clean up reentrancy storage variables)\n+    \"\"\"\n+    func_type = code._metadata[\"type\"]\n+    pos = getpos(code)\n+\n+    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)\n+\n+    # generate handlers for base args and register the variable records\n+    handle_base_args = _register_function_args(context, sig)\n+\n+    # generate handlers for kwargs and register the variable records\n+    kwarg_handlers = _generate_kwarg_handlers(context, sig, pos)\n+\n+    # once optional args have been handled,\n+    # generate the main body of the function\n+    entrance = [[\"label\", sig.external_function_base_entry_label]]\n+\n+    entrance += handle_base_args\n+\n+    if check_nonpayable and sig.mutability != \"payable\":\n+        # if the contract contains payable functions, but this is not one of them\n+        # add an assertion that the value of the call is zero\n+        entrance += [[\"assert\", [\"iszero\", \"callvalue\"]]]\n+\n+    entrance += nonreentrant_pre\n+\n+    body = [parse_body(c, context) for c in code.body]\n+\n+    exit = [[\"label\", sig.exit_sequence_label]] + nonreentrant_post\n+    if sig.is_init_func:\n+        pass  # init func has special exit sequence generated by parser.py\n+    elif context.return_type is None:\n+        exit += [[\"stop\"]]\n+    else:\n+        # ret_ofst and ret_len stack items passed by function body; consume using 'pass'\n+        exit += [[\"return\", \"pass\", \"pass\"]]\n+\n+    # the lll which comprises the main body of the function,\n+    # besides any kwarg handling\n+    func_common_lll = [\"seq\"] + entrance + body + exit\n+\n+    if sig.is_default_func or sig.is_init_func:\n+        # default and init funcs have special entries generated by parser.py\n+        ret = func_common_lll\n+    else:\n+        ret = kwarg_handlers\n+        # sneak the base code into the kwarg handler\n+        # TODO rethink this / make it clearer\n+        ret[-1][-1].append(func_common_lll)\n+\n+    return LLLnode.from_list(ret, pos=getpos(code))"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/internal_function.py",
          "status": "added",
          "additions": 64,
          "deletions": 0,
          "patch": "@@ -0,0 +1,64 @@\n+from vyper import ast as vy_ast\n+from vyper.ast.signatures import FunctionSignature\n+from vyper.old_codegen.context import Context\n+from vyper.old_codegen.function_definitions.utils import get_nonreentrant_lock\n+from vyper.old_codegen.lll_node import LLLnode\n+from vyper.old_codegen.parser_utils import getpos\n+from vyper.old_codegen.stmt import parse_body\n+\n+\n+def generate_lll_for_internal_function(\n+    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context\n+) -> LLLnode:\n+    \"\"\"\n+    Parse a internal function (FuncDef), and produce full function body.\n+\n+    :param sig: the FuntionSignature\n+    :param code: ast of function\n+    :param context: current calling context\n+    :return: function body in LLL\n+    \"\"\"\n+\n+    # The calling convention is:\n+    #   Caller fills in argument buffer\n+    #   Caller provides return address, return buffer on the stack\n+    #   Callee runs its code, fills in return buffer provided by caller\n+    #   Callee jumps back to caller\n+\n+    # The reason caller fills argument buffer is so there is less\n+    # complication with passing args on the stack; the caller is better\n+    # suited to optimize the copy operation. Also it avoids the callee\n+    # having to handle default args; that is easier left to the caller\n+    # as well. Meanwhile, the reason the callee fills the return buffer\n+    # is first, similarly, the callee is more suited to optimize the copy\n+    # operation. Second, it allows the caller to allocate the return\n+    # buffer in a way which reduces the number of copies. Third, it\n+    # reduces the potential for bugs since it forces the caller to have\n+    # the return data copied into a preallocated location. Otherwise, a\n+    # situation like the following is easy to bork:\n+    #   x: T[2] = [self.generate_T(), self.generate_T()]\n+\n+    func_type = code._metadata[\"type\"]\n+\n+    # Get nonreentrant lock\n+\n+    for arg in sig.args:\n+        # allocate a variable for every arg, setting mutability\n+        # to False to comply with vyper semantics, function arguments are immutable\n+        context.new_variable(arg.name, arg.typ, is_mutable=False)\n+\n+    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)\n+\n+    function_entry_label = sig.internal_function_label\n+    cleanup_label = sig.exit_sequence_label\n+\n+    # jump to the label which was passed in via stack\n+    stop_func = LLLnode.from_list([\"jump\", \"pass\"], annotation=\"jump to return address\")\n+\n+    enter = [[\"label\", function_entry_label]] + nonreentrant_pre\n+\n+    body = [parse_body(c, context) for c in code.body]\n+\n+    exit = [[\"label\", cleanup_label]] + nonreentrant_post + [stop_func]\n+\n+    return LLLnode.from_list([\"seq\"] + enter + body + exit, typ=None, pos=getpos(code),)"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/parse_external_function.py",
          "status": "removed",
          "additions": 0,
          "deletions": 236,
          "patch": "@@ -1,236 +0,0 @@\n-from typing import Any, List, Union\n-\n-from vyper import ast as vy_ast\n-from vyper.ast.signatures import sig_utils\n-from vyper.ast.signatures.function_signature import FunctionSignature\n-from vyper.old_codegen.arg_clamps import make_arg_clamper\n-from vyper.old_codegen.context import Context, VariableRecord\n-from vyper.old_codegen.expr import Expr\n-from vyper.old_codegen.function_definitions.utils import (\n-    get_default_names_to_set,\n-    get_nonreentrant_lock,\n-    get_sig_statements,\n-)\n-from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.parser_utils import getpos, make_setter\n-from vyper.old_codegen.stmt import parse_body\n-from vyper.old_codegen.types.types import ByteArrayLike, get_size_of_type\n-from vyper.utils import MemoryPositions\n-\n-\n-def get_external_arg_copier(\n-    total_size: int, memory_dest: int, offset: Union[int, List[Any]] = 4\n-) -> List[Any]:\n-    \"\"\"\n-    Generate argument copier.\n-\n-    :param total_size: total memory size to copy\n-    :param memory_dest: base memory address to start from\n-    :param offset: starting offset, used for ByteArrays\n-    \"\"\"\n-    copier = [\"calldatacopy\", memory_dest, offset, total_size]\n-    return copier\n-\n-\n-def parse_external_function(\n-    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,\n-) -> LLLnode:\n-    \"\"\"\n-    Parse a external function (FuncDef), and produce full function body.\n-\n-    :param sig: the FuntionSignature\n-    :param code: ast of function\n-    :param check_nonpayable: if True, include a check that `msg.value == 0`\n-                             at the beginning of the function\n-    :return: full sig compare & function body\n-    \"\"\"\n-\n-    func_type = code._metadata[\"type\"]\n-\n-    # Get nonreentrant lock\n-    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)\n-\n-    clampers = []\n-\n-    # Generate copiers\n-    copier: List[Any] = [\"pass\"]\n-    if not len(sig.base_args):\n-        copier = [\"pass\"]\n-    elif sig.name == \"__init__\":\n-        copier = [\"codecopy\", MemoryPositions.RESERVED_MEMORY, \"~codelen\", sig.base_copy_size]\n-        context.memory_allocator.expand_memory(sig.max_copy_size)\n-    clampers.append(copier)\n-\n-    if check_nonpayable and sig.mutability != \"payable\":\n-        # if the contract contains payable functions, but this is not one of them\n-        # add an assertion that the value of the call is zero\n-        clampers.append([\"assert\", [\"iszero\", \"callvalue\"]])\n-\n-    # Fill variable positions\n-    default_args_start_pos = len(sig.base_args)\n-    for i, arg in enumerate(sig.args):\n-        if i < len(sig.base_args):\n-            clampers.append(\n-                make_arg_clamper(\n-                    arg.pos,\n-                    context.memory_allocator.get_next_memory_position(),\n-                    arg.typ,\n-                    sig.name == \"__init__\",\n-                )\n-            )\n-        if isinstance(arg.typ, ByteArrayLike):\n-            mem_pos = context.memory_allocator.expand_memory(32 * get_size_of_type(arg.typ))\n-            context.vars[arg.name] = VariableRecord(arg.name, mem_pos, arg.typ, False)\n-        else:\n-            if sig.name == \"__init__\":\n-                context.vars[arg.name] = VariableRecord(\n-                    arg.name, MemoryPositions.RESERVED_MEMORY + arg.pos, arg.typ, False,\n-                )\n-            elif i >= default_args_start_pos:  # default args need to be allocated in memory.\n-                type_size = get_size_of_type(arg.typ) * 32\n-                default_arg_pos = context.memory_allocator.expand_memory(type_size)\n-                context.vars[arg.name] = VariableRecord(\n-                    name=arg.name, pos=default_arg_pos, typ=arg.typ, mutable=False,\n-                )\n-            else:\n-                context.vars[arg.name] = VariableRecord(\n-                    name=arg.name, pos=4 + arg.pos, typ=arg.typ, mutable=False, location=\"calldata\"\n-                )\n-\n-    # Create \"clampers\" (input well-formedness checkers)\n-    # Return function body\n-    if sig.name == \"__init__\":\n-        o = LLLnode.from_list(\n-            [\"seq\"] + clampers + [parse_body(code.body, context)],  # type: ignore\n-            pos=getpos(code),\n-        )\n-    # Is default function.\n-    elif sig.is_default_func():\n-        o = LLLnode.from_list(\n-            [\"seq\"] + clampers + [parse_body(code.body, context)] + [[\"stop\"]],  # type: ignore\n-            pos=getpos(code),\n-        )\n-    # Is a normal function.\n-    else:\n-        # Function with default parameters.\n-        if sig.total_default_args > 0:\n-            function_routine = f\"{sig.name}_{sig.method_id}\"\n-            default_sigs = sig_utils.generate_default_arg_sigs(\n-                code, context.sigs, context.global_ctx\n-            )\n-            sig_chain: List[Any] = [\"seq\"]\n-\n-            for default_sig in default_sigs:\n-                sig_compare, _ = get_sig_statements(default_sig, getpos(code))\n-\n-                # Populate unset default variables\n-                set_defaults = []\n-                for arg_name in get_default_names_to_set(sig, default_sig):\n-                    value = Expr(sig.default_values[arg_name], context).lll_node\n-                    var = context.vars[arg_name]\n-                    left = LLLnode.from_list(\n-                        var.pos,\n-                        typ=var.typ,\n-                        location=\"memory\",\n-                        pos=getpos(code),\n-                        mutable=var.mutable,\n-                    )\n-                    set_defaults.append(make_setter(left, value, \"memory\", pos=getpos(code)))\n-\n-                current_sig_arg_names = {x.name for x in default_sig.args}\n-                base_arg_names = {arg.name for arg in sig.base_args}\n-                copier_arg_count = len(default_sig.args) - len(sig.base_args)\n-                copier_arg_names = list(current_sig_arg_names - base_arg_names)\n-\n-                # Order copier_arg_names, this is very important.\n-                copier_arg_names = [x.name for x in default_sig.args if x.name in copier_arg_names]\n-\n-                # Variables to be populated from calldata/stack.\n-                default_copiers: List[Any] = []\n-                if copier_arg_count > 0:\n-                    # Get map of variables in calldata, with thier offsets\n-                    offset = 4\n-                    calldata_offset_map = {}\n-                    for arg in default_sig.args:\n-                        calldata_offset_map[arg.name] = offset\n-                        offset += (\n-                            32\n-                            if isinstance(arg.typ, ByteArrayLike)\n-                            else get_size_of_type(arg.typ) * 32\n-                        )\n-\n-                    # Copy default parameters from calldata.\n-                    for arg_name in copier_arg_names:\n-                        var = context.vars[arg_name]\n-                        calldata_offset = calldata_offset_map[arg_name]\n-\n-                        # Add clampers.\n-                        default_copiers.append(\n-                            make_arg_clamper(calldata_offset - 4, var.pos, var.typ,)\n-                        )\n-                        # Add copying code.\n-                        _offset: Union[int, List[Any]] = calldata_offset\n-                        if isinstance(var.typ, ByteArrayLike):\n-                            _offset = [\"add\", 4, [\"calldataload\", calldata_offset]]\n-                        default_copiers.append(\n-                            get_external_arg_copier(\n-                                memory_dest=var.pos, total_size=var.size * 32, offset=_offset,\n-                            )\n-                        )\n-\n-                    default_copiers.append(0)  # for over arching seq, POP\n-\n-                sig_chain.append(\n-                    [\n-                        \"if\",\n-                        sig_compare,\n-                        [\n-                            \"seq\",\n-                            [\"seq\"] + set_defaults if set_defaults else [\"pass\"],\n-                            [\"seq_unchecked\"] + default_copiers if default_copiers else [\"pass\"],\n-                            [\"goto\", function_routine],\n-                        ],\n-                    ]\n-                )\n-\n-            # Function with default parameters.\n-            function_jump_label = f\"{sig.name}_{sig.method_id}_skip\"\n-            o = LLLnode.from_list(\n-                [\n-                    \"seq\",\n-                    sig_chain,\n-                    [\n-                        \"seq\",\n-                        [\"goto\", function_jump_label],\n-                        [\"label\", function_routine],\n-                        [\"seq\"]\n-                        + nonreentrant_pre\n-                        + clampers\n-                        + [parse_body(c, context) for c in code.body]\n-                        + nonreentrant_post\n-                        + [[\"stop\"]],\n-                        [\"label\", function_jump_label],\n-                    ],\n-                ],\n-                typ=None,\n-                pos=getpos(code),\n-            )\n-\n-        else:\n-            # Function without default parameters.\n-            sig_compare, _ = get_sig_statements(sig, getpos(code))\n-            o = LLLnode.from_list(\n-                [\n-                    \"if\",\n-                    sig_compare,\n-                    [\"seq\"]\n-                    + nonreentrant_pre\n-                    + clampers\n-                    + [parse_body(c, context) for c in code.body]\n-                    + nonreentrant_post\n-                    + [[\"stop\"]],\n-                ],\n-                typ=None,\n-                pos=getpos(code),\n-            )\n-    return o"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/parse_function.py",
          "status": "removed",
          "additions": 0,
          "deletions": 67,
          "patch": "@@ -1,67 +0,0 @@\n-# can't use from [module] import [object] because it breaks mocks in testing\n-from vyper.ast.signatures import FunctionSignature\n-from vyper.old_codegen import context as ctx\n-from vyper.old_codegen.context import Constancy\n-# NOTE black/isort conflict >>\n-from vyper.old_codegen.function_definitions.parse_external_function import (\n-    parse_external_function,\n-)\n-# NOTE black/isort conflict >>\n-from vyper.old_codegen.function_definitions.parse_internal_function import (\n-    parse_internal_function,\n-)\n-from vyper.old_codegen.memory_allocator import MemoryAllocator\n-from vyper.utils import calc_mem_gas\n-\n-\n-# Is a function the initializer?\n-def is_initializer(code):\n-    return code.name == \"__init__\"\n-\n-\n-# Is a function the default function?\n-def is_default_func(code):\n-    return code.name == \"__default__\"\n-\n-\n-def parse_function(code, sigs, global_ctx, check_nonpayable, _vars=None):\n-    \"\"\"\n-    Parses a function and produces LLL code for the function, includes:\n-        - Signature method if statement\n-        - Argument handling\n-        - Clamping and copying of arguments\n-        - Function body\n-    \"\"\"\n-    if _vars is None:\n-        _vars = {}\n-    sig = FunctionSignature.from_definition(code, sigs=sigs, custom_structs=global_ctx._structs,)\n-\n-    # Validate return statements.\n-    sig.validate_return_statement_balance()\n-\n-    # Create a local (per function) context.\n-    memory_allocator = MemoryAllocator()\n-    context = ctx.Context(\n-        vars=_vars,\n-        global_ctx=global_ctx,\n-        sigs=sigs,\n-        memory_allocator=memory_allocator,\n-        return_type=sig.output_type,\n-        constancy=Constancy.Constant if sig.mutability in (\"view\", \"pure\") else Constancy.Mutable,\n-        is_payable=sig.mutability == \"payable\",\n-        is_internal=sig.internal,\n-        method_id=sig.method_id,\n-        sig=sig,\n-    )\n-\n-    if sig.internal:\n-        o = parse_internal_function(code=code, sig=sig, context=context,)\n-    else:\n-        o = parse_external_function(\n-            code=code, sig=sig, context=context, check_nonpayable=check_nonpayable\n-        )\n-\n-    o.context = context\n-    o.total_gas = o.gas + calc_mem_gas(o.context.memory_allocator.size_of_mem)\n-    o.func_name = sig.name\n-    return o"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/parse_internal_function.py",
          "status": "removed",
          "additions": 0,
          "deletions": 244,
          "patch": "@@ -1,244 +0,0 @@\n-from typing import Any, List\n-\n-from vyper import ast as vy_ast\n-from vyper.ast.signatures import FunctionSignature, sig_utils\n-from vyper.ast.signatures.function_signature import VariableRecord\n-from vyper.old_codegen.context import Context\n-from vyper.old_codegen.expr import Expr\n-from vyper.old_codegen.function_definitions.utils import (\n-    get_default_names_to_set,\n-    get_nonreentrant_lock,\n-    get_sig_statements,\n-    make_unpacker,\n-)\n-from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.parser_utils import getpos, make_setter\n-from vyper.old_codegen.stmt import parse_body\n-from vyper.old_codegen.types.types import (\n-    BaseType,\n-    ByteArrayLike,\n-    get_size_of_type,\n-)\n-from vyper.utils import MemoryPositions\n-\n-\n-def get_internal_arg_copier(total_size: int, memory_dest: int) -> List[Any]:\n-    \"\"\"\n-    Copy arguments.\n-    For internal functions, MSTORE arguments and callback pointer from the stack.\n-\n-    :param  total_size: total size to copy\n-    :param  memory_dest: base memory position to copy to\n-    :return: LLL list that copies total_size of memory\n-    \"\"\"\n-\n-    copier: List[Any] = [\"seq\"]\n-    for pos in range(0, total_size, 32):\n-        copier.append([\"mstore\", memory_dest + pos, \"pass\"])\n-    return copier\n-\n-\n-def parse_internal_function(\n-    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context\n-) -> LLLnode:\n-    \"\"\"\n-    Parse a internal function (FuncDef), and produce full function body.\n-\n-    :param sig: the FuntionSignature\n-    :param code: ast of function\n-    :return: full sig compare & function body\n-    \"\"\"\n-\n-    func_type = code._metadata[\"type\"]\n-\n-    # Get nonreentrant lock\n-    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)\n-\n-    # Create callback_ptr, this stores a destination in the bytecode for a internal\n-    # function to jump to after a function has executed.\n-    clampers: List[LLLnode] = []\n-\n-    # Allocate variable space.\n-    context.memory_allocator.expand_memory(sig.max_copy_size)\n-\n-    _post_callback_ptr = f\"{sig.name}_{sig.method_id}_post_callback_ptr\"\n-    context.callback_ptr = context.new_internal_variable(typ=BaseType(\"uint256\"))\n-    clampers.append(\n-        LLLnode.from_list(\n-            [\"mstore\", context.callback_ptr, \"pass\"], annotation=\"pop callback pointer\",\n-        )\n-    )\n-    if sig.total_default_args > 0:\n-        clampers.append(LLLnode.from_list([\"label\", _post_callback_ptr]))\n-\n-    # internal functions without return types need to jump back to\n-    # the calling function, as there is no return statement to handle the\n-    # jump.\n-    if sig.output_type is None:\n-        stop_func = [[\"jump\", [\"mload\", context.callback_ptr]]]\n-    else:\n-        stop_func = [[\"stop\"]]\n-\n-    # Generate copiers\n-    if len(sig.base_args) == 0:\n-        copier = [\"pass\"]\n-        clampers.append(LLLnode.from_list(copier))\n-    elif sig.total_default_args == 0:\n-        copier = get_internal_arg_copier(\n-            total_size=sig.base_copy_size, memory_dest=MemoryPositions.RESERVED_MEMORY\n-        )\n-        clampers.append(LLLnode.from_list(copier))\n-\n-    # Fill variable positions\n-    for arg in sig.args:\n-        if isinstance(arg.typ, ByteArrayLike):\n-            mem_pos = context.memory_allocator.expand_memory(32 * get_size_of_type(arg.typ))\n-            context.vars[arg.name] = VariableRecord(arg.name, mem_pos, arg.typ, False)\n-        else:\n-            context.vars[arg.name] = VariableRecord(\n-                arg.name, MemoryPositions.RESERVED_MEMORY + arg.pos, arg.typ, False,\n-            )\n-\n-    # internal function copiers. No clamping for internal functions.\n-    dyn_variable_names = [a.name for a in sig.base_args if isinstance(a.typ, ByteArrayLike)]\n-    if dyn_variable_names:\n-        i_placeholder = context.new_internal_variable(typ=BaseType(\"uint256\"))\n-        unpackers: List[Any] = []\n-        for idx, var_name in enumerate(dyn_variable_names):\n-            var = context.vars[var_name]\n-            ident = f\"_load_args_{sig.method_id}_dynarg{idx}\"\n-            o = make_unpacker(ident=ident, i_placeholder=i_placeholder, begin_pos=var.pos)\n-            unpackers.append(o)\n-\n-        if not unpackers:\n-            unpackers = [\"pass\"]\n-\n-        # 0 added to complete full overarching 'seq' statement, see internal_label.\n-        unpackers.append(0)\n-        clampers.append(\n-            LLLnode.from_list(\n-                [\"seq_unchecked\"] + unpackers,\n-                typ=None,\n-                annotation=\"dynamic unpacker\",\n-                pos=getpos(code),\n-            )\n-        )\n-\n-    # Function has default arguments.\n-    if sig.total_default_args > 0:  # Function with default parameters.\n-\n-        default_sigs = sig_utils.generate_default_arg_sigs(code, context.sigs, context.global_ctx)\n-        sig_chain: List[Any] = [\"seq\"]\n-\n-        for default_sig in default_sigs:\n-            sig_compare, internal_label = get_sig_statements(default_sig, getpos(code))\n-\n-            # Populate unset default variables\n-            set_defaults = []\n-            for arg_name in get_default_names_to_set(sig, default_sig):\n-                value = Expr(sig.default_values[arg_name], context).lll_node\n-                var = context.vars[arg_name]\n-                left = LLLnode.from_list(\n-                    var.pos, typ=var.typ, location=\"memory\", pos=getpos(code), mutable=var.mutable\n-                )\n-                set_defaults.append(make_setter(left, value, \"memory\", pos=getpos(code)))\n-            current_sig_arg_names = [x.name for x in default_sig.args]\n-\n-            # Load all variables in default section, if internal,\n-            # because the stack is a linear pipe.\n-            copier_arg_count = len(default_sig.args)\n-            copier_arg_names = current_sig_arg_names\n-\n-            # Order copier_arg_names, this is very important.\n-            copier_arg_names = [x.name for x in default_sig.args if x.name in copier_arg_names]\n-\n-            # Variables to be populated from calldata/stack.\n-            default_copiers: List[Any] = []\n-            if copier_arg_count > 0:\n-                # Get map of variables in calldata, with thier offsets\n-                offset = 4\n-                calldata_offset_map = {}\n-                for arg in default_sig.args:\n-                    calldata_offset_map[arg.name] = offset\n-                    offset += (\n-                        32 if isinstance(arg.typ, ByteArrayLike) else get_size_of_type(arg.typ) * 32\n-                    )\n-\n-                # Copy set default parameters from calldata\n-                dynamics = []\n-                for arg_name in copier_arg_names:\n-                    var = context.vars[arg_name]\n-                    if isinstance(var.typ, ByteArrayLike):\n-                        _size = 32\n-                        dynamics.append(var.pos)\n-                    else:\n-                        _size = var.size * 32\n-                    default_copiers.append(\n-                        get_internal_arg_copier(memory_dest=var.pos, total_size=_size,)\n-                    )\n-\n-                # Unpack byte array if necessary.\n-                if dynamics:\n-                    i_placeholder = context.new_internal_variable(typ=BaseType(\"uint256\"))\n-                    for idx, var_pos in enumerate(dynamics):\n-                        ident = f\"unpack_default_sig_dyn_{default_sig.method_id}_arg{idx}\"\n-                        default_copiers.append(\n-                            make_unpacker(\n-                                ident=ident, i_placeholder=i_placeholder, begin_pos=var_pos,\n-                            )\n-                        )\n-                default_copiers.append(0)  # for over arching seq, POP\n-\n-            sig_chain.append(\n-                [\n-                    \"if\",\n-                    sig_compare,\n-                    [\n-                        \"seq\",\n-                        internal_label,\n-                        LLLnode.from_list(\n-                            [\"mstore\", context.callback_ptr, \"pass\"],\n-                            annotation=\"pop callback pointer\",\n-                            pos=getpos(code),\n-                        ),\n-                        [\"seq\"] + set_defaults if set_defaults else [\"pass\"],\n-                        [\"seq_unchecked\"] + default_copiers if default_copiers else [\"pass\"],\n-                        [\"goto\", _post_callback_ptr],\n-                    ],\n-                ]\n-            )\n-\n-        # With internal functions all variable loading occurs in the default\n-        # function sub routine.\n-        _clampers = [[\"label\", _post_callback_ptr]]\n-\n-        # Function with default parameters.\n-        return LLLnode.from_list(\n-            [\n-                \"seq\",\n-                sig_chain,\n-                [\"seq\"]\n-                + nonreentrant_pre\n-                + _clampers\n-                + [parse_body(c, context) for c in code.body]\n-                + nonreentrant_post\n-                + stop_func,\n-            ],\n-            typ=None,\n-            pos=getpos(code),\n-        )\n-\n-    else:\n-        # Function without default parameters.\n-        sig_compare, internal_label = get_sig_statements(sig, getpos(code))\n-        return LLLnode.from_list(\n-            [\"seq\"]\n-            + [internal_label]\n-            + nonreentrant_pre\n-            + clampers\n-            + [parse_body(c, context) for c in code.body]\n-            + nonreentrant_post\n-            + stop_func,\n-            typ=None,\n-            pos=getpos(code),\n-        )"
        },
        {
          "filename": "vyper/old_codegen/function_definitions/utils.py",
          "status": "modified",
          "additions": 6,
          "deletions": 59,
          "patch": "@@ -1,61 +1,8 @@\n-from vyper.old_codegen.lll_node import LLLnode\n-\n-\n-def get_sig_statements(sig, pos):\n-    method_id_node = LLLnode.from_list(sig.method_id, pos=pos, annotation=f\"{sig.sig}\")\n-\n-    if sig.internal:\n-        sig_compare = 0\n-        private_label = LLLnode.from_list(\n-            [\"label\", f\"priv_{sig.method_id}\"], pos=pos, annotation=f\"{sig.sig}\"\n-        )\n-    else:\n-        sig_compare = [\"eq\", \"_func_sig\", method_id_node]\n-        private_label = [\"pass\"]\n-\n-    return sig_compare, private_label\n-\n-\n-def make_unpacker(ident, i_placeholder, begin_pos):\n-    start_label = \"dyn_unpack_start_\" + ident\n-    end_label = \"dyn_unpack_end_\" + ident\n-    return [\n-        \"seq_unchecked\",\n-        [\"mstore\", begin_pos, \"pass\"],  # get len\n-        [\"mstore\", i_placeholder, 0],\n-        [\"label\", start_label],\n-        [  # break\n-            \"if\",\n-            [\"ge\", [\"mload\", i_placeholder], [\"ceil32\", [\"mload\", begin_pos]]],\n-            [\"goto\", end_label],\n-        ],\n-        [  # pop into correct memory slot.\n-            \"mstore\",\n-            [\"add\", [\"add\", begin_pos, 32], [\"mload\", i_placeholder]],\n-            \"pass\",\n-        ],\n-        [\"mstore\", i_placeholder, [\"add\", 32, [\"mload\", i_placeholder]]],  # increment i\n-        [\"goto\", start_label],\n-        [\"label\", end_label],\n-    ]\n-\n-\n def get_nonreentrant_lock(func_type):\n-    nonreentrant_pre = [[\"pass\"]]\n-    nonreentrant_post = [[\"pass\"]]\n-    if func_type.nonreentrant:\n-        nkey = func_type.reentrancy_key_position.position\n-        nonreentrant_pre = [[\"seq\", [\"assert\", [\"iszero\", [\"sload\", nkey]]], [\"sstore\", nkey, 1]]]\n-        nonreentrant_post = [[\"sstore\", nkey, 0]]\n-    return nonreentrant_pre, nonreentrant_post\n+    if not func_type.nonreentrant:\n+        return [\"pass\"], [\"pass\"]\n \n-\n-def get_default_names_to_set(primary_sig, default_sig):\n-    \"\"\"\n-    Get names for default parameters that require a default value to be assigned.\n-    \"\"\"\n-\n-    current_sig_arg_names = [x.name for x in default_sig.args]\n-    for arg in primary_sig.default_args:\n-        if arg.arg not in current_sig_arg_names:\n-            yield arg.arg\n+    nkey = func_type.reentrancy_key_position.position\n+    nonreentrant_pre = [[\"seq\", [\"assert\", [\"iszero\", [\"sload\", nkey]]], [\"sstore\", nkey, 1]]]\n+    nonreentrant_post = [[\"sstore\", nkey, 0]]\n+    return nonreentrant_pre, nonreentrant_post"
        },
        {
          "filename": "vyper/old_codegen/global_context.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -219,5 +219,5 @@ def add_globals_and_events(self, item):\n         else:\n             raise InvalidType(\"Invalid global type specified\", item)\n \n-    def parse_type(self, ast_node, location):\n+    def parse_type(self, ast_node, location=None):\n         return parse_type(ast_node, location, sigs=self._contracts, custom_structs=self._structs,)"
        },
        {
          "filename": "vyper/old_codegen/keccak256_helper.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -19,6 +19,7 @@ def _gas_bound(num_words):\n     return SHA3_BASE + num_words * SHA3_PER_WORD\n \n \n+# TODO kwargs is dead argument\n def keccak256_helper(expr, lll_args, kwargs, context):\n     if len(lll_args) != 1:\n         # NOTE this may be checked at a higher level, but just be safe"
        },
        {
          "filename": "vyper/old_codegen/lll_node.py",
          "status": "modified",
          "additions": 55,
          "deletions": 6,
          "patch": "@@ -1,11 +1,12 @@\n import re\n+from enum import Enum, auto\n from typing import Any, List, Optional, Tuple, Union\n \n from vyper.compiler.settings import VYPER_COLOR_OUTPUT\n from vyper.evm.opcodes import get_comb_opcodes\n from vyper.exceptions import CompilerPanic\n from vyper.old_codegen.types import BaseType, NodeType, ceil32\n-from vyper.utils import VALID_LLL_MACROS\n+from vyper.utils import VALID_LLL_MACROS, cached_property\n \n # Set default string representation for ints in LLL output.\n AS_HEX_DEFAULT = False\n@@ -35,6 +36,21 @@ def __repr__(self) -> str:\n     __mul__ = __add__\n \n \n+def push_label_to_stack(labelname: str) -> str:\n+    #  items prefixed with `_sym_` are ignored until asm phase\n+    return \"_sym_\" + labelname\n+\n+\n+class Encoding(Enum):\n+    # vyper encoding, default for memory variables\n+    VYPER = auto()\n+    # abi encoded, default for args/return values from external funcs\n+    ABI = auto()\n+    # abi encoded, same as ABI but no clamps for bytestrings\n+    JSON_ABI = auto()\n+    # future: packed\n+\n+\n # Data structure for LLL parse tree\n class LLLnode:\n     repr_show_gas = False\n@@ -47,26 +63,29 @@ def __init__(\n         self,\n         value: Union[str, int],\n         args: List[\"LLLnode\"] = None,\n-        typ: \"BaseType\" = None,\n+        typ: NodeType = None,\n         location: str = None,\n         pos: Optional[Tuple[int, int]] = None,\n         annotation: Optional[str] = None,\n         mutable: bool = True,\n         add_gas_estimate: int = 0,\n         valency: Optional[int] = None,\n+        encoding: Encoding = Encoding.VYPER,\n     ):\n         if args is None:\n             args = []\n \n         self.value = value\n         self.args = args\n+        # TODO remove this sanity check once mypy is more thorough\n+        assert isinstance(typ, NodeType) or typ is None, repr(typ)\n         self.typ = typ\n-        assert isinstance(self.typ, NodeType) or self.typ is None, repr(self.typ)\n         self.location = location\n         self.pos = pos\n         self.annotation = annotation\n         self.mutable = mutable\n         self.add_gas_estimate = add_gas_estimate\n+        self.encoding = encoding\n         self.as_hex = AS_HEX_DEFAULT\n \n         # Optional annotation properties for gas estimation\n@@ -136,9 +155,11 @@ def __init__(\n             # With statements: with <var> <initial> <statement>\n             elif self.value == \"with\":\n                 if len(self.args) != 3:\n-                    raise CompilerPanic(\"With statement must have 3 arguments\")\n+                    raise CompilerPanic(f\"With statement must have 3 arguments: {self}\")\n                 if len(self.args[0].args) or not isinstance(self.args[0].value, str):\n-                    raise CompilerPanic(\"First argument to with statement must be a variable\")\n+                    raise CompilerPanic(\n+                        f\"First argument to with statement must be a variable: {self}\"\n+                    )\n                 if not self.args[1].valency and self.args[1].value != \"pass\":\n                     raise CompilerPanic(\n                         (\n@@ -203,6 +224,16 @@ def __init__(\n             elif self.value == \"seq\":\n                 self.valency = self.args[-1].valency if self.args else 0\n                 self.gas = sum([arg.gas for arg in self.args]) + 30\n+\n+            # GOTO is a jump with args\n+            # e.g. (goto my_label x y z) will push x y and z onto the stack,\n+            # then JUMP to my_label.\n+            elif self.value == \"goto\":\n+                for arg in self.args:\n+                    if not arg.valency and arg.value != \"pass\":\n+                        raise CompilerPanic(f\"zerovalent argument to goto {self}\")\n+                self.valency = 0\n+                self.gas = sum([arg.gas for arg in self.args])\n             # Multi statements: multi <expr> <expr> ...\n             elif self.value == \"multi\":\n                 for arg in self.args:\n@@ -238,6 +269,17 @@ def __init__(\n \n         self.gas += self.add_gas_estimate\n \n+    # the LLL should be cached.\n+    @property\n+    def is_complex_lll(self):\n+        return isinstance(self.value, str) and (\n+            self.value.lower() in VALID_LLL_MACROS or self.value.upper() in get_comb_opcodes()\n+        )\n+\n+    @cached_property\n+    def contains_self_call(self):\n+        return getattr(self, \"is_self_call\", False) or any(x.contains_self_call for x in self.args)\n+\n     def __getitem__(self, i):\n         return self.to_list()[i]\n \n@@ -328,13 +370,14 @@ def __repr__(self):\n     def from_list(\n         cls,\n         obj: Any,\n-        typ: \"BaseType\" = None,\n+        typ: NodeType = None,\n         location: str = None,\n         pos: Tuple[int, int] = None,\n         annotation: Optional[str] = None,\n         mutable: bool = True,\n         add_gas_estimate: int = 0,\n         valency: Optional[int] = None,\n+        encoding: Encoding = Encoding.VYPER,\n     ) -> \"LLLnode\":\n         if isinstance(typ, str):\n             typ = BaseType(typ)\n@@ -348,6 +391,9 @@ def from_list(\n                 obj.pos = pos\n             if obj.location is None:\n                 obj.location = location\n+            if obj.encoding is None:\n+                obj.encoding = encoding\n+\n             return obj\n         elif not isinstance(obj, list):\n             return cls(\n@@ -359,6 +405,8 @@ def from_list(\n                 annotation=annotation,\n                 mutable=mutable,\n                 add_gas_estimate=add_gas_estimate,\n+                valency=valency,\n+                encoding=encoding,\n             )\n         else:\n             return cls(\n@@ -371,4 +419,5 @@ def from_list(\n                 mutable=mutable,\n                 add_gas_estimate=add_gas_estimate,\n                 valency=valency,\n+                encoding=encoding,\n             )"
        },
        {
          "filename": "vyper/old_codegen/parser.py",
          "status": "modified",
          "additions": 66,
          "deletions": 46,
          "patch": "@@ -1,17 +1,16 @@\n-from typing import Any, List, Optional, Tuple\n+from typing import Any, List, Optional, Tuple, Union\n \n from vyper import ast as vy_ast\n-from vyper.ast.signatures import sig_utils\n from vyper.ast.signatures.function_signature import FunctionSignature\n from vyper.exceptions import (\n     EventDeclarationException,\n     FunctionDeclarationException,\n     StructureException,\n )\n from vyper.old_codegen.function_definitions import (\n+    generate_lll_for_function,\n     is_default_func,\n     is_initializer,\n-    parse_function,\n )\n from vyper.old_codegen.global_context import GlobalContext\n from vyper.old_codegen.lll_node import LLLnode\n@@ -29,7 +28,7 @@\n     # check that calldatasize is at least 4, otherwise\n     # calldataload will load zeros (cf. yellow paper).\n     [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],\n-    [\"mstore\", 28, [\"calldataload\", 0]],\n+    [\"calldatacopy\", 28, 0, 4],\n ]\n # Store limit constants at fixed addresses in memory.\n LIMIT_MEMORY_SET: List[Any] = [\n@@ -47,6 +46,7 @@ def init_func_init_lll():\n \n def parse_external_interfaces(external_interfaces, global_ctx):\n     for _interfacename in global_ctx._contracts:\n+        # TODO factor me into helper function\n         _interface_defs = global_ctx._contracts[_interfacename]\n         _defnames = [_def.name for _def in _interface_defs]\n         interface = {}\n@@ -87,79 +87,99 @@ def parse_external_interfaces(external_interfaces, global_ctx):\n     return external_interfaces\n \n \n-def parse_other_functions(o, otherfuncs, sigs, external_interfaces, global_ctx, default_function):\n+def parse_regular_functions(\n+    o, regular_functions, sigs, external_interfaces, global_ctx, default_function\n+):\n     # check for payable/nonpayable external functions to optimize nonpayable assertions\n     func_types = [i._metadata[\"type\"] for i in global_ctx._defs]\n     mutabilities = [i.mutability for i in func_types if i.visibility == FunctionVisibility.EXTERNAL]\n-    has_payable = next((True for i in mutabilities if i == StateMutability.PAYABLE), False)\n-    has_nonpayable = next((True for i in mutabilities if i != StateMutability.PAYABLE), False)\n+    has_payable = any(i == StateMutability.PAYABLE for i in mutabilities)\n+    has_nonpayable = any(i != StateMutability.PAYABLE for i in mutabilities)\n+\n     is_default_payable = (\n         default_function is not None\n         and default_function._metadata[\"type\"].mutability == StateMutability.PAYABLE\n     )\n+\n+    # TODO streamline the nonpayable check logic\n+\n     # when a contract has a payable default function and at least one nonpayable\n     # external function, we must perform the nonpayable check on every function\n     check_per_function = is_default_payable and has_nonpayable\n \n     # generate LLL for regular functions\n-    payable_func_sub = [\"seq\"]\n-    external_func_sub = [\"seq\"]\n-    internal_func_sub = [\"seq\"]\n+    payable_funcs = []\n+    nonpayable_funcs = []\n+    internal_funcs = []\n     add_gas = func_init_lll().gas\n \n-    for func_node in otherfuncs:\n+    for func_node in regular_functions:\n         func_type = func_node._metadata[\"type\"]\n-        func_lll = parse_function(\n+        func_lll, frame_start, frame_size = generate_lll_for_function(\n             func_node, {**{\"self\": sigs}, **external_interfaces}, global_ctx, check_per_function\n         )\n+\n         if func_type.visibility == FunctionVisibility.INTERNAL:\n-            internal_func_sub.append(func_lll)\n+            internal_funcs.append(func_lll)\n+\n         elif func_type.mutability == StateMutability.PAYABLE:\n-            add_gas += 30\n-            payable_func_sub.append(func_lll)\n+            add_gas += 30  # CMC 20210910 why?\n+            payable_funcs.append(func_lll)\n+\n         else:\n-            external_func_sub.append(func_lll)\n-            add_gas += 30\n+            add_gas += 30  # CMC 20210910 why?\n+            nonpayable_funcs.append(func_lll)\n+\n         func_lll.total_gas += add_gas\n-        for sig in sig_utils.generate_default_arg_sigs(func_node, external_interfaces, global_ctx):\n-            sig.gas = func_lll.total_gas\n-            sigs[sig.sig] = sig\n+\n+        # update sigs with metadata gathered from compiling the function so that\n+        # we can handle calls to self\n+        # TODO we only need to do this for internal functions; external functions\n+        # cannot be called via `self`\n+        sig = FunctionSignature.from_definition(func_node, external_interfaces, global_ctx._structs)\n+        sig.gas = func_lll.total_gas\n+        sig.frame_start = frame_start\n+        sig.frame_size = frame_size\n+        sigs[sig.name] = sig\n \n     # generate LLL for fallback function\n     if default_function:\n-        fallback_lll = parse_function(\n+        fallback_lll, _frame_start, _frame_size = generate_lll_for_function(\n             default_function,\n             {**{\"self\": sigs}, **external_interfaces},\n             global_ctx,\n             # include a nonpayble check here if the contract only has a default function\n-            check_per_function or not otherfuncs,\n+            check_per_function or not regular_functions,\n         )\n     else:\n         fallback_lll = LLLnode.from_list([\"revert\", 0, 0], typ=None, annotation=\"Default function\")\n \n     if check_per_function:\n-        external_seq = [\"seq\", payable_func_sub, external_func_sub]\n+        external_seq = [\"seq\"] + payable_funcs + nonpayable_funcs\n+\n     else:\n         # payable functions are placed prior to nonpayable functions\n         # and seperated by a nonpayable assertion\n         external_seq = [\"seq\"]\n         if has_payable:\n-            external_seq.append(payable_func_sub)\n+            external_seq += payable_funcs\n         if has_nonpayable:\n-            external_seq.extend([[\"assert\", [\"iszero\", \"callvalue\"]], external_func_sub])\n+            external_seq.append([\"assert\", [\"iszero\", \"callvalue\"]])\n+            external_seq += nonpayable_funcs\n \n     # bytecode is organized by: external functions, fallback fn, internal functions\n     # this way we save gas and reduce bytecode by not jumping over internal functions\n-    main_seq = [\n+    runtime = [\n         \"seq\",\n         func_init_lll(),\n-        [\"with\", \"_func_sig\", [\"mload\", 0], external_seq],\n+        [\"with\", \"_calldata_method_id\", [\"mload\", 0], external_seq],\n         [\"seq_unchecked\", [\"label\", \"fallback\"], fallback_lll],\n-        internal_func_sub,\n     ]\n+    runtime.extend(internal_funcs)\n \n-    o.append([\"return\", 0, [\"lll\", main_seq, 0]])\n-    return o, main_seq\n+    # TODO CMC 20210911 why does the lll have a trailing 0\n+    o.append([\"return\", 0, [\"lll\", runtime, 0]])\n+    return o, runtime\n \n \n # Main python parse tree => LLL method\n@@ -179,40 +199,40 @@ def parse_tree_to_lll(global_ctx: GlobalContext) -> Tuple[LLLnode, LLLnode]:\n             {[name for name in _names_events if _names_events.count(name) > 1][0]}\"\"\"\n         )\n     # Initialization function\n-    initfunc = [_def for _def in global_ctx._defs if is_initializer(_def)]\n+    init_function = next((_def for _def in global_ctx._defs if is_initializer(_def)), None)\n     # Default function\n-    defaultfunc = next((i for i in global_ctx._defs if is_default_func(i)), None)\n-    # Regular functions\n-    otherfuncs = [\n+    default_function = next((i for i in global_ctx._defs if is_default_func(i)), None)\n+\n+    regular_functions = [\n         _def for _def in global_ctx._defs if not is_initializer(_def) and not is_default_func(_def)\n     ]\n \n     sigs: dict = {}\n     external_interfaces: dict = {}\n     # Create the main statement\n-    o = [\"seq\"]\n+    o: List[Union[str, LLLnode]] = [\"seq\"]\n     if global_ctx._contracts or global_ctx._interfaces:\n         external_interfaces = parse_external_interfaces(external_interfaces, global_ctx)\n-    # If there is an init func...\n-    if initfunc:\n+\n+    # TODO: fix for #2251 is to move this after parse_regular_functions\n+    if init_function:\n         o.append(init_func_init_lll())\n-        o.append(\n-            parse_function(\n-                initfunc[0], {**{\"self\": sigs}, **external_interfaces}, global_ctx, False,\n-            )\n+        init_func_lll, _frame_start, _frame_size = generate_lll_for_function(\n+            init_function, {**{\"self\": sigs}, **external_interfaces}, global_ctx, False,\n         )\n+        o.append(init_func_lll)\n \n-    # If there are regular functions...\n-    if otherfuncs or defaultfunc:\n-        o, runtime = parse_other_functions(\n-            o, otherfuncs, sigs, external_interfaces, global_ctx, defaultfunc,\n+    if regular_functions or default_function:\n+        o, runtime = parse_regular_functions(\n+            o, regular_functions, sigs, external_interfaces, global_ctx, default_function,\n         )\n     else:\n         runtime = o.copy()\n \n-    return LLLnode.from_list(o, typ=None), LLLnode.from_list(runtime, typ=None)\n+    return LLLnode.from_list(o), LLLnode.from_list(runtime)\n \n \n+# TODO this function is dead code\n def parse_to_lll(\n     source_code: str, runtime_only: bool = False, interface_codes: Optional[InterfaceImports] = None\n ) -> LLLnode:"
        },
        {
          "filename": "vyper/old_codegen/parser_utils.py",
          "status": "modified",
          "additions": 342,
          "deletions": 242,
          "patch": "@@ -1,6 +1,7 @@\n from decimal import Decimal, getcontext\n \n from vyper import ast as vy_ast\n+from vyper.evm.opcodes import version_check\n from vyper.exceptions import (\n     CompilerPanic,\n     InvalidLiteral,\n@@ -9,22 +10,26 @@\n     TypeMismatch,\n )\n from vyper.old_codegen.arg_clamps import int128_clamp\n-from vyper.old_codegen.lll_node import LLLnode\n+from vyper.old_codegen.lll_node import Encoding, LLLnode\n from vyper.old_codegen.types import (\n     BaseType,\n     ByteArrayLike,\n-    ByteArrayType,\n     ListType,\n     MappingType,\n     StructType,\n     TupleLike,\n     TupleType,\n     ceil32,\n     get_size_of_type,\n-    has_dynamic_data,\n     is_base_type,\n )\n-from vyper.utils import GAS_IDENTITY, GAS_IDENTITYWORD, MemoryPositions\n+from vyper.utils import (\n+    GAS_CALLDATACOPY_WORD,\n+    GAS_CODECOPY_WORD,\n+    GAS_IDENTITY,\n+    GAS_IDENTITYWORD,\n+    MemoryPositions,\n+)\n \n getcontext().prec = 78  # MAX_UINT256 < 1e78\n \n@@ -33,7 +38,7 @@ def type_check_wrapper(fn):\n     def _wrapped(*args, **kwargs):\n         return_value = fn(*args, **kwargs)\n         if return_value is None:\n-            raise TypeCheckFailure(f\"{fn.__name__} did not return a value\")\n+            raise TypeCheckFailure(f\"{fn.__name__} {args} did not return a value\")\n         return return_value\n \n     return _wrapped\n@@ -67,11 +72,18 @@ def _identity_gas_bound(num_bytes):\n     return GAS_IDENTITY + GAS_IDENTITYWORD * (ceil32(num_bytes) // 32)\n \n \n+def _calldatacopy_gas_bound(num_bytes):\n+    return GAS_CALLDATACOPY_WORD * ceil32(num_bytes) // 32\n+\n+\n+def _codecopy_gas_bound(num_bytes):\n+    return GAS_CODECOPY_WORD * ceil32(num_bytes) // 32\n+\n+\n # Copy byte array word-for-word (including layout)\n def make_byte_array_copier(destination, source, pos=None):\n     if not isinstance(source.typ, ByteArrayLike):\n-        btype = \"byte array\" if isinstance(destination.typ, ByteArrayType) else \"string\"\n-        raise TypeMismatch(f\"Can only set a {btype} to another {btype}\", pos)\n+        raise TypeMismatch(f\"Cannot cast from {source.typ} to {destination.typ}\", pos)\n     if isinstance(source.typ, ByteArrayLike) and source.typ.maxlen > destination.typ.maxlen:\n         raise TypeMismatch(\n             f\"Cannot cast from greater max-length {source.typ.maxlen} to shorter \"\n@@ -86,22 +98,24 @@ def make_byte_array_copier(destination, source, pos=None):\n             )\n \n     # Special case: memory to memory\n-    if source.location == \"memory\" and destination.location == \"memory\":\n+    # TODO: this should be handled by make_byte_slice_copier.\n+    if destination.location == \"memory\" and source.location in (\"memory\", \"code\", \"calldata\"):\n+        if source.location == \"memory\":\n+            # TODO turn this into an LLL macro: memorycopy\n+            copy_op = [\"assert\", [\"call\", [\"gas\"], 4, 0, \"src\", \"sz\", destination, \"sz\"]]\n+            gas_bound = _identity_gas_bound(source.typ.maxlen)\n+        elif source.location == \"calldata\":\n+            copy_op = [\"calldatacopy\", destination, \"src\", \"sz\"]\n+            gas_bound = _calldatacopy_gas_bound(source.typ.maxlen)\n+        elif source.location == \"code\":\n+            copy_op = [\"codecopy\", destination, \"src\", \"sz\"]\n+            gas_bound = _codecopy_gas_bound(source.typ.maxlen)\n+        _sz_lll = [\"add\", 32, [load_op(source.location), \"src\"]]\n         o = LLLnode.from_list(\n-            [\n-                \"with\",\n-                \"_source\",\n-                source,\n-                [\n-                    \"with\",\n-                    \"_sz\",\n-                    [\"add\", 32, [\"mload\", \"_source\"]],\n-                    [\"assert\", [\"call\", [\"gas\"], 4, 0, \"_source\", \"_sz\", destination, \"_sz\"]],\n-                ],\n-            ],  # noqa: E501\n+            [\"with\", \"src\", source, [\"with\", \"sz\", _sz_lll, copy_op]],\n             typ=None,\n-            add_gas_estimate=_identity_gas_bound(source.typ.maxlen),\n-            annotation=\"Memory copy\",\n+            add_gas_estimate=gas_bound,\n+            annotation=\"copy bytestring to memory\",\n         )\n         return o\n \n@@ -112,13 +126,13 @@ def make_byte_array_copier(destination, source, pos=None):\n     # Get the length\n     if source.value is None:\n         length = 1\n-    elif source.location == \"memory\":\n-        length = [\"add\", [\"mload\", \"_pos\"], 32]\n+    elif source.location in (\"memory\", \"code\", \"calldata\"):\n+        length = [\"add\", [load_op(source.location), \"_pos\"], 32]\n     elif source.location == \"storage\":\n         length = [\"add\", [\"sload\", \"_pos\"], 32]\n         pos_node = LLLnode.from_list(pos_node, typ=source.typ, location=source.location,)\n     else:\n-        raise CompilerPanic(f\"Unsupported location: {source.location}\")\n+        raise CompilerPanic(f\"Unsupported location: {source.location} to {destination.location}\")\n     if destination.location == \"storage\":\n         destination = LLLnode.from_list(\n             destination, typ=destination.typ, location=destination.location,\n@@ -149,7 +163,7 @@ def make_byte_slice_copier(destination, source, length, max_length, pos=None):\n             [\n                 \"with\",\n                 \"_l\",\n-                max_length,\n+                max_length,  # CMC 20210917 shouldn't this just be length\n                 [\"pop\", [\"call\", [\"gas\"], 4, 0, source, \"_l\", destination, \"_l\"]],\n             ],\n             typ=None,\n@@ -161,20 +175,19 @@ def make_byte_slice_copier(destination, source, length, max_length, pos=None):\n     if source.value is None:\n \n         if destination.location == \"memory\":\n+            # CMC 20210917 shouldn't this just be length\n             return mzero(destination, max_length)\n \n         else:\n             loader = 0\n     # Copy over data\n-    elif source.location == \"memory\":\n-        loader = [\"mload\", [\"add\", \"_pos\", [\"mul\", 32, [\"mload\", MemoryPositions.FREE_LOOP_INDEX]]]]\n-    elif source.location == \"storage\":\n-        loader = [\"sload\", [\"add\", \"_pos\", [\"mload\", MemoryPositions.FREE_LOOP_INDEX]]]\n-    elif source.location == \"calldata\":\n+    elif source.location in (\"memory\", \"calldata\", \"code\"):\n         loader = [\n-            \"calldataload\",\n+            load_op(source.location),\n             [\"add\", \"_pos\", [\"mul\", 32, [\"mload\", MemoryPositions.FREE_LOOP_INDEX]]],\n         ]\n+    elif source.location == \"storage\":\n+        loader = [\"sload\", [\"add\", \"_pos\", [\"mload\", MemoryPositions.FREE_LOOP_INDEX]]]\n     else:\n         raise CompilerPanic(f\"Unsupported location: {source.location}\")\n     # Where to paste it?\n@@ -227,16 +240,19 @@ def make_byte_slice_copier(destination, source, length, max_length, pos=None):\n def byte_array_to_num(\n     arg, expr, out_type, offset=32,\n ):\n-    if arg.location == \"memory\":\n-        lengetter = LLLnode.from_list([\"mload\", \"_sub\"], typ=BaseType(\"int256\"))\n-        first_el_getter = LLLnode.from_list([\"mload\", [\"add\", 32, \"_sub\"]], typ=BaseType(\"int256\"))\n-    elif arg.location == \"storage\":\n+    if arg.location == \"storage\":\n         lengetter = LLLnode.from_list([\"sload\", \"_sub\"], typ=BaseType(\"int256\"))\n         first_el_getter = LLLnode.from_list([\"sload\", [\"add\", 1, \"_sub\"]], typ=BaseType(\"int256\"))\n+    else:\n+        op = load_op(arg.location)\n+        lengetter = LLLnode.from_list([op, \"_sub\"], typ=BaseType(\"int256\"))\n+        first_el_getter = LLLnode.from_list([op, [\"add\", 32, \"_sub\"]], typ=BaseType(\"int256\"))\n+\n     if out_type == \"int128\":\n         result = int128_clamp([\"div\", \"_el1\", [\"exp\", 256, [\"sub\", 32, \"_len\"]]])\n     elif out_type in (\"int256\", \"uint256\"):\n         result = [\"div\", \"_el1\", [\"exp\", 256, [\"sub\", offset, \"_len\"]]]\n+    # TODO decimal clamp?\n     return LLLnode.from_list(\n         [\n             \"with\",\n@@ -256,13 +272,7 @@ def byte_array_to_num(\n \n def get_bytearray_length(arg):\n     typ = BaseType(\"uint256\")\n-    if arg.location == \"memory\":\n-        return LLLnode.from_list([\"mload\", arg], typ=typ)\n-    elif arg.location == \"storage\":\n-        return LLLnode.from_list([\"sload\", arg], typ=typ)\n-    elif arg.location == \"calldata\":\n-        return LLLnode.from_list([\"calldataload\", arg], typ=typ)\n-    raise CompilerPanic(\"unreachable\", arg)  # pragma: no test\n+    return LLLnode.from_list([load_op(arg.location), arg], typ=typ)\n \n \n def getpos(node):\n@@ -274,11 +284,57 @@ def getpos(node):\n     )\n \n \n+def _add_ofst(loc, ofst):\n+    if isinstance(loc.value, int) and isinstance(ofst, int):\n+        ret = loc.value + ofst\n+    else:\n+        ret = [\"add\", loc, ofst]\n+    return LLLnode.from_list(ret, location=loc.location, encoding=loc.encoding)\n+\n+\n # Take a value representing a memory or storage location, and descend down to\n # an element or member variable\n+# This is analogous (but not necessarily equivalent to) getelementptr in LLVM.\n+# TODO refactor / streamline this code, especially the ABI decoding\n @type_check_wrapper\n-def add_variable_offset(parent, key, pos, array_bounds_check=True):\n+def get_element_ptr(parent, key, pos, array_bounds_check=True):\n+    # TODO rethink this circular import\n+    from vyper.old_codegen.abi import abi_type_of\n+\n     typ, location = parent.typ, parent.location\n+\n+    def _abi_helper(member_t, ofst, clamp=True):\n+        member_abi_t = abi_type_of(member_t)\n+        ofst_lll = _add_ofst(parent, ofst)\n+\n+        if member_abi_t.is_dynamic():\n+            # double dereference, according to ABI spec\n+            # TODO optimize special case: first dynamic item\n+            # offset is statically known.\n+            ofst_lll = _add_ofst(parent, unwrap_location(ofst_lll))\n+\n+        x = LLLnode.from_list(\n+            [\"ofst\"], typ=member_t, location=parent.location, annotation=f\"&({typ}->{member_t})\"\n+        )\n+\n+        if clamp and _needs_clamp(member_t, parent.encoding):\n+            # special handling for unsanitized external data that need clamping\n+            # TODO optimize me. this results in a double dereference because\n+            # it returns a pointer and not a value. probably the best thing\n+            # is to move the clamp to make_setter\n+            ret = [\"with\", x, ofst_lll, [\"seq\", clamp_basetype(x), x]]\n+        else:\n+            ret = ofst_lll\n+\n+        return LLLnode.from_list(\n+            ret,\n+            typ=member_t,\n+            location=parent.location,\n+            encoding=parent.encoding,\n+            pos=pos,\n+            # annotation=f\"({parent.typ})[{key.typ}]\",\n+        )\n+\n     if isinstance(typ, TupleLike):\n         if isinstance(typ, StructType):\n             subtype = typ.members[key]\n@@ -294,62 +350,47 @@ def add_variable_offset(parent, key, pos, array_bounds_check=True):\n         if parent.value is None:\n             return LLLnode.from_list(None, typ=subtype)\n \n+        if parent.value == \"multi\":\n+            assert parent.encoding != Encoding.ABI, \"no abi-encoded literals\"\n+            return parent.args[index]\n+\n+        if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n+            if parent.location == \"storage\":\n+                raise CompilerPanic(\"storage variables should not be abi encoded\")\n+\n+            # parent_abi_t = abi_type_of(parent.typ)\n+            member_t = typ.members[attrs[index]]\n+\n+            ofst = 0  # offset from parent start\n+\n+            for i in range(index):\n+                member_abi_t = abi_type_of(typ.members[attrs[i]])\n+                ofst += member_abi_t.embedded_static_size()\n+\n+            return _abi_helper(member_t, ofst)\n+\n         if location == \"storage\":\n             # for arrays and structs, calculate the storage slot by adding an offset\n             # of [index value being accessed] * [size of each item within the sequence]\n             offset = 0\n             for i in range(index):\n                 offset += get_size_of_type(typ.members[attrs[i]])\n-            return LLLnode.from_list([\"add\", parent, offset], typ=subtype, location=\"storage\",)\n-        elif location == \"storage_prehashed\":\n             return LLLnode.from_list(\n-                [\"add\", parent, LLLnode.from_list(index, annotation=annotation)],\n-                typ=subtype,\n-                location=\"storage\",\n+                [\"add\", parent, offset], typ=subtype, location=\"storage\", pos=pos,\n             )\n-        elif location in (\"calldata\", \"memory\"):\n+\n+        elif location in (\"calldata\", \"memory\", \"code\"):\n             offset = 0\n             for i in range(index):\n                 offset += 32 * get_size_of_type(typ.members[attrs[i]])\n             return LLLnode.from_list(\n-                [\"add\", offset, parent],\n+                _add_ofst(parent, offset),\n                 typ=typ.members[key],\n                 location=location,\n                 annotation=annotation,\n+                pos=pos,\n             )\n \n-    elif isinstance(typ, MappingType):\n-\n-        sub = None\n-        if isinstance(key.typ, ByteArrayLike):\n-            if isinstance(typ.keytype, ByteArrayLike) and (typ.keytype.maxlen >= key.typ.maxlen):\n-\n-                subtype = typ.valuetype\n-                if len(key.args[0].args) >= 3:  # handle bytes literal.\n-                    sub = LLLnode.from_list(\n-                        [\n-                            \"seq\",\n-                            key,\n-                            [\n-                                \"sha3\",\n-                                [\"add\", key.args[0].args[-1], 32],\n-                                [\"mload\", key.args[0].args[-1]],\n-                            ],\n-                        ]\n-                    )\n-                else:\n-                    value = key.args[0].value\n-                    if value == \"add\":\n-                        # special case, key is a bytes array within a tuple/struct\n-                        value = key.args[0]\n-                    sub = LLLnode.from_list([\"sha3\", [\"add\", value, 32], key])\n-        else:\n-            subtype = typ.valuetype\n-            sub = unwrap_location(key)\n-\n-        if sub is not None and location == \"storage\":\n-            return LLLnode.from_list([\"sha3_64\", parent, sub], typ=subtype, location=\"storage\")\n-\n     elif isinstance(typ, ListType) and is_base_type(key.typ, (\"int128\", \"int256\", \"uint256\")):\n         subtype = typ.subtype\n \n@@ -371,156 +412,150 @@ def add_variable_offset(parent, key, pos, array_bounds_check=True):\n             # an array index, and the clamp will throw an error.\n             sub = [\"uclamplt\", k, typ.count]\n \n+        if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n+            if parent.location == \"storage\":\n+                raise CompilerPanic(\"storage variables should not be abi encoded\")\n+\n+            member_t = typ.subtype\n+            member_abi_t = abi_type_of(member_t)\n+\n+            if key.typ.is_literal:\n+                # TODO this constant folding in LLL optimizer\n+                ofst = k.value * member_abi_t.embedded_static_size()\n+            else:\n+                ofst = [\"mul\", k, member_abi_t.embedded_static_size()]\n+\n+            return _abi_helper(member_t, ofst)\n+\n         if location == \"storage\":\n             # storage slot determined as [initial storage slot] + [index] * [size of base type]\n             offset = get_size_of_type(subtype)\n             return LLLnode.from_list(\n                 [\"add\", parent, [\"mul\", sub, offset]], typ=subtype, location=\"storage\", pos=pos\n             )\n-        elif location == \"storage_prehashed\":\n-            return LLLnode.from_list([\"add\", parent, sub], typ=subtype, location=\"storage\", pos=pos)\n-        elif location in (\"calldata\", \"memory\"):\n+        elif location in (\"calldata\", \"memory\", \"code\"):\n             offset = 32 * get_size_of_type(subtype)\n             return LLLnode.from_list(\n                 [\"add\", [\"mul\", offset, sub], parent], typ=subtype, location=location, pos=pos\n             )\n \n+    elif isinstance(typ, MappingType):\n+        sub = None\n+        if isinstance(key.typ, ByteArrayLike):\n+            # CMC 20210916 pretty sure this is dead code. TODO double check\n+            if isinstance(typ.keytype, ByteArrayLike) and (typ.keytype.maxlen >= key.typ.maxlen):\n+                subtype = typ.valuetype\n+                if len(key.args[0].args) >= 3:  # handle bytes literal.\n+                    sub = LLLnode.from_list(\n+                        [\n+                            \"seq\",\n+                            key,\n+                            [\n+                                \"sha3\",\n+                                [\"add\", key.args[0].args[-1], 32],\n+                                [\"mload\", key.args[0].args[-1]],\n+                            ],\n+                        ]\n+                    )\n+                else:\n+                    value = key.args[0].value\n+                    if value == \"add\":\n+                        # special case, key is a bytes array within a tuple/struct\n+                        value = key.args[0]\n+                    sub = LLLnode.from_list([\"sha3\", [\"add\", value, 32], key])\n+        else:\n+            subtype = typ.valuetype\n+            sub = unwrap_location(key)\n+\n+        if sub is not None and location == \"storage\":\n+            return LLLnode.from_list([\"sha3_64\", parent, sub], typ=subtype, location=\"storage\")\n+\n+\n+def load_op(location):\n+    if location == \"memory\":\n+        return \"mload\"\n+    if location == \"storage\":\n+        return \"sload\"\n+    if location == \"calldata\":\n+        return \"calldataload\"\n+    if location == \"code\":\n+        return \"codeload\"\n+    raise CompilerPanic(f\"unreachable {location}\")  # pragma: no test\n+\n \n # Unwrap location\n def unwrap_location(orig):\n-    if orig.location == \"memory\":\n-        return LLLnode.from_list([\"mload\", orig], typ=orig.typ)\n-    elif orig.location == \"storage\":\n-        return LLLnode.from_list([\"sload\", orig], typ=orig.typ)\n-    elif orig.location == \"calldata\":\n-        return LLLnode.from_list([\"calldataload\", orig], typ=orig.typ)\n+    if orig.location in (\"memory\", \"storage\", \"calldata\", \"code\"):\n+        return LLLnode.from_list([load_op(orig.location), orig], typ=orig.typ)\n     else:\n+        # CMC 20210909 TODO double check if this branch can be removed\n         # handle None value inserted by `empty`\n         if orig.value is None:\n             return LLLnode.from_list(0, typ=orig.typ)\n         return orig\n \n \n-# Pack function arguments for a call\n-@type_check_wrapper\n-def pack_arguments(signature, args, context, stmt_expr, is_external_call):\n-    pos = getpos(stmt_expr)\n-    setters = []\n-    staticarray_offset = 0\n-\n-    maxlen = sum([get_size_of_type(arg.typ) for arg in signature.args]) * 32\n-    if is_external_call:\n-        maxlen += 32\n-\n-    placeholder_typ = ByteArrayType(maxlen=maxlen)\n-    placeholder = context.new_internal_variable(placeholder_typ)\n-    if is_external_call:\n-        setters.append([\"mstore\", placeholder, signature.method_id])\n-        placeholder += 32\n-\n-    if len(signature.args) != len(args):\n-        return\n-\n-    # check for dynamic-length types\n-    dynamic_remaining = len([i for i in signature.args if isinstance(i.typ, ByteArrayLike)])\n-    needpos = bool(dynamic_remaining)\n-\n-    for i, (arg, typ) in enumerate(zip(args, [arg.typ for arg in signature.args])):\n-        if isinstance(typ, BaseType):\n-            setters.append(\n-                make_setter(\n-                    LLLnode.from_list(placeholder + staticarray_offset + i * 32, typ=typ,),\n-                    arg,\n-                    \"memory\",\n-                    pos=pos,\n-                    in_function_call=True,\n-                )\n-            )\n-\n-        elif isinstance(typ, ByteArrayLike):\n-            dynamic_remaining -= 1\n-            setters.append([\"mstore\", placeholder + staticarray_offset + i * 32, \"_poz\"])\n-            arg_copy = LLLnode.from_list(\"_s\", typ=arg.typ, location=arg.location)\n-            target = LLLnode.from_list([\"add\", placeholder, \"_poz\"], typ=typ, location=\"memory\",)\n-            pos_setter = \"pass\"\n-\n-            # if `arg.value` is None, this is a call to `empty()`\n-            # if `arg.typ.maxlen` is 0, this is a literal \"\" or b\"\"\n-            if arg.value is None or arg.typ.maxlen == 0:\n-                if dynamic_remaining:\n-                    # only adjust the dynamic pointer if this is not the last dynamic type\n-                    pos_setter = [\"set\", \"_poz\", [\"add\", \"_poz\", 64]]\n-                setters.append([\"seq\", mzero(target, 64), pos_setter])\n-            else:\n-                if dynamic_remaining:\n-                    pos_setter = [\n-                        \"set\",\n-                        \"_poz\",\n-                        [\"add\", 32, [\"ceil32\", [\"add\", \"_poz\", get_bytearray_length(arg_copy)]]],\n-                    ]\n-                setters.append(\n-                    [\n-                        \"with\",\n-                        \"_s\",\n-                        arg,\n-                        [\"seq\", make_byte_array_copier(target, arg_copy, pos), pos_setter],\n-                    ]\n-                )\n-\n-        elif isinstance(typ, (StructType, ListType)):\n-            if has_dynamic_data(typ):\n-                return\n-            target = LLLnode.from_list(\n-                [placeholder + staticarray_offset + i * 32], typ=typ, location=\"memory\",\n-            )\n-            setters.append(make_setter(target, arg, \"memory\", pos=pos))\n-            staticarray_offset += 32 * (get_size_of_type(typ) - 1)\n-\n-        else:\n-            return\n-\n-    if is_external_call:\n-        returner = [[placeholder - 4]]\n-        inargsize = placeholder_typ.maxlen - 28\n-    else:\n-        # internal call does not use a returner or adjust max length for signature\n-        returner = []\n-        inargsize = placeholder_typ.maxlen\n-\n-    if needpos:\n-        return (\n-            LLLnode.from_list(\n-                [\"with\", \"_poz\", len(args) * 32 + staticarray_offset, [\"seq\"] + setters + returner],\n-                typ=placeholder_typ,\n-                location=\"memory\",\n-            ),\n-            inargsize,\n-            placeholder,\n-        )\n-    else:\n-        return (\n-            LLLnode.from_list([\"seq\"] + setters + returner, typ=placeholder_typ, location=\"memory\"),\n-            inargsize,\n-            placeholder,\n-        )\n-\n-\n def _make_array_index_setter(target, target_token, pos, location, offset):\n     if location == \"memory\" and isinstance(target.value, int):\n         offset = target.value + 32 * get_size_of_type(target.typ.subtype) * offset\n         return LLLnode.from_list([offset], typ=target.typ.subtype, location=location, pos=pos)\n     else:\n-        return add_variable_offset(\n+        return get_element_ptr(\n             target_token,\n             LLLnode.from_list(offset, typ=\"int256\"),\n             pos=pos,\n             array_bounds_check=False,\n         )\n \n \n+# utility function, constructs an LLL tuple out of a list of LLL nodes\n+def lll_tuple_from_args(args):\n+    typ = TupleType([x.typ for x in args])\n+    return LLLnode.from_list([\"multi\"] + [x for x in args], typ=typ)\n+\n+\n+def _needs_external_call_wrap(lll_typ):\n+    # for calls to ABI conforming contracts.\n+    # according to the ABI spec, return types are ALWAYS tuples even\n+    # if only one element is being returned.\n+    # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding\n+    # \"and the return values v_1, ..., v_k of f are encoded as\n+    #\n+    #    enc((v_1, ..., v_k))\n+    #    i.e. the values are combined into a tuple and encoded.\n+    # \"\n+    # therefore, wrap it in a tuple if it's not already a tuple.\n+    # for example, `bytes` is returned as abi-encoded (bytes,)\n+    # and `(bytes,)` is returned as abi-encoded ((bytes,),)\n+    # In general `-> X` gets returned as (X,)\n+    # including structs. MyStruct is returned as abi-encoded (MyStruct,).\n+    # (Sorry this is so confusing. I didn't make these rules.)\n+\n+    return not (isinstance(lll_typ, TupleType) and len(lll_typ.members) > 1)\n+\n+\n+def calculate_type_for_external_return(lll_typ):\n+    if _needs_external_call_wrap(lll_typ):\n+        return TupleType([lll_typ])\n+    return lll_typ\n+\n+\n+def wrap_value_for_external_return(lll_val):\n+    # used for LHS promotion\n+    if _needs_external_call_wrap(lll_val.typ):\n+        return lll_tuple_from_args([lll_val])\n+    else:\n+        return lll_val\n+\n+\n+def set_type_for_external_return(lll_val):\n+    # used for RHS promotion\n+    lll_val.typ = calculate_type_for_external_return(lll_val.typ)\n+\n+\n # Create an x=y statement, where the types may be compound\n @type_check_wrapper\n-def make_setter(left, right, location, pos, in_function_call=False):\n+def make_setter(left, right, location, pos):\n     # Basic types\n     if isinstance(left.typ, BaseType):\n         right = unwrap_location(right)\n@@ -546,14 +581,8 @@ def make_setter(left, right, location, pos, in_function_call=False):\n \n         left_token = LLLnode.from_list(\"_L\", typ=left.typ, location=left.location)\n         # If the right side is a literal\n-        if right.value in [\"multi\", \"seq_unchecked\"] and right.typ.is_literal:\n-            if right.value == \"seq_unchecked\":\n-                # when the LLL is `seq_unchecked`, this is a literal where one or\n-                # more values must be pre-processed to avoid memory corruption\n-                subs = right.args[:-1]\n-                right = right.args[-1]\n-            else:\n-                subs = []\n+        if right.value == \"multi\":\n+            subs = []\n             for i in range(left.typ.count):\n                 lhs_setter = _make_array_index_setter(left, left_token, pos, location, i)\n                 subs.append(make_setter(lhs_setter, right.args[i], location, pos=pos,))\n@@ -571,7 +600,7 @@ def make_setter(left, right, location, pos, in_function_call=False):\n             for i in range(left.typ.count):\n                 subs.append(\n                     make_setter(\n-                        add_variable_offset(\n+                        get_element_ptr(\n                             left_token,\n                             LLLnode.from_list(i, typ=\"int256\"),\n                             pos=pos,\n@@ -585,7 +614,9 @@ def make_setter(left, right, location, pos, in_function_call=False):\n             return LLLnode.from_list([\"with\", \"_L\", left, [\"seq\"] + subs], typ=None)\n         # If the right side is a variable\n         else:\n-            right_token = LLLnode.from_list(\"_R\", typ=right.typ, location=right.location)\n+            right_token = LLLnode.from_list(\n+                \"_R\", typ=right.typ, location=right.location, encoding=right.encoding\n+            )\n             subs = []\n             for i in range(left.typ.count):\n                 lhs_setter = _make_array_index_setter(left, left_token, pos, left.location, i)\n@@ -620,7 +651,10 @@ def make_setter(left, right, location, pos, in_function_call=False):\n         left_token = LLLnode.from_list(\"_L\", typ=left.typ, location=left.location)\n         keyz = left.typ.tuple_keys()\n \n-        # If the left side is a literal\n+        if len(keyz) == 0:\n+            return LLLnode.from_list([\"pass\"])\n+\n+        # If the left side is complex\n         if left.value == \"multi\":\n             locations = [arg.location for arg in left.args]\n         else:\n@@ -630,6 +664,8 @@ def make_setter(left, right, location, pos, in_function_call=False):\n         if right.value == \"multi\":\n             if len(right.args) != len(keyz):\n                 return\n+            if left.value == \"multi\":\n+                left_token = left\n             # get the RHS arguments into a dict because\n             # they are not guaranteed to be in the same order\n             # the LHS keys.\n@@ -638,10 +674,7 @@ def make_setter(left, right, location, pos, in_function_call=False):\n             for (key, loc) in zip(keyz, locations):\n                 subs.append(\n                     make_setter(\n-                        add_variable_offset(left_token, key, pos=pos),\n-                        right_args[key],\n-                        loc,\n-                        pos=pos,\n+                        get_element_ptr(left_token, key, pos=pos), right_args[key], loc, pos=pos,\n                     )\n                 )\n             return LLLnode.from_list([\"with\", \"_L\", left, [\"seq\"] + subs], typ=None)\n@@ -657,40 +690,44 @@ def make_setter(left, right, location, pos, in_function_call=False):\n             for key, loc in zip(keyz, locations):\n                 subs.append(\n                     make_setter(\n-                        add_variable_offset(left_token, key, pos=pos),\n+                        get_element_ptr(left_token, key, pos=pos),\n                         LLLnode.from_list(None, typ=right.typ.members[key]),\n                         loc,\n                         pos=pos,\n                     )\n                 )\n             return LLLnode.from_list([\"with\", \"_L\", left, [\"seq\"] + subs], typ=None)\n-        # If tuple assign.\n-        elif isinstance(left.typ, TupleType) and isinstance(right.typ, TupleType):\n+        # literal tuple assign.\n+        elif (\n+            isinstance(left.typ, TupleType)\n+            and left.value == \"multi\"\n+            and isinstance(right.typ, TupleType)\n+        ):\n             subs = []\n             for var_arg in left.args:\n-                if var_arg.location == \"calldata\":\n+                if var_arg.location in (\"calldata\", \"code\"):\n                     return\n \n-            right_token = LLLnode.from_list(\"_R\", typ=right.typ, location=right.location)\n+            right_token = LLLnode.from_list(\n+                \"_R\", typ=right.typ, location=right.location, encoding=right.encoding\n+            )\n             for left_arg, key, loc in zip(left.args, keyz, locations):\n                 subs.append(\n-                    make_setter(\n-                        left_arg, add_variable_offset(right_token, key, pos=pos), loc, pos=pos\n-                    )\n+                    make_setter(left_arg, get_element_ptr(right_token, key, pos=pos), loc, pos=pos)\n                 )\n \n-            return LLLnode.from_list(\n-                [\"with\", \"_R\", right, [\"seq\"] + subs], typ=None, annotation=\"Tuple assignment\",\n-            )\n-        # If the left side is a variable i.e struct type\n+            return LLLnode.from_list([\"with\", \"_R\", right, [\"seq\"] + subs], typ=None)\n+        # general case\n         else:\n             subs = []\n-            right_token = LLLnode.from_list(\"_R\", typ=right.typ, location=right.location)\n+            right_token = LLLnode.from_list(\n+                \"_R\", typ=right.typ, location=right.location, encoding=right.encoding\n+            )\n             for typ, loc in zip(keyz, locations):\n                 subs.append(\n                     make_setter(\n-                        add_variable_offset(left_token, typ, pos=pos),\n-                        add_variable_offset(right_token, typ, pos=pos),\n+                        get_element_ptr(left_token, typ, pos=pos),\n+                        get_element_ptr(right_token, typ, pos=pos),\n                         loc,\n                         pos=pos,\n                     )\n@@ -700,6 +737,7 @@ def make_setter(left, right, location, pos, in_function_call=False):\n             )\n \n \n+# TODO move return checks to vyper/semantics/validation\n def is_return_from_function(node):\n     if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") == \"selfdestruct\":\n         return True\n@@ -735,21 +773,6 @@ def _check_return_body(node, node_list):\n             )\n \n \n-def _return_check(node):\n-    if is_return_from_function(node):\n-        return True\n-    elif isinstance(node, list):\n-        return any(_return_check(stmt) for stmt in node)\n-    elif isinstance(node, vy_ast.If):\n-        if_body_check = _return_check(node.body)\n-        else_body_check = _return_check(node.orelse)\n-        if if_body_check and else_body_check:  # both side need to match.\n-            return True\n-        else:\n-            return False\n-    return False\n-\n-\n def mzero(dst, nbytes):\n     # calldatacopy from past-the-end gives zero bytes.\n     # cf. YP H.2 (ops section) with CALLDATACOPY spec.\n@@ -775,3 +798,80 @@ def zero_pad(bytez_placeholder):\n         [\"with\", \"len\", len_, [\"with\", \"dst\", dst, mzero(\"dst\", num_zero_bytes)]],\n         annotation=\"Zero pad\",\n     )\n+\n+\n+# convenience rewrites for shr/sar/shl\n+def _shr(x, bits):\n+    if version_check(begin=\"constantinople\"):\n+        return [\"shr\", bits, x]\n+    return [\"div\", x, [\"exp\", 2, bits]]\n+\n+\n+def _sar(x, bits):\n+    if version_check(begin=\"constantinople\"):\n+        return [\"sar\", bits, x]\n+\n+    # emulate for older arches. keep in mind note from EIP 145:\n+    # This is not equivalent to PUSH1 2 EXP SDIV, since it rounds\n+    # differently. See SDIV(-1, 2) == 0, while SAR(-1, 1) == -1.\n+    return [\"sdiv\", [\"add\", [\"slt\", x, 0], x], [\"exp\", 2, bits]]\n+\n+\n+def _needs_clamp(t, encoding):\n+    assert encoding in (Encoding.ABI, Encoding.JSON_ABI)\n+    if isinstance(t, ByteArrayLike):\n+        if encoding == Encoding.JSON_ABI:\n+            # don't have bytestring size bound from json, don't clamp\n+            return False\n+        return True\n+    if isinstance(t, BaseType) and t.typ not in (\"int256\", \"uint256\", \"bytes32\"):\n+        return True\n+    return False\n+\n+\n+# clampers for basetype\n+@type_check_wrapper\n+def clamp_basetype(lll_node):\n+    t = lll_node.typ\n+    if isinstance(t, ByteArrayLike):\n+        return [\"assert\", [\"le\", get_bytearray_length(lll_node), t.maxlen]]\n+    if isinstance(t, BaseType):\n+        lll_node = unwrap_location(lll_node)\n+        if t.typ in (\"int128\"):\n+            return int_clamp(lll_node, 128, signed=True)\n+        if t.typ in (\"decimal\"):\n+            return [\n+                \"clamp\",\n+                [\"mload\", MemoryPositions.MINDECIMAL],\n+                lll_node,\n+                [\"mload\", MemoryPositions.MAXDECIMAL],\n+            ]\n+\n+        if t.typ in (\"address\",):\n+            return int_clamp(lll_node, 160)\n+        if t.typ in (\"bool\",):\n+            return int_clamp(lll_node, 1)\n+        if t.typ in (\"int256\", \"uint256\", \"bytes32\"):\n+            return [\"pass\"]  # special case, no clamp\n+    return  # raises\n+\n+\n+def int_clamp(lll_node, bits, signed=False):\n+    \"\"\"Generalized clamper for integer types. Takes the number of bits,\n+       whether it's signed, and returns an LLL node which checks it is\n+       in bounds.\n+    \"\"\"\n+    if bits >= 256:\n+        raise CompilerPanic(\"shouldn't clamp\", lll_node)\n+    if signed:\n+        # example for bits==128:\n+        # if _val is in bounds,\n+        # _val >>> 127 == 0 for positive _val\n+        # _val >>> 127 == -1 for negative _val\n+        # -1 and 0 are the only numbers which are unchanged by sar,\n+        # so sar'ing (_val>>>127) one more bit should leave it unchanged.\n+        ret = [\"with\", \"x\", lll_node, [\"assert\", [\"eq\", _sar(\"x\", bits - 1), _sar(\"x\", bits)]]]\n+    else:\n+        ret = [\"assert\", [\"iszero\", _shr(lll_node, bits)]]\n+\n+    return LLLnode.from_list(ret, annotation=f\"int_clamp {lll_node.typ}\")"
        },
        {
          "filename": "vyper/old_codegen/return_.py",
          "status": "modified",
          "additions": 64,
          "deletions": 150,
          "patch": "@@ -1,158 +1,72 @@\n-from vyper import ast as vy_ast\n-from vyper.old_codegen.function_definitions.utils import get_nonreentrant_lock\n+from typing import Any, Optional\n+\n+from vyper.old_codegen.abi import abi_encode, abi_type_of\n+from vyper.old_codegen.context import Context\n from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.parser_utils import getpos, make_setter\n-from vyper.old_codegen.types import BaseType, TupleType, get_size_of_type\n+from vyper.old_codegen.parser_utils import (\n+    getpos,\n+    make_setter,\n+    wrap_value_for_external_return,\n+)\n+from vyper.old_codegen.types import get_type_for_exact_size\n from vyper.old_codegen.types.check import check_assign\n-from vyper.utils import MemoryPositions\n \n-from .abi import abi_encode, abi_type_of, ensure_tuple\n+Stmt = Any  # mypy kludge\n \n \n-# Generate return code for stmt\n-def make_return_stmt(stmt, context, begin_pos, _size, loop_memory_position=None):\n-    # TODO check this out\n-    func_type = stmt.get_ancestor(vy_ast.FunctionDef)._metadata[\"type\"]\n-    _, nonreentrant_post = get_nonreentrant_lock(func_type)\n+# Generate code for return stmt\n+def make_return_stmt(lll_val: LLLnode, stmt: Any, context: Context) -> Optional[LLLnode]:\n+\n+    sig = context.sig\n+\n+    jump_to_exit = [\"goto\", sig.exit_sequence_label]\n+\n+    _pos = getpos(stmt)\n+\n+    if context.return_type is None:\n+        if stmt.value is not None:\n+            return None  # triggers an exception\n \n-    if context.is_internal:\n-        if loop_memory_position is None:\n-            loop_memory_position = context.new_internal_variable(BaseType(\"uint256\"))\n-\n-        # Make label for stack push loop.\n-        label_id = \"_\".join([str(x) for x in (context.method_id, stmt.lineno, stmt.col_offset)])\n-        exit_label = f\"make_return_loop_exit_{label_id}\"\n-        start_label = f\"make_return_loop_start_{label_id}\"\n-\n-        # Push prepared data onto the stack,\n-        # in reverse order so it can be popped of in order.\n-        if isinstance(begin_pos, int) and isinstance(_size, int):\n-            # static values, unroll the mloads instead.\n-            mloads = [[\"mload\", pos] for pos in range(begin_pos, _size, 32)]\n-        else:\n-            mloads = [\n-                \"seq_unchecked\",\n-                [\"mstore\", loop_memory_position, _size],\n-                [\"label\", start_label],\n-                [  # maybe exit loop / break.\n-                    \"if\",\n-                    [\"le\", [\"mload\", loop_memory_position], 0],\n-                    [\"goto\", exit_label],\n-                ],\n-                [  # push onto stack\n-                    \"mload\",\n-                    [\"add\", begin_pos, [\"sub\", [\"mload\", loop_memory_position], 32]],\n-                ],\n-                [  # decrement i by 32.\n-                    \"mstore\",\n-                    loop_memory_position,\n-                    [\"sub\", [\"mload\", loop_memory_position], 32],\n-                ],\n-                [\"goto\", start_label],\n-                [\"label\", exit_label],\n-            ]\n-\n-        # if we are in a for loop, we have to exit prior to returning\n-        exit_repeater = [\"exit_repeater\"] if context.forvars else []\n-\n-        return (\n-            [\"seq_unchecked\"]\n-            + exit_repeater\n-            + mloads\n-            + nonreentrant_post\n-            + [[\"jump\", [\"mload\", context.callback_ptr]]]\n-        )\n     else:\n-        return [\"seq_unchecked\"] + nonreentrant_post + [[\"return\", begin_pos, _size]]\n-\n-\n-# Generate code for returning a tuple or struct.\n-def gen_tuple_return(stmt, context, sub):\n-    abi_typ = abi_type_of(context.return_type)\n-    # according to the ABI, return types are ALWAYS tuples even if\n-    # only one element is being returned.\n-    # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding\n-    # \"and the return values v_1, ..., v_k of f are encoded as\n-    #\n-    #    enc((v_1, ..., v_k))\n-    #    i.e. the values are combined into a tuple and encoded.\n-    # \"\n-    # therefore, wrap it in a tuple if it's not already a tuple.\n-    # (big difference between returning `(bytes,)` and `bytes`.\n-    abi_typ = ensure_tuple(abi_typ)\n-    abi_bytes_needed = abi_typ.static_size() + abi_typ.dynamic_size_bound()\n-    dst = context.memory_allocator.expand_memory(abi_bytes_needed)\n-    return_buffer = LLLnode(\n-        dst, location=\"memory\", annotation=\"return_buffer\", typ=context.return_type\n-    )\n-\n-    check_assign(return_buffer, sub, pos=getpos(stmt))\n-\n-    if sub.value == \"multi\":\n-\n-        if isinstance(context.return_type, TupleType) and not abi_typ.dynamic_size_bound():\n-            # for tuples where every value is of the same type and a fixed length,\n-            # we can simplify the encoding by using make_setter, since\n-            # our memory encoding happens to be identical to the ABI\n-            # encoding.\n-            new_sub = LLLnode.from_list(\n-                context.new_internal_variable(context.return_type),\n-                typ=context.return_type,\n-                location=\"memory\",\n-            )\n-            setter = make_setter(new_sub, sub, \"memory\", pos=getpos(stmt))\n-            return LLLnode.from_list(\n-                [\n-                    \"seq\",\n-                    setter,\n-                    make_return_stmt(\n-                        stmt, context, new_sub, get_size_of_type(context.return_type) * 32,\n-                    ),\n-                ],\n-                typ=None,\n-                pos=getpos(stmt),\n-            )\n-\n-        # in case of multi we can't create a variable to store location of the return expression\n-        # as multi can have data from multiple location like store, calldata etc\n-        encode_out = abi_encode(return_buffer, sub, pos=getpos(stmt), returns_len=True)\n-        load_return_len = [\"mload\", MemoryPositions.FREE_VAR_SPACE]\n-        os = [\n-            \"seq\",\n-            [\"mstore\", MemoryPositions.FREE_VAR_SPACE, encode_out],\n-            make_return_stmt(stmt, context, return_buffer, load_return_len),\n-        ]\n-        return LLLnode.from_list(os, typ=None, pos=getpos(stmt), valency=0)\n-\n-    # for tuple return types where a function is called inside the tuple, we\n-    # process the calls prior to encoding the return data\n-    if sub.value == \"seq_unchecked\" and sub.args[-1].value == \"multi\":\n-        encode_out = abi_encode(return_buffer, sub.args[-1], pos=getpos(stmt), returns_len=True)\n-        load_return_len = [\"mload\", MemoryPositions.FREE_VAR_SPACE]\n-        os = (\n-            [\"seq\"]\n-            + sub.args[:-1]\n-            + [\n-                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, encode_out],\n-                make_return_stmt(stmt, context, return_buffer, load_return_len),\n-            ]\n+        # sanity typecheck\n+        _tmp = LLLnode(\"fake node\", location=\"memory\", typ=context.return_type)\n+        check_assign(_tmp, lll_val, _pos)\n+\n+    # helper function\n+    def finalize(fill_return_buffer):\n+        # do NOT bypass this. jump_to_exit may do important function cleanup.\n+        fill_return_buffer = LLLnode.from_list(\n+            fill_return_buffer, annotation=f\"fill return buffer {sig._lll_identifier}\"\n         )\n-        return LLLnode.from_list(os, typ=None, pos=getpos(stmt), valency=0)\n-\n-    # for all othe cases we are creating a stack variable named sub_loc to store the  location\n-    # of the return expression. This is done so that the return expression does not get evaluated\n-    # abi-encode uses a function named o_list which evaluate the expression multiple times\n-    sub_loc = LLLnode(\"sub_loc\", typ=sub.typ, location=sub.location)\n-    encode_out = abi_encode(return_buffer, sub_loc, pos=getpos(stmt), returns_len=True)\n-    load_return_len = [\"mload\", MemoryPositions.FREE_VAR_SPACE]\n-    os = [\n-        \"with\",\n-        \"sub_loc\",\n-        sub,\n-        [\n-            \"seq\",\n-            [\"mstore\", MemoryPositions.FREE_VAR_SPACE, encode_out],\n-            make_return_stmt(stmt, context, return_buffer, load_return_len),\n-        ],\n-    ]\n-    return LLLnode.from_list(os, typ=None, pos=getpos(stmt), valency=0)\n+        cleanup_loops = \"exit_repeater\" if context.forvars else \"pass\"\n+        return LLLnode.from_list(\n+            [\"seq_unchecked\", cleanup_loops, fill_return_buffer, jump_to_exit], typ=None, pos=_pos,\n+        )\n+\n+    if context.return_type is None:\n+        return finalize([\"pass\"])\n+\n+    if context.is_internal:\n+        dst = LLLnode.from_list([\"return_buffer\"], typ=context.return_type, location=\"memory\")\n+        fill_return_buffer = [\n+            \"with\",\n+            dst,\n+            \"pass\",  # return_buffer is passed on the stack by caller\n+            make_setter(dst, lll_val, location=\"memory\", pos=_pos),\n+        ]\n+\n+        return finalize(fill_return_buffer)\n+\n+    else:  # return from external function\n+\n+        lll_val = wrap_value_for_external_return(lll_val)\n+\n+        maxlen = abi_type_of(context.return_type).size_bound()\n+        return_buffer_ofst = context.new_internal_variable(get_type_for_exact_size(maxlen))\n+\n+        # encode_out is cleverly a sequence which does the abi-encoding and\n+        # also returns the length of the output as a stack element\n+        encode_out = abi_encode(return_buffer_ofst, lll_val, pos=_pos, returns_len=True)\n+\n+        # fill the return buffer and push the location and length onto the stack\n+        return finalize([\"seq_unchecked\", encode_out, return_buffer_ofst])"
        },
        {
          "filename": "vyper/old_codegen/self_call.py",
          "status": "modified",
          "additions": 78,
          "deletions": 256,
          "patch": "@@ -1,72 +1,48 @@\n-import itertools\n+from vyper.exceptions import StateAccessViolation, StructureException\n+from vyper.old_codegen.lll_node import LLLnode, push_label_to_stack\n+from vyper.old_codegen.parser_utils import getpos, make_setter\n+from vyper.old_codegen.types import TupleType\n \n-from vyper.ast.signatures.function_signature import FunctionSignature\n-from vyper.exceptions import (\n-    StateAccessViolation,\n-    StructureException,\n-    TypeCheckFailure,\n-)\n-from vyper.old_codegen.abi import abi_decode\n-from vyper.old_codegen.lll_node import LLLnode\n-from vyper.old_codegen.parser_utils import getpos, pack_arguments\n-from vyper.old_codegen.types import (\n-    BaseType,\n-    ByteArrayLike,\n-    ListType,\n-    TupleLike,\n-    get_size_of_type,\n-    get_static_size_of_type,\n-    has_dynamic_data,\n-)\n+_label_counter = 0\n \n \n-def _call_make_placeholder(stmt_expr, context, sig):\n-    if sig.output_type is None:\n-        return 0, 0, 0\n+# TODO a more general way of doing this\n+def _generate_label(name: str) -> str:\n+    global _label_counter\n+    _label_counter += 1\n+    return f\"label{_label_counter}\"\n \n-    output_placeholder = context.new_internal_variable(typ=sig.output_type)\n-    output_size = get_size_of_type(sig.output_type) * 32\n \n-    if isinstance(sig.output_type, BaseType):\n-        returner = output_placeholder\n-    elif isinstance(sig.output_type, ByteArrayLike):\n-        returner = output_placeholder\n-    elif isinstance(sig.output_type, TupleLike):\n-        # incase of struct we need to decode the output and then return it\n-        returner = [\"seq\"]\n-        decoded_placeholder = context.new_internal_variable(typ=sig.output_type)\n-        decoded_node = LLLnode(decoded_placeholder, typ=sig.output_type, location=\"memory\")\n-        output_node = LLLnode(output_placeholder, typ=sig.output_type, location=\"memory\")\n-        returner.append(abi_decode(decoded_node, output_node))\n-        returner.extend([decoded_placeholder])\n-    elif isinstance(sig.output_type, ListType):\n-        returner = output_placeholder\n-    else:\n-        raise TypeCheckFailure(f\"Invalid output type: {sig.output_type}\")\n-    return output_placeholder, returner, output_size\n+def lll_for_self_call(stmt_expr, context):\n+    from vyper.old_codegen.expr import (\n+        Expr,  # TODO rethink this circular import\n+    )\n \n+    pos = getpos(stmt_expr)\n \n-def make_call(stmt_expr, context):\n     # ** Internal Call **\n     # Steps:\n-    # (x) push current local variables\n-    # (x) push arguments\n-    # (x) push jumpdest (callback ptr)\n-    # (x) jump to label\n-    # (x) pop return values\n-    # (x) pop local variables\n+    # - copy arguments into the soon-to-be callee\n+    # - allocate return buffer\n+    # - push jumpdest (callback ptr) and return buffer location\n+    # - jump to label\n+    # - (private function will fill return buffer and jump back)\n \n-    pop_local_vars = []\n-    push_local_vars = []\n-    pop_return_values = []\n-    push_args = []\n     method_name = stmt_expr.func.attr\n \n-    # TODO check this out\n-    from vyper.old_codegen.expr import parse_sequence\n+    pos_args_lll = [Expr(x, context).lll_node for x in stmt_expr.args]\n+\n+    sig, kw_vals = context.lookup_internal_function(method_name, pos_args_lll)\n+\n+    kw_args_lll = [Expr(x, context).lll_node for x in kw_vals]\n+\n+    args_lll = pos_args_lll + kw_args_lll\n \n-    pre_init, expr_args = parse_sequence(stmt_expr, stmt_expr.args, context)\n-    sig = FunctionSignature.lookup_sig(context.sigs, method_name, expr_args, stmt_expr, context,)\n+    args_tuple_t = TupleType([x.typ for x in args_lll])\n+    args_as_tuple = LLLnode.from_list([\"multi\"] + [x for x in args_lll], typ=args_tuple_t)\n+\n+    # register callee to help calculate our starting frame offset\n+    context.register_callee(sig.frame_size)\n \n     if context.is_constant() and sig.mutability not in (\"view\", \"pure\"):\n         raise StateAccessViolation(\n@@ -75,217 +51,63 @@ def make_call(stmt_expr, context):\n             getpos(stmt_expr),\n         )\n \n+    # TODO move me to type checker phase\n     if not sig.internal:\n         raise StructureException(\"Cannot call external functions via 'self'\", stmt_expr)\n \n-    # Push local variables.\n-    var_slots = [(v.pos, v.size) for name, v in context.vars.items() if v.location == \"memory\"]\n-    if var_slots:\n-        var_slots.sort(key=lambda x: x[0])\n-\n-        if len(var_slots) > 10:\n-            # if memory is large enough, push and pop it via iteration\n-            mem_from, mem_to = var_slots[0][0], var_slots[-1][0] + var_slots[-1][1] * 32\n-            i_placeholder = context.new_internal_variable(BaseType(\"uint256\"))\n-            local_save_ident = f\"_{stmt_expr.lineno}_{stmt_expr.col_offset}\"\n-            push_loop_label = \"save_locals_start\" + local_save_ident\n-            pop_loop_label = \"restore_locals_start\" + local_save_ident\n-            push_local_vars = [\n-                [\"mstore\", i_placeholder, mem_from],\n-                [\"label\", push_loop_label],\n-                [\"mload\", [\"mload\", i_placeholder]],\n-                [\"mstore\", i_placeholder, [\"add\", [\"mload\", i_placeholder], 32]],\n-                [\"if\", [\"lt\", [\"mload\", i_placeholder], mem_to], [\"goto\", push_loop_label]],\n-            ]\n-            pop_local_vars = [\n-                [\"mstore\", i_placeholder, mem_to - 32],\n-                [\"label\", pop_loop_label],\n-                [\"mstore\", [\"mload\", i_placeholder], \"pass\"],\n-                [\"mstore\", i_placeholder, [\"sub\", [\"mload\", i_placeholder], 32]],\n-                [\"if\", [\"ge\", [\"mload\", i_placeholder], mem_from], [\"goto\", pop_loop_label]],\n-            ]\n-        else:\n-            # for smaller memory, hardcode the mload/mstore locations\n-            push_mem_slots = []\n-            for pos, size in var_slots:\n-                push_mem_slots.extend([pos + i * 32 for i in range(size)])\n-\n-            push_local_vars = [[\"mload\", pos] for pos in push_mem_slots]\n-            pop_local_vars = [[\"mstore\", pos, \"pass\"] for pos in push_mem_slots[::-1]]\n+    return_label = _generate_label(f\"{sig.internal_function_label}_call\")\n \n-    # Push Arguments\n-    if expr_args:\n-        inargs, inargsize, arg_pos = pack_arguments(\n-            sig, expr_args, context, stmt_expr, is_external_call=False\n+    # allocate space for the return buffer\n+    # TODO allocate in stmt and/or expr.py\n+    return_buffer = (\n+        context.new_internal_variable(sig.return_type) if sig.return_type is not None else \"pass\"\n+    )\n+    return_buffer = LLLnode.from_list([return_buffer], annotation=f\"{return_label}_return_buf\")\n+\n+    # note: dst_tuple_t != args_tuple_t\n+    dst_tuple_t = TupleType([arg.typ for arg in sig.args])\n+    args_dst = LLLnode(sig.frame_start, typ=dst_tuple_t, location=\"memory\")\n+\n+    # if one of the arguments is a self call, the argument\n+    # buffer could get borked. to prevent against that,\n+    # write args to a temporary buffer until all the arguments\n+    # are fully evaluated.\n+    if args_as_tuple.contains_self_call:\n+        copy_args = [\"seq\"]\n+        # TODO deallocate me\n+        tmp_args_buf = LLLnode(\n+            context.new_internal_variable(dst_tuple_t), typ=dst_tuple_t, location=\"memory\",\n         )\n-        push_args += [inargs]  # copy arguments first, to not mess up the push/pop sequencing.\n-\n-        static_arg_size = 32 * sum([get_static_size_of_type(arg.typ) for arg in expr_args])\n-        static_pos = int(arg_pos + static_arg_size)\n-        needs_dyn_section = any([has_dynamic_data(arg.typ) for arg in expr_args])\n-\n-        if needs_dyn_section:\n-            ident = f\"push_args_{sig.method_id}_{stmt_expr.lineno}_{stmt_expr.col_offset}\"\n-            start_label = ident + \"_start\"\n-            end_label = ident + \"_end\"\n-            i_placeholder = context.new_internal_variable(BaseType(\"uint256\"))\n-\n-            # Calculate copy start position.\n-            # Given | static | dynamic | section in memory,\n-            # copy backwards so the values are in order on the stack.\n-            # We calculate i, the end of the whole encoded part\n-            # (i.e. the starting index for copy)\n-            # by taking ceil32(len<arg>) + offset<arg> + arg_pos\n-            # for the last dynamic argument and arg_pos is the start\n-            # the whole argument section.\n-            idx = 0\n-            for arg in expr_args:\n-                if isinstance(arg.typ, ByteArrayLike):\n-                    last_idx = idx\n-                idx += get_static_size_of_type(arg.typ)\n-            push_args += [\n-                [\n-                    \"with\",\n-                    \"offset\",\n-                    [\"mload\", arg_pos + last_idx * 32],\n-                    [\n-                        \"with\",\n-                        \"len_pos\",\n-                        [\"add\", arg_pos, \"offset\"],\n-                        [\n-                            \"with\",\n-                            \"len_value\",\n-                            [\"mload\", \"len_pos\"],\n-                            [\"mstore\", i_placeholder, [\"add\", \"len_pos\", [\"ceil32\", \"len_value\"]]],\n-                        ],\n-                    ],\n-                ]\n-            ]\n-            # loop from end of dynamic section to start of dynamic section,\n-            # pushing each element onto the stack.\n-            push_args += [\n-                [\"label\", start_label],\n-                [\"if\", [\"lt\", [\"mload\", i_placeholder], static_pos], [\"goto\", end_label]],\n-                [\"mload\", [\"mload\", i_placeholder]],\n-                [\"mstore\", i_placeholder, [\"sub\", [\"mload\", i_placeholder], 32]],  # decrease i\n-                [\"goto\", start_label],\n-                [\"label\", end_label],\n-            ]\n-\n-        # push static section\n-        push_args += [[\"mload\", pos] for pos in reversed(range(arg_pos, static_pos, 32))]\n-    elif sig.args:\n-        raise StructureException(\n-            f\"Wrong number of args for: {sig.name} (0 args given, expected {len(sig.args)})\",\n-            stmt_expr,\n+        copy_args.append(\n+            # --> args evaluate here <--\n+            make_setter(tmp_args_buf, args_as_tuple, \"memory\", pos)\n         )\n \n-    # Jump to function label.\n-    jump_to_func = [\n-        [\"add\", [\"pc\"], 6],  # set callback pointer.\n-        [\"goto\", f\"priv_{sig.method_id}\"],\n-        [\"jumpdest\"],\n-    ]\n-\n-    # Pop return values.\n-    returner = [0]\n-    if sig.output_type:\n-        output_placeholder, returner, output_size = _call_make_placeholder(stmt_expr, context, sig)\n-        if output_size > 0:\n-            dynamic_offsets = []\n-            if isinstance(sig.output_type, (BaseType, ListType)):\n-                pop_return_values = [\n-                    [\"mstore\", [\"add\", output_placeholder, pos], \"pass\"]\n-                    for pos in range(0, output_size, 32)\n-                ]\n-            elif isinstance(sig.output_type, ByteArrayLike):\n-                dynamic_offsets = [(0, sig.output_type)]\n-                pop_return_values = [\n-                    [\"pop\", \"pass\"],\n-                ]\n-            elif isinstance(sig.output_type, TupleLike):\n-                static_offset = 0\n-                pop_return_values = []\n-                for name, typ in sig.output_type.tuple_items():\n-                    if isinstance(typ, ByteArrayLike):\n-                        pop_return_values.append(\n-                            [\"mstore\", [\"add\", output_placeholder, static_offset], \"pass\"]\n-                        )\n-                        dynamic_offsets.append(\n-                            ([\"mload\", [\"add\", output_placeholder, static_offset]], name)\n-                        )\n-                        static_offset += 32\n-                    else:\n-                        member_output_size = get_size_of_type(typ) * 32\n-                        pop_return_values.extend(\n-                            [\n-                                [\"mstore\", [\"add\", output_placeholder, pos], \"pass\"]\n-                                for pos in range(\n-                                    static_offset, static_offset + member_output_size, 32\n-                                )\n-                            ]\n-                        )\n-                        static_offset += member_output_size\n+        copy_args.append(make_setter(args_dst, tmp_args_buf, \"memory\", pos))\n \n-            # append dynamic unpacker.\n-            dyn_idx = 0\n-            for in_memory_offset, _out_type in dynamic_offsets:\n-                ident = f\"{stmt_expr.lineno}_{stmt_expr.col_offset}_arg_{dyn_idx}\"\n-                dyn_idx += 1\n-                start_label = \"dyn_unpack_start_\" + ident\n-                end_label = \"dyn_unpack_end_\" + ident\n-                i_placeholder = context.new_internal_variable(typ=BaseType(\"uint256\"))\n-                begin_pos = [\"add\", output_placeholder, in_memory_offset]\n-                # loop until length.\n-                o = LLLnode.from_list(\n-                    [\n-                        \"seq_unchecked\",\n-                        [\"mstore\", begin_pos, \"pass\"],  # get len\n-                        [\"mstore\", i_placeholder, 0],\n-                        [\"label\", start_label],\n-                        [  # break\n-                            \"if\",\n-                            [\"ge\", [\"mload\", i_placeholder], [\"ceil32\", [\"mload\", begin_pos]]],\n-                            [\"goto\", end_label],\n-                        ],\n-                        [  # pop into correct memory slot.\n-                            \"mstore\",\n-                            [\"add\", [\"add\", begin_pos, 32], [\"mload\", i_placeholder]],\n-                            \"pass\",\n-                        ],\n-                        # increment i\n-                        [\"mstore\", i_placeholder, [\"add\", 32, [\"mload\", i_placeholder]]],\n-                        [\"goto\", start_label],\n-                        [\"label\", end_label],\n-                    ],\n-                    typ=None,\n-                    annotation=\"dynamic unpacker\",\n-                    pos=getpos(stmt_expr),\n-                )\n-                pop_return_values.append(o)\n-\n-    call_body = list(\n-        itertools.chain(\n-            [\"seq_unchecked\"],\n-            pre_init,\n-            push_local_vars,\n-            push_args,\n-            jump_to_func,\n-            pop_return_values,\n-            pop_local_vars,\n-            [returner],\n-        )\n-    )\n-    # If we have no return, we need to pop off\n-    pop_returner_call_body = [\"pop\", call_body] if sig.output_type is None else call_body\n+    else:\n+        copy_args = make_setter(args_dst, args_as_tuple, \"memory\", pos)\n+\n+    call_sequence = [\n+        \"seq\",\n+        copy_args,\n+        [\n+            \"goto\",\n+            sig.internal_function_label,\n+            return_buffer,  # pass return buffer to subroutine\n+            push_label_to_stack(return_label),  # pass return label to subroutine\n+        ],\n+        [\"label\", return_label],\n+        return_buffer,  # push return buffer location to stack\n+    ]\n \n     o = LLLnode.from_list(\n-        pop_returner_call_body,\n-        typ=sig.output_type,\n+        call_sequence,\n+        typ=sig.return_type,\n         location=\"memory\",\n-        pos=getpos(stmt_expr),\n-        annotation=f\"Internal Call: {method_name}\",\n+        pos=pos,\n+        annotation=stmt_expr.get(\"node_source_code\"),\n         add_gas_estimate=sig.gas,\n     )\n-    o.gas += sig.gas\n+    o.is_self_call = True\n     return o"
        },
        {
          "filename": "vyper/old_codegen/stmt.py",
          "status": "modified",
          "additions": 21,
          "deletions": 150,
          "patch": "@@ -1,4 +1,5 @@\n import vyper.old_codegen.events as events\n+import vyper.utils as util\n from vyper import ast as vy_ast\n from vyper.builtin_functions import STMT_DISPATCH_TABLE\n from vyper.exceptions import StructureException, TypeCheckFailure\n@@ -8,24 +9,17 @@\n from vyper.old_codegen.parser_utils import (\n     LLLnode,\n     getpos,\n-    make_byte_array_copier,\n     make_setter,\n     unwrap_location,\n-    zero_pad,\n )\n-from vyper.old_codegen.return_ import gen_tuple_return, make_return_stmt\n+from vyper.old_codegen.return_ import make_return_stmt\n from vyper.old_codegen.types import (\n     BaseType,\n-    ByteArrayLike,\n     ByteArrayType,\n     ListType,\n-    NodeType,\n-    StructType,\n-    TupleType,\n     get_size_of_type,\n     parse_type,\n )\n-from vyper.utils import SizeLimits, bytes_to_int, fourbytes_to_int, keccak256\n \n \n class Stmt:\n@@ -76,20 +70,26 @@ def parse_AnnAssign(self):\n         # If bytes[32] to bytes32 assignment rewrite sub as bytes32.\n         if is_literal_bytes32_assign:\n             sub = LLLnode(\n-                bytes_to_int(self.stmt.value.s), typ=BaseType(\"bytes32\"), pos=getpos(self.stmt),\n+                util.bytes_to_int(self.stmt.value.s),\n+                typ=BaseType(\"bytes32\"),\n+                pos=getpos(self.stmt),\n             )\n \n         variable_loc = LLLnode.from_list(pos, typ=typ, location=\"memory\", pos=getpos(self.stmt),)\n+\n         lll_node = make_setter(variable_loc, sub, \"memory\", pos=getpos(self.stmt))\n+        lll_node.annotation = self.stmt.get(\"node_source_code\")\n \n         return lll_node\n \n     def parse_Assign(self):\n         # Assignment (e.g. x[4] = y)\n         sub = Expr(self.stmt.value, self.context).lll_node\n         target = self._get_target(self.stmt.target)\n+\n         lll_node = make_setter(target, sub, target.location, pos=getpos(self.stmt))\n         lll_node.pos = getpos(self.stmt)\n+        lll_node.annotation = self.stmt.get(\"node_source_code\")\n         return lll_node\n \n     def parse_If(self):\n@@ -136,29 +136,33 @@ def parse_Call(self):\n         if isinstance(self.stmt.func, vy_ast.Name):\n             funcname = self.stmt.func.id\n             return STMT_DISPATCH_TABLE[funcname].build_LLL(self.stmt, self.context)\n+\n         elif is_self_function:\n-            return self_call.make_call(self.stmt, self.context)\n+            return self_call.lll_for_self_call(self.stmt, self.context)\n         else:\n-            return external_call.make_external_call(self.stmt, self.context)\n+            return external_call.lll_for_external_call(self.stmt, self.context)\n \n     def _assert_reason(self, test_expr, msg):\n         if isinstance(msg, vy_ast.Name) and msg.id == \"UNREACHABLE\":\n             return LLLnode.from_list([\"assert_unreachable\", test_expr], typ=None, pos=getpos(msg))\n \n         reason_str_type = ByteArrayType(len(msg.value.strip()))\n \n+        # abi encode the reason string\n         sig_placeholder = self.context.new_internal_variable(BaseType(32))\n+        # offset of bytes in (bytes,)\n         arg_placeholder = self.context.new_internal_variable(BaseType(32))\n         placeholder_bytes = Expr(msg, self.context).lll_node\n \n-        method_id = fourbytes_to_int(keccak256(b\"Error(string)\")[:4])\n+        method_id = util.abi_method_id(\"Error(string)\")\n \n+        # abi encode method_id + bytestring\n         revert_seq = [\n             \"seq\",\n             [\"mstore\", sig_placeholder, method_id],\n             [\"mstore\", arg_placeholder, 32],\n             placeholder_bytes,\n-            [\"revert\", sig_placeholder + 28, int(4 + get_size_of_type(reason_str_type) * 32)],\n+            [\"revert\", sig_placeholder + 28, int(32 + 4 + get_size_of_type(reason_str_type) * 32)],\n         ]\n         if test_expr:\n             lll_node = [\"if\", [\"iszero\", test_expr], revert_seq]\n@@ -388,143 +392,10 @@ def parse_Break(self):\n         return LLLnode.from_list(\"break\", typ=None, pos=getpos(self.stmt))\n \n     def parse_Return(self):\n-        if self.context.return_type is None:\n-            if self.stmt.value:\n-                return\n-            return LLLnode.from_list(\n-                make_return_stmt(self.stmt, self.context, 0, 0),\n-                typ=None,\n-                pos=getpos(self.stmt),\n-                valency=0,\n-            )\n-\n-        sub = Expr(self.stmt.value, self.context).lll_node\n-\n-        # Returning a value (most common case)\n-        if isinstance(sub.typ, BaseType):\n-            sub = unwrap_location(sub)\n-\n-            if sub.typ.is_literal and (\n-                self.context.return_type.typ == sub.typ\n-                or \"int\" in self.context.return_type.typ\n-                and \"int\" in sub.typ.typ\n-            ):  # noqa: E501\n-                if SizeLimits.in_bounds(self.context.return_type.typ, sub.value):\n-                    return LLLnode.from_list(\n-                        [\n-                            \"seq\",\n-                            [\"mstore\", 0, sub],\n-                            make_return_stmt(self.stmt, self.context, 0, 32),\n-                        ],\n-                        typ=None,\n-                        pos=getpos(self.stmt),\n-                        valency=0,\n-                    )\n-            elif isinstance(sub.typ, BaseType):\n-                return LLLnode.from_list(\n-                    [\"seq\", [\"mstore\", 0, sub], make_return_stmt(self.stmt, self.context, 0, 32)],\n-                    typ=None,\n-                    pos=getpos(self.stmt),\n-                    valency=0,\n-                )\n-            return\n-        # Returning a byte array\n-        elif isinstance(sub.typ, ByteArrayLike):\n-            if not sub.typ.eq_base(self.context.return_type):\n-                return\n-            if sub.typ.maxlen > self.context.return_type.maxlen:\n-                return\n-\n-            # loop memory has to be allocated first.\n-            loop_memory_position = self.context.new_internal_variable(typ=BaseType(\"uint256\"))\n-            # len & bytez placeholder have to be declared after each other at all times.\n-            len_placeholder = self.context.new_internal_variable(BaseType(\"uint256\"))\n-            bytez_placeholder = self.context.new_internal_variable(sub.typ)\n-\n-            if sub.location in (\"storage\", \"memory\"):\n-                return LLLnode.from_list(\n-                    [\n-                        \"seq\",\n-                        make_byte_array_copier(\n-                            LLLnode(bytez_placeholder, location=\"memory\", typ=sub.typ),\n-                            sub,\n-                            pos=getpos(self.stmt),\n-                        ),\n-                        zero_pad(bytez_placeholder),\n-                        [\"mstore\", len_placeholder, 32],\n-                        make_return_stmt(\n-                            self.stmt,\n-                            self.context,\n-                            len_placeholder,\n-                            [\"ceil32\", [\"add\", [\"mload\", bytez_placeholder], 64]],\n-                            loop_memory_position=loop_memory_position,\n-                        ),\n-                    ],\n-                    typ=None,\n-                    pos=getpos(self.stmt),\n-                    valency=0,\n-                )\n-            return\n-\n-        elif isinstance(sub.typ, ListType):\n-            loop_memory_position = self.context.new_internal_variable(typ=BaseType(\"uint256\"))\n-            if sub.location == \"memory\" and sub.value != \"multi\":\n-                return LLLnode.from_list(\n-                    make_return_stmt(\n-                        self.stmt,\n-                        self.context,\n-                        sub,\n-                        get_size_of_type(self.context.return_type) * 32,\n-                        loop_memory_position=loop_memory_position,\n-                    ),\n-                    typ=None,\n-                    pos=getpos(self.stmt),\n-                    valency=0,\n-                )\n-            else:\n-                new_sub = LLLnode.from_list(\n-                    self.context.new_internal_variable(self.context.return_type),\n-                    typ=self.context.return_type,\n-                    location=\"memory\",\n-                )\n-                setter = make_setter(new_sub, sub, \"memory\", pos=getpos(self.stmt))\n-                return LLLnode.from_list(\n-                    [\n-                        \"seq\",\n-                        setter,\n-                        make_return_stmt(\n-                            self.stmt,\n-                            self.context,\n-                            new_sub,\n-                            get_size_of_type(self.context.return_type) * 32,\n-                            loop_memory_position=loop_memory_position,\n-                        ),\n-                    ],\n-                    typ=None,\n-                    pos=getpos(self.stmt),\n-                )\n-\n-        # Returning a struct\n-        elif isinstance(sub.typ, StructType):\n-            retty = self.context.return_type\n-            if isinstance(retty, StructType) and retty.name == sub.typ.name:\n-                return gen_tuple_return(self.stmt, self.context, sub)\n-\n-        # Returning a tuple.\n-        elif isinstance(sub.typ, TupleType):\n-            if not isinstance(self.context.return_type, TupleType):\n-                return\n-\n-            if len(self.context.return_type.members) != len(sub.typ.members):\n-                return\n-\n-            # check return type matches, sub type.\n-            for i, ret_x in enumerate(self.context.return_type.members):\n-                s_member = sub.typ.members[i]\n-                sub_type = s_member if isinstance(s_member, NodeType) else s_member.typ\n-                if type(sub_type) is not type(ret_x):\n-                    return\n-            return gen_tuple_return(self.stmt, self.context, sub)\n+        lll_val = None\n+        if self.stmt.value is not None:\n+            lll_val = Expr(self.stmt.value, self.context).lll_node\n+        return make_return_stmt(lll_val, self.stmt, self.context)\n \n     def _get_target(self, target):\n         if isinstance(target, vy_ast.Name) and target.id in self.context.forvars:"
        },
        {
          "filename": "vyper/old_codegen/types/check.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -6,6 +6,6 @@\n \n # Check assignment from rhs to lhs.\n # For now use make_setter for its typechecking side effects\n-def check_assign(lhs, rhs, pos, in_function_call=False):\n-    make_setter(lhs, rhs, location=\"memory\", pos=pos, in_function_call=in_function_call)\n+def check_assign(lhs, rhs, pos):\n+    make_setter(lhs, rhs, location=\"memory\", pos=pos)\n     # TODO Refactor into an actual type-checking function"
        },
        {
          "filename": "vyper/old_codegen/types/types.py",
          "status": "modified",
          "additions": 5,
          "deletions": 32,
          "patch": "@@ -181,6 +181,7 @@ def canonicalize_type(t, is_indexed=False):\n     raise InvalidType(f\"Invalid or unsupported type: {repr(t)}\")\n \n \n+# TODO location is unused\n def make_struct_type(name, location, sigs, members, custom_structs):\n     o = OrderedDict()\n \n@@ -196,7 +197,9 @@ def make_struct_type(name, location, sigs, members, custom_structs):\n \n # Parses an expression representing a type. Annotation refers to whether\n # the type is to be located in memory or storage\n-def parse_type(item, location, sigs=None, custom_structs=None):\n+# TODO: location is unused\n+# TODO: rename me to \"lll_type_from_annotation\"\n+def parse_type(item, location=None, sigs=None, custom_structs=None):\n     # Base and custom types, e.g. num\n     if isinstance(item, vy_ast.Name):\n         if item.id in BASE_TYPES:\n@@ -271,7 +274,7 @@ def parse_type(item, location, sigs=None, custom_structs=None):\n \n # byte array overhead, in words. (it should really be 1, but there are\n # some places in our calling convention where the layout expects 2)\n-BYTE_ARRAY_OVERHEAD = 2\n+BYTE_ARRAY_OVERHEAD = 1\n \n \n # Gets the maximum number of memory or storage keys needed to ABI-encode\n@@ -304,36 +307,6 @@ def get_type_for_exact_size(n_bytes):\n     return ByteArrayType(n_bytes - 32 * BYTE_ARRAY_OVERHEAD)\n \n \n-# amount of space a type takes in the static section of its ABI encoding\n-def get_static_size_of_type(typ):\n-    if isinstance(typ, BaseType):\n-        return 1\n-    elif isinstance(typ, ByteArrayLike):\n-        return 1\n-    elif isinstance(typ, ListType):\n-        return get_size_of_type(typ.subtype) * typ.count\n-    elif isinstance(typ, MappingType):\n-        raise InvalidType(\"Maps are not supported for function arguments or outputs.\")\n-    elif isinstance(typ, TupleLike):\n-        return sum([get_size_of_type(v) for v in typ.tuple_members()])\n-    else:\n-        raise InvalidType(f\"Can not get size of type, Unexpected type: {repr(typ)}\")\n-\n-\n-# could be rewritten as get_static_size_of_type == get_size_of_type?\n-def has_dynamic_data(typ):\n-    if isinstance(typ, BaseType):\n-        return False\n-    elif isinstance(typ, ByteArrayLike):\n-        return True\n-    elif isinstance(typ, ListType):\n-        return has_dynamic_data(typ.subtype)\n-    elif isinstance(typ, TupleLike):\n-        return any([has_dynamic_data(v) for v in typ.tuple_members()])\n-    else:\n-        raise InvalidType(f\"Unexpected type: {repr(typ)}\")\n-\n-\n def get_type(input):\n     if not hasattr(input, \"typ\"):\n         typ, len = \"num_literal\", 32"
        },
        {
          "filename": "vyper/semantics/namespace.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -22,7 +22,7 @@ class Namespace(dict):\n     def __init__(self):\n         super().__init__()\n         self._scopes = []\n-        # FLAG cyclic imports!\n+        # NOTE cyclic imports!\n         from vyper.builtin_functions.functions import get_builtin_functions\n         from vyper.semantics import environment\n         from vyper.semantics.types import get_types\n@@ -62,7 +62,7 @@ def enter_scope(self):\n         Called as a context manager, e.g. `with namespace.enter_scope():`\n         All items that are added within the context are removed upon exit.\n         \"\"\"\n-        # FLAG cyclic imports!\n+        # NOTE cyclic imports!\n         from vyper.semantics import environment\n \n         self._scopes.append(set())"
        },
        {
          "filename": "vyper/semantics/types/function.py",
          "status": "modified",
          "additions": 23,
          "deletions": 12,
          "patch": "@@ -96,6 +96,7 @@ def __init__(\n         self,\n         name: str,\n         arguments: OrderedDict,\n+        # TODO rename to something like positional_args, keyword_args\n         min_arg_count: int,\n         max_arg_count: int,\n         return_type: Optional[BaseTypeDefinition],\n@@ -321,13 +322,6 @@ def from_FunctionDef(\n             type_definition = get_type_from_annotation(\n                 arg.annotation, location=DataLocation.CALLDATA, is_immutable=True\n             )\n-            if isinstance(type_definition, StructDefinition) and type_definition.is_dynamic_size:\n-                # this is a temporary restriction and should be removed once support for dynamically\n-                # sized structs is implemented - https://github.com/vyperlang/vyper/issues/2190\n-                raise ArgumentException(\n-                    \"Struct with dynamically sized data cannot be used as a function input\", arg\n-                )\n-\n             if value is not None:\n                 if not check_constant(value):\n                     raise StateAccessViolation(\n@@ -367,7 +361,7 @@ def from_AnnAssign(cls, node: vy_ast.AnnAssign) -> \"ContractFunction\":\n         \"\"\"\n         Generate a `ContractFunction` object from an `AnnAssign` node.\n \n-        Used to create function definitions for public variables.\n+        Used to create getter functions for public variables.\n \n         Arguments\n         ---------\n@@ -402,7 +396,7 @@ def method_ids(self) -> Dict[str, int]:\n \n         * For functions without default arguments the dict contains one item.\n         * For functions with default arguments, there is one key for each\n-          function signfature.\n+          function signature.\n         \"\"\"\n         arg_types = [i.canonical_type for i in self.arguments.values()]\n \n@@ -414,6 +408,20 @@ def method_ids(self) -> Dict[str, int]:\n             method_ids.update(_generate_method_id(self.name, arg_types[:i]))\n         return method_ids\n \n+    # for caller-fills-args calling convention\n+    def get_args_buffer_offset(self) -> int:\n+        \"\"\"\n+        Get the location of the args buffer in the function frame (caller sets)\n+        \"\"\"\n+        return 0\n+\n+    # TODO is this needed?\n+    def get_args_buffer_len(self) -> int:\n+        \"\"\"\n+        Get the length of the argument buffer in the function frame\n+        \"\"\"\n+        return sum(arg_t.size_in_bytes() for arg_t in self.arguments.values())\n+\n     @property\n     def is_constructor(self) -> bool:\n         return self.name == \"__init__\"\n@@ -473,10 +481,8 @@ def to_abi_dict(self) -> List[Dict]:\n         typ = self.return_type\n         if typ is None:\n             abi_dict[\"outputs\"] = []\n-        elif isinstance(typ, TupleDefinition):\n+        elif isinstance(typ, TupleDefinition) and len(typ.value_type) > 1:  # type: ignore\n             abi_dict[\"outputs\"] = [_generate_abi_type(i) for i in typ.value_type]  # type: ignore\n-        elif isinstance(typ, StructDefinition):\n-            abi_dict[\"outputs\"] = [_generate_abi_type(v, k) for k, v in typ.members.items()]\n         else:\n             abi_dict[\"outputs\"] = [_generate_abi_type(typ)]\n \n@@ -498,6 +504,11 @@ def _generate_abi_type(type_definition, name=\"\"):\n             \"type\": \"tuple\",\n             \"components\": [_generate_abi_type(v, k) for k, v in type_definition.members.items()],\n         }\n+    if isinstance(type_definition, TupleDefinition):\n+        return {\n+            \"type\": \"tuple\",\n+            \"components\": [_generate_abi_type(i) for i in type_definition.value_type],\n+        }\n     return {\"name\": name, \"type\": type_definition.canonical_type}\n \n "
        },
        {
          "filename": "vyper/semantics/types/indexable/sequence.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -116,7 +116,9 @@ def __init__(self, value_type: Tuple[BaseTypeDefinition, ...]) -> None:\n         # always use the most restrictive location re: modification\n         location = sorted((i.location for i in value_type), key=lambda k: k.value)[-1]\n         is_immutable = next((True for i in value_type if getattr(i, \"is_immutable\", None)), False)\n+\n         super().__init__(\n+            # TODO fix the typing on value_type\n             value_type,  # type: ignore\n             len(value_type),\n             f\"{value_type}\","
        },
        {
          "filename": "vyper/semantics/types/value/array_value.py",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -1,9 +1,9 @@\n-import math\n from typing import Type\n \n from vyper import ast as vy_ast\n from vyper.exceptions import CompilerPanic, StructureException, UnexpectedValue\n from vyper.semantics import validation\n+from vyper.utils import ceil32\n \n from ..abstract import ArrayValueAbstractType, BytesAbstractType\n from ..bases import BasePrimitive, DataLocation, ValueTypeDefinition\n@@ -61,8 +61,7 @@ def size_in_bytes(self):\n         # because this data type is single-bytes, we make it so it takes the max 32 byte\n         # boundary as it's size, instead of giving it a size that is not cleanly divisble by 32\n \n-        # TODO adding 64 here instead of 32 to be compatible with parser - fix this!\n-        return 64 + math.ceil(self.length / 32) * 32\n+        return 32 + ceil32(self.length)\n \n     @property\n     def canonical_type(self) -> str:"
        },
        {
          "filename": "vyper/utils.py",
          "status": "modified",
          "additions": 29,
          "deletions": 1,
          "patch": "@@ -1,5 +1,7 @@\n import binascii\n import functools\n+import sys\n+import traceback\n from typing import Dict, List, Union\n \n from vyper.exceptions import InvalidLiteral\n@@ -13,18 +15,37 @@\n \n     keccak256 = lambda x: _sha3.sha3_256(x).digest()  # noqa: E731\n \n+try:\n+    # available py3.8+\n+    from functools import cached_property\n+except ImportError:\n+    from cached_property import cached_property  # type: ignore\n+\n \n # Converts four bytes to an integer\n def fourbytes_to_int(inp):\n     return (inp[0] << 24) + (inp[1] << 16) + (inp[2] << 8) + inp[3]\n \n \n+# utility function for debugging purposes\n+def trace(n=5, out=sys.stderr):\n+    print(\"BEGIN TRACE\", file=out)\n+    for x in list(traceback.format_stack())[-n:]:\n+        print(x.strip(), file=out)\n+    print(\"END TRACE\", file=out)\n+\n+\n # converts a signature like Func(bool,uint256,address) to its 4 byte method ID\n # TODO replace manual calculations in codebase with this\n def abi_method_id(method_sig):\n     return fourbytes_to_int(keccak256(bytes(method_sig, \"utf-8\"))[:4])\n \n \n+# map a string to only-alphanumeric chars\n+def mkalphanum(s):\n+    return \"\".join([c if c.isalnum() else \"_\" for c in s])\n+\n+\n # Converts string to bytes\n def string_to_bytes(str):\n     bytez = b\"\"\n@@ -77,6 +98,8 @@ def calc_mem_gas(memsize):\n # Specific gas usage\n GAS_IDENTITY = 15\n GAS_IDENTITYWORD = 3\n+GAS_CODECOPY_WORD = 3\n+GAS_CALLDATACOPY_WORD = 3\n \n # A decimal value can store multiples of 1/DECIMAL_DIVISOR\n MAX_DECIMAL_PLACES = 10\n@@ -139,7 +162,7 @@ def in_bounds(cls, type_str, value):\n     \"send\",\n }\n \n-# List of valid LLL macros. Used for colorising LLL output\n+# List of valid LLL macros.\n VALID_LLL_MACROS = {\n     \"assert\",\n     \"break\",\n@@ -299,3 +322,8 @@ def annotate_source_code(\n     cleanup_lines += [\"\"] * (num_lines - len(cleanup_lines))\n \n     return \"\\n\".join(cleanup_lines)\n+\n+\n+__all__ = [\n+    \"cached_property\",\n+]"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 17,
        "unique_directories": 28,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c208b954564e8fffdd4c86cc3c497e0c3df1aeec",
            "date": "2025-01-14T17:09:31Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "db8dcc713168b16977b5b07267653c9024f6acea",
            "date": "2025-01-12T17:01:49Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "10e91d5a2ba6eaab2f7194fd86cefb7a0ff19964",
            "date": "2025-01-12T16:34:14Z",
            "author_login": "tserg"
          },
          {
            "sha": "43259f8953672ef7a19167c6c048d020d82e05da",
            "date": "2025-01-12T16:32:46Z",
            "author_login": "charles-cooper"
          },
          {
            "sha": "9b5523e6131335c81714e7e8af63cc49404f5ce7",
            "date": "2025-01-12T16:19:30Z",
            "author_login": "charles-cooper"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-667",
    "description": "Vyper is a pythonic Smart Contract Language for the Ethereum virtual machine. Prior to version 0.3.0, default functions don't respect nonreentrancy keys and the lock isn't emitted. No vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is low. Version 0.3.0 contains a patch for the issue.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-25T18:15:09.157",
    "last_modified": "2025-01-02T22:43:19.753",
    "fix_date": "2021-10-03T05:58:47Z"
  },
  "references": [
    {
      "url": "https://github.com/vyperlang/vyper/commit/93287e5ac184b53b395c907d40701f721daf8177",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/issues/2455",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-m2v9-w374-5hj9",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/commit/93287e5ac184b53b395c907d40701f721daf8177",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/issues/2455",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-m2v9-w374-5hj9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:07.023038",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vyper",
    "owner": "vyperlang",
    "created_at": "2016-11-11T08:56:41Z",
    "updated_at": "2025-01-13T17:32:27Z",
    "pushed_at": "2025-01-12T17:01:50Z",
    "size": 11939,
    "stars": 4948,
    "forks": 817,
    "open_issues": 489,
    "watchers": 4948,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Python": 2662211,
      "Makefile": 2222,
      "Batchfile": 1614,
      "Dockerfile": 1145,
      "Shell": 472
    },
    "commit_activity": {
      "total_commits_last_year": 317,
      "avg_commits_per_week": 6.096153846153846,
      "days_active_last_year": 154
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:48:09.728520"
  }
}