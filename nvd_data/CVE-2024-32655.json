{
  "cve_id": "CVE-2024-32655",
  "github_data": {
    "repository": "npgsql/npgsql",
    "fix_commit": "091655eed0c84e502ab424950c930339d17c1928",
    "related_commits": [
      "091655eed0c84e502ab424950c930339d17c1928",
      "3183efb2bdcca159c8c2e22af57e18ea8f853cf0",
      "67acbe027e28477ac2199e15cfb554bb2ffaf169",
      "703d9af8fa48dfe8c0180e36edb8278f34342d7b",
      "a22a42d8141d7a3528f43c02c095a409507cf1af",
      "e34e2ba8042e666d9af54a1b255fba4d5b11df56",
      "f7e7ead0702d776a8f551f5786c4cac2d65c4bc6",
      "091655eed0c84e502ab424950c930339d17c1928",
      "3183efb2bdcca159c8c2e22af57e18ea8f853cf0",
      "67acbe027e28477ac2199e15cfb554bb2ffaf169",
      "703d9af8fa48dfe8c0180e36edb8278f34342d7b",
      "a22a42d8141d7a3528f43c02c095a409507cf1af",
      "e34e2ba8042e666d9af54a1b255fba4d5b11df56",
      "f7e7ead0702d776a8f551f5786c4cac2d65c4bc6"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "091655eed0c84e502ab424950c930339d17c1928",
      "commit_date": "2024-05-09T11:20:07Z",
      "author": {
        "login": "NinoFloris",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-x9vc-6hfv-hg8c",
        "length": 43,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 302,
        "additions": 272,
        "deletions": 30
      },
      "files": [
        {
          "filename": "src/Npgsql/Internal/NpgsqlConnector.FrontendMessages.cs",
          "status": "modified",
          "additions": 38,
          "deletions": 18,
          "patch": "@@ -19,6 +19,7 @@ internal Task WriteDescribe(StatementOrPortal statementOrPortal, byte[] asciiNam\n                   (asciiName.Length + 1);   // Statement/portal name\n \n         var writeBuffer = WriteBuffer;\n+        writeBuffer.StartMessage(len);\n         if (writeBuffer.WriteSpaceLeft < len)\n             return FlushAndWrite(len, statementOrPortal, asciiName, async, cancellationToken);\n \n@@ -48,6 +49,7 @@ internal Task WriteSync(bool async, CancellationToken cancellationToken = defaul\n                         sizeof(int);    // Length\n \n         var writeBuffer = WriteBuffer;\n+        writeBuffer.StartMessage(len);\n         if (writeBuffer.WriteSpaceLeft < len)\n             return FlushAndWrite(async, cancellationToken);\n \n@@ -79,6 +81,7 @@ internal Task WriteExecute(int maxRows, bool async, CancellationToken cancellati\n                         sizeof(int);         // Max number of rows\n \n         var writeBuffer = WriteBuffer;\n+        writeBuffer.StartMessage(len);\n         if (writeBuffer.WriteSpaceLeft < len)\n             return FlushAndWrite(maxRows, async, cancellationToken);\n \n@@ -118,9 +121,6 @@ internal async Task WriteParse(string sql, byte[] asciiName, List<NpgsqlParamete\n         }\n \n         var writeBuffer = WriteBuffer;\n-        if (writeBuffer.WriteSpaceLeft < 1 + 4 + asciiName.Length + 1)\n-            await Flush(async, cancellationToken).ConfigureAwait(false);\n-\n         var messageLength =\n             sizeof(byte)                +         // Message code\n             sizeof(int)                 +         // Length\n@@ -130,9 +130,14 @@ internal async Task WriteParse(string sql, byte[] asciiName, List<NpgsqlParamete\n             sizeof(ushort)              +         // Number of parameters\n             inputParameters.Count * sizeof(int);  // Parameter OIDs\n \n-        writeBuffer.WriteByte(FrontendMessageCode.Parse);\n-        writeBuffer.WriteInt32(messageLength - 1);\n-        writeBuffer.WriteNullTerminatedString(asciiName);\n+\n+        WriteBuffer.StartMessage(messageLength);\n+        if (WriteBuffer.WriteSpaceLeft < 1 + 4 + asciiName.Length + 1)\n+            await Flush(async, cancellationToken).ConfigureAwait(false);\n+\n+        WriteBuffer.WriteByte(FrontendMessageCode.Parse);\n+        WriteBuffer.WriteInt32(messageLength - 1);\n+        WriteBuffer.WriteNullTerminatedString(asciiName);\n \n         await writeBuffer.WriteString(sql, queryByteLen, async, cancellationToken).ConfigureAwait(false);\n \n@@ -171,12 +176,6 @@ internal async Task WriteBind(\n             sizeof(ushort);                       // Number of parameter format codes that follow\n \n         var writeBuffer = WriteBuffer;\n-        if (writeBuffer.WriteSpaceLeft < headerLength)\n-        {\n-            Debug.Assert(writeBuffer.Size >= headerLength, \"Write buffer too small for Bind header\");\n-            await Flush(async, cancellationToken).ConfigureAwait(false);\n-        }\n-\n         var formatCodesSum = 0;\n         var paramsLength = 0;\n         for (var paramIndex = 0; paramIndex < parameters.Count; paramIndex++)\n@@ -197,8 +196,15 @@ internal async Task WriteBind(\n                             sizeof(short)                        +                  // Number of result format codes\n                             sizeof(short) * (unknownResultTypeList?.Length ?? 1);   // Result format codes\n \n-        writeBuffer.WriteByte(FrontendMessageCode.Bind);\n-        writeBuffer.WriteInt32(messageLength - 1);\n+        WriteBuffer.StartMessage(messageLength);\n+        if (WriteBuffer.WriteSpaceLeft < headerLength)\n+        {\n+            Debug.Assert(WriteBuffer.Size >= headerLength, \"Write buffer too small for Bind header\");\n+            await Flush(async, cancellationToken).ConfigureAwait(false);\n+        }\n+\n+        WriteBuffer.WriteByte(FrontendMessageCode.Bind);\n+        WriteBuffer.WriteInt32(messageLength - 1);\n         Debug.Assert(portal == string.Empty);\n         writeBuffer.WriteByte(0);  // Portal is always empty\n \n@@ -269,6 +275,7 @@ internal Task WriteClose(StatementOrPortal type, byte[] asciiName, bool async, C\n                   asciiName.Length + sizeof(byte);  // Statement or portal name plus null terminator\n \n         var writeBuffer = WriteBuffer;\n+        writeBuffer.StartMessage(len);\n         if (writeBuffer.WriteSpaceLeft < len)\n             return FlushAndWrite(len, type, asciiName, async, cancellationToken);\n \n@@ -296,14 +303,17 @@ internal async Task WriteQuery(string sql, bool async, CancellationToken cancell\n     {\n         var queryByteLen = TextEncoding.GetByteCount(sql);\n \n+        var len = sizeof(byte) +\n+                  sizeof(int) + // Message length (including self excluding code)\n+                  queryByteLen + // Query byte length\n+                  sizeof(byte);\n+\n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < 1 + 4)\n             await Flush(async, cancellationToken).ConfigureAwait(false);\n \n         WriteBuffer.WriteByte(FrontendMessageCode.Query);\n-        WriteBuffer.WriteInt32(\n-            sizeof(int)  +        // Message length (including self excluding code)\n-            queryByteLen +        // Query byte length\n-            sizeof(byte));        // Null terminator\n+        WriteBuffer.WriteInt32(len - 1);\n \n         await WriteBuffer.WriteString(sql, queryByteLen, async, cancellationToken).ConfigureAwait(false);\n         if (WriteBuffer.WriteSpaceLeft < 1)\n@@ -316,6 +326,7 @@ internal async Task WriteCopyDone(bool async, CancellationToken cancellationToke\n         const int len = sizeof(byte) +   // Message code\n                         sizeof(int);     // Length\n \n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < len)\n             await Flush(async, cancellationToken).ConfigureAwait(false);\n \n@@ -331,6 +342,7 @@ internal async Task WriteCopyFail(bool async, CancellationToken cancellationToke\n                         sizeof(int) +   // Length\n                         sizeof(byte);   // Error message is always empty (only a null terminator)\n \n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < len)\n             await Flush(async, cancellationToken).ConfigureAwait(false);\n \n@@ -348,6 +360,7 @@ internal void WriteCancelRequest(int backendProcessId, int backendSecretKey)\n \n         Debug.Assert(backendProcessId != 0);\n \n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < len)\n             Flush(false).GetAwaiter().GetResult();\n \n@@ -362,6 +375,7 @@ internal void WriteTerminate()\n         const int len = sizeof(byte) +  // Message code\n                         sizeof(int);    // Length\n \n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < len)\n             Flush(false).GetAwaiter().GetResult();\n \n@@ -374,6 +388,7 @@ internal void WriteSslRequest()\n         const int len = sizeof(int) +  // Length\n                         sizeof(int);   // SSL request code\n \n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < len)\n             Flush(false).GetAwaiter().GetResult();\n \n@@ -394,6 +409,7 @@ internal void WriteStartup(Dictionary<string, string> parameters)\n                    NpgsqlWriteBuffer.UTF8Encoding.GetByteCount(kvp.Value) + 1;\n \n         // Should really never happen, just in case\n+        WriteBuffer.StartMessage(len);\n         if (len > WriteBuffer.Size)\n             throw new Exception(\"Startup message bigger than buffer\");\n \n@@ -417,8 +433,10 @@ internal void WriteStartup(Dictionary<string, string> parameters)\n \n     internal async Task WritePassword(byte[] payload, int offset, int count, bool async, CancellationToken cancellationToken = default)\n     {\n+        WriteBuffer.StartMessage(sizeof(byte) + sizeof(int) + count);\n         if (WriteBuffer.WriteSpaceLeft < sizeof(byte) + sizeof(int))\n             await WriteBuffer.Flush(async, cancellationToken).ConfigureAwait(false);\n+\n         WriteBuffer.WriteByte(FrontendMessageCode.Password);\n         WriteBuffer.WriteInt32(sizeof(int) + count);\n \n@@ -441,6 +459,7 @@ internal async Task WriteSASLInitialResponse(string mechanism, byte[] initialRes\n                   sizeof(int)                                                +  // Initial response length\n                   (initialResponse?.Length ?? 0);                               // Initial response payload\n \n+        WriteBuffer.StartMessage(len);\n         if (WriteBuffer.WriteSpaceLeft < len)\n             await WriteBuffer.Flush(async, cancellationToken).ConfigureAwait(false);\n \n@@ -464,6 +483,7 @@ internal async Task WriteSASLInitialResponse(string mechanism, byte[] initialRes\n \n     internal Task WritePregenerated(byte[] data, bool async = false, CancellationToken cancellationToken = default)\n     {\n+        WriteBuffer.StartMessage(data.Length);\n         if (WriteBuffer.WriteSpaceLeft < data.Length)\n             return FlushAndWrite(data, async, cancellationToken);\n "
        },
        {
          "filename": "src/Npgsql/Internal/NpgsqlWriteBuffer.cs",
          "status": "modified",
          "additions": 59,
          "deletions": 2,
          "patch": "@@ -29,6 +29,8 @@ sealed class NpgsqlWriteBuffer : IDisposable\n     internal Stream Underlying { private get; set; }\n \n     readonly Socket? _underlyingSocket;\n+    internal bool MessageLengthValidation { get; set; } = true;\n+\n     readonly ResettableCancellationTokenSource _timeoutCts;\n     readonly MetricsReporter? _metricsReporter;\n \n@@ -77,6 +79,9 @@ internal PgWriter GetWriter(NpgsqlDatabaseInfo typeCatalog, FlushMode flushMode\n \n     internal int WritePosition;\n \n+    int _messageBytesFlushed;\n+    int? _messageLength;\n+\n     bool _disposed;\n     readonly PgWriter _pgWriter;\n \n@@ -132,6 +137,8 @@ public async Task Flush(bool async, CancellationToken cancellationToken = defaul\n             WritePosition = pos;\n         } else if (WritePosition == 0)\n             return;\n+        else\n+            AdvanceMessageBytesFlushed(WritePosition);\n \n         var finalCt = async && Timeout > TimeSpan.Zero\n             ? _timeoutCts.Start(cancellationToken)\n@@ -200,15 +207,19 @@ internal void DirectWrite(ReadOnlySpan<byte> buffer)\n             Debug.Assert(WritePosition == 5);\n \n             WritePosition = 1;\n-            WriteInt32(buffer.Length + 4);\n+            WriteInt32(checked(buffer.Length + 4));\n             WritePosition = 5;\n             _copyMode = false;\n+            StartMessage(5);\n             Flush();\n             _copyMode = true;\n             WriteCopyDataHeader();  // And ready the buffer after the direct write completes\n         }\n         else\n+        {\n             Debug.Assert(WritePosition == 0);\n+            AdvanceMessageBytesFlushed(buffer.Length);\n+        }\n \n         try\n         {\n@@ -231,15 +242,19 @@ internal async Task DirectWrite(ReadOnlyMemory<byte> memory, bool async, Cancell\n             Debug.Assert(WritePosition == 5);\n \n             WritePosition = 1;\n-            WriteInt32(memory.Length + 4);\n+            WriteInt32(checked(memory.Length + 4));\n             WritePosition = 5;\n             _copyMode = false;\n+            StartMessage(5);\n             await Flush(async, cancellationToken).ConfigureAwait(false);\n             _copyMode = true;\n             WriteCopyDataHeader();  // And ready the buffer after the direct write completes\n         }\n         else\n+        {\n             Debug.Assert(WritePosition == 0);\n+            AdvanceMessageBytesFlushed(memory.Length);\n+        }\n \n         try\n         {\n@@ -537,9 +552,51 @@ public void Dispose()\n \n     #region Misc\n \n+    internal void StartMessage(int messageLength)\n+    {\n+        if (!MessageLengthValidation)\n+            return;\n+\n+        if (_messageLength is not null && _messageBytesFlushed != _messageLength && WritePosition != -_messageBytesFlushed + _messageLength)\n+            Throw();\n+\n+        // Add negative WritePosition to compensate for previous message(s) written without flushing.\n+        _messageBytesFlushed = -WritePosition;\n+        _messageLength = messageLength;\n+\n+        void Throw()\n+        {\n+            throw Connector.Break(new OverflowException(\"Did not write the amount of bytes the message length specified\"));\n+        }\n+    }\n+\n+    void AdvanceMessageBytesFlushed(int count)\n+    {\n+        if (!MessageLengthValidation)\n+            return;\n+\n+        if (count < 0 || _messageLength is null || (long)_messageBytesFlushed + count > _messageLength)\n+            Throw();\n+\n+        _messageBytesFlushed += count;\n+\n+        void Throw()\n+        {\n+            if (count < 0)\n+                throw new ArgumentOutOfRangeException(nameof(count), \"Can't advance by a negative count\");\n+\n+            if (_messageLength is null)\n+                throw Connector.Break(new InvalidOperationException(\"No message was started\"));\n+\n+            if ((long)_messageBytesFlushed + count > _messageLength)\n+                throw Connector.Break(new OverflowException(\"Tried to write more bytes than the message length specified\"));\n+        }\n+    }\n+\n     internal void Clear()\n     {\n         WritePosition = 0;\n+        _messageLength = null;\n     }\n \n     /// <summary>"
        },
        {
          "filename": "src/Npgsql/NpgsqlTransaction.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 10,
          "patch": "@@ -224,16 +224,7 @@ public void Save(string name)\n \n         // Note: savepoint names are PostgreSQL identifiers, and so limited by default to 63 characters.\n         // Since we are prepending, we assume below that the statement will always fit in the buffer.\n-        _connector.WriteBuffer.WriteByte(FrontendMessageCode.Query);\n-        _connector.WriteBuffer.WriteInt32(\n-            sizeof(int)  +                               // Message length (including self excluding code)\n-            _connector.TextEncoding.GetByteCount(\"SAVEPOINT \") +\n-            _connector.TextEncoding.GetByteCount(name) +\n-            sizeof(byte));                               // Null terminator\n-\n-        _connector.WriteBuffer.WriteString(\"SAVEPOINT \");\n-        _connector.WriteBuffer.WriteString(name);\n-        _connector.WriteBuffer.WriteByte(0);\n+        _connector.WriteQuery(\"SAVEPOINT \" + name, async: false).GetAwaiter().GetResult();\n \n         _connector.PendingPrependedResponses += 2;\n     }"
        },
        {
          "filename": "test/Npgsql.Tests/CommandTests.cs",
          "status": "modified",
          "additions": 171,
          "deletions": 0,
          "patch": "@@ -852,6 +852,176 @@ public async Task Use_after_reload_types_invalidates_cached_infos()\n         }\n     }\n \n+    [Test]\n+    public async Task Parameter_overflow_message_length_throws()\n+    {\n+        await using var conn = CreateConnection();\n+        await conn.OpenAsync();\n+        await using var cmd = new NpgsqlCommand(\"SELECT @a, @b, @c, @d, @e, @f, @g, @h\", conn);\n+\n+        var largeParam = new string('A', 1 << 29);\n+        cmd.Parameters.AddWithValue(\"a\", largeParam);\n+        cmd.Parameters.AddWithValue(\"b\", largeParam);\n+        cmd.Parameters.AddWithValue(\"c\", largeParam);\n+        cmd.Parameters.AddWithValue(\"d\", largeParam);\n+        cmd.Parameters.AddWithValue(\"e\", largeParam);\n+        cmd.Parameters.AddWithValue(\"f\", largeParam);\n+        cmd.Parameters.AddWithValue(\"g\", largeParam);\n+        cmd.Parameters.AddWithValue(\"h\", largeParam);\n+\n+        Assert.ThrowsAsync<OverflowException>(() => cmd.ExecuteReaderAsync());\n+    }\n+\n+    [Test]\n+    public async Task Composite_overflow_message_length_throws()\n+    {\n+        await using var adminConnection = await OpenConnectionAsync();\n+        var type = await GetTempTypeName(adminConnection);\n+\n+        await adminConnection.ExecuteNonQueryAsync(\n+            $\"CREATE TYPE {type} AS (a text, b text, c text, d text, e text, f text, g text, h text)\");\n+\n+        var dataSourceBuilder = CreateDataSourceBuilder();\n+        dataSourceBuilder.MapComposite<BigComposite>(type);\n+        await using var dataSource = dataSourceBuilder.Build();\n+        await using var connection = await dataSource.OpenConnectionAsync();\n+\n+        var largeString = new string('A', 1 << 29);\n+\n+        await using var cmd = connection.CreateCommand();\n+        cmd.CommandText = \"SELECT @a\";\n+        cmd.Parameters.AddWithValue(\"a\", new BigComposite\n+        {\n+            A = largeString,\n+            B = largeString,\n+            C = largeString,\n+            D = largeString,\n+            E = largeString,\n+            F = largeString,\n+            G = largeString,\n+            H = largeString\n+        });\n+\n+        Assert.ThrowsAsync<OverflowException>(async () => await cmd.ExecuteNonQueryAsync());\n+    }\n+\n+    record BigComposite\n+    {\n+        public string A { get; set; } = null!;\n+        public string B { get; set; } = null!;\n+        public string C { get; set; } = null!;\n+        public string D { get; set; } = null!;\n+        public string E { get; set; } = null!;\n+        public string F { get; set; } = null!;\n+        public string G { get; set; } = null!;\n+        public string H { get; set; } = null!;\n+    }\n+\n+    [Test]\n+    public async Task Array_overflow_message_length_throws()\n+    {\n+        await using var connection = await OpenConnectionAsync();\n+\n+        var largeString = new string('A', 1 << 29);\n+\n+        await using var cmd = connection.CreateCommand();\n+        cmd.CommandText = \"SELECT @a\";\n+        var array = new[]\n+        {\n+            largeString,\n+            largeString,\n+            largeString,\n+            largeString,\n+            largeString,\n+            largeString,\n+            largeString,\n+            largeString\n+        };\n+        cmd.Parameters.AddWithValue(\"a\", array);\n+\n+        Assert.ThrowsAsync<OverflowException>(async () => await cmd.ExecuteNonQueryAsync());\n+    }\n+\n+    [Test]\n+    public async Task Range_overflow_message_length_throws()\n+    {\n+        await using var adminConnection = await OpenConnectionAsync();\n+        var type = await GetTempTypeName(adminConnection);\n+        var rangeType = await GetTempTypeName(adminConnection);\n+\n+        await adminConnection.ExecuteNonQueryAsync(\n+            $\"CREATE TYPE {type} AS (a text, b text, c text, d text, e text, f text, g text, h text);CREATE TYPE {rangeType} AS RANGE(subtype={type})\");\n+\n+        var dataSourceBuilder = CreateDataSourceBuilder();\n+        dataSourceBuilder.MapComposite<BigComposite>(type);\n+        dataSourceBuilder.EnableUnmappedTypes();\n+        await using var dataSource = dataSourceBuilder.Build();\n+        await using var connection = await dataSource.OpenConnectionAsync();\n+\n+        var largeString = new string('A', (1 << 28) + 2000000);\n+\n+        await using var cmd = connection.CreateCommand();\n+        cmd.CommandText = \"SELECT @a\";\n+        var composite = new BigComposite\n+        {\n+            A = largeString,\n+            B = largeString,\n+            C = largeString,\n+            D = largeString\n+        };\n+        var range = new NpgsqlRange<BigComposite>(composite, composite);\n+        cmd.Parameters.Add(new NpgsqlParameter\n+        {\n+            Value = range,\n+            ParameterName = \"a\",\n+            DataTypeName = rangeType\n+        });\n+\n+        Assert.ThrowsAsync<OverflowException>(async () => await cmd.ExecuteNonQueryAsync());\n+    }\n+\n+    [Test]\n+    public async Task Multirange_overflow_message_length_throws()\n+    {\n+        await using var adminConnection = await OpenConnectionAsync();\n+        var type = await GetTempTypeName(adminConnection);\n+        var rangeType = await GetTempTypeName(adminConnection);\n+\n+        await adminConnection.ExecuteNonQueryAsync(\n+            $\"CREATE TYPE {type} AS (a text, b text, c text, d text, e text, f text, g text, h text);CREATE TYPE {rangeType} AS RANGE(subtype={type})\");\n+\n+        var dataSourceBuilder = CreateDataSourceBuilder();\n+        dataSourceBuilder.MapComposite<BigComposite>(type);\n+        dataSourceBuilder.EnableUnmappedTypes();\n+        await using var dataSource = dataSourceBuilder.Build();\n+        await using var connection = await dataSource.OpenConnectionAsync();\n+\n+        var largeString = new string('A', (1 << 28) + 2000000);\n+\n+        await using var cmd = connection.CreateCommand();\n+        cmd.CommandText = \"SELECT @a\";\n+        var composite = new BigComposite\n+        {\n+            A = largeString\n+        };\n+        var range = new NpgsqlRange<BigComposite>(composite, composite);\n+        var multirange = new[]\n+        {\n+            range,\n+            range,\n+            range,\n+            range\n+        };\n+        cmd.Parameters.Add(new NpgsqlParameter\n+        {\n+            Value = multirange,\n+            ParameterName = \"a\",\n+            DataTypeName = rangeType + \"_multirange\"\n+        });\n+\n+        Assert.ThrowsAsync<OverflowException>(async () => await cmd.ExecuteNonQueryAsync());\n+    }\n+\n     [Test, Description(\"CreateCommand before connection open\")]\n     [IssueLink(\"https://github.com/npgsql/npgsql/issues/565\")]\n     public async Task Create_command_before_connection_open()\n@@ -1027,6 +1197,7 @@ public async Task Too_many_parameters_throws([Values(PrepareOrNot.NotPrepared, P\n             sb.Append('@');\n             sb.Append(paramName);\n         }\n+\n         cmd.CommandText = sb.ToString();\n \n         if (prepare == PrepareOrNot.Prepared)"
        },
        {
          "filename": "test/Npgsql.Tests/Support/PgPostmasterMock.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -138,6 +138,7 @@ async Task<ServerOrCancellationRequest> Accept(bool completeCancellationImmediat\n         var readBuffer = new NpgsqlReadBuffer(null!, stream, clientSocket, ReadBufferSize, Encoding,\n             RelaxedEncoding);\n         var writeBuffer = new NpgsqlWriteBuffer(null!, stream, clientSocket, WriteBufferSize, Encoding);\n+        writeBuffer.MessageLengthValidation = false;\n \n         await readBuffer.EnsureAsync(4);\n         var len = readBuffer.ReadInt32();"
        },
        {
          "filename": "test/Npgsql.Tests/Support/PgServerMock.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -41,6 +41,7 @@ internal PgServerMock(\n         _stream = stream;\n         _readBuffer = readBuffer;\n         _writeBuffer = writeBuffer;\n+        writeBuffer.MessageLengthValidation = false;\n     }\n \n     internal async Task Startup(MockState state)"
        },
        {
          "filename": "test/Npgsql.Tests/WriteBufferTests.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -113,6 +113,7 @@ public void SetUp()\n     {\n         Underlying = new MemoryStream();\n         WriteBuffer = new NpgsqlWriteBuffer(null, Underlying, null, NpgsqlReadBuffer.DefaultSize, NpgsqlWriteBuffer.UTF8Encoding);\n+        WriteBuffer.MessageLengthValidation = false;\n     }\n #pragma warning restore CS8625\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "010dc51ae61f9ca71d30ced4d025e87db4b7c17b",
            "date": "2024-12-28T14:53:33Z",
            "author_login": "bbowyersmyth"
          },
          {
            "sha": "523033601b8fd6e9b8642938929e025624884349",
            "date": "2024-12-28T03:10:53Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "62dcf217551b263a8fa21bb1336dc3cd57114360",
            "date": "2024-12-17T12:06:59Z",
            "author_login": "vonzshik"
          },
          {
            "sha": "2b013ed5216c49ed4257c6bee5a994885a1bd66f",
            "date": "2024-11-20T17:29:31Z",
            "author_login": "vonzshik"
          },
          {
            "sha": "a1f1022a7103e069c48c3450e45d19a642d6995c",
            "date": "2024-11-20T16:28:27Z",
            "author_login": "roji"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-89",
    "description": "Npgsql is the .NET data provider for PostgreSQL. The `WriteBind()` method in `src/Npgsql/Internal/NpgsqlConnector.FrontendMessages.cs` uses `int` variables to store the message length and the sum of parameter lengths. Both variables overflow when the sum of parameter lengths becomes too large. This causes Npgsql to write a message size that is too small when constructing a Postgres protocol message to send it over the network to the database. When parsing the message, the database will only read a small number of bytes and treat any following bytes as new messages while they belong to the old message. Attackers can abuse this to inject arbitrary Postgres protocol messages into the connection, leading to the execution of arbitrary SQL statements on the application's behalf. This vulnerability is fixed in 4.0.14, 4.1.13, 5.0.18, 6.0.11, 7.0.7, and 8.0.3.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-05-14T15:36:51.087",
    "last_modified": "2024-12-12T21:15:08.060",
    "fix_date": "2024-05-09T11:20:07Z"
  },
  "references": [
    {
      "url": "https://github.com/npgsql/npgsql/commit/091655eed0c84e502ab424950c930339d17c1928",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/3183efb2bdcca159c8c2e22af57e18ea8f853cf0",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/67acbe027e28477ac2199e15cfb554bb2ffaf169",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/703d9af8fa48dfe8c0180e36edb8278f34342d7b",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/a22a42d8141d7a3528f43c02c095a409507cf1af",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/e34e2ba8042e666d9af54a1b255fba4d5b11df56",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/f7e7ead0702d776a8f551f5786c4cac2d65c4bc6",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v4.0.14",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v4.1.13",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v5.0.18",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v6.0.11",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v7.0.7",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v8.0.3",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/security/advisories/GHSA-x9vc-6hfv-hg8c",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.youtube.com/watch?v=Tfg1B8u1yvE",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/091655eed0c84e502ab424950c930339d17c1928",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/3183efb2bdcca159c8c2e22af57e18ea8f853cf0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/67acbe027e28477ac2199e15cfb554bb2ffaf169",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/703d9af8fa48dfe8c0180e36edb8278f34342d7b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/a22a42d8141d7a3528f43c02c095a409507cf1af",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/e34e2ba8042e666d9af54a1b255fba4d5b11df56",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/commit/f7e7ead0702d776a8f551f5786c4cac2d65c4bc6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v4.0.14",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v4.1.13",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v5.0.18",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v6.0.11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v7.0.7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/releases/tag/v8.0.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/npgsql/npgsql/security/advisories/GHSA-x9vc-6hfv-hg8c",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.888187",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "npgsql",
    "owner": "npgsql",
    "created_at": "2011-11-30T14:13:32Z",
    "updated_at": "2025-01-25T10:01:26Z",
    "pushed_at": "2025-01-14T13:44:41Z",
    "size": 66223,
    "stars": 3390,
    "forks": 826,
    "open_issues": 275,
    "watchers": 3390,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "hotfix/4.0.17",
      "hotfix/8.0.6",
      "hotfix/9.0.3",
      "main"
    ],
    "languages": {
      "C#": 4104635,
      "Shell": 1147,
      "Python": 480,
      "Dockerfile": 353
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "postgresql"
    },
    "collected_at": "2025-01-26T07:48:31.902151"
  }
}