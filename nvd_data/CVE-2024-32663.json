{
  "cve_id": "CVE-2024-32663",
  "github_data": {
    "repository": "OISF/suricata",
    "fix_commit": "08d93f7c3762781b743f88f9fdc4389eb9c3eb64",
    "related_commits": [
      "08d93f7c3762781b743f88f9fdc4389eb9c3eb64",
      "c0af92295e833d1db29b184d63cd3b829451d7fd",
      "d24b37a103c04bb2667e449e080ba4c8e56bb019",
      "e68ec4b227d19498f364a41eb25d3182f0383ca5",
      "08d93f7c3762781b743f88f9fdc4389eb9c3eb64",
      "c0af92295e833d1db29b184d63cd3b829451d7fd",
      "d24b37a103c04bb2667e449e080ba4c8e56bb019",
      "e68ec4b227d19498f364a41eb25d3182f0383ca5"
    ],
    "patch_url": "https://github.com/OISF/suricata/commit/08d93f7c3762781b743f88f9fdc4389eb9c3eb64.patch",
    "fix_commit_details": {
      "sha": "08d93f7c3762781b743f88f9fdc4389eb9c3eb64",
      "commit_date": "2024-03-27T13:33:54Z",
      "author": {
        "login": "catenacyber",
        "type": "User",
        "stats": {
          "total_commits": 1048,
          "average_weekly_commits": 1.2186046511627906,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 238
        }
      },
      "commit_message": {
        "title": "http2: use a reference counter for headers",
        "length": 525,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 80,
        "additions": 42,
        "deletions": 38
      },
      "files": [
        {
          "filename": "rust/src/http2/detect.rs",
          "status": "modified",
          "additions": 9,
          "deletions": 8,
          "patch": "@@ -23,6 +23,7 @@ use crate::core::{STREAM_TOCLIENT, STREAM_TOSERVER};\n use std::ffi::CStr;\n use std::mem::transmute;\n use std::str::FromStr;\n+use std::rc::Rc;\n \n fn http2_tx_has_frametype(\n     tx: &mut HTTP2Transaction, direction: u8, value: u8,\n@@ -489,7 +490,7 @@ fn http2_frames_get_header_firstvalue<'a>(\n     for i in 0..frames.len() {\n         if let Some(blocks) = http2_header_blocks(&frames[i]) {\n             for block in blocks.iter() {\n-                if block.name == name.as_bytes() {\n+                if block.name.as_ref() == name.as_bytes() {\n                     return Ok(&block.value);\n                 }\n             }\n@@ -512,7 +513,7 @@ fn http2_frames_get_header_value<'a>(\n     for i in 0..frames.len() {\n         if let Some(blocks) = http2_header_blocks(&frames[i]) {\n             for block in blocks.iter() {\n-                if block.name == name.as_bytes() {\n+                if block.name.as_ref() == name.as_bytes() {\n                     if found == 0 {\n                         single = Ok(&block.value);\n                         found = 1;\n@@ -899,8 +900,8 @@ fn http2_tx_set_header(state: &mut HTTP2State, name: &[u8], input: &[u8]) {\n     };\n     let mut blocks = Vec::new();\n     let b = parser::HTTP2FrameHeaderBlock {\n-        name: name.to_vec(),\n-        value: input.to_vec(),\n+        name: Rc::new(name.to_vec()),\n+        value: Rc::new(input.to_vec()),\n         error: parser::HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess,\n         sizeupdate: 0,\n     };\n@@ -1153,15 +1154,15 @@ mod tests {\n         };\n         let mut blocks = Vec::new();\n         let b = parser::HTTP2FrameHeaderBlock {\n-            name: \"Host\".as_bytes().to_vec(),\n-            value: \"abc.com\".as_bytes().to_vec(),\n+            name: \"Host\".as_bytes().to_vec().into(),\n+            value: \"abc.com\".as_bytes().to_vec().into(),\n             error: parser::HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess,\n             sizeupdate: 0,\n         };\n         blocks.push(b);\n         let b2 = parser::HTTP2FrameHeaderBlock {\n-            name: \"Host\".as_bytes().to_vec(),\n-            value: \"efg.net\".as_bytes().to_vec(),\n+            name: \"Host\".as_bytes().to_vec().into(),\n+            value: \"efg.net\".as_bytes().to_vec().into(),\n             error: parser::HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess,\n             sizeupdate: 0,\n         };"
        },
        {
          "filename": "rust/src/http2/http2.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -190,7 +190,7 @@ impl HTTP2Transaction {\n         let mut authority = None;\n         let mut host = None;\n         for block in blocks {\n-            if block.name == b\"content-encoding\" {\n+            if block.name.as_ref() == b\"content-encoding\" {\n                 #[cfg(feature = \"decompression\")]\n                 self.decoder.http2_encoding_fromvec(&block.value, _dir);\n             } else if block.name.eq_ignore_ascii_case(b\":authority\") {"
        },
        {
          "filename": "rust/src/http2/parser.rs",
          "status": "modified",
          "additions": 32,
          "deletions": 29,
          "patch": "@@ -25,6 +25,7 @@ use nom::Err;\n use nom::IResult;\n use std::fmt;\n use std::str::FromStr;\n+use std::rc::Rc;\n \n #[repr(u8)]\n #[derive(Clone, Copy, PartialEq, FromPrimitive, Debug)]\n@@ -281,32 +282,32 @@ fn http2_frame_header_static(n: u64, dyn_headers: &HTTP2DynTable) -> Option<HTTP\n     };\n     if name.len() > 0 {\n         return Some(HTTP2FrameHeaderBlock {\n-            name: name.as_bytes().to_vec(),\n-            value: value.as_bytes().to_vec(),\n+            name: Rc::new(name.as_bytes().to_vec()),\n+            value: Rc::new(value.as_bytes().to_vec()),\n             error: HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess,\n             sizeupdate: 0,\n         });\n     } else {\n         //use dynamic table\n         if n == 0 {\n             return Some(HTTP2FrameHeaderBlock {\n-                name: Vec::new(),\n-                value: Vec::new(),\n+                name: Rc::new(Vec::new()),\n+                value: Rc::new(Vec::new()),\n                 error: HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeIndex0,\n                 sizeupdate: 0,\n             });\n         } else if dyn_headers.table.len() + HTTP2_STATIC_HEADERS_NUMBER < n as usize {\n             return Some(HTTP2FrameHeaderBlock {\n-                name: Vec::new(),\n-                value: Vec::new(),\n+                name: Rc::new(Vec::new()),\n+                value: Rc::new(Vec::new()),\n                 error: HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeNotIndexed,\n                 sizeupdate: 0,\n             });\n         } else {\n             let indyn = dyn_headers.table.len() - (n as usize - HTTP2_STATIC_HEADERS_NUMBER);\n             let headcopy = HTTP2FrameHeaderBlock {\n-                name: dyn_headers.table[indyn].name.to_vec(),\n-                value: dyn_headers.table[indyn].value.to_vec(),\n+                name: dyn_headers.table[indyn].name.clone(),\n+                value: dyn_headers.table[indyn].value.clone(),\n                 error: HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess,\n                 sizeupdate: 0,\n             };\n@@ -334,8 +335,10 @@ impl fmt::Display for HTTP2HeaderDecodeStatus {\n \n #[derive(Clone, Debug)]\n pub struct HTTP2FrameHeaderBlock {\n-    pub name: Vec<u8>,\n-    pub value: Vec<u8>,\n+    // Use Rc reference counted so that indexed headers do not get copied.\n+    // Otherwise, this leads to quadratic complexity in memory occupation.\n+    pub name: Rc<Vec<u8>>,\n+    pub value: Rc<Vec<u8>>,\n     pub error: HTTP2HeaderDecodeStatus,\n     pub sizeupdate: u64,\n }\n@@ -386,7 +389,7 @@ fn http2_parse_headers_block_literal_common<'a>(\n ) -> IResult<&'a [u8], HTTP2FrameHeaderBlock> {\n     let (i3, name, error) = if index == 0 {\n         match http2_parse_headers_block_string(input) {\n-            Ok((r, n)) => Ok((r, n, HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess)),\n+            Ok((r, n)) => Ok((r, Rc::new(n), HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSuccess)),\n             Err(e) => Err(e),\n         }\n     } else {\n@@ -398,7 +401,7 @@ fn http2_parse_headers_block_literal_common<'a>(\n             )),\n             None => Ok((\n                 input,\n-                Vec::new(),\n+                Rc::new(Vec::new()),\n                 HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeNotIndexed,\n             )),\n         }\n@@ -408,7 +411,7 @@ fn http2_parse_headers_block_literal_common<'a>(\n         i4,\n         HTTP2FrameHeaderBlock {\n             name,\n-            value,\n+            value: Rc::new(value),\n             error,\n             sizeupdate: 0,\n         },\n@@ -436,8 +439,8 @@ fn http2_parse_headers_block_literal_incindex<'a>(\n     match r {\n         Ok((r, head)) => {\n             let headcopy = HTTP2FrameHeaderBlock {\n-                name: head.name.to_vec(),\n-                value: head.value.to_vec(),\n+                name: head.name.clone(),\n+                value: head.value.clone(),\n                 error: head.error,\n                 sizeupdate: 0,\n             };\n@@ -557,8 +560,8 @@ fn http2_parse_headers_block_dynamic_size<'a>(\n         return Ok((\n             i3,\n             HTTP2FrameHeaderBlock {\n-                name: Vec::new(),\n-                value: Vec::new(),\n+                name: Vec::new().into(),\n+                value: Vec::new().into(),\n                 error: HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeIntegerOverflow,\n                 sizeupdate: 0,\n             },\n@@ -581,8 +584,8 @@ fn http2_parse_headers_block_dynamic_size<'a>(\n     return Ok((\n         i3,\n         HTTP2FrameHeaderBlock {\n-            name: Vec::new(),\n-            value: Vec::new(),\n+            name: Rc::new(Vec::new()),\n+            value: Rc::new(Vec::new()),\n             error: HTTP2HeaderDecodeStatus::HTTP2HeaderDecodeSizeUpdate,\n             sizeupdate: maxsize2,\n         },\n@@ -936,8 +939,8 @@ mod tests {\n         match r0 {\n             Ok((remainder, hd)) => {\n                 // Check the first message.\n-                assert_eq!(hd.name, \":method\".as_bytes().to_vec());\n-                assert_eq!(hd.value, \"GET\".as_bytes().to_vec());\n+                assert_eq!(hd.name, \":method\".as_bytes().to_vec().into());\n+                assert_eq!(hd.value, \"GET\".as_bytes().to_vec().into());\n                 // And we should have no bytes left.\n                 assert_eq!(remainder.len(), 0);\n             }\n@@ -953,8 +956,8 @@ mod tests {\n         match r1 {\n             Ok((remainder, hd)) => {\n                 // Check the first message.\n-                assert_eq!(hd.name, \"accept\".as_bytes().to_vec());\n-                assert_eq!(hd.value, \"*/*\".as_bytes().to_vec());\n+                assert_eq!(hd.name, \"accept\".as_bytes().to_vec().into());\n+                assert_eq!(hd.value, \"*/*\".as_bytes().to_vec().into());\n                 // And we should have no bytes left.\n                 assert_eq!(remainder.len(), 0);\n                 assert_eq!(dynh.table.len(), 1);\n@@ -973,8 +976,8 @@ mod tests {\n         match result {\n             Ok((remainder, hd)) => {\n                 // Check the first message.\n-                assert_eq!(hd.name, \":authority\".as_bytes().to_vec());\n-                assert_eq!(hd.value, \"localhost:3000\".as_bytes().to_vec());\n+                assert_eq!(hd.name, \":authority\".as_bytes().to_vec().into());\n+                assert_eq!(hd.value, \"localhost:3000\".as_bytes().to_vec().into());\n                 // And we should have no bytes left.\n                 assert_eq!(remainder.len(), 0);\n                 assert_eq!(dynh.table.len(), 2);\n@@ -991,8 +994,8 @@ mod tests {\n         match r3 {\n             Ok((remainder, hd)) => {\n                 // same as before\n-                assert_eq!(hd.name, \":authority\".as_bytes().to_vec());\n-                assert_eq!(hd.value, \"localhost:3000\".as_bytes().to_vec());\n+                assert_eq!(hd.name, \":authority\".as_bytes().to_vec().into());\n+                assert_eq!(hd.value, \"localhost:3000\".as_bytes().to_vec().into());\n                 // And we should have no bytes left.\n                 assert_eq!(remainder.len(), 0);\n                 assert_eq!(dynh.table.len(), 2);\n@@ -1027,8 +1030,8 @@ mod tests {\n         match r2 {\n             Ok((remainder, hd)) => {\n                 // Check the first message.\n-                assert_eq!(hd.name, \":path\".as_bytes().to_vec());\n-                assert_eq!(hd.value, \"/doc/manual/html/index.html\".as_bytes().to_vec());\n+                assert_eq!(hd.name, \":path\".as_bytes().to_vec().into());\n+                assert_eq!(hd.value, \"/doc/manual/html/index.html\".as_bytes().to_vec().into());\n                 // And we should have no bytes left.\n                 assert_eq!(remainder.len(), 0);\n                 assert_eq!(dynh.table.len(), 2);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "637708acb476cdae526b870e4301e22197da1869",
            "date": "2025-01-13T12:39:21Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "a92212d6e504b535c63ce8d234bf4804c7b8dcca",
            "date": "2025-01-10T16:27:55Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "eab212b0be760daa2689bcb6e2d05c12fd708682",
            "date": "2025-01-10T15:57:51Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "ae1a4ef757583e4307d3322130f893db4b716a59",
            "date": "2024-11-11T06:26:11Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "e6be049c5dc2859a833fc21321bc7bfd15be2904",
            "date": "2024-11-11T06:21:03Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to 7.0.5 and 6.0.19, a small amount of HTTP/2 traffic can lead to Suricata using a large amount of memory. The issue has been addressed in Suricata 7.0.5 and 6.0.19. Workarounds include disabling the HTTP/2 parser and reducing `app-layer.protocols.http2.max-table-size` value (default is 65536).",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-07T15:15:08.713",
    "last_modified": "2024-12-19T19:40:02.880",
    "fix_date": "2024-03-27T13:33:54Z"
  },
  "references": [
    {
      "url": "https://github.com/OISF/suricata/commit/08d93f7c3762781b743f88f9fdc4389eb9c3eb64",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/c0af92295e833d1db29b184d63cd3b829451d7fd",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/d24b37a103c04bb2667e449e080ba4c8e56bb019",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/e68ec4b227d19498f364a41eb25d3182f0383ca5",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-9jxm-qw9v-266r",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6892",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6900",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/08d93f7c3762781b743f88f9fdc4389eb9c3eb64",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/c0af92295e833d1db29b184d63cd3b829451d7fd",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/d24b37a103c04bb2667e449e080ba4c8e56bb019",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/e68ec4b227d19498f364a41eb25d3182f0383ca5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-9jxm-qw9v-266r",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6892",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6900",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.870038",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "OISF",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-14T12:53:46Z",
    "pushed_at": "2025-01-14T06:40:06Z",
    "size": 74648,
    "stars": 4847,
    "forks": 1483,
    "open_issues": 74,
    "watchers": 4847,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 13993560,
      "Rust": 3470702,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45461,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1056,
      "avg_commits_per_week": 20.307692307692307,
      "days_active_last_year": 254
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:41:46.043023"
  }
}