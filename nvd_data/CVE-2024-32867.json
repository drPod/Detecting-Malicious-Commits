{
  "cve_id": "CVE-2024-32867",
  "github_data": {
    "repository": "OISF/suricata",
    "fix_commit": "1e110d0a71db46571040b937e17a4bc9f91d6de9",
    "related_commits": [
      "1e110d0a71db46571040b937e17a4bc9f91d6de9",
      "2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
      "414f97c6695c5a2e1d378a36a6f50d7288767634",
      "bf3d420fb709ebe074019a99e3bd3a2364524a4b",
      "d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
      "e6267758ed5da27f804f0c1c07f9423bdf4d72b8",
      "1e110d0a71db46571040b937e17a4bc9f91d6de9",
      "2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
      "414f97c6695c5a2e1d378a36a6f50d7288767634",
      "bf3d420fb709ebe074019a99e3bd3a2364524a4b",
      "d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
      "e6267758ed5da27f804f0c1c07f9423bdf4d72b8"
    ],
    "patch_url": "https://github.com/OISF/suricata/commit/1e110d0a71db46571040b937e17a4bc9f91d6de9.patch",
    "fix_commit_details": {
      "sha": "1e110d0a71db46571040b937e17a4bc9f91d6de9",
      "commit_date": "2023-12-07T22:44:56Z",
      "author": {
        "login": "jasonish",
        "type": "User",
        "stats": {
          "total_commits": 1524,
          "average_weekly_commits": 1.7720930232558139,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 330
        }
      },
      "commit_message": {
        "title": "defrag: fix subsequent overlap of start of original (bsd)",
        "length": 530,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 387,
        "additions": 380,
        "deletions": 7
      },
      "files": [
        {
          "filename": "src/defrag.c",
          "status": "modified",
          "additions": 380,
          "deletions": 7,
          "patch": "@@ -674,16 +674,45 @@ DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker,\n             switch (tracker->policy) {\n             case DEFRAG_POLICY_BSD:\n                 if (frag_offset < prev->offset + prev->data_len) {\n-                    if (frag_offset >= prev->offset) {\n-                        ltrim = prev->offset + prev->data_len - frag_offset;\n+                    if (prev->offset <= frag_offset) {\n+                        /* We prefer the data from the previous\n+                         * fragment, so trim off the data in the new\n+                         * fragment that exists in the previous\n+                         * fragment. */\n+                        uint16_t prev_end = prev->offset + prev->data_len;\n+                        if (prev_end > frag_end) {\n+                            /* Just skip. */\n+                            /* TODO: Set overlap flag. */\n+                            goto done;\n+                        }\n+                        ltrim = prev_end - frag_offset;\n+\n+                        if ((next != NULL) && (frag_end > next->offset)) {\n+                            next->ltrim = frag_end - next->offset;\n+                        }\n+\n+                        goto insert;\n                     }\n+\n+                    /* If the end of this fragment overlaps the start\n+                     * of the previous fragment, then trim up the\n+                     * start of previous fragment so this fragment is\n+                     * used.\n+                     *\n+                     * See:\n+                     * DefragBsdSubsequentOverlapsStartOfOriginal.\n+                     */\n+                    if (frag_offset <= prev->offset && frag_end > prev->offset + prev->ltrim) {\n+                        uint16_t prev_ltrim = frag_end - prev->offset;\n+                        if (prev_ltrim > prev->ltrim) {\n+                            prev->ltrim = prev_ltrim;\n+                        }\n+                    }\n+\n                     if ((next != NULL) && (frag_end > next->offset)) {\n                         next->ltrim = frag_end - next->offset;\n                     }\n-                    if ((frag_offset < prev->offset) &&\n-                        (frag_end >= prev->offset + prev->data_len)) {\n-                        prev->skip = 1;\n-                    }\n+\n                     goto insert;\n                 }\n                 break;\n@@ -1184,6 +1213,77 @@ static Packet *BuildIpv4TestPacket(\n     return NULL;\n }\n \n+/**\n+ * Allocate a test packet, much like BuildIpv4TestPacket, but with\n+ * the full content provided by the caller.\n+ */\n+static Packet *BuildIpv4TestPacketWithContent(\n+        uint8_t proto, uint16_t id, uint16_t off, int mf, const uint8_t *content, int content_len)\n+{\n+    Packet *p = NULL;\n+    int hlen = 20;\n+    int ttl = 64;\n+    IPV4Hdr ip4h;\n+\n+    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n+    if (unlikely(p == NULL))\n+        return NULL;\n+\n+    PacketInit(p);\n+\n+    struct timeval tval;\n+    gettimeofday(&tval, NULL);\n+    p->ts = SCTIME_FROM_TIMEVAL(&tval);\n+    ip4h.ip_verhl = 4 << 4;\n+    ip4h.ip_verhl |= hlen >> 2;\n+    ip4h.ip_len = htons(hlen + content_len);\n+    ip4h.ip_id = htons(id);\n+    if (mf)\n+        ip4h.ip_off = htons(IP_MF | off);\n+    else\n+        ip4h.ip_off = htons(off);\n+    ip4h.ip_ttl = ttl;\n+    ip4h.ip_proto = proto;\n+\n+    ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n+    ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n+\n+    /* copy content_len crap, we need full length */\n+    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));\n+    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);\n+    SET_IPV4_SRC_ADDR(p, &p->src);\n+    SET_IPV4_DST_ADDR(p, &p->dst);\n+\n+    PacketCopyDataOffset(p, hlen, content, content_len);\n+    SET_PKT_LEN(p, hlen + content_len);\n+\n+    p->ip4h->ip_csum = IPV4Checksum((uint16_t *)GET_PKT_DATA(p), hlen, 0);\n+\n+    /* Self test. */\n+    if (IPV4_GET_VER(p) != 4)\n+        goto error;\n+    if (IPV4_GET_HLEN(p) != hlen)\n+        goto error;\n+    if (IPV4_GET_IPLEN(p) != hlen + content_len)\n+        goto error;\n+    if (IPV4_GET_IPID(p) != id)\n+        goto error;\n+    if (IPV4_GET_IPOFFSET(p) != off)\n+        goto error;\n+    if (IPV4_GET_MF(p) != mf)\n+        goto error;\n+    if (IPV4_GET_IPTTL(p) != ttl)\n+        goto error;\n+    if (IPV4_GET_IPPROTO(p) != proto)\n+        goto error;\n+\n+    return p;\n+error:\n+    if (p != NULL)\n+        SCFree(p);\n+    return NULL;\n+}\n+\n static Packet *BuildIpv6TestPacket(\n         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t content, int content_len)\n {\n@@ -1255,6 +1355,71 @@ static Packet *BuildIpv6TestPacket(\n     return NULL;\n }\n \n+static Packet *BuildIpv6TestPacketWithContent(\n+        uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t *content, int content_len)\n+{\n+    Packet *p = NULL;\n+    IPV6Hdr ip6h;\n+\n+    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n+    if (unlikely(p == NULL))\n+        return NULL;\n+\n+    PacketInit(p);\n+\n+    struct timeval tval;\n+    gettimeofday(&tval, NULL);\n+    p->ts = SCTIME_FROM_TIMEVAL(&tval);\n+\n+    ip6h.s_ip6_nxt = 44;\n+    ip6h.s_ip6_hlim = 2;\n+\n+    /* Source and dest address - very bogus addresses. */\n+    ip6h.s_ip6_src[0] = 0x01010101;\n+    ip6h.s_ip6_src[1] = 0x01010101;\n+    ip6h.s_ip6_src[2] = 0x01010101;\n+    ip6h.s_ip6_src[3] = 0x01010101;\n+    ip6h.s_ip6_dst[0] = 0x02020202;\n+    ip6h.s_ip6_dst[1] = 0x02020202;\n+    ip6h.s_ip6_dst[2] = 0x02020202;\n+    ip6h.s_ip6_dst[3] = 0x02020202;\n+\n+    /* copy content_len crap, we need full length */\n+    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));\n+\n+    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);\n+    IPV6_SET_RAW_VER(p->ip6h, 6);\n+    /* Fragmentation header. */\n+    IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n+    fh->ip6fh_nxt = proto;\n+    fh->ip6fh_ident = htonl(id);\n+    fh->ip6fh_offlg = htons((off << 3) | mf);\n+\n+    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);\n+\n+    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), content, content_len);\n+    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);\n+\n+    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);\n+\n+    SET_IPV6_SRC_ADDR(p, &p->src);\n+    SET_IPV6_DST_ADDR(p, &p->dst);\n+\n+    /* Self test. */\n+    if (IPV6_GET_VER(p) != 6)\n+        goto error;\n+    if (IPV6_GET_NH(p) != 44)\n+        goto error;\n+    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)\n+        goto error;\n+\n+    return p;\n+error:\n+    if (p != NULL)\n+        SCFree(p);\n+    return NULL;\n+}\n+\n /**\n  * Test the simplest possible re-assembly scenario.  All packet in\n  * order and no overlaps.\n@@ -1560,7 +1725,13 @@ static int DefragDoSturgesNovakTest(int policy, uint8_t *expected, size_t expect\n     FAIL_IF(IPV4_GET_IPLEN(reassembled) != 20 + 192);\n     FAIL_IF(expected_len != 192);\n \n-    FAIL_IF(memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0);\n+    if (memcmp(expected, GET_PKT_DATA(reassembled) + 20, expected_len) != 0) {\n+        printf(\"Expected:\\n\");\n+        PrintRawDataFp(stdout, expected, expected_len);\n+        printf(\"Got:\\n\");\n+        PrintRawDataFp(stdout, GET_PKT_DATA(reassembled) + 20, GET_PKT_LEN(reassembled) - 20);\n+        FAIL;\n+    }\n     SCFree(reassembled);\n \n     /* Make sure all frags were returned back to the pool. */\n@@ -2554,6 +2725,16 @@ static int DefragTestJeremyLinux(void)\n     PASS;\n }\n \n+/**\n+ * | 0        | 8        | 16       | 24       | 32       |\n+ * |----------|----------|----------|----------|----------|\n+ * |                                  AAAAAAAA | AAAAAAAA |\n+ * |          | BBBBBBBB | BBBBBBBB |          |          |\n+ * |          |          | CCCCCCCC | CCCCCCCC |          |\n+ * | DDDDDDDD |          |          |          |          |\n+ *\n+ * | DDDDDDDD | BBBBBBBB | BBBBBBBB | CCCCCCCC | AAAAAAAA |\n+ */\n static int DefragBsdFragmentAfterNoMfIpv4Test(void)\n {\n     DefragInit();\n@@ -2644,6 +2825,192 @@ static int DefragBsdFragmentAfterNoMfIpv6Test(void)\n     PASS;\n }\n \n+static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2(void)\n+{\n+    DefragInit();\n+    default_policy = DEFRAG_POLICY_BSD;\n+    Packet *packets[4];\n+\n+    /* Packet 1: off=16, mf=1 */\n+    packets[0] = BuildIpv4TestPacketWithContent(\n+            IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n+\n+    /* Packet 2: off=8, mf=1 */\n+    packets[1] = BuildIpv4TestPacketWithContent(\n+            IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);\n+\n+    /* Packet 3: off=0, mf=1: IP and ICMP header. */\n+    packets[2] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n+\n+    /* Packet 4: off=8, mf=1 */\n+    packets[3] =\n+            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n+\n+    Packet *r = Defrag(NULL, NULL, packets[0]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[1]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[2]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[3]);\n+    FAIL_IF_NULL(r);\n+\n+    // clang-format off\n+    const uint8_t expected[] = {\n+\t// AACCBBDD\n+\t// AACCDDBB\n+\t// AABBDDCC\n+\t// DDCCBBAA\n+\t'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',\n+\t'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',\n+\t'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',\n+\t'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',\n+    };\n+    // clang-format on\n+\n+    FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 20 + 8, sizeof(expected)) != 0);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n+static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2(void)\n+{\n+    DefragInit();\n+    default_policy = DEFRAG_POLICY_BSD;\n+    Packet *packets[4];\n+\n+    /* Packet 1: off=16, mf=1 */\n+    packets[0] = BuildIpv6TestPacketWithContent(\n+            IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n+\n+    /* Packet 2: off=8, mf=1 */\n+    packets[1] = BuildIpv6TestPacketWithContent(\n+            IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);\n+\n+    /* Packet 3: off=0, mf=1: IP and ICMP header. */\n+    packets[2] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n+\n+    /* Packet 4: off=8, mf=1 */\n+    packets[3] =\n+            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n+\n+    Packet *r = Defrag(NULL, NULL, packets[0]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[1]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[2]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[3]);\n+    FAIL_IF_NULL(r);\n+\n+    // clang-format off\n+    const uint8_t expected[] = {\n+\t// AACCBBDD\n+\t// AACCDDBB\n+\t// AABBDDCC\n+\t// DDCCBBAA\n+\t'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',\n+\t'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',\n+\t'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',\n+\t'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',\n+    };\n+    // clang-format on\n+\n+    FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 40 + 8, sizeof(expected)) != 0);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n+/**\n+ * #### Input\n+ *\n+ * | 96 (0)   | 104 (8)  | 112 (16) | 120 (24) |\n+ * |----------|----------|----------|----------|\n+ * |          | EEEEEEEE | EEEEEEEE | EEEEEEEE |\n+ * | MMMMMMMM | MMMMMMMM | MMMMMMMM |          |\n+ *\n+ * #### Expected Output\n+ *\n+ * | MMMMMMMM | MMMMMMMM | MMMMMMMM | EEEEEEEE |\n+ */\n+static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test(void)\n+{\n+    DefragInit();\n+    default_policy = DEFRAG_POLICY_BSD;\n+    Packet *packets[2];\n+\n+    packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);\n+    packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);\n+\n+    Packet *r = Defrag(NULL, NULL, packets[0]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[1]);\n+    FAIL_IF_NULL(r);\n+\n+    // clang-format off\n+    const uint8_t expected[] = {\n+\t'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',\n+\t'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',\n+\t'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',\n+\t'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',\n+    };\n+    // clang-format on\n+\n+    if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {\n+        printf(\"Expected:\\n\");\n+        PrintRawDataFp(stdout, expected, sizeof(expected));\n+        printf(\"Got:\\n\");\n+        PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n+        FAIL;\n+    }\n+\n+    PASS;\n+}\n+\n+static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test(void)\n+{\n+    DefragInit();\n+    default_policy = DEFRAG_POLICY_BSD;\n+    Packet *packets[2];\n+\n+    packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);\n+    packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);\n+\n+    Packet *r = Defrag(NULL, NULL, packets[0]);\n+    FAIL_IF_NOT_NULL(r);\n+\n+    r = Defrag(NULL, NULL, packets[1]);\n+    FAIL_IF_NULL(r);\n+\n+    // clang-format off\n+    const uint8_t expected[] = {\n+\t'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',\n+\t'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',\n+\t'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',\n+\t'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',\n+    };\n+    // clang-format on\n+\n+    if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {\n+        printf(\"Expected:\\n\");\n+        PrintRawDataFp(stdout, expected, sizeof(expected));\n+        printf(\"Got:\\n\");\n+        PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n+        FAIL;\n+    }\n+\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void DefragRegisterTests(void)\n@@ -2686,5 +3053,11 @@ void DefragRegisterTests(void)\n \n     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);\n     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);\n+    UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test\",\n+            DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test);\n+    UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test\",\n+            DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test);\n+    UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2\", DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);\n+    UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\", DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);\n #endif /* UNITTESTS */\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "078c6469a0cf44ebef934fa11e5f41de08e046be",
            "date": "2025-01-08T21:03:24Z",
            "author_login": "AkakiAlice"
          },
          {
            "sha": "b1c2643c87b0caeeccfd314842c6967119aa7d17",
            "date": "2024-11-07T20:46:33Z",
            "author_login": "AkakiAlice"
          },
          {
            "sha": "637708acb476cdae526b870e4301e22197da1869",
            "date": "2025-01-13T12:39:21Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "a92212d6e504b535c63ce8d234bf4804c7b8dcca",
            "date": "2025-01-10T16:27:55Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "eab212b0be760daa2689bcb6e2d05c12fd708682",
            "date": "2025-01-10T15:57:51Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-754",
    "description": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to 7.0.5 and 6.0.19, various problems in handling of fragmentation anomalies can lead to mis-detection of rules and policy. This vulnerability is fixed in 7.0.5 or 6.0.19.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-07T15:15:09.143",
    "last_modified": "2024-12-19T19:48:46.393",
    "fix_date": "2023-12-07T22:44:56Z"
  },
  "references": [
    {
      "url": "https://github.com/OISF/suricata/commit/1e110d0a71db46571040b937e17a4bc9f91d6de9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/414f97c6695c5a2e1d378a36a6f50d7288767634",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/bf3d420fb709ebe074019a99e3bd3a2364524a4b",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/e6267758ed5da27f804f0c1c07f9423bdf4d72b8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-xvrx-88mv-xcq5",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6672",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6673",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6677",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/1e110d0a71db46571040b937e17a4bc9f91d6de9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/2f39ba75f153ba9bdf8eedc2a839cc973dbaea66",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/414f97c6695c5a2e1d378a36a6f50d7288767634",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/bf3d420fb709ebe074019a99e3bd3a2364524a4b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/commit/e6267758ed5da27f804f0c1c07f9423bdf4d72b8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-xvrx-88mv-xcq5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6672",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6673",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/6677",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.870428",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "OISF",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-14T12:53:46Z",
    "pushed_at": "2025-01-14T06:40:06Z",
    "size": 74648,
    "stars": 4847,
    "forks": 1483,
    "open_issues": 74,
    "watchers": 4847,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 13993560,
      "Rust": 3470702,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45461,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1056,
      "avg_commits_per_week": 20.307692307692307,
      "days_active_last_year": 254
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:41:46.043023"
  }
}