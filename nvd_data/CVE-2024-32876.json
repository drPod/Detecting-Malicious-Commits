{
  "cve_id": "CVE-2024-32876",
  "github_data": {
    "repository": "TeamNewPipe/NewPipe",
    "fix_commit": "a69bbab73220f36e53c801cf7e9ea3627bb017eb",
    "related_commits": [
      "a69bbab73220f36e53c801cf7e9ea3627bb017eb",
      "a69bbab73220f36e53c801cf7e9ea3627bb017eb"
    ],
    "patch_url": "https://github.com/TeamNewPipe/NewPipe/commit/a69bbab73220f36e53c801cf7e9ea3627bb017eb.patch",
    "fix_commit_details": {
      "sha": "a69bbab73220f36e53c801cf7e9ea3627bb017eb",
      "commit_date": "2024-04-23T17:22:17Z",
      "author": {
        "login": "Stypox",
        "type": "User",
        "stats": {
          "total_commits": 1163,
          "average_weekly_commits": 2.3783231083844583,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 176
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-wxrm-jhpf-vp6v",
        "length": 81,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 909,
        "additions": 665,
        "deletions": 244
      },
      "files": [
        {
          "filename": "app/src/main/java/org/schabi/newpipe/error/UserAction.java",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -6,6 +6,7 @@\n public enum UserAction {\n     USER_REPORT(\"user report\"),\n     UI_ERROR(\"ui error\"),\n+    DATABASE_IMPORT_EXPORT(\"database import or export\"),\n     SUBSCRIPTION_CHANGE(\"subscription change\"),\n     SUBSCRIPTION_UPDATE(\"subscription update\"),\n     SUBSCRIPTION_GET(\"get subscription\"),"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/settings/BackupRestoreSettingsFragment.java",
          "status": "modified",
          "additions": 38,
          "deletions": 8,
          "patch": "@@ -21,9 +21,15 @@\n import androidx.preference.Preference;\n import androidx.preference.PreferenceManager;\n \n+import com.grack.nanojson.JsonParserException;\n+\n import org.schabi.newpipe.NewPipeDatabase;\n import org.schabi.newpipe.R;\n+import org.schabi.newpipe.error.ErrorInfo;\n import org.schabi.newpipe.error.ErrorUtil;\n+import org.schabi.newpipe.error.UserAction;\n+import org.schabi.newpipe.settings.export.BackupFileLocator;\n+import org.schabi.newpipe.settings.export.ImportExportManager;\n import org.schabi.newpipe.streams.io.NoFileManagerSafeGuard;\n import org.schabi.newpipe.streams.io.StoredFileHelper;\n import org.schabi.newpipe.util.NavigationHelper;\n@@ -42,7 +48,7 @@ public class BackupRestoreSettingsFragment extends BasePreferenceFragment {\n \n     private final SimpleDateFormat exportDateFormat =\n             new SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.US);\n-    private ContentSettingsManager manager;\n+    private ImportExportManager manager;\n     private String importExportDataPathKey;\n     private final ActivityResultLauncher<Intent> requestImportPathLauncher =\n             registerForActivityResult(new ActivityResultContracts.StartActivityForResult(),\n@@ -57,8 +63,7 @@ public void onCreatePreferences(@Nullable final Bundle savedInstanceState,\n                                     @Nullable final String rootKey) {\n         final File homeDir = ContextCompat.getDataDir(requireContext());\n         Objects.requireNonNull(homeDir);\n-        manager = new ContentSettingsManager(new NewPipeFileLocator(homeDir));\n-        manager.deleteSettingsFile();\n+        manager = new ImportExportManager(new BackupFileLocator(homeDir));\n \n         importExportDataPathKey = getString(R.string.import_export_data_path);\n \n@@ -165,7 +170,7 @@ private void exportDatabase(final StoredFileHelper file, final Uri exportDataUri\n             Toast.makeText(requireContext(), R.string.export_complete_toast, Toast.LENGTH_SHORT)\n                     .show();\n         } catch (final Exception e) {\n-            ErrorUtil.showUiErrorSnackbar(this, \"Exporting database\", e);\n+            showErrorSnackbar(e, \"Exporting database and settings\");\n         }\n     }\n \n@@ -182,16 +187,21 @@ private void importDatabase(final StoredFileHelper file, final Uri importDataUri\n                 throw new IOException(\"Could not create databases dir\");\n             }\n \n+            // replace the current database\n             if (!manager.extractDb(file)) {\n                 Toast.makeText(requireContext(), R.string.could_not_import_all_files,\n                                 Toast.LENGTH_LONG)\n                         .show();\n             }\n \n             // if settings file exist, ask if it should be imported.\n-            if (manager.extractSettings(file)) {\n+            final boolean hasJsonPrefs = manager.exportHasJsonPrefs(file);\n+            if (hasJsonPrefs || manager.exportHasSerializedPrefs(file)) {\n                 new androidx.appcompat.app.AlertDialog.Builder(requireContext())\n                         .setTitle(R.string.import_settings)\n+                        .setMessage(hasJsonPrefs ? null : requireContext()\n+                                .getString(R.string.import_settings_vulnerable_format))\n+                        .setOnDismissListener(dialog -> finishImport(importDataUri))\n                         .setNegativeButton(R.string.cancel, (dialog, which) -> {\n                             dialog.dismiss();\n                             finishImport(importDataUri);\n@@ -201,7 +211,16 @@ private void importDatabase(final StoredFileHelper file, final Uri importDataUri\n                             final Context context = requireContext();\n                             final SharedPreferences prefs = PreferenceManager\n                                     .getDefaultSharedPreferences(context);\n-                            manager.loadSharedPreferences(prefs);\n+                            try {\n+                                if (hasJsonPrefs) {\n+                                    manager.loadJsonPrefs(file, prefs);\n+                                } else {\n+                                    manager.loadSerializedPrefs(file, prefs);\n+                                }\n+                            } catch (IOException | ClassNotFoundException | JsonParserException e) {\n+                                createErrorNotification(e, \"Importing preferences\");\n+                                return;\n+                            }\n                             cleanImport(context, prefs);\n                             finishImport(importDataUri);\n                         })\n@@ -210,7 +229,7 @@ private void importDatabase(final StoredFileHelper file, final Uri importDataUri\n                 finishImport(importDataUri);\n             }\n         } catch (final Exception e) {\n-            ErrorUtil.showUiErrorSnackbar(this, \"Importing database\", e);\n+            showErrorSnackbar(e, \"Importing database and settings\");\n         }\n     }\n \n@@ -247,7 +266,7 @@ private void cleanImport(@NonNull final Context context,\n     }\n \n     /**\n-     * Save import path and restart system.\n+     * Save import path and restart app.\n      *\n      * @param importDataUri The import path to save\n      */\n@@ -268,4 +287,15 @@ private void saveLastImportExportDataUri(final Uri importExportDataUri) {\n                 .putString(importExportDataPathKey, importExportDataUri.toString());\n         editor.apply();\n     }\n+\n+    private void showErrorSnackbar(final Throwable e, final String request) {\n+        ErrorUtil.showSnackbar(this, new ErrorInfo(e, UserAction.DATABASE_IMPORT_EXPORT, request));\n+    }\n+\n+    private void createErrorNotification(final Throwable e, final String request) {\n+        ErrorUtil.createNotification(\n+                requireContext(),\n+                new ErrorInfo(e, UserAction.DATABASE_IMPORT_EXPORT, request)\n+        );\n+    }\n }"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/settings/ContentSettingsManager.kt",
          "status": "removed",
          "additions": 0,
          "deletions": 120,
          "patch": "@@ -1,120 +0,0 @@\n-package org.schabi.newpipe.settings\n-\n-import android.content.SharedPreferences\n-import android.util.Log\n-import org.schabi.newpipe.MainActivity.DEBUG\n-import org.schabi.newpipe.streams.io.SharpOutputStream\n-import org.schabi.newpipe.streams.io.StoredFileHelper\n-import org.schabi.newpipe.util.ZipHelper\n-import java.io.IOException\n-import java.io.ObjectInputStream\n-import java.io.ObjectOutputStream\n-import java.util.zip.ZipOutputStream\n-\n-class ContentSettingsManager(private val fileLocator: NewPipeFileLocator) {\n-    companion object {\n-        const val TAG = \"ContentSetManager\"\n-    }\n-\n-    /**\n-     * Exports given [SharedPreferences] to the file in given outputPath.\n-     * It also creates the file.\n-     */\n-    @Throws(Exception::class)\n-    fun exportDatabase(preferences: SharedPreferences, file: StoredFileHelper) {\n-        file.create()\n-        ZipOutputStream(SharpOutputStream(file.stream).buffered())\n-            .use { outZip ->\n-                ZipHelper.addFileToZip(outZip, fileLocator.db.path, \"newpipe.db\")\n-\n-                try {\n-                    ObjectOutputStream(fileLocator.settings.outputStream()).use { output ->\n-                        output.writeObject(preferences.all)\n-                        output.flush()\n-                    }\n-                } catch (e: IOException) {\n-                    if (DEBUG) {\n-                        Log.e(TAG, \"Unable to exportDatabase\", e)\n-                    }\n-                }\n-\n-                ZipHelper.addFileToZip(outZip, fileLocator.settings.path, \"newpipe.settings\")\n-            }\n-    }\n-\n-    fun deleteSettingsFile() {\n-        fileLocator.settings.delete()\n-    }\n-\n-    /**\n-     * Tries to create database directory if it does not exist.\n-     *\n-     * @return Whether the directory exists afterwards.\n-     */\n-    fun ensureDbDirectoryExists(): Boolean {\n-        return fileLocator.dbDir.exists() || fileLocator.dbDir.mkdir()\n-    }\n-\n-    fun extractDb(file: StoredFileHelper): Boolean {\n-        val success = ZipHelper.extractFileFromZip(file, fileLocator.db.path, \"newpipe.db\")\n-        if (success) {\n-            fileLocator.dbJournal.delete()\n-            fileLocator.dbWal.delete()\n-            fileLocator.dbShm.delete()\n-        }\n-\n-        return success\n-    }\n-\n-    fun extractSettings(file: StoredFileHelper): Boolean {\n-        return ZipHelper.extractFileFromZip(file, fileLocator.settings.path, \"newpipe.settings\")\n-    }\n-\n-    /**\n-     * Remove all shared preferences from the app and load the preferences supplied to the manager.\n-     */\n-    fun loadSharedPreferences(preferences: SharedPreferences) {\n-        try {\n-            val preferenceEditor = preferences.edit()\n-\n-            ObjectInputStream(fileLocator.settings.inputStream()).use { input ->\n-                preferenceEditor.clear()\n-                @Suppress(\"UNCHECKED_CAST\")\n-                val entries = input.readObject() as Map<String, *>\n-                for ((key, value) in entries) {\n-                    when (value) {\n-                        is Boolean -> {\n-                            preferenceEditor.putBoolean(key, value)\n-                        }\n-                        is Float -> {\n-                            preferenceEditor.putFloat(key, value)\n-                        }\n-                        is Int -> {\n-                            preferenceEditor.putInt(key, value)\n-                        }\n-                        is Long -> {\n-                            preferenceEditor.putLong(key, value)\n-                        }\n-                        is String -> {\n-                            preferenceEditor.putString(key, value)\n-                        }\n-                        is Set<*> -> {\n-                            // There are currently only Sets with type String possible\n-                            @Suppress(\"UNCHECKED_CAST\")\n-                            preferenceEditor.putStringSet(key, value as Set<String>?)\n-                        }\n-                    }\n-                }\n-                preferenceEditor.commit()\n-            }\n-        } catch (e: IOException) {\n-            if (DEBUG) {\n-                Log.e(TAG, \"Unable to loadSharedPreferences\", e)\n-            }\n-        } catch (e: ClassNotFoundException) {\n-            if (DEBUG) {\n-                Log.e(TAG, \"Unable to loadSharedPreferences\", e)\n-            }\n-        }\n-    }\n-}"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/settings/NewPipeFileLocator.kt",
          "status": "removed",
          "additions": 0,
          "deletions": 21,
          "patch": "@@ -1,21 +0,0 @@\n-package org.schabi.newpipe.settings\n-\n-import java.io.File\n-\n-/**\n- * Locates specific files of NewPipe based on the home directory of the app.\n- */\n-class NewPipeFileLocator(private val homeDir: File) {\n-\n-    val dbDir by lazy { File(homeDir, \"/databases\") }\n-\n-    val db by lazy { File(homeDir, \"/databases/newpipe.db\") }\n-\n-    val dbJournal by lazy { File(homeDir, \"/databases/newpipe.db-journal\") }\n-\n-    val dbShm by lazy { File(homeDir, \"/databases/newpipe.db-shm\") }\n-\n-    val dbWal by lazy { File(homeDir, \"/databases/newpipe.db-wal\") }\n-\n-    val settings by lazy { File(homeDir, \"/databases/newpipe.settings\") }\n-}"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/settings/export/BackupFileLocator.kt",
          "status": "added",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -0,0 +1,28 @@\n+package org.schabi.newpipe.settings.export\n+\n+import java.io.File\n+\n+/**\n+ * Locates specific files of NewPipe based on the home directory of the app.\n+ */\n+class BackupFileLocator(private val homeDir: File) {\n+    companion object {\n+        const val FILE_NAME_DB = \"newpipe.db\"\n+        @Deprecated(\n+            \"Serializing preferences with Java's ObjectOutputStream is vulnerable to injections\",\n+            replaceWith = ReplaceWith(\"FILE_NAME_JSON_PREFS\")\n+        )\n+        const val FILE_NAME_SERIALIZED_PREFS = \"newpipe.settings\"\n+        const val FILE_NAME_JSON_PREFS = \"preferences.json\"\n+    }\n+\n+    val dbDir by lazy { File(homeDir, \"/databases\") }\n+\n+    val db by lazy { File(dbDir, FILE_NAME_DB) }\n+\n+    val dbJournal by lazy { File(dbDir, \"$FILE_NAME_DB-journal\") }\n+\n+    val dbShm by lazy { File(dbDir, \"$FILE_NAME_DB-shm\") }\n+\n+    val dbWal by lazy { File(dbDir, \"$FILE_NAME_DB-wal\") }\n+}"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/settings/export/ImportExportManager.kt",
          "status": "added",
          "additions": 180,
          "deletions": 0,
          "patch": "@@ -0,0 +1,180 @@\n+package org.schabi.newpipe.settings.export\n+\n+import android.content.SharedPreferences\n+import com.grack.nanojson.JsonArray\n+import com.grack.nanojson.JsonParser\n+import com.grack.nanojson.JsonParserException\n+import com.grack.nanojson.JsonWriter\n+import org.schabi.newpipe.streams.io.SharpOutputStream\n+import org.schabi.newpipe.streams.io.StoredFileHelper\n+import org.schabi.newpipe.util.ZipHelper\n+import java.io.FileNotFoundException\n+import java.io.IOException\n+import java.io.ObjectOutputStream\n+import java.util.zip.ZipOutputStream\n+\n+class ImportExportManager(private val fileLocator: BackupFileLocator) {\n+    companion object {\n+        const val TAG = \"ImportExportManager\"\n+    }\n+\n+    /**\n+     * Exports given [SharedPreferences] to the file in given outputPath.\n+     * It also creates the file.\n+     */\n+    @Throws(Exception::class)\n+    fun exportDatabase(preferences: SharedPreferences, file: StoredFileHelper) {\n+        file.create()\n+        ZipOutputStream(SharpOutputStream(file.stream).buffered()).use { outZip ->\n+            // add the database\n+            ZipHelper.addFileToZip(\n+                outZip,\n+                BackupFileLocator.FILE_NAME_DB,\n+                fileLocator.db.path,\n+            )\n+\n+            // add the legacy vulnerable serialized preferences (will be removed in the future)\n+            ZipHelper.addFileToZip(\n+                outZip,\n+                BackupFileLocator.FILE_NAME_SERIALIZED_PREFS\n+            ) { byteOutput ->\n+                ObjectOutputStream(byteOutput).use { output ->\n+                    output.writeObject(preferences.all)\n+                    output.flush()\n+                }\n+            }\n+\n+            // add the JSON preferences\n+            ZipHelper.addFileToZip(\n+                outZip,\n+                BackupFileLocator.FILE_NAME_JSON_PREFS\n+            ) { byteOutput ->\n+                JsonWriter\n+                    .indent(\"\")\n+                    .on(byteOutput)\n+                    .`object`(preferences.all)\n+                    .done()\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tries to create database directory if it does not exist.\n+     *\n+     * @return Whether the directory exists afterwards.\n+     */\n+    fun ensureDbDirectoryExists(): Boolean {\n+        return fileLocator.dbDir.exists() || fileLocator.dbDir.mkdir()\n+    }\n+\n+    /**\n+     * Extracts the database from the given file to the app's database directory.\n+     * The current app's database will be overwritten.\n+     * @param file the .zip file to extract the database from\n+     * @return true if the database was successfully extracted, false otherwise\n+     */\n+    fun extractDb(file: StoredFileHelper): Boolean {\n+        val success = ZipHelper.extractFileFromZip(\n+                file,\n+                BackupFileLocator.FILE_NAME_DB,\n+                fileLocator.db.path,\n+        )\n+\n+        if (success) {\n+            fileLocator.dbJournal.delete()\n+            fileLocator.dbWal.delete()\n+            fileLocator.dbShm.delete()\n+        }\n+\n+        return success\n+    }\n+\n+    @Deprecated(\n+        \"Serializing preferences with Java's ObjectOutputStream is vulnerable to injections\",\n+        replaceWith = ReplaceWith(\"exportHasJsonPrefs\")\n+    )\n+    fun exportHasSerializedPrefs(zipFile: StoredFileHelper): Boolean {\n+        return ZipHelper.zipContainsFile(zipFile, BackupFileLocator.FILE_NAME_SERIALIZED_PREFS)\n+    }\n+\n+    fun exportHasJsonPrefs(zipFile: StoredFileHelper): Boolean {\n+        return ZipHelper.zipContainsFile(zipFile, BackupFileLocator.FILE_NAME_JSON_PREFS)\n+    }\n+\n+    /**\n+     * Remove all shared preferences from the app and load the preferences supplied to the manager.\n+     */\n+    @Deprecated(\n+        \"Serializing preferences with Java's ObjectOutputStream is vulnerable to injections\",\n+        replaceWith = ReplaceWith(\"loadJsonPrefs\")\n+    )\n+    @Throws(IOException::class, ClassNotFoundException::class)\n+    fun loadSerializedPrefs(zipFile: StoredFileHelper, preferences: SharedPreferences) {\n+        ZipHelper.extractFileFromZip(zipFile, BackupFileLocator.FILE_NAME_SERIALIZED_PREFS) {\n+            PreferencesObjectInputStream(it).use { input ->\n+                @Suppress(\"UNCHECKED_CAST\")\n+                val entries = input.readObject() as Map<String, *>\n+\n+                val editor = preferences.edit()\n+                editor.clear()\n+\n+                for ((key, value) in entries) {\n+                    when (value) {\n+                        is Boolean -> editor.putBoolean(key, value)\n+                        is Float -> editor.putFloat(key, value)\n+                        is Int -> editor.putInt(key, value)\n+                        is Long -> editor.putLong(key, value)\n+                        is String -> editor.putString(key, value)\n+                        is Set<*> -> {\n+                            // There are currently only Sets with type String possible\n+                            @Suppress(\"UNCHECKED_CAST\")\n+                            editor.putStringSet(key, value as Set<String>?)\n+                        }\n+                    }\n+                }\n+\n+                if (!editor.commit()) {\n+                    throw IOException(\"Unable to commit loadSerializedPrefs\")\n+                }\n+            }\n+        }.let { fileExists ->\n+            if (!fileExists) {\n+                throw FileNotFoundException(BackupFileLocator.FILE_NAME_SERIALIZED_PREFS)\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove all shared preferences from the app and load the preferences supplied to the manager.\n+     */\n+    @Throws(IOException::class, JsonParserException::class)\n+    fun loadJsonPrefs(zipFile: StoredFileHelper, preferences: SharedPreferences) {\n+        ZipHelper.extractFileFromZip(zipFile, BackupFileLocator.FILE_NAME_JSON_PREFS) {\n+            val jsonObject = JsonParser.`object`().from(it)\n+\n+            val editor = preferences.edit()\n+            editor.clear()\n+\n+            for ((key, value) in jsonObject) {\n+                when (value) {\n+                    is Boolean -> editor.putBoolean(key, value)\n+                    is Float -> editor.putFloat(key, value)\n+                    is Int -> editor.putInt(key, value)\n+                    is Long -> editor.putLong(key, value)\n+                    is String -> editor.putString(key, value)\n+                    is JsonArray -> {\n+                        editor.putStringSet(key, value.mapNotNull { e -> e as? String }.toSet())\n+                    }\n+                }\n+            }\n+\n+            if (!editor.commit()) {\n+                throw IOException(\"Unable to commit loadJsonPrefs\")\n+            }\n+        }.let { fileExists ->\n+            if (!fileExists) {\n+                throw FileNotFoundException(BackupFileLocator.FILE_NAME_JSON_PREFS)\n+            }\n+        }\n+    }\n+}"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/settings/export/PreferencesObjectInputStream.java",
          "status": "added",
          "additions": 58,
          "deletions": 0,
          "patch": "@@ -0,0 +1,58 @@\n+package org.schabi.newpipe.settings.export;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamClass;\n+import java.util.Set;\n+\n+/**\n+ * An {@link ObjectInputStream} that only allows preferences-related types to be deserialized, to\n+ * prevent injections. The only allowed types are: all primitive types, all boxed primitive types,\n+ * null, strings. HashMap, HashSet and arrays of previously defined types are also allowed. Sources:\n+ * <a href=\"https://wiki.sei.cmu.edu/confluence/display/java/SER00-J.+Enable+serialization+compatibility+during+class+evolution\">\n+ * cmu.edu\n+ * </a>,\n+ * <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#harden-your-own-javaioobjectinputstream\">\n+ * OWASP cheatsheet\n+ * </a>,\n+ * <a href=\"https://commons.apache.org/proper/commons-io/apidocs/src-html/org/apache/commons/io/serialization/ValidatingObjectInputStream.html#line-118\">\n+ * Apache's {@code ValidatingObjectInputStream}\n+ * </a>\n+ */\n+public class PreferencesObjectInputStream extends ObjectInputStream {\n+\n+    /**\n+     * Primitive types, strings and other built-in types do not pass through resolveClass() but\n+     * instead have a custom encoding; see\n+     * <a href=\"https://docs.oracle.com/javase/6/docs/platform/serialization/spec/protocol.html#10152\">\n+     * official docs</a>.\n+     */\n+    private static final Set<String> CLASS_WHITELIST = Set.of(\n+            \"java.lang.Boolean\",\n+            \"java.lang.Byte\",\n+            \"java.lang.Character\",\n+            \"java.lang.Short\",\n+            \"java.lang.Integer\",\n+            \"java.lang.Long\",\n+            \"java.lang.Float\",\n+            \"java.lang.Double\",\n+            \"java.lang.Void\",\n+            \"java.util.HashMap\",\n+            \"java.util.HashSet\"\n+    );\n+\n+    public PreferencesObjectInputStream(final InputStream in) throws IOException {\n+        super(in);\n+    }\n+\n+    @Override\n+    protected Class<?> resolveClass(final ObjectStreamClass desc)\n+            throws ClassNotFoundException, IOException {\n+        if (CLASS_WHITELIST.contains(desc.getName())) {\n+            return super.resolveClass(desc);\n+        } else {\n+            throw new ClassNotFoundException(\"Class not allowed: \" + desc.getName());\n+        }\n+    }\n+}"
        },
        {
          "filename": "app/src/main/java/org/schabi/newpipe/util/ZipHelper.java",
          "status": "modified",
          "additions": 127,
          "deletions": 43,
          "patch": "@@ -1,18 +1,21 @@\n package org.schabi.newpipe.util;\n \n import org.schabi.newpipe.streams.io.SharpInputStream;\n+import org.schabi.newpipe.streams.io.StoredFileHelper;\n \n import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipInputStream;\n import java.util.zip.ZipOutputStream;\n \n-import org.schabi.newpipe.streams.io.StoredFileHelper;\n-\n /**\n  * Created by Christian Schabesberger on 28.01.18.\n  * Copyright 2018 Christian Schabesberger <chris.schabesberger@mailbox.org>\n@@ -34,73 +37,154 @@\n  */\n \n public final class ZipHelper {\n-    private ZipHelper() { }\n \n     private static final int BUFFER_SIZE = 2048;\n \n+    @FunctionalInterface\n+    public interface InputStreamConsumer {\n+        void acceptStream(InputStream inputStream) throws IOException;\n+    }\n+\n+    @FunctionalInterface\n+    public interface OutputStreamConsumer {\n+        void acceptStream(OutputStream outputStream) throws IOException;\n+    }\n+\n+\n+    private ZipHelper() { }\n+\n+\n     /**\n-     * This function helps to create zip files.\n-     * Caution this will override the original file.\n+     * This function helps to create zip files. Caution this will overwrite the original file.\n      *\n-     * @param outZip The ZipOutputStream where the data should be stored in\n-     * @param file   The path of the file that should be added to zip.\n-     * @param name   The path of the file inside the zip.\n-     * @throws Exception\n+     * @param outZip     the ZipOutputStream where the data should be stored in\n+     * @param nameInZip  the path of the file inside the zip\n+     * @param fileOnDisk the path of the file on the disk that should be added to zip\n      */\n-    public static void addFileToZip(final ZipOutputStream outZip, final String file,\n-                                    final String name) throws Exception {\n+    public static void addFileToZip(final ZipOutputStream outZip,\n+                                    final String nameInZip,\n+                                    final String fileOnDisk) throws IOException {\n+        try (FileInputStream fi = new FileInputStream(fileOnDisk)) {\n+            addFileToZip(outZip, nameInZip, fi);\n+        }\n+    }\n+\n+    /**\n+     * This function helps to create zip files. Caution this will overwrite the original file.\n+     *\n+     * @param outZip         the ZipOutputStream where the data should be stored in\n+     * @param nameInZip      the path of the file inside the zip\n+     * @param streamConsumer will be called with an output stream that will go to the output file\n+     */\n+    public static void addFileToZip(final ZipOutputStream outZip,\n+                                    final String nameInZip,\n+                                    final OutputStreamConsumer streamConsumer) throws IOException {\n+        final byte[] bytes;\n+        try (ByteArrayOutputStream byteOutput = new ByteArrayOutputStream()) {\n+            streamConsumer.acceptStream(byteOutput);\n+            bytes = byteOutput.toByteArray();\n+        }\n+\n+        try (ByteArrayInputStream byteInput = new ByteArrayInputStream(bytes)) {\n+            ZipHelper.addFileToZip(outZip, nameInZip, byteInput);\n+        }\n+    }\n+\n+    /**\n+     * This function helps to create zip files. Caution this will overwrite the original file.\n+     *\n+     * @param outZip      the ZipOutputStream where the data should be stored in\n+     * @param nameInZip   the path of the file inside the zip\n+     * @param inputStream the content to put inside the file\n+     */\n+    public static void addFileToZip(final ZipOutputStream outZip,\n+                                    final String nameInZip,\n+                                    final InputStream inputStream) throws IOException {\n         final byte[] data = new byte[BUFFER_SIZE];\n-        try (FileInputStream fi = new FileInputStream(file);\n-             BufferedInputStream inputStream = new BufferedInputStream(fi, BUFFER_SIZE)) {\n-            final ZipEntry entry = new ZipEntry(name);\n+        try (BufferedInputStream bufferedInputStream =\n+                     new BufferedInputStream(inputStream, BUFFER_SIZE)) {\n+            final ZipEntry entry = new ZipEntry(nameInZip);\n             outZip.putNextEntry(entry);\n             int count;\n-            while ((count = inputStream.read(data, 0, BUFFER_SIZE)) != -1) {\n+            while ((count = bufferedInputStream.read(data, 0, BUFFER_SIZE)) != -1) {\n                 outZip.write(data, 0, count);\n             }\n         }\n     }\n \n+    /**\n+     * This will extract data from ZipInputStream. Caution this will overwrite the original file.\n+     *\n+     * @param zipFile    the zip file to extract from\n+     * @param nameInZip  the path of the file inside the zip\n+     * @param fileOnDisk the path of the file on the disk where the data should be extracted to\n+     * @return will return true if the file was found within the zip file\n+     */\n+    public static boolean extractFileFromZip(final StoredFileHelper zipFile,\n+                                             final String nameInZip,\n+                                             final String fileOnDisk) throws IOException {\n+        return extractFileFromZip(zipFile, nameInZip, input -> {\n+            // delete old file first\n+            final File oldFile = new File(fileOnDisk);\n+            if (oldFile.exists()) {\n+                if (!oldFile.delete()) {\n+                    throw new IOException(\"Could not delete \" + fileOnDisk);\n+                }\n+            }\n+\n+            final byte[] data = new byte[BUFFER_SIZE];\n+            try (FileOutputStream outFile = new FileOutputStream(fileOnDisk)) {\n+                int count;\n+                while ((count = input.read(data)) != -1) {\n+                    outFile.write(data, 0, count);\n+                }\n+            }\n+        });\n+    }\n+\n     /**\n      * This will extract data from ZipInputStream.\n-     * Caution this will override the original file.\n      *\n-     * @param zipFile The zip file\n-     * @param file The path of the file on the disk where the data should be extracted to.\n-     * @param name The path of the file inside the zip.\n+     * @param zipFile        the zip file to extract from\n+     * @param nameInZip      the path of the file inside the zip\n+     * @param streamConsumer will be called with the input stream from the file inside the zip\n      * @return will return true if the file was found within the zip file\n-     * @throws Exception\n      */\n-    public static boolean extractFileFromZip(final StoredFileHelper zipFile, final String file,\n-                                             final String name) throws Exception {\n+    public static boolean extractFileFromZip(final StoredFileHelper zipFile,\n+                                             final String nameInZip,\n+                                             final InputStreamConsumer streamConsumer)\n+            throws IOException {\n+        try (ZipInputStream inZip = new ZipInputStream(new BufferedInputStream(\n+                new SharpInputStream(zipFile.getStream())))) {\n+            ZipEntry ze;\n+            while ((ze = inZip.getNextEntry()) != null) {\n+                if (ze.getName().equals(nameInZip)) {\n+                    streamConsumer.acceptStream(inZip);\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * @param zipFile   the zip file\n+     * @param fileInZip the filename to check\n+     * @return whether the provided filename is in the zip; only the first level is checked\n+     */\n+    public static boolean zipContainsFile(final StoredFileHelper zipFile, final String fileInZip)\n+            throws Exception {\n         try (ZipInputStream inZip = new ZipInputStream(new BufferedInputStream(\n                 new SharpInputStream(zipFile.getStream())))) {\n-            final byte[] data = new byte[BUFFER_SIZE];\n-            boolean found = false;\n             ZipEntry ze;\n \n             while ((ze = inZip.getNextEntry()) != null) {\n-                if (ze.getName().equals(name)) {\n-                    found = true;\n-                    // delete old file first\n-                    final File oldFile = new File(file);\n-                    if (oldFile.exists()) {\n-                        if (!oldFile.delete()) {\n-                            throw new Exception(\"Could not delete \" + file);\n-                        }\n-                    }\n-\n-                    try (FileOutputStream outFile = new FileOutputStream(file)) {\n-                        int count = 0;\n-                        while ((count = inZip.read(data)) != -1) {\n-                            outFile.write(data, 0, count);\n-                        }\n-                    }\n-\n-                    inZip.closeEntry();\n+                if (ze.getName().equals(fileInZip)) {\n+                    return true;\n                 }\n             }\n-            return found;\n+            return false;\n         }\n     }\n "
        },
        {
          "filename": "app/src/main/res/values/strings.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -856,4 +856,5 @@\n     </plurals>\n     <string name=\"show_more\">Show more</string>\n     <string name=\"show_less\">Show less</string>\n+    <string name=\"import_settings_vulnerable_format\">The settings in the export being imported use a vulnerable format that was deprecated since NewPipe 0.27.0. Make sure the export being imported is from a trusted source, and prefer using only exports obtained from NewPipe 0.27.0 or newer in the future. Support for importing settings in this vulnerable format will soon be removed completely, and then old versions of NewPipe will not be able to import settings of exports from new versions anymore.</string>\n </resources>"
        },
        {
          "filename": "app/src/test/java/org/schabi/newpipe/settings/ImportAllCombinationsTest.kt",
          "status": "added",
          "additions": 184,
          "deletions": 0,
          "patch": "@@ -0,0 +1,184 @@\n+package org.schabi.newpipe.settings\n+\n+import android.content.SharedPreferences\n+import org.junit.Assert\n+import org.junit.Test\n+import org.mockito.Mockito\n+import org.schabi.newpipe.settings.export.BackupFileLocator\n+import org.schabi.newpipe.settings.export.ImportExportManager\n+import org.schabi.newpipe.streams.io.StoredFileHelper\n+import us.shandian.giga.io.FileStream\n+import java.io.File\n+import java.io.IOException\n+import java.nio.file.Files\n+\n+class ImportAllCombinationsTest {\n+\n+    companion object {\n+        private val classloader = ImportExportManager::class.java.classLoader!!\n+    }\n+\n+    private enum class Ser(val id: String) {\n+        YES(\"ser\"),\n+        VULNERABLE(\"vulnser\"),\n+        NO(\"noser\");\n+    }\n+\n+    private data class FailData(\n+        val containsDb: Boolean,\n+        val containsSer: Ser,\n+        val containsJson: Boolean,\n+        val filename: String,\n+        val throwable: Throwable,\n+    )\n+\n+    private fun testZipCombination(\n+        containsDb: Boolean,\n+        containsSer: Ser,\n+        containsJson: Boolean,\n+        filename: String,\n+        runTest: (test: () -> Unit) -> Unit,\n+    ) {\n+        val zipFile = File(classloader.getResource(filename)?.file!!)\n+        val zip = Mockito.mock(StoredFileHelper::class.java, Mockito.withSettings().stubOnly())\n+        Mockito.`when`(zip.stream).then { FileStream(zipFile) }\n+\n+        val fileLocator = Mockito.mock(\n+            BackupFileLocator::class.java,\n+            Mockito.withSettings().stubOnly()\n+        )\n+        val db = File.createTempFile(\"newpipe_\", \"\")\n+        val dbJournal = File.createTempFile(\"newpipe_\", \"\")\n+        val dbWal = File.createTempFile(\"newpipe_\", \"\")\n+        val dbShm = File.createTempFile(\"newpipe_\", \"\")\n+        Mockito.`when`(fileLocator.db).thenReturn(db)\n+        Mockito.`when`(fileLocator.dbJournal).thenReturn(dbJournal)\n+        Mockito.`when`(fileLocator.dbShm).thenReturn(dbShm)\n+        Mockito.`when`(fileLocator.dbWal).thenReturn(dbWal)\n+\n+        if (containsDb) {\n+            runTest {\n+                Assert.assertTrue(ImportExportManager(fileLocator).extractDb(zip))\n+                Assert.assertFalse(dbJournal.exists())\n+                Assert.assertFalse(dbWal.exists())\n+                Assert.assertFalse(dbShm.exists())\n+                Assert.assertTrue(\"database file size is zero\", Files.size(db.toPath()) > 0)\n+            }\n+        } else {\n+            runTest {\n+                Assert.assertFalse(ImportExportManager(fileLocator).extractDb(zip))\n+                Assert.assertTrue(dbJournal.exists())\n+                Assert.assertTrue(dbWal.exists())\n+                Assert.assertTrue(dbShm.exists())\n+                Assert.assertEquals(0, Files.size(db.toPath()))\n+            }\n+        }\n+\n+        val preferences = Mockito.mock(SharedPreferences::class.java, Mockito.withSettings().stubOnly())\n+        var editor = Mockito.mock(SharedPreferences.Editor::class.java)\n+        Mockito.`when`(preferences.edit()).thenReturn(editor)\n+        Mockito.`when`(editor.commit()).thenReturn(true)\n+\n+        when (containsSer) {\n+            Ser.YES -> runTest {\n+                Assert.assertTrue(ImportExportManager(fileLocator).exportHasSerializedPrefs(zip))\n+                ImportExportManager(fileLocator).loadSerializedPrefs(zip, preferences)\n+\n+                Mockito.verify(editor, Mockito.times(1)).clear()\n+                Mockito.verify(editor, Mockito.times(1)).commit()\n+                Mockito.verify(editor, Mockito.atLeastOnce())\n+                    .putBoolean(Mockito.anyString(), Mockito.anyBoolean())\n+                Mockito.verify(editor, Mockito.atLeastOnce())\n+                    .putString(Mockito.anyString(), Mockito.anyString())\n+                Mockito.verify(editor, Mockito.atLeastOnce())\n+                    .putInt(Mockito.anyString(), Mockito.anyInt())\n+            }\n+            Ser.VULNERABLE -> runTest {\n+                Assert.assertTrue(ImportExportManager(fileLocator).exportHasSerializedPrefs(zip))\n+                Assert.assertThrows(ClassNotFoundException::class.java) {\n+                    ImportExportManager(fileLocator).loadSerializedPrefs(zip, preferences)\n+                }\n+\n+                Mockito.verify(editor, Mockito.never()).clear()\n+                Mockito.verify(editor, Mockito.never()).commit()\n+            }\n+            Ser.NO -> runTest {\n+                Assert.assertFalse(ImportExportManager(fileLocator).exportHasSerializedPrefs(zip))\n+                Assert.assertThrows(IOException::class.java) {\n+                    ImportExportManager(fileLocator).loadSerializedPrefs(zip, preferences)\n+                }\n+\n+                Mockito.verify(editor, Mockito.never()).clear()\n+                Mockito.verify(editor, Mockito.never()).commit()\n+            }\n+        }\n+\n+        // recreate editor mock so verify() behaves correctly\n+        editor = Mockito.mock(SharedPreferences.Editor::class.java)\n+        Mockito.`when`(preferences.edit()).thenReturn(editor)\n+        Mockito.`when`(editor.commit()).thenReturn(true)\n+\n+        if (containsJson) {\n+            runTest {\n+                Assert.assertTrue(ImportExportManager(fileLocator).exportHasJsonPrefs(zip))\n+                ImportExportManager(fileLocator).loadJsonPrefs(zip, preferences)\n+\n+                Mockito.verify(editor, Mockito.times(1)).clear()\n+                Mockito.verify(editor, Mockito.times(1)).commit()\n+                Mockito.verify(editor, Mockito.atLeastOnce())\n+                    .putBoolean(Mockito.anyString(), Mockito.anyBoolean())\n+                Mockito.verify(editor, Mockito.atLeastOnce())\n+                    .putString(Mockito.anyString(), Mockito.anyString())\n+                Mockito.verify(editor, Mockito.atLeastOnce())\n+                    .putInt(Mockito.anyString(), Mockito.anyInt())\n+            }\n+        } else {\n+            runTest {\n+                Assert.assertFalse(ImportExportManager(fileLocator).exportHasJsonPrefs(zip))\n+                Assert.assertThrows(IOException::class.java) {\n+                    ImportExportManager(fileLocator).loadJsonPrefs(zip, preferences)\n+                }\n+\n+                Mockito.verify(editor, Mockito.never()).clear()\n+                Mockito.verify(editor, Mockito.never()).commit()\n+            }\n+        }\n+    }\n+\n+    @Test\n+    fun `Importing all possible combinations of zip files`() {\n+        val failedAssertions = mutableListOf<FailData>()\n+        for (containsDb in listOf(true, false)) {\n+            for (containsSer in Ser.entries) {\n+                for (containsJson in listOf(true, false)) {\n+                    val filename = \"settings/${if (containsDb) \"db\" else \"nodb\"}_${\n+                    containsSer.id}_${if (containsJson) \"json\" else \"nojson\"}.zip\"\n+                    testZipCombination(containsDb, containsSer, containsJson, filename) { test ->\n+                        try {\n+                            test()\n+                        } catch (e: Throwable) {\n+                            failedAssertions.add(\n+                                FailData(\n+                                    containsDb, containsSer, containsJson,\n+                                    filename, e\n+                                )\n+                            )\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (failedAssertions.isNotEmpty()) {\n+            for (a in failedAssertions) {\n+                println(\n+                    \"Assertion failed with containsDb=${a.containsDb}, containsSer=${\n+                    a.containsSer}, containsJson=${a.containsJson}, filename=${a.filename}:\"\n+                )\n+                a.throwable.printStackTrace()\n+                println()\n+            }\n+            Assert.fail(\"${failedAssertions.size} assertions failed\")\n+        }\n+    }\n+}"
        },
        {
          "filename": "app/src/test/java/org/schabi/newpipe/settings/ImportExportManagerTest.kt",
          "status": "renamed",
          "additions": 41,
          "deletions": 51,
          "patch": "@@ -1,8 +1,10 @@\n package org.schabi.newpipe.settings\n \n import android.content.SharedPreferences\n+import com.grack.nanojson.JsonParser\n import org.junit.Assert.assertEquals\n import org.junit.Assert.assertFalse\n+import org.junit.Assert.assertThrows\n import org.junit.Assert.assertTrue\n import org.junit.Assume\n import org.junit.Before\n@@ -17,6 +19,8 @@ import org.mockito.Mockito.verify\n import org.mockito.Mockito.`when`\n import org.mockito.Mockito.withSettings\n import org.mockito.junit.MockitoJUnitRunner\n+import org.schabi.newpipe.settings.export.BackupFileLocator\n+import org.schabi.newpipe.settings.export.ImportExportManager\n import org.schabi.newpipe.streams.io.StoredFileHelper\n import us.shandian.giga.io.FileStream\n import java.io.File\n@@ -25,27 +29,25 @@ import java.nio.file.Files\n import java.util.zip.ZipFile\n \n @RunWith(MockitoJUnitRunner::class)\n-class ContentSettingsManagerTest {\n+class ImportExportManagerTest {\n \n     companion object {\n-        private val classloader = ContentSettingsManager::class.java.classLoader!!\n+        private val classloader = ImportExportManager::class.java.classLoader!!\n     }\n \n-    private lateinit var fileLocator: NewPipeFileLocator\n+    private lateinit var fileLocator: BackupFileLocator\n     private lateinit var storedFileHelper: StoredFileHelper\n \n     @Before\n     fun setupFileLocator() {\n-        fileLocator = Mockito.mock(NewPipeFileLocator::class.java, withSettings().stubOnly())\n+        fileLocator = Mockito.mock(BackupFileLocator::class.java, withSettings().stubOnly())\n         storedFileHelper = Mockito.mock(StoredFileHelper::class.java, withSettings().stubOnly())\n     }\n \n     @Test\n     fun `The settings must be exported successfully in the correct format`() {\n         val db = File(classloader.getResource(\"settings/newpipe.db\")!!.file)\n-        val newpipeSettings = File.createTempFile(\"newpipe_\", \"\")\n         `when`(fileLocator.db).thenReturn(db)\n-        `when`(fileLocator.settings).thenReturn(newpipeSettings)\n \n         val expectedPreferences = mapOf(\"such pref\" to \"much wow\")\n         val sharedPreferences =\n@@ -54,11 +56,11 @@ class ContentSettingsManagerTest {\n \n         val output = File.createTempFile(\"newpipe_\", \"\")\n         `when`(storedFileHelper.stream).thenReturn(FileStream(output))\n-        ContentSettingsManager(fileLocator).exportDatabase(sharedPreferences, storedFileHelper)\n+        ImportExportManager(fileLocator).exportDatabase(sharedPreferences, storedFileHelper)\n \n         val zipFile = ZipFile(output)\n         val entries = zipFile.entries().toList()\n-        assertEquals(2, entries.size)\n+        assertEquals(3, entries.size)\n \n         zipFile.getInputStream(entries.first { it.name == \"newpipe.db\" }).use { actual ->\n             db.inputStream().use { expected ->\n@@ -70,26 +72,11 @@ class ContentSettingsManagerTest {\n             val actualPreferences = ObjectInputStream(actual).readObject()\n             assertEquals(expectedPreferences, actualPreferences)\n         }\n-    }\n-\n-    @Test\n-    fun `Settings file must be deleted`() {\n-        val settings = File.createTempFile(\"newpipe_\", \"\")\n-        `when`(fileLocator.settings).thenReturn(settings)\n-\n-        ContentSettingsManager(fileLocator).deleteSettingsFile()\n-\n-        assertFalse(settings.exists())\n-    }\n \n-    @Test\n-    fun `Deleting settings file must do nothing if none exist`() {\n-        val settings = File(\"non_existent\")\n-        `when`(fileLocator.settings).thenReturn(settings)\n-\n-        ContentSettingsManager(fileLocator).deleteSettingsFile()\n-\n-        assertFalse(settings.exists())\n+        zipFile.getInputStream(entries.first { it.name == \"preferences.json\" }).use { actual ->\n+            val actualPreferences = JsonParser.`object`().from(actual)\n+            assertEquals(expectedPreferences, actualPreferences)\n+        }\n     }\n \n     @Test\n@@ -98,7 +85,7 @@ class ContentSettingsManagerTest {\n         Assume.assumeTrue(dir.delete())\n         `when`(fileLocator.dbDir).thenReturn(dir)\n \n-        ContentSettingsManager(fileLocator).ensureDbDirectoryExists()\n+        ImportExportManager(fileLocator).ensureDbDirectoryExists()\n         assertTrue(dir.exists())\n     }\n \n@@ -107,7 +94,7 @@ class ContentSettingsManagerTest {\n         val dir = Files.createTempDirectory(\"newpipe_\").toFile()\n         `when`(fileLocator.dbDir).thenReturn(dir)\n \n-        ContentSettingsManager(fileLocator).ensureDbDirectoryExists()\n+        ImportExportManager(fileLocator).ensureDbDirectoryExists()\n         assertTrue(dir.exists())\n     }\n \n@@ -122,9 +109,9 @@ class ContentSettingsManagerTest {\n         `when`(fileLocator.dbShm).thenReturn(dbShm)\n         `when`(fileLocator.dbWal).thenReturn(dbWal)\n \n-        val zip = File(classloader.getResource(\"settings/newpipe.zip\")?.file!!)\n+        val zip = File(classloader.getResource(\"settings/db_ser_json.zip\")?.file!!)\n         `when`(storedFileHelper.stream).thenReturn(FileStream(zip))\n-        val success = ContentSettingsManager(fileLocator).extractDb(storedFileHelper)\n+        val success = ImportExportManager(fileLocator).extractDb(storedFileHelper)\n \n         assertTrue(success)\n         assertFalse(dbJournal.exists())\n@@ -141,9 +128,9 @@ class ContentSettingsManagerTest {\n         val dbShm = File.createTempFile(\"newpipe_\", \"\")\n         `when`(fileLocator.db).thenReturn(db)\n \n-        val emptyZip = File(classloader.getResource(\"settings/empty.zip\")?.file!!)\n+        val emptyZip = File(classloader.getResource(\"settings/nodb_noser_nojson.zip\")?.file!!)\n         `when`(storedFileHelper.stream).thenReturn(FileStream(emptyZip))\n-        val success = ContentSettingsManager(fileLocator).extractDb(storedFileHelper)\n+        val success = ImportExportManager(fileLocator).extractDb(storedFileHelper)\n \n         assertFalse(success)\n         assertTrue(dbJournal.exists())\n@@ -154,41 +141,44 @@ class ContentSettingsManagerTest {\n \n     @Test\n     fun `Contains setting must return true if a settings file exists in the zip`() {\n-        val settings = File.createTempFile(\"newpipe_\", \"\")\n-        `when`(fileLocator.settings).thenReturn(settings)\n-\n-        val zip = File(classloader.getResource(\"settings/newpipe.zip\")?.file!!)\n+        val zip = File(classloader.getResource(\"settings/db_ser_json.zip\")?.file!!)\n         `when`(storedFileHelper.stream).thenReturn(FileStream(zip))\n-        val contains = ContentSettingsManager(fileLocator).extractSettings(storedFileHelper)\n-\n-        assertTrue(contains)\n+        assertTrue(ImportExportManager(fileLocator).exportHasSerializedPrefs(storedFileHelper))\n     }\n \n     @Test\n-    fun `Contains setting must return false if a no settings file exists in the zip`() {\n-        val settings = File.createTempFile(\"newpipe_\", \"\")\n-        `when`(fileLocator.settings).thenReturn(settings)\n-\n-        val emptyZip = File(classloader.getResource(\"settings/empty.zip\")?.file!!)\n+    fun `Contains setting must return false if no settings file exists in the zip`() {\n+        val emptyZip = File(classloader.getResource(\"settings/nodb_noser_nojson.zip\")?.file!!)\n         `when`(storedFileHelper.stream).thenReturn(FileStream(emptyZip))\n-        val contains = ContentSettingsManager(fileLocator).extractSettings(storedFileHelper)\n-\n-        assertFalse(contains)\n+        assertFalse(ImportExportManager(fileLocator).exportHasSerializedPrefs(storedFileHelper))\n     }\n \n     @Test\n     fun `Preferences must be set from the settings file`() {\n-        val settings = File(classloader.getResource(\"settings/newpipe.settings\")!!.path)\n-        `when`(fileLocator.settings).thenReturn(settings)\n+        val zip = File(classloader.getResource(\"settings/db_ser_json.zip\")?.file!!)\n+        `when`(storedFileHelper.stream).thenReturn(FileStream(zip))\n \n         val preferences = Mockito.mock(SharedPreferences::class.java, withSettings().stubOnly())\n         val editor = Mockito.mock(SharedPreferences.Editor::class.java)\n         `when`(preferences.edit()).thenReturn(editor)\n+        `when`(editor.commit()).thenReturn(true)\n \n-        ContentSettingsManager(fileLocator).loadSharedPreferences(preferences)\n+        ImportExportManager(fileLocator).loadSerializedPrefs(storedFileHelper, preferences)\n \n         verify(editor, atLeastOnce()).putBoolean(anyString(), anyBoolean())\n         verify(editor, atLeastOnce()).putString(anyString(), anyString())\n         verify(editor, atLeastOnce()).putInt(anyString(), anyInt())\n     }\n+\n+    @Test\n+    fun `Importing preferences with a serialization injected class should fail`() {\n+        val emptyZip = File(classloader.getResource(\"settings/db_vulnser_json.zip\")?.file!!)\n+        `when`(storedFileHelper.stream).thenReturn(FileStream(emptyZip))\n+\n+        val preferences = Mockito.mock(SharedPreferences::class.java, withSettings().stubOnly())\n+\n+        assertThrows(ClassNotFoundException::class.java) {\n+            ImportExportManager(fileLocator).loadSerializedPrefs(storedFileHelper, preferences)\n+        }\n+    }\n }"
        },
        {
          "filename": "app/src/test/resources/settings/README.md",
          "status": "added",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -0,0 +1,4 @@\n+`*.zip` files in this folder are NewPipe database exports, in all possible configurations:\n+- `db` / `nodb` indicates if there is a `newpipe.db` database included or not\n+- `ser` / `vulnser` / `noser` indicates if there is a `newpipe.settings` Java-serialized preferences file included, if it is included and contains an injection attack, of if it is not included\n+- `json` / `nojson` indicates if there is a `preferences.json` JSON preferences file included or not"
        },
        {
          "filename": "app/src/test/resources/settings/db_noser_json.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/db_noser_nojson.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/db_ser_json.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/db_ser_nojson.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/db_vulnser_json.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/db_vulnser_nojson.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/newpipe.settings",
          "status": "removed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/newpipe.zip",
          "status": "removed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/nodb_noser_json.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/nodb_noser_nojson.zip",
          "status": "renamed",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/nodb_ser_json.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/nodb_ser_nojson.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/nodb_vulnser_json.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "app/src/test/resources/settings/nodb_vulnser_nojson.zip",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "checkstyle/checkstyle.xml",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -39,11 +39,13 @@\n     <module name=\"Translation\"/>\n \n     <!-- Checks for Size Violations.                    -->\n-    <!-- See https://checkstyle.org/config_sizes.html -->\n+    <!-- See https://checkstyle.sourceforge.io/checks/sizes/index.html -->\n     <module name=\"FileLength\"/>\n     <module name=\"LineLength\">\n       <property name=\"max\" value=\"100\"/>\n       <property name=\"fileExtensions\" value=\"java\"/>\n+      <!-- Also allow links in javadocs to be longer (the default would just cover imports) -->\n+      <property name=\"ignorePattern\" value=\"^((package|import) .*)|( *\\* &lt;a href ?\\= ?&quot;.*&quot;&gt;)$\"/>\n     </module>\n \n     <!-- Checks for whitespace                               -->"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 23,
        "dependency_files": 0,
        "test_files": 17,
        "unique_directories": 8,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f7d0fd545d8bce62907e0419cc8cbb42ea58e313",
            "date": "2025-01-04T08:34:07Z",
            "author_login": "Stypox"
          },
          {
            "sha": "27e6be792fd525a48eb0cfc4e90125e9be43e282",
            "date": "2025-01-04T08:15:44Z",
            "author_login": "tom93"
          },
          {
            "sha": "3fc0147f47a41e39ffcff744f18dff6e2d7ccb48",
            "date": "2024-12-17T09:42:34Z",
            "author_login": "Stypox"
          },
          {
            "sha": "c6b05c60945de01e74156705a81839a4aa64dbf0",
            "date": "2024-12-07T20:30:41Z",
            "author_login": "Rishi2003Das"
          },
          {
            "sha": "240a2fe36b45914dac766305d7adceea6c335717",
            "date": "2024-12-07T20:30:04Z",
            "author_login": "Rishi2003Das"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:L",
    "cwe_id": "CWE-502",
    "description": "NewPipe is an Android app for video streaming written in Java. It supports exporting and importing backups, as a way to let users move their data to a new device effortlessly. However, in versions 0.13.4 through 0.26.1, importing a backup file from an untrusted source could have resulted in Arbitrary Code Execution. This is because backups are serialized/deserialized using Java's Object Serialization Stream Protocol, which can allow constructing any class in the app, unless properly restricted.\n\nTo exploit this vulnerability, an attacker would need to build a backup file containing the exploit, and then persuade a user into importing it. During the import process, the malicious code would be executed, possibly crashing the app, stealing user data from the NewPipe app, performing nasty actions through Android APIs, and attempting Android JVM/Sandbox escapes through vulnerabilities in the Android OS.\n\nThe attack can take place only if the user imports a malicious backup file, so an attacker would need to trick a user into importing a backup file from a source they can control. The implementation details of the malicious backup file can be independent of the attacked user or the device they are being run on, and do not require additional privileges.\n\nAll NewPipe versions from 0.13.4 to 0.26.1 are vulnerable. NewPipe version 0.27.0 fixes the issue by doing the following: Restrict the classes that can be deserialized when calling Java's Object Serialization Stream Protocol, by adding a whitelist with only innocuous data-only classes that can't lead to Arbitrary Code Execution; deprecate backups serialized with Java's Object Serialization Stream Protocol; use JSON serialization for all newly created backups (but still include an alternative file serialized with Java's Object Serialization Stream Protocol in the backup zip for backwards compatibility); show a warning to the user when attempting to import a backup where the only available serialization mode is Java's Object Serialization Stream Protocol (note that in the future this serialization mode will be removed completely).\n",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-04-24T19:15:47.140",
    "last_modified": "2024-11-21T09:15:55.083",
    "fix_date": "2024-04-23T17:22:17Z"
  },
  "references": [
    {
      "url": "https://docs.oracle.com/javase/6/docs/platform/serialization/spec/protocol.html",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/TeamNewPipe/NewPipe/commit/a69bbab73220f36e53c801cf7e9ea3627bb017eb",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/TeamNewPipe/NewPipe/releases/tag/v0.27.0",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/TeamNewPipe/NewPipe/security/advisories/GHSA-wxrm-jhpf-vp6v",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://docs.oracle.com/javase/6/docs/platform/serialization/spec/protocol.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/TeamNewPipe/NewPipe/commit/a69bbab73220f36e53c801cf7e9ea3627bb017eb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/TeamNewPipe/NewPipe/releases/tag/v0.27.0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/TeamNewPipe/NewPipe/security/advisories/GHSA-wxrm-jhpf-vp6v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:07.017646",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "NewPipe",
    "owner": "TeamNewPipe",
    "created_at": "2015-09-03T23:39:26Z",
    "updated_at": "2025-01-14T21:53:11Z",
    "pushed_at": "2025-01-04T08:34:08Z",
    "size": 77783,
    "stars": 32235,
    "forks": 3096,
    "open_issues": 1185,
    "watchers": 32235,
    "has_security_policy": false,
    "default_branch": "dev",
    "protected_branches": [
      "dev",
      "master"
    ],
    "languages": {
      "Java": 2628195,
      "Kotlin": 422077,
      "HTML": 77544
    },
    "commit_activity": {
      "total_commits_last_year": 406,
      "avg_commits_per_week": 7.8076923076923075,
      "days_active_last_year": 84
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T22:00:38.529123"
  }
}