{
  "cve_id": "CVE-2024-32967",
  "github_data": {
    "repository": "zitadel/zitadel",
    "fix_commit": "b918603b576d156a08b90917c14c2d019c82ffc6",
    "related_commits": [
      "b918603b576d156a08b90917c14c2d019c82ffc6",
      "b918603b576d156a08b90917c14c2d019c82ffc6"
    ],
    "patch_url": "https://github.com/zitadel/zitadel/commit/b918603b576d156a08b90917c14c2d019c82ffc6.patch",
    "fix_commit_details": {
      "sha": "b918603b576d156a08b90917c14c2d019c82ffc6",
      "commit_date": "2024-04-23T08:35:25Z",
      "author": {
        "login": "livio-a",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: exclude db connection error details (#7785)",
        "length": 198,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 105,
        "additions": 67,
        "deletions": 38
      },
      "files": [
        {
          "filename": "cmd/start/start.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -356,7 +356,7 @@ func startAPIs(\n \t\thttp_util.WithMaxAge(int(math.Floor(config.Quotas.Access.ExhaustedCookieMaxAge.Seconds()))),\n \t)\n \tlimitingAccessInterceptor := middleware.NewAccessInterceptor(accessSvc, exhaustedCookieHandler, &config.Quotas.Access.AccessConfig)\n-\tapis, err := api.New(ctx, config.Port, router, queries, verifier, config.InternalAuthZ, tlsConfig, config.HTTP2HostHeader, config.HTTP1HostHeader, limitingAccessInterceptor)\n+\tapis, err := api.New(ctx, config.Port, router, queries, verifier, config.InternalAuthZ, tlsConfig, config.HTTP2HostHeader, config.HTTP1HostHeader, config.ExternalDomain, limitingAccessInterceptor)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"error creating api %w\", err)\n \t}\n@@ -400,7 +400,7 @@ func startAPIs(\n \tif err := apis.RegisterService(ctx, org.CreateServer(commands, queries, permissionCheck)); err != nil {\n \t\treturn err\n \t}\n-\tinstanceInterceptor := middleware.InstanceInterceptor(queries, config.HTTP1HostHeader, login.IgnoreInstanceEndpoints...)\n+\tinstanceInterceptor := middleware.InstanceInterceptor(queries, config.HTTP1HostHeader, config.ExternalDomain, login.IgnoreInstanceEndpoints...)\n \tassetsCache := middleware.AssetsCacheInterceptor(config.AssetStorage.Cache.MaxAge, config.AssetStorage.Cache.SharedMaxAge)\n \tapis.RegisterHandlerOnPrefix(assets.HandlerPrefix, assets.NewHandler(commands, verifier, config.InternalAuthZ, id.SonyFlakeGenerator(), store, queries, middleware.CallDurationHandler, instanceInterceptor.Handler, assetsCache.Handler, limitingAccessInterceptor.Handle))\n "
        },
        {
          "filename": "internal/api/api.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -49,7 +49,7 @@ func New(\n \tqueries *query.Queries,\n \tverifier internal_authz.APITokenVerifier,\n \tauthZ internal_authz.Config,\n-\ttlsConfig *tls.Config, http2HostName, http1HostName string,\n+\ttlsConfig *tls.Config, http2HostName, http1HostName, externalDomain string,\n \taccessInterceptor *http_mw.AccessInterceptor,\n ) (_ *API, err error) {\n \tapi := &API{\n@@ -62,7 +62,7 @@ func New(\n \t\taccessInterceptor: accessInterceptor,\n \t}\n \n-\tapi.grpcServer = server.CreateServer(api.verifier, authZ, queries, http2HostName, tlsConfig, accessInterceptor.AccessService())\n+\tapi.grpcServer = server.CreateServer(api.verifier, authZ, queries, http2HostName, externalDomain, tlsConfig, accessInterceptor.AccessService())\n \tapi.grpcGateway, err = server.CreateGateway(ctx, port, http1HostName, accessInterceptor, tlsConfig)\n \tif err != nil {\n \t\treturn nil, err"
        },
        {
          "filename": "internal/api/assets/asset.go",
          "status": "modified",
          "additions": 21,
          "deletions": 7,
          "patch": "@@ -2,6 +2,7 @@ package assets\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n@@ -12,14 +13,17 @@ import (\n \t\"github.com/gabriel-vasile/mimetype\"\n \t\"github.com/gorilla/mux\"\n \t\"github.com/zitadel/logging\"\n+\t\"golang.org/x/text/language\"\n \n \t\"github.com/zitadel/zitadel/internal/api/authz\"\n \thttp_util \"github.com/zitadel/zitadel/internal/api/http\"\n \thttp_mw \"github.com/zitadel/zitadel/internal/api/http/middleware\"\n \t\"github.com/zitadel/zitadel/internal/command\"\n+\t\"github.com/zitadel/zitadel/internal/i18n\"\n \t\"github.com/zitadel/zitadel/internal/id\"\n \t\"github.com/zitadel/zitadel/internal/query\"\n \t\"github.com/zitadel/zitadel/internal/static\"\n+\t\"github.com/zitadel/zitadel/internal/zerrors\"\n )\n \n const (\n@@ -73,19 +77,29 @@ type Downloader interface {\n \n type ErrorHandler func(w http.ResponseWriter, r *http.Request, err error, defaultCode int)\n \n-func DefaultErrorHandler(w http.ResponseWriter, r *http.Request, err error, defaultCode int) {\n-\tlogging.WithFields(\"uri\", r.RequestURI).WithError(err).Warn(\"error occurred on asset api\")\n-\tcode, ok := http_util.ZitadelErrorToHTTPStatusCode(err)\n-\tif !ok {\n-\t\tcode = defaultCode\n+func DefaultErrorHandler(translator *i18n.Translator) func(w http.ResponseWriter, r *http.Request, err error, defaultCode int) {\n+\treturn func(w http.ResponseWriter, r *http.Request, err error, defaultCode int) {\n+\t\tlogging.WithFields(\"uri\", r.RequestURI).WithError(err).Warn(\"error occurred on asset api\")\n+\t\tcode, ok := http_util.ZitadelErrorToHTTPStatusCode(err)\n+\t\tif !ok {\n+\t\t\tcode = defaultCode\n+\t\t}\n+\t\tzErr := new(zerrors.ZitadelError)\n+\t\tif errors.As(err, &zErr) {\n+\t\t\tzErr.SetMessage(translator.LocalizeFromCtx(r.Context(), zErr.GetMessage(), nil))\n+\t\t\tzErr.Parent = nil // ensuring we don't leak any unwanted information\n+\t\t\terr = zErr\n+\t\t}\n+\t\thttp.Error(w, err.Error(), code)\n \t}\n-\thttp.Error(w, err.Error(), code)\n }\n \n func NewHandler(commands *command.Commands, verifier authz.APITokenVerifier, authConfig authz.Config, idGenerator id.Generator, storage static.Storage, queries *query.Queries, callDurationInterceptor, instanceInterceptor, assetCacheInterceptor, accessInterceptor func(handler http.Handler) http.Handler) http.Handler {\n+\ttranslator, err := i18n.NewZitadelTranslator(language.English)\n+\tlogging.OnError(err).Panic(\"unable to get translator\")\n \th := &Handler{\n \t\tcommands:        commands,\n-\t\terrorHandler:    DefaultErrorHandler,\n+\t\terrorHandler:    DefaultErrorHandler(translator),\n \t\tauthInterceptor: http_mw.AuthorizationInterceptor(verifier, authConfig),\n \t\tidGenerator:     idGenerator,\n \t\tstorage:         storage,"
        },
        {
          "filename": "internal/api/grpc/gerrors/zitadel_errors.go",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -2,6 +2,7 @@ package gerrors\n \n import (\n \t\"errors\"\n+\t\"strings\"\n \n \t\"github.com/zitadel/logging\"\n \t\"google.golang.org/grpc/codes\"\n@@ -35,6 +36,9 @@ func ExtractZITADELError(err error) (c codes.Code, msg, id string, ok bool) {\n \tif err == nil {\n \t\treturn codes.OK, \"\", \"\", false\n \t}\n+\tif strings.Contains(err.Error(), \"failed to connect to\") { // version of pgx does not yet export the error type\n+\t\treturn codes.Internal, \"db connection error\", \"\", true\n+\t}\n \tzitadelErr := new(zerrors.ZitadelError)\n \tif ok := errors.As(err, &zitadelErr); !ok {\n \t\treturn codes.Unknown, err.Error(), \"\", false"
        },
        {
          "filename": "internal/api/grpc/server/middleware/instance_interceptor.go",
          "status": "modified",
          "additions": 12,
          "deletions": 8,
          "patch": "@@ -14,6 +14,7 @@ import (\n \t\"google.golang.org/grpc/status\"\n \n \t\"github.com/zitadel/zitadel/internal/api/authz\"\n+\tzitadel_http \"github.com/zitadel/zitadel/internal/api/http\"\n \t\"github.com/zitadel/zitadel/internal/i18n\"\n \t\"github.com/zitadel/zitadel/internal/telemetry/tracing\"\n \t\"github.com/zitadel/zitadel/internal/zerrors\"\n@@ -23,15 +24,15 @@ const (\n \tHTTP1Host = \"x-zitadel-http1-host\"\n )\n \n-func InstanceInterceptor(verifier authz.InstanceVerifier, headerName string, explicitInstanceIdServices ...string) grpc.UnaryServerInterceptor {\n+func InstanceInterceptor(verifier authz.InstanceVerifier, headerName, externalDomain string, explicitInstanceIdServices ...string) grpc.UnaryServerInterceptor {\n \ttranslator, err := i18n.NewZitadelTranslator(language.English)\n \tlogging.OnError(err).Panic(\"unable to get translator\")\n \treturn func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n-\t\treturn setInstance(ctx, req, info, handler, verifier, headerName, translator, explicitInstanceIdServices...)\n+\t\treturn setInstance(ctx, req, info, handler, verifier, headerName, externalDomain, translator, explicitInstanceIdServices...)\n \t}\n }\n \n-func setInstance(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler, verifier authz.InstanceVerifier, headerName string, translator *i18n.Translator, idFromRequestsServices ...string) (_ interface{}, err error) {\n+func setInstance(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler, verifier authz.InstanceVerifier, headerName, externalDomain string, translator *i18n.Translator, idFromRequestsServices ...string) (_ interface{}, err error) {\n \tinterceptorCtx, span := tracing.NewServerInterceptorSpan(ctx)\n \tdefer func() { span.EndWithError(err) }()\n \tfor _, service := range idFromRequestsServices {\n@@ -55,18 +56,21 @@ func setInstance(ctx context.Context, req interface{}, info *grpc.UnaryServerInf\n \t\t\treturn handler(authz.WithInstance(ctx, instance), req)\n \t\t}\n \t}\n-\n \thost, err := hostFromContext(interceptorCtx, headerName)\n \tif err != nil {\n \t\treturn nil, status.Error(codes.NotFound, err.Error())\n \t}\n \tinstance, err := verifier.InstanceByHost(interceptorCtx, host)\n \tif err != nil {\n-\t\tnotFoundErr := new(zerrors.NotFoundError)\n-\t\tif errors.As(err, &notFoundErr) {\n-\t\t\tnotFoundErr.Message = translator.LocalizeFromCtx(ctx, notFoundErr.GetMessage(), nil)\n+\t\torigin := zitadel_http.ComposedOrigin(ctx)\n+\t\tlogging.WithFields(\"origin\", origin, \"externalDomain\", externalDomain).WithError(err).Error(\"unable to set instance\")\n+\t\tzErr := new(zerrors.ZitadelError)\n+\t\tif errors.As(err, &zErr) {\n+\t\t\tzErr.SetMessage(translator.LocalizeFromCtx(ctx, zErr.GetMessage(), nil))\n+\t\t\tzErr.Parent = err\n+\t\t\treturn nil, status.Error(codes.NotFound, fmt.Sprintf(\"unable to set instance using origin %s (ExternalDomain is %s): %s\", origin, externalDomain, zErr))\n \t\t}\n-\t\treturn nil, status.Error(codes.NotFound, err.Error())\n+\t\treturn nil, status.Error(codes.NotFound, fmt.Sprintf(\"unable to set instance using origin %s (ExternalDomain is %s)\", origin, externalDomain))\n \t}\n \tspan.End()\n \treturn handler(authz.WithInstance(ctx, instance), req)"
        },
        {
          "filename": "internal/api/grpc/server/middleware/instance_interceptor_test.go",
          "status": "modified",
          "additions": 8,
          "deletions": 7,
          "patch": "@@ -78,12 +78,13 @@ func Test_hostNameFromContext(t *testing.T) {\n \n func Test_setInstance(t *testing.T) {\n \ttype args struct {\n-\t\tctx        context.Context\n-\t\treq        interface{}\n-\t\tinfo       *grpc.UnaryServerInfo\n-\t\thandler    grpc.UnaryHandler\n-\t\tverifier   authz.InstanceVerifier\n-\t\theaderName string\n+\t\tctx            context.Context\n+\t\treq            interface{}\n+\t\tinfo           *grpc.UnaryServerInfo\n+\t\thandler        grpc.UnaryHandler\n+\t\tverifier       authz.InstanceVerifier\n+\t\theaderName     string\n+\t\texternalDomain string\n \t}\n \ttype res struct {\n \t\twant interface{}\n@@ -136,7 +137,7 @@ func Test_setInstance(t *testing.T) {\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n-\t\t\tgot, err := setInstance(tt.args.ctx, tt.args.req, tt.args.info, tt.args.handler, tt.args.verifier, tt.args.headerName, nil)\n+\t\t\tgot, err := setInstance(tt.args.ctx, tt.args.req, tt.args.info, tt.args.handler, tt.args.verifier, tt.args.headerName, \"\", nil)\n \t\t\tif (err != nil) != tt.res.err {\n \t\t\t\tt.Errorf(\"setInstance() error = %v, wantErr %v\", err, tt.res.err)\n \t\t\t\treturn"
        },
        {
          "filename": "internal/api/grpc/server/server.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -39,6 +39,7 @@ func CreateServer(\n \tauthConfig authz.Config,\n \tqueries *query.Queries,\n \thostHeaderName string,\n+\texternalDomain string,\n \ttlsConfig *tls.Config,\n \taccessSvc *logstore.Service[*record.AccessLog],\n ) *grpc.Server {\n@@ -50,7 +51,7 @@ func CreateServer(\n \t\t\t\tmiddleware.DefaultTracingServer(),\n \t\t\t\tmiddleware.MetricsHandler(metricTypes, grpc_api.Probes...),\n \t\t\t\tmiddleware.NoCacheInterceptor(),\n-\t\t\t\tmiddleware.InstanceInterceptor(queries, hostHeaderName, system_pb.SystemService_ServiceDesc.ServiceName, healthpb.Health_ServiceDesc.ServiceName),\n+\t\t\t\tmiddleware.InstanceInterceptor(queries, hostHeaderName, externalDomain, system_pb.SystemService_ServiceDesc.ServiceName, healthpb.Health_ServiceDesc.ServiceName),\n \t\t\t\tmiddleware.AccessStorageInterceptor(accessSvc),\n \t\t\t\tmiddleware.ErrorHandler(),\n \t\t\t\tmiddleware.LimitsInterceptor(system_pb.SystemService_ServiceDesc.ServiceName),"
        },
        {
          "filename": "internal/api/http/middleware/instance_interceptor.go",
          "status": "modified",
          "additions": 16,
          "deletions": 11,
          "patch": "@@ -19,16 +19,17 @@ import (\n )\n \n type instanceInterceptor struct {\n-\tverifier        authz.InstanceVerifier\n-\theaderName      string\n-\tignoredPrefixes []string\n-\ttranslator      *i18n.Translator\n+\tverifier                   authz.InstanceVerifier\n+\theaderName, externalDomain string\n+\tignoredPrefixes            []string\n+\ttranslator                 *i18n.Translator\n }\n \n-func InstanceInterceptor(verifier authz.InstanceVerifier, headerName string, ignoredPrefixes ...string) *instanceInterceptor {\n+func InstanceInterceptor(verifier authz.InstanceVerifier, headerName, externalDomain string, ignoredPrefixes ...string) *instanceInterceptor {\n \treturn &instanceInterceptor{\n \t\tverifier:        verifier,\n \t\theaderName:      headerName,\n+\t\texternalDomain:  externalDomain,\n \t\tignoredPrefixes: ignoredPrefixes,\n \t\ttranslator:      newZitadelTranslator(),\n \t}\n@@ -55,11 +56,15 @@ func (a *instanceInterceptor) handleInstance(w http.ResponseWriter, r *http.Requ\n \t}\n \tctx, err := setInstance(r, a.verifier, a.headerName)\n \tif err != nil {\n-\t\tcaosErr := new(zerrors.NotFoundError)\n-\t\tif errors.As(err, &caosErr) {\n-\t\t\tcaosErr.Message = a.translator.LocalizeFromRequest(r, caosErr.GetMessage(), nil)\n+\t\torigin := zitadel_http.ComposedOrigin(r.Context())\n+\t\tlogging.WithFields(\"origin\", origin, \"externalDomain\", a.externalDomain).WithError(err).Error(\"unable to set instance\")\n+\t\tzErr := new(zerrors.ZitadelError)\n+\t\tif errors.As(err, &zErr) {\n+\t\t\tzErr.SetMessage(a.translator.LocalizeFromRequest(r, zErr.GetMessage(), nil))\n+\t\t\thttp.Error(w, fmt.Sprintf(\"unable to set instance using origin %s (ExternalDomain is %s): %s\", origin, a.externalDomain, zErr), http.StatusNotFound)\n+\t\t\treturn\n \t\t}\n-\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n+\t\thttp.Error(w, fmt.Sprintf(\"unable to set instance using origin %s (ExternalDomain is %s)\", origin, a.externalDomain), http.StatusNotFound)\n \t\treturn\n \t}\n \tr = r.WithContext(ctx)\n@@ -68,13 +73,13 @@ func (a *instanceInterceptor) handleInstance(w http.ResponseWriter, r *http.Requ\n \n func setInstance(r *http.Request, verifier authz.InstanceVerifier, headerName string) (_ context.Context, err error) {\n \tctx := r.Context()\n-\n \tauthCtx, span := tracing.NewServerInterceptorSpan(ctx)\n \tdefer func() { span.EndWithError(err) }()\n \n \thost, err := HostFromRequest(r, headerName)\n+\n \tif err != nil {\n-\t\treturn nil, zerrors.ThrowNotFound(err, \"INST-zWq7X\", \"Errors.Instance.NotFound\")\n+\t\treturn nil, zerrors.ThrowNotFound(err, \"INST-zWq7X\", \"Errors.IAM.NotFound\")\n \t}\n \n \tinstance, err := verifier.InstanceByHost(authCtx, host)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 7,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "84997ffe1aaaebe8ed97edd689242f7d3fca6fd3",
            "date": "2025-01-14T13:15:59Z",
            "author_login": "stebenz"
          },
          {
            "sha": "e2a2e13d44e9c86ebbc65153e0a40cbbae873df8",
            "date": "2025-01-14T06:49:26Z",
            "author_login": "stebenz"
          },
          {
            "sha": "9c7f2a7d50e689104929e8fcda86ea8afc3ba26d",
            "date": "2025-01-10T11:15:06Z",
            "author_login": "latonz"
          },
          {
            "sha": "b0bcb051fcee9903ccce31c7d5afae7ee44f3ce3",
            "date": "2025-01-10T10:30:26Z",
            "author_login": "dennypenta"
          },
          {
            "sha": "af09e51b1eeddefa524f94424c431f4ac9b016d5",
            "date": "2025-01-09T14:12:13Z",
            "author_login": "latonz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "Zitadel is an open source identity management system. In case ZITADEL could not connect to the database, connection information including db name, username and db host name could be returned to the user. This has been addressed in all supported release branches in a point release. There is no workaround since a patch is already available. Users are advised to upgrade.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-01T07:15:40.537",
    "last_modified": "2025-01-08T18:30:33.600",
    "fix_date": "2024-04-23T08:35:25Z"
  },
  "references": [
    {
      "url": "https://github.com/zitadel/zitadel/commit/b918603b576d156a08b90917c14c2d019c82ffc6",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.45.7",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.46.7",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.47.10",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.48.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.49.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.50.3",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/security/advisories/GHSA-q5qj-x2h5-3945",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/commit/b918603b576d156a08b90917c14c2d019c82ffc6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.45.7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.46.7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.47.10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.48.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.49.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.50.3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/security/advisories/GHSA-q5qj-x2h5-3945",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:07.045670",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zitadel",
    "owner": "zitadel",
    "created_at": "2020-03-16T13:51:31Z",
    "updated_at": "2025-01-14T13:16:05Z",
    "pushed_at": "2025-01-14T13:16:01Z",
    "size": 473588,
    "stars": 9434,
    "forks": 615,
    "open_issues": 654,
    "watchers": 9434,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.87.x",
      "alpha"
    ],
    "languages": {
      "Go": 14957664,
      "TypeScript": 1840621,
      "HTML": 757763,
      "SCSS": 351027,
      "CSS": 112445,
      "JavaScript": 28231,
      "PLpgSQL": 13669,
      "Makefile": 9966,
      "Dockerfile": 9249,
      "Shell": 238
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:18:03.409729"
  }
}