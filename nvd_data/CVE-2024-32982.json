{
  "cve_id": "CVE-2024-32982",
  "github_data": {
    "repository": "litestar-org/litestar",
    "fix_commit": "57e706e7effdc182fc9a2af5981bc88afb21851b",
    "related_commits": [
      "57e706e7effdc182fc9a2af5981bc88afb21851b",
      "57e706e7effdc182fc9a2af5981bc88afb21851b"
    ],
    "patch_url": "https://github.com/litestar-org/litestar/commit/57e706e7effdc182fc9a2af5981bc88afb21851b.patch",
    "fix_commit_details": {
      "sha": "57e706e7effdc182fc9a2af5981bc88afb21851b",
      "commit_date": "2024-05-06T06:37:34Z",
      "author": {
        "login": "JacobCoffee",
        "type": "User",
        "stats": {
          "total_commits": 213,
          "average_weekly_commits": 1.3067484662576687,
          "total_additions": 30370,
          "total_deletions": 18076,
          "weeks_active": 66
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-83pv-qr33-2vcf",
        "length": 409,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 138,
        "additions": 130,
        "deletions": 8
      },
      "files": [
        {
          "filename": "litestar/static_files/base.py",
          "status": "modified",
          "additions": 15,
          "deletions": 5,
          "patch": "@@ -1,6 +1,7 @@\n+# ruff: noqa: PTH118\n from __future__ import annotations\n \n-from os.path import commonpath\n+import os.path\n from pathlib import Path\n from typing import TYPE_CHECKING, Literal, Sequence\n \n@@ -12,7 +13,6 @@\n \n __all__ = (\"StaticFiles\",)\n \n-\n if TYPE_CHECKING:\n     from litestar.types import Receive, Scope, Send\n     from litestar.types.composite_types import PathType\n@@ -45,7 +45,9 @@ def __init__(\n             headers: Headers that will be sent with every response.\n         \"\"\"\n         self.adapter = FileSystemAdapter(file_system)\n-        self.directories = tuple(Path(p).resolve() if resolve_symlinks else Path(p) for p in directories)\n+        self.directories = tuple(\n+            os.path.normpath(Path(p).resolve() if resolve_symlinks else Path(p)) for p in directories\n+        )\n         self.is_html_mode = is_html_mode\n         self.send_as_attachment = send_as_attachment\n         self.headers = headers\n@@ -55,6 +57,12 @@ async def get_fs_info(\n     ) -> tuple[Path, FileInfo] | tuple[None, None]:\n         \"\"\"Return the resolved path and a :class:`stat_result <os.stat_result>`.\n \n+        .. versionchanged:: 2.8.3\n+\n+            Prevent `CVE-2024-32982 <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-32982>`_\n+            by ensuring that the resolved path is within the configured directory as part of `advisory\n+            GHSA-83pv-qr33-2vcf <https://github.com/advisories/GHSA-83pv-qr33-2vcf>`_.\n+\n         Args:\n             directories: A list of directory paths.\n             file_path: A file path to resolve\n@@ -66,8 +74,10 @@ async def get_fs_info(\n         for directory in directories:\n             try:\n                 joined_path = Path(directory, file_path)\n-                file_info = await self.adapter.info(joined_path)\n-                if file_info and commonpath([str(directory), file_info[\"name\"], joined_path]) == str(directory):\n+                normalized_file_path = os.path.normpath(joined_path)\n+                if os.path.commonpath([directory, normalized_file_path]) == str(directory) and (\n+                    file_info := await self.adapter.info(joined_path)\n+                ):\n                     return joined_path, file_info\n             except FileNotFoundError:\n                 continue"
        },
        {
          "filename": "tests/e2e/test_routing/test_path_resolution.py",
          "status": "modified",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -360,3 +360,51 @@ async def pathfinder(path: Optional[Path]) -> str:\n \n     assert httpx.get(\"http://127.0.0.1:9999/\").text == \"None\"\n     assert httpx.get(\"http://127.0.0.1:9999/something\").text == \"/something\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"server_command\",\n+    [\n+        pytest.param([\"uvicorn\", \"app:app\", \"--port\", \"9999\", \"--root-path\", \"/test\"], id=\"uvicorn\"),\n+        pytest.param([\"hypercorn\", \"app:app\", \"--bind\", \"127.0.0.1:9999\", \"--root-path\", \"/test\"], id=\"hypercorn\"),\n+        pytest.param([\"daphne\", \"app:app\", \"--port\", \"9999\", \"--root-path\", \"/test\"], id=\"daphne\"),\n+    ],\n+)\n+@pytest.mark.xdist_group(\"live_server_test\")\n+@pytest.mark.server_integration\n+def test_no_path_traversal_from_static_directory(\n+    tmp_path: Path, monkeypatch: MonkeyPatch, server_command: List[str], run_server: Callable[[str, List[str]], None]\n+) -> None:\n+    import http.client\n+\n+    static = tmp_path / \"static\"\n+    static.mkdir()\n+    (static / \"index.html\").write_text(\"Hello, World!\")\n+\n+    app = \"\"\"\n+from pathlib import Path\n+from litestar import Litestar\n+from litestar.static_files import create_static_files_router\n+import uvicorn\n+\n+app = Litestar(\n+    route_handlers=[\n+        create_static_files_router(path=\"/static\", directories=[\"static\"]),\n+    ],\n+)\n+    \"\"\"\n+\n+    def send_request(host: str, port: int, path: str) -> http.client.HTTPResponse:\n+        connection = http.client.HTTPConnection(host, port)\n+        connection.request(\"GET\", path)\n+        resp = connection.getresponse()\n+        connection.close()\n+        return resp\n+\n+    run_server(app, server_command)\n+\n+    response = send_request(\"127.0.0.1\", 9999, \"/static/index.html\")\n+    assert response.status == 200\n+\n+    response = send_request(\"127.0.0.1\", 9999, \"/static/../app.py\")\n+    assert response.status == 404"
        },
        {
          "filename": "tests/unit/test_static_files/test_file_serving_resolution.py",
          "status": "modified",
          "additions": 29,
          "deletions": 1,
          "patch": "@@ -10,7 +10,7 @@\n from typing_extensions import TypeAlias\n \n from litestar import MediaType, Router, get\n-from litestar.static_files import StaticFilesConfig, create_static_files_router\n+from litestar.static_files import StaticFiles, StaticFilesConfig, create_static_files_router\n from litestar.status_codes import HTTP_200_OK\n from litestar.testing import create_test_client\n from tests.unit.test_static_files.conftest import MakeConfig\n@@ -295,3 +295,31 @@ def test_resolve_symlinks(tmp_path: Path, resolve: bool) -> None:\n             assert client.get(\"/test.txt\").status_code == 404\n         else:\n             assert client.get(\"/test.txt\").status_code == 200\n+\n+\n+async def test_staticfiles_get_fs_info_no_access_to_non_static_directory(\n+    tmp_path: Path,\n+    file_system: FileSystemProtocol,\n+) -> None:\n+    assets = tmp_path / \"assets\"\n+    assets.mkdir()\n+    index = tmp_path / \"index.html\"\n+    index.write_text(\"content\", \"utf-8\")\n+    static_files = StaticFiles(is_html_mode=False, directories=[assets], file_system=file_system)\n+    path, info = await static_files.get_fs_info([assets], \"../index.html\")\n+    assert path is None\n+    assert info is None\n+\n+\n+async def test_staticfiles_get_fs_info_no_access_to_non_static_file_with_prefix(\n+    tmp_path: Path,\n+    file_system: FileSystemProtocol,\n+) -> None:\n+    static = tmp_path / \"static\"\n+    static.mkdir()\n+    private_file = tmp_path / \"staticsecrets.env\"\n+    private_file.write_text(\"content\", \"utf-8\")\n+    static_files = StaticFiles(is_html_mode=False, directories=[static], file_system=file_system)\n+    path, info = await static_files.get_fs_info([static], \"../staticsecrets.env\")\n+    assert path is None\n+    assert info is None"
        },
        {
          "filename": "tests/unit/test_static_files/test_static_files_validation.py",
          "status": "modified",
          "additions": 38,
          "deletions": 2,
          "patch": "@@ -1,4 +1,6 @@\n-from typing import TYPE_CHECKING, Any, List\n+import asyncio\n+from pathlib import Path, PosixPath\n+from typing import TYPE_CHECKING, Any, List, cast\n \n import pytest\n \n@@ -9,7 +11,7 @@\n from litestar.testing import create_test_client\n \n if TYPE_CHECKING:\n-    from pathlib import Path\n+    from litestar.static_files import StaticFiles\n \n \n @pytest.mark.parametrize(\"directories\", [[], [\"\"]])\n@@ -113,3 +115,37 @@ def test_runtime_validation_of_request_method_create_handler(tmpdir: \"Path\", met\n     with create_test_client(create_static_files_router(path=\"/static\", directories=[tmpdir])) as client:\n         response = client.request(method, \"/static/test.txt\")\n         assert response.status_code == expected\n+\n+\n+def test_config_validation_of_path_prevents_directory_traversal(tmpdir: \"Path\") -> None:\n+    # Setup: Create a 'secret.txt' outside the static directory to simulate sensitive file\n+    secret_path = Path(tmpdir) / \"../secret.txt\"\n+    secret_path.write_text(\"This is a secret file.\", encoding=\"utf-8\")\n+\n+    # Setup: Create 'test.txt' inside the static directory\n+    test_file_path = Path(tmpdir) / \"test.txt\"\n+    test_file_path.write_text(\"This is a test file.\", encoding=\"utf-8\")\n+\n+    # Get StaticFiles handler\n+    config = StaticFilesConfig(path=\"/static\", directories=[tmpdir])\n+    asgi_router = config.to_static_files_app()\n+    static_files_handler = cast(\"StaticFiles\", asgi_router.fn)\n+\n+    # Resolve file path with the StaticFiles handler\n+    string_path = Path(\"../secret.txt\").as_posix()\n+\n+    coroutine = static_files_handler.get_fs_info(directories=static_files_handler.directories, file_path=string_path)\n+    resolved_path, fs_info = asyncio.run(coroutine)\n+\n+    assert resolved_path is None  # Because the resolved path is outside the static directory\n+    assert fs_info is None  # Because the file doesn't exist, so there is no info\n+\n+    # Resolve file path with the StaticFiles handler\n+    string_path = Path(\"test.txt\").as_posix()\n+\n+    coroutine = static_files_handler.get_fs_info(directories=static_files_handler.directories, file_path=string_path)\n+    resolved_path, fs_info = asyncio.run(coroutine)\n+\n+    expected_resolved_path = PosixPath(str(tmpdir / \"test.txt\"))\n+    assert resolved_path == expected_resolved_path  # Because the resolved path is inside the static directory\n+    assert fs_info is not None  # Because the file exists, so there is info"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b140afb8ef8f60cab8a89c5d2afeb67cb3fbeb0b",
            "date": "2025-01-13T07:16:12Z",
            "author_login": "euri10"
          },
          {
            "sha": "2db1f4d2131d9902af15e00312e1673d0b3d0a61",
            "date": "2025-01-11T19:24:15Z",
            "author_login": "provinzkraut"
          },
          {
            "sha": "a814224eaeebae7511ec4ae5ad90559c6e26c6e1",
            "date": "2025-01-10T03:58:19Z",
            "author_login": "JacobCoffee"
          },
          {
            "sha": "79827933ac01fe0d8a0ad44498b173ae14023b0d",
            "date": "2025-01-10T02:56:10Z",
            "author_login": "cofin"
          },
          {
            "sha": "b09a549c4f0564cb19ff97cc2410b11afea297da",
            "date": "2025-01-10T02:47:15Z",
            "author_login": "cofin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.2,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N",
    "cwe_id": "CWE-22",
    "description": "Litestar and Starlite is an Asynchronous Server Gateway Interface (ASGI) framework. Prior to 2.8.3, 2.7.2, and 2.6.4, a Local File Inclusion (LFI) vulnerability has been discovered in the static file serving component of LiteStar. This vulnerability allows attackers to exploit path traversal flaws, enabling unauthorized access to sensitive files outside the designated directories. Such access can lead to the disclosure of sensitive information or potentially compromise the server. The vulnerability is located in the file path handling mechanism within the static content serving function, specifically at `litestar/static_files/base.py`. This vulnerability is fixed in versions 2.8.3, 2.7.2, and 2.6.4.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-06T15:15:23.330",
    "last_modified": "2024-11-21T09:16:09.857",
    "fix_date": "2024-05-06T06:37:34Z"
  },
  "references": [
    {
      "url": "https://github.com/litestar-org/litestar/blob/main/litestar/static_files/base.py#L70",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/litestar-org/litestar/commit/57e706e7effdc182fc9a2af5981bc88afb21851b",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/litestar-org/litestar/security/advisories/GHSA-83pv-qr33-2vcf",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/litestar-org/litestar/blob/main/litestar/static_files/base.py#L70",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/litestar-org/litestar/commit/57e706e7effdc182fc9a2af5981bc88afb21851b",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/litestar-org/litestar/security/advisories/GHSA-83pv-qr33-2vcf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.861511",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "litestar",
    "owner": "litestar-org",
    "created_at": "2021-12-06T19:43:06Z",
    "updated_at": "2025-01-14T16:47:30Z",
    "pushed_at": "2025-01-13T18:57:11Z",
    "size": 127636,
    "stars": 5810,
    "forks": 390,
    "open_issues": 195,
    "watchers": 5810,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.51",
      "release-2.9.1",
      "release-2.10.0",
      "release-2.11.0",
      "v3.0"
    ],
    "languages": {
      "Python": 3474135,
      "Makefile": 5351,
      "HTML": 1855,
      "CSS": 1830,
      "JavaScript": 920,
      "Lua": 848,
      "Dockerfile": 689
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:06:23.650164"
  }
}