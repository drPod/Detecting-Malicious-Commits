{
  "cve_id": "CVE-2024-34068",
  "github_data": {
    "repository": "pterodactyl/wings",
    "fix_commit": "c152e36101aba45d8868a9a0eeb890995e8934b8",
    "related_commits": [
      "c152e36101aba45d8868a9a0eeb890995e8934b8",
      "c152e36101aba45d8868a9a0eeb890995e8934b8"
    ],
    "patch_url": "https://github.com/pterodactyl/wings/commit/c152e36101aba45d8868a9a0eeb890995e8934b8.patch",
    "fix_commit_details": {
      "sha": "c152e36101aba45d8868a9a0eeb890995e8934b8",
      "commit_date": "2024-04-10T21:22:09Z",
      "author": {
        "login": "matthewpi",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "downloader: move internal subnet validation into http Transport",
        "length": 63,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 125,
        "additions": 52,
        "deletions": 73
      },
      "files": [
        {
          "filename": "router/downloader/downloader.go",
          "status": "modified",
          "additions": 52,
          "deletions": 73,
          "patch": "@@ -20,20 +20,58 @@ import (\n \t\"github.com/pterodactyl/wings/server\"\n )\n \n-var client = &http.Client{\n-\tTimeout: time.Hour * 12,\n-\t// Disallow any redirect on an HTTP call. This is a security requirement: do not modify\n-\t// this logic without first ensuring that the new target location IS NOT within the current\n-\t// instance's local network.\n-\t//\n-\t// This specific error response just causes the client to not follow the redirect and\n-\t// returns the actual redirect response to the caller. Not perfect, but simple and most\n-\t// people won't be using URLs that redirect anyways hopefully?\n-\t//\n-\t// We'll re-evaluate this down the road if needed.\n-\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n-\t\treturn http.ErrUseLastResponse\n-\t},\n+var client *http.Client\n+\n+func init() {\n+\tdialer := &net.Dialer{\n+\t\tLocalAddr: nil,\n+\t}\n+\n+\ttrnspt := http.DefaultTransport.(*http.Transport).Clone()\n+\ttrnspt.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n+\t\tc, err := dialer.DialContext(ctx, network, addr)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.WithStack(err)\n+\t\t}\n+\n+\t\tipStr, _, err := net.SplitHostPort(c.RemoteAddr().String())\n+\t\tif err != nil {\n+\t\t\treturn c, errors.WithStack(err)\n+\t\t}\n+\t\tip := net.ParseIP(ipStr)\n+\t\tif ip == nil {\n+\t\t\treturn c, errors.WithStack(ErrInvalidIPAddress)\n+\t\t}\n+\t\tif ip.IsLoopback() || ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() || ip.IsInterfaceLocalMulticast() {\n+\t\t\treturn c, errors.WithStack(ErrInternalResolution)\n+\t\t}\n+\t\tfor _, block := range internalRanges {\n+\t\t\tif !block.Contains(ip) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn c, errors.WithStack(ErrInternalResolution)\n+\t\t}\n+\t\treturn c, nil\n+\t}\n+\n+\tclient = &http.Client{\n+\t\tTimeout: time.Hour * 12,\n+\n+\t\tTransport: trnspt,\n+\n+\t\t// Disallow any redirect on an HTTP call. This is a security requirement: do not modify\n+\t\t// this logic without first ensuring that the new target location IS NOT within the current\n+\t\t// instance's local network.\n+\t\t//\n+\t\t// This specific error response just causes the client to not follow the redirect and\n+\t\t// returns the actual redirect response to the caller. Not perfect, but simple and most\n+\t\t// people won't be using URLs that redirect anyways hopefully?\n+\t\t//\n+\t\t// We'll re-evaluate this down the road if needed.\n+\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n+\t\t\treturn http.ErrUseLastResponse\n+\t\t},\n+\t}\n }\n \n var instance = &Downloader{\n@@ -143,12 +181,6 @@ func (dl *Download) Execute() error {\n \tdl.cancelFunc = &cancel\n \tdefer dl.Cancel()\n \n-\t// Always ensure that we're checking the destination for the download to avoid a malicious\n-\t// user from accessing internal network resources.\n-\tif err := dl.isExternalNetwork(ctx); err != nil {\n-\t\treturn err\n-\t}\n-\n \t// At this point we have verified the destination is not within the local network, so we can\n \t// now make a request to that URL and pull down the file, saving it to the server's data\n \t// directory.\n@@ -243,59 +275,6 @@ func (dl *Download) counter(contentLength int64) *Counter {\n \t}\n }\n \n-// Verifies that a given download resolves to a location not within the current local\n-// network for the machine. If the final destination of a resource is within the local\n-// network an ErrInternalResolution error is returned.\n-func (dl *Download) isExternalNetwork(ctx context.Context) error {\n-\tdialer := &net.Dialer{\n-\t\tLocalAddr: nil,\n-\t}\n-\n-\thost := dl.req.URL.Host\n-\n-\t// This cluster-fuck of math and integer shit converts an integer IP into a proper IPv4.\n-\t// For example: 16843009 would become 1.1.1.1\n-\t//if i, err := strconv.ParseInt(host, 10, 64); err == nil {\n-\t//\thost = strconv.FormatInt((i>>24)&0xFF, 10) + \".\" + strconv.FormatInt((i>>16)&0xFF, 10) + \".\" + strconv.FormatInt((i>>8)&0xFF, 10) + \".\" + strconv.FormatInt(i&0xFF, 10)\n-\t//}\n-\n-\tif _, _, err := net.SplitHostPort(host); err != nil {\n-\t\tif !strings.Contains(err.Error(), \"missing port in address\") {\n-\t\t\treturn errors.WithStack(err)\n-\t\t}\n-\t\tswitch dl.req.URL.Scheme {\n-\t\tcase \"http\":\n-\t\t\thost += \":80\"\n-\t\tcase \"https\":\n-\t\t\thost += \":443\"\n-\t\t}\n-\t}\n-\n-\tc, err := dialer.DialContext(ctx, \"tcp\", host)\n-\tif err != nil {\n-\t\treturn errors.WithStack(err)\n-\t}\n-\t_ = c.Close()\n-\n-\tipStr, _, err := net.SplitHostPort(c.RemoteAddr().String())\n-\tif err != nil {\n-\t\treturn errors.WithStack(err)\n-\t}\n-\tip := net.ParseIP(ipStr)\n-\tif ip == nil {\n-\t\treturn errors.WithStack(ErrInvalidIPAddress)\n-\t}\n-\tif ip.IsLoopback() || ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() || ip.IsInterfaceLocalMulticast() {\n-\t\treturn errors.WithStack(ErrInternalResolution)\n-\t}\n-\tfor _, block := range internalRanges {\n-\t\tif block.Contains(ip) {\n-\t\t\treturn errors.WithStack(ErrInternalResolution)\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n // Downloader represents a global downloader that keeps track of all currently processing downloads\n // for the machine.\n type Downloader struct {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "c6c235dbc07341d5f50606819624a2e4770648a7",
            "date": "2025-01-12T22:28:46Z",
            "author_login": "matthewpi"
          },
          {
            "sha": "a55277da471a7b559e7fa45bb07024b7629e7ba2",
            "date": "2025-01-12T21:45:16Z",
            "author_login": "matthewpi"
          },
          {
            "sha": "76a9f6dc5a3396a8e3b71fa1ebe2dcfa3ad93b3c",
            "date": "2025-01-12T21:25:34Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "0e96ef3edffe9978a13553b907899fdfe30d80c6",
            "date": "2025-01-12T21:25:19Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1dee350268f632045203cf892f186e9c45f55a84",
            "date": "2025-01-12T21:22:18Z",
            "author_login": "matthewpi"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N",
    "cwe_id": "CWE-284",
    "description": "Pterodactyl wings is the server control plane for Pterodactyl Panel. An authenticated user who has access to a game server is able to bypass the previously implemented access control (GHSA-6rg3-8h8x-5xfv) that prevents accessing internal endpoints of the node hosting Wings in the pull endpoint. This would allow malicious users to potentially access resources on local networks that would otherwise be inaccessible. This issue has been addressed in version 1.11.2 and users are advised to upgrade. Users unable to upgrade may enable the `api.disable_remote_download` option as a workaround. ",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-03T18:15:09.773",
    "last_modified": "2024-11-21T09:18:01.393",
    "fix_date": "2024-04-10T21:22:09Z"
  },
  "references": [
    {
      "url": "https://github.com/pterodactyl/wings/commit/c152e36101aba45d8868a9a0eeb890995e8934b8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-6rg3-8h8x-5xfv",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-qq22-jj8x-4wwv",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/commit/c152e36101aba45d8868a9a0eeb890995e8934b8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-6rg3-8h8x-5xfv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-qq22-jj8x-4wwv",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.851082",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "wings",
    "owner": "pterodactyl",
    "created_at": "2017-05-17T10:49:28Z",
    "updated_at": "2025-01-13T06:01:10Z",
    "pushed_at": "2025-01-12T22:32:13Z",
    "size": 3463,
    "stars": 769,
    "forks": 335,
    "open_issues": 18,
    "watchers": 769,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [
      "develop"
    ],
    "languages": {
      "Go": 651888,
      "Nix": 1270,
      "Makefile": 963,
      "Dockerfile": 697,
      "Shell": 10
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:17:48.763579"
  }
}