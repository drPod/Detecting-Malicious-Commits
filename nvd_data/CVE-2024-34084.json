{
  "cve_id": "CVE-2024-34084",
  "github_data": {
    "repository": "stacklok/minder",
    "fix_commit": "3e5a527d2f1b535159206161d1d519602c75bd0d",
    "related_commits": [
      "3e5a527d2f1b535159206161d1d519602c75bd0d",
      "3e5a527d2f1b535159206161d1d519602c75bd0d"
    ],
    "patch_url": "https://github.com/stacklok/minder/commit/3e5a527d2f1b535159206161d1d519602c75bd0d.patch",
    "fix_commit_details": {
      "sha": "3e5a527d2f1b535159206161d1d519602c75bd0d",
      "commit_date": "2024-05-07T07:05:45Z",
      "author": {
        "login": "JAORMX",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-9c5w-9q3f-3hv7",
        "length": 98,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 88,
        "additions": 84,
        "deletions": 4
      },
      "files": [
        {
          "filename": "internal/controlplane/handlers_githubwebhooks_test.go",
          "status": "modified",
          "additions": 69,
          "deletions": 0,
          "patch": "@@ -21,8 +21,10 @@ import (\n \t\"database/sql\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io\"\n \t\"net/http\"\n \t\"os\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n@@ -436,6 +438,73 @@ func (s *UnitTestSuite) TestNoopWebhookHandler() {\n \tassert.Equal(t, http.StatusOK, resp.StatusCode, \"unexpected status code\")\n }\n \n+func (s *UnitTestSuite) TestHandleWebHookWithTooLargeRequest() {\n+\tt := s.T()\n+\tt.Parallel()\n+\n+\tctrl := gomock.NewController(t)\n+\tdefer ctrl.Finish()\n+\n+\tmockStore := mockdb.NewMockStore(ctrl)\n+\tsrv, evt := newDefaultServer(t, mockStore, nil)\n+\tdefer evt.Close()\n+\n+\tpq := testqueue.NewPassthroughQueue(t)\n+\tqueued := pq.GetQueue()\n+\n+\tevt.Register(events.TopicQueueEntityEvaluate, pq.Pass)\n+\n+\tgo func() {\n+\t\terr := evt.Run(context.Background())\n+\t\trequire.NoError(t, err, \"failed to run eventer\")\n+\t}()\n+\n+\t<-evt.Running()\n+\n+\thook := withMaxSizeMiddleware(srv.HandleGitHubWebHook())\n+\tport, err := rand.GetRandomPort()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\taddr := fmt.Sprintf(\"localhost:%d\", port)\n+\tserver := &http.Server{\n+\t\tAddr:              fmt.Sprintf(\":%d\", port),\n+\t\tHandler:           hook,\n+\t\tReadHeaderTimeout: 1 * time.Second,\n+\t}\n+\tgo server.ListenAndServe()\n+\n+\tevent := github.PackageEvent{\n+\t\tAction: github.String(\"published\"),\n+\t\tRepo: &github.Repository{\n+\t\t\tID:   github.Int64(12345),\n+\t\t\tName: github.String(\"stacklok/minder\"),\n+\t\t},\n+\t\tOrg: &github.Organization{\n+\t\t\tLogin: github.String(\"stacklok\"),\n+\t\t},\n+\t}\n+\tpackageJson, err := json.Marshal(event)\n+\trequire.NoError(t, err, \"failed to marshal package event\")\n+\n+\tmaliciousBody := strings.NewReader(strings.Repeat(\"1337\", 1000000000))\n+\tmaliciousBodyReader := io.MultiReader(maliciousBody, maliciousBody, maliciousBody, maliciousBody, maliciousBody)\n+\t_ = packageJson\n+\n+\tclient := &http.Client{}\n+\treq, err := http.NewRequest(\"POST\", fmt.Sprintf(\"http://%s\", addr), maliciousBodyReader)\n+\trequire.NoError(t, err, \"failed to create request\")\n+\n+\treq.Header.Add(\"X-GitHub-Event\", \"meta\")\n+\treq.Header.Add(\"X-GitHub-Delivery\", \"12345\")\n+\treq.Header.Add(\"Content-Type\", \"application/json\")\n+\tresp, err := httpDoWithRetry(client, req)\n+\trequire.NoError(t, err, \"failed to make request\")\n+\t// We expect OK since we don't want to leak information about registered repositories\n+\trequire.Equal(t, http.StatusBadRequest, resp.StatusCode, \"unexpected status code\")\n+\tassert.Len(t, queued, 0)\n+}\n+\n func TestAll(t *testing.T) {\n \tt.Parallel()\n "
        },
        {
          "filename": "internal/controlplane/server.go",
          "status": "modified",
          "additions": 15,
          "deletions": 4,
          "patch": "@@ -70,6 +70,10 @@ const metricsPath = \"/metrics\"\n \n var (\n \treadHeaderTimeout = 2 * time.Second\n+\n+\t// RequestBodyMaxBytes is the maximum number of bytes that can be read from a request body\n+\t// We limit to 2MB for now\n+\tRequestBodyMaxBytes int64 = 2 << 20\n )\n \n // Server represents the controlplane server\n@@ -316,10 +320,10 @@ func (s *Server) StartHTTPServer(ctx context.Context) error {\n \t\treturn fmt.Errorf(\"failed to register GitHub App callback handler: %w\", err)\n \t}\n \n-\tmux.Handle(\"/\", s.handlerWithHTTPMiddleware(gwmux))\n-\tmux.Handle(\"/api/v1/webhook/\", mw(s.HandleGitHubWebHook()))\n-\tmux.Handle(\"/api/v1/ghapp/\", mw(s.HandleGitHubAppWebhook()))\n-\tmux.Handle(\"/api/v1/gh-marketplace/\", mw(s.NoopWebhookHandler()))\n+\tmux.Handle(\"/\", withMaxSizeMiddleware(s.handlerWithHTTPMiddleware(gwmux)))\n+\tmux.Handle(\"/api/v1/webhook/\", mw(withMaxSizeMiddleware(s.HandleGitHubWebHook())))\n+\tmux.Handle(\"/api/v1/ghapp/\", mw(withMaxSizeMiddleware(s.HandleGitHubAppWebhook())))\n+\tmux.Handle(\"/api/v1/gh-marketplace/\", mw(withMaxSizeMiddleware(s.NoopWebhookHandler())))\n \tmux.Handle(\"/static/\", fs)\n \n \terrch := make(chan error)\n@@ -451,3 +455,10 @@ func shutdownHandler(component string, sdf shutdowner) {\n \t\tlog.Fatal().Msgf(\"error shutting down '%s': %+v\", component, err)\n \t}\n }\n+\n+func withMaxSizeMiddleware(h http.Handler) http.Handler {\n+\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tr.Body = http.MaxBytesReader(w, r.Body, RequestBodyMaxBytes)\n+\t\th.ServeHTTP(w, r)\n+\t})\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8373b8030ec90dbde8a19dd9b7a7f5c3639112d3",
            "date": "2025-01-14T11:22:31Z",
            "author_login": "eleftherias"
          },
          {
            "sha": "0a089beb20a3e819fa4b730bf40bac7728164050",
            "date": "2025-01-14T08:53:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "95e9036cf631a5162e31541f2cdecd5bb08c77e6",
            "date": "2025-01-14T08:53:08Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ca1e9121478cf27cb183e20c3afea7ba980081ba",
            "date": "2025-01-14T08:20:16Z",
            "author_login": "JAORMX"
          },
          {
            "sha": "cc38ccde3608df3370d4eb8e71a12d08f46dde1b",
            "date": "2025-01-14T08:10:17Z",
            "author_login": "JAORMX"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Minder's `HandleGithubWebhook` is susceptible to a denial of service attack from an untrusted HTTP request. The vulnerability exists before the request has been validated, and as such the request is still untrusted at the point of failure. This allows an attacker with the ability to send requests to `HandleGithubWebhook` to crash the Minder controlplane and deny other users from using it. This vulnerability is fixed in 0.0.48.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-07T15:15:09.540",
    "last_modified": "2024-11-21T09:18:03.513",
    "fix_date": "2024-05-07T07:05:45Z"
  },
  "references": [
    {
      "url": "https://github.com/stacklok/minder/commit/3e5a527d2f1b535159206161d1d519602c75bd0d",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/security/advisories/GHSA-9c5w-9q3f-3hv7",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/commit/3e5a527d2f1b535159206161d1d519602c75bd0d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/security/advisories/GHSA-9c5w-9q3f-3hv7",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:20.871034",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "minder",
    "owner": "stacklok",
    "created_at": "2023-04-05T16:47:15Z",
    "updated_at": "2025-01-14T15:03:03Z",
    "pushed_at": "2025-01-14T11:22:31Z",
    "size": 129864,
    "stars": 306,
    "forks": 41,
    "open_issues": 125,
    "watchers": 306,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 3893376,
      "PLpgSQL": 125512,
      "Makefile": 14093,
      "Dockerfile": 3059,
      "HTML": 2450,
      "Shell": 1410,
      "Smarty": 538,
      "CSS": 429
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:37:25.727886"
  }
}