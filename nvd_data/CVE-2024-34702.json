{
  "cve_id": "CVE-2024-34702",
  "github_data": {
    "repository": "randombit/botan",
    "fix_commit": "21dccc8fef18c165ba3301d850ac61521f85637e",
    "related_commits": [
      "21dccc8fef18c165ba3301d850ac61521f85637e",
      "39535f13c322f56aa3da2f44b2b6abb8619a82ac",
      "477822a2d10f02d8ba46c9d8a5132f25843f5cc1",
      "7606d70d3a2ac7114476ec2651ca0243c4536fdf",
      "c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
      "ff704b12e6fa351aaedd07bffdc91722e84586b8",
      "21dccc8fef18c165ba3301d850ac61521f85637e",
      "39535f13c322f56aa3da2f44b2b6abb8619a82ac",
      "477822a2d10f02d8ba46c9d8a5132f25843f5cc1",
      "7606d70d3a2ac7114476ec2651ca0243c4536fdf",
      "c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
      "ff704b12e6fa351aaedd07bffdc91722e84586b8"
    ],
    "patch_url": "https://github.com/randombit/botan/commit/21dccc8fef18c165ba3301d850ac61521f85637e.patch",
    "fix_commit_details": {
      "sha": "21dccc8fef18c165ba3301d850ac61521f85637e",
      "commit_date": "2024-07-08T14:50:21Z",
      "author": {
        "login": "randombit",
        "type": "User",
        "stats": {
          "total_commits": 13729,
          "average_weekly_commits": 14.081025641025642,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 791
        }
      },
      "commit_message": {
        "title": "Merge pull request #4187 from randombit/jack/fix-nc-dos-2x",
        "length": 96,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 479,
        "additions": 401,
        "deletions": 78
      },
      "files": [
        {
          "filename": "src/lib/x509/asn1_alt_name.cpp",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -257,6 +257,10 @@ void AlternativeName::decode_from(BER_Decoder& source)\n             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);\n             add_attribute(\"IP\", ipv4_to_string(ip));\n             }\n+         else if(obj.length() != 16)\n+            {\n+            throw Decoding_Error(\"Invalid length for IP address SAN\");\n+            }\n          }\n \n       }"
        },
        {
          "filename": "src/lib/x509/name_constraint.cpp",
          "status": "modified",
          "additions": 302,
          "deletions": 11,
          "patch": "@@ -163,31 +163,48 @@ GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) cons\n \n bool GeneralName::matches_dns(const std::string& nam) const\n    {\n-   if(nam.size() == name().size())\n+   const std::string constraint = tolower_string(name());\n+   const std::string issued = tolower_string(nam);\n+\n+   if(nam.size() == constraint.size())\n       {\n-      return tolower_string(nam) == tolower_string(name());\n+      return issued == constraint;\n       }\n-   else if(name().size() > nam.size())\n+   else if(constraint.size() > nam.size())\n       {\n       // The constraint is longer than the issued name: not possibly a match\n       return false;\n       }\n-   else // name.size() < nam.size()\n+   else\n       {\n-      // constr is suffix of nam\n-      const std::string constr = name().front() == '.' ? name() : \".\" + name();\n-      const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());\n-      return tolower_string(constr) == tolower_string(substr);\n+      if(constraint.empty()) {\n+         return true;\n+      }\n+\n+      std::string substr = issued.substr(nam.size() - constraint.size(), constraint.size());\n+\n+      if(constraint.front() == '.') {\n+         return substr == constraint;\n+      } else if(substr[0] == '.') {\n+         return substr.substr(1) == constraint;\n+      } else {\n+         return substr == constraint && issued[issued.size() - constraint.size() - 1] == '.';\n       }\n    }\n+}\n \n bool GeneralName::matches_dn(const std::string& nam) const\n    {\n    std::stringstream ss(nam);\n-   std::stringstream tt(name());\n-   X509_DN nam_dn, my_dn;\n-\n+   X509_DN nam_dn;\n    ss >> nam_dn;\n+   return matches_dn_obj(nam_dn);\n+   }\n+\n+bool GeneralName::matches_dn_obj(const X509_DN& nam_dn) const\n+   {\n+   std::stringstream tt(name());\n+   X509_DN my_dn;\n    tt >> my_dn;\n \n    auto attr = nam_dn.get_attributes();\n@@ -270,4 +287,278 @@ std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs)\n    os << gs.minimum() << \",\" << gs.maximum() << \",\" << gs.base();\n    return os;\n    }\n+\n+NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,\n+                                 std::vector<GeneralSubtree>&& excluded_subtrees) :\n+   m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)\n+   {\n+   for(const auto& c : m_permitted_subtrees)\n+      {\n+      m_permitted_name_types.insert(c.base().type());\n+      }\n+   for(const auto& c : m_excluded_subtrees)\n+      {\n+      m_excluded_name_types.insert(c.base().type());\n+      }\n+   }\n+\n+namespace {\n+\n+bool looks_like_ipv4(const std::string& s)\n+   {\n+   try\n+     {\n+     // ignores return value\n+     string_to_ipv4(s);\n+     return true;\n+     }\n+   catch(...)\n+      {\n+      return false;\n+      }\n+   }\n+\n+}\n+\n+bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {\n+   if(permitted().empty()) {\n+      return true;\n+   }\n+\n+   const auto& alt_name = cert.subject_alt_name();\n+\n+   if(reject_unknown) {\n+      if(m_permitted_name_types.find(\"URI\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {\n+         return false;\n+      }\n+      if(m_permitted_name_types.find(\"RFC822\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {\n+         return false;\n+      }\n+   }\n+\n+   auto is_permitted_dn = [&](const X509_DN& dn) {\n+      // If no restrictions, then immediate accept\n+      if(m_permitted_name_types.find(\"DN\") == m_permitted_name_types.end()) {\n+         return true;\n+      }\n+\n+      if(dn.empty()) {\n+         return true;\n+      }\n+\n+      for(const auto& c : m_permitted_subtrees) {\n+         if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {\n+            return true;\n+         }\n+      }\n+\n+      // There is at least one permitted name and we didn't match\n+      return false;\n+   };\n+\n+   auto is_permitted_dns_name = [&](const std::string& name) {\n+      if(name.empty() || name[0] == '.') {\n+         return false;\n+      }\n+\n+      // If no restrictions, then immediate accept\n+      if(m_permitted_name_types.find(\"DNS\") == m_permitted_name_types.end()) {\n+         return true;\n+      }\n+\n+      for(const auto& c : m_permitted_subtrees) {\n+         if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {\n+            return true;\n+         }\n+      }\n+\n+      // There is at least one permitted name and we didn't match\n+      return false;\n+   };\n+\n+   auto is_permitted_ipv4 = [&](const std::string& ipv4) {\n+      // If no restrictions, then immediate accept\n+      if(m_permitted_name_types.find(\"IP\") == m_permitted_name_types.end()) {\n+         return true;\n+      }\n+\n+      for(const auto& c : m_permitted_subtrees) {\n+         if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {\n+            return true;\n+         }\n+      }\n+\n+      // There is at least one permitted name and we didn't match\n+      return false;\n+   };\n+\n+   if(!is_permitted_dn(cert.subject_dn())) {\n+      return false;\n+   }\n+\n+   if(!is_permitted_dn(alt_name.dn()))\n+      {\n+      return false;\n+      }\n+\n+   for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {\n+      if(!is_permitted_dns_name(alt_dns)) {\n+         return false;\n+      }\n+   }\n+\n+   for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {\n+      if(!is_permitted_ipv4(alt_ipv4)) {\n+         return false;\n+      }\n+   }\n+\n+   if(!alt_name.has_items())\n+      {\n+      for(const auto& cn : cert.subject_info(\"Name\"))\n+         {\n+         if(cn.find(\".\") != std::string::npos)\n+            {\n+            if(looks_like_ipv4(cn))\n+               {\n+               if(!is_permitted_ipv4(cn))\n+                  {\n+                  return false;\n+                  }\n+               }\n+            else\n+               {\n+               if(!is_permitted_dns_name(cn))\n+                  {\n+                  return false;\n+                  }\n+               }\n+            }\n+         }\n+      }\n+\n+   // We didn't encounter a name that doesn't have a matching constraint\n+   return true;\n }\n+\n+bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {\n+   if(excluded().empty()) {\n+      return false;\n+   }\n+\n+   const auto& alt_name = cert.subject_alt_name();\n+\n+   if(reject_unknown) {\n+      if(m_excluded_name_types.find(\"URI\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {\n+         return false;\n+      }\n+      if(m_excluded_name_types.find(\"RFC822\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {\n+         return false;\n+      }\n+   }\n+\n+   auto is_excluded_dn = [&](const X509_DN& dn) {\n+      // If no restrictions, then immediate accept\n+      if(m_excluded_name_types.find(\"DN\") == m_excluded_name_types.end()) {\n+         return false;\n+      }\n+\n+      if(dn.empty()) {\n+         return false;\n+      }\n+\n+      for(const auto& c : m_excluded_subtrees) {\n+         if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {\n+            return true;\n+         }\n+      }\n+\n+      // There is at least one excluded name and we didn't match\n+      return false;\n+   };\n+\n+   auto is_excluded_dns_name = [&](const std::string& name) {\n+      if(name.empty() || name[0] == '.') {\n+         return true;\n+      }\n+\n+      // If no restrictions, then immediate accept\n+      if(m_excluded_name_types.find(\"DNS\") == m_excluded_name_types.end()) {\n+         return false;\n+      }\n+\n+      for(const auto& c : m_excluded_subtrees) {\n+         if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {\n+            return true;\n+         }\n+      }\n+\n+      // There is at least one excluded name and we didn't match\n+      return false;\n+   };\n+\n+   auto is_excluded_ipv4 = [&](const std::string& ipv4) {\n+      // If no restrictions, then immediate accept\n+      if(m_excluded_name_types.find(\"IP\") == m_excluded_name_types.end()) {\n+         return false;\n+      }\n+\n+      for(const auto& c : m_excluded_subtrees) {\n+         if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {\n+            return true;\n+         }\n+      }\n+\n+      // There is at least one excluded name and we didn't match\n+      return false;\n+   };\n+\n+   if(is_excluded_dn(cert.subject_dn())) {\n+      return true;\n+   }\n+\n+   if(is_excluded_dn(alt_name.dn())) {\n+      return true;\n+   }\n+\n+   for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {\n+      if(is_excluded_dns_name(alt_dns)) {\n+         return true;\n+      }\n+   }\n+\n+   for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {\n+      if(is_excluded_ipv4(alt_ipv4)) {\n+         return true;\n+      }\n+   }\n+\n+   if(!alt_name.has_items())\n+      {\n+      for(const auto& cn : cert.subject_info(\"Name\"))\n+         {\n+         if(cn.find(\".\") != std::string::npos)\n+            {\n+            if(looks_like_ipv4(cn))\n+               {\n+               if(is_excluded_ipv4(cn))\n+                  {\n+                  return true;\n+                  }\n+               }\n+            else\n+               {\n+               if(is_excluded_dns_name(cn))\n+                  {\n+                  return true;\n+                  }\n+               }\n+            }\n+         }\n+      }\n+\n+   // We didn't encounter a name that matched any prohibited name\n+   return false;\n+}\n+\n+}  // namespace Botan"
        },
        {
          "filename": "src/lib/x509/pkix_types.h",
          "status": "modified",
          "additions": 30,
          "deletions": 7,
          "patch": "@@ -191,6 +191,9 @@ class BOTAN_PUBLIC_API(2,0) Attribute final : public ASN1_Object\n * Handles parsing GeneralName types in their BER and canonical string\n * encoding. Allows matching GeneralNames against each other using\n * the rules laid out in the RFC 5280, sec. 4.2.1.10 (Name Contraints).\n+*\n+* This entire class is deprecated and will be removed in a future\n+* major release\n */\n class BOTAN_PUBLIC_API(2,0) GeneralName final : public ASN1_Object\n    {\n@@ -213,6 +216,7 @@ class BOTAN_PUBLIC_API(2,0) GeneralName final : public ASN1_Object\n       * Creates a new GeneralName for its string format.\n       * @param str type and name, colon-separated, e.g., \"DNS:google.com\"\n       */\n+      BOTAN_DEPRECATED(\"Deprecated no replacement\")\n       GeneralName(const std::string& str);\n \n       void encode_into(DER_Encoder&) const override;\n@@ -234,15 +238,17 @@ class BOTAN_PUBLIC_API(2,0) GeneralName final : public ASN1_Object\n       * @param cert certificate to be matched\n       * @return the match result\n       */\n+      BOTAN_DEPRECATED(\"Deprecated no replacement\")\n       MatchResult matches(const X509_Certificate& cert) const;\n \n-   private:\n-      std::string m_type;\n-      std::string m_name;\n-\n       bool matches_dns(const std::string&) const;\n       bool matches_dn(const std::string&) const;\n+      bool matches_dn_obj(const X509_DN& dn) const;\n       bool matches_ip(const std::string&) const;\n+\n+   private:\n+      std::string m_type;\n+      std::string m_name;\n    };\n \n std::ostream& operator<<(std::ostream& os, const GeneralName& gn);\n@@ -253,13 +259,17 @@ std::ostream& operator<<(std::ostream& os, const GeneralName& gn);\n * The Name Constraint extension adds a minimum and maximum path\n * length to a GeneralName to form a constraint. The length limits\n * are currently unused.\n+*\n+* This entire class is deprecated and will be removed in a future\n+* major release\n */\n class BOTAN_PUBLIC_API(2,0) GeneralSubtree final : public ASN1_Object\n    {\n    public:\n       /**\n       * Creates an empty name constraint.\n       */\n+      BOTAN_DEPRECATED(\"Deprecated no replacement\")\n       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max())\n       {}\n \n@@ -269,6 +279,7 @@ class BOTAN_PUBLIC_API(2,0) GeneralSubtree final : public ASN1_Object\n       * @param min minimum path length\n       * @param max maximum path length\n       */\n+      BOTAN_DEPRECATED(\"Deprecated no replacement\")\n       GeneralSubtree(const GeneralName& base, size_t min, size_t max)\n       : m_base(base), m_minimum(min), m_maximum(max)\n       {}\n@@ -277,6 +288,7 @@ class BOTAN_PUBLIC_API(2,0) GeneralSubtree final : public ASN1_Object\n       * Creates a new name constraint for its string format.\n       * @param str name constraint\n       */\n+      BOTAN_DEPRECATED(\"Deprecated no replacement\")\n       GeneralSubtree(const std::string& str);\n \n       void encode_into(DER_Encoder&) const override;\n@@ -325,9 +337,7 @@ class BOTAN_PUBLIC_API(2,0) NameConstraints final\n       * @param excluded_subtrees names for which the certificate is not permitted\n       */\n       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,\n-                    std::vector<GeneralSubtree>&& excluded_subtrees)\n-      : m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)\n-      {}\n+                      std::vector<GeneralSubtree>&& excluded_subtrees);\n \n       /**\n       * @return permitted names\n@@ -339,9 +349,22 @@ class BOTAN_PUBLIC_API(2,0) NameConstraints final\n       */\n       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }\n \n+      /**\n+      * Return true if all of the names in the certificate are permitted\n+      */\n+      bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;\n+\n+      /**\n+      * Return true if any of the names in the certificate are excluded\n+      */\n+      bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;\n+\n    private:\n       std::vector<GeneralSubtree> m_permitted_subtrees;\n       std::vector<GeneralSubtree> m_excluded_subtrees;\n+\n+      std::set<std::string> m_permitted_name_types;\n+      std::set<std::string> m_excluded_name_types;\n    };\n \n /**"
        },
        {
          "filename": "src/lib/x509/x509_ext.cpp",
          "status": "modified",
          "additions": 33,
          "deletions": 47,
          "patch": "@@ -602,27 +602,27 @@ void Name_Constraints::decode_inner(const std::vector<uint8_t>& in)\n    {\n    std::vector<GeneralSubtree> permit, exclude;\n    BER_Decoder ber(in);\n-   BER_Decoder ext = ber.start_cons(SEQUENCE);\n-   BER_Object per = ext.get_next_object();\n+   BER_Decoder inner = ber.start_cons(SEQUENCE);\n+   BER_Object per = inner.get_next_object();\n \n-   ext.push_back(per);\n+   inner.push_back(per);\n    if(per.is_a(0, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))\n       {\n-      ext.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));\n+      inner.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));\n       if(permit.empty())\n          throw Encoding_Error(\"Empty Name Contraint list\");\n       }\n \n-   BER_Object exc = ext.get_next_object();\n-   ext.push_back(exc);\n-   if(per.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))\n+   BER_Object exc = inner.get_next_object();\n+   inner.push_back(exc);\n+   if(exc.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))\n       {\n-      ext.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));\n+      inner.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));\n       if(exclude.empty())\n          throw Encoding_Error(\"Empty Name Contraint list\");\n       }\n \n-   ext.end_cons();\n+   inner.end_cons();\n \n    if(permit.empty() && exclude.empty())\n       throw Encoding_Error(\"Empty Name Contraint extension\");\n@@ -651,11 +651,17 @@ void Name_Constraints::contents_to(Data_Store& subject, Data_Store&) const\n       }\n    }\n \n-void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& issuer,\n+void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& /*issuer*/,\n       const std::vector<std::shared_ptr<const X509_Certificate>>& cert_path,\n       std::vector<std::set<Certificate_Status_Code>>& cert_status,\n       size_t pos)\n    {\n+   // This is much smaller limit than in Botan3 because here name constraint checks\n+   // are much more expensive due to optimizations which would be difficult to\n+   // backport here.\n+   const size_t MAX_NC_COMPARES = (1 << 12);\n+   const size_t total_constraints = m_name_constraints.permitted().size() + m_name_constraints.excluded().size();\n+\n    if(!m_name_constraints.permitted().empty() || !m_name_constraints.excluded().empty())\n       {\n       if(!subject.is_CA_cert())\n@@ -664,54 +670,34 @@ void Name_Constraints::validate(const X509_Certificate& subject, const X509_Cert\n          }\n \n       const bool issuer_name_constraint_critical =\n-         issuer.is_critical(\"X509v3.NameConstraints\");\n+         subject.is_critical(\"X509v3.NameConstraints\");\n \n       // Check that all subordinate certs pass the name constraint\n       for(size_t j = 0; j < pos; ++j)\n          {\n-         bool permitted = m_name_constraints.permitted().empty();\n-         bool failed = false;\n+         const auto& cert = cert_path.at(j);\n \n-         for(auto c: m_name_constraints.permitted())\n-            {\n-            switch(c.base().matches(*cert_path.at(j)))\n-               {\n-               case GeneralName::MatchResult::NotFound:\n-               case GeneralName::MatchResult::All:\n-                  permitted = true;\n-                  break;\n-               case GeneralName::MatchResult::UnknownType:\n-                  failed = issuer_name_constraint_critical;\n-                  permitted = true;\n-                  break;\n-               default:\n-                  break;\n-               }\n-            }\n+         const size_t total_names =\n+            cert->subject_dn().dn_info().size() +\n+            cert->subject_alt_name().get_attributes().size();\n \n-         for(auto c: m_name_constraints.excluded())\n-            {\n-            switch(c.base().matches(*cert_path.at(j)))\n-               {\n-               case GeneralName::MatchResult::All:\n-               case GeneralName::MatchResult::Some:\n-                  failed = true;\n-                  break;\n-               case GeneralName::MatchResult::UnknownType:\n-                  failed = issuer_name_constraint_critical;\n-                  break;\n-               default:\n-                  break;\n-               }\n-            }\n+         if(total_names * total_constraints >= MAX_NC_COMPARES) {\n+            cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);\n+            continue;\n+         }\n \n-         if(failed || !permitted)\n-            {\n+         if(!m_name_constraints.is_permitted(*cert, issuer_name_constraint_critical)) {\n             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);\n-            }\n+            continue;\n+         }\n+\n+         if(m_name_constraints.is_excluded(*cert, issuer_name_constraint_critical)) {\n+            cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);\n+            continue;\n          }\n       }\n    }\n+}\n \n namespace {\n "
        },
        {
          "filename": "src/lib/x509/x509cert.cpp",
          "status": "modified",
          "additions": 25,
          "deletions": 5,
          "patch": "@@ -17,6 +17,7 @@\n #include <botan/oids.h>\n #include <botan/hash.h>\n #include <botan/hex.h>\n+#include <botan/internal/stl_util.h>\n #include <algorithm>\n #include <sstream>\n \n@@ -788,16 +789,35 @@ bool X509_Certificate::matches_dns_name(const std::string& name) const\n    if(name.empty())\n       return false;\n \n-   std::vector<std::string> issued_names = subject_info(\"DNS\");\n+   bool is_ipv4 = false;\n \n-   // Fall back to CN only if no DNS names are set (RFC 6125 sec 6.4.4)\n-   if(issued_names.empty())\n+   try {\n+      string_to_ipv4(name);\n+      is_ipv4 = true;\n+      }\n+   catch(...) {}\n+\n+   std::vector<std::string> issued_names;\n+\n+   if(subject_alt_name().has_items()) {\n+      issued_names = subject_alt_name().get_attribute(is_ipv4 ? \"IP\" : \"DNS\");\n+   } else if(is_ipv4 == false) {\n+      // Use CN only if no SAN is included\n       issued_names = subject_info(\"Name\");\n+   }\n \n    for(size_t i = 0; i != issued_names.size(); ++i)\n       {\n-      if(host_wildcard_match(issued_names[i], name))\n-         return true;\n+      if(is_ipv4)\n+         {\n+         if(issued_names[i] == name)\n+            return true;\n+         }\n+      else\n+         {\n+         if(host_wildcard_match(issued_names[i], name))\n+            return true;\n+         }\n       }\n \n    return false;"
        },
        {
          "filename": "src/python/botan2.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -1285,6 +1285,7 @@ def _load_buf_or_file(filename, buf, file_fn, buf_fn):\n #\n class X509Cert(object): # pylint: disable=invalid-name\n     def __init__(self, filename=None, buf=None):\n+        self.__obj = c_void_p(0)\n         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_cert_load_file, _DLL.botan_x509_cert_load)\n \n     def __del__(self):\n@@ -1464,6 +1465,7 @@ def is_revoked(self, crl):\n #\n class X509CRL(object):\n     def __init__(self, filename=None, buf=None):\n+        self.__obj = c_void_p(0)\n         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_crl_load_file, _DLL.botan_x509_crl_load)\n \n     def __del__(self):"
        },
        {
          "filename": "src/scripts/test_python.py",
          "status": "modified",
          "additions": 0,
          "deletions": 3,
          "patch": "@@ -474,9 +474,6 @@ def test_certs(self):\n         self.assertEqual(cert.issuer_dn('Organizational Unit', 0), 'bsi')\n         self.assertEqual(cert.issuer_dn('Country', 0), 'DE')\n \n-        self.assertTrue(cert.hostname_match('csca-germany'))\n-        self.assertFalse(cert.hostname_match('csca-slovakia'))\n-\n         self.assertEqual(cert.not_before(), 1184858838)\n         self.assertEqual(cert.not_after(), 1831907880)\n "
        },
        {
          "filename": "src/tests/test_name_constraint.cpp",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -29,17 +29,17 @@ class Name_Constraint_Tests final : public Test\n             std::make_tuple(\n                \"Root_Email_Name_Constraint.crt\",\n                \"Invalid_Email_Name_Constraint.crt\",\n-               \"Invalid Email Name Constraint\",\n+               \"\",\n                \"Certificate does not pass name constraint\"),\n             std::make_tuple(\n                \"Root_DN_Name_Constraint.crt\",\n                \"Invalid_DN_Name_Constraint.crt\",\n-               \"Invalid DN Name Constraint\",\n+               \"\",\n                \"Certificate does not pass name constraint\"),\n             std::make_tuple(\n                \"Root_DN_Name_Constraint.crt\",\n                \"Valid_DN_Name_Constraint.crt\",\n-               \"Valid DN Name Constraint\",\n+               \"\",\n                \"Verified\"),\n             std::make_tuple(\n                \"Root_DNS_Name_Constraint.crt\",\n@@ -49,12 +49,12 @@ class Name_Constraint_Tests final : public Test\n             std::make_tuple(\n                \"Root_IP_Name_Constraint.crt\",\n                \"Valid_IP_Name_Constraint.crt\",\n-               \"Valid IP Name Constraint\",\n+               \"\",\n                \"Verified\"),\n             std::make_tuple(\n                \"Root_IP_Name_Constraint.crt\",\n                \"Invalid_IP_Name_Constraint.crt\",\n-               \"Invalid IP Name Constraint\",\n+               \"\",\n                \"Certificate does not pass name constraint\"),\n             };\n          std::vector<Test::Result> results;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "88c33405780a2cb28a2b2ba0b63bd9d0b088bf1b",
            "date": "2025-01-14T12:03:56Z",
            "author_login": "reneme"
          },
          {
            "sha": "8a93d909a7f42a41f7841885cabf722f3649ab7a",
            "date": "2025-01-14T07:59:06Z",
            "author_login": "randombit"
          },
          {
            "sha": "e7786aa9f8ca00e3f10f21e05215ac12ca7f1c90",
            "date": "2025-01-14T07:56:40Z",
            "author_login": "reneme"
          },
          {
            "sha": "17593ebb6d2c0955713d72d12d6c178027d46073",
            "date": "2025-01-13T22:22:41Z",
            "author_login": "randombit"
          },
          {
            "sha": "b6b38efd263d1a65ac364248ca5555d40b1d16a5",
            "date": "2025-01-13T12:05:31Z",
            "author_login": "randombit"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-405",
    "description": "Botan is a C++ cryptography library. X.509 certificates can identify elliptic curves using either an object identifier or using explicit encoding of the parameters.  Prior to 3.5.0 and 2.19.5, checking name constraints in X.509 certificates is quadratic in the number of names and name constraints. An attacker who presented a certificate chain which contained a very large number of names in the SubjectAlternativeName, signed by a CA certificate which contained a large number of name constraints, could cause a denial of service. The problem has been addressed in Botan 3.5.0 and a partial backport has also been applied and is included in Botan 2.19.5.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-08T17:15:11.233",
    "last_modified": "2024-11-21T09:19:13.673",
    "fix_date": "2024-07-08T14:50:21Z"
  },
  "references": [
    {
      "url": "https://github.com/randombit/botan/commit/21dccc8fef18c165ba3301d850ac61521f85637e",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/39535f13c322f56aa3da2f44b2b6abb8619a82ac",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/477822a2d10f02d8ba46c9d8a5132f25843f5cc1",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/7606d70d3a2ac7114476ec2651ca0243c4536fdf",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/ff704b12e6fa351aaedd07bffdc91722e84586b8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4034",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4045",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4047",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4052",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4186",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4187",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/security/advisories/GHSA-5gg9-hqpr-r58j",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/21dccc8fef18c165ba3301d850ac61521f85637e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/39535f13c322f56aa3da2f44b2b6abb8619a82ac",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/477822a2d10f02d8ba46c9d8a5132f25843f5cc1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/7606d70d3a2ac7114476ec2651ca0243c4536fdf",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/c3264821b9f6286ee4e6e3e06826f6b7177e6d41",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/commit/ff704b12e6fa351aaedd07bffdc91722e84586b8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4034",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4045",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4047",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4052",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4186",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/pull/4187",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/randombit/botan/security/advisories/GHSA-5gg9-hqpr-r58j",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.417871",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "botan",
    "owner": "randombit",
    "created_at": "2013-03-06T16:51:39Z",
    "updated_at": "2025-01-14T12:22:38Z",
    "pushed_at": "2025-01-14T13:10:17Z",
    "size": 106654,
    "stars": 2776,
    "forks": 574,
    "open_issues": 215,
    "watchers": 2776,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "insito-bib",
      "master",
      "release-1_8",
      "release-1_10",
      "release-2",
      "release-3"
    ],
    "languages": {
      "C++": 9975206,
      "Python": 672161,
      "C": 204972,
      "Shell": 25498,
      "CMake": 8895,
      "PowerShell": 1888,
      "Emacs Lisp": 1313,
      "HTML": 184
    },
    "commit_activity": {
      "total_commits_last_year": 1232,
      "avg_commits_per_week": 23.692307692307693,
      "days_active_last_year": 242
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-2-clause"
    },
    "collected_at": "2025-01-14T13:10:52.207996"
  }
}