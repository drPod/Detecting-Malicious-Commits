{
  "cve_id": "CVE-2024-35178",
  "github_data": {
    "repository": "jupyter-server/jupyter_server",
    "fix_commit": "79fbf801c5908f4d1d9bc90004b74cfaaeeed2df",
    "related_commits": [
      "79fbf801c5908f4d1d9bc90004b74cfaaeeed2df",
      "79fbf801c5908f4d1d9bc90004b74cfaaeeed2df"
    ],
    "patch_url": "https://github.com/jupyter-server/jupyter_server/commit/79fbf801c5908f4d1d9bc90004b74cfaaeeed2df.patch",
    "fix_commit_details": {
      "sha": "79fbf801c5908f4d1d9bc90004b74cfaaeeed2df",
      "commit_date": "2024-05-31T01:27:40Z",
      "author": {
        "login": "minrk",
        "type": "User",
        "stats": {
          "total_commits": 2908,
          "average_weekly_commits": 3.319634703196347,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 368
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-hrw6-wg82-cm62",
        "length": 742,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 138,
        "additions": 81,
        "deletions": 57
      },
      "files": [
        {
          "filename": "jupyter_server/utils.py",
          "status": "modified",
          "additions": 42,
          "deletions": 57,
          "patch": "@@ -11,6 +11,7 @@\n import sys\n import warnings\n from contextlib import contextmanager\n+from pathlib import Path\n from typing import Any, Generator, NewType, Sequence\n from urllib.parse import (\n     SplitResult,\n@@ -338,81 +339,65 @@ def is_namespace_package(namespace: str) -> bool | None:\n     return isinstance(spec.submodule_search_locations, _NamespacePath)\n \n \n-def filefind(filename: str, path_dirs: Sequence[str] | str | None = None) -> str:\n+def filefind(filename: str, path_dirs: Sequence[str]) -> str:\n     \"\"\"Find a file by looking through a sequence of paths.\n-    This iterates through a sequence of paths looking for a file and returns\n-    the full, absolute path of the first occurrence of the file.  If no set of\n-    path dirs is given, the filename is tested as is, after running through\n-    :func:`expandvars` and :func:`expanduser`.  Thus a simple call::\n \n-        filefind(\"myfile.txt\")\n+    For use in FileFindHandler.\n \n-    will find the file in the current working dir, but::\n+    Iterates through a sequence of paths looking for a file and returns\n+    the full, absolute path of the first occurrence of the file.\n \n-        filefind(\"~/myfile.txt\")\n+    Absolute paths are not accepted for inputs.\n \n-    Will find the file in the users home directory.  This function does not\n-    automatically try any paths, such as the cwd or the user's home directory.\n+    This function does not automatically try any paths,\n+    such as the cwd or the user's home directory.\n \n     Parameters\n     ----------\n     filename : str\n-        The filename to look for.\n-    path_dirs : str, None or sequence of str\n-        The sequence of paths to look for the file in.  If None, the filename\n-        need to be absolute or be in the cwd.  If a string, the string is\n-        put into a sequence and the searched.  If a sequence, walk through\n-        each element and join with ``filename``, calling :func:`expandvars`\n-        and :func:`expanduser` before testing for existence.\n+        The filename to look for. Must be a relative path.\n+    path_dirs : sequence of str\n+        The sequence of paths to look in for the file.\n+        Walk through each element and join with ``filename``.\n+        Only after ensuring the path resolves within the directory is it checked for existence.\n \n     Returns\n     -------\n-    Raises :exc:`IOError` or returns absolute path to file.\n+    Raises :exc:`OSError` or returns absolute path to file.\n     \"\"\"\n-\n-    # If paths are quoted, abspath gets confused, strip them...\n-    filename = filename.strip('\"').strip(\"'\")\n-    # If the input is an absolute path, just check it exists\n-    if os.path.isabs(filename) and os.path.isfile(filename):\n-        return filename\n-\n-    if path_dirs is None:\n-        path_dirs = (\"\",)\n-    elif isinstance(path_dirs, str):\n-        path_dirs = (path_dirs,)\n-\n-    for path in path_dirs:\n-        if path == \".\":\n-            path = os.getcwd()  # noqa: PLW2901\n-        testname = expand_path(os.path.join(path, filename))\n-        if os.path.isfile(testname):\n-            return os.path.abspath(testname)\n+    file_path = Path(filename)\n+\n+    # If the input is an absolute path, reject it\n+    if file_path.is_absolute():\n+        msg = f\"{filename} is absolute, filefind only accepts relative paths.\"\n+        raise OSError(msg)\n+\n+    for path_str in path_dirs:\n+        path = Path(path_str).absolute()\n+        test_path = path / file_path\n+        # os.path.abspath resolves '..', but Path.absolute() doesn't\n+        # Path.resolve() does, but traverses symlinks, which we don't want\n+        test_path = Path(os.path.abspath(test_path))\n+        if sys.version_info >= (3, 9):\n+            if not test_path.is_relative_to(path):\n+                # points outside root, e.g. via `filename='../foo'`\n+                continue\n+        else:\n+            # is_relative_to is new in 3.9\n+            try:\n+                test_path.relative_to(path)\n+            except ValueError:\n+                # points outside root, e.g. via `filename='../foo'`\n+                continue\n+        # make sure we don't call is_file before we know it's a file within a prefix\n+        # GHSA-hrw6-wg82-cm62 - can leak password hash on windows.\n+        if test_path.is_file():\n+            return os.path.abspath(test_path)\n \n     msg = f\"File {filename!r} does not exist in any of the search paths: {path_dirs!r}\"\n     raise OSError(msg)\n \n \n-def expand_path(s: str) -> str:\n-    \"\"\"Expand $VARS and ~names in a string, like a shell\n-\n-    :Examples:\n-       In [2]: os.environ['FOO']='test'\n-       In [3]: expand_path('variable FOO is $FOO')\n-       Out[3]: 'variable FOO is test'\n-    \"\"\"\n-    # This is a pretty subtle hack. When expand user is given a UNC path\n-    # on Windows (\\\\server\\share$\\%username%), os.path.expandvars, removes\n-    # the $ to get (\\\\server\\share\\%username%). I think it considered $\n-    # alone an empty var. But, we need the $ to remains there (it indicates\n-    # a hidden share).\n-    if os.name == \"nt\":\n-        s = s.replace(\"$\\\\\", \"IPYTHON_TEMP\")\n-    s = os.path.expandvars(os.path.expanduser(s))\n-    if os.name == \"nt\":\n-        s = s.replace(\"IPYTHON_TEMP\", \"$\\\\\")\n-    return s\n-\n-\n def import_item(name: str) -> Any:\n     \"\"\"Import and return ``bar`` given the string ``foo.bar``.\n     Calling ``bar = import_item(\"foo.bar\")`` is the functional equivalent of"
        },
        {
          "filename": "tests/test_utils.py",
          "status": "modified",
          "additions": 39,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n from jupyter_server.utils import (\n     check_pid,\n     check_version,\n+    filefind,\n     is_namespace_package,\n     path2url,\n     run_sync_in_loop,\n@@ -125,3 +126,41 @@ def test_unix_socket_in_use(tmp_path):\n     sock.listen(0)\n     assert unix_socket_in_use(server_address)\n     sock.close()\n+\n+\n+@pytest.mark.parametrize(\n+    \"filename, result\",\n+    [\n+        (\"/foo\", OSError),\n+        (\"../c/in-c\", OSError),\n+        (\"in-a\", \"a/in-a\"),\n+        (\"in-b\", \"b/in-b\"),\n+        (\"in-both\", \"a/in-both\"),\n+        (r\"\\in-a\", OSError),\n+        (\"not-found\", OSError),\n+    ],\n+)\n+def test_filefind(tmp_path, filename, result):\n+    a = tmp_path / \"a\"\n+    a.mkdir()\n+    b = tmp_path / \"b\"\n+    b.mkdir()\n+    c = tmp_path / \"c\"\n+    c.mkdir()\n+    for parent in (a, b):\n+        with parent.joinpath(\"in-both\").open(\"w\"):\n+            pass\n+    with a.joinpath(\"in-a\").open(\"w\"):\n+        pass\n+    with b.joinpath(\"in-b\").open(\"w\"):\n+        pass\n+    with c.joinpath(\"in-c\").open(\"w\"):\n+        pass\n+\n+    if isinstance(result, str):\n+        found = filefind(filename, [str(a), str(b)])\n+        found_relative = Path(found).relative_to(tmp_path)\n+        assert str(found_relative) == result\n+    else:\n+        with pytest.raises(result):\n+            filefind(filename, [str(a), str(b)])"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "952782bc9636baa74f4a03966e1c14b43808d703",
            "date": "2024-12-20T13:02:28Z",
            "author_login": "minrk"
          },
          {
            "sha": "8a6f60774599b4d72ad449f98ab2214d2d035bb4",
            "date": "2024-12-20T13:02:26Z",
            "author_login": "minrk"
          },
          {
            "sha": "f23b3392624001c8fba6623e19f526a98b4a07ba",
            "date": "2024-12-20T12:52:39Z",
            "author_login": "minrk"
          },
          {
            "sha": "219597175e8275e7f3e958952a4254aedc046859",
            "date": "2024-12-20T12:23:45Z",
            "author_login": "minrk"
          },
          {
            "sha": "e74da85b1ed78151e62311f3610660315847145d",
            "date": "2024-12-20T12:06:13Z",
            "author_login": "cjwatson"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "The Jupyter Server provides the backend for Jupyter web applications. Jupyter Server on Windows has a vulnerability that lets unauthenticated attackers leak the NTLMv2 password hash of the Windows user running the Jupyter server. An attacker can crack this password to gain access to the Windows machine hosting the Jupyter server, or access other network-accessible machines or 3rd party services using that credential. Or an attacker perform an NTLM relay attack without cracking the credential to gain access to other network-accessible machines. This vulnerability is fixed in 2.14.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-06T16:15:11.937",
    "last_modified": "2024-11-21T09:19:52.497",
    "fix_date": "2024-05-31T01:27:40Z"
  },
  "references": [
    {
      "url": "https://github.com/jupyter-server/jupyter_server/commit/79fbf801c5908f4d1d9bc90004b74cfaaeeed2df",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/jupyter-server/jupyter_server/security/advisories/GHSA-hrw6-wg82-cm62",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/jupyter-server/jupyter_server/commit/79fbf801c5908f4d1d9bc90004b74cfaaeeed2df",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/jupyter-server/jupyter_server/security/advisories/GHSA-hrw6-wg82-cm62",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:26.343366",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jupyter_server",
    "owner": "jupyter-server",
    "created_at": "2016-09-21T19:18:45Z",
    "updated_at": "2025-01-08T11:04:52Z",
    "pushed_at": "2025-01-06T21:30:38Z",
    "size": 25887,
    "stars": 496,
    "forks": 313,
    "open_issues": 205,
    "watchers": 496,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.x",
      "1.0.x",
      "main"
    ],
    "languages": {
      "Python": 1075364,
      "HTML": 10136,
      "CSS": 1414,
      "JavaScript": 528
    },
    "commit_activity": {
      "total_commits_last_year": 76,
      "avg_commits_per_week": 1.4615384615384615,
      "days_active_last_year": 31
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T15:10:39.648352"
  }
}