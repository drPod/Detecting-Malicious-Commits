{
  "cve_id": "CVE-2024-35190",
  "github_data": {
    "repository": "asterisk/asterisk",
    "fix_commit": "85241bd22936cc15760fd1f65d16c98be7aeaf6d",
    "related_commits": [
      "85241bd22936cc15760fd1f65d16c98be7aeaf6d",
      "85241bd22936cc15760fd1f65d16c98be7aeaf6d"
    ],
    "patch_url": "https://github.com/asterisk/asterisk/commit/85241bd22936cc15760fd1f65d16c98be7aeaf6d.patch",
    "fix_commit_details": {
      "sha": "85241bd22936cc15760fd1f65d16c98be7aeaf6d",
      "commit_date": "2024-05-17T14:04:40Z",
      "author": {
        "login": "gtjoseph",
        "type": "User",
        "stats": {
          "total_commits": 1056,
          "average_weekly_commits": 0.9271290605794557,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 351
        }
      },
      "commit_message": {
        "title": "Revert \"res_pjsip_endpoint_identifier_ip: Add endpoint identifier transport address.\"",
        "length": 139,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 193,
        "additions": 37,
        "deletions": 156
      },
      "files": [
        {
          "filename": "configs/samples/pjsip.conf.sample",
          "status": "modified",
          "additions": 4,
          "deletions": 49,
          "patch": "@@ -197,47 +197,6 @@\n ;tcp_keepalive_interval_time=10  ; The time in seconds between individual keepalive probes\n ;tcp_keepalive_probe_count=5     ; The maximum number of keepalive probes TCP should send before dropping the connection\n \n-;===============ENDPOINT IDENTIFIER TRANSPORT EXAMPLE==========================\n-;\n-; When Asterisk has multiple bound IP addresses, and endpoints don't use any\n-; other means of identification (e.g.: username), the transports' bind addresses\n-; can be used to identify them. Can be useful in case you're connecting to the\n-; same ITSP multiple times on different IPs / NICs.\n-;\n-;[transport-eth0]\n-;type=transport\n-;protocol=tcp\n-;bind=192.168.1.1:5060\n-;\n-;[transport-eth1]\n-;type=transport\n-;protocol=udp\n-;bind=192.168.2.1:5060\n-;\n-;\n-;[myprovider-a]\n-;type=endpoint\n-;transport=transport-eth0\n-;identify_by=transport\n-;\n-;[myprovider-b]\n-;type=endpoint\n-;transport=transport-eth1\n-;identify_by=transport\n-;\n-;\n-;[identify-a]\n-;type=identify\n-;endpoint=myprovider-a\n-;match=192.168.1.1:5060\t; This is the bind address of [transport-eth0]\n-;;transport=tcp\t\t; Optionally, this is the transport protocol of [transport-eth0]\n-;\n-;[identify-b]\n-;type=identify\n-;endpoint=myprovider-b\n-;match=192.168.2.1:5060\t; This is the bind address of [transport-eth1]\n-;;transport=udp\t\t; Optionally, This is the transport protocol of [transport-eth1]\n-\n ;===============OUTBOUND REGISTRATION WITH OUTBOUND AUTHENTICATION============\n ;\n ; This is a simple registration that works with some SIP trunking providers.\n@@ -725,10 +684,9 @@\n                         ; identified.\n                         ; \"username\": Identify by the From or To username and domain\n                         ; \"auth_username\": Identify by the Authorization username and realm\n-                        ; \"ip\": Identify by the source (remote) IP address\n+                        ; \"ip\": Identify by the source IP address\n                         ; \"header\": Identify by a configured SIP header value.\n                         ; \"request_uri\": Identify by the configured SIP request URI.\n-                        ; \"transport\": Identify by the bound (local) IP address\n                         ; In the username and auth_username cases, if an exact match\n                         ; on both username and domain/realm fails, the match is\n                         ; retried with just the username.\n@@ -1313,10 +1271,9 @@\n             ; (default: \"no\")\n ;endpoint_identifier_order=ip,username,anonymous\n             ; The order by which endpoint identifiers are given priority.\n-            ; Currently, \"ip\", \"header\", \"request_uri\", \"transport\", \"username\",\n-            ; \"auth_username\" and \"anonymous\"  are valid identifiers as registered by\n-            ; the res_pjsip_endpoint_identifier_* modules.\n-            ; Some modules like res_pjsip_endpoint_identifier_user register\n+            ; Currently, \"ip\", \"header\", \"username\", \"auth_username\" and \"anonymous\"\n+            ; are valid identifiers as registered by the res_pjsip_endpoint_identifier_*\n+            ; modules.  Some modules like res_pjsip_endpoint_identifier_user register\n             ; more than one identifier.  Use the CLI command \"pjsip show identifiers\"\n             ; to see the identifiers currently available.\n             ; (default: ip,username,anonymous)\n@@ -1504,8 +1461,6 @@\n ;match= ; Comma separated list of IP addresses, networks, or hostnames to match\n         ; against (default: \"\")\n ;match_header= ; SIP header with specified value to match against (default: \"\")\n-;match_request_uri= ; SIP request URI to match against (default: \"\")\n-;transport= ; Match ageinst the transport protocol (tcp or udp) (default: \"\")\n ;type=  ; Must be of type identify (default: \"\")\n \n "
        },
        {
          "filename": "contrib/ast-db-manage/config/versions/bd9c5159c7ea_revert_d5122576cca8_add_transport_.py",
          "status": "added",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -0,0 +1,22 @@\n+\"\"\"Revert d5122576cca8 add transport attribute to identify\n+\n+Revision ID: bd9c5159c7ea\n+Revises: 6c475a93f48a\n+Create Date: 2024-05-17 08:30:58.299083\n+\n+\"\"\"\n+\n+# revision identifiers, used by Alembic.\n+revision = 'bd9c5159c7ea'\n+down_revision = '6c475a93f48a'\n+\n+from alembic import op\n+import sqlalchemy as sa\n+\n+\n+def upgrade():\n+    op.drop_column('ps_endpoint_id_ips', 'transport')\n+\n+\n+def downgrade():\n+    op.add_column('ps_endpoint_id_ips', sa.Column('transport', sa.String(128)))"
        },
        {
          "filename": "include/asterisk/res_pjsip.h",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -617,8 +617,6 @@ enum ast_sip_endpoint_identifier_type {\n \tAST_SIP_ENDPOINT_IDENTIFY_BY_HEADER = (1 << 3),\n \t/*! Identify based on request uri */\n \tAST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI = (1 << 4),\n-\t/*! Identify based on bound (local) IP address */\n-\tAST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT = (1 << 5),\n };\n AST_VECTOR(ast_sip_identify_by_vector, enum ast_sip_endpoint_identifier_type);\n "
        },
        {
          "filename": "res/res_pjsip/pjsip_config.xml",
          "status": "modified",
          "additions": 0,
          "deletions": 8,
          "patch": "@@ -565,14 +565,6 @@\n \t\t\t\t\t\t\t\tbut simply allowed by this configuration option.\n \t\t\t\t\t\t\t\t</para>\n \t\t\t\t\t\t\t</enum>\n-\t\t\t\t\t\t\t<enum name=\"transport\">\n-\t\t\t\t\t\t\t\t<para>Matches the endpoint based on the destination IP\n-\t\t\t\t\t\t\t\taddress.\n-\t\t\t\t\t\t\t\t</para>\n-\t\t\t\t\t\t\t\t<para>This method of identification is not configured here\n-\t\t\t\t\t\t\t\tbut simply allowed by this configuration option.\n-\t\t\t\t\t\t\t\t</para>\n-\t\t\t\t\t\t\t</enum>\n \t\t\t\t\t\t</enumlist>\n \t\t\t\t\t</description>\n \t\t\t\t</configOption>"
        },
        {
          "filename": "res/res_pjsip/pjsip_configuration.c",
          "status": "modified",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -426,9 +426,6 @@ static const char *sip_endpoint_identifier_type2str(enum ast_sip_endpoint_identi\n \tcase AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI:\n \t\tstr = \"request_uri\";\n \t\tbreak;\n-\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT:\n-\t\tstr = \"transport\";\n-\t\tbreak;\n \t}\n \treturn str;\n }\n@@ -456,8 +453,6 @@ static int sip_endpoint_identifier_str2type(const char *str)\n \t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n \t} else if (!strcasecmp(str, \"request_uri\")) {\n \t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n-\t} else if (!strcasecmp(str, \"transport\")) {\n-\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n \t} else {\n \t\tmethod = -1;\n \t}"
        },
        {
          "filename": "res/res_pjsip_endpoint_identifier_ip.c",
          "status": "modified",
          "additions": 11,
          "deletions": 92,
          "patch": "@@ -124,16 +124,6 @@\n \t\t\t\t\t\t</para></note>\n \t\t\t\t\t</description>\n \t\t\t\t</configOption>\n-\t\t\t\t<configOption name=\"transport\">\n-\t\t\t\t\t<synopsis>Match against a transport type.</synopsis>\n-\t\t\t\t\t<description>\n-\t\t\t\t\t\t<para>When using the ip or transport identifier, this option\n-\t\t\t\t\t\tcan be used to match the transport type <literal>(udp or tcp)\n-\t\t\t\t\t\t</literal> as well.</para>\n-\t\t\t\t\t\t<para>When omitted, or left empty, which is the default, it\n-\t\t\t\t\t\twon't match against the transport type.</para>\n-\t\t\t\t\t</description>\n-\t\t\t\t</configOption>\n \t\t\t\t<configOption name=\"type\">\n \t\t\t\t\t<synopsis>Must be of type 'identify'.</synopsis>\n \t\t\t\t</configOption>\n@@ -161,8 +151,6 @@ struct ip_identify_match {\n \t\tAST_STRING_FIELD(match_header_name);\n \t\t/*! SIP header value of the match_header string */\n \t\tAST_STRING_FIELD(match_header_value);\n-\t\t/*! The name of the transport type */\n-\t\tAST_STRING_FIELD(transport);\n \t);\n \t/*! Compiled match_header regular expression when is_header_regex is non-zero */\n \tregex_t regex_header_buf;\n@@ -180,12 +168,6 @@ struct ip_identify_match {\n \tunsigned int is_request_uri_regex:1;\n };\n \n-/*! \\brief Structure for a socket address with transport */\n-struct ast_sockaddr_with_tp {\n-\tstruct ast_sockaddr addr;\n-\tchar tp[128];\n-};\n-\n /*! \\brief Destructor function for a matching object */\n static void ip_identify_destroy(void *obj)\n {\n@@ -321,29 +303,18 @@ static int request_identify_match_check(void *obj, void *arg, int flags)\n static int ip_identify_match_check(void *obj, void *arg, int flags)\n {\n \tstruct ip_identify_match *identify = obj;\n-\tstruct ast_sockaddr_with_tp *addr_with_tp = arg;\n-\tstruct ast_sockaddr address = addr_with_tp->addr;\n+\tstruct ast_sockaddr *addr = arg;\n \tint sense;\n \n-\tsense = ast_apply_ha(identify->matches, &address);\n+\tsense = ast_apply_ha(identify->matches, addr);\n \tif (sense != AST_SENSE_ALLOW) {\n-\t\tast_debug(3, \"Address %s matches identify '%s'\\n\",\n-\t\t\t\tast_sockaddr_stringify(&address),\n-\t\t\t\tast_sorcery_object_get_id(identify));\n-\t\tif (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {\n-\t\t\tast_debug(3, \"Transport %s matches identify '%s'\\n\",\n-\t\t\t\taddr_with_tp->tp,\n-\t\t\t\tast_sorcery_object_get_id(identify));\n-\t\t\treturn CMP_MATCH;\n-\t\t} else {\n-\t\t\tast_debug(3, \"Transport %s match not matched identify '%s'\\n\",\n-\t\t\t\taddr_with_tp->tp,\n+\t\tast_debug(3, \"Source address %s matches identify '%s'\\n\",\n+\t\t\t\tast_sockaddr_stringify(addr),\n \t\t\t\tast_sorcery_object_get_id(identify));\n-\t\t\treturn 0;\n-\t\t}\n+\t\treturn CMP_MATCH;\n \t} else {\n-\t\tast_debug(3, \"Address %s does not match identify '%s'\\n\",\n-\t\t\t\tast_sockaddr_stringify(&address),\n+\t\tast_debug(3, \"Source address %s does not match identify '%s'\\n\",\n+\t\t\t\tast_sockaddr_stringify(addr),\n \t\t\t\tast_sorcery_object_get_id(identify));\n \t\treturn 0;\n \t}\n@@ -384,54 +355,18 @@ static struct ast_sip_endpoint *common_identify(ao2_callback_fn *identify_match_\n \n static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n {\n-\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n-\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n-\n-\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n-\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n-\n-\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n-}\n-\n-static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)\n-{\n-\tchar buffer[PJ_INET6_ADDRSTRLEN];\n-\tpj_status_t status;\n-\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n-\tunion pj_sockaddr sock = rdata->tp_info.transport->local_addr;\n-\n-\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n-\n-\tif (sock.addr.sa_family == PJ_AF_INET6) {\n-\t\tstatus = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);\n-\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"::\")) {\n-\t\t\tast_log(LOG_WARNING, \"Matching against '::' may be unpredictable.\\n\");\n-\t\t}\n-\t} else {\n-\t\tstatus = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);\n-\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"0.0.0.0\")) {\n-\t\t\tast_log(LOG_WARNING, \"Matching against '0.0.0.0' may be unpredictable.\\n\");\n-\t\t}\n-\t}\n+\tstruct ast_sockaddr addr = { { 0, } };\n \n-\tif (status == PJ_SUCCESS) {\n-\t\tast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);\n-\t\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);\n+\tast_sockaddr_parse(&addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n+\tast_sockaddr_set_port(&addr, rdata->pkt_info.src_port);\n \n-\t\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n-\t} else {\n-\t\treturn NULL;\n-\t}\n+\treturn common_identify(ip_identify_match_check, &addr);\n }\n \n static struct ast_sip_endpoint_identifier ip_identifier = {\n \t.identify_endpoint = ip_identify,\n };\n \n-static struct ast_sip_endpoint_identifier transport_identifier = {\n-\t.identify_endpoint = transport_identify,\n-};\n-\n static struct ast_sip_endpoint *header_identify(pjsip_rx_data *rdata)\n {\n \treturn common_identify(header_identify_match_check, rdata);\n@@ -595,12 +530,6 @@ static int ip_identify_apply(const struct ast_sorcery *sorcery, void *obj)\n \t\treturn -1;\n \t}\n \n-\tif (!ast_strlen_zero(identify->transport)) {\n-\t\tif (ast_string_field_set(identify, transport, identify->transport)) {\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n-\n \tif (!ast_strlen_zero(identify->match_header)) {\n \t\tchar *c_header;\n \t\tchar *c_value;\n@@ -950,13 +879,6 @@ static int cli_print_body(void *obj, void *arg, int flags)\n \t\t\t\taddr, ast_sockaddr_cidr_bits(&match->netmask));\n \t\t}\n \n-\t\tif (!ast_strlen_zero(ident->transport)) {\n-\t\t\tast_str_append(&context->output_buffer, 0, \"%*s: %s\\n\",\n-\t\t\t\tindent,\n-\t\t\t\t\"Transport\",\n-\t\t\t\tident->transport);\n-\t\t}\n-\n \t\tif (!ast_strlen_zero(ident->match_header)) {\n \t\t\tast_str_append(&context->output_buffer, 0, \"%*s: %s\\n\",\n \t\t\t\tindent,\n@@ -1032,13 +954,11 @@ static int load_module(void)\n \tast_sorcery_object_field_register(ast_sip_get_sorcery(), \"identify\", \"match_header\", \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, match_header));\n \tast_sorcery_object_field_register(ast_sip_get_sorcery(), \"identify\", \"match_request_uri\", \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, match_request_uri));\n \tast_sorcery_object_field_register(ast_sip_get_sorcery(), \"identify\", \"srv_lookups\", \"yes\", OPT_BOOL_T, 1, FLDSET(struct ip_identify_match, srv_lookups));\n-\tast_sorcery_object_field_register(ast_sip_get_sorcery(), \"identify\", \"transport\", \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, transport));\n \tast_sorcery_load_object(ast_sip_get_sorcery(), \"identify\");\n \n \tast_sip_register_endpoint_identifier_with_name(&ip_identifier, \"ip\");\n \tast_sip_register_endpoint_identifier_with_name(&header_identifier, \"header\");\n \tast_sip_register_endpoint_identifier_with_name(&request_identifier, \"request_uri\");\n-\tast_sip_register_endpoint_identifier_with_name(&transport_identifier, \"transport\");\n \tast_sip_register_endpoint_formatter(&endpoint_identify_formatter);\n \n \tcli_formatter = ao2_alloc(sizeof(struct ast_sip_cli_formatter_entry), NULL);\n@@ -1075,7 +995,6 @@ static int unload_module(void)\n \tast_sip_unregister_endpoint_identifier(&header_identifier);\n \tast_sip_unregister_endpoint_identifier(&request_identifier);\n \tast_sip_unregister_endpoint_identifier(&ip_identifier);\n-\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n \n \treturn 0;\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 4,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "831b5ec11d8bfd12cb82818639f0bbbab1e779e2",
            "date": "2025-01-07T20:17:56Z",
            "author_login": "seuros"
          },
          {
            "sha": "468601fd13e9543744c33118abc544b5c942d691",
            "date": "2025-01-02T19:38:30Z",
            "author_login": "seanbright"
          },
          {
            "sha": "4ef68fbce8df8b63759995e2cddc2331ec344b79",
            "date": "2025-01-08T16:57:54Z",
            "author_login": "DooMMasteR"
          },
          {
            "sha": "7b71efd172333fbeb9ffcda45070bacded7a91ba",
            "date": "2025-01-09T19:34:39Z",
            "author_login": "seanbright"
          },
          {
            "sha": "a24853ecdf0593f2d25a04a28a8f0977cf436a9d",
            "date": "2025-01-08T22:00:39Z",
            "author_login": "seuros"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N",
    "cwe_id": "CWE-303",
    "description": "Asterisk is an open source private branch exchange and telephony toolkit. After upgrade to 18.23.0, ALL unauthorized SIP requests are identified as PJSIP Endpoint of local asterisk server. This vulnerability is fixed in 18.23.1, 20.8.1, and 21.3.1.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-17T17:15:07.067",
    "last_modified": "2024-11-21T09:19:53.977",
    "fix_date": "2024-05-17T14:04:40Z"
  },
  "references": [
    {
      "url": "https://github.com/asterisk/asterisk/commit/85241bd22936cc15760fd1f65d16c98be7aeaf6d",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/pull/600",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/pull/602",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/security/advisories/GHSA-qqxj-v78h-hrf9",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/commit/85241bd22936cc15760fd1f65d16c98be7aeaf6d",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/pull/600",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/pull/602",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/security/advisories/GHSA-qqxj-v78h-hrf9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:24.253266",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "asterisk",
    "owner": "asterisk",
    "created_at": "2015-04-11T17:07:55Z",
    "updated_at": "2025-01-13T17:09:18Z",
    "pushed_at": "2025-01-13T17:09:13Z",
    "size": 374114,
    "stars": 2344,
    "forks": 988,
    "open_issues": 128,
    "watchers": 2344,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 36851690,
      "Python": 358820,
      "Shell": 260947,
      "M4": 191704,
      "Makefile": 139089,
      "Perl": 111005,
      "Yacc": 64828,
      "Mustache": 31730,
      "Lex": 26043,
      "XSLT": 15366,
      "Vim Script": 11793,
      "HTML": 11310,
      "Roff": 10448,
      "JavaScript": 7906,
      "Tcl": 4198,
      "PHP": 2106,
      "Mako": 1730,
      "CSS": 1031,
      "Awk": 642
    },
    "commit_activity": {
      "total_commits_last_year": 211,
      "avg_commits_per_week": 4.0576923076923075,
      "days_active_last_year": 152
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:58:39.405654"
  }
}