{
  "cve_id": "CVE-2024-36106",
  "github_data": {
    "repository": "argoproj/argo-cd",
    "fix_commit": "c2647055c261a550e5da075793260f6524e65ad9",
    "related_commits": [
      "c2647055c261a550e5da075793260f6524e65ad9",
      "c2647055c261a550e5da075793260f6524e65ad9"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "c2647055c261a550e5da075793260f6524e65ad9",
      "commit_date": "2024-06-06T08:30:10Z",
      "author": {
        "login": "pasha-codefresh",
        "type": "User",
        "stats": {
          "total_commits": 261,
          "average_weekly_commits": 0.71900826446281,
          "total_additions": 223909,
          "total_deletions": 165744,
          "weeks_active": 88
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-3cqf-953p-h5cp",
        "length": 871,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 213,
        "additions": 192,
        "deletions": 21
      },
      "files": [
        {
          "filename": "server/cluster/cluster.go",
          "status": "modified",
          "additions": 30,
          "deletions": 21,
          "patch": "@@ -187,15 +187,11 @@ func (s *Server) Create(ctx context.Context, q *cluster.ClusterCreateRequest) (*\n \n // Get returns a cluster from a query\n func (s *Server) Get(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {\n-\tc, err := s.getClusterWith403IfNotExist(ctx, q)\n+\tc, err := s.getClusterAndVerifyAccess(ctx, q, rbacpolicy.ActionGet)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionGet, CreateClusterRBACObject(c.Project, q.Server)); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \treturn s.toAPIResponse(c), nil\n }\n \n@@ -207,6 +203,21 @@ func (s *Server) getClusterWith403IfNotExist(ctx context.Context, q *cluster.Clu\n \treturn repo, nil\n }\n \n+func (s *Server) getClusterAndVerifyAccess(ctx context.Context, q *cluster.ClusterQuery, action string) (*appv1.Cluster, error) {\n+\tc, err := s.getClusterWith403IfNotExist(ctx, q)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// verify that user can do the specified action inside project where cluster is located\n+\tif !s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, action, CreateClusterRBACObject(c.Project, c.Server)) {\n+\t\tlog.WithField(\"cluster\", q.Server).Warnf(\"encountered permissions issue while processing request: %v\", err)\n+\t\treturn nil, common.PermissionDeniedAPIError\n+\t}\n+\n+\treturn c, nil\n+}\n+\n func (s *Server) getCluster(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {\n \tif q.Id != nil {\n \t\tq.Server = \"\"\n@@ -278,20 +289,16 @@ var clusterFieldsByPath = map[string]func(updated *appv1.Cluster, existing *appv\n \n // Update updates a cluster\n func (s *Server) Update(ctx context.Context, q *cluster.ClusterUpdateRequest) (*appv1.Cluster, error) {\n-\tc, err := s.getClusterWith403IfNotExist(ctx, &cluster.ClusterQuery{\n+\tc, err := s.getClusterAndVerifyAccess(ctx, &cluster.ClusterQuery{\n \t\tServer: q.Cluster.Server,\n \t\tName:   q.Cluster.Name,\n \t\tId:     q.Id,\n-\t})\n+\t}, rbacpolicy.ActionUpdate)\n+\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\t// verify that user can do update inside project where cluster is located\n-\tif !s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(c.Project, c.Server)) {\n-\t\treturn nil, common.PermissionDeniedAPIError\n-\t}\n-\n \tif len(q.UpdatedFields) == 0 || sets.NewString(q.UpdatedFields...).Has(\"project\") {\n \t\t// verify that user can do update inside project where cluster will be located\n \t\tif !s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(q.Cluster.Project, c.Server)) {\n@@ -341,7 +348,8 @@ func (s *Server) Delete(ctx context.Context, q *cluster.ClusterQuery) (*cluster.\n \tif q.Name != \"\" {\n \t\tservers, err := s.db.GetClusterServersByName(ctx, q.Name)\n \t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\t\tlog.WithField(\"cluster\", q.Name).Warnf(\"failed to get cluster servers by name: %v\", err)\n+\t\t\treturn nil, common.PermissionDeniedAPIError\n \t\t}\n \t\tfor _, server := range servers {\n \t\t\tif err := enforceAndDelete(s, ctx, server, c.Project); err != nil {\n@@ -359,7 +367,8 @@ func (s *Server) Delete(ctx context.Context, q *cluster.ClusterQuery) (*cluster.\n \n func enforceAndDelete(s *Server, ctx context.Context, server, project string) error {\n \tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionDelete, CreateClusterRBACObject(project, server)); err != nil {\n-\t\treturn err\n+\t\tlog.WithField(\"cluster\", server).Warnf(\"encountered permissions issue while processing request: %v\", err)\n+\t\treturn common.PermissionDeniedAPIError\n \t}\n \tif err := s.db.DeleteCluster(ctx, server); err != nil {\n \t\treturn err\n@@ -378,16 +387,19 @@ func (s *Server) RotateAuth(ctx context.Context, q *cluster.ClusterQuery) (*clus\n \tif q.Name != \"\" {\n \t\tservers, err = s.db.GetClusterServersByName(ctx, q.Name)\n \t\tif err != nil {\n-\t\t\treturn nil, status.Errorf(codes.NotFound, \"failed to get cluster servers by name: %v\", err)\n+\t\t\tlog.WithField(\"cluster\", q.Name).Warnf(\"failed to get cluster servers by name: %v\", err)\n+\t\t\treturn nil, common.PermissionDeniedAPIError\n \t\t}\n \t\tfor _, server := range servers {\n \t\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(clust.Project, server)); err != nil {\n-\t\t\t\treturn nil, status.Errorf(codes.PermissionDenied, \"encountered permissions issue while processing request: %v\", err)\n+\t\t\t\tlog.WithField(\"cluster\", server).Warnf(\"encountered permissions issue while processing request: %v\", err)\n+\t\t\t\treturn nil, common.PermissionDeniedAPIError\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(clust.Project, q.Server)); err != nil {\n-\t\t\treturn nil, status.Errorf(codes.PermissionDenied, \"encountered permissions issue while processing request: %v\", err)\n+\t\t\tlog.WithField(\"cluster\", q.Server).Warnf(\"encountered permissions issue while processing request: %v\", err)\n+\t\t\treturn nil, common.PermissionDeniedAPIError\n \t\t}\n \t\tservers = append(servers, q.Server)\n \t}\n@@ -467,13 +479,10 @@ func (s *Server) toAPIResponse(clust *appv1.Cluster) *appv1.Cluster {\n \n // InvalidateCache invalidates cluster cache\n func (s *Server) InvalidateCache(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {\n-\tcls, err := s.getClusterWith403IfNotExist(ctx, q)\n+\tcls, err := s.getClusterAndVerifyAccess(ctx, q, rbacpolicy.ActionUpdate)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(cls.Project, q.Server)); err != nil {\n-\t\treturn nil, err\n-\t}\n \tnow := v1.Now()\n \tcls.RefreshRequestedAt = &now\n \tcls, err = s.db.UpdateCluster(ctx, cls)"
        },
        {
          "filename": "server/cluster/cluster_test.go",
          "status": "modified",
          "additions": 162,
          "deletions": 0,
          "patch": "@@ -4,6 +4,9 @@ import (\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"github.com/argoproj/argo-cd/v2/server/rbacpolicy\"\n+\t\"github.com/argoproj/argo-cd/v2/util/assets\"\n+\t\"github.com/golang-jwt/jwt/v4\"\n \t\"reflect\"\n \t\"testing\"\n \t\"time\"\n@@ -51,6 +54,16 @@ func newNoopEnforcer() *rbac.Enforcer {\n \treturn enf\n }\n \n+func newEnforcer() *rbac.Enforcer {\n+\tenforcer := rbac.NewEnforcer(fake.NewSimpleClientset(test.NewFakeConfigMap()), test.FakeArgoCDNamespace, common.ArgoCDRBACConfigMapName, nil)\n+\t_ = enforcer.SetBuiltinPolicy(assets.BuiltinPolicyCSV)\n+\tenforcer.SetDefaultRole(\"role:test\")\n+\tenforcer.SetClaimsEnforcerFunc(func(claims jwt.Claims, rvals ...interface{}) bool {\n+\t\treturn true\n+\t})\n+\treturn enforcer\n+}\n+\n func TestUpdateCluster_RejectInvalidParams(t *testing.T) {\n \ttestCases := []struct {\n \t\tname    string\n@@ -604,3 +617,152 @@ func TestListCluster(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestGetClusterAndVerifyAccess(t *testing.T) {\n+\tt.Run(\"GetClusterAndVerifyAccess - No Cluster\", func(t *testing.T) {\n+\t\tdb := &dbmocks.ArgoDB{}\n+\n+\t\tmockCluster := v1alpha1.Cluster{\n+\t\t\tName:       \"test/ing\",\n+\t\t\tServer:     \"https://127.0.0.1\",\n+\t\t\tNamespaces: []string{\"default\", \"kube-system\"},\n+\t\t}\n+\t\tmockClusterList := v1alpha1.ClusterList{\n+\t\t\tListMeta: v1.ListMeta{},\n+\t\t\tItems: []v1alpha1.Cluster{\n+\t\t\t\tmockCluster,\n+\t\t\t},\n+\t\t}\n+\n+\t\tdb.On(\"ListClusters\", mock.Anything).Return(&mockClusterList, nil)\n+\n+\t\tserver := NewServer(db, newNoopEnforcer(), newServerInMemoryCache(), &kubetest.MockKubectlCmd{})\n+\t\tcluster, err := server.getClusterAndVerifyAccess(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tName: \"test/not-exists\",\n+\t\t}, rbacpolicy.ActionGet)\n+\n+\t\tassert.Nil(t, cluster)\n+\t\tassert.ErrorIs(t, err, common.PermissionDeniedAPIError)\n+\t})\n+\n+\tt.Run(\"GetClusterAndVerifyAccess - Permissions Denied\", func(t *testing.T) {\n+\t\tdb := &dbmocks.ArgoDB{}\n+\n+\t\tmockCluster := v1alpha1.Cluster{\n+\t\t\tName:       \"test/ing\",\n+\t\t\tServer:     \"https://127.0.0.1\",\n+\t\t\tNamespaces: []string{\"default\", \"kube-system\"},\n+\t\t}\n+\t\tmockClusterList := v1alpha1.ClusterList{\n+\t\t\tListMeta: v1.ListMeta{},\n+\t\t\tItems: []v1alpha1.Cluster{\n+\t\t\t\tmockCluster,\n+\t\t\t},\n+\t\t}\n+\n+\t\tdb.On(\"ListClusters\", mock.Anything).Return(&mockClusterList, nil)\n+\n+\t\tserver := NewServer(db, newEnforcer(), newServerInMemoryCache(), &kubetest.MockKubectlCmd{})\n+\t\tcluster, err := server.getClusterAndVerifyAccess(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tName: \"test/ing\",\n+\t\t}, rbacpolicy.ActionGet)\n+\n+\t\tassert.Nil(t, cluster)\n+\t\tassert.ErrorIs(t, err, common.PermissionDeniedAPIError)\n+\t})\n+}\n+\n+func TestNoClusterEnumeration(t *testing.T) {\n+\tdb := &dbmocks.ArgoDB{}\n+\n+\tmockCluster := v1alpha1.Cluster{\n+\t\tName:       \"test/ing\",\n+\t\tServer:     \"https://127.0.0.1\",\n+\t\tNamespaces: []string{\"default\", \"kube-system\"},\n+\t}\n+\tmockClusterList := v1alpha1.ClusterList{\n+\t\tListMeta: v1.ListMeta{},\n+\t\tItems: []v1alpha1.Cluster{\n+\t\t\tmockCluster,\n+\t\t},\n+\t}\n+\n+\tdb.On(\"ListClusters\", mock.Anything).Return(&mockClusterList, nil)\n+\tdb.On(\"GetCluster\", mock.Anything, mock.Anything).Return(&mockCluster, nil)\n+\n+\tserver := NewServer(db, newEnforcer(), newServerInMemoryCache(), &kubetest.MockKubectlCmd{})\n+\n+\tt.Run(\"Get\", func(t *testing.T) {\n+\t\t_, err := server.Get(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tName: \"cluster-not-exists\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\n+\t\t_, err = server.Get(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tName: \"test/ing\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\t})\n+\n+\tt.Run(\"Update\", func(t *testing.T) {\n+\t\t_, err := server.Update(context.Background(), &clusterapi.ClusterUpdateRequest{\n+\t\t\tCluster: &v1alpha1.Cluster{\n+\t\t\t\tName: \"cluster-not-exists\",\n+\t\t\t},\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\n+\t\t_, err = server.Update(context.Background(), &clusterapi.ClusterUpdateRequest{\n+\t\t\tCluster: &v1alpha1.Cluster{\n+\t\t\t\tName: \"test/ing\",\n+\t\t\t},\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\t})\n+\n+\tt.Run(\"Delete\", func(t *testing.T) {\n+\t\t_, err := server.Delete(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tServer: \"https://127.0.0.2\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\n+\t\t_, err = server.Delete(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tServer: \"https://127.0.0.1\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\t})\n+\n+\tt.Run(\"RotateAuth\", func(t *testing.T) {\n+\t\t_, err := server.RotateAuth(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tServer: \"https://127.0.0.2\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\n+\t\t_, err = server.RotateAuth(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tServer: \"https://127.0.0.1\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\t})\n+\n+\tt.Run(\"InvalidateCache\", func(t *testing.T) {\n+\t\t_, err := server.InvalidateCache(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tServer: \"https://127.0.0.2\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\n+\t\t_, err = server.InvalidateCache(context.Background(), &clusterapi.ClusterQuery{\n+\t\t\tServer: \"https://127.0.0.1\",\n+\t\t})\n+\t\tassert.Error(t, err)\n+\t\tassert.Equal(t, common.PermissionDeniedAPIError.Error(), err.Error(), \"error message must be _only_ the permission error, to avoid leaking information about cluster existence\")\n+\t})\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "544aea18c32b34eac523791e7e2ef186abbd6daf",
            "date": "2025-01-24T21:58:00Z",
            "author_login": "rpelczar"
          },
          {
            "sha": "75def4f2df3e27892292b8020bfb9100a2784105",
            "date": "2025-01-24T13:28:45Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c7e02eefdd6ea3e9ab84f4014724175dca0edac5",
            "date": "2025-01-24T13:16:35Z",
            "author_login": "reggie-k"
          },
          {
            "sha": "bd9923fd75439821639abe2697e3d99ed723c29b",
            "date": "2025-01-24T13:15:02Z",
            "author_login": "crenshaw-dev"
          },
          {
            "sha": "bcf2143dfee5c979d6ee97bbefcd8b82ff2c18dc",
            "date": "2025-01-23T11:12:44Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-209",
    "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. It\u2019s possible for authenticated users to enumerate clusters by name by inspecting error messages. It\u2019s also possible to enumerate the names of projects with project-scoped clusters if you know the names of the clusters. This vulnerability is fixed in 2.11.3, 2.10.12, and 2.9.17.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-06T15:15:45.023",
    "last_modified": "2024-11-21T09:21:37.303",
    "fix_date": "2024-06-06T08:30:10Z"
  },
  "references": [
    {
      "url": "https://github.com/argoproj/argo-cd/commit/c2647055c261a550e5da075793260f6524e65ad9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-3cqf-953p-h5cp",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/c2647055c261a550e5da075793260f6524e65ad9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-3cqf-953p-h5cp",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:26.343218",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "argo-cd",
    "owner": "argoproj",
    "created_at": "2018-02-09T11:12:01Z",
    "updated_at": "2025-01-26T07:30:32Z",
    "pushed_at": "2025-01-26T00:30:55Z",
    "size": 126760,
    "stars": 18517,
    "forks": 5658,
    "open_issues": 3618,
    "watchers": 18517,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 6748861,
      "TypeScript": 1301647,
      "Lua": 203056,
      "SCSS": 92996,
      "Shell": 58415,
      "Makefile": 24896,
      "Dockerfile": 15239,
      "Procfile": 10040,
      "JavaScript": 5975,
      "CSS": 2209,
      "Mustache": 1066,
      "HTML": 895
    },
    "commit_activity": {
      "total_commits_last_year": 1669,
      "avg_commits_per_week": 32.09615384615385,
      "days_active_last_year": 305
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:38:30.002178"
  }
}