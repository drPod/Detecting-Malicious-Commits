{
  "cve_id": "CVE-2024-36671",
  "github_data": {
    "repository": "nodemcu/nodemcu-firmware",
    "fix_commit": "193fe3593eb1537667179089535cdb7457327887",
    "related_commits": [
      "193fe3593eb1537667179089535cdb7457327887"
    ],
    "patch_url": "https://github.com/nodemcu/nodemcu-firmware/commit/193fe3593eb1537667179089535cdb7457327887.patch",
    "fix_commit_details": {
      "sha": "193fe3593eb1537667179089535cdb7457327887",
      "commit_date": "2022-07-10T15:01:21Z",
      "author": {
        "login": "HHHartmann",
        "type": "User",
        "stats": {
          "total_commits": 71,
          "average_weekly_commits": 0.13246268656716417,
          "total_additions": 7442,
          "total_deletions": 2922,
          "weeks_active": 36
        }
      },
      "commit_message": {
        "title": "Fix some bugs and problems in gossip (#3527)",
        "length": 433,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 91,
        "additions": 57,
        "deletions": 34
      },
      "files": [
        {
          "filename": ".github/workflows/build.yml",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -58,7 +58,7 @@ jobs:\n \n   build_luac_cross_win:\n \n-    runs-on: windows-latest\n+    runs-on: windows-2019\n \n     steps:\n     - uses: actions/checkout@v2"
        },
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -28,6 +28,8 @@ uz_zip\n \n # ignore VS Code files\n .vscode/**\n+# ignore VS files\n+.vs/**\n \n # ignore IDEA files\n .idea"
        },
        {
          "filename": "docs/lua-modules/gossip.md",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -68,7 +68,7 @@ gossip.setConfig(config)\n \n Sets the configuration for gossip. The available options are:\n \n-`seedList` : the list of seeds gossip will start with; this will be updated as new nodes are discovered. Note that it's enough for all nodes to start with the same IP in the seedList, as once they have one seed in common, the data will propagate\n+`seedList` : the list of seeds gossip will start with; this will be updated as new nodes are discovered. Note that it's enough for all nodes to start with the same IP in the seedList, as once they have one seed in common, the data will propagate. If the seedList is empty a broadcast is sent, so this can be used for automatic discovery of nodes.\n \n `roundInterval`: interval in milliseconds at which gossip will pick a random node from the seed list and send a `SYN` request\n "
        },
        {
          "filename": "lua_modules/gossip/gossip.lua",
          "status": "modified",
          "additions": 34,
          "deletions": 19,
          "patch": "@@ -15,11 +15,7 @@ end\n \n utils.debug = function(message)\n   if gossip.config.debug then\n-    if gossip.config.debugOutput then\n-      gossip.config.debugOutput(message);\n-    else\n-      print(message);\n-    end\n+    gossip.config.debugOutput(message);\n   end\n end\n \n@@ -105,15 +101,23 @@ state.start = function()\n     return;\n   end\n \n+  -- sending to own IP makes no sense\n+  for index, value in ipairs(gossip.config.seedList) do\n+      if value == gossip.ip then\n+          table.remove(gossip.config.seedList, index)\n+          utils.debug('removing own ip from seed list')\n+      end\n+  end\n+\n   gossip.networkState[gossip.ip] = {};\n   local localState = gossip.networkState[gossip.ip];\n   localState.revision = state.setRev();\n   localState.heartbeat = tmr.time();\n   localState.state = constants.nodeState.UP;\n \n-  gossip.inboundSocket = net.createUDPSocket();\n-  gossip.inboundSocket:listen(gossip.config.comPort);\n-  gossip.inboundSocket:on('receive', network.receiveData);\n+  gossip.socket = net.createUDPSocket();\n+  gossip.socket:listen(gossip.config.comPort);\n+  gossip.socket:on('receive', network.receiveData);\n \n   gossip.started = true;\n \n@@ -128,27 +132,38 @@ end\n state.tickNodeState = function(ip)\n   if gossip.networkState[ip] then\n     local nodeState = gossip.networkState[ip].state;\n+    local oldNodeState = nodeState;\n     if nodeState < constants.nodeState.REMOVE then\n       nodeState = nodeState + constants.nodeState.TICK;\n       gossip.networkState[ip].state = nodeState;\n     end\n+    if oldNodeState == constants.nodeState.DOWN then\n+      if gossip.updateCallback then gossip.updateCallback(gossip.networkState[ip]); end\n+    end\n   end\n end\n \n -- Network\n+network.broadcastIp = \"255.255.255.255\"\n \n network.pushGossip = function(data, ip)\n+  if not gossip.started then\n+    utils.debug('Gossip not started.');\n+    return;\n+  end\n   gossip.networkState[gossip.ip].data = data;\n   network.sendSyn(nil, ip);\n end\n \n network.updateNetworkState = function(updateData)\n   if gossip.updateCallback then gossip.updateCallback(updateData); end\n   for ip, data in pairs(updateData) do\n-    if not utils.contains(gossip.config.seedList, ip) then\n+    if not utils.contains(gossip.config.seedList, ip) and ip ~= network.broadcastIp and ip ~= gossip.ip then\n       table.insert(gossip.config.seedList, ip);\n     end\n-    gossip.networkState[ip] = data;\n+    if ip ~= gossip.ip then\n+      gossip.networkState[ip] = data;\n+    end\n   end\n end\n \n@@ -170,17 +185,16 @@ network.pickRandomNode = function()\n     return gossip.config.seedList[randomListPick];\n   end\n   utils.debug(\n-      'Seedlist is empty. Please provide one or wait for node to be contacted.');\n-  return nil;\n+      'Seedlist is empty. Using broadcast IP '..network.broadcastIp..' to discover.');\n+  return network.broadcastIp;\n end\n \n network.sendData = function(ip, data, sendType)\n-  local outboundSocket = net.createUDPSocket();\n-  data.type = sendType;\n-  local dataToSend = sjson.encode(data);\n-  data.type = nil;\n-  outboundSocket:send(gossip.config.comPort, ip, dataToSend);\n-  outboundSocket:close();\n+  data.type = sendType\n+  local dataToSend = sjson.encode(data)\n+  data.type = nil\n+  gossip.socket:send(gossip.config.comPort, ip, dataToSend)\n+  utils.debug(\"Sent \"..#dataToSend..\" bytes\")\n end\n \n network.receiveSyn = function(ip, synData)\n@@ -235,7 +249,8 @@ constants.defaultConfig = {\n   seedList = {},\n   roundInterval = 15000,\n   comPort = 5000,\n-  debug = false\n+  debug = false,\n+  debugOutput = print\n };\n \n constants.comparisonFields = {'revision', 'heartbeat', 'state'};"
        },
        {
          "filename": "lua_modules/gossip/gossip_tests.lua",
          "status": "modified",
          "additions": 13,
          "deletions": 7,
          "patch": "@@ -24,6 +24,7 @@ file.putcontents = dummy\n \n local Ip_1 = '192.168.0.1';\n local Ip_2 = '192.168.0.2';\n+local Ip_own = '192.168.0.3';\n \n -- test runner\n \n@@ -186,20 +187,19 @@ function Test.utils_getMinus()\n     state = constants.nodeState.SUSPECT;\n   };\n \n-  --local diff1 = utils.getMinus(data1, data2);\n+  local diff1 = utils.getMinus(data1, data2);\n   local diff2 = utils.getMinus(data2, data1);\n \n-  --assert(diff1[Ip_1] ~= nil and diff1[Ip_2] == nil);\n+  assert(diff1[Ip_1] ~= nil and diff1[Ip_2] == nil);\n   assert(diff2[Ip_1] == nil and diff2[Ip_2] ~= nil);\n-\n end\n \n -- state\n \n function Test.state_setRev()\n-  gossip.ip = Ip_1;\n-  gossip.networkState[Ip_1] = {};\n-  gossip.networkState[Ip_1].revision = -1;\n+  gossip.ip = Ip_own;\n+  gossip.networkState[Ip_own] = {};\n+  gossip.networkState[Ip_own].revision = -1;\n   assert(state.setRev() == 0, 'Revision not initialized to 0.');\n end\n \n@@ -223,6 +223,7 @@ end\n -- network\n \n function Test.network_updateNetworkState_no_callback()\n+  gossip.ip = Ip_own;\n   local updateData = {}\n   updateData[Ip_1] = {\n     revision = 1,\n@@ -232,7 +233,12 @@ function Test.network_updateNetworkState_no_callback()\n   updateData[Ip_2] = {\n     revision = 1,\n     heartbeat = 700,\n-    state = constants.nodeState.UP\n+    state = constants.nodeState.DOWN\n+  };\n+  updateData[Ip_own] = {\n+    revision = 1,\n+    heartbeat = 800,\n+    state = constants.nodeState.DOWN\n   };\n   network.updateNetworkState(updateData);\n   -- send duplicate data"
        },
        {
          "filename": "lua_modules/yeelink/yeelink_lib.lua",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -54,10 +54,10 @@ end)\n -- apikey must be -> string <-\n -- e.g. xxx.init(00000,00000,\"123j12b3jkb12k4b23bv54i2b5b3o4\")\n --========================================\n-function M.init(_device, _sensor, _apikey)\n-    device = tostring(_device)\n-    sensor = tostring(_sensor)\n-    apikey = _apikey\n+function M.init(device_, sensor_, apikey_)\n+    device = tostring(device_)\n+    sensor = tostring(sensor_)\n+    apikey = apikey_\n     if dns == \"0.0.0.0\" then\n       tmr.create():alarm(5000,tmr.ALARM_AUTO,function ()\n         if dns == \"0.0.0.0\" then\n@@ -90,9 +90,9 @@ end\n --\n --e.g. xxx.update(233.333)\n --============================================================\n-function M.update(_datapoint)\n+function M.update(datapoint_)\n \n-    datapoint = tostring(_datapoint)\n+    datapoint = tostring(datapoint_)\n \n     sk:on(\"connection\", function()\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "36cbf9f017d356319a6369e299765eedff191154",
            "date": "2024-02-25T08:04:43Z",
            "author_login": "HHHartmann"
          },
          {
            "sha": "a492a31e9c55f4cf3d74004a108a91878f94eaec",
            "date": "2024-02-25T08:01:01Z",
            "author_login": "HHHartmann"
          },
          {
            "sha": "3d09b7471967e5957abab2d4cca659a3ea05ca21",
            "date": "2024-02-25T08:00:08Z",
            "author_login": "HHHartmann"
          },
          {
            "sha": "0b879ce126fca1b281fcccd56d6aa685a0bd8a8d",
            "date": "2024-02-18T22:00:21Z",
            "author_login": "marcelstoer"
          },
          {
            "sha": "7971be78fcccfec2a3e301519afc307fc4c7844c",
            "date": "2024-02-18T21:14:27Z",
            "author_login": "marcelstoer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-190",
    "description": "nodemcu before v3.0.0-release_20240225 was discovered to contain an integer overflow via the getnum function at /modules/struct.c.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-11-29T15:15:17.027",
    "last_modified": "2024-12-04T17:15:13.437",
    "fix_date": "2022-07-10T15:01:21Z"
  },
  "references": [
    {
      "url": "https://github.com/nodemcu/nodemcu-firmware/commit/193fe3593eb1537667179089535cdb7457327887#diff-5c3fa597431eda03ac3339ae6bf7f05e1a50d6fc7333679ec38e21b337cb6721",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/nodemcu/nodemcu-firmware/issues/3626",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/nodemcu/nodemcu-firmware/pull/3633",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/nodemcu/nodemcu-firmware/pull/3634",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/nodemcu/nodemcu-firmware/pull/3635",
      "source": "cve@mitre.org",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.314759",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nodemcu-firmware",
    "owner": "nodemcu",
    "created_at": "2014-11-20T15:06:45Z",
    "updated_at": "2025-01-13T20:11:10Z",
    "pushed_at": "2024-12-21T22:29:52Z",
    "size": 113118,
    "stars": 7716,
    "forks": 3123,
    "open_issues": 115,
    "watchers": 7716,
    "has_security_policy": false,
    "default_branch": "release",
    "protected_branches": [
      "1.5.4.1-final",
      "dev-esp32-idf3-final"
    ],
    "languages": {
      "C": 11337820,
      "Lua": 671852,
      "Makefile": 85173,
      "C++": 29289,
      "Python": 17073,
      "Shell": 14671,
      "Tcl": 10995,
      "Assembly": 8901,
      "HTML": 8441,
      "GDB": 853
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:13:26.608182"
  }
}