{
  "cve_id": "CVE-2024-37158",
  "github_data": {
    "repository": "evmos/evmos",
    "fix_commit": "b2a09ca66613d8b04decd3f2dcba8e1e77709dcb",
    "related_commits": [
      "b2a09ca66613d8b04decd3f2dcba8e1e77709dcb",
      "b2a09ca66613d8b04decd3f2dcba8e1e77709dcb"
    ],
    "patch_url": "https://github.com/evmos/evmos/commit/b2a09ca66613d8b04decd3f2dcba8e1e77709dcb.patch",
    "fix_commit_details": {
      "sha": "b2a09ca66613d8b04decd3f2dcba8e1e77709dcb",
      "commit_date": "2024-04-22T14:08:28Z",
      "author": {
        "login": "GAtom22",
        "type": "User",
        "stats": {
          "total_commits": 490,
          "average_weekly_commits": 2.832369942196532,
          "total_additions": 373357,
          "total_deletions": 176025,
          "weeks_active": 101
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-pxv8-qhrh-jc7v",
        "length": 167,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 3446,
        "additions": 2489,
        "deletions": 957
      },
      "files": [
        {
          "filename": "app/ante/cosmos/vesting.go",
          "status": "removed",
          "additions": 0,
          "deletions": 123,
          "patch": "@@ -1,123 +0,0 @@\n-// Copyright Tharsis Labs Ltd.(Evmos)\n-// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n-package cosmos\n-\n-import (\n-\terrorsmod \"cosmossdk.io/errors\"\n-\t\"github.com/cosmos/cosmos-sdk/codec\"\n-\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n-\terrortypes \"github.com/cosmos/cosmos-sdk/types/errors\"\n-\t\"github.com/cosmos/cosmos-sdk/x/authz\"\n-\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n-\tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n-\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n-)\n-\n-// TODO: remove once Cosmos SDK is upgraded to v0.46\n-\n-// VestingDelegationDecorator validates delegation of vested coins\n-type VestingDelegationDecorator struct {\n-\tak  evmtypes.AccountKeeper\n-\tsk  vestingtypes.StakingKeeper\n-\tbk  evmtypes.BankKeeper\n-\tcdc codec.BinaryCodec\n-}\n-\n-// NewVestingDelegationDecorator creates a new VestingDelegationDecorator\n-func NewVestingDelegationDecorator(ak evmtypes.AccountKeeper, sk vestingtypes.StakingKeeper, bk evmtypes.BankKeeper, cdc codec.BinaryCodec) VestingDelegationDecorator {\n-\treturn VestingDelegationDecorator{\n-\t\tak:  ak,\n-\t\tsk:  sk,\n-\t\tbk:  bk,\n-\t\tcdc: cdc,\n-\t}\n-}\n-\n-// AnteHandle checks if the tx contains a staking delegation.\n-// It errors if the coins are still locked or the bond amount is greater than\n-// the coins already vested\n-func (vdd VestingDelegationDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) {\n-\tfor _, msg := range tx.GetMsgs() {\n-\t\tswitch msg := msg.(type) {\n-\t\tcase *authz.MsgExec:\n-\t\t\t// Check for bypassing authorization\n-\t\t\tif err := vdd.validateAuthz(ctx, msg); err != nil {\n-\t\t\t\treturn ctx, err\n-\t\t\t}\n-\t\tdefault:\n-\t\t\tif err := vdd.validateMsg(ctx, msg); err != nil {\n-\t\t\t\treturn ctx, err\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn next(ctx, tx, simulate)\n-}\n-\n-// validateAuthz validates the authorization internal message\n-func (vdd VestingDelegationDecorator) validateAuthz(ctx sdk.Context, execMsg *authz.MsgExec) error {\n-\tfor _, v := range execMsg.Msgs {\n-\t\tvar innerMsg sdk.Msg\n-\t\tif err := vdd.cdc.UnpackAny(v, &innerMsg); err != nil {\n-\t\t\treturn errorsmod.Wrap(err, \"cannot unmarshal authz exec msgs\")\n-\t\t}\n-\n-\t\tif err := vdd.validateMsg(ctx, innerMsg); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-// validateMsg checks that the only vested coins can be delegated\n-func (vdd VestingDelegationDecorator) validateMsg(ctx sdk.Context, msg sdk.Msg) error {\n-\tdelegateMsg, ok := msg.(*stakingtypes.MsgDelegate)\n-\tif !ok {\n-\t\treturn nil\n-\t}\n-\n-\tfor _, addr := range msg.GetSigners() {\n-\t\tacc := vdd.ak.GetAccount(ctx, addr)\n-\t\tif acc == nil {\n-\t\t\treturn errorsmod.Wrapf(\n-\t\t\t\terrortypes.ErrUnknownAddress,\n-\t\t\t\t\"account %s does not exist\", addr,\n-\t\t\t)\n-\t\t}\n-\n-\t\tclawbackAccount, isClawback := acc.(*vestingtypes.ClawbackVestingAccount)\n-\t\tif !isClawback {\n-\t\t\t// continue to next decorator as this logic only applies to vesting\n-\t\t\treturn nil\n-\t\t}\n-\n-\t\t// error if bond amount is > vested coins\n-\t\tbondDenom := vdd.sk.BondDenom(ctx)\n-\t\tcoins := clawbackAccount.GetVestedOnly(ctx.BlockTime())\n-\t\tif coins == nil || coins.Empty() {\n-\t\t\treturn errorsmod.Wrap(\n-\t\t\t\tvestingtypes.ErrInsufficientVestedCoins,\n-\t\t\t\t\"account has no vested coins\",\n-\t\t\t)\n-\t\t}\n-\n-\t\tbalance := vdd.bk.GetBalance(ctx, addr, bondDenom)\n-\t\tunvestedOnly := clawbackAccount.GetUnvestedOnly(ctx.BlockTime())\n-\t\tspendable, hasNeg := sdk.Coins{balance}.SafeSub(unvestedOnly...)\n-\t\tif hasNeg {\n-\t\t\tspendable = sdk.NewCoins()\n-\t\t}\n-\n-\t\tvested := spendable.AmountOf(bondDenom)\n-\t\tif vested.LT(delegateMsg.Amount.Amount) {\n-\t\t\treturn errorsmod.Wrapf(\n-\t\t\t\tvestingtypes.ErrInsufficientVestedCoins,\n-\t\t\t\t\"cannot delegate unvested coins. coins vested < delegation amount (%s < %s)\",\n-\t\t\t\tvested, delegateMsg.Amount.Amount,\n-\t\t\t)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}"
        },
        {
          "filename": "app/ante/handler_options.go",
          "status": "modified",
          "additions": 0,
          "deletions": 2,
          "patch": "@@ -119,7 +119,6 @@ func newCosmosAnteHandler(options HandlerOptions) sdk.AnteHandler {\n \t\tcosmosante.NewMinGasPriceDecorator(options.FeeMarketKeeper, options.EvmKeeper),\n \t\tante.NewConsumeGasForTxSizeDecorator(options.AccountKeeper),\n \t\tcosmosante.NewDeductFeeDecorator(options.AccountKeeper, options.BankKeeper, options.DistributionKeeper, options.FeegrantKeeper, options.StakingKeeper, options.TxFeeChecker),\n-\t\tcosmosante.NewVestingDelegationDecorator(options.AccountKeeper, options.StakingKeeper, options.BankKeeper, options.Cdc),\n \t\t// SetPubKeyDecorator must be called before all signature verification decorators\n \t\tante.NewSetPubKeyDecorator(options.AccountKeeper),\n \t\tante.NewValidateSigCountDecorator(options.AccountKeeper),\n@@ -146,7 +145,6 @@ func newLegacyCosmosAnteHandlerEip712(options HandlerOptions) sdk.AnteHandler {\n \t\tante.NewValidateMemoDecorator(options.AccountKeeper),\n \t\tante.NewConsumeGasForTxSizeDecorator(options.AccountKeeper),\n \t\tcosmosante.NewDeductFeeDecorator(options.AccountKeeper, options.BankKeeper, options.DistributionKeeper, options.FeegrantKeeper, options.StakingKeeper, options.TxFeeChecker),\n-\t\tcosmosante.NewVestingDelegationDecorator(options.AccountKeeper, options.StakingKeeper, options.BankKeeper, options.Cdc),\n \t\t// SetPubKeyDecorator must be called before all signature verification decorators\n \t\tante.NewSetPubKeyDecorator(options.AccountKeeper),\n \t\tante.NewValidateSigCountDecorator(options.AccountKeeper),"
        },
        {
          "filename": "app/app.go",
          "status": "modified",
          "additions": 9,
          "deletions": 8,
          "patch": "@@ -88,8 +88,7 @@ import (\n \t\"github.com/cosmos/cosmos-sdk/x/slashing\"\n \tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n \tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n-\t\"github.com/cosmos/cosmos-sdk/x/staking\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\tsdkstaking \"github.com/cosmos/cosmos-sdk/x/staking\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/cosmos/cosmos-sdk/x/upgrade\"\n \tupgradeclient \"github.com/cosmos/cosmos-sdk/x/upgrade/client\"\n@@ -161,6 +160,8 @@ import (\n \tinflation \"github.com/evmos/evmos/v18/x/inflation/v1\"\n \tinflationkeeper \"github.com/evmos/evmos/v18/x/inflation/v1/keeper\"\n \tinflationtypes \"github.com/evmos/evmos/v18/x/inflation/v1/types\"\n+\t\"github.com/evmos/evmos/v18/x/staking\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n \trevenue \"github.com/evmos/evmos/v18/x/revenue/v1\"\n \trevenuekeeper \"github.com/evmos/evmos/v18/x/revenue/v1/keeper\"\n \trevenuetypes \"github.com/evmos/evmos/v18/x/revenue/v1/types\"\n@@ -212,7 +213,7 @@ var (\n \t\tgenutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n \t\tbank.AppModuleBasic{},\n \t\tcapability.AppModuleBasic{},\n-\t\tstaking.AppModuleBasic{},\n+\t\tstaking.AppModuleBasic{AppModuleBasic: &sdkstaking.AppModuleBasic{}},\n \t\tdistr.AppModuleBasic{},\n \t\tgov.NewAppModuleBasic(\n \t\t\t[]govclient.ProposalHandler{\n@@ -646,12 +647,12 @@ func NewEvmos(\n \t\tevm.NewAppModule(app.EvmKeeper, app.AccountKeeper, app.GetSubspace(evmtypes.ModuleName)),\n \t\tfeemarket.NewAppModule(app.FeeMarketKeeper, app.GetSubspace(feemarkettypes.ModuleName)),\n \t\t// Evmos app modules\n-\t\tinflation.NewAppModule(app.InflationKeeper, app.AccountKeeper, app.StakingKeeper,\n+\t\tinflation.NewAppModule(app.InflationKeeper, app.AccountKeeper, *app.StakingKeeper.Keeper,\n \t\t\tapp.GetSubspace(inflationtypes.ModuleName)),\n \t\terc20.NewAppModule(app.Erc20Keeper, app.AccountKeeper,\n \t\t\tapp.GetSubspace(erc20types.ModuleName)),\n \t\tepochs.NewAppModule(appCodec, app.EpochsKeeper),\n-\t\tvesting.NewAppModule(app.VestingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper),\n+\t\tvesting.NewAppModule(app.VestingKeeper, app.AccountKeeper, app.BankKeeper, *app.StakingKeeper.Keeper),\n \t\trevenue.NewAppModule(app.RevenueKeeper, app.AccountKeeper,\n \t\t\tapp.GetSubspace(revenuetypes.ModuleName)),\n \t)\n@@ -1195,7 +1196,7 @@ func (app *Evmos) setupUpgradeHandlers() {\n \t\tv10.UpgradeName,\n \t\tv10.CreateUpgradeHandler(\n \t\t\tapp.mm, app.configurator,\n-\t\t\tapp.StakingKeeper,\n+\t\t\t*app.StakingKeeper.Keeper,\n \t\t),\n \t)\n \n@@ -1206,7 +1207,7 @@ func (app *Evmos) setupUpgradeHandlers() {\n \t\t\tapp.mm, app.configurator,\n \t\t\tapp.AccountKeeper,\n \t\t\tapp.BankKeeper,\n-\t\t\tapp.StakingKeeper,\n+\t\t\t*app.StakingKeeper.Keeper,\n \t\t\tapp.DistrKeeper,\n \t\t),\n \t)\n@@ -1252,7 +1253,7 @@ func (app *Evmos) setupUpgradeHandlers() {\n \t\t\tapp.mm, app.configurator,\n \t\t\tapp.BankKeeper,\n \t\t\tapp.EvmKeeper,\n-\t\t\tapp.StakingKeeper,\n+\t\t\t*app.StakingKeeper.Keeper,\n \t\t),\n \t)\n "
        },
        {
          "filename": "app/export.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -50,7 +50,7 @@ func (app *Evmos) ExportAppStateAndValidators(\n \t\treturn servertypes.ExportedApp{}, err\n \t}\n \n-\tvalidators, err := staking.WriteValidators(ctx, &app.StakingKeeper)\n+\tvalidators, err := staking.WriteValidators(ctx, app.StakingKeeper.Keeper)\n \tif err != nil {\n \t\treturn servertypes.ExportedApp{}, err\n \t}"
        },
        {
          "filename": "app/upgrades/v11/upgrades_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -107,7 +107,7 @@ func (suite *UpgradeTestSuite) setValidators(validatorsAddr []string) {\n \t\tvalidator, err := stakingtypes.NewValidator(valAddr, suite.consKey, stakingtypes.Description{})\n \t\tsuite.Require().NoError(err)\n \n-\t\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\t\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \n \t\terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \t\tsuite.Require().NoError(err)\n@@ -253,7 +253,7 @@ func (suite *UpgradeTestSuite) TestDistributeRewards() {\n \t\t\tsuite.Require().Equal(math.ZeroInt(), initialDel)\n \n \t\t\tif utils.IsMainnet(tc.chainID) {\n-\t\t\t\tv11.HandleRewardDistribution(suite.ctx, suite.app.Logger(), suite.app.BankKeeper, suite.app.StakingKeeper, suite.app.DistrKeeper)\n+\t\t\t\tv11.HandleRewardDistribution(suite.ctx, suite.app.Logger(), suite.app.BankKeeper, *suite.app.StakingKeeper.Keeper, suite.app.DistrKeeper)\n \t\t\t}\n \n \t\t\t// account not in list should NOT get rewards"
        },
        {
          "filename": "app/upgrades/v14/migrations_test.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -136,11 +136,11 @@ func (s *UpgradesTestSuite) TestUpdateMigrateNativeMultisigs() {\n \texpectedSharesMap[s.validators[0].OperatorAddress] = expectedSharesMap[s.validators[0].OperatorAddress].Sub(delegateShares)\n \n \t// Migrate strategic reserves\n-\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, s.app.StakingKeeper, newStrategicReserve.Addr, oldStrategicReservesAddrs...)\n+\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, *s.app.StakingKeeper.Keeper, newStrategicReserve.Addr, oldStrategicReservesAddrs...)\n \ts.Require().NoError(err, \"failed to migrate strategic reserves\")\n \n \t// Migrate premint wallet\n-\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, s.app.StakingKeeper, newPremintWallet.Addr, oldPremintWallet.Addr.String())\n+\terr = v14.MigrateNativeMultisigs(s.ctx, s.app.BankKeeper, *s.app.StakingKeeper.Keeper, newPremintWallet.Addr, oldPremintWallet.Addr.String())\n \ts.Require().NoError(err, \"failed to migrate premint wallet\")\n \n \t// Check that the multisigs have been updated\n@@ -162,7 +162,7 @@ func (s *UpgradesTestSuite) TestInstantUnbonding() {\n \tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, s.address.Bytes(), s.validators[0].GetOperator())\n \ts.Require().True(found, \"delegation not found\")\n \n-\tunbondAmount, err := v14.InstantUnbonding(s.ctx, s.app.BankKeeper, s.app.StakingKeeper, delegation, s.bondDenom)\n+\tunbondAmount, err := v14.InstantUnbonding(s.ctx, s.app.BankKeeper, *s.app.StakingKeeper.Keeper, delegation, s.bondDenom)\n \ts.Require().NoError(err, \"failed to unbond\")\n \ts.Require().Equal(unbondAmount, math.NewInt(1e18), \"expected different unbond amount\")\n "
        },
        {
          "filename": "precompiles/distribution/distribution.go",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -8,15 +8,14 @@ import (\n \t\"embed\"\n \t\"fmt\"\n \n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n-\n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n \tdistributionkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n var _ vm.PrecompiledContract = &Precompile{}"
        },
        {
          "filename": "precompiles/distribution/integration_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -204,7 +204,7 @@ var _ = Describe(\"Calling distribution precompile from EOA\", func() {\n \t\t\t// create a validator with s.address and s.privKey because this account is\n \t\t\t// used for signing txs\n \t\t\tstakeAmt = math.NewInt(100)\n-\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, stakeAmt)\n+\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, stakeAmt)\n \n \t\t\t// set some validator commission\n \t\t\tvalAddr = s.address.Bytes()\n@@ -793,7 +793,7 @@ var _ = Describe(\"Calling distribution precompile from another contract\", func()\n \t\t\t// used for signing txs\n \t\t\tvalAddr = s.address.Bytes()\n \t\t\tstakeAmt := math.NewInt(100)\n-\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, stakeAmt)\n+\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, stakeAmt)\n \n \t\t\t// set some commissions to validators\n \t\t\tvar valAddresses []sdk.ValAddress"
        },
        {
          "filename": "precompiles/distribution/utils_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -243,7 +243,7 @@ func (s *PrecompileTestSuite) prepareStakingRewards(stkRs ...stakingRewards) {\n \t\ts.Require().NoError(err)\n \n \t\t// end block to bond validator and increase block height\n-\t\tsdkstaking.EndBlocker(s.ctx, &s.app.StakingKeeper)\n+\t\tsdkstaking.EndBlocker(s.ctx, s.app.StakingKeeper.Keeper)\n \t\t// allocate rewards to validator (of these 50% will be paid out to the delegator)\n \t\tallocatedRewards := sdk.NewDecCoins(sdk.NewDecCoin(s.bondDenom, r.RewardAmt.Mul(math.NewInt(2))))\n \t\ts.app.DistrKeeper.AllocateTokensToValidator(s.ctx, r.Validator, allocatedRewards)"
        },
        {
          "filename": "precompiles/outposts/osmosis/osmosis.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -10,7 +10,6 @@ import (\n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n \tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tclienttypes \"github.com/cosmos/ibc-go/v7/modules/core/02-client/types\"\n \tchannelkeeper \"github.com/cosmos/ibc-go/v7/modules/core/04-channel/keeper\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n@@ -20,6 +19,7 @@ import (\n \t\"github.com/evmos/evmos/v18/precompiles/ics20\"\n \terc20keeper \"github.com/evmos/evmos/v18/x/erc20/keeper\"\n \ttransferkeeper \"github.com/evmos/evmos/v18/x/ibc/transfer/keeper\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n const ("
        },
        {
          "filename": "precompiles/outposts/stride/stride.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -9,7 +9,6 @@ import (\n \n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tclienttypes \"github.com/cosmos/ibc-go/v7/modules/core/02-client/types\"\n \n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n@@ -19,6 +18,7 @@ import (\n \t\"github.com/evmos/evmos/v18/precompiles/ics20\"\n \terc20keeper \"github.com/evmos/evmos/v18/x/erc20/keeper\"\n \ttransferkeeper \"github.com/evmos/evmos/v18/x/ibc/transfer/keeper\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n var _ vm.PrecompiledContract = &Precompile{}"
        },
        {
          "filename": "precompiles/staking/integration_test.go",
          "status": "modified",
          "additions": 397,
          "deletions": 1,
          "patch": "@@ -20,6 +20,7 @@ import (\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \tcompiledcontracts \"github.com/evmos/evmos/v18/contracts\"\n+\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n \t\"github.com/evmos/evmos/v18/precompiles/distribution\"\n@@ -29,6 +30,7 @@ import (\n \t\"github.com/evmos/evmos/v18/precompiles/testutil/contracts\"\n \tevmosutil \"github.com/evmos/evmos/v18/testutil\"\n \ttestutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n )\n \n // General variables used for integration tests\n@@ -736,6 +738,219 @@ var _ = Describe(\"Calling staking precompile directly\", func() {\n \t\t})\n \t})\n \n+\tDescribe(\"Calling precompile txs from a vesting account\", func() {\n+\t\tvar (\n+\t\t\tfunder          common.Address\n+\t\t\tvestAcc         common.Address\n+\t\t\tvestAccPriv     *ethsecp256k1.PrivKey\n+\t\t\tclawbackAccount *vestingtypes.ClawbackVestingAccount\n+\t\t\tunvested        sdk.Coins\n+\t\t\tvested          sdk.Coins\n+\t\t\t// unlockedVested are unlocked vested coins of the vesting schedule\n+\t\t\tunlockedVested      sdk.Coins\n+\t\t\tdefaultDelegateArgs contracts.CallArgs\n+\t\t)\n+\n+\t\tBeforeEach(func() {\n+\t\t\t// Setup vesting account\n+\t\t\tfunder = s.address\n+\t\t\tvestAcc, vestAccPriv = testutiltx.NewAddrKey()\n+\t\t\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\n+\t\t\tclawbackAccount = s.setupVestingAccount(funder.Bytes(), vestAcc.Bytes())\n+\n+\t\t\t// Check if all tokens are unvested at vestingStart\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tExpect(vestingAmtTotal).To(Equal(unvested))\n+\t\t\tExpect(vested.IsZero()).To(BeTrue())\n+\n+\t\t\t// populate the default delegate args\n+\t\t\tdefaultDelegateArgs = defaultCallArgs.WithMethodName(staking.DelegateMethod)\n+\t\t\tdefaultDelegateArgs = defaultDelegateArgs.WithPrivKey(vestAccPriv)\n+\t\t})\n+\n+\t\tContext(\"before first vesting period - all tokens locked and unvested\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\ts.NextBlock()\n+\n+\t\t\t\t// Ensure no tokens are vested\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.ZeroInt()))\n+\t\t\t\tExpect(vested).To(Equal(zeroCoins), \"expected different vested coins\")\n+\t\t\t\tExpect(unvested).To(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins), \"expected different unvested coins\")\n+\t\t\t\tExpect(unlocked).To(Equal(zeroCoins), \"expected different unlocked coins\")\n+\t\t\t})\n+\n+\t\t\tIt(\"Should not be able to delegate unvested tokens\", func() {\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), unvested.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tfailCheck := defaultLogCheck.\n+\t\t\t\t\tWithErrContains(\"cannot delegate unvested coins\")\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, failCheck)\n+\t\t\t\tExpect(err).NotTo(BeNil(), \"error while calling the smart contract: %v\", err)\n+\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"coins available for delegation < delegation amount\"))\n+\t\t\t})\n+\n+\t\t\tIt(\"Should be able to delegate tokens not involved in vesting schedule\", func() {\n+\t\t\t\t// send some coins to the vesting account\n+\t\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), coinsToDelegate)\n+\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t// check balance is updated\n+\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\t\t\t\tExpect(balance).To(Equal(accountGasCoverage[0].Add(evmosutil.TestVestingSchedule.TotalVestingCoins[0]).Add(coinsToDelegate[0])))\n+\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\n+\t\t\t\t// check vesting balance is untouched\n+\t\t\t\tbalancePost := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\t\t\t\tExpect(balancePost.IsGTE(evmosutil.TestVestingSchedule.TotalVestingCoins[0])).To(BeTrue())\n+\t\t\t})\n+\t\t})\n+\n+\t\tContext(\"after first vesting period and before lockup - some vested tokens, but still all locked\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// Surpass cliff but none of lockup duration\n+\t\t\t\tcliffDuration := time.Duration(evmosutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\ts.NextBlockAfter(cliffDuration * time.Second)\n+\n+\t\t\t\t// Check if some, but not all tokens are vested\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.CliffMonths))))\n+\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins), \"expected some tokens to have been vested\")\n+\t\t\t\tExpect(vested).To(Equal(expVested), \"expected different vested amount\")\n+\n+\t\t\t\t// check the vested tokens are still locked\n+\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tExpect(unlockedVested).To(Equal(sdk.Coins{}))\n+\n+\t\t\t\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\t\t\t\tres, err := s.app.VestingKeeper.Balances(s.ctx, &vestingtypes.QueryBalancesRequest{Address: clawbackAccount.Address})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(res.Vested).To(Equal(expVested))\n+\t\t\t\tExpect(res.Unvested).To(Equal(vestingAmtTotal.Sub(expVested...)))\n+\t\t\t\t// All coins from vesting schedule should be locked\n+\t\t\t\tExpect(res.Locked).To(Equal(vestingAmtTotal))\n+\t\t\t})\n+\n+\t\t\tIt(\"Should be able to delegate locked vested tokens\", func() {\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), vested[0].Amount.BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(vested[0].Amount.BigInt()))\n+\t\t\t})\n+\n+\t\t\tIt(\"Should be able to delegate locked vested tokens + free tokens (not in vesting schedule)\", func() {\n+\t\t\t\t// send some coins to the vesting account\n+\t\t\t\tamt := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), amt)\n+\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t// check balance is updated\n+\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\t\t\t\tExpect(balance).To(Equal(accountGasCoverage[0].Add(evmosutil.TestVestingSchedule.TotalVestingCoins[0]).Add(amt[0])))\n+\n+\t\t\t\tcoinsToDelegate := amt.Add(vested...)\n+\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate[0].Amount.BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\t\t\t})\n+\t\t})\n+\n+\t\tContext(\"Between first and second lockup periods - vested coins are unlocked\", func() {\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// Surpass first lockup\n+\t\t\t\tvestDuration := time.Duration(evmosutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\ts.NextBlockAfter(vestDuration * time.Second)\n+\n+\t\t\t\t// Check if some, but not all tokens are vested and unlocked\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\n+\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\texpUnlockedVested := expVested\n+\n+\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins), \"expected not all tokens to be vested\")\n+\t\t\t\tExpect(vested).To(Equal(expVested), \"expected different amount of vested tokens\")\n+\t\t\t\t// all vested coins are unlocked\n+\t\t\t\tExpect(unlockedVested).To(Equal(vested))\n+\t\t\t\tExpect(unlocked).To(Equal(evmosutil.TestVestingSchedule.UnlockedCoinsPerLockup))\n+\t\t\t\tExpect(unlockedVested).To(Equal(expUnlockedVested))\n+\t\t\t})\n+\t\t\tIt(\"Should be able to delegate unlocked vested tokens\", func() {\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), unlockedVested[0].Amount.BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(unlockedVested[0].Amount.BigInt()))\n+\t\t\t})\n+\n+\t\t\tIt(\"Cannot delegate more than vested tokens (and free tokens)\", func() {\n+\t\t\t\t// calculate the delegatable amount\n+\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, vestAcc.Bytes(), s.bondDenom)\n+\t\t\t\tunvestedOnly := clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\tdelegatable := balance.Sub(unvestedOnly[0])\n+\n+\t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n+\t\t\t\t\tvestAcc, valAddr.String(), delegatable.Amount.Add(sdk.OneInt()).BigInt(),\n+\t\t\t\t)\n+\n+\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\tExpect(err).NotTo(BeNil(), \"error while calling the smart contract: %v\", err)\n+\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins\"))\n+\n+\t\t\t\t_, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\tExpect(found).To(BeFalse(), \"expected delegation NOT to be found\")\n+\t\t\t})\n+\t\t})\n+\t})\n+\n \tDescribe(\"to query allowance\", func() {\n \t\tvar (\n \t\t\tdefaultAllowanceArgs contracts.CallArgs\n@@ -1649,7 +1864,7 @@ var _ = Describe(\"Calling staking precompile via Solidity\", func() {\n \n \t\t\tIt(\"shouldn't delegate to a validator that is not in the allow list of the approval\", func() {\n \t\t\t\t// create a new validator, which is not included in the active set of the last block\n-\t\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, math.NewInt(100))\n+\t\t\t\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, math.NewInt(100))\n \t\t\t\tnewValAddr := sdk.ValAddress(s.address.Bytes())\n \n \t\t\t\tdelegateArgs := defaultDelegateArgs.WithArgs(\n@@ -1663,6 +1878,187 @@ var _ = Describe(\"Calling staking precompile via Solidity\", func() {\n \t\t\t\tExpect(delegation.GetShares()).To(Equal(math.LegacyNewDecFromInt(math.NewInt(100))), \"expected only the delegation from creating the validator, no more\")\n \t\t\t})\n \t\t})\n+\t\tDescribe(\"delegation from a vesting account\", func() {\n+\t\t\tvar (\n+\t\t\t\tfunder          common.Address\n+\t\t\t\tvestAcc         common.Address\n+\t\t\t\tvestAccPriv     *ethsecp256k1.PrivKey\n+\t\t\t\tclawbackAccount *vestingtypes.ClawbackVestingAccount\n+\t\t\t\tunvested        sdk.Coins\n+\t\t\t\tvested          sdk.Coins\n+\t\t\t\t// unlockedVested are unlocked vested coins of the vesting schedule\n+\t\t\t\tunlockedVested sdk.Coins\n+\t\t\t\tdefaultArgs    contracts.CallArgs\n+\t\t\t)\n+\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// Setup vesting account\n+\t\t\t\tfunder = s.address\n+\t\t\t\tvestAcc, vestAccPriv = testutiltx.NewAddrKey()\n+\n+\t\t\t\tclawbackAccount = s.setupVestingAccount(funder.Bytes(), vestAcc.Bytes())\n+\n+\t\t\t\t// Check if all tokens are unvested at vestingStart\n+\t\t\t\ttotalVestingCoins := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\t\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tExpect(unvested).To(Equal(totalVestingCoins))\n+\t\t\t\tExpect(vested.IsZero()).To(BeTrue())\n+\n+\t\t\t\t// create approval to allow spending all vesting coins\n+\t\t\t\tcArgs := defaultApproveArgs.WithArgs(\n+\t\t\t\t\tcontractAddr, []string{staking.DelegateMsg}, totalVestingCoins.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t).WithPrivKey(vestAccPriv)\n+\t\t\t\ts.SetupApprovalWithContractCalls(cArgs)\n+\n+\t\t\t\t// add the vesting account priv key to the delegate args\n+\t\t\t\tdefaultArgs = defaultDelegateArgs.WithPrivKey(vestAccPriv)\n+\t\t\t})\n+\n+\t\t\tContext(\"before first vesting period - all tokens locked and unvested\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\ts.NextBlock()\n+\n+\t\t\t\t\t// Ensure no tokens are vested\n+\t\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.ZeroInt()))\n+\t\t\t\t\tExpect(vested).To(Equal(zeroCoins))\n+\t\t\t\t\tExpect(unvested).To(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins))\n+\t\t\t\t\tExpect(unlocked).To(Equal(zeroCoins))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should not be able to delegate unvested tokens\", func() {\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), unvested.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, execRevertedCheck)\n+\t\t\t\t\tExpect(err).To(HaveOccurred(), \"error while calling the smart contract: %v\", err)\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should be able to delegate tokens not involved in vesting schedule\", func() {\n+\t\t\t\t\t// send some coins to the vesting account\n+\t\t\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), coinsToDelegate)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate.AmountOf(s.bondDenom).BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tContext(\"after first vesting period and before lockup - some vested tokens, but still all locked\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\t// Surpass cliff but none of lockup duration\n+\t\t\t\t\tcliffDuration := time.Duration(evmosutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\t\ts.NextBlockAfter(cliffDuration * time.Second)\n+\n+\t\t\t\t\t// Check if some, but not all tokens are vested\n+\t\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.CliffMonths))))\n+\t\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins))\n+\t\t\t\t\tExpect(vested).To(Equal(expVested))\n+\n+\t\t\t\t\t// check the vested tokens are still locked\n+\t\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tExpect(unlockedVested).To(Equal(sdk.Coins{}))\n+\n+\t\t\t\t\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\t\t\t\t\tres, err := s.app.VestingKeeper.Balances(s.ctx, &vestingtypes.QueryBalancesRequest{Address: clawbackAccount.Address})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.Vested).To(Equal(expVested))\n+\t\t\t\t\tExpect(res.Unvested).To(Equal(vestingAmtTotal.Sub(expVested...)))\n+\t\t\t\t\t// All coins from vesting schedule should be locked\n+\t\t\t\t\tExpect(res.Locked).To(Equal(vestingAmtTotal))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should be able to delegate locked vested tokens\", func() {\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), vested[0].Amount.BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(vested[0].Amount.BigInt()))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"Should be able to delegate locked vested tokens + free tokens (not in vesting schedule)\", func() {\n+\t\t\t\t\t// send some coins to the vesting account\n+\t\t\t\t\tamt := sdk.NewCoins(sdk.NewCoin(s.bondDenom, math.NewInt(1e18)))\n+\t\t\t\t\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), amt)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t\t\tcoinsToDelegate := amt.Add(vested...)\n+\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), coinsToDelegate[0].Amount.BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err = contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(coinsToDelegate[0].Amount.BigInt()))\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tContext(\"Between first and second lockup periods - vested coins are unlocked\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\t// Surpass first lockup\n+\t\t\t\t\tvestDuration := time.Duration(evmosutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\t\ts.NextBlockAfter(vestDuration * time.Second)\n+\n+\t\t\t\t\t// Check if some, but not all tokens are vested and unlocked\n+\t\t\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\t\tunlockedVested = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(s.bondDenom, evmosutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount.Mul(math.NewInt(evmosutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\t\texpUnlockedVested := expVested\n+\n+\t\t\t\t\tExpect(vested).NotTo(Equal(evmosutil.TestVestingSchedule.TotalVestingCoins))\n+\t\t\t\t\tExpect(vested).To(Equal(expVested))\n+\t\t\t\t\t// all vested coins are unlocked\n+\t\t\t\t\tExpect(unlockedVested).To(Equal(vested))\n+\t\t\t\t\tExpect(unlocked).To(Equal(evmosutil.TestVestingSchedule.UnlockedCoinsPerLockup))\n+\t\t\t\t\tExpect(unlockedVested).To(Equal(expUnlockedVested))\n+\t\t\t\t})\n+\t\t\t\tIt(\"Should be able to delegate unlocked vested tokens\", func() {\n+\t\t\t\t\tdelegateArgs := defaultArgs.WithArgs(\n+\t\t\t\t\t\tvestAcc, valAddr.String(), unlockedVested[0].Amount.BigInt(),\n+\t\t\t\t\t)\n+\n+\t\t\t\t\tlogCheckArgs := passCheck.WithExpEvents(staking.EventTypeDelegate)\n+\n+\t\t\t\t\t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, delegateArgs, logCheckArgs)\n+\t\t\t\t\tExpect(err).To(BeNil(), \"error while calling the smart contract: %v\", err)\n+\n+\t\t\t\t\tdelegation, found := s.app.StakingKeeper.GetDelegation(s.ctx, vestAcc.Bytes(), valAddr)\n+\t\t\t\t\tExpect(found).To(BeTrue(), \"expected delegation to be found\")\n+\t\t\t\t\tExpect(delegation.Shares.BigInt()).To(Equal(unlockedVested[0].Amount.BigInt()))\n+\t\t\t\t})\n+\t\t\t})\n+\t\t})\n \t})\n \n \tContext(\"unbonding\", func() {"
        },
        {
          "filename": "precompiles/staking/query.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -50,7 +50,7 @@ func (p Precompile) Delegation(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Delegation(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n@@ -80,7 +80,7 @@ func (p Precompile) UnbondingDelegation(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.UnbondingDelegation(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n@@ -109,7 +109,7 @@ func (p Precompile) Validator(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Validator(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n@@ -138,7 +138,7 @@ func (p Precompile) Validators(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Validators(sdk.WrapSDKContext(ctx), req)\n \tif err != nil {\n@@ -184,7 +184,7 @@ func (p Precompile) Redelegations(\n \t\treturn nil, err\n \t}\n \n-\tqueryServer := stakingkeeper.Querier{Keeper: &p.stakingKeeper}\n+\tqueryServer := stakingkeeper.Querier{Keeper: p.stakingKeeper.Keeper}\n \n \tres, err := queryServer.Redelegations(ctx, req)\n \tif err != nil {"
        },
        {
          "filename": "precompiles/staking/staking.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -11,12 +11,12 @@ import (\n \t\"github.com/cometbft/cometbft/libs/log\"\n \tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n var _ vm.PrecompiledContract = &Precompile{}"
        },
        {
          "filename": "precompiles/staking/tx.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -8,13 +8,13 @@ import (\n \t\"time\"\n \n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/ethereum/go-ethereum/core/vm\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \t\"github.com/evmos/evmos/v18/x/evm/statedb\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n )\n \n const ("
        },
        {
          "filename": "precompiles/staking/utils_test.go",
          "status": "modified",
          "additions": 57,
          "deletions": 4,
          "patch": "@@ -2,6 +2,7 @@ package staking_test\n \n import (\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"math/big\"\n \t\"time\"\n \n@@ -20,12 +21,13 @@ import (\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/accounts/abi\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n+\t\"github.com/ethereum/go-ethereum/crypto\"\n \tevmosapp \"github.com/evmos/evmos/v18/app\"\n+\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n \t\"github.com/evmos/evmos/v18/precompiles/authorization\"\n \tcmn \"github.com/evmos/evmos/v18/precompiles/common\"\n \t\"github.com/evmos/evmos/v18/precompiles/staking\"\n@@ -38,9 +40,14 @@ import (\n \t\"github.com/evmos/evmos/v18/x/evm/statedb\"\n \tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n \tinflationtypes \"github.com/evmos/evmos/v18/x/inflation/v1/types\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n \t\"golang.org/x/exp/slices\"\n )\n \n+// stipend to pay EVM tx fees\n+var accountGasCoverage = sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, math.NewInt(1e16)))\n+\n // SetupWithGenesisValSet initializes a new EvmosApp with a validator set and genesis accounts\n // that also act as delegators. For simplicity, each validator is bonded with a delegation\n // of one consensus engine unit (10^6) in the default token of the simapp from first genesis\n@@ -328,6 +335,13 @@ func (s *PrecompileTestSuite) SetupApprovalWithContractCalls(approvalArgs contra\n \t_, _, err := contracts.CallContractAndCheckLogs(s.ctx, s.app, approvalArgs, logCheckArgs)\n \tExpect(err).To(BeNil(), \"error while approving: %v\", err)\n \n+\t// get granter address from private key provided\n+\tpk, ok := approvalArgs.PrivKey.(*ethsecp256k1.PrivKey)\n+\tExpect(ok).To(BeTrue(), fmt.Sprintf(\"expected a ethsecp256k1.PrivKey, but got %T\", approvalArgs.PrivKey))\n+\tkey, err := pk.ToECDSA()\n+\tExpect(err).To(BeNil())\n+\tgranter := crypto.PubkeyToAddress(key.PublicKey)\n+\n \t// iterate over args\n \tvar expectedAuthz stakingtypes.AuthorizationType\n \tfor _, msgType := range msgTypes {\n@@ -341,7 +355,7 @@ func (s *PrecompileTestSuite) SetupApprovalWithContractCalls(approvalArgs contra\n \t\tcase staking.CancelUnbondingDelegationMsg:\n \t\t\texpectedAuthz = staking.CancelUnbondingDelegationAuthz\n \t\t}\n-\t\tauthz, expirationTime := s.CheckAuthorization(expectedAuthz, approvalArgs.ContractAddr, s.address)\n+\t\tauthz, expirationTime := s.CheckAuthorization(expectedAuthz, approvalArgs.ContractAddr, granter)\n \t\tExpect(authz).ToNot(BeNil(), \"expected authorization to be set\")\n \t\tExpect(authz.MaxTokens.Amount).To(Equal(math.NewInt(expAmount.Int64())), \"expected different allowance\")\n \t\tExpect(authz.MsgTypeURL()).To(Equal(msgType), \"expected different message type\")\n@@ -363,8 +377,13 @@ func (s *PrecompileTestSuite) DeployContract(contract evmtypes.CompiledContract)\n \n // NextBlock commits the current block and sets up the next block.\n func (s *PrecompileTestSuite) NextBlock() {\n+\ts.NextBlockAfter(time.Second)\n+}\n+\n+// NextBlock commits the current block and sets up the next block.\n+func (s *PrecompileTestSuite) NextBlockAfter(t time.Duration) {\n \tvar err error\n-\ts.ctx, err = evmosutil.CommitAndCreateNewCtx(s.ctx, s.app, time.Second, nil)\n+\ts.ctx, err = evmosutil.CommitAndCreateNewCtx(s.ctx, s.app, t, nil)\n \tExpect(err).To(BeNil(), \"failed to commit block\")\n }\n \n@@ -499,7 +518,7 @@ func (s *PrecompileTestSuite) setupRedelegations(redelAmt *big.Int) error {\n \n \t// create a validator with s.address and s.privKey\n \t// then create a redelegation from validator[0] to this new validator\n-\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), s.app.StakingKeeper, math.NewInt(100))\n+\ttestutil.CreateValidator(s.ctx, s.T(), s.privKey.PubKey(), *s.app.StakingKeeper.Keeper, math.NewInt(100))\n \tmsg.ValidatorDstAddress = sdk.ValAddress(s.address.Bytes()).String()\n \t_, err := msgSrv.BeginRedelegate(s.ctx, &msg)\n \treturn err\n@@ -514,3 +533,37 @@ func (s *PrecompileTestSuite) CheckValidatorOutput(valOut staking.ValidatorInfo)\n \tExpect(slices.Contains(validatorAddrs, valOut.OperatorAddress)).To(BeTrue(), \"operator address not found in test suite validators\")\n \tExpect(valOut.DelegatorShares).To(Equal(big.NewInt(1e18)), \"expected different delegator shares\")\n }\n+\n+// setupVestingAccount is a helper function used in integraiton tests to setup a vesting account\n+// using the TestVestingSchedule. Also, funds the account with extra funds to pay for transaction fees\n+func (s *PrecompileTestSuite) setupVestingAccount(funder, vestAcc sdk.AccAddress) *vestingtypes.ClawbackVestingAccount {\n+\tvestingAmtTotal := evmosutil.TestVestingSchedule.TotalVestingCoins\n+\n+\tvestingStart := s.ctx.BlockTime()\n+\tbaseAccount := authtypes.NewBaseAccountWithAddress(vestAcc.Bytes())\n+\tclawbackAccount := vestingtypes.NewClawbackVestingAccount(\n+\t\tbaseAccount,\n+\t\tfunder,\n+\t\tvestingAmtTotal,\n+\t\tvestingStart,\n+\t\tevmosutil.TestVestingSchedule.LockupPeriods,\n+\t\tevmosutil.TestVestingSchedule.VestingPeriods,\n+\t)\n+\n+\terr := evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), vestingAmtTotal)\n+\tExpect(err).To(BeNil())\n+\tacc := s.app.AccountKeeper.NewAccount(s.ctx, clawbackAccount)\n+\ts.app.AccountKeeper.SetAccount(s.ctx, acc)\n+\n+\t// Check all coins are locked up\n+\tlockedUp := clawbackAccount.GetLockedUpCoins(s.ctx.BlockTime())\n+\tExpect(vestingAmtTotal).To(Equal(lockedUp))\n+\n+\t// Grant gas stipend to cover EVM fees\n+\terr = evmosutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), accountGasCoverage)\n+\tExpect(err).To(BeNil())\n+\tgranteeBalance := s.app.BankKeeper.GetBalance(s.ctx, clawbackAccount.GetAddress(), s.bondDenom)\n+\tExpect(granteeBalance).To(Equal(accountGasCoverage[0].Add(vestingAmtTotal[0])))\n+\n+\treturn clawbackAccount\n+}"
        },
        {
          "filename": "tests/nix_tests/test_patches.py",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -12,6 +12,7 @@\n     deploy_contract,\n     eth_to_bech32,\n     get_fees_from_tx_result,\n+    wait_for_cosmos_tx_receipt,\n     wait_for_new_blocks,\n )\n \n@@ -371,7 +372,8 @@ def test_unvested_token_delegation(evmos_cluster):\n     )\n     tx = cli.sign_tx_json(tx, address, max_priority_price=0)\n     rsp = cli.broadcast_tx_json(tx, broadcast_mode=\"sync\")\n-\n+    # get tx receipt to check if tx failed as expected \n+    receipt = wait_for_cosmos_tx_receipt(cli, rsp[\"txhash\"])\n     # assert tx fails with corresponding error message\n-    assert rsp[\"code\"] == 2\n-    assert \"insufficient vested coins\" in rsp[\"raw_log\"]\n+    assert receipt[\"tx_result\"][\"code\"] == 2\n+    assert \"insufficient vested coins\" in receipt[\"tx_result\"][\"log\"]"
        },
        {
          "filename": "testutil/integration/evmos/network/clients.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -85,6 +85,6 @@ func (n *IntegrationNetwork) GetAuthzClient() authz.QueryClient {\n \n func (n *IntegrationNetwork) GetStakingClient() stakingtypes.QueryClient {\n \tqueryHelper := getQueryHelper(n.GetContext())\n-\tstakingtypes.RegisterQueryServer(queryHelper, stakingkeeper.Querier{Keeper: &n.app.StakingKeeper})\n+\tstakingtypes.RegisterQueryServer(queryHelper, stakingkeeper.Querier{Keeper: n.app.StakingKeeper.Keeper})\n \treturn stakingtypes.NewQueryClient(queryHelper)\n }"
        },
        {
          "filename": "testutil/integration/evmos/network/config.go",
          "status": "modified",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -9,6 +9,8 @@ import (\n \t\"github.com/evmos/evmos/v18/utils\"\n \n \tsdktypes \"github.com/cosmos/cosmos-sdk/types\"\n+\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n+\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \tevmostypes \"github.com/evmos/evmos/v18/types\"\n )\n \n@@ -20,6 +22,7 @@ type Config struct {\n \teip155ChainID      *big.Int\n \tamountOfValidators int\n \tpreFundedAccounts  []sdktypes.AccAddress\n+\tbalances           []banktypes.Balance\n \tdenom              string\n }\n \n@@ -36,6 +39,24 @@ func DefaultConfig() Config {\n \t}\n }\n \n+// getGenAccountsAndBalances takes the network configuration and returns the used\n+// genesis accounts and balances.\n+//\n+// NOTE: If the balances are set, the pre-funded accounts are ignored.\n+func getGenAccountsAndBalances(cfg Config) (genAccounts []authtypes.GenesisAccount, balances []banktypes.Balance) {\n+\tif len(cfg.balances) > 0 {\n+\t\tbalances = cfg.balances\n+\t\taccounts := getAccAddrsFromBalances(balances)\n+\t\tgenAccounts = createGenesisAccounts(accounts)\n+\t} else {\n+\t\tcoin := sdktypes.NewCoin(cfg.denom, PrefundedAccountInitialBalance)\n+\t\tgenAccounts = createGenesisAccounts(cfg.preFundedAccounts)\n+\t\tbalances = createBalances(cfg.preFundedAccounts, coin)\n+\t}\n+\n+\treturn\n+}\n+\n // ConfigOption defines a function that can modify the NetworkConfig.\n // The purpose of this is to force to be declarative when the default configuration\n // requires to be changed.\n@@ -67,6 +88,14 @@ func WithPreFundedAccounts(accounts ...sdktypes.AccAddress) ConfigOption {\n \t}\n }\n \n+// WithBalances sets the specific balances for the pre-funded accounts, that\n+// are being set up for the network.\n+func WithBalances(balances ...banktypes.Balance) ConfigOption {\n+\treturn func(cfg *Config) {\n+\t\tcfg.balances = append(cfg.balances, balances...)\n+\t}\n+}\n+\n // WithDenom sets the denom for the network.\n func WithDenom(denom string) ConfigOption {\n \treturn func(cfg *Config) {"
        },
        {
          "filename": "testutil/integration/evmos/network/network.go",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -7,6 +7,7 @@ import (\n \t\"encoding/json\"\n \t\"math\"\n \t\"math/big\"\n+\t\"time\"\n \n \tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \n@@ -105,9 +106,7 @@ var (\n func (n *IntegrationNetwork) configureAndInitChain() error {\n \t// Create funded accounts based on the config and\n \t// create genesis accounts\n-\tcoin := sdktypes.NewCoin(n.cfg.denom, PrefundedAccountInitialBalance)\n-\tgenAccounts := createGenesisAccounts(n.cfg.preFundedAccounts)\n-\tfundedAccountBalances := createBalances(n.cfg.preFundedAccounts, coin)\n+\tgenAccounts, fundedAccountBalances := getGenAccountsAndBalances(n.cfg)\n \n \t// Create validator set with the amount of validators specified in the config\n \t// with the default power of 1.\n@@ -154,8 +153,10 @@ func (n *IntegrationNetwork) configureAndInitChain() error {\n \t\treturn err\n \t}\n \n+\tnow := time.Now()\n \tevmosApp.InitChain(\n \t\tabcitypes.RequestInitChain{\n+\t\t\tTime:            now,\n \t\t\tChainId:         n.cfg.chainID,\n \t\t\tValidators:      []abcitypes.ValidatorUpdate{},\n \t\t\tConsensusParams: app.DefaultConsensusParams,\n@@ -168,6 +169,7 @@ func (n *IntegrationNetwork) configureAndInitChain() error {\n \theader := tmproto.Header{\n \t\tChainID:            n.cfg.chainID,\n \t\tHeight:             evmosApp.LastBlockHeight() + 1,\n+\t\tTime:               now,\n \t\tAppHash:            evmosApp.LastCommitID().Hash,\n \t\tValidatorsHash:     valSet.Hash(),\n \t\tNextValidatorsHash: valSet.Hash(),"
        },
        {
          "filename": "testutil/integration/evmos/network/setup.go",
          "status": "modified",
          "additions": 19,
          "deletions": 1,
          "patch": "@@ -23,6 +23,8 @@ import (\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\t\"github.com/ethereum/go-ethereum/crypto\"\n+\tevmostypes \"github.com/evmos/evmos/v18/types\"\n \tepochstypes \"github.com/evmos/evmos/v18/x/epochs/types\"\n \tinfltypes \"github.com/evmos/evmos/v18/x/inflation/v1/types\"\n )\n@@ -50,9 +52,25 @@ func createValidatorSetAndSigners(numberOfValidators int) (*tmtypes.ValidatorSet\n func createGenesisAccounts(accounts []sdktypes.AccAddress) []authtypes.GenesisAccount {\n \tnumberOfAccounts := len(accounts)\n \tgenAccounts := make([]authtypes.GenesisAccount, 0, numberOfAccounts)\n+\temptyCodeHash := crypto.Keccak256Hash(nil).String()\n \tfor _, acc := range accounts {\n \t\tbaseAcc := authtypes.NewBaseAccount(acc, nil, 0, 0)\n-\t\tgenAccounts = append(genAccounts, baseAcc)\n+\t\tethAcc := &evmostypes.EthAccount{\n+\t\t\tBaseAccount: baseAcc,\n+\t\t\tCodeHash:    emptyCodeHash,\n+\t\t}\n+\t\tgenAccounts = append(genAccounts, ethAcc)\n+\t}\n+\treturn genAccounts\n+}\n+\n+// getAccAddrsFromBalances returns a slice of genesis accounts from the\n+// given balances.\n+func getAccAddrsFromBalances(balances []banktypes.Balance) []sdktypes.AccAddress {\n+\tnumberOfBalances := len(balances)\n+\tgenAccounts := make([]sdktypes.AccAddress, 0, numberOfBalances)\n+\tfor _, balance := range balances {\n+\t\tgenAccounts = append(genAccounts, balance.GetAddress())\n \t}\n \treturn genAccounts\n }"
        },
        {
          "filename": "testutil/integration/ibc/coordinator/coordinator.go",
          "status": "modified",
          "additions": 2,
          "deletions": 5,
          "patch": "@@ -41,10 +41,7 @@ type Coordinator interface {\n }\n \n // TODO: Replace for a config\n-var (\n-\tAmountOfDummyChains = 2\n-\tGlobalTime          = time.Date(time.Now().Year()+1, 1, 2, 0, 0, 0, 0, time.UTC)\n-)\n+var AmountOfDummyChains = 2\n \n var _ Coordinator = (*IntegrationCoordinator)(nil)\n \n@@ -62,7 +59,7 @@ type IntegrationCoordinator struct {\n func NewIntegrationCoordinator(t *testing.T, preConfiguredChains []network.Network) *IntegrationCoordinator {\n \tcoord := &ibctesting.Coordinator{\n \t\tT:           t,\n-\t\tCurrentTime: GlobalTime,\n+\t\tCurrentTime: time.Now(),\n \t}\n \tibcChains := getIBCChains(t, coord, preConfiguredChains)\n \tdummyChains, dummyChainsIds := generateDummyChains(t, coord, AmountOfDummyChains)"
        },
        {
          "filename": "testutil/staking-rewards.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -110,7 +110,7 @@ func PrepareAccountsForDelegationRewards(t *testing.T, ctx sdk.Context, app *app\n \t\terr = app.StakingKeeper.SetParams(ctx, stakingParams)\n \t\trequire.NoError(t, err)\n \n-\t\tstakingHelper := teststaking.NewHelper(t, ctx, &app.StakingKeeper)\n+\t\tstakingHelper := teststaking.NewHelper(t, ctx, app.StakingKeeper.Keeper)\n \t\tstakingHelper.Commission = stakingtypes.NewCommissionRates(zeroDec, zeroDec, zeroDec)\n \t\tstakingHelper.Denom = utils.BaseDenom\n \n@@ -122,7 +122,7 @@ func PrepareAccountsForDelegationRewards(t *testing.T, ctx sdk.Context, app *app\n \n \t\t// end block to bond validator and increase block height\n \t\t// Not using Commit() here because code panics due to invalid block height\n-\t\tstaking.EndBlocker(ctx, &app.StakingKeeper)\n+\t\tstaking.EndBlocker(ctx, app.StakingKeeper.Keeper)\n \n \t\t// allocate rewards to validator (of these 50% will be paid out to the delegator)\n \t\tvalidator := app.StakingKeeper.Validator(ctx, valAddr)"
        },
        {
          "filename": "testutil/vesting.go",
          "status": "added",
          "additions": 88,
          "deletions": 0,
          "patch": "@@ -0,0 +1,88 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+package testutil\n+\n+import (\n+\t\"cosmossdk.io/math\"\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+)\n+\n+type vestingSchedule struct {\n+\tCliffMonths int64\n+\t// CliffPeriodLength in seconds\n+\tCliffPeriodLength int64\n+\tNumLockupPeriods  int64\n+\tLockupMonths      int64\n+\t// LockupPeriodLength in seconds\n+\tLockupPeriodLength int64\n+\tNumVestingPeriods  int64\n+\t// VestingPeriodLength in seconds\n+\tVestingPeriodLength    int64\n+\tTotalVestingCoins      sdk.Coins\n+\tVestedCoinsPerPeriod   sdk.Coins\n+\tUnlockedCoinsPerLockup sdk.Coins\n+\tVestingPeriods         []sdkvesting.Period\n+\tLockupPeriods          []sdkvesting.Period\n+}\n+\n+// Vesting schedule for tests that use vesting account\n+var (\n+\tTestVestingSchedule vestingSchedule\n+\t// Monthly vesting period\n+\tstakeDenom    = utils.BaseDenom\n+\tamt           = math.NewInt(1e17)\n+\tvestingLength = int64(60 * 60 * 24 * 30) // in seconds\n+\tvestingAmt    = sdk.NewCoins(sdk.NewCoin(stakeDenom, amt))\n+\tvestingPeriod = sdkvesting.Period{Length: vestingLength, Amount: vestingAmt}\n+\n+\t// 4 years vesting total\n+\tperiodsTotal    = int64(48)\n+\tvestingAmtTotal = sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n+\n+\t// 6 month cliff\n+\tcliff       = int64(6)\n+\tcliffLength = vestingLength * cliff\n+\tcliffAmt    = sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n+\tcliffPeriod = sdkvesting.Period{Length: cliffLength, Amount: cliffAmt}\n+\n+\t// 12 month lockup\n+\tlockup       = int64(12) // 12 months\n+\tlockupLength = vestingLength * lockup\n+\t// Unlock at 12 and 24 months\n+\tnumLockupPeriods = int64(2)\n+\t// Unlock half of the total vest in each unlock event. By default, all tokens are\n+\t// unlocked after surpassing the final period.\n+\tunlockedPerLockup = vestingAmtTotal.QuoInt(math.NewInt(numLockupPeriods))\n+\tlockupPeriod      = sdkvesting.Period{Length: lockupLength, Amount: unlockedPerLockup}\n+\tlockupPeriods     = make(sdkvesting.Periods, numLockupPeriods)\n+\t// add initial cliff to vesting periods\n+\tvestingPeriods = sdkvesting.Periods{cliffPeriod}\n+)\n+\n+func init() {\n+\tfor i := range lockupPeriods {\n+\t\tlockupPeriods[i] = lockupPeriod\n+\t}\n+\n+\t// Create vesting periods with initial cliff\n+\tfor p := int64(1); p <= periodsTotal-cliff; p++ {\n+\t\tvestingPeriods = append(vestingPeriods, vestingPeriod)\n+\t}\n+\n+\tTestVestingSchedule = vestingSchedule{\n+\t\tCliffMonths:            cliff,\n+\t\tCliffPeriodLength:      cliffLength,\n+\t\tNumLockupPeriods:       numLockupPeriods,\n+\t\tNumVestingPeriods:      periodsTotal,\n+\t\tLockupMonths:           lockup,\n+\t\tLockupPeriodLength:     lockupLength,\n+\t\tVestingPeriodLength:    vestingLength,\n+\t\tTotalVestingCoins:      vestingAmtTotal,\n+\t\tVestedCoinsPerPeriod:   vestingAmt,\n+\t\tUnlockedCoinsPerLockup: unlockedPerLockup,\n+\t\tVestingPeriods:         vestingPeriods,\n+\t\tLockupPeriods:          lockupPeriods,\n+\t}\n+}"
        },
        {
          "filename": "x/erc20/keeper/utils_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -103,7 +103,7 @@ func (suite *KeeperTestSuite) DoSetupTest(t require.TestingT) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, privCons.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n \terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)"
        },
        {
          "filename": "x/evm/keeper/precompiles.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -20,7 +20,6 @@ import (\n \tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n \tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n \tdistributionkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tchannelkeeper \"github.com/cosmos/ibc-go/v7/modules/core/04-channel/keeper\"\n \tbankprecompile \"github.com/evmos/evmos/v18/precompiles/bank\"\n \tdistprecompile \"github.com/evmos/evmos/v18/precompiles/distribution\"\n@@ -33,6 +32,7 @@ import (\n \tvestingprecompile \"github.com/evmos/evmos/v18/precompiles/vesting\"\n \terc20Keeper \"github.com/evmos/evmos/v18/x/erc20/keeper\"\n \ttransferkeeper \"github.com/evmos/evmos/v18/x/ibc/transfer/keeper\"\n+\tstakingkeeper \"github.com/evmos/evmos/v18/x/staking/keeper\"\n \tvestingkeeper \"github.com/evmos/evmos/v18/x/vesting/keeper\"\n )\n "
        },
        {
          "filename": "x/feemarket/keeper/utils_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -70,7 +70,7 @@ func (suite *KeeperTestSuite) SetupApp(checkTx bool, chainID string) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, priv.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n "
        },
        {
          "filename": "x/ibc/transfer/keeper/keeper_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -122,7 +122,7 @@ func (suite *KeeperTestSuite) DoSetupTest(t require.TestingT) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, privCons.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n \terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)"
        },
        {
          "filename": "x/revenue/v1/keeper/utils_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -74,7 +74,7 @@ func (suite *KeeperTestSuite) SetupApp(chainID string) {\n \tvalAddr := sdk.ValAddress(suite.address.Bytes())\n \tvalidator, err := stakingtypes.NewValidator(valAddr, privCons.PubKey(), stakingtypes.Description{})\n \trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n \terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n \trequire.NoError(t, err)\n \terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)"
        },
        {
          "filename": "x/staking/keeper/integration_test.go",
          "status": "added",
          "additions": 395,
          "deletions": 0,
          "patch": "@@ -0,0 +1,395 @@\n+package keeper_test\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519\"\n+\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\t\"github.com/cosmos/cosmos-sdk/x/authz\"\n+\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/common/factory\"\n+\tevmosfactory \"github.com/evmos/evmos/v18/testutil/integration/evmos/factory\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/grpc\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/keyring\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/network\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+\n+\t//nolint:revive // dot imports are fine for Ginkgo\n+\t. \"github.com/onsi/ginkgo/v2\"\n+\t//nolint:revive // dot imports are fine for Ginkgo\n+\t. \"github.com/onsi/gomega\"\n+)\n+\n+func TestKeeperIntegrationTestSuite(t *testing.T) {\n+\t// Run Ginkgo integration tests\n+\tRegisterFailHandler(Fail)\n+\tRunSpecs(t, \"Keeper Suite\")\n+}\n+\n+var _ = Describe(\"Staking module tests\", func() {\n+\tvar (\n+\t\tnw   *network.UnitTestNetwork\n+\t\tgh   grpc.Handler\n+\t\tkeys keyring.Keyring\n+\t\ttf   evmosfactory.TxFactory\n+\t)\n+\n+\tContext(\"using a vesting account\", func() {\n+\t\tvar (\n+\t\t\tclawbackAccount       *vestingtypes.ClawbackVestingAccount\n+\t\t\tfunder                keyring.Key\n+\t\t\tvestingAccount        keyring.Key\n+\t\t\totherAccount          keyring.Key\n+\t\t\tvestAccInitialBalance *sdk.Coin\n+\t\t\t// initialized vars\n+\t\t\tgasPrice = math.NewInt(700_000_000)\n+\t\t\tgas      = uint64(500_000)\n+\t\t)\n+\n+\t\tBeforeEach(func() {\n+\t\t\t// setup network\n+\t\t\t// create 3 prefunded accounts:\n+\t\t\tkeys = keyring.New(3)\n+\t\t\tfunder = keys.GetKey(0)\n+\t\t\tvestingAccount = keys.GetKey(1)\n+\t\t\totherAccount = keys.GetKey(2)\n+\n+\t\t\t// set a higher initial balance for the funder to have\n+\t\t\t// enough for the vesting schedule\n+\t\t\tfunderInitialBalance, ok := math.NewIntFromString(\"100_000_000_000_000_000_000\")\n+\t\t\tExpect(ok).To(BeTrue())\n+\t\t\tbalances := []banktypes.Balance{\n+\t\t\t\t{\n+\t\t\t\t\tAddress: funder.AccAddr.String(),\n+\t\t\t\t\tCoins:   sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, funderInitialBalance)),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAddress: vestingAccount.AccAddr.String(),\n+\t\t\t\t\tCoins:   sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, network.PrefundedAccountInitialBalance)),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAddress: otherAccount.AccAddr.String(),\n+\t\t\t\t\tCoins:   sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, network.PrefundedAccountInitialBalance)),\n+\t\t\t\t},\n+\t\t\t}\n+\n+\t\t\tnw = network.NewUnitTestNetwork(\n+\t\t\t\tnetwork.WithBalances(balances...),\n+\t\t\t)\n+\t\t\tgh = grpc.NewIntegrationHandler(nw)\n+\t\t\ttf = evmosfactory.New(nw, gh)\n+\n+\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t// setup vesting account\n+\t\t\tcreateAccMsg := vestingtypes.NewMsgCreateClawbackVestingAccount(funder.AccAddr, vestingAccount.AccAddr, false)\n+\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createAccMsg}})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t// get vesting account initial balance (free tokens)\n+\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tvestAccInitialBalance = balRes.Balance\n+\n+\t\t\t// Fund the clawback vesting accounts\n+\t\t\tvestingStart := nw.GetContext().BlockTime()\n+\t\t\tfundMsg := vestingtypes.NewMsgFundVestingAccount(funder.AccAddr, vestingAccount.AccAddr, vestingStart, testutil.TestVestingSchedule.LockupPeriods, testutil.TestVestingSchedule.VestingPeriods)\n+\t\t\tres, err = tf.ExecuteCosmosTx(funder.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{fundMsg}})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t// check vesting account was created successfully\n+\t\t\tacc, err := gh.GetAccount(vestingAccount.AccAddr.String())\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tclawbackAccount, ok = acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\tExpect(ok).To(BeTrue())\n+\t\t})\n+\n+\t\tContext(\"delegate\", func() {\n+\t\t\tvar delMsg *types.MsgDelegate\n+\n+\t\t\tContext(\"using MsgDelegate\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\t// create a MsgDelegate to delegate the free tokens (balance previous to be converted to clawback account) + vested coins per period\n+\t\t\t\t\tdelMsg = types.NewMsgDelegate(vestingAccount.AccAddr, nw.GetValidators()[0].GetOperator(), testutil.TestVestingSchedule.VestedCoinsPerPeriod.Add(*vestAccInitialBalance)[0])\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should not allow to delegate unvested tokens\", func() {\n+\t\t\t\t\t// all coins in vesting schedule should be unvested\n+\t\t\t\t\tunvestedCoins := clawbackAccount.GetVestingCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(unvestedCoins).To(Equal(testutil.TestVestingSchedule.TotalVestingCoins))\n+\n+\t\t\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tdelegatableBalance := balRes.Balance.Sub(unvestedCoins[0])\n+\t\t\t\t\tExpect(delegatableBalance.Amount.LT(delMsg.Amount.Amount)).To(BeTrue())\n+\n+\t\t\t\t\t_, err = tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}})\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins\"))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate free tokens when all tokens in vesting schedule are unvested\", func() {\n+\t\t\t\t\t// calculate fees to deduct from free balance\n+\t\t\t\t\t// to get the proper delegation amount\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Sub(fees)\n+\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate locked vested tokens\", func() {\n+\t\t\t\t\t// cliff period passes - some tokens vested, but still all locked\n+\t\t\t\t\tvestingPeriod := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(vestingPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpCoins := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).MulRaw(testutil.TestVestingSchedule.CliffMonths)))\n+\t\t\t\t\tlockedVestedCoins := clawbackAccount.GetLockedUpVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(lockedVestedCoins).To(Equal(expCoins))\n+\n+\t\t\t\t\t// deduct fees from delegation amount to pay the tx\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Add(lockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate unlocked vested tokens\", func() {\n+\t\t\t\t\t// first lockup period passes\n+\t\t\t\t\tlockupPeriod := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(lockupPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).Mul(math.NewInt(testutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\t\tvestedCoins := clawbackAccount.GetVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(vestedCoins).To(Equal(expVested))\n+\n+\t\t\t\t\t// all vested coins should be unlocked\n+\t\t\t\t\tunlockedVestedCoins := clawbackAccount.GetUnlockedVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(unlockedVestedCoins).To(Equal(vestedCoins))\n+\n+\t\t\t\t\t// delegation amount is all free coins + unlocked vested - fee to pay tx\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Add(unlockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{delMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\t\t\t})\n+\n+\t\t\tContext(\"MsgDelegate nested in MsgExec\", func() {\n+\t\t\t\tBeforeEach(func() {\n+\t\t\t\t\texpiration := time.Now().Add(time.Hour * 24 * 365 * 2) // 2years\n+\t\t\t\t\t// create a grant for other account\n+\t\t\t\t\t// to send a MsgDelegate\n+\t\t\t\t\tgrantMsg, err := authz.NewMsgGrant(vestingAccount.AccAddr, otherAccount.AccAddr, authz.NewGenericAuthorization(\"/cosmos.staking.v1beta1.MsgDelegate\"), &expiration)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{grantMsg}})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// create a MsgDelegate to delegate vested coins per period\n+\t\t\t\t\tdelMsg = types.NewMsgDelegate(vestingAccount.AccAddr, nw.GetValidators()[0].GetOperator(), testutil.TestVestingSchedule.VestedCoinsPerPeriod.Add(*vestAccInitialBalance)[0])\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should not allow to delegate unvested tokens\", func() {\n+\t\t\t\t\t// all coins in vesting schedule should be unvested\n+\t\t\t\t\tunvestedCoins := clawbackAccount.GetVestingCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(unvestedCoins).To(Equal(testutil.TestVestingSchedule.TotalVestingCoins))\n+\n+\t\t\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tdelegatableBalance := balRes.Balance.Sub(unvestedCoins[0])\n+\t\t\t\t\tExpect(delegatableBalance.Amount.LT(delMsg.Amount.Amount)).To(BeTrue())\n+\n+\t\t\t\t\texecMsg := authz.NewMsgExec(otherAccount.AccAddr, []sdk.Msg{delMsg})\n+\t\t\t\t\t_, err = tf.ExecuteCosmosTx(otherAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{&execMsg}})\n+\t\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins.\"))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"should allow to delegate locked vested tokens\", func() {\n+\t\t\t\t\t// cliff period passes - some tokens vested, but still all locked\n+\t\t\t\t\tvestingPeriod := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(vestingPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpCoins := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).MulRaw(testutil.TestVestingSchedule.CliffMonths)))\n+\t\t\t\t\tlockedVestedCoins := clawbackAccount.GetLockedUpVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(lockedVestedCoins).To(Equal(expCoins))\n+\n+\t\t\t\t\t// update delegation amount to be the free balance + locked vested coins - fees\n+\t\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\t\tdelMsg.Amount = vestAccInitialBalance.Add(lockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\t\texecMsg := authz.NewMsgExec(otherAccount.AccAddr, []sdk.Msg{delMsg})\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(otherAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{&execMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\n+\t\t\t\tIt(\"after first lockup period - should allow to delegate unlocked vested tokens\", func() {\n+\t\t\t\t\t// first lockup period passes\n+\t\t\t\t\tlockupPeriod := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\t\tExpect(nw.NextBlockAfter(lockupPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t\t// check there're some vested coins\n+\t\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).Mul(math.NewInt(testutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\t\tvestedCoins := clawbackAccount.GetVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\t\tExpect(vestedCoins).To(Equal(expVested))\n+\n+\t\t\t\t\texecMsg := authz.NewMsgExec(otherAccount.AccAddr, []sdk.Msg{delMsg})\n+\t\t\t\t\tres, err := tf.ExecuteCosmosTx(otherAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{&execMsg}, Gas: gas})\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t\t// check delegation was created successfully\n+\t\t\t\t\tdelRes, err := gh.GetDelegation(vestingAccount.AccAddr.String(), nw.GetValidators()[0].OperatorAddress)\n+\t\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(delMsg.Amount))\n+\t\t\t\t})\n+\t\t\t})\n+\t\t})\n+\n+\t\tContext(\"create validator with self delegation\", func() {\n+\t\t\tvar createValMsg *types.MsgCreateValidator\n+\n+\t\t\tBeforeEach(func() {\n+\t\t\t\t// create a MsgCreateValidator to create a validator.\n+\t\t\t\t// Self delegate coins in the vesting schedule\n+\t\t\t\tvar err error\n+\t\t\t\tpubKey := ed25519.GenPrivKey().PubKey()\n+\t\t\t\tcommissions := types.NewCommissionRates(\n+\t\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t\t\tsdk.NewDecWithPrec(2, 1),\n+\t\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t\t)\n+\t\t\t\tcreateValMsg, err = types.NewMsgCreateValidator(\n+\t\t\t\t\tsdk.ValAddress(vestingAccount.AccAddr),\n+\t\t\t\t\tpubKey,\n+\t\t\t\t\ttestutil.TestVestingSchedule.VestedCoinsPerPeriod.Add(*vestAccInitialBalance)[0],\n+\t\t\t\t\ttypes.NewDescription(\"T\", \"E\", \"S\", \"T\", \"Z\"),\n+\t\t\t\t\tcommissions,\n+\t\t\t\t\tsdk.OneInt(),\n+\t\t\t\t)\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t})\n+\n+\t\t\tIt(\"should not allow to create validator with unvested tokens in self delegation\", func() {\n+\t\t\t\t// all coins in vesting schedule should be unvested\n+\t\t\t\tunvestedCoins := clawbackAccount.GetVestingCoins(nw.GetContext().BlockTime())\n+\t\t\t\tExpect(unvestedCoins).To(Equal(testutil.TestVestingSchedule.TotalVestingCoins))\n+\n+\t\t\t\tbalRes, err := gh.GetBalance(vestingAccount.AccAddr, nw.GetDenom())\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tdelegatableBalance := balRes.Balance.Sub(unvestedCoins[0])\n+\t\t\t\tExpect(delegatableBalance.Amount.LT(createValMsg.Value.Amount)).To(BeTrue())\n+\n+\t\t\t\t_, err = tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createValMsg}})\n+\t\t\t\tExpect(err).To(HaveOccurred())\n+\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins.\"))\n+\t\t\t})\n+\n+\t\t\tIt(\"should allow to create validator with locked vested tokens\", func() {\n+\t\t\t\t// cliff period passes - some tokens vested, but still all locked\n+\t\t\t\tvestingPeriod := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\tExpect(nw.NextBlockAfter(vestingPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t// check there're some vested coins\n+\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\texpCoins := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).MulRaw(testutil.TestVestingSchedule.CliffMonths)))\n+\t\t\t\tlockedVestedCoins := clawbackAccount.GetLockedUpVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\tExpect(lockedVestedCoins).To(Equal(expCoins))\n+\n+\t\t\t\t// update delegation amount to be the free balance + locked vested coins - fees\n+\t\t\t\tfees := sdk.NewCoin(nw.GetDenom(), gasPrice.Mul(math.NewIntFromUint64(gas)))\n+\t\t\t\tcreateValMsg.Value = vestAccInitialBalance.Add(lockedVestedCoins[0]).Sub(fees)\n+\n+\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createValMsg}, Gas: gas, GasPrice: &gasPrice})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t// check validator was created successfully\n+\t\t\t\tqc := nw.GetStakingClient()\n+\t\t\t\tvalRes, err := qc.Validator(nw.GetContext(), &types.QueryValidatorRequest{ValidatorAddr: sdk.ValAddress(vestingAccount.AccAddr).String()})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(valRes.Validator.Status).To(Equal(types.Bonded))\n+\t\t\t})\n+\n+\t\t\tIt(\"after first lockup period - should allow to create validator with a delegation of vested tokens\", func() {\n+\t\t\t\t// first lockup period passes\n+\t\t\t\tlockupPeriod := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\tExpect(nw.NextBlockAfter(lockupPeriod * time.Second)).To(BeNil())\n+\n+\t\t\t\t// check there're some vested coins\n+\t\t\t\tdenom := nw.GetDenom()\n+\t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(denom, testutil.TestVestingSchedule.VestedCoinsPerPeriod.AmountOf(denom).Mul(math.NewInt(testutil.TestVestingSchedule.LockupMonths))))\n+\t\t\t\tvestedCoins := clawbackAccount.GetVestedCoins(nw.GetContext().BlockTime())\n+\t\t\t\tExpect(vestedCoins).To(Equal(expVested))\n+\n+\t\t\t\tres, err := tf.ExecuteCosmosTx(vestingAccount.Priv, factory.CosmosTxArgs{Msgs: []sdk.Msg{createValMsg}, Gas: 500_000})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\t\t\t\tExpect(nw.NextBlock()).To(BeNil())\n+\n+\t\t\t\t// check validator was created successfully\n+\t\t\t\tqc := nw.GetStakingClient()\n+\t\t\t\tvalRes, err := qc.Validator(nw.GetContext(), &types.QueryValidatorRequest{ValidatorAddr: sdk.ValAddress(vestingAccount.AccAddr).String()})\n+\t\t\t\tExpect(err).To(BeNil())\n+\t\t\t\tExpect(valRes.Validator.Status).To(Equal(types.Bonded))\n+\t\t\t})\n+\t\t})\n+\t})\n+})"
        },
        {
          "filename": "x/staking/keeper/keeper.go",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper\n+\n+import (\n+\t\"github.com/cosmos/cosmos-sdk/codec\"\n+\tstoretypes \"github.com/cosmos/cosmos-sdk/store/types\"\n+\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+)\n+\n+// Keeper is a wrapper around the Cosmos SDK staking keeper.\n+type Keeper struct {\n+\t*stakingkeeper.Keeper\n+\tak types.AccountKeeper\n+\tbk types.BankKeeper\n+}\n+\n+// NewKeeper creates a new staking Keeper wrapper instance.\n+func NewKeeper(\n+\tcdc codec.BinaryCodec,\n+\tkey storetypes.StoreKey,\n+\tak types.AccountKeeper,\n+\tbk types.BankKeeper,\n+\tauthority string,\n+) *Keeper {\n+\treturn &Keeper{\n+\t\tstakingkeeper.NewKeeper(cdc, key, ak, bk, authority),\n+\t\tak,\n+\t\tbk,\n+\t}\n+}"
        },
        {
          "filename": "x/staking/keeper/msg_server.go",
          "status": "added",
          "additions": 107,
          "deletions": 0,
          "patch": "@@ -0,0 +1,107 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper\n+\n+import (\n+\t\"context\"\n+\n+\terrorsmod \"cosmossdk.io/errors\"\n+\t\"cosmossdk.io/math\"\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\terrortypes \"github.com/cosmos/cosmos-sdk/types/errors\"\n+\tsdkstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+)\n+\n+// msgServer is a wrapper around the Cosmos SDK message server.\n+type msgServer struct {\n+\ttypes.MsgServer\n+\t*Keeper\n+}\n+\n+var _ types.MsgServer = msgServer{}\n+\n+// NewMsgServerImpl returns an implementation of the staking MsgServer interface\n+// for the provided Keeper.\n+func NewMsgServerImpl(keeper *Keeper) types.MsgServer {\n+\tbaseMsgServer := sdkstakingkeeper.NewMsgServerImpl(keeper.Keeper)\n+\treturn &msgServer{baseMsgServer, keeper}\n+}\n+\n+// Delegate defines a method for performing a delegation of coins from a delegator to a validator.\n+// The method performs some checks if the sender of the tx is a clawback vesting account and then\n+// relay the message to the Cosmos SDK staking method.\n+func (k msgServer) Delegate(goCtx context.Context, msg *types.MsgDelegate) (*types.MsgDelegateResponse, error) {\n+\tif err := k.validateDelegationAmountNotUnvested(goCtx, msg.DelegatorAddress, msg.Amount.Amount); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn k.MsgServer.Delegate(goCtx, msg)\n+}\n+\n+// CreateValidator defines a method to create a validator. The method performs some checks if the\n+// sender of the tx is a clawback vesting account and then relay the message to the Cosmos SDK staking\n+// method.\n+func (k msgServer) CreateValidator(goCtx context.Context, msg *types.MsgCreateValidator) (*types.MsgCreateValidatorResponse, error) {\n+\tif err := k.validateDelegationAmountNotUnvested(goCtx, msg.DelegatorAddress, msg.Value.Amount); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn k.MsgServer.CreateValidator(goCtx, msg)\n+}\n+\n+// validateDelegationAmountNotUnvested checks if the delegator is a clawback vesting account.\n+// In such case, checks that the provided delegation amount is available according\n+// to the current vesting schedule (unvested coins cannot be delegated).\n+func (k msgServer) validateDelegationAmountNotUnvested(goCtx context.Context, delegatorAddress string, amount math.Int) error {\n+\tctx := sdk.UnwrapSDKContext(goCtx)\n+\taddr, err := sdk.AccAddressFromBech32(delegatorAddress)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tacc := k.ak.GetAccount(ctx, addr)\n+\tif acc == nil {\n+\t\treturn errorsmod.Wrapf(\n+\t\t\terrortypes.ErrUnknownAddress,\n+\t\t\t\"account %s does not exist\", addr,\n+\t\t)\n+\t}\n+\t// check if delegator address is a clawback vesting account. If not, no check\n+\t// is required.\n+\tclawbackAccount, isClawback := acc.(*vestingtypes.ClawbackVestingAccount)\n+\tif !isClawback {\n+\t\treturn nil\n+\t}\n+\n+\t// vesting account can only delegate\n+\t// if enough free balance (coins not in vesting schedule)\n+\t// plus the vested coins (locked/unlocked)\n+\tbondDenom := k.BondDenom(ctx)\n+\t// GetBalance returns entire account balance\n+\t// balance = free coins + all coins in vesting schedule\n+\tbalance := k.bk.GetBalance(ctx, addr, bondDenom)\n+\tunvestedOnly := clawbackAccount.GetVestingCoins(ctx.BlockTime())\n+\t// delegatable coins are going to be all the free coins + vested coins\n+\t// Can only delegate bondable coins\n+\tunvestedBondableAmt := unvestedOnly.AmountOf(bondDenom)\n+\t// A ClawbackVestingAccount can delegate coins from the vesting schedule\n+\t// when having vested locked coins or unlocked vested coins.\n+\t// It CANNOT delegate unvested coins\n+\tdelegatableAmt := balance.Amount.Sub(unvestedBondableAmt)\n+\tif delegatableAmt.IsNegative() {\n+\t\tdelegatableAmt = math.ZeroInt()\n+\t}\n+\n+\tif delegatableAmt.LT(amount) {\n+\t\treturn errorsmod.Wrapf(\n+\t\t\tvestingtypes.ErrInsufficientVestedCoins,\n+\t\t\t\"cannot delegate unvested coins. coins available for delegation < delegation amount (%s < %s)\",\n+\t\t\tdelegatableAmt, amount,\n+\t\t)\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "x/staking/keeper/msg_server_test.go",
          "status": "added",
          "additions": 271,
          "deletions": 0,
          "patch": "@@ -0,0 +1,271 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper_test\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519\"\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/network\"\n+\tutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+\t\"github.com/evmos/evmos/v18/x/staking/keeper\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestMsgDelegate(t *testing.T) {\n+\tvar (\n+\t\tctx              sdk.Context\n+\t\tnw               *network.UnitTestNetwork\n+\t\tdefaultDelCoin   = sdk.NewCoin(utils.BaseDenom, math.NewInt(1e18))\n+\t\tdelegatorAddr, _ = utiltx.NewAccAddressAndKey()\n+\t\tfunderAddr, _    = utiltx.NewAccAddressAndKey()\n+\t)\n+\n+\ttestCases := []struct {\n+\t\tname   string\n+\t\tsetup  func() sdk.Coin\n+\t\texpErr bool\n+\t\terrMsg string\n+\t}{\n+\t\t{\n+\t\t\tname: \"can delegate from a common EthAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\t// Send some funds to delegator account\n+\t\t\t\terr := testutil.FundAccountWithBaseDenom(ctx, nw.App.BankKeeper, delegatorAddr, defaultDelCoin.Amount.Int64())\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can delegate free coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins.Add(defaultDelCoin))\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"cannot delegate unvested coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: true,\n+\t\t\terrMsg: \"cannot delegate unvested coins\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can delegate locked vested coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// after first vesting period and before lockup\n+\t\t\t\t// some vested tokens, but still all locked\n+\t\t\t\tcliffDuration := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(cliffDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, delegatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\t// check that locked vested is > 0\n+\t\t\t\tlockedVested := vestAcc.GetLockedUpVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, lockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn lockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can delegate unlocked vested coins from a ClawbackVestingAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, delegatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// Between first and second lockup periods\n+\t\t\t\t// vested coins are unlocked\n+\t\t\t\tlockDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(lockDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, delegatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\tunlockedVested := vestAcc.GetUnlockedVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, unlockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn unlockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tnw = network.NewUnitTestNetwork()\n+\t\t\tctx = nw.GetContext()\n+\t\t\tdelCoin := tc.setup()\n+\n+\t\t\tsrv := keeper.NewMsgServerImpl(&nw.App.StakingKeeper)\n+\t\t\tres, err := srv.Delegate(ctx, &types.MsgDelegate{\n+\t\t\t\tDelegatorAddress: delegatorAddr.String(),\n+\t\t\t\tValidatorAddress: nw.GetValidators()[0].OperatorAddress,\n+\t\t\t\tAmount:           delCoin,\n+\t\t\t})\n+\n+\t\t\tif tc.expErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\trequire.Contains(t, err.Error(), tc.errMsg)\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\trequire.NotNil(t, res)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestMsgCreateValidator(t *testing.T) {\n+\tvar (\n+\t\tctx              sdk.Context\n+\t\tnw               *network.UnitTestNetwork\n+\t\tdefaultDelCoin   = sdk.NewCoin(utils.BaseDenom, math.NewInt(1e18))\n+\t\tvalidatorAddr, _ = utiltx.NewAccAddressAndKey()\n+\t\tfunderAddr, _    = utiltx.NewAccAddressAndKey()\n+\t)\n+\n+\ttestCases := []struct {\n+\t\tname   string\n+\t\tsetup  func() sdk.Coin\n+\t\texpErr bool\n+\t\terrMsg string\n+\t}{\n+\t\t{\n+\t\t\tname: \"can create a validator using a common EthAccount\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\t// Send some funds to delegator account\n+\t\t\t\terr := testutil.FundAccountWithBaseDenom(ctx, nw.App.BankKeeper, validatorAddr, defaultDelCoin.Amount.Int64())\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can create a validator using a ClawbackVestingAccount and free tokens in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins.Add(defaultDelCoin))\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"cannot create a validator using a ClawbackVestingAccount and unvested tokens in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\treturn defaultDelCoin\n+\t\t\t},\n+\t\t\texpErr: true,\n+\t\t\terrMsg: \"cannot delegate unvested coins\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can create a validator using a ClawbackVestingAccount and locked vested coins in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// after first vesting period and before lockup\n+\t\t\t\t// some vested tokens, but still all locked\n+\t\t\t\tcliffDuration := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(cliffDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, validatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\t// check that locked vested is > 0\n+\t\t\t\tlockedVested := vestAcc.GetLockedUpVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, lockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn lockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"can create a validator using a ClawbackVestingAccount and unlocked vested coins in self delegation\",\n+\t\t\tsetup: func() sdk.Coin {\n+\t\t\t\terr := setupClawbackVestingAccount(ctx, nw, validatorAddr, funderAddr, testutil.TestVestingSchedule.TotalVestingCoins)\n+\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t// Between first and second lockup periods\n+\t\t\t\t// vested coins are unlocked\n+\t\t\t\tlockDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n+\t\t\t\tnw.NextBlockAfter(lockDuration * time.Second)\n+\t\t\t\tctx = nw.GetContext()\n+\n+\t\t\t\tacc := nw.App.AccountKeeper.GetAccount(ctx, validatorAddr)\n+\t\t\t\tvestAcc, ok := acc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\t\trequire.True(t, ok)\n+\n+\t\t\t\tunlockedVested := vestAcc.GetUnlockedVestedCoins(ctx.BlockTime())\n+\t\t\t\trequire.True(t, unlockedVested.IsAllGT(sdk.NewCoins()))\n+\n+\t\t\t\t// returned delegation coins are the locked vested coins\n+\t\t\t\treturn unlockedVested[0]\n+\t\t\t},\n+\t\t\texpErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tnw = network.NewUnitTestNetwork()\n+\t\t\tctx = nw.GetContext()\n+\t\t\tcoinToSelfBond := tc.setup()\n+\n+\t\t\tpubKey := ed25519.GenPrivKey().PubKey()\n+\t\t\tcommissions := types.NewCommissionRates(\n+\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t\tsdk.NewDecWithPrec(2, 1),\n+\t\t\t\tsdk.NewDecWithPrec(5, 2),\n+\t\t\t)\n+\t\t\tmsg, err := types.NewMsgCreateValidator(\n+\t\t\t\tsdk.ValAddress(validatorAddr),\n+\t\t\t\tpubKey,\n+\t\t\t\tcoinToSelfBond,\n+\t\t\t\ttypes.NewDescription(\"T\", \"E\", \"S\", \"T\", \"Z\"),\n+\t\t\t\tcommissions,\n+\t\t\t\tsdk.OneInt(),\n+\t\t\t)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tsrv := keeper.NewMsgServerImpl(&nw.App.StakingKeeper)\n+\t\t\tres, err := srv.CreateValidator(ctx, msg)\n+\n+\t\t\tif tc.expErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\trequire.Contains(t, err.Error(), tc.errMsg)\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\trequire.NotNil(t, res)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "x/staking/keeper/util_test.go",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package keeper_test\n+\n+import (\n+\t\"errors\"\n+\t\"time\"\n+\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\t\"github.com/evmos/evmos/v18/testutil/integration/evmos/network\"\n+\t\"github.com/evmos/evmos/v18/x/vesting/types\"\n+)\n+\n+// setupClawbackVestingAccount sets up a clawback vesting account\n+// using the TestVestingSchedule. If exceeded balance is provided,\n+// will fund the vesting account with it.\n+func setupClawbackVestingAccount(ctx sdk.Context, nw *network.UnitTestNetwork, vestingAcc, funderAcc sdk.AccAddress, balances sdk.Coins) error {\n+\ttotalVestingCoins := testutil.TestVestingSchedule.TotalVestingCoins\n+\tif totalVestingCoins.IsAllGT(balances) {\n+\t\treturn errors.New(\"should provide enough balance for the vesting schedule\")\n+\t}\n+\t// fund the vesting account to set the account and then\n+\t// send funds over to the funder account so free balance remains\n+\terr := testutil.FundAccount(ctx, nw.App.BankKeeper, vestingAcc, balances)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = nw.App.BankKeeper.SendCoins(ctx, vestingAcc, funderAcc, totalVestingCoins)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// create a clawback vesting account\n+\tmsgCreate := types.NewMsgCreateClawbackVestingAccount(funderAcc, vestingAcc, false)\n+\tif _, err = nw.App.VestingKeeper.CreateClawbackVestingAccount(ctx, msgCreate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// fund vesting account\n+\tmsgFund := types.NewMsgFundVestingAccount(funderAcc, vestingAcc, time.Now(), testutil.TestVestingSchedule.LockupPeriods, testutil.TestVestingSchedule.VestingPeriods)\n+\tif _, err = nw.App.VestingKeeper.FundVestingAccount(ctx, msgFund); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}"
        },
        {
          "filename": "x/staking/module.go",
          "status": "added",
          "additions": 61,
          "deletions": 0,
          "patch": "@@ -0,0 +1,61 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+\n+package staking\n+\n+import (\n+\t\"github.com/cosmos/cosmos-sdk/codec\"\n+\t\"github.com/cosmos/cosmos-sdk/types/module\"\n+\t\"github.com/cosmos/cosmos-sdk/x/auth/exported\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking\"\n+\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\t\"github.com/cosmos/cosmos-sdk/x/staking/types\"\n+\n+\t\"github.com/evmos/evmos/v18/x/staking/keeper\"\n+)\n+\n+var (\n+\t_ module.BeginBlockAppModule = AppModule{}\n+\t_ module.EndBlockAppModule   = AppModule{}\n+\t_ module.AppModuleBasic      = AppModuleBasic{}\n+\t_ module.AppModuleSimulation = AppModule{}\n+)\n+\n+// AppModuleBasic defines the basic application module used by the staking module.\n+type AppModuleBasic struct {\n+\t*staking.AppModuleBasic\n+}\n+\n+// AppModule represents a wrapper around the Cosmos SDK staking module AppModule and\n+// the Evmos custom staking module keeper.\n+type AppModule struct {\n+\t*staking.AppModule\n+\tkeeper *keeper.Keeper\n+}\n+\n+// NewAppModule creates a wrapper for the staking module.\n+func NewAppModule(\n+\tcdc codec.Codec,\n+\tk *keeper.Keeper,\n+\tak types.AccountKeeper,\n+\tbk types.BankKeeper,\n+\tls exported.Subspace,\n+) AppModule {\n+\tam := staking.NewAppModule(cdc, k.Keeper, ak, bk, ls)\n+\treturn AppModule{\n+\t\tAppModule: &am,\n+\t\tkeeper:    k,\n+\t}\n+}\n+\n+// RegisterServices registers module services.\n+func (am AppModule) RegisterServices(cfg module.Configurator) {\n+\t// Override Staking Msg Server\n+\ttypes.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))\n+\tquerier := stakingkeeper.Querier{Keeper: am.keeper.Keeper}\n+\ttypes.RegisterQueryServer(cfg.QueryServer(), querier)\n+\n+\t// !! NOTE: when upgrading to a new cosmos-sdk version\n+\t// !! Check if there're store migrations for the staking module\n+\t// !! if so, you'll need to add them here\n+}"
        },
        {
          "filename": "x/vesting/keeper/gov_test.go",
          "status": "modified",
          "additions": 6,
          "deletions": 2,
          "patch": "@@ -6,7 +6,9 @@ import (\n )\n \n func (suite *KeeperTestSuite) TestGovClawbackStore() {\n-\tsuite.SetupTest()\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n \n \taddr := sdk.AccAddress(suite.address.Bytes())\n \n@@ -30,7 +32,9 @@ func (suite *KeeperTestSuite) TestGovClawbackStore() {\n }\n \n func (suite *KeeperTestSuite) TestGovClawbackNoOps() {\n-\tsuite.SetupTest()\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n \n \taddr := sdk.AccAddress(suite.address.Bytes())\n \taddr2 := sdk.AccAddress(testutiltx.GenerateAddress().Bytes())"
        },
        {
          "filename": "x/vesting/keeper/grpc_query.go",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -40,9 +40,9 @@ func (k Keeper) Balances(\n \t\t)\n \t}\n \n-\tlocked := clawbackAccount.GetLockedOnly(ctx.BlockTime())\n-\tunvested := clawbackAccount.GetUnvestedOnly(ctx.BlockTime())\n-\tvested := clawbackAccount.GetVestedOnly(ctx.BlockTime())\n+\tlocked := clawbackAccount.GetLockedUpCoins(ctx.BlockTime())\n+\tunvested := clawbackAccount.GetVestingCoins(ctx.BlockTime())\n+\tvested := clawbackAccount.GetVestedCoins(ctx.BlockTime())\n \n \treturn &types.QueryBalancesResponse{\n \t\tLocked:   locked,"
        },
        {
          "filename": "x/vesting/keeper/grpc_query_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -117,7 +117,7 @@ func (suite *KeeperTestSuite) TestBalances() {\n \n \tfor _, tc := range testCases {\n \t\tsuite.Run(fmt.Sprintf(\"Case %s\", tc.name), func() {\n-\t\t\tsuite.SetupTest() // reset\n+\t\t\tsuite.Require().NoError(suite.SetupTest()) // reset\n \t\t\tctx := sdk.WrapSDKContext(suite.ctx)\n \t\t\ttc.malleate()\n \t\t\tsuite.Commit()"
        },
        {
          "filename": "x/vesting/keeper/integration_test.go",
          "status": "modified",
          "additions": 412,
          "deletions": 380,
          "patch": "@@ -4,6 +4,7 @@ import (\n \t\"fmt\"\n \t\"math/big\"\n \t\"strings\"\n+\t\"testing\"\n \t\"time\"\n \n \t//nolint:revive // dot imports are fine for Ginkgo\n@@ -12,14 +13,17 @@ import (\n \t. \"github.com/onsi/gomega\"\n \n \t\"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \terrortypes \"github.com/cosmos/cosmos-sdk/types/errors\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n+\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n \tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n \tgovv1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1\"\n \tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n \tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n+\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/common\"\n \t\"github.com/evmos/evmos/v18/contracts\"\n \t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n@@ -31,6 +35,15 @@ import (\n \t\"github.com/evmos/evmos/v18/x/vesting/types\"\n )\n \n+func TestKeeperIntegrationTestSuite(t *testing.T) {\n+\ts = new(KeeperTestSuite)\n+\ts.SetT(t)\n+\n+\t// Run Ginkgo integration tests\n+\tRegisterFailHandler(Fail)\n+\tRunSpecs(t, \"Keeper Suite\")\n+}\n+\n // TestClawbackAccount is a struct to store all relevant information that is corresponding\n // to a clawback vesting account.\n type TestClawbackAccount struct {\n@@ -40,7 +53,20 @@ type TestClawbackAccount struct {\n }\n \n // Initialize general error variable for easier handling in loops throughout this test suite.\n-var err error\n+var (\n+\terr                error\n+\tstakeDenom         = utils.BaseDenom\n+\taccountGasCoverage = sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e16)))\n+\tamt                = testutil.TestVestingSchedule.VestedCoinsPerPeriod[0].Amount\n+\tcliff              = testutil.TestVestingSchedule.CliffMonths\n+\tcliffLength        = testutil.TestVestingSchedule.CliffPeriodLength\n+\tvestingAmtTotal    = testutil.TestVestingSchedule.TotalVestingCoins\n+\tvestingLength      = testutil.TestVestingSchedule.VestingPeriodLength\n+\tnumLockupPeriods   = testutil.TestVestingSchedule.NumLockupPeriods\n+\tperiodsTotal       = testutil.TestVestingSchedule.NumVestingPeriods\n+\tlockup             = testutil.TestVestingSchedule.LockupMonths\n+\tunlockedPerLockup  = testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n+)\n \n // Clawback vesting with Cliff and Lock. In this case the cliff is reached\n // before the lockup period is reached to represent the scenario in which an\n@@ -52,44 +78,6 @@ var err error\n // 22/09 Cliff ends\n // 23/02 Lock ends\n var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n-\t// Monthly vesting period\n-\tstakeDenom := utils.BaseDenom\n-\tamt := math.NewInt(1e17)\n-\tvestingLength := int64(60 * 60 * 24 * 30) // in seconds\n-\tvestingAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt))\n-\tvestingPeriod := sdkvesting.Period{Length: vestingLength, Amount: vestingAmt}\n-\n-\t// 4 years vesting total\n-\tperiodsTotal := int64(48)\n-\tvestingAmtTotal := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n-\n-\t// 6 month cliff\n-\tcliff := int64(6)\n-\tcliffLength := vestingLength * cliff\n-\tcliffAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n-\tcliffPeriod := sdkvesting.Period{Length: cliffLength, Amount: cliffAmt}\n-\n-\t// 12 month lockup\n-\tlockup := int64(12) // 12 months\n-\tlockupLength := vestingLength * lockup\n-\t// Unlock at 12 and 24 months\n-\tnumLockupPeriods := int64(2)\n-\t// Unlock 1/4th of the total vest in each unlock event. By default, all tokens are\n-\t// unlocked after surpassing the final period.\n-\tunlockedPerLockup := vestingAmtTotal.QuoInt(math.NewInt(4))\n-\tunlockedPerLockupAmt := unlockedPerLockup[0].Amount\n-\tlockupPeriod := sdkvesting.Period{Length: lockupLength, Amount: unlockedPerLockup}\n-\tlockupPeriods := make(sdkvesting.Periods, numLockupPeriods)\n-\tfor i := range lockupPeriods {\n-\t\tlockupPeriods[i] = lockupPeriod\n-\t}\n-\n-\t// Create vesting periods with initial cliff\n-\tvestingPeriods := sdkvesting.Periods{cliffPeriod}\n-\tfor p := int64(1); p <= periodsTotal-cliff; p++ {\n-\t\tvestingPeriods = append(vestingPeriods, vestingPeriod)\n-\t}\n-\n \t// Create test accounts with private keys for signing\n \tnumTestAccounts := 4\n \ttestAccounts := make([]TestClawbackAccount, numTestAccounts)\n@@ -102,20 +90,20 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t}\n \tnumTestMsgs := 3\n \n-\taccountGasCoverage := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e16)))\n-\n \tvar (\n-\t\tclawbackAccount   *types.ClawbackVestingAccount\n-\t\tunvested          sdk.Coins\n-\t\tvested            sdk.Coins\n+\t\tclawbackAccount *types.ClawbackVestingAccount\n+\t\tunvested        sdk.Coins\n+\t\tvested          sdk.Coins\n+\t\t// freeCoins are unlocked vested coins of the vesting schedule\n+\t\tfreeCoins         sdk.Coins\n \t\ttwoThirdsOfVested sdk.Coins\n \t)\n \n \tdest := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \tfunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \n \tBeforeEach(func() {\n-\t\ts.SetupTest()\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n \n \t\t// Initialize all test accounts\n \t\tfor i, account := range testAccounts {\n@@ -127,65 +115,64 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t\tfunder,\n \t\t\t\tvestingAmtTotal,\n \t\t\t\tvestingStart,\n-\t\t\t\tlockupPeriods,\n-\t\t\t\tvestingPeriods,\n+\t\t\t\ttestutil.TestVestingSchedule.LockupPeriods,\n+\t\t\t\ttestutil.TestVestingSchedule.VestingPeriods,\n \t\t\t)\n \n \t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, vestingAmtTotal)\n-\t\t\ts.Require().NoError(err)\n+\t\t\tExpect(err).To(BeNil())\n \t\t\tacc := s.app.AccountKeeper.NewAccount(s.ctx, clawbackAccount)\n \t\t\ts.app.AccountKeeper.SetAccount(s.ctx, acc)\n \n \t\t\t// Check if all tokens are unvested at vestingStart\n-\t\t\tunvested = clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\ts.Require().Equal(vestingAmtTotal, unvested)\n-\t\t\ts.Require().True(vested.IsZero())\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tExpect(vestingAmtTotal).To(Equal(unvested))\n+\t\t\tExpect(vested.IsZero()).To(BeTrue())\n \n \t\t\t// Grant gas stipend to cover EVM fees\n \t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, clawbackAccount.GetAddress(), accountGasCoverage)\n-\t\t\ts.Require().NoError(err)\n+\t\t\tExpect(err).To(BeNil())\n \t\t\tgranteeBalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n-\t\t\ts.Require().Equal(granteeBalance, accountGasCoverage[0].Add(vestingAmtTotal[0]))\n+\t\t\tExpect(granteeBalance).To(Equal(accountGasCoverage[0].Add(vestingAmtTotal[0])))\n \n \t\t\t// Update testAccounts clawbackAccount reference\n \t\t\ttestAccounts[i].clawbackAccount = clawbackAccount\n \t\t}\n \t})\n-\n \tContext(\"before first vesting period\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Add a commit to instantiate blocks\n \t\t\ts.Commit()\n \n \t\t\t// Ensure no tokens are vested\n-\t\t\tvested := clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked := clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tvested := clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.ZeroInt()))\n-\t\t\ts.Require().Equal(zeroCoins, vested)\n-\t\t\ts.Require().Equal(zeroCoins, unlocked)\n+\t\t\tExpect(zeroCoins).To(Equal(vested))\n+\t\t\tExpect(zeroCoins).To(Equal(unlocked))\n \t\t})\n \n \t\tIt(\"cannot delegate tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], accountGasCoverage.Add(sdk.NewCoin(stakeDenom, math.NewInt(1))))\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, accountGasCoverage.Add(sdk.NewCoin(stakeDenom, math.NewInt(1)))[0], s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n \t\tIt(\"can transfer spendable tokens\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\t// Fund account with new spendable tokens\n-\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, unvested)\n+\t\t\tamt := unvested\n+\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, amt)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\terr = s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n \t\t\t\taccount.address,\n \t\t\t\tdest,\n-\t\t\t\tunvested,\n+\t\t\t\tamt,\n \t\t\t)\n \t\t\tExpect(err).To(BeNil())\n \t\t})\n-\n \t\tIt(\"cannot transfer unvested tokens\", func() {\n \t\t\terr := s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n@@ -195,77 +182,162 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n-\n \t\tIt(\"can perform Ethereum tx with spendable balance\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\t// Fund account with new spendable tokens\n-\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, unlockedPerLockup)\n+\t\t\tcoins := testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n+\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, coins)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := coins.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, coins.AmountOf(stakeDenom), stakeDenom, msg)\n \t\t})\n \n \t\tIt(\"cannot perform Ethereum tx with unvested balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\tunlockedCoins := testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n+\t\t\ttxAmount := unlockedCoins.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\tassertEthFails(msg)\n \t\t})\n \t})\n-\n \tContext(\"after first vesting period and before lockup\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass cliff but none of lockup duration\n-\t\t\tcliffDuration := time.Duration(cliffLength)\n+\t\t\tcliffDuration := time.Duration(testutil.TestVestingSchedule.CliffPeriodLength)\n \t\t\ts.CommitAfter(cliffDuration * time.Second)\n \n \t\t\t// Check if some, but not all tokens are vested\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n-\t\t\ts.Require().NotEqual(vestingAmtTotal, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(testutil.TestVestingSchedule.CliffMonths))))\n+\t\t\tExpect(vested).NotTo(Equal(vestingAmtTotal))\n+\t\t\tExpect(vested).To(Equal(expVested))\n+\n+\t\t\t// check the vested tokens are still locked\n+\t\t\tfreeCoins = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\tExpect(freeCoins).To(Equal(sdk.Coins{}))\n \n \t\t\ttwoThirdsOfVested = vested.Sub(vested.QuoInt(math.NewInt(3))...)\n+\n+\t\t\tres, err := s.app.VestingKeeper.Balances(s.ctx, &types.QueryBalancesRequest{Address: clawbackAccount.Address})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(res.Vested).To(Equal(expVested))\n+\t\t\tExpect(res.Unvested).To(Equal(vestingAmtTotal.Sub(expVested...)))\n+\t\t\t// All coins from vesting schedule should be locked\n+\t\t\tExpect(res.Locked).To(Equal(vestingAmtTotal))\n \t\t})\n \n-\t\tIt(\"can delegate vested tokens and update spendable balance\", func() {\n+\t\tIt(\"can delegate vested locked tokens\", func() {\n \t\t\ttestAccount := testAccounts[0]\n-\t\t\t// Verify that the total spendable coins decreases after staking\n-\t\t\t// vested tokens.\n+\t\t\t// Verify that the total spendable coins should only be coins\n+\t\t\t// not in the vesting schedule. Because all coins from the vesting\n+\t\t\t// schedule are still locked\n \t\t\tspendablePre := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePre).To(Equal(accountGasCoverage))\n+\n+\t\t\t// delegate the vested locked coins.\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccount.privKey, vested[0], s.validator)\n+\t\t\tExpect(err).To(BeNil(), \"expected no error during delegation\")\n \n-\t\t\t_, err := delegate(testAccount, vested)\n+\t\t\t// check spendable coins have only been reduced by the gas paid for the transaction to show that the delegated coins were taken from the locked but vested amount\n+\t\t\tspendablePost := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePost).To(Equal(spendablePre.Sub(accountGasCoverage...)))\n+\n+\t\t\t// check delegation was created successfully\n+\t\t\tstkQuerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tdelRes, err := stkQuerier.DelegatorDelegations(s.ctx, &stakingtypes.QueryDelegatorDelegationsRequest{DelegatorAddr: testAccount.clawbackAccount.Address})\n \t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponses).To(HaveLen(1))\n+\t\t\tExpect(delRes.DelegationResponses[0].Balance.Amount).To(Equal(vested[0].Amount))\n+\t\t})\n \n+\t\tIt(\"can delegate tokens from account balance - tokens not in vesting schedule\", func() {\n+\t\t\ttestAccount := testAccounts[0]\n+\n+\t\t\t// send some funds to the account to delegate\n+\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e18)))\n+\t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, testAccount.address, coinsToDelegate)\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// Verify that the total spendable coins should only be coins\n+\t\t\t// not in the vesting schedule. Because all coins from the vesting\n+\t\t\t// schedule are still locked\n+\t\t\tspendablePre := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePre).To(Equal(accountGasCoverage.Add(coinsToDelegate...)))\n+\n+\t\t\t// delegate funds not in vesting schedule\n+\t\t\tres, err := testutil.Delegate(s.ctx, s.app, testAccount.privKey, coinsToDelegate[0], s.validator)\n+\t\t\tExpect(err).NotTo(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\n+\t\t\t// check spendable balance is updated properly\n \t\t\tspendablePost := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n-\t\t\tExpect(spendablePost.AmountOf(stakeDenom).GT(spendablePre.AmountOf(stakeDenom)))\n+\t\t\tExpect(spendablePost).To(Equal(spendablePre.Sub(coinsToDelegate...).Sub(accountGasCoverage...)))\n \t\t})\n \n-\t\tIt(\"cannot delegate unvested tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], vestingAmtTotal)\n+\t\tIt(\"can delegate tokens from account balance (free tokens) + locked vested tokens\", func() {\n+\t\t\ttestAccount := testAccounts[0]\n+\n+\t\t\t// send some funds to the account to delegate\n+\t\t\tamt := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e18)))\n+\t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, testAccount.address, amt)\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t// Verify that the total spendable coins should only be coins\n+\t\t\t// not in the vesting schedule. Because all coins from the vesting\n+\t\t\t// schedule are still locked\n+\t\t\tspendablePre := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePre).To(Equal(accountGasCoverage.Add(amt...)))\n+\n+\t\t\t// delegate some tokens from the account balance + locked vested coins\n+\t\t\tcoinsToDelegate := amt.Add(vested...)\n+\n+\t\t\tres, err := testutil.Delegate(s.ctx, s.app, testAccount.privKey, coinsToDelegate[0], s.validator)\n+\t\t\tExpect(err).NotTo(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(res.IsOK()).To(BeTrue())\n+\n+\t\t\t// check spendable balance is updated properly\n+\t\t\tspendablePost := s.app.BankKeeper.SpendableCoins(s.ctx, testAccount.address)\n+\t\t\tExpect(spendablePost).To(Equal(spendablePre.Sub(amt...).Sub(accountGasCoverage...)))\n+\t\t})\n+\n+\t\tIt(\"cannot delegate unvested tokens in sequetial txs\", func() {\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, twoThirdsOfVested[0], s.validator)\n+\t\t\tExpect(err).To(BeNil(), \"error while executing the delegate message\")\n+\t\t\t_, err = testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, twoThirdsOfVested[0], s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n-\t\tIt(\"cannot delegate unvested tokens in batches\", func() {\n-\t\t\tmsg, err := delegate(testAccounts[0], twoThirdsOfVested)\n+\t\tIt(\"cannot delegate then send tokens\", func() {\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, twoThirdsOfVested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tmsgServer := stakingkeeper.NewMsgServerImpl(&s.app.StakingKeeper)\n-\t\t\t_, err = msgServer.Delegate(s.ctx, msg)\n-\t\t\tExpect(err).ToNot(HaveOccurred(), \"error while executing the delegate message\")\n+\t\t\terr = s.app.BankKeeper.SendCoins(\n+\t\t\t\ts.ctx,\n+\t\t\t\tclawbackAccount.GetAddress(),\n+\t\t\t\tdest,\n+\t\t\t\ttwoThirdsOfVested,\n+\t\t\t)\n+\t\t\tExpect(err).ToNot(BeNil())\n+\t\t})\n \n-\t\t\t_, err = delegate(testAccounts[0], twoThirdsOfVested)\n+\t\tIt(\"cannot delegate more than the locked vested tokens\", func() {\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, vested[0].Add(sdk.NewCoin(stakeDenom, math.NewInt(1))), s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n-\t\tIt(\"cannot delegate then send tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], twoThirdsOfVested)\n+\t\tIt(\"cannot delegate free tokens and then send locked/unvested tokens\", func() {\n+\t\t\t// send some funds to the account to delegate\n+\t\t\tcoinsToDelegate := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.NewInt(1e18)))\n+\t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, testAccounts[0].address, coinsToDelegate)\n+\t\t\tExpect(err).To(BeNil())\n+\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, coinsToDelegate[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\terr = s.app.BankKeeper.SendCoins(\n@@ -277,7 +349,7 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n-\t\tIt(\"cannot transfer vested tokens\", func() {\n+\t\tIt(\"cannot transfer locked vested tokens\", func() {\n \t\t\terr := s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n \t\t\t\tclawbackAccount.GetAddress(),\n@@ -289,85 +361,141 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \n \t\tIt(\"can perform Ethereum tx with spendable balance\", func() {\n \t\t\taccount := testAccounts[0]\n+\t\t\tcoins := testutil.TestVestingSchedule.UnlockedCoinsPerLockup\n \t\t\t// Fund account with new spendable tokens\n-\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, unlockedPerLockup)\n+\t\t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, account.address, coins)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n-\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n+\t\t\ttxAmount := coins.AmountOf(stakeDenom)\n+\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, txAmount, stakeDenom, msg)\n \t\t})\n \n-\t\tIt(\"cannot perform Ethereum tx with locked balance\", func() {\n+\t\tIt(\"cannot perform Ethereum tx with locked vested balance\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\ttxAmount := vested.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msg)\n \t\t})\n \t})\n-\n \tContext(\"Between first and second lockup periods\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass first lockup\n-\t\t\tvestDuration := time.Duration(lockupLength)\n+\t\t\tvestDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength)\n \t\t\ts.CommitAfter(vestDuration * time.Second)\n \n+\t\t\t// after first lockup period\n+\t\t\t// half of total vesting tokens are unlocked\n+\t\t\t// but only 12 vesting periods passed\n \t\t\t// Check if some, but not all tokens are vested and unlocked\n \t\t\tfor _, account := range testAccounts {\n-\t\t\t\tvested := account.clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\t\tunlocked := account.clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\t\tvested = account.clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\t\tunlocked := account.clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\t\tfreeCoins = account.clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\n \t\t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(lockup))))\n+\t\t\t\texpUnlockedVested := expVested\n \n-\t\t\t\ts.Require().NotEqual(vestingAmtTotal, vested)\n-\t\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\t\ts.Require().Equal(unlocked, unlockedPerLockup)\n+\t\t\t\tExpect(vested).NotTo(Equal(vestingAmtTotal))\n+\t\t\t\tExpect(vested).To(Equal(expVested))\n+\t\t\t\tExpect(unlocked).To(Equal(unlockedPerLockup))\n+\t\t\t\tExpect(freeCoins).To(Equal(expUnlockedVested))\n \t\t\t}\n \t\t})\n \n-\t\tIt(\"should enable access to unlocked EVM tokens (single-account, single-msg)\", func() {\n+\t\tIt(\"delegate unlocked vested tokens and spendable balance is updated properly\", func() {\n+\t\t\taccount := testAccounts[0]\n+\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n+\t\t\t// the returned balance should be the account's initial balance and\n+\t\t\t// the total amount of the vesting schedule\n+\t\t\tExpect(balance.Amount).To(Equal(accountGasCoverage.Add(vestingAmtTotal...)[0].Amount))\n+\n+\t\t\tspReq := &banktypes.QuerySpendableBalanceByDenomRequest{Address: account.address.String(), Denom: stakeDenom}\n+\t\t\tspRes, err := s.app.BankKeeper.SpendableBalanceByDenom(s.ctx, spReq)\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// spendable balance should be the initial account balance + vested tokens\n+\t\t\tinitialSpendableBalance := spRes.Balance\n+\t\t\tExpect(initialSpendableBalance.Amount).To(Equal(accountGasCoverage.Add(freeCoins...)[0].Amount))\n+\n+\t\t\t// can delegate vested tokens\n+\t\t\t// fees paid is accountGasCoverage amount\n+\t\t\tres, err := testutil.Delegate(s.ctx, s.app, account.privKey, freeCoins[0], s.validator)\n+\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(res.Code).To(BeZero(), \"expected delegation to succeed\")\n+\n+\t\t\t// spendable balance should be updated to be prevSpendableBalance - delegatedAmt - fees\n+\t\t\tspRes, err = s.app.BankKeeper.SpendableBalanceByDenom(s.ctx, spReq)\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(spRes.Balance.Amount.Int64()).To(Equal(int64(0)))\n+\n+\t\t\t// try to send coins - should error\n+\t\t\terr = s.app.BankKeeper.SendCoins(s.ctx, account.address, funder, vested)\n+\t\t\tExpect(err).NotTo(BeNil())\n+\t\t\tExpect(err.Error()).To(ContainSubstring(\"spendable balance\"))\n+\t\t\tExpect(err.Error()).To(ContainSubstring(\"is smaller than\"))\n+\t\t})\n+\n+\t\tIt(\"cannot delegate more than vested tokens\", func() {\n \t\t\taccount := testAccounts[0]\n+\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n+\t\t\t// the returned balance should be the account's initial balance and\n+\t\t\t// the total amount of the vesting schedule\n+\t\t\tExpect(balance.Amount).To(Equal(accountGasCoverage.Add(vestingAmtTotal...)[0].Amount))\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n-\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n+\t\t\tspReq := &banktypes.QuerySpendableBalanceByDenomRequest{Address: account.address.String(), Denom: stakeDenom}\n+\t\t\tspRes, err := s.app.BankKeeper.SpendableBalanceByDenom(s.ctx, spReq)\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\t// spendable balance should be the initial account balance + vested tokens\n+\t\t\tinitialSpendableBalance := spRes.Balance\n+\t\t\tExpect(initialSpendableBalance.Amount).To(Equal(accountGasCoverage.Add(freeCoins...)[0].Amount))\n+\n+\t\t\t// cannot delegate more than vested tokens\n+\t\t\t_, err = testutil.Delegate(s.ctx, s.app, account.privKey, freeCoins[0].Add(sdk.NewCoin(stakeDenom, math.NewInt(1))), s.validator)\n+\t\t\tExpect(err).To(HaveOccurred(), \"expected no error during delegation\")\n+\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot delegate unvested coins\"))\n+\t\t})\n+\n+\t\tIt(\"should enable access to unlocked and vested EVM tokens (single-account, single-msg)\", func() {\n+\t\t\taccount := testAccounts[0]\n+\t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, vested[0].Amount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, vested[0].Amount, stakeDenom, msg)\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens (single-account, multiple-msgs)\", func() {\n \t\t\taccount := testAccounts[0]\n \n \t\t\t// Split the total unlocked amount into numTestMsgs equally sized tx's\n \t\t\tmsgs := make([]sdk.Msg, numTestMsgs)\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \n \t\t\tfor i := 0; i < numTestMsgs; i++ {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, i)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, unlockedPerLockupAmt, stakeDenom, msgs...)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, vested[0].Amount, stakeDenom, msgs...)\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens (multi-account, single-msg)\", func() {\n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := vested[0].Amount.BigInt()\n \n \t\t\tmsgs := make([]sdk.Msg, numTestAccounts)\n \t\t\tfor i, grantee := range testAccounts {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, grantee.privKey, grantee.address, dest, txAmount, 0)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n \n-\t\t\tassertEthSucceeds(testAccounts, funder, dest, unlockedPerLockupAmt, stakeDenom, msgs...)\n+\t\t\tassertEthSucceeds(testAccounts, funder, dest, vested[0].Amount, stakeDenom, msgs...)\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens (multi-account, multiple-msgs)\", func() {\n \t\t\tmsgs := []sdk.Msg{}\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \n \t\t\tfor _, grantee := range testAccounts {\n \t\t\t\tfor j := 0; j < numTestMsgs; j++ {\n@@ -377,7 +505,7 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tassertEthSucceeds(testAccounts, funder, dest, unlockedPerLockupAmt, stakeDenom, msgs...)\n+\t\t\tassertEthSucceeds(testAccounts, funder, dest, vested[0].Amount, stakeDenom, msgs...)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (single-account, single-msg)\", func() {\n@@ -386,43 +514,39 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msg)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (single-account, multiple-msgs)\", func() {\n \t\t\tmsgs := make([]sdk.Msg, numTestMsgs+1)\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \t\t\ttestAccount := testAccounts[0]\n \n \t\t\t// Add additional message that exceeds unlocked balance\n \t\t\tfor i := 0; i < numTestMsgs+1; i++ {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, i)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n-\n \t\t\tassertEthFails(msgs...)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (multi-account, single-msg)\", func() {\n \t\t\tmsgs := make([]sdk.Msg, numTestAccounts+1)\n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := vested[0].Amount.BigInt()\n \n \t\t\tfor i, account := range testAccounts {\n \t\t\t\tmsgs[i], err = utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\t\tExpect(err).To(BeNil())\n \t\t\t}\n-\n \t\t\t// Add additional message that exceeds unlocked balance\n \t\t\tmsgs[numTestAccounts], err = utiltx.CreateEthTx(s.ctx, s.app, testAccounts[0].privKey, testAccounts[0].address, dest, txAmount, 1)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msgs...)\n \t\t})\n \n \t\tIt(\"should not enable access to locked EVM tokens (multi-account, multiple-msgs)\", func() {\n \t\t\tmsgs := []sdk.Msg{}\n-\t\t\ttxAmount := unlockedPerLockupAmt.QuoRaw(int64(numTestMsgs)).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.QuoRaw(int64(numTestMsgs)).BigInt()\n \t\t\tvar addedMsg sdk.Msg\n \n \t\t\tfor _, account := range testAccounts {\n@@ -431,95 +555,94 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t\t\tmsgs = append(msgs, addedMsg)\n \t\t\t\t}\n \t\t\t}\n-\n \t\t\t// Add additional message that exceeds unlocked balance\n \t\t\taddedMsg, err = utiltx.CreateEthTx(s.ctx, s.app, testAccounts[0].privKey, testAccounts[0].address, dest, txAmount, numTestMsgs)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tmsgs = append(msgs, addedMsg)\n-\n \t\t\tassertEthFails(msgs...)\n \t\t})\n-\n \t\tIt(\"should not short-circuit with a normal account\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\taddress, privKey := utiltx.NewAccAddressAndKey()\n-\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom).BigInt()\n-\n \t\t\t// Fund a normal account to try to short-circuit the AnteHandler\n \t\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, address, vestingAmtTotal.MulInt(math.NewInt(2)))\n \t\t\tExpect(err).To(BeNil())\n \t\t\tnormalAccMsg, err := utiltx.CreateEthTx(s.ctx, s.app, privKey, address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\t// Attempt to spend entire balance\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \t\t\terr = validateEthVestingTransactionDecorator(normalAccMsg, msg)\n \t\t\tExpect(err).ToNot(BeNil())\n-\n \t\t\t_, err = testutil.DeliverEthTx(s.app, nil, msg)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \t})\n \n \tContext(\"after first lockup and additional vest\", func() {\n \t\tBeforeEach(func() {\n-\t\t\tvestDuration := time.Duration(lockupLength + vestingLength)\n+\t\t\tvestDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength + vestingLength)\n \t\t\ts.CommitAfter(vestDuration * time.Second)\n \n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n+\t\t\t// after first lockup period\n+\t\t\t// half of total vesting tokens are unlocked\n+\t\t\t// now only 13 vesting periods passed\n+\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(lockup+1))))\n \n-\t\t\tunlocked := clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\texpUnlocked := unlockedPerLockup\n \n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().Equal(expUnlocked, unlocked)\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expUnlocked).To(Equal(unlocked))\n \t\t})\n \n \t\tIt(\"should enable access to unlocked EVM tokens\", func() {\n \t\t\ttestAccount := testAccounts[0]\n \n-\t\t\ttxAmount := unlockedPerLockupAmt.BigInt()\n+\t\t\ttxAmount := vested[0].Amount.BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n-\t\t\tassertEthSucceeds([]TestClawbackAccount{testAccount}, funder, dest, unlockedPerLockupAmt, stakeDenom, msg)\n+\t\t\tassertEthSucceeds([]TestClawbackAccount{testAccount}, funder, dest, vested[0].Amount, stakeDenom, msg)\n \t\t})\n \n-\t\tIt(\"should not enable access to locked EVM tokens\", func() {\n+\t\tIt(\"should not enable access to unvested EVM tokens\", func() {\n \t\t\ttestAccount := testAccounts[0]\n \n-\t\t\ttxAmount := vested.AmountOf(stakeDenom).BigInt()\n+\t\t\ttxAmount := vested[0].Amount.Add(amt).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, testAccount.privKey, testAccount.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\tassertEthFails(msg)\n \t\t})\n \t})\n-\n \tContext(\"after half of vesting period and both lockups\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass lockup duration\n-\t\t\tlockupDuration := time.Duration(lockupLength * numLockupPeriods)\n+\t\t\tlockupDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength * numLockupPeriods)\n \t\t\ts.CommitAfter(lockupDuration * time.Second)\n+\t\t\t// after two lockup period\n+\t\t\t// total vesting tokens are unlocked\n+\t\t\t// and 24/48 vesting periods passed\n \n \t\t\t// Check if some, but not all tokens are vested\n-\t\t\tunvested = clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(lockup*numLockupPeriods))))\n-\t\t\ts.Require().NotEqual(vestingAmtTotal, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n+\t\t\tExpect(vestingAmtTotal).NotTo(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vested))\n \t\t})\n \n \t\tIt(\"can delegate vested tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \t\t})\n \n \t\tIt(\"cannot delegate unvested tokens\", func() {\n-\t\t\t_, err := delegate(testAccounts[0], vestingAmtTotal)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testAccounts[0].privKey, vestingAmtTotal[0], s.validator)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n \n@@ -532,7 +655,6 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t)\n \t\t\tExpect(err).To(BeNil())\n \t\t})\n-\n \t\tIt(\"cannot transfer unvested tokens\", func() {\n \t\t\terr := s.app.BankKeeper.SendCoins(\n \t\t\t\ts.ctx,\n@@ -542,63 +664,57 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n \t\t\t)\n \t\t\tExpect(err).ToNot(BeNil())\n \t\t})\n-\n \t\tIt(\"can perform Ethereum tx with spendable balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\n \t\t\ttxAmount := vested.AmountOf(stakeDenom).BigInt()\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount, 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, vested.AmountOf(stakeDenom), stakeDenom, msg)\n \t\t})\n \t})\n-\n \tContext(\"after entire vesting period and both lockups\", func() {\n \t\tBeforeEach(func() {\n \t\t\t// Surpass vest duration\n \t\t\tvestDuration := time.Duration(vestingLength * periodsTotal)\n \t\t\ts.CommitAfter(vestDuration * time.Second)\n \n \t\t\t// Check that all tokens are vested and unlocked\n-\t\t\tunvested = clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tlocked := clawbackAccount.LockedCoins(s.ctx.BlockTime())\n+\t\t\tunvested = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked := clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\tunlockedVested := clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n+\t\t\tnotSpendable := clawbackAccount.LockedCoins(s.ctx.BlockTime())\n+\n+\t\t\t// all vested coins should be unlocked\n+\t\t\tExpect(vested).To(Equal(unlockedVested))\n \n \t\t\tzeroCoins := sdk.NewCoins(sdk.NewCoin(stakeDenom, math.ZeroInt()))\n-\t\t\ts.Require().Equal(vestingAmtTotal, vested)\n-\t\t\ts.Require().Equal(zeroCoins, locked)\n-\t\t\ts.Require().Equal(zeroCoins, unvested)\n+\t\t\tExpect(vestingAmtTotal).To(Equal(vested))\n+\t\t\tExpect(vestingAmtTotal).To(Equal(unlocked))\n+\t\t\tExpect(zeroCoins).To(Equal(notSpendable))\n+\t\t\tExpect(zeroCoins).To(Equal(unvested))\n \t\t})\n \n \t\tIt(\"can send entire balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom)\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthSucceeds([]TestClawbackAccount{account}, funder, dest, txAmount, stakeDenom, msg)\n \t\t})\n-\n \t\tIt(\"cannot exceed balance\", func() {\n \t\t\taccount := testAccounts[0]\n-\n \t\t\ttxAmount := vestingAmtTotal.AmountOf(stakeDenom).Mul(math.NewInt(2))\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, txAmount.BigInt(), 0)\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tassertEthFails(msg)\n \t\t})\n-\n \t\tIt(\"should short-circuit with zero balance\", func() {\n \t\t\taccount := testAccounts[0]\n \t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, account.address, stakeDenom)\n-\n \t\t\t// Drain account balance\n \t\t\terr := s.app.BankKeeper.SendCoins(s.ctx, account.address, dest, sdk.NewCoins(balance))\n \t\t\tExpect(err).To(BeNil())\n-\n \t\t\tmsg, err := utiltx.CreateEthTx(s.ctx, s.app, account.privKey, account.address, dest, big.NewInt(0), 0)\n \t\t\tExpect(err).To(BeNil())\n \t\t\terr = validateEthVestingTransactionDecorator(msg)\n@@ -614,36 +730,6 @@ var _ = Describe(\"Clawback Vesting Accounts\", Ordered, func() {\n // 22/09 Cliff ends\n // 23/02 Lock ends\n var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n-\t// Monthly vesting period\n-\tstakeDenom := utils.BaseDenom\n-\tamt := math.NewInt(1)\n-\tvestingLength := int64(60 * 60 * 24 * 30) // in seconds\n-\tvestingAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt))\n-\tvestingPeriod := sdkvesting.Period{Length: vestingLength, Amount: vestingAmt}\n-\n-\t// 4 years vesting total\n-\tperiodsTotal := int64(48)\n-\tvestingTotal := amt.Mul(math.NewInt(periodsTotal))\n-\tvestingAmtTotal := sdk.NewCoins(sdk.NewCoin(stakeDenom, vestingTotal))\n-\n-\t// 6 month cliff\n-\tcliff := int64(6)\n-\tcliffLength := vestingLength * cliff\n-\tcliffAmt := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(cliff))))\n-\tcliffPeriod := sdkvesting.Period{Length: cliffLength, Amount: cliffAmt}\n-\n-\t// 12 month lockup\n-\tlockup := int64(12) // 12 year\n-\tlockupLength := vestingLength * lockup\n-\tlockupPeriod := sdkvesting.Period{Length: lockupLength, Amount: vestingAmtTotal}\n-\tlockupPeriods := sdkvesting.Periods{lockupPeriod}\n-\n-\t// Create vesting periods with initial cliff\n-\tvestingPeriods := sdkvesting.Periods{cliffPeriod}\n-\tfor p := int64(1); p <= periodsTotal-cliff; p++ {\n-\t\tvestingPeriods = append(vestingPeriods, vestingPeriod)\n-\t}\n-\n \tvar (\n \t\tclawbackAccount *types.ClawbackVestingAccount\n \t\tvesting         sdk.Coins\n@@ -653,12 +739,13 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\tisClawback      bool\n \t)\n \n-\tvestingAddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n+\tvestingAddr, vestingPriv := utiltx.NewAccAddressAndKey()\n \tfunder, funderPriv := utiltx.NewAccAddressAndKey()\n \tdest := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \n \tBeforeEach(func() {\n-\t\ts.SetupTest()\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n+\n \t\tvestingStart := s.ctx.BlockTime()\n \n \t\t// Initialize account at vesting address by funding it with tokens\n@@ -668,46 +755,45 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\terr = s.app.BankKeeper.SendCoins(s.ctx, vestingAddr, funder, vestingAmtTotal)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to send coins to funder\")\n \n+\t\t// Send some tokens to the vesting account to cover tx fees\n+\t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, vestingAddr, accountGasCoverage)\n+\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n+\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\tExpect(balanceFunder).To(Equal(vestingAmtTotal[0]), \"expected different funder balance\")\n-\t\tExpect(balanceGrantee.IsZero()).To(BeTrue(), \"expected balance of vesting account to be zero\")\n+\t\tExpect(balanceGrantee.Amount).To(Equal(accountGasCoverage[0].Amount))\n \t\tExpect(balanceDest.IsZero()).To(BeTrue(), \"expected destination balance to be zero\")\n \n \t\tmsg := types.NewMsgCreateClawbackVestingAccount(funder, vestingAddr, true)\n-\n \t\t_, err = s.app.VestingKeeper.CreateClawbackVestingAccount(sdk.WrapSDKContext(s.ctx), msg)\n \t\tExpect(err).ToNot(HaveOccurred(), \"expected creating clawback vesting account to succeed\")\n-\n \t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\tclawbackAccount, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n-\n \t\t// fund the vesting account\n-\t\tmsgFund := types.NewMsgFundVestingAccount(funder, vestingAddr, vestingStart, lockupPeriods, vestingPeriods)\n+\t\tmsgFund := types.NewMsgFundVestingAccount(funder, vestingAddr, vestingStart, testutil.TestVestingSchedule.LockupPeriods, testutil.TestVestingSchedule.VestingPeriods)\n \t\t_, err = s.app.VestingKeeper.FundVestingAccount(sdk.WrapSDKContext(s.ctx), msgFund)\n \t\tExpect(err).ToNot(HaveOccurred(), \"expected funding vesting account to succeed\")\n-\n \t\tacc = s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\tclawbackAccount, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n \n \t\t// Check if all tokens are unvested and locked at vestingStart\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\tExpect(vesting).To(Equal(vestingAmtTotal), \"expected difference vesting tokens\")\n \t\tExpect(vested.IsZero()).To(BeTrue(), \"expected no tokens to be vested\")\n \t\tExpect(unlocked.IsZero()).To(BeTrue(), \"expected no tokens to be unlocked\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee = s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest = s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\tExpect(bF.IsZero()).To(BeTrue(), \"expected funder balance to be zero\")\n-\t\tExpect(balanceGrantee).To(Equal(vestingAmtTotal[0]), \"expected all tokens to be locked\")\n+\t\tExpect(balanceGrantee).To(Equal(vestingAmtTotal.Add(accountGasCoverage...)[0]), \"expected all tokens to be locked\")\n \t\tExpect(balanceDest.IsZero()).To(BeTrue(), \"expected no tokens to be unlocked\")\n \t})\n \n@@ -716,37 +802,30 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\temptyVestingAddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \t\terr := testutil.FundAccount(s.ctx, s.app.BankKeeper, emptyVestingAddr, vestingAmtTotal)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n-\n \t\tmsg := types.NewMsgCreateClawbackVestingAccount(funder, emptyVestingAddr, false)\n-\n \t\t_, err = s.app.VestingKeeper.CreateClawbackVestingAccount(sdk.WrapSDKContext(s.ctx), msg)\n \t\tExpect(err).ToNot(HaveOccurred(), \"expected creating clawback vesting account to succeed\")\n-\n \t\tclawbackMsg := types.NewMsgClawback(funder, emptyVestingAddr, dest)\n \t\t_, err = s.app.VestingKeeper.Clawback(ctx, clawbackMsg)\n \t\tExpect(err).To(HaveOccurred())\n \t\tExpect(err.Error()).To(ContainSubstring(\"has no vesting or lockup periods\"))\n \t})\n-\n \tIt(\"should claw back unvested amount before cliff\", func() {\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n-\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback before cliff\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t// All initial vesting amount goes to dest\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\tExpect(bF).To(Equal(balanceFunder), \"expected funder balance to be unchanged\")\n-\t\tExpect(bG.IsZero()).To(BeTrue(), \"expected all tokens to be clawed back\")\n+\t\tExpect(bG.Amount).To(Equal(accountGasCoverage[0].Amount), \"expected all tokens to be clawed back\")\n \t\tExpect(bD).To(Equal(balanceDest.Add(vestingAmtTotal[0])), \"expected all tokens to be clawed back to the destination account\")\n \t})\n \n@@ -756,82 +835,78 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\ts.CommitAfter(cliffDuration * time.Second)\n \n \t\t// Check that all tokens are locked and some, but not all tokens are vested\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n-\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\tfree = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\texpVestedAmount := amt.Mul(math.NewInt(cliff))\n \t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\ts.Require().Equal(expVested, vested)\n-\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\ts.Require().True(free.IsZero())\n-\t\ts.Require().Equal(vesting, vestingAmtTotal)\n+\t\tExpect(expVested).To(Equal(vested))\n+\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\tExpect(free.IsZero()).To(BeTrue())\n+\t\tExpect(vesting).To(Equal(vestingAmtTotal.Sub(expVested...)))\n \n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(unvested), \"expected unvested coins to be clawed back\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n-\t\texpClawback := clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n+\t\texpClawback := clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\t// Any unvested amount is clawed back\n-\t\ts.Require().Equal(balanceFunder, bF)\n-\t\ts.Require().Equal(balanceGrantee.Sub(expClawback[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\ts.Require().Equal(balanceDest.Add(expClawback[0]).Amount.Uint64(), bD.Amount.Uint64())\n+\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\tExpect(balanceGrantee.Sub(expClawback[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n+\t\tExpect(balanceDest.Add(expClawback[0]).Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t})\n \n \tIt(\"should claw back any unvested amount after cliff and unlocking\", func() {\n \t\t// Surpass lockup duration\n \t\t// A strict `if t < clawbackTime` comparison is used in ComputeClawback\n \t\t// so, we increment the duration with 1 for the free token calculation to match\n-\t\tlockupDuration := time.Duration(lockupLength + 1)\n+\t\tlockupDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength + 1)\n \t\ts.CommitAfter(lockupDuration * time.Second)\n \n \t\t// Check if some, but not all tokens are vested and unlocked\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\texpVestedAmount := amt.Mul(math.NewInt(lockup))\n \t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\ts.Require().Equal(free, vested)\n-\t\ts.Require().Equal(expVested, vested)\n-\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\ts.Require().Equal(vesting, unvested)\n+\t\tExpect(free).To(Equal(vested))\n+\t\tExpect(expVested).To(Equal(vested))\n+\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\tExpect(vesting).To(Equal(unvested))\n \n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(unvested), \"expected only coins to be clawed back\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t// Any unvested amount is clawed back\n-\t\ts.Require().Equal(balanceFunder, bF)\n-\t\ts.Require().Equal(balanceGrantee.Sub(vesting[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\ts.Require().Equal(balanceDest.Add(vesting[0]).Amount.Uint64(), bD.Amount.Uint64())\n+\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\tExpect(balanceGrantee.Sub(vesting[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n+\t\tExpect(balanceDest.Add(vesting[0]).Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t})\n \n \tIt(\"should not claw back any amount after vesting periods end\", func() {\n@@ -840,46 +915,43 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\ts.CommitAfter(vestingDuration * time.Second)\n \n \t\t// Check if some, but not all tokens are vested and unlocked\n-\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n \t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\ts.Require().Equal(free, vested)\n-\t\ts.Require().Equal(expVested, vested)\n-\t\ts.Require().Equal(expVested, vestingAmtTotal)\n-\t\ts.Require().Equal(unlocked, vestingAmtTotal)\n-\t\ts.Require().Equal(vesting, unvested)\n-\t\ts.Require().True(vesting.IsZero())\n+\t\tExpect(free).To(Equal(vested))\n+\t\tExpect(expVested).To(Equal(vested))\n+\t\tExpect(expVested).To(Equal(vestingAmtTotal))\n+\t\tExpect(unlocked).To(Equal(vestingAmtTotal))\n+\t\tExpect(vesting).To(Equal(unvested))\n+\t\tExpect(vesting.IsZero()).To(BeTrue())\n \n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n-\n \t\t// Perform clawback\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil(), \"expected no error during clawback\")\n \t\tExpect(res).ToNot(BeNil(), \"expected response not to be nil\")\n \t\tExpect(res.Coins).To(BeEmpty(), \"expected nothing to be clawed back\")\n-\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t// No amount is clawed back\n-\t\ts.Require().Equal(balanceFunder, bF)\n-\t\ts.Require().Equal(balanceGrantee, bG)\n-\t\ts.Require().Equal(balanceDest, bD)\n+\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\tExpect(balanceGrantee).To(Equal(bG))\n+\t\tExpect(balanceDest).To(Equal(bD))\n \t})\n \n \tContext(\"while there is an active governance proposal for the vesting account\", func() {\n \t\tvar clawbackProposalID uint64\n-\n \t\tBeforeEach(func() {\n \t\t\t// submit a different proposal to simulate having multiple proposals of different types\n \t\t\t// on chain.\n@@ -893,20 +965,16 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t\ts.address.Bytes(),\n \t\t\t)\n \t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error creating the proposal submission message\")\n-\n \t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, s.priv, nil, msgSubmitProposal)\n \t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during proposal submission\")\n-\n \t\t\t// submit clawback proposal\n \t\t\tgovClawbackProposal := &types.ClawbackProposal{\n \t\t\t\tTitle:              \"test gov clawback\",\n \t\t\t\tDescription:        \"this is an example of a governance proposal to clawback vesting coins\",\n \t\t\t\tAddress:            vestingAddr.String(),\n \t\t\t\tDestinationAddress: funder.String(),\n \t\t\t}\n-\n \t\t\tdeposit := sdk.Coins{sdk.Coin{Denom: stakeDenom, Amount: math.NewInt(1)}}\n-\n \t\t\t// Create the message to submit the proposal\n \t\t\tmsgSubmit, err := govv1beta1.NewMsgSubmitProposal(\n \t\t\t\tgovClawbackProposal, deposit, s.address.Bytes(),\n@@ -915,9 +983,7 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t// deliver the proposal\n \t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, s.priv, nil, msgSubmit)\n \t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during proposal submission\")\n-\n \t\t\ts.Commit()\n-\n \t\t\t// Check if the proposal was submitted\n \t\t\tproposals := s.app.GovKeeper.GetProposals(s.ctx)\n \t\t\tExpect(len(proposals)).To(Equal(2), \"expected two proposals to be found\")\n@@ -926,49 +992,40 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tExpect(proposal.GetTitle()).To(Equal(\"test gov clawback\"), \"expected different proposal title\")\n \t\t\tExpect(proposal.Status).To(Equal(govv1.StatusDepositPeriod), \"expected proposal to be in deposit period\")\n \t\t})\n-\n \t\tContext(\"with deposit made\", func() {\n \t\t\tBeforeEach(func() {\n \t\t\t\tparams := s.app.GovKeeper.GetParams(s.ctx)\n \t\t\t\tdepositAmount := params.MinDeposit[0].Amount.Sub(math.NewInt(1))\n \t\t\t\tdeposit := sdk.Coins{sdk.Coin{Denom: params.MinDeposit[0].Denom, Amount: depositAmount}}\n-\n \t\t\t\t// Deliver the deposit\n \t\t\t\tmsgDeposit := govv1beta1.NewMsgDeposit(s.address.Bytes(), clawbackProposalID, deposit)\n \t\t\t\t_, err := testutil.DeliverTx(s.ctx, s.app, s.priv, nil, msgDeposit)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during proposal deposit\")\n-\n \t\t\t\ts.Commit()\n-\n \t\t\t\t// Check the proposal is in voting period\n \t\t\t\tproposal, found := s.app.GovKeeper.GetProposal(s.ctx, clawbackProposalID)\n \t\t\t\tExpect(found).To(BeTrue(), \"expected proposal to be found\")\n \t\t\t\tExpect(proposal.Status).To(Equal(govv1.StatusVotingPeriod), \"expected proposal to be in voting period\")\n-\n \t\t\t\t// Check the store entry was set correctly\n \t\t\t\thasActivePropposal := s.app.VestingKeeper.HasActiveClawbackProposal(s.ctx, vestingAddr)\n \t\t\t\tExpect(hasActivePropposal).To(BeTrue(), \"expected an active clawback proposal for the vesting account\")\n \t\t\t})\n-\n \t\t\tIt(\"should not allow clawback\", func() {\n \t\t\t\t// Try to clawback tokens\n \t\t\t\tmsgClawback := types.NewMsgClawback(funder, vestingAddr, dest)\n \t\t\t\t_, err = s.app.VestingKeeper.Clawback(sdk.WrapSDKContext(s.ctx), msgClawback)\n \t\t\t\tExpect(err).To(HaveOccurred(), \"expected error during clawback while there is an active governance proposal\")\n \t\t\t\tExpect(err.Error()).To(ContainSubstring(\"clawback is disabled while there is an active clawback proposal\"))\n-\n \t\t\t\t// Check that the clawback was not performed\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback := acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n-\n \t\t\t\tbalances, err := s.app.VestingKeeper.Balances(s.ctx, &types.QueryBalancesRequest{\n \t\t\t\t\tAddress: vestingAddr.String(),\n \t\t\t\t})\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during balances query\")\n \t\t\t\tExpect(balances.Unvested).To(Equal(vestingAmtTotal), \"expected no tokens to be clawed back\")\n-\n \t\t\t\t// Delegate some funds to the suite validators in order to vote on proposal with enough voting power\n \t\t\t\t// using only the suite private key\n \t\t\t\tpriv, ok := s.priv.(*ethsecp256k1.PrivKey)\n@@ -981,39 +1038,32 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during delegation\")\n \t\t\t\t\tExpect(res.Code).To(BeZero(), \"expected delegation to succeed\")\n \t\t\t\t}\n-\n \t\t\t\t// Vote on proposal\n \t\t\t\tres, err := testutil.Vote(s.ctx, s.app, priv, clawbackProposalID, govv1beta1.OptionYes)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to vote on proposal %d\", clawbackProposalID)\n \t\t\t\tExpect(res.Code).To(BeZero(), \"expected proposal voting to succeed\")\n-\n \t\t\t\t// Check that the funds are clawed back after the proposal has ended\n \t\t\t\ts.CommitAfter(time.Hour * 24 * 365) // one year\n \t\t\t\t// Commit again because EndBlocker is run with time of the previous block and gov proposals are ended in EndBlocker\n \t\t\t\ts.Commit()\n-\n \t\t\t\t// Check that proposal has passed\n \t\t\t\tproposal, found := s.app.GovKeeper.GetProposal(s.ctx, clawbackProposalID)\n \t\t\t\tExpect(found).To(BeTrue(), \"expected proposal to exist\")\n \t\t\t\tExpect(proposal.Status).ToNot(Equal(govv1.StatusVotingPeriod), \"expected proposal to not be in voting period anymore\")\n \t\t\t\tExpect(proposal.Status).To(Equal(govv1.StatusPassed), \"expected proposal to have passed\")\n-\n \t\t\t\t// Check that the account was converted to a normal account\n \t\t\t\tacc = s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeFalse(), \"expected account to be a normal account\")\n-\n \t\t\t\thasActiveProposal := s.app.VestingKeeper.HasActiveClawbackProposal(s.ctx, vestingAddr)\n \t\t\t\tExpect(hasActiveProposal).To(BeFalse(), \"expected no active clawback proposal\")\n \t\t\t})\n-\n \t\t\tIt(\"should not allow changing the vesting funder\", func() {\n \t\t\t\tmsgUpdateFunder := types.NewMsgUpdateVestingFunder(funder, dest, vestingAddr)\n \t\t\t\t_, err = s.app.VestingKeeper.UpdateVestingFunder(sdk.WrapSDKContext(s.ctx), msgUpdateFunder)\n \t\t\t\tExpect(err).To(HaveOccurred(), \"expected error during update funder while there is an active governance proposal\")\n \t\t\t\tExpect(err.Error()).To(ContainSubstring(\"cannot update funder while there is an active clawback proposal\"))\n-\n \t\t\t\t// Check that the funder was not updated\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n@@ -1022,48 +1072,39 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t\tExpect(clawbackAcc.FunderAddress).To(Equal(funder.String()), \"expected funder to be unchanged\")\n \t\t\t})\n \t\t})\n-\n \t\tContext(\"without deposit made\", func() {\n \t\t\tIt(\"allows clawback and changing the funder before the deposit period ends\", func() {\n \t\t\t\tnewFunder, newPriv := utiltx.NewAccAddressAndKey()\n-\n \t\t\t\t// fund accounts\n \t\t\t\terr = testutil.FundAccountWithBaseDenom(s.ctx, s.app.BankKeeper, newFunder, 5e18)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n \t\t\t\terr = testutil.FundAccountWithBaseDenom(s.ctx, s.app.BankKeeper, funder, 5e18)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund target account\")\n-\n \t\t\t\tmsgUpdateFunder := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, funderPriv, nil, msgUpdateFunder)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during update funder while there is an active governance proposal\")\n-\n \t\t\t\t// Check that the funder was updated\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback := acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeTrue(), \"expected account to be clawback vesting account\")\n-\n \t\t\t\t// Claw back tokens\n \t\t\t\tmsgClawback := types.NewMsgClawback(newFunder, vestingAddr, funder)\n \t\t\t\t_, err = testutil.DeliverTx(s.ctx, s.app, newPriv, nil, msgClawback)\n \t\t\t\tExpect(err).ToNot(HaveOccurred(), \"expected no error during clawback while there is no deposit made\")\n-\n \t\t\t\t// Check account is converted to a normal account\n \t\t\t\tacc = s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tExpect(acc).ToNot(BeNil(), \"expected account to exist\")\n \t\t\t\t_, isClawback = acc.(*types.ClawbackVestingAccount)\n \t\t\t\tExpect(isClawback).To(BeFalse(), \"expected account to be a normal account\")\n \t\t\t})\n-\n \t\t\tIt(\"should remove the store entry after the deposit period ends\", func() {\n \t\t\t\ts.CommitAfter(time.Hour * 24 * 365) // one year\n \t\t\t\t// Commit again because EndBlocker is run with time of the previous block and gov proposals are ended in EndBlocker\n \t\t\t\ts.Commit()\n-\n \t\t\t\t// Check that the proposal has ended -- since deposit failed it's removed from the store\n \t\t\t\t_, found := s.app.GovKeeper.GetProposal(s.ctx, clawbackProposalID)\n \t\t\t\tExpect(found).To(BeFalse(), \"expected proposal not to be found\")\n-\n \t\t\t\t// Check that the store entry was removed\n \t\t\t\thasActiveProposal := s.app.VestingKeeper.HasActiveClawbackProposal(s.ctx, vestingAddr)\n \t\t\t\tExpect(hasActiveProposal).To(BeFalse(),\n@@ -1073,97 +1114,88 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\t})\n \t\t})\n \t})\n-\n \tIt(\"should update vesting funder and claw back unvested amount before cliff\", func() {\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tnewFunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceNewFunder := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n-\n \t\t// Update clawback vesting account funder\n \t\tupdateFunderMsg := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t_, err := s.app.VestingKeeper.UpdateVestingFunder(ctx, updateFunderMsg)\n-\t\ts.Require().NoError(err)\n+\t\tExpect(err).To(BeNil())\n \n \t\t// Perform clawback before cliff - funds should go to new funder (no dest address defined)\n \t\tmsg := types.NewMsgClawback(newFunder, vestingAddr, sdk.AccAddress([]byte{}))\n \t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\tExpect(err).To(BeNil())\n \t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t// All initial vesting amount goes to funder\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbNewF := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \n \t\t// Original funder balance should not change\n-\t\ts.Require().Equal(bF, balanceFunder)\n+\t\tExpect(bF).To(Equal(balanceFunder))\n \t\t// New funder should get the vested tokens\n-\t\ts.Require().Equal(balanceNewFunder.Add(vestingAmtTotal[0]).Amount.Uint64(), bNewF.Amount.Uint64())\n-\t\ts.Require().Equal(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64(), bG.Amount.Uint64())\n+\t\tExpect(balanceNewFunder.Add(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bNewF.Amount.Uint64()))\n+\t\tExpect(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n \t})\n \n \tIt(\"should update vesting funder and first funder cannot claw back unvested before cliff\", func() {\n \t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\tnewFunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\n \t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbalanceNewFunder := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n-\n \t\t// Update clawback vesting account funder\n \t\tupdateFunderMsg := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t_, err := s.app.VestingKeeper.UpdateVestingFunder(ctx, updateFunderMsg)\n-\t\ts.Require().NoError(err)\n+\t\tExpect(err).To(BeNil())\n \n \t\t// Original funder tries to perform clawback before cliff - is not the current funder\n \t\tmsg := types.NewMsgClawback(funder, vestingAddr, sdk.AccAddress([]byte{}))\n \t\t_, err = s.app.VestingKeeper.Clawback(ctx, msg)\n-\t\ts.Require().Error(err)\n+\t\tExpect(err).NotTo(BeNil())\n \n \t\t// All balances should remain the same\n \t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\tbNewF := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \n-\t\ts.Require().Equal(bF, balanceFunder)\n-\t\ts.Require().Equal(balanceNewFunder, bNewF)\n-\t\ts.Require().Equal(balanceGrantee, bG)\n+\t\tExpect(bF).To(Equal(balanceFunder))\n+\t\tExpect(balanceNewFunder).To(Equal(bNewF))\n+\t\tExpect(balanceGrantee).To(Equal(bG))\n \t})\n \n \tContext(\"governance clawback to community pool\", func() {\n \t\tIt(\"should claw back unvested amount before cliff\", func() {\n \t\t\tctx := sdk.WrapSDKContext(s.ctx)\n-\n \t\t\t// initial balances\n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n-\n \t\t\t// Perform clawback before cliff\n \t\t\tmsg := types.NewMsgClawback(authtypes.NewModuleAddress(govtypes.ModuleName), vestingAddr, dest)\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t\t// All initial vesting amount goes to community pool instead of dest\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool = s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbCP := pool.CommunityPool[0]\n \n-\t\t\ts.Require().Equal(bF, balanceFunder)\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64(), bG.Amount.Uint64())\n+\t\t\tExpect(bF).To(Equal(balanceFunder))\n+\t\t\tExpect(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n \t\t\t// destination address should remain unchanged\n-\t\t\ts.Require().Equal(balanceDest.Amount.Uint64(), bD.Amount.Uint64())\n+\t\t\tExpect(balanceDest.Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t\t\t// vesting amount should go to community pool\n-\t\t\ts.Require().Equal(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64())), bCP.Amount)\n-\t\t\ts.Require().Equal(stakeDenom, bCP.Denom)\n+\t\t\tExpect(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64()))).To(Equal(bCP.Amount))\n+\t\t\tExpect(stakeDenom).To(Equal(bCP.Denom))\n \t\t})\n \n \t\tIt(\"should claw back any unvested amount after cliff before unlocking\", func() {\n@@ -1172,32 +1204,31 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\ts.CommitAfter(cliffDuration * time.Second)\n \n \t\t\t// Check that all tokens are locked and some, but not all tokens are vested\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n-\t\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n+\t\t\tfree = clawbackAccount.GetUnlockedVestedCoins(s.ctx.BlockTime())\n \t\t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\t\texpVestedAmount := amt.Mul(math.NewInt(cliff))\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\t\ts.Require().True(free.IsZero())\n-\t\t\ts.Require().Equal(vesting, vestingAmtTotal)\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\t\tExpect(free.IsZero()).To(BeTrue())\n+\t\t\tExpect(vesting).To(Equal(vestingAmtTotal.Sub(expVested...)))\n \n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n-\t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n \n \t\t\ttestClawbackAccount := TestClawbackAccount{\n-\t\t\t\tprivKey:         nil,\n+\t\t\t\tprivKey:         vestingPriv,\n \t\t\t\taddress:         vestingAddr,\n \t\t\t\tclawbackAccount: clawbackAccount,\n \t\t\t}\n \t\t\t// stake vested tokens\n-\t\t\t_, err := delegate(testClawbackAccount, vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testClawbackAccount.privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback\n@@ -1206,56 +1237,65 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(unvested), \"expected unvested coins to be clawed back\")\n-\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool = s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbCP := pool.CommunityPool[0]\n \n-\t\t\texpClawback := clawbackAccount.GetUnvestedOnly(s.ctx.BlockTime())\n+\t\t\texpClawback := clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\t\t// Any unvested amount is clawed back to community pool\n-\t\t\ts.Require().Equal(balanceFunder, bF)\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(expClawback[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\t\ts.Require().Equal(balanceDest.Amount.Uint64(), bD.Amount.Uint64())\n+\t\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\t\t// grantee balance should be zero because delegated all unvested tokens\n+\t\t\tExpect(bG.Amount).To(Equal(math.ZeroInt()))\n+\t\t\tExpect(balanceDest.Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n \t\t\t// vesting amount should go to community pool\n-\t\t\ts.Require().Equal(balanceCommPool.Amount.Add(math.LegacyNewDec(expClawback[0].Amount.Int64())), bCP.Amount)\n-\t\t\ts.Require().Equal(stakeDenom, bCP.Denom)\n+\t\t\tExpect(balanceCommPool.Amount.Add(math.LegacyNewDec(expClawback[0].Amount.Int64()))).To(Equal(bCP.Amount))\n+\t\t\tExpect(stakeDenom).To(Equal(bCP.Denom))\n+\n+\t\t\t// check delegation was not clawed back\n+\t\t\tqueryHelper := baseapp.NewQueryServerTestHelper(s.ctx, s.app.InterfaceRegistry())\n+\t\t\tquerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tstakingtypes.RegisterQueryServer(queryHelper, querier)\n+\t\t\tqc := stakingtypes.NewQueryClient(queryHelper)\n+\t\t\tdelRes, err := qc.Delegation(s.ctx, &stakingtypes.QueryDelegationRequest{DelegatorAddr: vestingAddr.String(), ValidatorAddr: s.validator.OperatorAddress})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponse).NotTo(BeNil())\n+\t\t\tExpect(delRes.DelegationResponse.Balance).To(Equal(vested[0]))\n \t\t})\n \n \t\tIt(\"should claw back any unvested amount after cliff and unlocking\", func() {\n \t\t\t// Surpass lockup duration\n \t\t\t// A strict `if t < clawbackTime` comparison is used in ComputeClawback\n \t\t\t// so, we increment the duration with 1 for the free token calculation to match\n-\t\t\tlockupDuration := time.Duration(lockupLength + 1)\n+\t\t\tlockupDuration := time.Duration(testutil.TestVestingSchedule.LockupPeriodLength + 1)\n \t\t\ts.CommitAfter(lockupDuration * time.Second)\n \n \t\t\t// Check if some, but not all tokens are vested and unlocked\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \t\t\texpVestedAmount := amt.Mul(math.NewInt(lockup))\n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, expVestedAmount))\n \t\t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\t\ts.Require().Equal(free, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().True(expVestedAmount.GT(math.NewInt(0)))\n-\t\t\ts.Require().Equal(vesting, unvested)\n+\t\t\tExpect(free).To(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expVestedAmount.GT(math.NewInt(0))).To(BeTrue())\n+\t\t\tExpect(vesting).To(Equal(unvested))\n \n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n-\t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t\ttestClawbackAccount := TestClawbackAccount{\n-\t\t\t\tprivKey:         nil,\n+\t\t\t\tprivKey:         vestingPriv,\n \t\t\t\taddress:         vestingAddr,\n \t\t\t\tclawbackAccount: clawbackAccount,\n \t\t\t}\n \t\t\t// stake vested tokens\n-\t\t\t_, err := delegate(testClawbackAccount, vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testClawbackAccount.privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback\n@@ -1264,15 +1304,22 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(unvested), \"expected only unvested coins to be clawed back\")\n-\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \n \t\t\t// Any unvested amount is clawed back\n-\t\t\ts.Require().Equal(balanceFunder, bF)\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(vesting[0]).Amount.Uint64(), bG.Amount.Uint64())\n-\t\t\ts.Require().Equal(balanceDest.Add(vesting[0]).Amount.Uint64(), bD.Amount.Uint64())\n+\t\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\t\t// final grantee balance should be 0 because delegated all the vested amt\n+\t\t\tExpect(bG.Amount).To(Equal(math.ZeroInt()))\n+\t\t\tExpect(balanceDest.Add(vesting[0]).Amount.Uint64()).To(Equal(bD.Amount.Uint64()))\n+\n+\t\t\t// check delegated tokens were not clawed back\n+\t\t\tstkQuerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tdelRes, err := stkQuerier.DelegatorDelegations(s.ctx, &stakingtypes.QueryDelegatorDelegationsRequest{DelegatorAddr: vestingAddr.String()})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponses).To(HaveLen(1))\n+\t\t\tExpect(delRes.DelegationResponses[0].Balance.Amount).To(Equal(vested[0].Amount))\n \t\t})\n \n \t\tIt(\"should not claw back any amount after vesting periods end\", func() {\n@@ -1281,34 +1328,33 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\ts.CommitAfter(vestingDuration * time.Second)\n \n \t\t\t// Check if some, but not all tokens are vested and unlocked\n-\t\t\tvested = clawbackAccount.GetVestedOnly(s.ctx.BlockTime())\n-\t\t\tunlocked = clawbackAccount.GetUnlockedOnly(s.ctx.BlockTime())\n+\t\t\tvested = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n+\t\t\tunlocked = clawbackAccount.GetUnlockedCoins(s.ctx.BlockTime())\n \t\t\tfree = clawbackAccount.GetVestedCoins(s.ctx.BlockTime())\n \t\t\tvesting = clawbackAccount.GetVestingCoins(s.ctx.BlockTime())\n \n \t\t\texpVested := sdk.NewCoins(sdk.NewCoin(stakeDenom, amt.Mul(math.NewInt(periodsTotal))))\n \t\t\tunvested := vestingAmtTotal.Sub(vested...)\n \n-\t\t\ts.Require().Equal(free, vested)\n-\t\t\ts.Require().Equal(expVested, vested)\n-\t\t\ts.Require().Equal(expVested, vestingAmtTotal)\n-\t\t\ts.Require().Equal(unlocked, vestingAmtTotal)\n-\t\t\ts.Require().Equal(vesting, unvested)\n-\t\t\ts.Require().True(vesting.IsZero())\n+\t\t\tExpect(free).To(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vested))\n+\t\t\tExpect(expVested).To(Equal(vestingAmtTotal))\n+\t\t\tExpect(unlocked).To(Equal(vestingAmtTotal))\n+\t\t\tExpect(vesting).To(Equal(unvested))\n+\t\t\tExpect(vesting.IsZero()).To(BeTrue())\n \n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n-\t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbalanceDest := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n \n \t\t\ttestClawbackAccount := TestClawbackAccount{\n-\t\t\t\tprivKey:         nil,\n+\t\t\t\tprivKey:         vestingPriv,\n \t\t\t\taddress:         vestingAddr,\n \t\t\t\tclawbackAccount: clawbackAccount,\n \t\t\t}\n \t\t\t// stake vested tokens\n-\t\t\t_, err := delegate(testClawbackAccount, vested)\n+\t\t\t_, err := testutil.Delegate(s.ctx, s.app, testClawbackAccount.privKey, vested[0], s.validator)\n \t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback\n@@ -1317,41 +1363,44 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil(), \"expected no error during clawback\")\n \t\t\tExpect(res.Coins).To(BeEmpty(), \"expected nothing to be clawed back after end of vesting schedules\")\n-\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbG := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tbD := s.app.BankKeeper.GetBalance(s.ctx, dest, stakeDenom)\n \t\t\tpool = s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbCP := pool.CommunityPool[0]\n \n \t\t\t// No amount is clawed back\n-\t\t\ts.Require().Equal(balanceFunder, bF)\n-\t\t\ts.Require().Equal(balanceGrantee, bG)\n-\t\t\ts.Require().Equal(balanceDest, bD)\n-\t\t\ts.Require().Equal(balanceCommPool.Amount, bCP.Amount)\n+\t\t\tExpect(balanceFunder).To(Equal(bF))\n+\t\t\t// final grantee balance should be 0 because delegated all the vested amt\n+\t\t\tExpect(bG.Amount).To(Equal(math.ZeroInt()))\n+\t\t\tExpect(balanceDest).To(Equal(bD))\n+\t\t\tExpect(balanceCommPool.Amount).To(Equal(bCP.Amount))\n+\t\t\t// check delegated tokens were not clawed back\n+\t\t\tstkQuerier := stakingkeeper.Querier{Keeper: s.app.StakingKeeper.Keeper}\n+\t\t\tdelRes, err := stkQuerier.DelegatorDelegations(s.ctx, &stakingtypes.QueryDelegatorDelegationsRequest{DelegatorAddr: vestingAddr.String()})\n+\t\t\tExpect(err).To(BeNil())\n+\t\t\tExpect(delRes.DelegationResponses).To(HaveLen(1))\n+\t\t\tExpect(delRes.DelegationResponses[0].Balance.Amount).To(Equal(vested[0].Amount))\n \t\t})\n \n \t\tIt(\"should update vesting funder and claw back unvested amount before cliff\", func() {\n \t\t\tctx := sdk.WrapSDKContext(s.ctx)\n \t\t\tnewFunder := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\n \t\t\tbalanceFunder := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbalanceNewFunder := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n \t\t\tbalanceGrantee := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, stakeDenom)\n \t\t\tpool := s.app.DistrKeeper.GetFeePool(s.ctx)\n \t\t\tbalanceCommPool := pool.CommunityPool[0]\n-\n \t\t\t// Update clawback vesting account funder\n \t\t\tupdateFunderMsg := types.NewMsgUpdateVestingFunder(funder, newFunder, vestingAddr)\n \t\t\t_, err := s.app.VestingKeeper.UpdateVestingFunder(ctx, updateFunderMsg)\n-\t\t\ts.Require().NoError(err)\n+\t\t\tExpect(err).To(BeNil())\n \n \t\t\t// Perform clawback before cliff - funds should go to new funder (no dest address defined)\n \t\t\tmsg := types.NewMsgClawback(authtypes.NewModuleAddress(govtypes.ModuleName), vestingAddr, nil)\n \t\t\tres, err := s.app.VestingKeeper.Clawback(ctx, msg)\n \t\t\tExpect(err).To(BeNil())\n \t\t\tExpect(res.Coins).To(Equal(vestingAmtTotal), \"expected different coins to be clawed back\")\n-\n \t\t\t// All initial vesting amount goes to funder\n \t\t\tbF := s.app.BankKeeper.GetBalance(s.ctx, funder, stakeDenom)\n \t\t\tbNewF := s.app.BankKeeper.GetBalance(s.ctx, newFunder, stakeDenom)\n@@ -1360,18 +1409,17 @@ var _ = Describe(\"Clawback Vesting Accounts - claw back tokens\", func() {\n \t\t\tbCP := pool.CommunityPool[0]\n \n \t\t\t// Original funder balance should not change\n-\t\t\ts.Require().Equal(bF, balanceFunder)\n+\t\t\tExpect(bF).To(Equal(balanceFunder))\n \t\t\t// New funder should not get the vested tokens\n-\t\t\ts.Require().Equal(balanceNewFunder.Amount.Uint64(), bNewF.Amount.Uint64())\n-\t\t\ts.Require().Equal(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64(), bG.Amount.Uint64())\n+\t\t\tExpect(balanceNewFunder.Amount.Uint64()).To(Equal(bNewF.Amount.Uint64()))\n+\t\t\tExpect(balanceGrantee.Sub(vestingAmtTotal[0]).Amount.Uint64()).To(Equal(bG.Amount.Uint64()))\n \t\t\t// vesting amount should go to community pool\n-\t\t\ts.Require().Equal(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64())), bCP.Amount)\n+\t\t\tExpect(balanceCommPool.Amount.Add(math.LegacyNewDec(vestingAmtTotal[0].Amount.Int64()))).To(Equal(bCP.Amount))\n \t\t})\n \n \t\tIt(\"should not claw back when governance clawback is disabled\", func() {\n \t\t\t// disable governance clawback\n \t\t\ts.app.VestingKeeper.SetGovClawbackDisabled(s.ctx, vestingAddr)\n-\n \t\t\t// Perform clawback before cliff\n \t\t\tmsg := types.NewMsgClawback(authtypes.NewModuleAddress(govtypes.ModuleName), vestingAddr, dest)\n \t\t\t_, err := s.app.VestingKeeper.Clawback(s.ctx, msg)\n@@ -1395,6 +1443,7 @@ var _ = Describe(\"Clawback Vesting Account - Smart contract\", func() {\n \t)\n \n \tBeforeEach(func() {\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n \t\tcontract = contracts.ERC20MinterBurnerDecimalsContract\n \t\tcontractAddr, err = testutil.DeployContract(\n \t\t\ts.ctx,\n@@ -1406,7 +1455,6 @@ var _ = Describe(\"Clawback Vesting Account - Smart contract\", func() {\n \t\t)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to deploy contract\")\n \t})\n-\n \tIt(\"should not convert a smart contract to a clawback vesting account\", func() {\n \t\tmsgCreate := types.NewMsgCreateClawbackVestingAccount(\n \t\t\ts.address.Bytes(),\n@@ -1420,13 +1468,11 @@ var _ = Describe(\"Clawback Vesting Account - Smart contract\", func() {\n \t\t\t\t\"account %s is a contract account and cannot be converted in a clawback vesting account\",\n \t\t\t\tsdk.AccAddress(contractAddr.Bytes()).String()),\n \t\t))\n-\n \t\t// Check that the account was not converted\n \t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, contractAddr.Bytes())\n \t\tExpect(acc).ToNot(BeNil(), \"smart contract should be found\")\n \t\t_, ok := acc.(*types.ClawbackVestingAccount)\n \t\tExpect(ok).To(BeFalse(), \"account should not be a clawback vesting account\")\n-\n \t\t// Check that the contract code was not deleted\n \t\t//\n \t\t// NOTE: When it was possible to create clawback vesting accounts for smart contracts,\n@@ -1475,39 +1521,34 @@ var _ = Describe(\"Clawback Vesting Account - Barberry bug\", func() {\n \t\t// vestingLength is a period of time in seconds to be used for the creation of the vesting\n \t\t// account.\n \t\tvestingLength = int64(60 * 60 * 24 * 30) // 30 days in seconds\n-\n \t\t// txCost is the cost of a transaction to be deducted from the expected account balance\n \t\ttxCost int64\n \t)\n \n \tBeforeEach(func() {\n-\t\ts.SetupTest()\n+\t\tExpect(s.SetupTest()).To(BeNil()) // reset\n \n \t\t// Initialize the account at the vesting address and the funder accounts by funding them\n \t\tfundedCoins := sdk.Coins{{Denom: utils.BaseDenom, Amount: math.NewInt(2e18)}} // fund more than what is sent to the vesting account for transaction fees\n \t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, vestingAddr, fundedCoins)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund account\")\n \t\terr = testutil.FundAccount(s.ctx, s.app.BankKeeper, funder, fundedCoins)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund account\")\n-\n \t\t// Create a clawback vesting account\n \t\tmsgCreate := types.NewMsgCreateClawbackVestingAccount(\n \t\t\tfunder,\n \t\t\tvestingAddr,\n \t\t\tfalse,\n \t\t)\n-\n \t\tres, err := testutil.DeliverTx(s.ctx, s.app, vestingPriv, &gasPrice, msgCreate)\n \t\tExpect(err).ToNot(HaveOccurred(), \"failed to create clawback vesting account\")\n \t\ttxCost = gasPrice.Int64() * res.GasWanted\n-\n \t\t// Check clawback acccount was created\n \t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\tExpect(acc).ToNot(BeNil(), \"clawback vesting account not created\")\n \t\t_, ok := acc.(*types.ClawbackVestingAccount)\n \t\tExpect(ok).To(BeTrue(), \"account is not a clawback vesting account\")\n \t})\n-\n \tContext(\"when funding a clawback vesting account\", func() {\n \t\ttestcases := []struct {\n \t\t\tname         string\n@@ -1564,27 +1605,23 @@ var _ = Describe(\"Clawback Vesting Account - Barberry bug\", func() {\n \t\t\t\terrContains:  \"vesting and/or lockup schedules must be present\",\n \t\t\t},\n \t\t}\n-\n \t\tfor _, tc := range testcases {\n \t\t\ttc := tc\n \t\t\tIt(tc.name, func() {\n \t\t\t\tvar (\n \t\t\t\t\tlockupPeriods  sdkvesting.Periods\n \t\t\t\t\tvestingPeriods sdkvesting.Periods\n \t\t\t\t)\n-\n \t\t\t\tif !tc.lockupCoins.Empty() {\n \t\t\t\t\tlockupPeriods = sdkvesting.Periods{\n \t\t\t\t\t\tsdkvesting.Period{Length: vestingLength, Amount: tc.lockupCoins},\n \t\t\t\t\t}\n \t\t\t\t}\n-\n \t\t\t\tif !tc.vestingCoins.Empty() {\n \t\t\t\t\tvestingPeriods = sdkvesting.Periods{\n \t\t\t\t\t\tsdkvesting.Period{Length: vestingLength, Amount: tc.vestingCoins},\n \t\t\t\t\t}\n \t\t\t\t}\n-\n \t\t\t\t// Fund the clawback vesting account at the given address\n \t\t\t\tmsg := types.NewMsgFundVestingAccount(\n \t\t\t\t\tfunder,\n@@ -1593,24 +1630,19 @@ var _ = Describe(\"Clawback Vesting Account - Barberry bug\", func() {\n \t\t\t\t\tlockupPeriods,\n \t\t\t\t\tvestingPeriods,\n \t\t\t\t)\n-\n \t\t\t\t// Deliver transaction with message\n \t\t\t\tres, err := testutil.DeliverTx(s.ctx, s.app, funderPriv, nil, msg)\n-\n \t\t\t\t// Get account at the new address\n \t\t\t\tacc := s.app.AccountKeeper.GetAccount(s.ctx, vestingAddr)\n \t\t\t\tvacc, _ := acc.(*types.ClawbackVestingAccount)\n-\n \t\t\t\tif tc.expError {\n \t\t\t\t\tExpect(err).To(HaveOccurred(), \"expected funding the vesting account to have failed\")\n \t\t\t\t\tExpect(err.Error()).To(ContainSubstring(tc.errContains), \"expected funding the vesting account to have failed\")\n-\n \t\t\t\t\tExpect(vacc.LockupPeriods).To(BeEmpty(), \"expected clawback vesting account to not have been funded\")\n \t\t\t\t} else {\n \t\t\t\t\tExpect(err).ToNot(HaveOccurred(), \"failed to fund clawback vesting account\")\n \t\t\t\t\tExpect(res.Code).To(Equal(uint32(0)), \"failed to fund clawback vesting account\")\n \t\t\t\t\tExpect(vacc.LockupPeriods).ToNot(BeEmpty(), \"vesting account should have been funded\")\n-\n \t\t\t\t\t// Check that the vesting account has the correct balance\n \t\t\t\t\tbalance := s.app.BankKeeper.GetBalance(s.ctx, vestingAddr, utils.BaseDenom)\n \t\t\t\t\texpBalance := int64(2e18) + int64(1e18) - txCost // fundedCoins + vestingCoins - txCost"
        },
        {
          "filename": "x/vesting/keeper/migrations.go",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -6,9 +6,13 @@ import (\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \t\"github.com/cosmos/cosmos-sdk/types/module\"\n \tv2 \"github.com/evmos/evmos/v18/x/vesting/migrations/v2\"\n+\tv3 \"github.com/evmos/evmos/v18/x/vesting/migrations/v3\"\n )\n \n-var _ module.MigrationHandler = Migrator{}.Migrate1to2\n+var (\n+\t_ module.MigrationHandler = Migrator{}.Migrate1to2\n+\t_ module.MigrationHandler = Migrator{}.Migrate2to3\n+)\n \n // Migrator is a struct for handling in-place store migrations.\n type Migrator struct {\n@@ -26,3 +30,8 @@ func NewMigrator(keeper Keeper) Migrator {\n func (m Migrator) Migrate1to2(ctx sdk.Context) error {\n \treturn v2.MigrateStore(ctx, m.keeper.accountKeeper)\n }\n+\n+// Migrate2to3 migrates the store from consensus version 2 to 3\n+func (m Migrator) Migrate2to3(ctx sdk.Context) error {\n+\treturn v3.MigrateStore(ctx, m.keeper.accountKeeper)\n+}"
        },
        {
          "filename": "x/vesting/keeper/migrations_test.go",
          "status": "modified",
          "additions": 90,
          "deletions": 2,
          "patch": "@@ -3,6 +3,7 @@ package keeper_test\n import (\n \t\"time\"\n \n+\t\"github.com/cosmos/cosmos-sdk/types\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n \tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n \ttestutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n@@ -11,8 +12,10 @@ import (\n \tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n )\n \n-func (suite *KeeperTestSuite) TestMigration() {\n-\tsuite.SetupTest()\n+func (suite *KeeperTestSuite) TestMigrate1to2() {\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n \n \t// Create account addresses for testing\n \tvestingAddr, _ := testutiltx.NewAccAddressAndKey()\n@@ -45,3 +48,88 @@ func (suite *KeeperTestSuite) TestMigration() {\n \tsuite.Require().NotNil(foundAcc, \"vesting account not found\")\n \tsuite.Require().IsType(&vestingtypes.ClawbackVestingAccount{}, foundAcc, \"vesting account is not a v2 base vesting account\")\n }\n+\n+func (suite *KeeperTestSuite) TestMigrate2to3() {\n+\tvar emtpyCoins types.Coins\n+\tif err := suite.SetupTest(); err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\t// Create account addresses for testing\n+\tvestingAddr, _ := testutiltx.NewAccAddressAndKey()\n+\tfunder, _ := testutiltx.NewAccAddressAndKey()\n+\n+\t// create a base vesting account instead of a clawback vesting account at the vesting address\n+\tbaseAccount := authtypes.NewBaseAccountWithAddress(vestingAddr)\n+\tacc := sdkvesting.NewBaseVestingAccount(baseAccount, balances, 500000)\n+\n+\ttestCases := []struct {\n+\t\tname                    string\n+\t\tinitialDelegatedVesting types.Coins\n+\t\tinitialDelegatedFree    types.Coins\n+\t\texpectedDelegatedFree   types.Coins\n+\t}{\n+\t\t{\n+\t\t\tname:                    \"delegated vesting > 0 and delegated free == 0\",\n+\t\t\tinitialDelegatedVesting: quarter,\n+\t\t\tinitialDelegatedFree:    emtpyCoins,\n+\t\t\texpectedDelegatedFree:   quarter,\n+\t\t},\n+\t\t{\n+\t\t\tname:                    \"delegated vesting > 0 and delegated free > 0\",\n+\t\t\tinitialDelegatedVesting: quarter,\n+\t\t\tinitialDelegatedFree:    quarter,\n+\t\t\texpectedDelegatedFree:   types.NewCoins(types.NewInt64Coin(\"test\", 500)),\n+\t\t},\n+\t\t{\n+\t\t\tname:                    \"delegated vesting == 0 and delegated free > 0\",\n+\t\t\tinitialDelegatedVesting: emtpyCoins,\n+\t\t\tinitialDelegatedFree:    quarter,\n+\t\t\texpectedDelegatedFree:   quarter,\n+\t\t},\n+\t\t{\n+\t\t\tname:                    \"delegated vesting == 0 and delegated free == 0\",\n+\t\t\tinitialDelegatedVesting: emtpyCoins,\n+\t\t\tinitialDelegatedFree:    emtpyCoins,\n+\t\t\texpectedDelegatedFree:   emtpyCoins,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tsuite.Run(tc.name, func() {\n+\t\t\tacc.DelegatedVesting = tc.initialDelegatedVesting\n+\t\t\tacc.DelegatedFree = tc.initialDelegatedFree\n+\n+\t\t\tvestAcc := &vestingtypes.ClawbackVestingAccount{\n+\t\t\t\tBaseVestingAccount: acc,\n+\t\t\t\tFunderAddress:      funder.String(),\n+\t\t\t\tStartTime:          time.Now(),\n+\t\t\t\tLockupPeriods:      lockupPeriods,\n+\t\t\t\tVestingPeriods:     vestingPeriods,\n+\t\t\t}\n+\t\t\tsuite.app.AccountKeeper.SetAccount(suite.ctx, vestAcc)\n+\n+\t\t\t// check account was created successfully\n+\t\t\tfoundAcc := suite.app.AccountKeeper.GetAccount(suite.ctx, vestingAddr)\n+\t\t\tsuite.Require().NotNil(foundAcc, \"vesting account not found\")\n+\t\t\tvestAcc, ok := foundAcc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\tsuite.Require().True(ok)\n+\t\t\tsuite.Require().Equal(tc.initialDelegatedVesting, vestAcc.DelegatedVesting)\n+\t\t\tsuite.Require().Equal(tc.initialDelegatedFree, vestAcc.DelegatedFree)\n+\n+\t\t\t// migrate\n+\t\t\tmigrator := keeper.NewMigrator(suite.app.VestingKeeper)\n+\t\t\terr = migrator.Migrate2to3(suite.ctx)\n+\t\t\tsuite.Require().NoError(err, \"migration failed\")\n+\n+\t\t\t// check that the account delegated vesting coins were migrated\n+\t\t\t// to the delegated free coins\n+\t\t\tfoundAcc = suite.app.AccountKeeper.GetAccount(suite.ctx, vestingAddr)\n+\t\t\tsuite.Require().NotNil(foundAcc, \"vesting account not found\")\n+\t\t\tvestAcc, ok = foundAcc.(*vestingtypes.ClawbackVestingAccount)\n+\t\t\tsuite.Require().True(ok)\n+\t\t\tsuite.Require().Equal(emtpyCoins, vestAcc.DelegatedVesting)\n+\t\t\tsuite.Require().Equal(tc.expectedDelegatedFree, vestAcc.DelegatedFree)\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "x/vesting/keeper/msg_server.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -371,6 +371,11 @@ func (k Keeper) ConvertVestingAccount(\n \t\treturn nil, errorsmod.Wrapf(errortypes.ErrInvalidRequest, \"vesting coins still left in account: %s\", msg.VestingAddress)\n \t}\n \n+\t// check if account has any locked up coins left\n+\tif vestingAcc.HasLockedCoins(ctx.BlockTime()) {\n+\t\treturn nil, errorsmod.Wrapf(errortypes.ErrInvalidRequest, \"locked up coins still left in account: %s\", msg.VestingAddress)\n+\t}\n+\t\n \t// if gov clawback is disabled, remove the entry from the store.\n \t// if no entry is found for the address, this will no-op\n \tk.DeleteGovClawbackDisabled(ctx, address)"
        },
        {
          "filename": "x/vesting/keeper/setup_test.go",
          "status": "modified",
          "additions": 127,
          "deletions": 13,
          "patch": "@@ -1,23 +1,34 @@\n package keeper_test\n \n import (\n+\t\"errors\"\n+\t\"math\"\n \t\"testing\"\n+\t\"time\"\n \n-\t//nolint:revive // dot imports are fine for Ginkgo\n-\t. \"github.com/onsi/ginkgo/v2\"\n-\t//nolint:revive // dot imports are fine for Ginkgo\n-\t. \"github.com/onsi/gomega\"\n-\n+\tsdkmath \"cosmossdk.io/math\"\n+\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n \t\"github.com/cosmos/cosmos-sdk/client\"\n \t\"github.com/cosmos/cosmos-sdk/crypto/keyring\"\n \tcryptotypes \"github.com/cosmos/cosmos-sdk/crypto/types\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n+\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n \tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/common\"\n+\t\"github.com/ethereum/go-ethereum/crypto\"\n \t\"github.com/stretchr/testify/suite\"\n \n \tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n-\tevm \"github.com/evmos/evmos/v18/x/evm/types\"\n+\n+\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n+\t\"github.com/evmos/evmos/v18/encoding\"\n+\t\"github.com/evmos/evmos/v18/testutil\"\n+\tutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n+\tevmostypes \"github.com/evmos/evmos/v18/types\"\n+\t\"github.com/evmos/evmos/v18/utils\"\n+\tepochstypes \"github.com/evmos/evmos/v18/x/epochs/types\"\n+\tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n \n \t\"github.com/evmos/evmos/v18/app\"\n \t\"github.com/evmos/evmos/v18/x/vesting/types\"\n@@ -41,7 +52,7 @@ type KeeperTestSuite struct {\n \n \tctx            sdk.Context\n \tapp            *app.Evmos\n-\tqueryClientEvm evm.QueryClient\n+\tqueryClientEvm evmtypes.QueryClient\n \tqueryClient    types.QueryClient\n \taddress        common.Address\n \tconsAddress    sdk.ConsAddress\n@@ -57,12 +68,115 @@ var s *KeeperTestSuite\n func TestKeeperTestSuite(t *testing.T) {\n \ts = new(KeeperTestSuite)\n \tsuite.Run(t, s)\n-\n-\t// Run Ginkgo integration tests\n-\tRegisterFailHandler(Fail)\n-\tRunSpecs(t, \"Keeper Suite\")\n }\n \n-func (suite *KeeperTestSuite) SetupTest() {\n-\tsuite.DoSetupTest(suite.T())\n+func (suite *KeeperTestSuite) SetupTest() error {\n+\tcheckTx := false\n+\n+\t// account key\n+\tpriv, err := ethsecp256k1.GenerateKey()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tsuite.address = common.BytesToAddress(priv.PubKey().Address().Bytes())\n+\tsuite.signer = utiltx.NewSigner(priv)\n+\tsuite.priv = priv\n+\n+\t// consensus key\n+\tpriv, err = ethsecp256k1.GenerateKey()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tsuite.consAddress = sdk.ConsAddress(priv.PubKey().Address())\n+\n+\t// Init app\n+\tchainID := utils.TestnetChainID + \"-1\"\n+\tsuite.app = app.Setup(checkTx, nil, chainID)\n+\n+\t// Set Context\n+\theader := testutil.NewHeader(\n+\t\t1, time.Now().UTC(), chainID, suite.consAddress, nil, nil,\n+\t)\n+\tsuite.ctx = suite.app.BaseApp.NewContext(false, header)\n+\n+\t// Setup query helpers\n+\tqueryHelperEvm := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n+\tevmtypes.RegisterQueryServer(queryHelperEvm, suite.app.EvmKeeper)\n+\tsuite.queryClientEvm = evmtypes.NewQueryClient(queryHelperEvm)\n+\n+\tqueryHelper := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n+\ttypes.RegisterQueryServer(queryHelper, suite.app.VestingKeeper)\n+\tsuite.queryClient = types.NewQueryClient(queryHelper)\n+\n+\t// Set epoch start time and height for all epoch identifiers from the epoch\n+\t// module\n+\tidentifiers := []string{epochstypes.WeekEpochID, epochstypes.DayEpochID}\n+\tfor _, identifier := range identifiers {\n+\t\tepoch, found := suite.app.EpochsKeeper.GetEpochInfo(suite.ctx, identifier)\n+\t\tif !found {\n+\t\t\treturn errors.New(\"epoch info not found\")\n+\t\t}\n+\t\tepoch.StartTime = suite.ctx.BlockTime()\n+\t\tepoch.CurrentEpochStartHeight = suite.ctx.BlockHeight()\n+\t\tsuite.app.EpochsKeeper.SetEpochInfo(suite.ctx, epoch)\n+\t}\n+\n+\tacc := &evmostypes.EthAccount{\n+\t\tBaseAccount: authtypes.NewBaseAccount(sdk.AccAddress(suite.address.Bytes()), nil, 0, 0),\n+\t\tCodeHash:    common.BytesToHash(crypto.Keccak256(nil)).String(),\n+\t}\n+\n+\tsuite.app.AccountKeeper.SetAccount(suite.ctx, acc)\n+\n+\t// fund signer acc to pay for tx fees\n+\tamt := sdkmath.NewInt(int64(math.Pow10(18) * 2))\n+\terr = testutil.FundAccount(\n+\t\tsuite.ctx,\n+\t\tsuite.app.BankKeeper,\n+\t\tsuite.priv.PubKey().Address().Bytes(),\n+\t\tsdk.NewCoins(sdk.NewCoin(utils.BaseDenom, amt)),\n+\t)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Set Validator\n+\tvalAddr := sdk.ValAddress(suite.address.Bytes())\n+\tvalidator, err := stakingtypes.NewValidator(valAddr, priv.PubKey(), stakingtypes.Description{})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvalidator = stakingkeeper.TestingUpdateValidator(suite.app.StakingKeeper.Keeper, suite.ctx, validator, true)\n+\terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvalidators := s.app.StakingKeeper.GetValidators(s.ctx, 1)\n+\tsuite.validator = validators[0]\n+\n+\tencodingConfig := encoding.MakeConfig(app.ModuleBasics)\n+\tsuite.clientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig)\n+\tsuite.ethSigner = ethtypes.LatestSignerForChainID(suite.app.EvmKeeper.ChainID())\n+\n+\t// Deploy contracts\n+\tcontract, err = suite.DeployContract(erc20Name, erc20Symbol, erc20Decimals)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tcontract2, err = suite.DeployContract(erc20Name2, erc20Symbol2, erc20Decimals)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Set correct denom in govKeeper\n+\tgovParams := suite.app.GovKeeper.GetParams(suite.ctx)\n+\tgovParams.MinDeposit = sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, sdkmath.NewInt(1e6)))\n+\tvotingPeriod := time.Second\n+\tgovParams.VotingPeriod = &votingPeriod\n+\n+\treturn suite.app.GovKeeper.SetParams(suite.ctx, govParams)\n }"
        },
        {
          "filename": "x/vesting/keeper/utils_test.go",
          "status": "modified",
          "additions": 0,
          "deletions": 120,
          "patch": "@@ -1,134 +1,23 @@\n package keeper_test\n \n import (\n-\t\"math\"\n \t\"strings\"\n \t\"time\"\n \n \t//nolint:revive // dot imports are fine for Ginkgo\n \t. \"github.com/onsi/gomega\"\n \n \tsdkmath \"cosmossdk.io/math\"\n-\t\"github.com/cosmos/cosmos-sdk/baseapp\"\n-\t\"github.com/cosmos/cosmos-sdk/client\"\n \tsdk \"github.com/cosmos/cosmos-sdk/types\"\n \tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n-\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n-\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n \t\"github.com/ethereum/go-ethereum/common\"\n-\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n-\t\"github.com/ethereum/go-ethereum/crypto\"\n \n-\t\"github.com/evmos/evmos/v18/app\"\n-\tcosmosante \"github.com/evmos/evmos/v18/app/ante/cosmos\"\n \tevmante \"github.com/evmos/evmos/v18/app/ante/evm\"\n \t\"github.com/evmos/evmos/v18/contracts\"\n-\t\"github.com/evmos/evmos/v18/crypto/ethsecp256k1\"\n-\t\"github.com/evmos/evmos/v18/encoding\"\n \t\"github.com/evmos/evmos/v18/testutil\"\n-\tutiltx \"github.com/evmos/evmos/v18/testutil/tx\"\n-\tevmostypes \"github.com/evmos/evmos/v18/types\"\n-\t\"github.com/evmos/evmos/v18/utils\"\n-\tepochstypes \"github.com/evmos/evmos/v18/x/epochs/types\"\n-\tevmtypes \"github.com/evmos/evmos/v18/x/evm/types\"\n \t\"github.com/evmos/evmos/v18/x/vesting/types\"\n-\n-\t\"github.com/stretchr/testify/require\"\n )\n \n-func (suite *KeeperTestSuite) DoSetupTest(t require.TestingT) {\n-\tcheckTx := false\n-\n-\t// account key\n-\tpriv, err := ethsecp256k1.GenerateKey()\n-\trequire.NoError(t, err)\n-\tsuite.address = common.BytesToAddress(priv.PubKey().Address().Bytes())\n-\tsuite.signer = utiltx.NewSigner(priv)\n-\tsuite.priv = priv\n-\n-\t// consensus key\n-\tpriv, err = ethsecp256k1.GenerateKey()\n-\trequire.NoError(t, err)\n-\tsuite.consAddress = sdk.ConsAddress(priv.PubKey().Address())\n-\n-\t// Init app\n-\tchainID := utils.TestnetChainID + \"-1\"\n-\tsuite.app = app.Setup(checkTx, nil, chainID)\n-\n-\t// Set Context\n-\theader := testutil.NewHeader(\n-\t\t1, time.Now().UTC(), chainID, suite.consAddress, nil, nil,\n-\t)\n-\tsuite.ctx = suite.app.BaseApp.NewContext(false, header)\n-\n-\t// Setup query helpers\n-\tqueryHelperEvm := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n-\tevmtypes.RegisterQueryServer(queryHelperEvm, suite.app.EvmKeeper)\n-\tsuite.queryClientEvm = evmtypes.NewQueryClient(queryHelperEvm)\n-\n-\tqueryHelper := baseapp.NewQueryServerTestHelper(suite.ctx, suite.app.InterfaceRegistry())\n-\ttypes.RegisterQueryServer(queryHelper, suite.app.VestingKeeper)\n-\tsuite.queryClient = types.NewQueryClient(queryHelper)\n-\n-\t// Set epoch start time and height for all epoch identifiers from the epoch\n-\t// module\n-\tidentifiers := []string{epochstypes.WeekEpochID, epochstypes.DayEpochID}\n-\tfor _, identifier := range identifiers {\n-\t\tepoch, found := suite.app.EpochsKeeper.GetEpochInfo(suite.ctx, identifier)\n-\t\tsuite.Require().True(found)\n-\t\tepoch.StartTime = suite.ctx.BlockTime()\n-\t\tepoch.CurrentEpochStartHeight = suite.ctx.BlockHeight()\n-\t\tsuite.app.EpochsKeeper.SetEpochInfo(suite.ctx, epoch)\n-\t}\n-\n-\tacc := &evmostypes.EthAccount{\n-\t\tBaseAccount: authtypes.NewBaseAccount(sdk.AccAddress(suite.address.Bytes()), nil, 0, 0),\n-\t\tCodeHash:    common.BytesToHash(crypto.Keccak256(nil)).String(),\n-\t}\n-\n-\tsuite.app.AccountKeeper.SetAccount(suite.ctx, acc)\n-\n-\t// fund signer acc to pay for tx fees\n-\tamt := sdkmath.NewInt(int64(math.Pow10(18) * 2))\n-\terr = testutil.FundAccount(\n-\t\tsuite.ctx,\n-\t\tsuite.app.BankKeeper,\n-\t\tsuite.priv.PubKey().Address().Bytes(),\n-\t\tsdk.NewCoins(sdk.NewCoin(utils.BaseDenom, amt)),\n-\t)\n-\tsuite.Require().NoError(err)\n-\n-\t// Set Validator\n-\tvalAddr := sdk.ValAddress(suite.address.Bytes())\n-\tvalidator, err := stakingtypes.NewValidator(valAddr, priv.PubKey(), stakingtypes.Description{})\n-\trequire.NoError(t, err)\n-\tvalidator = stakingkeeper.TestingUpdateValidator(&suite.app.StakingKeeper, suite.ctx, validator, true)\n-\terr = suite.app.StakingKeeper.Hooks().AfterValidatorCreated(suite.ctx, validator.GetOperator())\n-\trequire.NoError(t, err)\n-\terr = suite.app.StakingKeeper.SetValidatorByConsAddr(suite.ctx, validator)\n-\trequire.NoError(t, err)\n-\tvalidators := s.app.StakingKeeper.GetValidators(s.ctx, 1)\n-\tsuite.validator = validators[0]\n-\n-\tencodingConfig := encoding.MakeConfig(app.ModuleBasics)\n-\tsuite.clientCtx = client.Context{}.WithTxConfig(encodingConfig.TxConfig)\n-\tsuite.ethSigner = ethtypes.LatestSignerForChainID(suite.app.EvmKeeper.ChainID())\n-\n-\t// Deploy contracts\n-\tcontract, err = suite.DeployContract(erc20Name, erc20Symbol, erc20Decimals)\n-\trequire.NoError(t, err)\n-\tcontract2, err = suite.DeployContract(erc20Name2, erc20Symbol2, erc20Decimals)\n-\trequire.NoError(t, err)\n-\n-\t// Set correct denom in govKeeper\n-\tgovParams := suite.app.GovKeeper.GetParams(suite.ctx)\n-\tgovParams.MinDeposit = sdk.NewCoins(sdk.NewCoin(utils.BaseDenom, sdkmath.NewInt(1e6)))\n-\tvotingPeriod := time.Second\n-\tgovParams.VotingPeriod = &votingPeriod\n-\terr = suite.app.GovKeeper.SetParams(suite.ctx, govParams)\n-\tsuite.Require().NoError(err, \"failed to set gov params\")\n-}\n-\n // Commit commits and starts a new block with an updated context.\n func (suite *KeeperTestSuite) Commit() {\n \tsuite.CommitAfter(time.Second * 0)\n@@ -218,15 +107,6 @@ func assertEthSucceeds(testAccounts []TestClawbackAccount, funder sdk.AccAddress\n \t}\n }\n \n-// delegate is a helper function which creates a message to delegate a given amount of tokens\n-// to a validator and checks if the Cosmos vesting delegation decorator returns no error.\n-func delegate(account TestClawbackAccount, coins sdk.Coins) (*stakingtypes.MsgDelegate, error) {\n-\tmsg := stakingtypes.NewMsgDelegate(account.address, s.validator.GetOperator(), coins[0])\n-\tdec := cosmosante.NewVestingDelegationDecorator(s.app.AccountKeeper, s.app.StakingKeeper, s.app.BankKeeper, types.ModuleCdc)\n-\terr = testutil.ValidateAnteForMsgs(s.ctx, dec, msg)\n-\treturn msg, err\n-}\n-\n // validateEthVestingTransactionDecorator is a helper function to execute the eth vesting transaction decorator\n // with 1 or more given messages and return any occurring error.\n func validateEthVestingTransactionDecorator(msgs ...sdk.Msg) error {"
        },
        {
          "filename": "x/vesting/migrations/v3/migrate.go",
          "status": "added",
          "additions": 38,
          "deletions": 0,
          "patch": "@@ -0,0 +1,38 @@\n+// Copyright Tharsis Labs Ltd.(Evmos)\n+// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/evmos/blob/main/LICENSE)\n+package v3\n+\n+import (\n+\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n+\taccounttypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n+\tvestingtypes \"github.com/evmos/evmos/v18/x/vesting/types\"\n+)\n+\n+// MigrateStore migrates the x/vesting module state from the consensus version 2 to\n+// version 3.\n+// Specifically, it adds the DelegatedVesting (that should always be 0)\n+// to the DelegatedFree\n+func MigrateStore(\n+\tctx sdk.Context,\n+\tak vestingtypes.AccountKeeper,\n+) error {\n+\tak.IterateAccounts(ctx, func(account accounttypes.AccountI) bool {\n+\t\tif vestAcc, ok := account.(*vestingtypes.ClawbackVestingAccount); ok {\n+\t\t\t// if DelegatedVesting == 0, skip it\n+\t\t\tif !vestAcc.DelegatedVesting.IsAllPositive() {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\t// add DelegatedVesting to DelegatedFree,\n+\t\t\t// because it is not possible to delegate vesting coins.\n+\t\t\t// ONLY vested (free) coins can be delegated\n+\t\t\tvestAcc.DelegatedFree = vestAcc.DelegatedFree.Add(vestAcc.DelegatedVesting...)\n+\t\t\tvestAcc.DelegatedVesting = sdk.NewCoins()\n+\n+\t\t\tak.SetAccount(ctx, vestAcc)\n+\t\t}\n+\n+\t\treturn false\n+\t})\n+\n+\treturn nil\n+}"
        },
        {
          "filename": "x/vesting/migrations/v3/migrate_test.go",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+package v3\n+\n+// NOTE: Migrations are tested in keeper package."
        },
        {
          "filename": "x/vesting/module.go",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -28,7 +28,7 @@ import (\n )\n \n // consensusVersion defines the current x/vesting module consensus version.\n-const consensusVersion = 2\n+const consensusVersion = 3\n \n var (\n \t_ module.AppModule      = AppModule{}\n@@ -133,6 +133,10 @@ func (am AppModule) RegisterServices(cfg module.Configurator) {\n \tif err := cfg.RegisterMigration(types.ModuleName, 1, migrator.Migrate1to2); err != nil {\n \t\tpanic(fmt.Errorf(\"failed to migrate %s to v2: %w\", types.ModuleName, err))\n \t}\n+\n+\tif err := cfg.RegisterMigration(types.ModuleName, 2, migrator.Migrate2to3); err != nil {\n+\t\tpanic(fmt.Errorf(\"failed to migrate %s to v3: %w\", types.ModuleName, err))\n+\t}\n }\n \n // InitGenesis performs a no-op."
        },
        {
          "filename": "x/vesting/types/clawback_vesting_account.go",
          "status": "modified",
          "additions": 51,
          "deletions": 35,
          "patch": "@@ -51,35 +51,55 @@ func NewClawbackVestingAccount(\n \t}\n }\n \n-// GetVestedCoins returns the total number of vested coins that are still in lockup. If no coins are\n-// vested, nil is returned.\n-func (va ClawbackVestingAccount) GetVestedCoins(blockTime time.Time) sdk.Coins {\n-\t// It's likely that one or the other schedule will be nearly trivial,\n-\t// so there should be little overhead in recomputing the conjunction each time.\n-\tcoins := va.GetUnlockedOnly(blockTime).Min(va.GetVestedOnly(blockTime))\n+// GetLockedUpVestedCoins returns the total number of vested coins that are locked.\n+func (va ClawbackVestingAccount) GetLockedUpVestedCoins(blockTime time.Time) sdk.Coins {\n+\treturn va.GetVestedCoins(blockTime).Sub(va.GetUnlockedVestedCoins(blockTime)...)\n+}\n+\n+// GetUnlockedVestedCoins returns the total number of vested coins that are unlocked.\n+// If no coins are vested and unlocked, nil is returned.\n+func (va ClawbackVestingAccount) GetUnlockedVestedCoins(blockTime time.Time) sdk.Coins {\n+\tcoins := va.GetUnlockedCoins(blockTime).Min(va.GetVestedCoins(blockTime))\n \tif coins.IsZero() {\n-\t\treturn nil\n+\t\treturn sdk.Coins{}\n \t}\n \treturn coins\n }\n \n-// GetVestingCoins returns the total number of vesting coins. If no coins are\n-// vesting, nil is returned.\n+// GetVestingCoins returns the total number of vesting coins (unvested coins).\n+// If no coins are vesting, nil is returned.\n func (va ClawbackVestingAccount) GetVestingCoins(blockTime time.Time) sdk.Coins {\n \treturn va.OriginalVesting.Sub(va.GetVestedCoins(blockTime)...)\n }\n \n-// LockedCoins returns the set of coins that are not spendable (i.e. locked),\n-// defined as the vesting coins that are not delegated.\n+// LockedCoins returns the set of coins that are not spendable (i.e. locked or unvested),\n+// defined as the vesting coins (unvested) plus locked vested coins.\n+//\n+// totalAmt = vesting(un/locked) + lockedVested + unlockedVested\n+//\n+//\t(all)   =   (cannot spend)    (cannot spend)   (CAN spend)\n+//\n+// lockedCoins = totalAmt - unlockedVested\n func (va ClawbackVestingAccount) LockedCoins(blockTime time.Time) sdk.Coins {\n-\treturn va.BaseVestingAccount.LockedCoinsFromVesting(va.GetVestingCoins(blockTime))\n+\treturn va.OriginalVesting.Sub(va.GetUnlockedVestedCoins(blockTime)...)\n }\n \n // TrackDelegation tracks a desired delegation amount by setting the appropriate\n-// values for the amount of delegated vesting, delegated free, and reducing the\n-// overall amount of base coins.\n-func (va *ClawbackVestingAccount) TrackDelegation(blockTime time.Time, balance, amount sdk.Coins) {\n-\tva.BaseVestingAccount.TrackDelegation(balance, va.GetVestingCoins(blockTime), amount)\n+// values for the amount of delegated free coins.\n+// The 'balance' input parameter is the delegator account balance.\n+// The 'amount' input parameter are the delegated coins\n+// Note that unvested coins cannot be delegated\n+func (va *ClawbackVestingAccount) TrackDelegation(_ time.Time, balance, amount sdk.Coins) {\n+\t// Can only delegate vested (free) coins\n+\tfor _, coin := range amount {\n+\t\tbaseAmt := balance.AmountOf(coin.Denom)\n+\t\t// Panic if the delegation amount is zero or if the base coins does not\n+\t\t// exceed the desired delegation amount.\n+\t\tif coin.Amount.IsZero() || baseAmt.LT(coin.Amount) {\n+\t\t\tpanic(\"delegation attempt with zero coins or insufficient funds\")\n+\t\t}\n+\t\tva.DelegatedFree = va.DelegatedFree.Add(coin)\n+\t}\n }\n \n // GetStartTime returns the time when vesting starts for a periodic vesting\n@@ -125,7 +145,7 @@ func (va ClawbackVestingAccount) Validate() error {\n \t}\n \n \tif vestingEnd > va.EndTime {\n-\t\treturn errors.New(\"vesting schedule exteds beyond account end time\")\n+\t\treturn errors.New(\"vesting schedule extends beyond account end time\")\n \t}\n \n \tif !CoinEq(vestingCoins, va.OriginalVesting) {\n@@ -135,29 +155,25 @@ func (va ClawbackVestingAccount) Validate() error {\n \treturn va.BaseVestingAccount.Validate()\n }\n \n-// GetUnlockedOnly returns the unlocking schedule at blockTime.\n-func (va ClawbackVestingAccount) GetUnlockedOnly(blockTime time.Time) sdk.Coins {\n+// GetUnlockedCoins returns the unlocked coins at blockTime.\n+// Note that these unlocked coins can be vested or unvested\n+// and is determined by the lockup periods\n+func (va ClawbackVestingAccount) GetUnlockedCoins(blockTime time.Time) sdk.Coins {\n \treturn ReadSchedule(va.GetStartTime(), va.EndTime, va.LockupPeriods, va.OriginalVesting, blockTime.Unix())\n }\n \n-// GetLockedOnly returns the locking schedule at blockTime.\n-func (va ClawbackVestingAccount) GetLockedOnly(blockTime time.Time) sdk.Coins {\n-\treturn va.OriginalVesting.Sub(va.GetUnlockedOnly(blockTime)...)\n+// GetLockedUpCoins returns the locked coins at blockTime.\n+// Note that these locked up coins can be vested or unvested,\n+// and is determined by the lockup periods\n+func (va ClawbackVestingAccount) GetLockedUpCoins(blockTime time.Time) sdk.Coins {\n+\treturn va.OriginalVesting.Sub(va.GetUnlockedCoins(blockTime)...)\n }\n \n-// GetVestedOnly returns the vesting schedule at blockTime.\n-func (va ClawbackVestingAccount) GetVestedOnly(blockTime time.Time) sdk.Coins {\n+// GetVestedCoins returns the vested coins at blockTime.\n+func (va ClawbackVestingAccount) GetVestedCoins(blockTime time.Time) sdk.Coins {\n \treturn ReadSchedule(va.GetStartTime(), va.EndTime, va.VestingPeriods, va.OriginalVesting, blockTime.Unix())\n }\n \n-// GetUnvestedOnly returns the unvesting schedule at blockTime.\n-func (va ClawbackVestingAccount) GetUnvestedOnly(blockTime time.Time) sdk.Coins {\n-\ttotalUnvested := va.OriginalVesting.Sub(va.GetVestedOnly(blockTime)...)\n-\tif totalUnvested == nil {\n-\t\ttotalUnvested = sdk.Coins{}\n-\t}\n-\treturn totalUnvested\n-}\n \n // GetPassedPeriodCount returns the amount of passed periods at blockTime.\n func (va ClawbackVestingAccount) GetPassedPeriodCount(blockTime time.Time) int {\n@@ -170,8 +186,8 @@ func (va ClawbackVestingAccount) GetPassedPeriodCount(blockTime time.Time) int {\n func (va ClawbackVestingAccount) ComputeClawback(\n \tclawbackTime int64,\n ) (ClawbackVestingAccount, sdk.Coins) {\n-\ttotalVested := va.GetVestedOnly(time.Unix(clawbackTime, 0))\n-\ttotalUnvested := va.GetUnvestedOnly(time.Unix(clawbackTime, 0))\n+\ttotalVested := va.GetVestedCoins(time.Unix(clawbackTime, 0))\n+\ttotalUnvested := va.GetVestingCoins(time.Unix(clawbackTime, 0))\n \n \t// Remove all unvested periods from the schedule\n \tpassedPeriodID := va.GetPassedPeriodCount(time.Unix(clawbackTime, 0))\n@@ -203,5 +219,5 @@ func (va ClawbackVestingAccount) ComputeClawback(\n // HasLockedCoins returns true if the block time has not passed all clawback\n // account's lockup periods\n func (va ClawbackVestingAccount) HasLockedCoins(blockTime time.Time) bool {\n-\treturn !va.GetLockedOnly(blockTime).IsZero()\n+\treturn !va.GetLockedUpCoins(blockTime).IsZero()\n }"
        },
        {
          "filename": "x/vesting/types/clawback_vesting_account_test.go",
          "status": "modified",
          "additions": 184,
          "deletions": 220,
          "patch": "@@ -19,12 +19,24 @@ var (\n \tstakeDenom    = \"stake\"\n \tfeeDenom      = \"fee\"\n \tlockupPeriods = sdkvesting.Periods{\n-\t\tsdkvesting.Period{Length: int64(16 * 60 * 60), Amount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100))},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(16 * 60 * 60), // 16hs\n+\t\t\tAmount: sdk.NewCoins(sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100)),\n+\t\t},\n \t}\n \tvestingPeriods = sdkvesting.Periods{\n-\t\tsdkvesting.Period{Length: int64(12 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)}},\n-\t\tsdkvesting.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},\n-\t\tsdkvesting.Period{Length: int64(6 * 60 * 60), Amount: sdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)}},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(12 * 60 * 60), // 12hs\n+\t\t\tAmount: getPercentOfVestingCoins(50),\n+\t\t},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(6 * 60 * 60), // 6hs\n+\t\t\tAmount: getPercentOfVestingCoins(25),\n+\t\t},\n+\t\tsdkvesting.Period{\n+\t\t\tLength: int64(6 * 60 * 60), // 6hs\n+\t\t\tAmount: getPercentOfVestingCoins(25),\n+\t\t},\n \t}\n \torigCoins = sdk.Coins{sdk.NewInt64Coin(feeDenom, 1000), sdk.NewInt64Coin(stakeDenom, 100)}\n )\n@@ -38,30 +50,31 @@ func TestVestingAccountSuite(t *testing.T) {\n }\n \n func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n-\taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n+\taddr := sdk.AccAddress(\"test_address\")\n \tbaseAcc := authtypes.NewBaseAccountWithAddress(addr)\n \tinitialVesting := sdk.NewCoins(sdk.NewInt64Coin(sdk.DefaultBondDenom, 50))\n \n \ttestCases := []struct {\n-\t\tname   string\n-\t\tacc    authtypes.GenesisAccount\n-\t\texpErr bool\n+\t\tname      string\n+\t\tacc       authtypes.GenesisAccount\n+\t\texpErr    bool\n+\t\texpErrMsg string\n \t}{\n \t\t{\n-\t\t\t\"Clawback vesting account - pass\",\n-\t\t\ttypes.NewClawbackVestingAccount(\n+\t\t\tname: \"Clawback vesting account - pass\",\n+\t\t\tacc: types.NewClawbackVestingAccount(\n \t\t\t\tbaseAcc,\n-\t\t\t\tsdk.AccAddress([]byte(\"the funder\")),\n+\t\t\t\tsdk.AccAddress(\"the funder\"),\n \t\t\t\tinitialVesting,\n \t\t\t\ttime.Now(),\n \t\t\t\tsdkvesting.Periods{sdkvesting.Period{Length: 101, Amount: initialVesting}},\n \t\t\t\tsdkvesting.Periods{sdkvesting.Period{Length: 201, Amount: initialVesting}},\n \t\t\t),\n-\t\t\tfalse,\n+\t\t\texpErr: false,\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - invalid vesting end\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - invalid vesting end\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n@@ -72,11 +85,12 @@ func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"vesting start-time must be before end-time\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - lockup too long\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - lockup too long\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n@@ -87,11 +101,12 @@ func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 20, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"lockup schedule extends beyond account end time\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - invalid lockup coins\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - invalid lockup coins\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n@@ -102,11 +117,12 @@ func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting.Add(initialVesting...)}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"original vesting coins does not match the sum of all coins in lockup periods\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - vesting too long\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - vesting too long\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n@@ -117,11 +133,12 @@ func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 20, Amount: initialVesting}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"vesting schedule extends beyond account end time\",\n \t\t},\n \t\t{\n-\t\t\t\"Clawback vesting account - invalid vesting coins\",\n-\t\t\t&types.ClawbackVestingAccount{\n+\t\t\tname: \"Clawback vesting account - invalid vesting coins\",\n+\t\t\tacc: &types.ClawbackVestingAccount{\n \t\t\t\tBaseVestingAccount: &sdkvesting.BaseVestingAccount{\n \t\t\t\t\tBaseAccount:     baseAcc,\n \t\t\t\t\tOriginalVesting: initialVesting,\n@@ -132,242 +149,186 @@ func (suite *VestingAccountTestSuite) TestClawbackAccountNew() {\n \t\t\t\tLockupPeriods:  sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting}},\n \t\t\t\tVestingPeriods: sdkvesting.Periods{sdkvesting.Period{Length: 10, Amount: initialVesting.Add(initialVesting...)}},\n \t\t\t},\n-\t\t\ttrue,\n+\t\t\texpErr:    true,\n+\t\t\texpErrMsg: \"original vesting coins does not match the sum of all coins in vesting periods\",\n \t\t},\n \t}\n \n \tfor _, tc := range testCases {\n \t\tsuite.Run(tc.name, func() {\n-\t\t\tsuite.Require().Equal(tc.expErr, tc.acc.Validate() != nil)\n+\t\t\terr := tc.acc.Validate()\n+\t\t\tif tc.expErr {\n+\t\t\t\tsuite.Require().Error(err)\n+\t\t\t\tsuite.Require().Contains(err.Error(), tc.expErrMsg)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tsuite.Require().NoError(err)\n \t\t})\n \t}\n }\n \n-func (suite *VestingAccountTestSuite) TestGetVestedVestingLockedCoins() {\n+func (suite *VestingAccountTestSuite) TestGetCoinsFunctions() {\n \tnow := tmtime.Now()\n \tendTime := now.Add(24 * time.Hour)\n \taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \tbacc := authtypes.NewBaseAccountWithAddress(addr)\n \tva := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte(\"funder\")), origCoins, now, lockupPeriods, vestingPeriods)\n \n \ttestCases := []struct {\n-\t\tname              string\n-\t\ttime              time.Time\n-\t\texpVestedCoins    sdk.Coins\n-\t\texpUnvestedCoins  sdk.Coins\n-\t\texpSpendableCoins sdk.Coins\n+\t\tname                   string\n+\t\ttime                   time.Time\n+\t\texpVestedCoins         sdk.Coins\n+\t\texpLockedUpVestedCoins sdk.Coins\n+\t\texpUnlockedVestedCoins sdk.Coins\n+\t\texpUnvestedCoins       sdk.Coins\n+\t\texpLockedUpCoins       sdk.Coins\n+\t\texpUnlockedCoins       sdk.Coins\n+\t\texpNotSpendable        sdk.Coins\n \t}{\n \t\t{\n-\t\t\t\"no coins vested at the beginning of the vesting schedule\",\n-\t\t\tnow,\n-\t\t\tnil,\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"all coins vested at the end of the vesting schedule\",\n-\t\t\tendTime,\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.NewCoins(),\n-\t\t},\n-\t\t{\n-\t\t\t\"no coins vested during first vesting period\",\n-\t\t\tnow.Add(6 * time.Hour),\n-\t\t\tnil,\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"no coins vested after period 1 before unlocking\",\n-\t\t\tnow.Add(14 * time.Hour),\n-\t\t\tnil,\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"50 percent of coins vested after period 1 at unlocking\",\n-\t\t\tnow.Add(16 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t},\n-\t\t{\n-\t\t\t\"period 2 coins don't vest until period is over\",\n-\t\t\tnow.Add(17 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t},\n-\t\t{\n-\t\t\t\"75 percent of coins vested after period 2\",\n-\t\t\tnow.Add(18 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 750), sdk.NewInt64Coin(stakeDenom, 75)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t},\n-\t\t{\n-\t\t\t\"100 percent of coins vested\",\n-\t\t\tnow.Add(48 * time.Hour),\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.NewCoins(),\n+\t\t\tname:                   \"no coins vested at the beginning of the vesting schedule, all locked\",\n+\t\t\ttime:                   now,\n+\t\t\texpVestedCoins:         sdk.Coins{},\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: sdk.Coins{},\n+\t\t\texpUnvestedCoins:       origCoins,\n+\t\t\texpLockedUpCoins:       origCoins,\n+\t\t\texpUnlockedCoins:       sdk.Coins{},\n+\t\t\texpNotSpendable:        origCoins,\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"all coins vested and unlocked at the end of the vesting schedule\",\n+\t\t\ttime:                   endTime,\n+\t\t\texpVestedCoins:         origCoins,\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: origCoins,\n+\t\t\texpUnvestedCoins:       sdk.Coins{},\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        sdk.Coins{},\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"no coins vested during first vesting period, all still locked\",\n+\t\t\ttime:                   now.Add(6 * time.Hour),\n+\t\t\texpVestedCoins:         sdk.Coins{},\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: sdk.Coins{},\n+\t\t\texpUnvestedCoins:       origCoins,\n+\t\t\texpLockedUpCoins:       origCoins,\n+\t\t\texpUnlockedCoins:       sdk.Coins{},\n+\t\t\texpNotSpendable:        origCoins,\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"50 percent of coins are vested after 1st vesting period, but before unlocking (all locked coins)\",\n+\t\t\ttime:                   now.Add(12 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpVestedCoins: getPercentOfVestingCoins(50),\n+\t\t\texpUnlockedVestedCoins: sdk.Coins{},\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpCoins:       origCoins,\n+\t\t\texpUnlockedCoins:       sdk.Coins{},\n+\t\t\texpNotSpendable:        origCoins,\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"after lockup period (all coins unlocked) - 50 percent of coins already vested\",\n+\t\t\ttime:                   now.Add(16 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: getPercentOfVestingCoins(50),\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        getPercentOfVestingCoins(50),\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"in between vesting periods 1 and 2 - no new coins don't vested\",\n+\t\t\ttime:                   now.Add(17 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: getPercentOfVestingCoins(50),\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(50),\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        getPercentOfVestingCoins(50),\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"75 percent of coins vested after period 2\",\n+\t\t\ttime:                   now.Add(18 * time.Hour),\n+\t\t\texpVestedCoins:         getPercentOfVestingCoins(75),\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: getPercentOfVestingCoins(75),\n+\t\t\texpUnvestedCoins:       getPercentOfVestingCoins(25),\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        getPercentOfVestingCoins(25),\n+\t\t},\n+\t\t{\n+\t\t\tname:                   \"100 percent of coins vested\",\n+\t\t\ttime:                   now.Add(48 * time.Hour),\n+\t\t\texpVestedCoins:         origCoins,\n+\t\t\texpLockedUpVestedCoins: sdk.Coins{},\n+\t\t\texpUnlockedVestedCoins: origCoins,\n+\t\t\texpUnvestedCoins:       sdk.Coins{},\n+\t\t\texpLockedUpCoins:       sdk.Coins{},\n+\t\t\texpUnlockedCoins:       origCoins,\n+\t\t\texpNotSpendable:        sdk.Coins{},\n \t\t},\n \t}\n \n \tfor _, tc := range testCases {\n \t\tsuite.Run(tc.name, func() {\n \t\t\tvestedCoins := va.GetVestedCoins(tc.time)\n \t\t\tsuite.Require().Equal(tc.expVestedCoins, vestedCoins)\n+\t\t\tlockedUpVested := va.GetLockedUpVestedCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expLockedUpVestedCoins, lockedUpVested)\n+\t\t\tunlockedVestedCoins := va.GetUnlockedVestedCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expUnlockedVestedCoins, unlockedVestedCoins)\n \t\t\tunvestedCoins := va.GetVestingCoins(tc.time)\n \t\t\tsuite.Require().Equal(tc.expUnvestedCoins, unvestedCoins)\n-\t\t\tspendableCoins := va.LockedCoins(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expSpendableCoins, spendableCoins)\n-\t\t})\n-\t}\n-}\n-\n-func (suite *VestingAccountTestSuite) TestGetVestedUnvestedLockedOnly() {\n-\tnow := tmtime.Now()\n-\tendTime := now.Add(24 * time.Hour)\n-\taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n-\tbacc := authtypes.NewBaseAccountWithAddress(addr)\n-\tva := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte(\"funder\")), origCoins, now, lockupPeriods, vestingPeriods)\n-\n-\ttestCases := []struct {\n-\t\tname             string\n-\t\ttime             time.Time\n-\t\texpVestedCoins   sdk.Coins\n-\t\texpUnvestedCoins sdk.Coins\n-\t\texpLockedCoins   sdk.Coins\n-\t}{\n-\t\t{\n-\t\t\t\"no coins vested at the beginning of the vesting schedule\",\n-\t\t\tnow,\n-\t\t\tsdk.Coins{},\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"all coins vested at the end of the vesting schedule\",\n-\t\t\tendTime,\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"no coins vested during first vesting period\",\n-\t\t\tnow.Add(6 * time.Hour),\n-\t\t\tsdk.Coins{},\n-\t\t\torigCoins,\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"50 percent of coins vested after period 1 before unlocking\",\n-\t\t\tnow.Add(14 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\torigCoins,\n-\t\t},\n-\t\t{\n-\t\t\t\"50 percent of coins vested after period 1 at unlocking\",\n-\t\t\tnow.Add(16 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"period 2 coins don't vest until period is over\",\n-\t\t\tnow.Add(17 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 500), sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"75 percent of coins vested after period 2\",\n-\t\t\tnow.Add(18 * time.Hour),\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 750), sdk.NewInt64Coin(stakeDenom, 75)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(feeDenom, 250), sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t\t{\n-\t\t\t\"100 percent of coins vested\",\n-\t\t\tnow.Add(48 * time.Hour),\n-\t\t\torigCoins,\n-\t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n-\t\t},\n-\t}\n-\n-\tfor _, tc := range testCases {\n-\t\tsuite.Run(tc.name, func() {\n-\t\t\tvestedCoins := va.GetVestedOnly(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expVestedCoins, vestedCoins)\n-\t\t\tunvestedCoins := va.GetUnvestedOnly(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expUnvestedCoins, unvestedCoins)\n-\t\t\tlockedCoins := va.GetLockedOnly(tc.time)\n-\t\t\tsuite.Require().Equal(tc.expLockedCoins, lockedCoins)\n+\t\t\tlockedUpCoins := va.GetLockedUpCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expLockedUpCoins, lockedUpCoins)\n+\t\t\tunlockedCoins := va.GetUnlockedCoins(tc.time)\n+\t\t\tsuite.Require().Equal(tc.expUnlockedCoins, unlockedCoins)\n+\t\t\tsuite.Require().Equal(tc.expNotSpendable, va.LockedCoins(tc.time))\n \t\t})\n \t}\n }\n-\n func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \tnow := tmtime.Now()\n \tendTime := now.Add(24 * time.Hour)\n \n \ttestCases := []struct {\n-\t\tname                   string\n-\t\tdelegate               func(*types.ClawbackVestingAccount)\n-\t\texpDelegatedUnvested   sdk.Coins\n-\t\texpDelegatedFree       sdk.Coins\n-\t\tundelegate             func(*types.ClawbackVestingAccount)\n-\t\texpUndelegatedUnvested sdk.Coins\n-\t\texpUndelegatedFree     sdk.Coins\n-\t\texpDelegationPanic     bool\n-\t\texpUndelegationPanic   bool\n+\t\tname                 string\n+\t\tdelegate             func(*types.ClawbackVestingAccount)\n+\t\texpDelegatedFree     sdk.Coins\n+\t\tundelegate           func(*types.ClawbackVestingAccount)\n+\t\texpUndelegatedFree   sdk.Coins\n+\t\texpDelegationPanic   bool\n+\t\texpUndelegationPanic bool\n \t}{\n-\t\t{\n-\t\t\t\"delegate and undelegate all unvested coins\",\n-\t\t\tfunc(va *types.ClawbackVestingAccount) {\n-\t\t\t\tva.TrackDelegation(now, origCoins, origCoins)\n-\t\t\t},\n-\t\t\torigCoins,\n-\t\t\tnil,\n-\t\t\tfunc(va *types.ClawbackVestingAccount) {\n-\t\t\t\tva.TrackUndelegation(origCoins)\n-\t\t\t},\n-\t\t\tsdk.Coins{},\n-\t\t\tnil,\n-\t\t\tfalse,\n-\t\t\tfalse,\n-\t\t},\n \t\t{\n \t\t\t\"delegate and undelegated all vested coins\",\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackDelegation(endTime, origCoins, origCoins)\n \t\t\t},\n-\t\t\tnil,\n \t\t\torigCoins,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(origCoins)\n \t\t\t},\n-\t\t\tnil,\n \t\t\tsdk.Coins{},\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n \t\t{\n-\t\t\t\"delegate and undelegate half of unvested coins\",\n+\t\t\t\"delegate and undelegate half of vested coins\",\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackDelegation(now, origCoins, vestingPeriods[0].Amount)\n \t\t\t},\n \t\t\tvestingPeriods[0].Amount,\n-\t\t\tnil,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(vestingPeriods[0].Amount)\n \t\t\t},\n \t\t\tsdk.Coins{},\n-\t\t\tnil,\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n@@ -377,12 +338,10 @@ func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now, origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 1000000)})\n \t\t\t},\n \t\t\tvestingPeriods[0].Amount,\n-\t\t\tnil,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(vestingPeriods[0].Amount)\n \t\t\t},\n \t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n \t\t\ttrue,\n \t\t\tfalse,\n \t\t},\n@@ -392,12 +351,10 @@ func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now, origCoins, origCoins)\n \t\t\t},\n \t\t\tvestingPeriods[0].Amount,\n-\t\t\tnil,\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 0)})\n \t\t\t},\n \t\t\tsdk.Coins{},\n-\t\t\tsdk.Coins{},\n \t\t\tfalse,\n \t\t\ttrue,\n \t\t},\n@@ -407,13 +364,11 @@ func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n+\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 100)},\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)})\n \t\t\t},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)},\n+\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 75)},\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n@@ -423,26 +378,21 @@ func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t\tva.TrackDelegation(now.Add(17*time.Hour), origCoins, sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n-\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)},\n+\t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 100)},\n \t\t\tfunc(va *types.ClawbackVestingAccount) {\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)})\n \t\t\t\tva.TrackUndelegation(sdk.Coins{sdk.NewInt64Coin(stakeDenom, 50)})\n \t\t\t},\n \t\t\tsdk.Coins{sdk.NewInt64Coin(stakeDenom, 25)},\n-\t\t\tsdk.Coins{},\n \t\t\tfalse,\n \t\t\tfalse,\n \t\t},\n \t}\n-\n \tfor _, tc := range testCases {\n \t\tsuite.Run(tc.name, func() {\n \t\t\taddr := sdk.AccAddress(utiltx.GenerateAddress().Bytes())\n \t\t\tbacc := authtypes.NewBaseAccountWithAddress(addr)\n-\n \t\t\tva := types.NewClawbackVestingAccount(bacc, sdk.AccAddress([]byte(\"funder\")), origCoins, now, lockupPeriods, vestingPeriods)\n-\n \t\t\tif tc.expDelegationPanic { //nolint:gocritic\n \t\t\t\tsuite.Require().Panics(func() {\n \t\t\t\t\ttc.delegate(va)\n@@ -452,14 +402,15 @@ func (suite *VestingAccountTestSuite) TestTrackDelegationUndelegation() {\n \t\t\t\t\ttc.undelegate(va)\n \t\t\t\t})\n \t\t\t} else {\n+\t\t\t\tvar emptyCoins sdk.Coins\n \t\t\t\t// Track Delegation\n \t\t\t\ttc.delegate(va)\n-\t\t\t\tsuite.Require().Equal(tc.expDelegatedUnvested, va.DelegatedVesting)\n+\t\t\t\tsuite.Require().Equal(emptyCoins, va.DelegatedVesting)\n \t\t\t\tsuite.Require().Equal(tc.expDelegatedFree, va.DelegatedFree)\n \n \t\t\t\t// Track Undelegation\n \t\t\t\ttc.undelegate(va)\n-\t\t\t\tsuite.Require().Equal(tc.expUndelegatedUnvested, va.DelegatedVesting)\n+\t\t\t\tsuite.Require().Equal(emptyCoins, va.DelegatedVesting)\n \t\t\t\tsuite.Require().Equal(tc.expUndelegatedFree, va.DelegatedFree)\n \t\t\t}\n \t\t})\n@@ -538,3 +489,16 @@ func (suite *VestingAccountTestSuite) TestComputeClawback() {\n \t\t})\n \t}\n }\n+\n+// getPercentOfVestingCoins is a helper function to calculate\n+// the specified percentage of the coins in the vesting schedule\n+func getPercentOfVestingCoins(percentage int64) sdk.Coins {\n+\tif percentage < 0 || percentage > 100 {\n+\t\tpanic(\"invalid percentage passed!\")\n+\t}\n+\tvar retCoins sdk.Coins\n+\tfor _, coin := range origCoins {\n+\t\tretCoins = retCoins.Add(sdk.NewCoin(coin.Denom, coin.Amount.MulRaw(percentage).QuoRaw(100)))\n+\t}\n+\treturn retCoins\n+}"
        },
        {
          "filename": "x/vesting/types/schedule.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -8,7 +8,7 @@ import (\n \tsdkvesting \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n )\n \n-// ReadSchedule returns the value of a schedule at readTime.\n+// ReadSchedule returns the coins of a schedule at readTime.\n //\n // A \"schedule\" is an increasing step function of Coins over time. It's\n // specified as an absolute start time and a sequence of relative periods, with"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 29,
        "unique_directories": 24,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cb46d96dae36a26b3cd11570421c2edc2e804bd4",
            "date": "2025-01-13T13:35:37Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "116a676f8e9c4f4847a05fe7a3fbe627956f44fe",
            "date": "2025-01-13T08:22:05Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "392b2279dafa5182b3a5299f165a2e035d031e0a",
            "date": "2025-01-10T10:48:35Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "9274fcaddad99ca39807a4e85d5e4c10585dc78a",
            "date": "2025-01-09T13:58:02Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1a507391b54073793be7bc4e6b14ce8d529054ae",
            "date": "2025-01-07T09:00:46Z",
            "author_login": "xujk-byte"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-691",
    "description": "Evmos is the Ethereum Virtual Machine (EVM) Hub on the Cosmos Network. Preliminary checks on actions computed by the clawback vesting accounts are performed in the ante handler. Evmos core, implements two different ante handlers: one for Cosmos transactions and one for Ethereum transactions. Checks performed on the two implementation are different. The vulnerability discovered allowed a clawback account to bypass Cosmos ante handler checks by sending an Ethereum transaction targeting a precompile used to interact with a Cosmos SDK module. This vulnerability is fixed in 18.0.0.\n\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-17T14:15:10.430",
    "last_modified": "2024-11-21T09:23:19.610",
    "fix_date": "2024-04-22T14:08:28Z"
  },
  "references": [
    {
      "url": "https://github.com/evmos/evmos/commit/b2a09ca66613d8b04decd3f2dcba8e1e77709dcb",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/evmos/evmos/security/advisories/GHSA-pxv8-qhrh-jc7v",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/evmos/evmos/commit/b2a09ca66613d8b04decd3f2dcba8e1e77709dcb",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/evmos/evmos/security/advisories/GHSA-pxv8-qhrh-jc7v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.832277",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "evmos",
    "owner": "evmos",
    "created_at": "2021-09-28T09:13:46Z",
    "updated_at": "2025-01-13T13:35:42Z",
    "pushed_at": "2025-01-14T13:36:57Z",
    "size": 197487,
    "stars": 1680,
    "forks": 878,
    "open_issues": 23,
    "watchers": 1680,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 4931570,
      "Python": 413227,
      "Solidity": 118737,
      "Jsonnet": 56049,
      "JavaScript": 47253,
      "Shell": 44165,
      "Nix": 23467,
      "Makefile": 21112,
      "Batchfile": 2623,
      "Dockerfile": 1717
    },
    "commit_activity": {
      "total_commits_last_year": 455,
      "avg_commits_per_week": 8.75,
      "days_active_last_year": 185
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T17:51:27.088637"
  }
}