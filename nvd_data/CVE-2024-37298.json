{
  "cve_id": "CVE-2024-37298",
  "github_data": {
    "repository": "gorilla/schema",
    "fix_commit": "cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff",
    "related_commits": [
      "cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff",
      "cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff"
    ],
    "patch_url": "https://github.com/gorilla/schema/commit/cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff.patch",
    "fix_commit_details": {
      "sha": "cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff",
      "commit_date": "2024-06-29T20:34:06Z",
      "author": {
        "login": "bharat-rajani",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-3669-72x9-r9p3",
        "length": 161,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 143,
        "additions": 137,
        "deletions": 6
      },
      "files": [
        {
          "filename": "decoder.go",
          "status": "modified",
          "additions": 17,
          "deletions": 1,
          "patch": "@@ -12,16 +12,21 @@ import (\n \t\"strings\"\n )\n \n+const (\n+\tdefaultMaxSize = 16000\n+)\n+\n // NewDecoder returns a new Decoder.\n func NewDecoder() *Decoder {\n-\treturn &Decoder{cache: newCache()}\n+\treturn &Decoder{cache: newCache(), maxSize: defaultMaxSize}\n }\n \n // Decoder decodes values from a map[string][]string to a struct.\n type Decoder struct {\n \tcache             *cache\n \tzeroEmpty         bool\n \tignoreUnknownKeys bool\n+\tmaxSize           int\n }\n \n // SetAliasTag changes the tag used to locate custom field aliases.\n@@ -54,6 +59,13 @@ func (d *Decoder) IgnoreUnknownKeys(i bool) {\n \td.ignoreUnknownKeys = i\n }\n \n+// MaxSize limits the size of slices for URL nested arrays or object arrays.\n+// Choose MaxSize carefully; large values may create many zero-value slice elements.\n+// Example: \"items.100000=apple\" would create a slice with 100,000 empty strings.\n+func (d *Decoder) MaxSize(size int) {\n+\td.maxSize = size\n+}\n+\n // RegisterConverter registers a converter function for a custom type.\n func (d *Decoder) RegisterConverter(value interface{}, converterFunc Converter) {\n \td.cache.registerConverter(value, converterFunc)\n@@ -302,6 +314,10 @@ func (d *Decoder) decode(v reflect.Value, path string, parts []pathPart, values\n \t// Slice of structs. Let's go recursive.\n \tif len(parts) > 1 {\n \t\tidx := parts[0].index\n+\t\t// a defensive check to avoid creating a large slice based on user input index\n+\t\tif idx > d.maxSize {\n+\t\t\treturn fmt.Errorf(\"%v index %d is larger than the configured maxSize %d\", v.Kind(), idx, d.maxSize)\n+\t\t}\n \t\tif v.IsNil() || v.Len() < idx+1 {\n \t\t\tvalue := reflect.MakeSlice(t, idx+1, idx+1)\n \t\t\tif v.Len() < idx+1 {"
        },
        {
          "filename": "decoder_test.go",
          "status": "modified",
          "additions": 120,
          "deletions": 5,
          "patch": "@@ -2063,7 +2063,7 @@ type S24 struct {\n \n type S24e struct {\n \t*S24\n-\tF2 string `schema:\"F2\"`\t\n+\tF2 string `schema:\"F2\"`\n }\n \n func TestUnmarshallToEmbeddedNoData(t *testing.T) {\n@@ -2074,13 +2074,14 @@ func TestUnmarshallToEmbeddedNoData(t *testing.T) {\n \ts := &S24e{}\n \n \tdecoder := NewDecoder()\n-\terr := decoder.Decode(s, data);\n-\t\n+\terr := decoder.Decode(s, data)\n+\n \texpectedErr := `schema: invalid path \"F3\"`\n \tif err.Error() != expectedErr {\n \t\tt.Fatalf(\"got %q, want %q\", err, expectedErr)\n \t}\n }\n+\n type S25ee struct {\n \tF3 string `schema:\"F3\"`\n }\n@@ -2095,14 +2096,13 @@ type S25 struct {\n \tF1 string `schema:\"F1\"`\n }\n \n-func TestDoubleEmbedded(t *testing.T){\n+func TestDoubleEmbedded(t *testing.T) {\n \tdata := map[string][]string{\n \t\t\"F1\": {\"raw a\"},\n \t\t\"F2\": {\"raw b\"},\n \t\t\"F3\": {\"raw c\"},\n \t}\n \n-\t\n \ts := S25{}\n \tdecoder := NewDecoder()\n \n@@ -2412,3 +2412,118 @@ func TestDefaultsAreNotSupportedForStructsAndStructSlices(t *testing.T) {\n \t\tt.Errorf(\"decoding should fail with error msg %s got %q\", expected, err)\n \t}\n }\n+\n+func TestDecoder_MaxSize(t *testing.T) {\n+\tt.Parallel()\n+\n+\ttype Nested struct {\n+\t\tVal          int\n+\t\tNestedValues []struct {\n+\t\t\tNVal int\n+\t\t}\n+\t}\n+\ttype NestedSlices struct {\n+\t\tValues []Nested\n+\t}\n+\n+\ttestcases := []struct {\n+\t\tname            string\n+\t\tmaxSize         int\n+\t\tdecoderInput    func() (dst NestedSlices, src map[string][]string)\n+\t\texpectedDecoded NestedSlices\n+\t\texpectedErr     MultiError\n+\t}{\n+\t\t{\n+\t\t\tname:    \"no error on decoding under max size\",\n+\t\t\tmaxSize: 10,\n+\t\t\tdecoderInput: func() (dst NestedSlices, src map[string][]string) {\n+\t\t\t\treturn dst, map[string][]string{\n+\t\t\t\t\t\"Values.1.Val\":                 {\"132\"},\n+\t\t\t\t\t\"Values.1.NestedValues.1.NVal\": {\"1\"},\n+\t\t\t\t\t\"Values.1.NestedValues.2.NVal\": {\"2\"},\n+\t\t\t\t\t\"Values.1.NestedValues.3.NVal\": {\"3\"},\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\texpectedDecoded: NestedSlices{\n+\t\t\t\tValues: []Nested{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tVal:          0,\n+\t\t\t\t\t\tNestedValues: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tVal: 132, NestedValues: []struct{ NVal int }{\n+\t\t\t\t\t\t\t{NVal: 0},\n+\t\t\t\t\t\t\t{NVal: 1},\n+\t\t\t\t\t\t\t{NVal: 2},\n+\t\t\t\t\t\t\t{NVal: 3},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedErr: nil,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"error on decoding above max size\",\n+\t\t\tmaxSize: 1,\n+\t\t\tdecoderInput: func() (dst NestedSlices, src map[string][]string) {\n+\t\t\t\treturn dst, map[string][]string{\n+\t\t\t\t\t\"Values.1.Val\":                 {\"132\"},\n+\t\t\t\t\t\"Values.1.NestedValues.1.NVal\": {\"1\"},\n+\t\t\t\t\t\"Values.1.NestedValues.2.NVal\": {\"2\"},\n+\t\t\t\t\t\"Values.1.NestedValues.3.NVal\": {\"3\"},\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\texpectedErr: MultiError{\n+\t\t\t\t\"Values.1.NestedValues.2.NVal\": errors.New(\"slice index 2 is larger than the configured maxSize 1\"),\n+\t\t\t\t\"Values.1.NestedValues.3.NVal\": errors.New(\"slice index 3 is larger than the configured maxSize 1\"),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testcases {\n+\t\ttc := tc\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\tdec := NewDecoder()\n+\t\t\tdec.MaxSize(tc.maxSize)\n+\t\t\tdst, src := tc.decoderInput()\n+\t\t\terr := dec.Decode(&dst, src)\n+\n+\t\t\tif tc.expectedErr != nil {\n+\t\t\t\tvar gotErr MultiError\n+\t\t\t\tif !errors.As(err, &gotErr) {\n+\t\t\t\t\tt.Errorf(\"decoder error is not of type %T\", gotErr)\n+\t\t\t\t}\n+\t\t\t\tif !reflect.DeepEqual(gotErr, tc.expectedErr) {\n+\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expectedErr, gotErr)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif !reflect.DeepEqual(dst, tc.expectedDecoded) {\n+\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expectedDecoded, dst)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestDecoder_SetMaxSize(t *testing.T) {\n+\n+\tt.Run(\"default maxsize should be equal to given constant\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tdec := NewDecoder()\n+\t\tif !reflect.DeepEqual(dec.maxSize, defaultMaxSize) {\n+\t\t\tt.Errorf(\"unexpected default max size\")\n+\t\t}\n+\t})\n+\n+\tt.Run(\"configured maxsize should be set properly\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\t\tconfiguredMaxSize := 50\n+\t\tlimitedMaxSizeDecoder := NewDecoder()\n+\t\tlimitedMaxSizeDecoder.MaxSize(configuredMaxSize)\n+\t\tif !reflect.DeepEqual(limitedMaxSizeDecoder.maxSize, configuredMaxSize) {\n+\t\t\tt.Errorf(\"invalid decoder maxsize, expected: %d, got: %d\",\n+\t\t\t\tconfiguredMaxSize, limitedMaxSizeDecoder.maxSize)\n+\t\t}\n+\t})\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff",
            "date": "2024-06-29T20:34:06Z",
            "author_login": "bharat-rajani"
          },
          {
            "sha": "180f71e625073e210314dc8ca83dfbbbd0096dfe",
            "date": "2024-06-03T04:29:40Z",
            "author_login": "morus12"
          },
          {
            "sha": "a377fd6ca77773650ff9d8e6ac1e3fe7eb660bf3",
            "date": "2024-04-16T22:12:45Z",
            "author_login": "lll-lll-lll-lll"
          },
          {
            "sha": "be699f4f1e911a0cf6b80f3844e710c417ad031b",
            "date": "2024-04-16T21:56:32Z",
            "author_login": "lll-lll-lll-lll"
          },
          {
            "sha": "50924ff92dda478a664c6c208ea220301a0c1d68",
            "date": "2024-04-14T02:57:41Z",
            "author_login": "lll-lll-lll-lll"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "gorilla/schema converts structs to and from form values. Prior to version 1.4.1 Running `schema.Decoder.Decode()` on a struct that has a field of type `[]struct{...}` opens it up to malicious attacks regarding memory allocations, taking advantage of the sparse slice functionality. Any use of `schema.Decoder.Decode()` on a struct with arrays of other structs could be vulnerable to this memory exhaustion vulnerability. Version 1.4.1 contains a patch for the issue.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-01T19:15:04.283",
    "last_modified": "2024-11-21T09:23:33.653",
    "fix_date": "2024-06-29T20:34:06Z"
  },
  "references": [
    {
      "url": "https://github.com/gorilla/schema/blob/main/decoder.go#L223",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gorilla/schema/commit/cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gorilla/schema/security/advisories/GHSA-3669-72x9-r9p3",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gorilla/schema/blob/main/decoder.go#L223",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/gorilla/schema/commit/cd59f2f12cbdfa9c06aa63e425d1fe4a806967ff",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/gorilla/schema/security/advisories/GHSA-3669-72x9-r9p3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.880178",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "schema",
    "owner": "gorilla",
    "created_at": "2012-10-02T21:33:46Z",
    "updated_at": "2025-01-12T14:59:11Z",
    "pushed_at": "2024-08-19T14:00:33Z",
    "size": 162,
    "stars": 1397,
    "forks": 232,
    "open_issues": 17,
    "watchers": 1397,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 113180,
      "Makefile": 950
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T18:48:19.730392"
  }
}