{
  "cve_id": "CVE-2024-37904",
  "github_data": {
    "repository": "stacklok/minder",
    "fix_commit": "7979b43",
    "related_commits": [
      "7979b43",
      "7979b43"
    ],
    "patch_url": "https://github.com/stacklok/minder/commit/7979b43.patch",
    "fix_commit_details": {
      "sha": "7979b43",
      "commit_date": "2024-06-12T18:12:22Z",
      "author": {
        "login": "evankanderson",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix Git.Clone after 35bab8f (#3587)",
        "length": 86,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 58,
        "additions": 38,
        "deletions": 20
      },
      "files": [
        {
          "filename": "internal/config/server/provider.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -22,6 +22,7 @@ type ProviderConfig struct {\n \tGit       GitConfig        `mapstructure:\"git\"`\n }\n \n+// GitConfig provides server-side configuration for Git operations like \"clone\"\n type GitConfig struct {\n \tMaxFiles int64 `mapstructure:\"max_files\" default:\"10000\"`\n \tMaxBytes int64 `mapstructure:\"max_bytes\" default:\"100_000_000\"`"
        },
        {
          "filename": "internal/engine/ingester/git/git_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -17,17 +17,17 @@ package git_test\n import (\n \t\"bytes\"\n \t\"context\"\n-\t\"github.com/stacklok/minder/internal/config/server\"\n-\tv1 \"github.com/stacklok/minder/pkg/providers/v1\"\n \t\"testing\"\n \n \t\"github.com/stretchr/testify/require\"\n \n+\t\"github.com/stacklok/minder/internal/config/server\"\n \tengerrors \"github.com/stacklok/minder/internal/engine/errors\"\n \tgitengine \"github.com/stacklok/minder/internal/engine/ingester/git\"\n \t\"github.com/stacklok/minder/internal/providers/credentials\"\n \tgitclient \"github.com/stacklok/minder/internal/providers/git\"\n \tpb \"github.com/stacklok/minder/pkg/api/protobuf/go/minder/v1\"\n+\tv1 \"github.com/stacklok/minder/pkg/providers/v1\"\n )\n \n func TestGitIngestWithCloneURLFromRepo(t *testing.T) {"
        },
        {
          "filename": "internal/providers/git/git.go",
          "status": "modified",
          "additions": 19,
          "deletions": 8,
          "patch": "@@ -19,15 +19,14 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"io/fs\"\n \n \t\"github.com/go-git/go-billy/v5/memfs\"\n-\t\"github.com/go-git/go-git/v5/plumbing/cache\"\n-\t\"github.com/go-git/go-git/v5/storage/filesystem\"\n-\n \t\"github.com/go-git/go-git/v5\"\n \t\"github.com/go-git/go-git/v5/plumbing\"\n+\t\"github.com/go-git/go-git/v5/plumbing/cache\"\n \t\"github.com/go-git/go-git/v5/plumbing/transport\"\n+\t\"github.com/go-git/go-git/v5/storage/filesystem\"\n+\n \t\"github.com/stacklok/minder/internal/config/server\"\n \t\"github.com/stacklok/minder/internal/providers/git/memboxfs\"\n \tminderv1 \"github.com/stacklok/minder/pkg/api/protobuf/go/minder/v1\"\n@@ -46,6 +45,7 @@ const maxCachedObjectSize = 100 * 1024 // 100KiB\n // Ensure that the Git client implements the Git interface\n var _ provifv1.Git = (*Git)(nil)\n \n+// Options implements the \"functional options\" pattern for Git\n type Options func(*Git)\n \n // NewGit creates a new GitHub client\n@@ -59,6 +59,7 @@ func NewGit(token provifv1.GitCredential, opts ...Options) *Git {\n \treturn ret\n }\n \n+// WithConfig configures the Git implementation with server-side configuration options.\n func WithConfig(cfg server.GitConfig) Options {\n \treturn func(g *Git) {\n \t\tg.maxFiles = cfg.MaxFiles\n@@ -97,9 +98,17 @@ func (g *Git) Clone(ctx context.Context, url, branch string) (*git.Repository, e\n \t\t\tTotalFileSize: g.maxBytes,\n \t\t}\n \t}\n+\t// go-git seems to want separate filesystems for the storer and the checked out files\n+\tstorerFs := memfs.New()\n+\tif g.maxFiles != 0 && g.maxBytes != 0 {\n+\t\tstorerFs = &memboxfs.LimitedFs{\n+\t\t\tFs:            storerFs,\n+\t\t\tMaxFiles:      g.maxFiles,\n+\t\t\tTotalFileSize: g.maxBytes,\n+\t\t}\n+\t}\n \tstorerCache := cache.NewObjectLRU(maxCachedObjectSize)\n-\t// reuse same FS for storage and cloned files\n-\tstorer := filesystem.NewStorage(memFS, storerCache)\n+\tstorer := filesystem.NewStorage(storerFs, storerCache)\n \n \t// We clone to the memfs go-billy filesystem driver, which doesn't\n \t// allow for direct access to the underlying filesystem. This is\n@@ -112,8 +121,10 @@ func (g *Git) Clone(ctx context.Context, url, branch string) (*git.Repository, e\n \t\t\treturn nil, provifv1.ErrProviderGitBranchNotFound\n \t\t} else if errors.Is(err, transport.ErrEmptyRemoteRepository) {\n \t\t\treturn nil, provifv1.ErrRepositoryEmpty\n-\t\t} else if errors.Is(err, fs.ErrPermission) {\n-\t\t\treturn nil, provifv1.ErrRepositoryTooLarge\n+\t\t} else if errors.Is(err, memboxfs.ErrTooManyFiles) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %w\", provifv1.ErrRepositoryTooLarge, err)\n+\t\t} else if errors.Is(err, memboxfs.ErrTooBig) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %w\", provifv1.ErrRepositoryTooLarge, err)\n \t\t}\n \t\treturn nil, fmt.Errorf(\"could not clone repo: %w\", err)\n \t}"
        },
        {
          "filename": "internal/providers/git/memboxfs/fs.go",
          "status": "modified",
          "additions": 16,
          "deletions": 10,
          "patch": "@@ -28,17 +28,23 @@ import (\n // LimitedFs provides a size-limited billy.Filesystem.  This is a struct, there's\n // no constructor here. Note that LimitedFs is not thread-safe.\n type LimitedFs struct {\n-\tFs billy.Filesystem\n+\tFs            billy.Filesystem\n \tMaxFiles      int64\n \tTotalFileSize int64\n \n-\tcurrentFiles  int64\n-\tcurrentSize   int64\n+\tcurrentFiles int64\n+\tcurrentSize  int64\n }\n \n // ErrNotImplemented is returned when a method is not implemented.\n var ErrNotImplemented = fmt.Errorf(\"not implemented\")\n \n+// ErrTooBig is returned when a file is too big.\n+var ErrTooBig = fmt.Errorf(\"file too big\")\n+\n+// ErrTooManyFiles is returned when there are too many files.\n+var ErrTooManyFiles = fmt.Errorf(\"too many files\")\n+\n var _ billy.Filesystem = (*LimitedFs)(nil)\n \n // Chroot implements billy.Filesystem.\n@@ -50,7 +56,7 @@ func (_ *LimitedFs) Chroot(_ string) (billy.Filesystem, error) {\n func (f *LimitedFs) Create(filename string) (billy.File, error) {\n \tf.currentFiles++\n \tif f.currentFiles >= f.MaxFiles {\n-\t\treturn nil, fs.ErrPermission\n+\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrTooManyFiles, filename)\n \t}\n \tfile, err := f.Fs.Create(filename)\n \treturn &fileWrapper{f: file, fs: f}, err\n@@ -71,7 +77,7 @@ func (f *LimitedFs) MkdirAll(filename string, perm fs.FileMode) error {\n \t// TODO: account for path segments correctly\n \tf.currentFiles++\n \tif f.currentFiles >= f.MaxFiles {\n-\t\treturn fs.ErrPermission\n+\t\treturn fmt.Errorf(\"%w: %s\", ErrTooManyFiles, filename)\n \t}\n \treturn f.Fs.MkdirAll(filename, perm)\n }\n@@ -86,7 +92,7 @@ func (f *LimitedFs) OpenFile(filename string, flag int, perm fs.FileMode) (billy\n \tif flag&os.O_CREATE != 0 {\n \t\tf.currentFiles++\n \t\tif f.currentFiles >= f.MaxFiles {\n-\t\t\treturn nil, fs.ErrPermission\n+\t\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrTooManyFiles, filename)\n \t\t}\n \t}\n \tfile, err := f.Fs.OpenFile(filename, flag, perm)\n@@ -129,7 +135,7 @@ func (f *LimitedFs) Stat(filename string) (fs.FileInfo, error) {\n func (f *LimitedFs) Symlink(target string, link string) error {\n \tf.currentFiles++\n \tif f.currentFiles >= f.MaxFiles {\n-\t\treturn fs.ErrPermission\n+\t\treturn fmt.Errorf(\"%w: %s\", ErrTooManyFiles, link)\n \t}\n \treturn f.Fs.Symlink(target, link)\n }\n@@ -138,7 +144,7 @@ func (f *LimitedFs) Symlink(target string, link string) error {\n func (f *LimitedFs) TempFile(dir string, prefix string) (billy.File, error) {\n \tf.currentFiles++\n \tif f.currentFiles >= f.MaxFiles {\n-\t\treturn nil, fs.ErrPermission\n+\t\treturn nil, fmt.Errorf(\"%w: %s/%s\", ErrTooManyFiles, dir, prefix)\n \t}\n \tfile, err := f.Fs.TempFile(dir, prefix)\n \treturn &fileWrapper{f: file, fs: f}, err\n@@ -191,7 +197,7 @@ func (f *fileWrapper) Truncate(size int64) error {\n \n \tgrowth := size - existingSize\n \tif growth+f.fs.currentSize > f.fs.TotalFileSize {\n-\t\treturn fs.ErrPermission\n+\t\treturn fmt.Errorf(\"%w: %s\", ErrTooBig, f.Name())\n \t}\n \n \tf.fs.currentSize += growth\n@@ -219,7 +225,7 @@ func (f *fileWrapper) Write(p []byte) (n int, err error) {\n \t\tgrowth = 0\n \t}\n \tif growth+f.fs.currentSize > f.fs.TotalFileSize {\n-\t\treturn 0, fs.ErrPermission\n+\t\treturn 0, fmt.Errorf(\"%w: %s\", ErrTooBig, f.Name())\n \t}\n \n \tf.fs.currentSize += growth"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8373b8030ec90dbde8a19dd9b7a7f5c3639112d3",
            "date": "2025-01-14T11:22:31Z",
            "author_login": "eleftherias"
          },
          {
            "sha": "0a089beb20a3e819fa4b730bf40bac7728164050",
            "date": "2025-01-14T08:53:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "95e9036cf631a5162e31541f2cdecd5bb08c77e6",
            "date": "2025-01-14T08:53:08Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "ca1e9121478cf27cb183e20c3afea7ba980081ba",
            "date": "2025-01-14T08:20:16Z",
            "author_login": "JAORMX"
          },
          {
            "sha": "cc38ccde3608df3370d4eb8e71a12d08f46dde1b",
            "date": "2025-01-14T08:10:17Z",
            "author_login": "JAORMX"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Minder is an open source Software Supply Chain Security Platform. Minder's Git provider is vulnerable to a denial of service from a maliciously configured GitHub repository. The Git provider clones users repositories using the `github.com/go-git/go-git/v5` library on lines `L55-L89`. The Git provider does the following on the lines `L56-L62`. First, it sets the `CloneOptions`, specifying the url, the depth etc. It then validates the options. It then sets up an in-memory filesystem, to which it clones and Finally, it clones the repository. The `(g *Git) Clone()` method is vulnerable to a DoS attack: A Minder user can instruct Minder to clone a large repository which will exhaust memory and crash the Minder server. The root cause of this vulnerability is a combination of the following conditions: 1. Users can control the Git URL which Minder clones, 2. Minder does not enforce a size limit to the repository, 3. Minder clones the entire repository into memory. This issue has been addressed in commit `7979b43` which has been included in release version v0.0.52. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-18T17:15:52.337",
    "last_modified": "2024-11-21T09:24:30.433",
    "fix_date": "2024-06-12T18:12:22Z"
  },
  "references": [
    {
      "url": "https://github.com/stacklok/minder/blob/85985445c8ac3e51f03372e99c7b2f08a6d274aa/internal/providers/git/git.go#L55-L89",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/blob/85985445c8ac3e51f03372e99c7b2f08a6d274aa/internal/providers/git/git.go#L56-L62",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/commit/7979b43",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/security/advisories/GHSA-hpcg-xjq5-g666",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/blob/85985445c8ac3e51f03372e99c7b2f08a6d274aa/internal/providers/git/git.go#L55-L89",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/blob/85985445c8ac3e51f03372e99c7b2f08a6d274aa/internal/providers/git/git.go#L56-L62",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/commit/7979b43",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/stacklok/minder/security/advisories/GHSA-hpcg-xjq5-g666",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.841667",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "minder",
    "owner": "stacklok",
    "created_at": "2023-04-05T16:47:15Z",
    "updated_at": "2025-01-14T15:03:03Z",
    "pushed_at": "2025-01-14T11:22:31Z",
    "size": 129864,
    "stars": 306,
    "forks": 41,
    "open_issues": 125,
    "watchers": 306,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 3893376,
      "PLpgSQL": 125512,
      "Makefile": 14093,
      "Dockerfile": 3059,
      "HTML": 2450,
      "Shell": 1410,
      "Smarty": 538,
      "CSS": 429
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T15:37:25.727886"
  }
}