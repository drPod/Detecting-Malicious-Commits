{
  "cve_id": "CVE-2024-3829",
  "github_data": {
    "repository": "qdrant/qdrant",
    "fix_commit": "ee7a31ec3459a6a4219200234615c1817ab82260",
    "related_commits": [
      "ee7a31ec3459a6a4219200234615c1817ab82260",
      "ee7a31ec3459a6a4219200234615c1817ab82260"
    ],
    "patch_url": "https://github.com/qdrant/qdrant/commit/ee7a31ec3459a6a4219200234615c1817ab82260.patch",
    "fix_commit_details": {
      "sha": "ee7a31ec3459a6a4219200234615c1817ab82260",
      "commit_date": "2024-04-15T13:31:08Z",
      "author": {
        "login": "generall",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix snapshot tar symlinks validation (#4033)",
        "length": 275,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 122,
        "additions": 93,
        "deletions": 29
      },
      "files": [
        {
          "filename": "lib/collection/src/collection/snapshots.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -8,6 +8,7 @@ use tokio::fs;\n use super::Collection;\n use crate::collection::CollectionVersion;\n use crate::common::snapshots_manager::SnapshotStorageManager;\n+use crate::common::validate_snapshot_archive::validate_open_snapshot_archive;\n use crate::config::{CollectionConfig, ShardingMethod};\n use crate::operations::snapshot_ops::SnapshotDescription;\n use crate::operations::types::{CollectionError, CollectionResult, NodeType};\n@@ -187,8 +188,7 @@ impl Collection {\n         is_distributed: bool,\n     ) -> CollectionResult<()> {\n         // decompress archive\n-        let archive_file = std::fs::File::open(snapshot_path)?;\n-        let mut ar = tar::Archive::new(archive_file);\n+        let mut ar = validate_open_snapshot_archive(snapshot_path)?;\n         ar.unpack(target_dir)?;\n \n         let config = CollectionConfig::load(target_dir)?;"
        },
        {
          "filename": "lib/collection/src/common/mod.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -9,3 +9,4 @@ pub mod snapshots_manager;\n pub mod stoppable_task;\n pub mod stoppable_task_async;\n pub mod stopping_guard;\n+pub mod validate_snapshot_archive;"
        },
        {
          "filename": "lib/collection/src/common/validate_snapshot_archive.rs",
          "status": "added",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -0,0 +1,13 @@\n+use std::fs::File;\n+use std::path::Path;\n+\n+use segment::common::validate_snapshot_archive::open_snapshot_archive_with_validation;\n+use tar::Archive;\n+\n+use crate::operations::types::CollectionResult;\n+\n+pub fn validate_open_snapshot_archive<P: AsRef<Path>>(\n+    archive_path: P,\n+) -> CollectionResult<Archive<File>> {\n+    Ok(open_snapshot_archive_with_validation(archive_path)?)\n+}"
        },
        {
          "filename": "lib/collection/src/shards/shard_holder.rs",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -12,6 +12,7 @@ use tokio::sync::RwLock;\n \n use super::replica_set::AbortShardTransfer;\n use super::transfer::transfer_tasks_pool::TransferTasksPool;\n+use crate::common::validate_snapshot_archive::validate_open_snapshot_archive;\n use crate::config::{CollectionConfig, ShardingMethod};\n use crate::hash_ring::HashRing;\n use crate::operations::shard_selector_internal::ShardSelectorInternal;\n@@ -802,14 +803,13 @@ impl ShardHolder {\n             return Err(shard_not_found_error(shard_id));\n         }\n \n-        let snapshot = std::fs::File::open(snapshot_path)?;\n-\n         if !temp_dir.exists() {\n             std::fs::create_dir_all(temp_dir)?;\n         }\n \n         let snapshot_file_name = snapshot_path.file_name().unwrap().to_string_lossy();\n \n+        let snapshot_path = snapshot_path.to_path_buf();\n         let snapshot_temp_dir = tempfile::Builder::new()\n             .prefix(&format!(\n                 \"{collection_name}-shard-{shard_id}-{snapshot_file_name}\"\n@@ -822,7 +822,7 @@ impl ShardHolder {\n             cancel::blocking::spawn_cancel_on_token(\n                 cancel.child_token(),\n                 move |cancel| -> CollectionResult<_> {\n-                    let mut tar = tar::Archive::new(snapshot);\n+                    let mut tar = validate_open_snapshot_archive(snapshot_path)?;\n \n                     if cancel.is_cancelled() {\n                         return Err(cancel::Error::Cancelled.into());"
        },
        {
          "filename": "lib/collection/src/tests/snapshot_test.rs",
          "status": "modified",
          "additions": 21,
          "deletions": 12,
          "patch": "@@ -72,10 +72,7 @@ async fn _test_snapshot_collection(node_type: NodeType) {\n \n     let snapshots_path = Builder::new().prefix(\"test_snapshots\").tempdir().unwrap();\n     let collection_dir = Builder::new().prefix(\"test_collection\").tempdir().unwrap();\n-    let recover_dir = Builder::new()\n-        .prefix(\"test_collection_rec\")\n-        .tempdir()\n-        .unwrap();\n+\n     let collection_name = \"test\".to_string();\n     let collection_name_rec = \"test_rec\".to_string();\n     let mut shards = HashMap::new();\n@@ -115,14 +112,26 @@ async fn _test_snapshot_collection(node_type: NodeType) {\n         .unwrap();\n \n     assert_eq!(snapshot_description.checksum.unwrap().len(), 64);\n-    // Do not recover in local mode if some shards are remote\n-    assert!(Collection::restore_snapshot(\n-        &snapshots_path.path().join(&snapshot_description.name),\n-        recover_dir.path(),\n-        0,\n-        false,\n-    )\n-    .is_err());\n+\n+    {\n+        let recover_dir = Builder::new()\n+            .prefix(\"test_collection_rec\")\n+            .tempdir()\n+            .unwrap();\n+        // Do not recover in local mode if some shards are remote\n+        assert!(Collection::restore_snapshot(\n+            &snapshots_path.path().join(&snapshot_description.name),\n+            recover_dir.path(),\n+            0,\n+            false,\n+        )\n+        .is_err());\n+    }\n+\n+    let recover_dir = Builder::new()\n+        .prefix(\"test_collection_rec\")\n+        .tempdir()\n+        .unwrap();\n \n     if let Err(err) = Collection::restore_snapshot(\n         &snapshots_path.path().join(snapshot_description.name),"
        },
        {
          "filename": "lib/segment/src/common/mod.rs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@ pub mod rocksdb_buffered_delete_wrapper;\n pub mod rocksdb_buffered_update_wrapper;\n pub mod rocksdb_wrapper;\n pub mod utils;\n+pub mod validate_snapshot_archive;\n pub mod vector_utils;\n pub mod version;\n "
        },
        {
          "filename": "lib/segment/src/common/validate_snapshot_archive.rs",
          "status": "added",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -0,0 +1,45 @@\n+use std::fs::File;\n+use std::path::Path;\n+\n+use tar::Archive;\n+\n+use crate::common::operation_error::{OperationError, OperationResult};\n+\n+pub fn open_snapshot_archive_with_validation<P: AsRef<Path>>(\n+    snapshot_path: P,\n+) -> OperationResult<Archive<File>> {\n+    let path = snapshot_path.as_ref();\n+    {\n+        let archive_file = File::open(path).map_err(|err| {\n+            OperationError::service_error(format!(\n+                \"failed to open segment snapshot archive {path:?}: {err}\"\n+            ))\n+        })?;\n+        let mut ar = Archive::new(archive_file);\n+\n+        for entry in ar.entries_with_seek()? {\n+            let entry_type = entry?.header().entry_type();\n+            if !matches!(\n+                entry_type,\n+                tar::EntryType::Regular | tar::EntryType::Directory,\n+            ) {\n+                return Err(OperationError::ValidationError {\n+                    description: format!(\n+                        \"Malformed snapshot, tar archive contains {entry_type:?} entry\",\n+                    ),\n+                });\n+            }\n+        }\n+    }\n+\n+    let archive_file = File::open(path).map_err(|err| {\n+        OperationError::service_error(format!(\n+            \"failed to open segment snapshot archive {path:?}: {err}\"\n+        ))\n+    })?;\n+\n+    let mut ar = Archive::new(archive_file);\n+    ar.set_overwrite(false);\n+\n+    Ok(ar)\n+}"
        },
        {
          "filename": "lib/segment/src/segment.rs",
          "status": "modified",
          "additions": 5,
          "deletions": 10,
          "patch": "@@ -21,6 +21,7 @@ use crate::common::operation_error::OperationError::TypeInferenceError;\n use crate::common::operation_error::{\n     get_service_error, OperationError, OperationResult, SegmentFailedState,\n };\n+use crate::common::validate_snapshot_archive::open_snapshot_archive_with_validation;\n use crate::common::version::{StorageVersion, VERSION_FILE};\n use crate::common::{check_named_vectors, check_query_vectors, check_stopped, check_vector_name};\n use crate::data_types::named_vectors::NamedVectors;\n@@ -474,20 +475,14 @@ impl Segment {\n     pub fn restore_snapshot(snapshot_path: &Path, segment_id: &str) -> OperationResult<()> {\n         let segment_path = snapshot_path.parent().unwrap().join(segment_id);\n \n-        let archive_file = File::open(snapshot_path).map_err(|err| {\n+        let mut archive = open_snapshot_archive_with_validation(snapshot_path)?;\n+\n+        archive.unpack(&segment_path).map_err(|err| {\n             OperationError::service_error(format!(\n-                \"failed to open segment snapshot archive {snapshot_path:?}: {err}\"\n+                \"failed to unpack segment snapshot archive {snapshot_path:?}: {err}\"\n             ))\n         })?;\n \n-        tar::Archive::new(archive_file)\n-            .unpack(&segment_path)\n-            .map_err(|err| {\n-                OperationError::service_error(format!(\n-                    \"failed to unpack segment snapshot archive {snapshot_path:?}: {err}\"\n-                ))\n-            })?;\n-\n         let snapshot_path = segment_path.join(SNAPSHOT_PATH);\n \n         if snapshot_path.exists() {"
        },
        {
          "filename": "src/snapshots.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2,6 +2,7 @@ use std::fs::{self, remove_dir_all, rename};\n use std::path::{Path, PathBuf};\n \n use collection::collection::Collection;\n+use collection::common::validate_snapshot_archive::validate_open_snapshot_archive;\n use collection::shards::shard::PeerId;\n use log::info;\n use storage::content_manager::alias_mapping::AliasPersistence;\n@@ -94,8 +95,7 @@ pub fn recover_full_snapshot(\n     fs::create_dir_all(&snapshot_temp_path).unwrap();\n \n     // Un-tar snapshot into temporary directory\n-    let archive_file = fs::File::open(snapshot_path).unwrap();\n-    let mut ar = tar::Archive::new(archive_file);\n+    let mut ar = validate_open_snapshot_archive(snapshot_path).unwrap();\n     ar.unpack(&snapshot_temp_path).unwrap();\n \n     // Read configuration file with snapshot-to-collection mapping"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 7,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e545b6964b328b1ab1964c4656d077e4f7680034",
            "date": "2025-01-08T14:43:27Z",
            "author_login": "timvisee"
          },
          {
            "sha": "7ea41c794da98cb4bd9e457445d27f840659e013",
            "date": "2025-01-08T13:32:23Z",
            "author_login": "IvanPleshkov"
          },
          {
            "sha": "d841d7dbe60831083dafb07e93c79278fcd365a1",
            "date": "2025-01-08T12:51:15Z",
            "author_login": "IvanPleshkov"
          },
          {
            "sha": "157ef24cb2ad5714e13ef95dd60f327b8ef269de",
            "date": "2025-01-08T09:58:47Z",
            "author_login": "IvanPleshkov"
          },
          {
            "sha": "472f8e0a7167c49a2ec18064b757f0fbb8bfbd67",
            "date": "2025-01-07T20:45:09Z",
            "author_login": "generall"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-20",
    "description": "qdrant/qdrant version 1.9.0-dev is vulnerable to arbitrary file read and write during the snapshot recovery process. Attackers can exploit this vulnerability by manipulating snapshot files to include symlinks, leading to arbitrary file read by adding a symlink that points to a desired file on the filesystem and arbitrary file write by including a symlink and a payload file in the snapshot's directory structure. This vulnerability allows for the reading and writing of arbitrary files on the server, which could potentially lead to a full takeover of the system. The issue is fixed in version v1.9.0.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-06-03T10:15:14.267",
    "last_modified": "2024-11-21T09:30:29.107",
    "fix_date": "2024-04-15T13:31:08Z"
  },
  "references": [
    {
      "url": "https://github.com/qdrant/qdrant/commit/ee7a31ec3459a6a4219200234615c1817ab82260",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/abd9c906-75ee-4d84-b76d-ce1386401e08",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/qdrant/qdrant/commit/ee7a31ec3459a6a4219200234615c1817ab82260",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/abd9c906-75ee-4d84-b76d-ce1386401e08",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:26.333006",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "qdrant",
    "owner": "qdrant",
    "created_at": "2020-05-30T21:37:01Z",
    "updated_at": "2025-01-14T14:17:13Z",
    "pushed_at": "2025-01-14T14:15:51Z",
    "size": 27075,
    "stars": 21340,
    "forks": 1464,
    "open_issues": 358,
    "watchers": 21340,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Rust": 7514996,
      "Python": 911220,
      "Shell": 91875,
      "C": 16974,
      "Dockerfile": 7599,
      "Nix": 5997,
      "JavaScript": 1502,
      "Mermaid": 970
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:26:34.529008"
  }
}