{
  "cve_id": "CVE-2024-38513",
  "github_data": {
    "repository": "gofiber/fiber",
    "fix_commit": "66a881441b27322a331f1b526cf1eb6b3358a4d8",
    "related_commits": [
      "66a881441b27322a331f1b526cf1eb6b3358a4d8",
      "66a881441b27322a331f1b526cf1eb6b3358a4d8"
    ],
    "patch_url": "https://github.com/gofiber/fiber/commit/66a881441b27322a331f1b526cf1eb6b3358a4d8.patch",
    "fix_commit_details": {
      "sha": "66a881441b27322a331f1b526cf1eb6b3358a4d8",
      "commit_date": "2024-06-30T19:16:23Z",
      "author": {
        "login": "sixcolors",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix(middleware/session): mutex for thread safety (#3050)",
        "length": 400,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 300,
        "additions": 276,
        "deletions": 24
      },
      "files": [
        {
          "filename": "middleware/session/session.go",
          "status": "modified",
          "additions": 41,
          "deletions": 8,
          "patch": "@@ -14,6 +14,7 @@ import (\n )\n \n type Session struct {\n+\tmu         sync.RWMutex  // Mutex to protect non-data fields\n \tid         string        // session id\n \tfresh      bool          // if new session\n \tctx        *fiber.Ctx    // fiber context\n@@ -42,6 +43,7 @@ func acquireSession() *Session {\n }\n \n func releaseSession(s *Session) {\n+\ts.mu.Lock()\n \ts.id = \"\"\n \ts.exp = 0\n \ts.ctx = nil\n@@ -52,16 +54,21 @@ func releaseSession(s *Session) {\n \tif s.byteBuffer != nil {\n \t\ts.byteBuffer.Reset()\n \t}\n+\ts.mu.Unlock()\n \tsessionPool.Put(s)\n }\n \n // Fresh is true if the current session is new\n func (s *Session) Fresh() bool {\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n \treturn s.fresh\n }\n \n // ID returns the session id\n func (s *Session) ID() string {\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n \treturn s.id\n }\n \n@@ -102,6 +109,9 @@ func (s *Session) Destroy() error {\n \t// Reset local data\n \ts.data.Reset()\n \n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\n \t// Use external Storage if exist\n \tif err := s.config.Storage.Delete(s.id); err != nil {\n \t\treturn err\n@@ -114,6 +124,9 @@ func (s *Session) Destroy() error {\n \n // Regenerate generates a new session id and delete the old one from Storage\n func (s *Session) Regenerate() error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n \t// Delete old id from storage\n \tif err := s.config.Storage.Delete(s.id); err != nil {\n \t\treturn err\n@@ -131,6 +144,10 @@ func (s *Session) Reset() error {\n \tif s.data != nil {\n \t\ts.data.Reset()\n \t}\n+\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n \t// Reset byte buffer\n \tif s.byteBuffer != nil {\n \t\ts.byteBuffer.Reset()\n@@ -154,20 +171,24 @@ func (s *Session) Reset() error {\n \n // refresh generates a new session, and set session.fresh to be true\n func (s *Session) refresh() {\n-\t// Create a new id\n \ts.id = s.config.KeyGenerator()\n-\n-\t// We assign a new id to the session, so the session must be fresh\n \ts.fresh = true\n }\n \n // Save will update the storage and client cookie\n+//\n+// sess.Save() will save the session data to the storage and update the\n+// client cookie, and it will release the session after saving.\n+//\n+// It's not safe to use the session after calling Save().\n func (s *Session) Save() error {\n \t// Better safe than sorry\n \tif s.data == nil {\n \t\treturn nil\n \t}\n \n+\ts.mu.Lock()\n+\n \t// Check if session has your own expiration, otherwise use default value\n \tif s.exp <= 0 {\n \t\ts.exp = s.config.Expiration\n@@ -177,25 +198,25 @@ func (s *Session) Save() error {\n \ts.setSession()\n \n \t// Convert data to bytes\n-\tmux.Lock()\n-\tdefer mux.Unlock()\n \tencCache := gob.NewEncoder(s.byteBuffer)\n \terr := encCache.Encode(&s.data.Data)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to encode data: %w\", err)\n \t}\n \n-\t// copy the data in buffer\n+\t// Copy the data in buffer\n \tencodedBytes := make([]byte, s.byteBuffer.Len())\n \tcopy(encodedBytes, s.byteBuffer.Bytes())\n \n-\t// pass copied bytes with session id to provider\n+\t// Pass copied bytes with session id to provider\n \tif err := s.config.Storage.Set(s.id, encodedBytes, s.exp); err != nil {\n \t\treturn err\n \t}\n \n+\ts.mu.Unlock()\n+\n \t// Release session\n-\t// TODO: It's not safe to use the Session after called Save()\n+\t// TODO: It's not safe to use the Session after calling Save()\n \treleaseSession(s)\n \n \treturn nil\n@@ -211,6 +232,8 @@ func (s *Session) Keys() []string {\n \n // SetExpiry sets a specific expiration for this session\n func (s *Session) SetExpiry(exp time.Duration) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n \ts.exp = exp\n }\n \n@@ -276,3 +299,13 @@ func (s *Session) delSession() {\n \t\tfasthttp.ReleaseCookie(fcookie)\n \t}\n }\n+\n+// decodeSessionData decodes the session data from raw bytes.\n+func (s *Session) decodeSessionData(rawData []byte) error {\n+\t_, _ = s.byteBuffer.Write(rawData) //nolint:errcheck // This will never fail\n+\tencCache := gob.NewDecoder(s.byteBuffer)\n+\tif err := encCache.Decode(&s.data.Data); err != nil {\n+\t\treturn fmt.Errorf(\"failed to decode session data: %w\", err)\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "middleware/session/session_test.go",
          "status": "modified",
          "additions": 229,
          "deletions": 0,
          "patch": "@@ -1,6 +1,8 @@\n package session\n \n import (\n+\t\"errors\"\n+\t\"sync\"\n \t\"testing\"\n \t\"time\"\n \n@@ -673,3 +675,230 @@ func Benchmark_Session(b *testing.B) {\n \t\tutils.AssertEqual(b, nil, err)\n \t})\n }\n+\n+// go test -v -run=^$ -bench=Benchmark_Session_Parallel -benchmem -count=4\n+func Benchmark_Session_Parallel(b *testing.B) {\n+\tb.Run(\"default\", func(b *testing.B) {\n+\t\tapp, store := fiber.New(), New()\n+\t\tb.ReportAllocs()\n+\t\tb.ResetTimer()\n+\t\tb.RunParallel(func(pb *testing.PB) {\n+\t\t\tfor pb.Next() {\n+\t\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\t\t\tc.Request().Header.SetCookie(store.sessionName, \"12356789\")\n+\n+\t\t\t\tsess, _ := store.Get(c) //nolint:errcheck // We're inside a benchmark\n+\t\t\t\tsess.Set(\"john\", \"doe\")\n+\t\t\t\t_ = sess.Save() //nolint:errcheck // We're inside a benchmark\n+\t\t\t\tapp.ReleaseCtx(c)\n+\t\t\t}\n+\t\t})\n+\t})\n+\n+\tb.Run(\"storage\", func(b *testing.B) {\n+\t\tapp := fiber.New()\n+\t\tstore := New(Config{\n+\t\t\tStorage: memory.New(),\n+\t\t})\n+\t\tb.ReportAllocs()\n+\t\tb.ResetTimer()\n+\t\tb.RunParallel(func(pb *testing.PB) {\n+\t\t\tfor pb.Next() {\n+\t\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\t\t\tc.Request().Header.SetCookie(store.sessionName, \"12356789\")\n+\n+\t\t\t\tsess, _ := store.Get(c) //nolint:errcheck // We're inside a benchmark\n+\t\t\t\tsess.Set(\"john\", \"doe\")\n+\t\t\t\t_ = sess.Save() //nolint:errcheck // We're inside a benchmark\n+\t\t\t\tapp.ReleaseCtx(c)\n+\t\t\t}\n+\t\t})\n+\t})\n+}\n+\n+// go test -v -run=^$ -bench=Benchmark_Session_Asserted -benchmem -count=4\n+func Benchmark_Session_Asserted(b *testing.B) {\n+\tb.Run(\"default\", func(b *testing.B) {\n+\t\tapp, store := fiber.New(), New()\n+\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\tdefer app.ReleaseCtx(c)\n+\t\tc.Request().Header.SetCookie(store.sessionName, \"12356789\")\n+\n+\t\tb.ReportAllocs()\n+\t\tb.ResetTimer()\n+\t\tfor n := 0; n < b.N; n++ {\n+\t\t\tsess, err := store.Get(c)\n+\t\t\tutils.AssertEqual(b, nil, err)\n+\t\t\tsess.Set(\"john\", \"doe\")\n+\t\t\terr = sess.Save()\n+\t\t\tutils.AssertEqual(b, nil, err)\n+\t\t}\n+\t})\n+\n+\tb.Run(\"storage\", func(b *testing.B) {\n+\t\tapp := fiber.New()\n+\t\tstore := New(Config{\n+\t\t\tStorage: memory.New(),\n+\t\t})\n+\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\tdefer app.ReleaseCtx(c)\n+\t\tc.Request().Header.SetCookie(store.sessionName, \"12356789\")\n+\n+\t\tb.ReportAllocs()\n+\t\tb.ResetTimer()\n+\t\tfor n := 0; n < b.N; n++ {\n+\t\t\tsess, err := store.Get(c)\n+\t\t\tutils.AssertEqual(b, nil, err)\n+\t\t\tsess.Set(\"john\", \"doe\")\n+\t\t\terr = sess.Save()\n+\t\t\tutils.AssertEqual(b, nil, err)\n+\t\t}\n+\t})\n+}\n+\n+// go test -v -run=^$ -bench=Benchmark_Session_Asserted_Parallel -benchmem -count=4\n+func Benchmark_Session_Asserted_Parallel(b *testing.B) {\n+\tb.Run(\"default\", func(b *testing.B) {\n+\t\tapp, store := fiber.New(), New()\n+\t\tb.ReportAllocs()\n+\t\tb.ResetTimer()\n+\t\tb.RunParallel(func(pb *testing.PB) {\n+\t\t\tfor pb.Next() {\n+\t\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\t\t\tc.Request().Header.SetCookie(store.sessionName, \"12356789\")\n+\n+\t\t\t\tsess, err := store.Get(c)\n+\t\t\t\tutils.AssertEqual(b, nil, err)\n+\t\t\t\tsess.Set(\"john\", \"doe\")\n+\t\t\t\tutils.AssertEqual(b, nil, sess.Save())\n+\t\t\t\tapp.ReleaseCtx(c)\n+\t\t\t}\n+\t\t})\n+\t})\n+\n+\tb.Run(\"storage\", func(b *testing.B) {\n+\t\tapp := fiber.New()\n+\t\tstore := New(Config{\n+\t\t\tStorage: memory.New(),\n+\t\t})\n+\t\tb.ReportAllocs()\n+\t\tb.ResetTimer()\n+\t\tb.RunParallel(func(pb *testing.PB) {\n+\t\t\tfor pb.Next() {\n+\t\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\t\t\tc.Request().Header.SetCookie(store.sessionName, \"12356789\")\n+\n+\t\t\t\tsess, err := store.Get(c)\n+\t\t\t\tutils.AssertEqual(b, nil, err)\n+\t\t\t\tsess.Set(\"john\", \"doe\")\n+\t\t\t\tutils.AssertEqual(b, nil, sess.Save())\n+\t\t\t\tapp.ReleaseCtx(c)\n+\t\t\t}\n+\t\t})\n+\t})\n+}\n+\n+// go test -v -race -run Test_Session_Concurrency ./...\n+func Test_Session_Concurrency(t *testing.T) {\n+\tt.Parallel()\n+\tapp := fiber.New()\n+\tstore := New()\n+\n+\tvar wg sync.WaitGroup\n+\terrChan := make(chan error, 10) // Buffered channel to collect errors\n+\tconst numGoroutines = 10        // Number of concurrent goroutines to test\n+\n+\t// Start numGoroutines goroutines\n+\tfor i := 0; i < numGoroutines; i++ {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\n+\t\t\tlocalCtx := app.AcquireCtx(&fasthttp.RequestCtx{})\n+\n+\t\t\tsess, err := store.Get(localCtx)\n+\t\t\tif err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Set a value\n+\t\t\tsess.Set(\"name\", \"john\")\n+\n+\t\t\t// get the session id\n+\t\t\tid := sess.ID()\n+\n+\t\t\t// Check if the session is fresh\n+\t\t\tif !sess.Fresh() {\n+\t\t\t\terrChan <- errors.New(\"session should be fresh\")\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Save the session\n+\t\t\tif err := sess.Save(); err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Release the context\n+\t\t\tapp.ReleaseCtx(localCtx)\n+\n+\t\t\t// Acquire a new context\n+\t\t\tlocalCtx = app.AcquireCtx(&fasthttp.RequestCtx{})\n+\t\t\tdefer app.ReleaseCtx(localCtx)\n+\n+\t\t\t// Set the session id in the header\n+\t\t\tlocalCtx.Request().Header.SetCookie(store.sessionName, id)\n+\n+\t\t\t// Get the session\n+\t\t\tsess, err = store.Get(localCtx)\n+\t\t\tif err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Get the value\n+\t\t\tname := sess.Get(\"name\")\n+\t\t\tif name != \"john\" {\n+\t\t\t\terrChan <- errors.New(\"name should be john\")\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Get ID from the session\n+\t\t\tif sess.ID() != id {\n+\t\t\t\terrChan <- errors.New(\"id should be the same\")\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Check if the session is fresh\n+\t\t\tif sess.Fresh() {\n+\t\t\t\terrChan <- errors.New(\"session should not be fresh\")\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Delete the key\n+\t\t\tsess.Delete(\"name\")\n+\n+\t\t\t// Get the value\n+\t\t\tname = sess.Get(\"name\")\n+\t\t\tif name != nil {\n+\t\t\t\terrChan <- errors.New(\"name should be nil\")\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Destroy the session\n+\t\t\tif err := sess.Destroy(); err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\twg.Wait()      // Wait for all goroutines to finish\n+\tclose(errChan) // Close the channel to signal no more errors will be sent\n+\n+\t// Check for errors sent to errChan\n+\tfor err := range errChan {\n+\t\tutils.AssertEqual(t, nil, err)\n+\t}\n+}"
        },
        {
          "filename": "middleware/session/store.go",
          "status": "modified",
          "additions": 6,
          "deletions": 16,
          "patch": "@@ -4,7 +4,6 @@ import (\n \t\"encoding/gob\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"sync\"\n \n \t\"github.com/gofiber/fiber/v2\"\n \t\"github.com/gofiber/fiber/v2/internal/storage/memory\"\n@@ -14,9 +13,6 @@ import (\n // ErrEmptySessionID is an error that occurs when the session ID is empty.\n var ErrEmptySessionID = errors.New(\"session id cannot be empty\")\n \n-// mux is a global mutex for session operations.\n-var mux sync.Mutex\n-\n // sessionIDKey is the local key type used to store and retrieve the session ID in context.\n type sessionIDKey int\n \n@@ -81,13 +77,19 @@ func (s *Store) Get(c *fiber.Ctx) (*Session, error) {\n \n \t// Create session object\n \tsess := acquireSession()\n+\n+\tsess.mu.Lock()\n+\tdefer sess.mu.Unlock()\n+\n \tsess.ctx = c\n \tsess.config = s\n \tsess.id = id\n \tsess.fresh = fresh\n \n \t// Decode session data if found\n \tif rawData != nil {\n+\t\tsess.data.Lock()\n+\t\tdefer sess.data.Unlock()\n \t\tif err := sess.decodeSessionData(rawData); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to decode session data: %w\", err)\n \t\t}\n@@ -132,15 +134,3 @@ func (s *Store) Delete(id string) error {\n \t}\n \treturn s.Storage.Delete(id)\n }\n-\n-// decodeSessionData decodes the session data from raw bytes.\n-func (s *Session) decodeSessionData(rawData []byte) error {\n-\tmux.Lock()\n-\tdefer mux.Unlock()\n-\t_, _ = s.byteBuffer.Write(rawData) //nolint:errcheck // This will never fail\n-\tencCache := gob.NewDecoder(s.byteBuffer)\n-\tif err := encCache.Decode(&s.data.Data); err != nil {\n-\t\treturn fmt.Errorf(\"failed to decode session data: %w\", err)\n-\t}\n-\treturn nil\n-}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "44b971ace579437b8792025ec14e972630386b90",
            "date": "2025-01-14T02:37:29Z",
            "author_login": "gaby"
          },
          {
            "sha": "4e5fea1d7a830a52cbe736d2da88660a2e959549",
            "date": "2025-01-13T13:18:03Z",
            "author_login": "grivera64"
          },
          {
            "sha": "6c7473b842148a0a59bc2c0d511f330373fa3fde",
            "date": "2025-01-10T12:46:21Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "bc37f209bfef66d8ff84dc7d13dc066107eb3d9c",
            "date": "2025-01-08T07:19:20Z",
            "author_login": "ReneWerner87"
          },
          {
            "sha": "86d72bbba8b5998bb4583f3bff110ede1391d795",
            "date": "2025-01-07T18:20:53Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 10.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-384",
    "description": "Fiber is an Express-inspired web framework written in Go A vulnerability present in versions prior to 2.52.5 is a session middleware issue in GoFiber versions 2 and above. This vulnerability allows users to supply their own session_id value, resulting in the creation of a session with that key. If a website relies on the mere presence of a session for security purposes, this can lead to significant security risks, including unauthorized access and session fixation attacks. All users utilizing GoFiber's session middleware in the affected versions are impacted. The issue has been addressed in version 2.52.5. Users are strongly encouraged to upgrade to version 2.52.5 or higher to mitigate this vulnerability. Users who are unable to upgrade immediately can apply the following workarounds to reduce the risk: Either implement additional validation to ensure session IDs are not supplied by the user and are securely generated by the server, or regularly rotate session IDs and enforce strict session expiration policies.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-01T19:15:05.173",
    "last_modified": "2024-11-21T09:26:08.203",
    "fix_date": "2024-06-30T19:16:23Z"
  },
  "references": [
    {
      "url": "https://github.com/gofiber/fiber/commit/66a881441b27322a331f1b526cf1eb6b3358a4d8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/security/advisories/GHSA-98j2-3j3p-fw2v",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/commit/66a881441b27322a331f1b526cf1eb6b3358a4d8",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/gofiber/fiber/security/advisories/GHSA-98j2-3j3p-fw2v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.880480",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fiber",
    "owner": "gofiber",
    "created_at": "2020-01-16T03:59:20Z",
    "updated_at": "2025-01-14T12:32:36Z",
    "pushed_at": "2025-01-14T02:37:36Z",
    "size": 229934,
    "stars": 34637,
    "forks": 1696,
    "open_issues": 100,
    "watchers": 34637,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "v2"
    ],
    "languages": {
      "Go": 1562365,
      "Makefile": 1868
    },
    "commit_activity": {
      "total_commits_last_year": 253,
      "avg_commits_per_week": 4.865384615384615,
      "days_active_last_year": 141
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:42:58.049694"
  }
}