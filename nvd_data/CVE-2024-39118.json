{
  "cve_id": "CVE-2024-39118",
  "github_data": {
    "repository": "MommyHeather/AdvancedBackups",
    "fix_commit": "1545f499f73bf434ed292c31121fdda8042ff5d6",
    "related_commits": [
      "1545f499f73bf434ed292c31121fdda8042ff5d6",
      "1545f499f73bf434ed292c31121fdda8042ff5d6"
    ],
    "patch_url": "https://github.com/MommyHeather/AdvancedBackups/commit/1545f499f73bf434ed292c31121fdda8042ff5d6.patch",
    "fix_commit_details": {
      "sha": "1545f499f73bf434ed292c31121fdda8042ff5d6",
      "commit_date": "2024-06-16T00:47:11Z",
      "author": {
        "login": "HeatherComputer",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix a zip slip bug",
        "length": 18,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 1874,
        "additions": 968,
        "deletions": 906
      },
      "files": [
        {
          "filename": "src/main/java/co/uk/mommyheather/advancedbackups/cli/AdvancedBackupsCLI.java",
          "status": "modified",
          "additions": 959,
          "deletions": 906,
          "patch": "@@ -1,906 +1,959 @@\n-package co.uk.mommyheather.advancedbackups.cli;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.InputMismatchException;\n-import java.util.List;\n-import java.util.Properties;\n-import java.util.regex.Pattern;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n-\n-import org.fusesource.jansi.AnsiConsole;\n-\n-public class AdvancedBackupsCLI {\n-\n-    private static String backupLocation;\n-    private static File serverDir = new File(new File(\"\").toPath().toAbsolutePath().getParent().toString());\n-    private static String type;\n-    private static ArrayList<String> fileNames = new ArrayList<>();\n-    private static File worldFile;\n-    private static String worldPath;\n-    public static void main(String args[]){\n-        \n-        \n-\n-        if (System.console() != null) {\n-            AnsiConsole.systemInstall(); //this gets ansi escape codes working on windows. this was a FUCKING PAIN IN MY ASS\n-        }\n-        \n-        System.out.print(\"\\033[H\\033[2J\");\n-        System.out.flush();\n-        \n-         \n-        CLIIOHelpers.info(\"Advanced Backups - Version \" + AdvancedBackupsCLI.class.getPackage().getImplementationVersion());\n-        CLIIOHelpers.info(\"Note : this cannot restore backups made prior to the 3.0 release.\");\n-        CLIIOHelpers.info(\"Searching for properties...\", false);\n-\n-        \n-        Properties props = new Properties();\n-        File file = new File(serverDir, \"config/AdvancedBackups.properties\");\n-        FileReader reader;\n-        try {\n-            reader = new FileReader(file);   \n-            props.load(reader);\n-\n-            backupLocation = props.getProperty(\"config.advancedbackups.path\");\n-            type = props.getProperty(\"config.advancedbackups.type\");\n-        } catch (Exception e) {\n-            CLIIOHelpers.error(\"ERROR LOADING PROPERTIES!\");\n-            CLIIOHelpers.error(getStackTrace(e));\n-            CLIIOHelpers.error(\"\");\n-            CLIIOHelpers.error(\"\");\n-            CLIIOHelpers.error(\"Ensure you're running this from within the mods directory, and the config file is in the parent directory!\");\n-            // Fatal, cannot proceed\n-            return;\n-        }\n-\n-        if (backupLocation == null || type == null) {\n-            CLIIOHelpers.error(\"ERROR LOADING PROPERTIES!\");\n-            CLIIOHelpers.error(\"Backup location : \" + backupLocation);\n-            CLIIOHelpers.error(\"Type : \" + type);\n-            // Fatal, cannot proceed\n-            return;\n-        }\n-\n-        CLIIOHelpers.info(\"Config loaded!\");\n-\n-        //What's a good way to check between absolute and relative? Not all absolute paths will start with /..\n-        File backupDir = new File(serverDir, backupLocation.replaceAll(Pattern.quote(\".\" + File.separator), \"\"));\n-\n-        if (!backupDir.exists()) {\n-            //Is it absolute?\n-            backupDir = new File(backupLocation.replaceAll(Pattern.quote(\".\" + File.separator), \"\"));\n-            if (!backupDir.exists()) {\n-                CLIIOHelpers.error(\"Could not find backup directory!\");\n-                CLIIOHelpers.error(backupDir.getAbsolutePath());\n-                CLIIOHelpers.error(\"Have you made any backups before?\");\n-                //Fatal, cannot continue\n-                return;\n-            }\n-        }\n-\n-        \n-        //check for backups from \"other mods\"\n-        boolean flag = false;\n-        ArrayList<File> otherBackups = new ArrayList<>();\n-        for (File b : backupDir.listFiles()) {\n-            if (b.getName().endsWith(\"zip\")) {\n-                flag = true;\n-                otherBackups.add(b);\n-            }\n-\n-        }\n-\n-        if (flag) {\n-            String result = CLIIOHelpers.getSelectionFromList(\"Backups from another mod have been found. These can be restored if you want.\\nWould you want to work with these backups?\", \n-            Arrays.asList(new String[]{\"Use backups from AdvancedBackups\", \"Use backups from other mod\"}));\n-            if (result == \"Use backups from other mod\") {\n-                restoreOtherModZip(backupDir);\n-                return;\n-            }\n-        }\n-\n-        type = CLIIOHelpers.getBackupType(type);\n-        if (type.equals(\"snapshot (command-made only)\")) type = \"snapshots\";\n-\n-        /*/\n-        if (backupLocation.startsWith(Pattern.quote(File.separator)) || backupLocation.indexOf(\":\") == 1) {\n-            backupDir = new File(backupLocation, File.separator + type + File.separator);\n-        }\n-        else {\n-            backupDir = new File(serverDir, backupLocation.replaceAll(Pattern.quote(\".\" + File.separator), \"\") + File.separator + type + File.separator);\n-        }\n-*/\n-        \n-               \n-        boolean exportMode = false;\n-        int backupDateIndex;\n-\n-        \n-\n-        CLIIOHelpers.info(\"Do you want to export a backup, restore the entire world state at this point, or a singular file?\");\n-\n-        String restore = CLIIOHelpers.getSelectionFromList(\"Enter a number.\",\n-            Arrays.asList(new String[]{\"Export backup as zip\", \"Restore single file\", \"Restore entire world\"}));\n-        \n-            \n-        if (restore.equals(\"Export backup as zip\")) {\n-            exportMode = true;\n-        }\n-        \n-        \n-        worldFile = CLIIOHelpers.getWorldFile(serverDir);\n-        worldPath = worldFile.getName().replace(\" \", \"_\");\n-\n-        backupDir = new File(backupDir, worldFile.getName() + \"/\" + type);\n-\n-        try {\n-            backupDateIndex = getBackupDate(backupDir, exportMode);\n-        } catch (IOException e) {\n-            CLIIOHelpers.error(\"ERROR VIEWING BACKUPS!\");\n-            e.printStackTrace();\n-            return;\n-        }\n-\n-        if (exportMode) { \n-            worldFile = new File(serverDir, \"AdvancedBackups.temp\");\n-            worldFile.mkdirs();\n-        }\n-\n-\n-        if (!CLIIOHelpers.confirmWarningMessage()) {\n-            CLIIOHelpers.error(\"ABORTED - WILL NOT PROCEED.\");\n-            return;\n-        }\n-\n-        CLIIOHelpers.info(\"Preparing...\");\n-        \n-\n-\n-        switch(restore) {\n-            case \"Restore entire world\" : {\n-                //No going back now!\n-                CLIIOHelpers.info(\"Backing up current world state...\");\n-                CLIIOHelpers.info(\"Backup saved to : \" + deleteEntireWorld(worldFile, false));\n-                switch(type) {\n-                    case \"snapshots\" :\n-                    case \"zips\" : { \n-                        restoreFullZip(backupDateIndex, worldFile);\n-                        return;\n-                    }\n-                    case \"differential\" : {\n-                        restoreFullDifferential(backupDateIndex, worldFile);\n-                        return;\n-                    }\n-                    case \"incremental\" : {\n-                        restoreFullIncremental(backupDateIndex, worldFile);\n-                        return;\n-                    }\n-                }\n-            }\n-            case \"Restore single file\" : {\n-                switch(type) {\n-                    case \"snapshots\" :\n-                    case \"zips\" : {\n-                        restorePartialZip(backupDateIndex, worldFile);\n-                        return;\n-                    }\n-                    case \"differential\" : {\n-                        restorePartialDifferential(backupDateIndex, worldFile);\n-                        return;\n-                    }\n-                    case \"incremental\" : {\n-                        restorePartialIncremental(backupDateIndex, worldFile);\n-                        return;\n-                    }\n-                }\n-            }\n-            case \"Export backup as zip\" : {\n-\n-                CLIIOHelpers.info(\"Restoring to temporary directory...\");\n-\n-                switch(type) {\n-                    case \"snapshots\" :\n-                    case \"zips\" : { \n-                        restoreFullZip(backupDateIndex, worldFile);\n-                        break;\n-                    }\n-                    case \"differential\" : {\n-                        restoreFullDifferential(backupDateIndex, worldFile);\n-                        break;\n-                    }\n-                    case \"incremental\" : {\n-                        restoreFullIncremental(backupDateIndex, worldFile);\n-                        break;\n-                    }\n-                }\n-\n-                CLIIOHelpers.info(\"Done. Preparing to write to zip...\");\n-                CLIIOHelpers.info(\"Export saved to : \" + deleteEntireWorld(worldFile, true));\n-            }\n-\n-        }\n-    }\n-\n-\n-    private static String getStackTrace(final Throwable throwable) {\n-        final StringWriter sw = new StringWriter();\n-        final PrintWriter pw = new PrintWriter(sw, true);\n-        throwable.printStackTrace(pw);\n-        return sw.getBuffer().toString();\n-    }\n-\n-\n-\n-    private static int getBackupDate(File backupDir, boolean exportMode) throws IOException {\n-        fileNames.clear();\n-        int inputType;\n-\n-        CLIIOHelpers.info(\"Select a backup to restore.\");\n-\n-        String[] fileNameArray = backupDir.list();\n-        if (fileNameArray == null || fileNameArray.length <=0) {\n-            throw new IOException(String.format(\"Selected backup directory %s is empty, or is a file!\", backupDir.getAbsolutePath()));\n-        }\n-        ArrayList<String> fileNameList = new ArrayList<String>(Arrays.asList(fileNameArray)); //i need to do this. i hate this.\n-        fileNameList.removeIf((name) -> {\n-            return (name.endsWith(\"json\") ||\n-                name.contains(\"incomplete\") ||\n-                name.contains(\"DS_Store\"));\n-        });\n-\n-        if (fileNameList.isEmpty()) {\n-            throw new IOException(String.format(\"Selected backup directory %s is empty, or is a file!\", backupDir.getAbsolutePath()));\n-        }\n-\n-        for (String fileName : CLIIOHelpers.sortStringsAlphabeticallyWithDirectoryPriority(fileNameList)) {\n-            if (exportMode) {\n-                if (fileName.endsWith(\"json\")) continue;\n-                if (fileName.contains(\"incomplete\")) continue;\n-                File file = new File(backupDir, fileName);\n-                fileNames.add(file.getAbsolutePath());\n-                String out = file.getName();\n-                String[] outs = out.split(\"\\\\_\");\n-                if (outs.length >=2) {\n-                    out = \". \" + outs[outs.length-2] + \"_\" + outs[outs.length-1];\n-                }\n-                else {\n-                    out = \". \" + out;\n-                }\n-                CLIIOHelpers.info(fileNames.size() + out);\n-\n-            }\n-            else {\n-                if (fileName.endsWith(\"json\")) continue;\n-                if (fileName.contains(\"incomplete\")) continue;\n-                File file = new File(backupDir, fileName);\n-                fileNames.add(file.getAbsolutePath());\n-                String out = file.getName();\n-                out = out.replaceAll(\".zip\", \"\");\n-                //out = out.replaceAll(worldPath + \"_\", \": \");\n-                out = out.replaceAll(\"backup_\", \": \");\n-                out = out.replaceAll(\"-partial\", \"\\u001B[33m partial\\u001B[0m\");\n-                out = out.replaceAll(\"-full\", \"\\u001B[32m full\\u001B[0m\");\n-                CLIIOHelpers.info(fileNames.size() + out);\n-\n-            }\n-        }\n-\n-        try {\n-            String line = CLIIOHelpers.input.nextLine();\n-            if (line == \"\") {\n-                CLIIOHelpers.warn(\"Please enter a number.\");\n-                return getBackupDate(backupDir, exportMode);\n-            }\n-            inputType = Integer.parseInt(line);\n-        } catch (InputMismatchException | NumberFormatException e) {\n-            CLIIOHelpers.warn(\"That was not a number. Please enter a number.\");\n-            return getBackupDate(backupDir, exportMode);\n-        }\n-\n-        if (inputType < 1 || inputType > fileNames.size()) {\n-            CLIIOHelpers.warn(\"Please enter a number between \" + fileNames.size() + \".\");\n-            return getBackupDate(backupDir, exportMode);\n-        }\n-        \n-        return inputType - 1;\n-    }\n-\n-\n-\n-    private static void restoreFullZip(int index, File worldFile) {\n-        byte[] buffer = new byte[1024];\n-        //The most basic of the bunch.\n-        ZipEntry entry;\n-        try {\n-            FileInputStream fileInputStream = new FileInputStream(fileNames.get(index));\n-            ZipInputStream zip = new ZipInputStream(fileInputStream);\n-            while ((entry = zip.getNextEntry()) != null) {\n-                File outputFile;\n-\n-                outputFile = new File(worldFile, entry.getName());\n-                \n-                if (!outputFile.getParentFile().exists()) {\n-                    outputFile.getParentFile().mkdirs();\n-                }\n-\n-                CLIIOHelpers.info(\"Restoring \" + outputFile.getName());\n-\n-                FileOutputStream outputStream = new FileOutputStream(outputFile);\n-                int length = 0;\n-                while ((length = zip.read(buffer)) > 0) {\n-                    outputStream.write(buffer, 0, length);\n-                }\n-                outputStream.close();\n-            }\n-        } catch (IOException e) {\n-            // TODO Auto-generated catch block\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private static void restoreFullDifferential(int index, File worldFile) {\n-        //Do we need to check for past backups? if selected is a full backup, we do not.\n-        File backup = new File(fileNames.get(index));\n-        if (backup.getName().contains(\"-full\")) {\n-            if (backup.isFile()) {\n-                restoreFullZip(index, worldFile);\n-                return;\n-            }\n-            restoreFolder(index, worldFile);\n-            return;\n-        }\n-        //find last FULL backup\n-        for (int i = index;i>=0;i--) {\n-            String name = fileNames.get(i);\n-            if (name.contains(\"-full\")) {\n-                CLIIOHelpers.info(\"Restoring last full backup...\");\n-                File file = new File(name);\n-                if (file.isFile()) {\n-                    restoreFullZip(i, worldFile);\n-                }\n-                else {\n-                    restoreFolder(i, worldFile);\n-                }\n-                break;\n-            }\n-        }\n-        CLIIOHelpers.info(\"\\n\\nRestoring selected backup...\");\n-        if (backup.isFile()) {\n-            restoreFullZip(index, worldFile);\n-        }\n-        else {\n-            restoreFolder(index, worldFile);\n-        }\n-    }\n-\n-    private static void restoreFullIncremental(int index, File worldFile) {\n-        //Do we need to check for past backups? if selected is a full backup, we do not.\n-        File backup = new File(fileNames.get(index));\n-        if (backup.getName().contains(\"-full\")) {\n-            if (backup.isFile()) {\n-                restoreFullZip(index, worldFile);\n-                return;\n-            }\n-            restoreFolder(index, worldFile);\n-            return;\n-        }\n-        //find last FULL backup\n-        int i = index;\n-        while(i >= 0) {\n-            String name = fileNames.get(i);\n-            if (name.contains(\"-full\")) {\n-                CLIIOHelpers.info(\"Restoring last full backup...\");\n-                File file = new File(name);\n-                if (file.isFile()) {\n-                    restoreFullZip(i, worldFile);\n-                }\n-                else {\n-                    restoreFolder(i, worldFile);\n-                }\n-                break;\n-            }\n-            i--;\n-        }\n-        //restore backups up until the selected one\n-        while(i < index) {\n-            String name = fileNames.get(i);\n-            CLIIOHelpers.info(\"Restoring chained backup...\");\n-            File file = new File(name);\n-            if (file.isFile()) {\n-                restoreFullZip(i, worldFile);\n-            }\n-            else {\n-                restoreFolder(i, worldFile);\n-            }\n-            i++;\n-        }\n-        \n-        \n-        CLIIOHelpers.info(\"\\n\\nRestoring selected backup...\");\n-        if (backup.isFile()) {\n-            restoreFullZip(index, worldFile);\n-        }\n-        else {\n-            restoreFolder(index, worldFile);\n-        }\n-    }\n-\n-    private static void restorePartialZip(int index, File worldFile) {\n-\n-        HashMap<String, Object> filePaths = new HashMap<>();\n-        HashMap<String, String> dates = new HashMap<>();\n-        HashMap<String, ZipFile> entryOwners = new HashMap<>();\n-        try {\n-            File backup = new File(fileNames.get(index));\n-    \n-            addBackupNamesToLists(backup, entryOwners, filePaths, dates, \"\\u001B[32m\");\n-\n-            ZipEntry select = ((ZipEntry) CLIIOHelpers.getFileToRestore(filePaths, \"\", worldFile));\n-\n-            File outputFile = new File(worldFile, select.toString());\n-            FileOutputStream outputStream = new FileOutputStream(outputFile);\n-\n-            CLIIOHelpers.info(\"Restoring \" + select.toString() + \"...\");\n-\n-            byte[] buffer = new byte[1028];\n-            InputStream inputSteam = entryOwners.get(select.toString()).getInputStream(select);\n-            int length;\n-            while ((length = inputSteam.read(buffer, 0, buffer.length)) > 0) {\n-                outputStream.write(buffer, 0, length);\n-            }\n-            outputStream.flush();\n-            outputStream.close();\n-\n-        } catch (IOException e) {\n-\n-        }\n-\n-\n-\n-         \n-    }\n-\n-    private static void restorePartialDifferential(int index, File worldFile) {\n-        //Do we need to check for past backups? if selected is a full backup, we do not.\n-        HashMap<String, Object> filePaths = new HashMap<>();\n-        HashMap<String, String> dates = new HashMap<>();\n-        HashMap<String, ZipFile> entryOwners = new HashMap<>();\n-        try {\n-            File backup = new File(fileNames.get(index));\n-            if (!backup.getName().contains(\"-full\")) {\n-                //find last FULL backup\n-                for (int i = index;i>=0;i--) {\n-                    String name = fileNames.get(i);\n-                    if (name.contains(\"-full\")) {\n-                        addBackupNamesToLists(new File(name), entryOwners, filePaths, dates, \"\\u001b[31m\");\n-                        break;\n-                    }    \n-                }\n-            }\n-\n-            File file = new File(fileNames.get(index));\n-            addBackupNamesToLists(file, entryOwners, filePaths, dates, \"\\u001B[32m\");\n-\n-            HashMap<String, Object> properMapping = new HashMap<>();\n-            for (String date : dates.keySet()) {\n-                properMapping.put(\n-                    date + \" \" + dates.get(date),\n-                    filePaths.get(date)\n-                );\n-            }\n-\n-            Object select = CLIIOHelpers.getFileToRestore(properMapping, \"\", worldFile);\n-            if (select instanceof Path) {\n-                Path input = (Path) select;\n-\n-\n-                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-full/\")) {\n-                    select = new File(\n-                        select.toString().replace(\"\\\\\", \"/\")\n-                        .split(\"-full/\")[1]\n-                    ).toPath();\n-                }\n-                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-partial/\")) {\n-                    select = new File(\n-                        select.toString().replace(\"\\\\\", \"/\")\n-                        .split(\"-partial/\")[1]\n-                    ).toPath();\n-                }\n-    \n-                File outputFile = new File(worldFile, select.toString());\n-                if (!outputFile.getParentFile().exists()) {\n-                    outputFile.getParentFile().mkdirs();\n-                }\n-                CLIIOHelpers.info(\"\\n\\nRestoring file : \" + select);\n-                Files.copy(input, outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n-            }\n-            else if (select instanceof ZipEntry) {\n-                ZipEntry entry = (ZipEntry) select;\n-\n-                File outputFile = new File(worldFile, entry.toString());\n-                FileOutputStream outputStream = new FileOutputStream(outputFile);\n-\n-                CLIIOHelpers.info(\"Restoring \" + entry.toString() + \"...\");\n-\n-                byte[] buffer = new byte[1028];\n-                InputStream inputSteam = entryOwners.get(entry.toString()).getInputStream(entry);\n-                int length;\n-                while ((length = inputSteam.read(buffer, 0, buffer.length)) > 0) {\n-                    outputStream.write(buffer, 0, length);\n-                }\n-                outputStream.flush();\n-                outputStream.close();\n-            }\n-\n-\n-        }\n-        catch (IOException e){\n-            //TODO : Scream at user\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private static void restorePartialIncremental(int index, File worldFile) {\n-        //Do we need to check for past backups? if selected is a full backup, we do not.\n-        HashMap<String, Object> filePaths = new HashMap<>();\n-        HashMap<String, String> dates = new HashMap<>();\n-        HashMap<String, ZipFile> entryOwners = new HashMap<>();\n-        try {\n-            File backup = new File(fileNames.get(index));\n-            if (!backup.getName().contains(\"-full\")) {\n-                int i;\n-                //find last FULL backup\n-                for (i = index;i>=0;i--) {\n-                    String name = fileNames.get(i);\n-                    if (name.contains(\"-full\")) {\n-                        addBackupNamesToLists(new File(name), entryOwners, filePaths, dates, \"\\u001b[31m\");\n-                        break;\n-                    }    \n-                }\n-                while (i < index) {\n-                    String name = fileNames.get(i);\n-                    addBackupNamesToLists(new File(name), entryOwners, filePaths, dates, \"\\u001b[31m\");\n-                    i++;\n-                }\n-                \n-            }\n-\n-            File file = new File(fileNames.get(index));\n-            addBackupNamesToLists(file, entryOwners, filePaths, dates, \"\\u001B[32m\");\n-\n-            HashMap<String, Object> properMapping = new HashMap<>();\n-            for (String date : dates.keySet()) {\n-                properMapping.put(\n-                    date + \" \" + dates.get(date),\n-                    filePaths.get(date)\n-                );\n-            }\n-\n-            Object select = CLIIOHelpers.getFileToRestore(properMapping, \"\", worldFile);\n-            if (select instanceof Path) {\n-                Path input = (Path) select;\n-\n-\n-                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-full/\")) {\n-                    select = new File(\n-                        select.toString().replace(\"\\\\\", \"/\")\n-                        .split(\"-full/\")[1]\n-                    ).toPath();\n-                }\n-                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-partial/\")) {\n-                    select = new File(\n-                        select.toString().replace(\"\\\\\", \"/\")\n-                        .split(\"-partial/\")[1]\n-                    ).toPath();\n-                }\n-    \n-                File outputFile = new File(worldFile, select.toString());\n-                if (!outputFile.getParentFile().exists()) {\n-                    outputFile.getParentFile().mkdirs();\n-                }\n-                CLIIOHelpers.info(\"\\n\\nRestoring file : \" + select);\n-                Files.copy(input, outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n-            }\n-            else if (select instanceof ZipEntry) {\n-                ZipEntry entry = (ZipEntry) select;\n-\n-                File outputFile = new File(worldFile, entry.toString());\n-                FileOutputStream outputStream = new FileOutputStream(outputFile);\n-\n-                CLIIOHelpers.info(\"Restoring \" + entry.toString() + \"...\");\n-\n-                byte[] buffer = new byte[1028];\n-                InputStream inputSteam = entryOwners.get(entry.toString()).getInputStream(entry);\n-                int length;\n-                while ((length = inputSteam.read(buffer, 0, buffer.length)) > 0) {\n-                    outputStream.write(buffer, 0, length);\n-                }\n-                outputStream.flush();\n-                outputStream.close();\n-            }\n-\n-\n-        }\n-        catch (IOException e){\n-            //TODO : Scream at user\n-            e.printStackTrace();\n-        }\n-    }\n-\n-\n-    private static void restoreFolder(int index, File worldFile) {\n-        File backup = new File(fileNames.get(index));\n-\n-        try {\n-            Files.walkFileTree(backup.toPath(), new SimpleFileVisitor<Path>() {\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) throws IOException {\n-                    File source = backup.toPath().relativize(file).toFile();\n-                    File outputFile = new File(worldFile, source.getPath());\n-\n-                    if (!outputFile.getParentFile().exists()) {\n-                        outputFile.getParentFile().mkdirs();\n-                    }\n-                    \n-                    CLIIOHelpers.info(\"Restoring \" + outputFile.getName());\n-                    Files.copy(file, outputFile.toPath());\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-        } catch (IOException e) {\n-            // TODO Auto-generated catch block\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    \n-    private static void restoreOtherModZip(File backupDir) {\n-        worldFile = serverDir;\n-        Path file;\n-        HashMap<String, File> backups = new HashMap<>();\n-        HashMap<String, Path> entries = new HashMap<>();\n-\n-        for (File b : backupDir.getParentFile().listFiles()) {\n-            if (b.getName().endsWith(\"zip\")) {\n-                backups.put(b.getName(), b);\n-            }\n-        }\n-\n-        String backupName = CLIIOHelpers.getSelectionFromList(\"Select a backup to restore from.\", new ArrayList<String>(backups.keySet()));\n-        \n-        boolean fullWorld = CLIIOHelpers.getSelectionFromList(\"Do you want to restore the whole world or a singular file?\", \n-        Arrays.asList(new String[]{\"Whole world\", \"Single file\"})) == \"Whole world\";\n-\n-        if (!fullWorld) {\n-            if (!CLIIOHelpers.confirmWarningMessage()) return;\n-            \n-            try {\n-                FileSystem zipFs = FileSystems.newFileSystem(backups.get(backupName).toPath(), AdvancedBackupsCLI.class.getClassLoader());\n-                Path root = zipFs.getPath(\"\");\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) throws IOException {\n-                        entries.put(file.toString(), file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-\n-                file = CLIIOHelpers.getFileToRestore(entries, \"\", worldFile);\n-                CLIIOHelpers.info(\"Restoring \" + file.toString() + \"...\");\n-                Path outputFile = new File(worldFile, file.toString()).toPath();\n-                if (!outputFile.getParent().toFile().exists()) {\n-                    outputFile.getParent().toFile().mkdirs();\n-                }\n-                Files.copy(file, outputFile, StandardCopyOption.REPLACE_EXISTING);\n-                CLIIOHelpers.info(\"Done.\");\n-                \n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                e.printStackTrace();\n-                return;\n-            }\n-        }\n-\n-        else {\n-            if (!CLIIOHelpers.confirmWarningMessage()) return;\n-\n-            Path levelDatPath;\n-            ArrayList<Path> levelDatPathWrapper = new ArrayList<>();\n-            \n-            try {\n-                FileSystem zipFs = FileSystems.newFileSystem(backups.get(backupName).toPath(), AdvancedBackupsCLI.class.getClassLoader());\n-                Path root = zipFs.getPath(\"\");\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) throws IOException {\n-                        if (file.getFileName().toString().equals(\"level.dat\")) levelDatPathWrapper.add(file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-\n-                levelDatPath = levelDatPathWrapper.get(0);\n-                CLIIOHelpers.info(\"Making backup of existing world...\");\n-                CLIIOHelpers.info(\"Backup saved to : \" + deleteEntireWorld(new File(worldFile, levelDatPath.getParent().toString()), false));\n-                byte[] buffer = new byte[1024];\n-                ZipEntry entry;\n-                FileInputStream fileInputStream = new FileInputStream(backups.get(backupName));\n-                ZipInputStream zip = new ZipInputStream(fileInputStream);\n-                while ((entry = zip.getNextEntry()) != null) {\n-                    File outputFile;\n-    \n-                    outputFile = new File(worldFile, entry.getName());\n-                    \n-                    if (!outputFile.getParentFile().exists()) {\n-                        outputFile.getParentFile().mkdirs();\n-                    }\n-\n-                    \n-                    CLIIOHelpers.info(\"Restoring \" + outputFile.toString() + \"...\");\n-    \n-                    FileOutputStream outputStream = new FileOutputStream(outputFile);\n-                    int length = 0;\n-                    while ((length = zip.read(buffer)) > 0) {\n-                        outputStream.write(buffer, 0, length);\n-                    }\n-                    outputStream.close();\n-                }\n-                \n-            } catch (IOException e) {\n-                // TODO Auto-generated catch block\n-                e.printStackTrace();\n-            }\n-\n-\n-            \n-        }\n-\n-        CLIIOHelpers.info(\"Done.\");\n-\n-    }\n-\n-\n-\n-    private static String deleteEntireWorld(File worldDir, boolean exportMode) {\n-        String ret = backupExistingWorld(worldDir, exportMode);\n-        try {\n-            Files.walkFileTree(worldDir.toPath(), new SimpleFileVisitor<Path>() {\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\n-                    file.toFile().delete();\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                \n-                @Override\n-                public FileVisitResult postVisitDirectory(Path file, java.io.IOException arg1) {\n-                    if (file.toFile().listFiles().length == 0) {\n-                        file.toFile().delete();\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-        } catch (IOException e) {\n-            CLIIOHelpers.warn(\"Failed to delete file :\");\n-            e.printStackTrace();\n-        }\n-        return ret;\n-    }\n-\n-    private static String backupExistingWorld(File worldDir, boolean export) {\n-        File out = new File(worldDir, \"../cli\" + serialiseBackupName(export ? \"export\" : \"backup\") + \".zip\");\n-        try {\n-            FileOutputStream outputStream = new FileOutputStream(out);\n-            ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream);\n-            zipOutputStream.setLevel(4);\n-            Files.walkFileTree(worldDir.toPath(), new SimpleFileVisitor<Path>() {\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\n-                    Path targetFile;\n-                    try {\n-                        targetFile = worldDir.toPath().relativize(file);\n-                        if (targetFile.toFile().getName().compareTo(\"session.lock\") == 0) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        zipOutputStream.putNextEntry(new ZipEntry(targetFile.toString()));\n-                        byte[] bytes = Files.readAllBytes(file);\n-                        zipOutputStream.write(bytes, 0, bytes.length);\n-                        zipOutputStream.closeEntry();\n-\n-                    } catch (IOException e) {\n-                        // TODO : Scream at user\n-                        e.printStackTrace();\n-                    }\n-                    \n-                        return FileVisitResult.CONTINUE;\n-                }\n-            });\n-            zipOutputStream.flush();\n-            zipOutputStream.close();\n-\n-            CLIIOHelpers.info(\"Done.\");\n-        } catch (Exception e) {\n-            \n-        }\n-\n-        return out.getName();\n-    }\n-\n-\n-\n-    private static void addBackupNamesToLists(File file, HashMap<String, ZipFile> entryOwners, HashMap<String, Object> filePaths, \n-        HashMap<String, String> dates, String colour) throws IOException {\n-        \n-        if (file.isFile()) {\n-            \n-            ZipFile zipFile = new ZipFile(file);\n-            Enumeration<? extends ZipEntry> entryEnum = zipFile.entries();\n-\n-            while (entryEnum.hasMoreElements()) {\n-                ZipEntry entry = entryEnum.nextElement();\n-\n-                String backupName = file.toString().replace(\"\\\\\", \"/\");\n-                filePaths.put(entry.toString().replace(\"\\\\\", \"/\"), entry);\n-                dates.put(entry.toString().replace(\"\\\\\", \"/\"), \"\\u001b[31m\"\n-                 + backupName\n-                .substring(backupName.toString().lastIndexOf(\"/\") + 1) \n-                //.replace(worldPath + \"_\", \"\")\n-                .replace(\"backup_\", \"\")\n-                .replace(\"-full.zip\", \"\")\n-                .replace(\"-partial.zip\", \"\")\n-                + \"\\u001B[0m\");\n-                entryOwners.put(entry.toString(), zipFile);\n-            }\n-        }\n-\n-        else {\n-            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {\n-                @Override\n-                public FileVisitResult visitFile(Path path, BasicFileAttributes attributes) throws IOException {\n-                    String backupName = file.toString().replace(\"\\\\\", \"/\");\n-                    filePaths.put(file.toPath().relativize(path).toString().replace(\"\\\\\", \"/\"), path);\n-                    dates.put(file.toPath().relativize(path).toString().replace(\"\\\\\", \"/\"), \"\\u001b[31m\"\n-                     + backupName\n-                    .substring(backupName.toString().lastIndexOf(\"/\") + 1) \n-                    //.replace(worldPath + \"_\", \"\")\n-                    .replace(\"backup_\", \"\")\n-                    .replace(\"-full\", \"\")\n-                    .replace(\"-partial\", \"\")\n-                    + \"\\u001B[0m\");\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-        }\n-    }\n-\n-    \n-    public static String serialiseBackupName(String in) {\n-        Date date = new Date();\n-        String pattern = \"yyyy-MM-dd_HH-mm-ss\";\n-        \n-        return in + \"_\" + new SimpleDateFormat(pattern).format(date);\n-    }\n-    \n-}\n+package co.uk.mommyheather.advancedbackups.cli;\r\n+\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileOutputStream;\r\n+import java.io.FileReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.StringWriter;\r\n+import java.nio.file.FileSystem;\r\n+import java.nio.file.FileSystems;\r\n+import java.nio.file.FileVisitResult;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.SimpleFileVisitor;\r\n+import java.nio.file.StandardCopyOption;\r\n+import java.nio.file.attribute.BasicFileAttributes;\r\n+import java.text.SimpleDateFormat;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Date;\r\n+import java.util.Enumeration;\r\n+import java.util.HashMap;\r\n+import java.util.InputMismatchException;\r\n+import java.util.List;\r\n+import java.util.Properties;\r\n+import java.util.regex.Pattern;\r\n+import java.util.zip.ZipEntry;\r\n+import java.util.zip.ZipFile;\r\n+import java.util.zip.ZipInputStream;\r\n+import java.util.zip.ZipOutputStream;\r\n+\r\n+import org.fusesource.jansi.AnsiConsole;\r\n+\r\n+import co.uk.mommyheather.advancedbackups.core.ABCore;\r\n+\r\n+public class AdvancedBackupsCLI {\r\n+\r\n+    private static String backupLocation;\r\n+    private static File serverDir = new File(new File(\"\").toPath().toAbsolutePath().getParent().toString());\r\n+    private static String type;\r\n+    private static ArrayList<String> fileNames = new ArrayList<>();\r\n+    private static File worldFile;\r\n+    private static String worldPath;\r\n+    public static void main(String args[]) throws IllegalBackupException {\r\n+        \r\n+        \r\n+\r\n+        if (System.console() != null) {\r\n+            AnsiConsole.systemInstall(); //this gets ansi escape codes working on windows. this was a FUCKING PAIN IN MY ASS\r\n+        }\r\n+        \r\n+        System.out.print(\"\\033[H\\033[2J\");\r\n+        System.out.flush();\r\n+        \r\n+         \r\n+        CLIIOHelpers.info(\"Advanced Backups - Version \" + AdvancedBackupsCLI.class.getPackage().getImplementationVersion());\r\n+        CLIIOHelpers.info(\"Note : this cannot restore backups made prior to the 3.0 release.\");\r\n+        CLIIOHelpers.info(\"Searching for properties...\", false);\r\n+\r\n+        \r\n+        Properties props = new Properties();\r\n+        File file = new File(serverDir, \"config/AdvancedBackups.properties\");\r\n+        FileReader reader;\r\n+        try {\r\n+            reader = new FileReader(file);   \r\n+            props.load(reader);\r\n+\r\n+            backupLocation = props.getProperty(\"config.advancedbackups.path\");\r\n+            type = props.getProperty(\"config.advancedbackups.type\");\r\n+        } catch (Exception e) {\r\n+            CLIIOHelpers.error(\"ERROR LOADING PROPERTIES!\");\r\n+            CLIIOHelpers.error(getStackTrace(e));\r\n+            CLIIOHelpers.error(\"\");\r\n+            CLIIOHelpers.error(\"\");\r\n+            CLIIOHelpers.error(\"Ensure you're running this from within the mods directory, and the config file is in the parent directory!\");\r\n+            // Fatal, cannot proceed\r\n+            return;\r\n+        }\r\n+\r\n+        if (backupLocation == null || type == null) {\r\n+            CLIIOHelpers.error(\"ERROR LOADING PROPERTIES!\");\r\n+            CLIIOHelpers.error(\"Backup location : \" + backupLocation);\r\n+            CLIIOHelpers.error(\"Type : \" + type);\r\n+            // Fatal, cannot proceed\r\n+            return;\r\n+        }\r\n+\r\n+        CLIIOHelpers.info(\"Config loaded!\");\r\n+\r\n+        //What's a good way to check between absolute and relative? Not all absolute paths will start with /..\r\n+        File backupDir = new File(serverDir, backupLocation.replaceAll(Pattern.quote(\".\" + File.separator), \"\"));\r\n+\r\n+        if (!backupDir.exists()) {\r\n+            //Is it absolute?\r\n+            backupDir = new File(backupLocation.replaceAll(Pattern.quote(\".\" + File.separator), \"\"));\r\n+            if (!backupDir.exists()) {\r\n+                CLIIOHelpers.error(\"Could not find backup directory!\");\r\n+                CLIIOHelpers.error(backupDir.getAbsolutePath());\r\n+                CLIIOHelpers.error(\"Have you made any backups before?\");\r\n+                //Fatal, cannot continue\r\n+                return;\r\n+            }\r\n+        }\r\n+\r\n+        \r\n+        //check for backups from \"other mods\"\r\n+        boolean flag = false;\r\n+        ArrayList<File> otherBackups = new ArrayList<>();\r\n+        for (File b : backupDir.listFiles()) {\r\n+            if (b.getName().endsWith(\"zip\")) {\r\n+                flag = true;\r\n+                otherBackups.add(b);\r\n+            }\r\n+\r\n+        }\r\n+\r\n+        if (flag) {\r\n+            String result = CLIIOHelpers.getSelectionFromList(\"Backups from another mod have been found. These can be restored if you want.\\nWould you want to work with these backups?\", \r\n+            Arrays.asList(new String[]{\"Use backups from AdvancedBackups\", \"Use backups from other mod\"}));\r\n+            if (result == \"Use backups from other mod\") {\r\n+                restoreOtherModZip(backupDir);\r\n+                return;\r\n+            }\r\n+        }\r\n+\r\n+        type = CLIIOHelpers.getBackupType(type);\r\n+        if (type.equals(\"snapshot (command-made only)\")) type = \"snapshots\";\r\n+\r\n+        /*/\r\n+        if (backupLocation.startsWith(Pattern.quote(File.separator)) || backupLocation.indexOf(\":\") == 1) {\r\n+            backupDir = new File(backupLocation, File.separator + type + File.separator);\r\n+        }\r\n+        else {\r\n+            backupDir = new File(serverDir, backupLocation.replaceAll(Pattern.quote(\".\" + File.separator), \"\") + File.separator + type + File.separator);\r\n+        }\r\n+*/\r\n+        \r\n+               \r\n+        boolean exportMode = false;\r\n+        int backupDateIndex;\r\n+\r\n+        \r\n+\r\n+        CLIIOHelpers.info(\"Do you want to export a backup, restore the entire world state at this point, or a singular file?\");\r\n+\r\n+        String restore = CLIIOHelpers.getSelectionFromList(\"Enter a number.\",\r\n+            Arrays.asList(new String[]{\"Export backup as zip\", \"Restore single file\", \"Restore entire world\"}));\r\n+        \r\n+            \r\n+        if (restore.equals(\"Export backup as zip\")) {\r\n+            exportMode = true;\r\n+        }\r\n+        \r\n+        \r\n+        worldFile = CLIIOHelpers.getWorldFile(serverDir);\r\n+        worldPath = worldFile.getName().replace(\" \", \"_\");\r\n+\r\n+        backupDir = new File(backupDir, worldFile.getName() + \"/\" + type);\r\n+\r\n+        try {\r\n+            backupDateIndex = getBackupDate(backupDir, exportMode);\r\n+        } catch (IOException e) {\r\n+            CLIIOHelpers.error(\"ERROR VIEWING BACKUPS!\");\r\n+            e.printStackTrace();\r\n+            return;\r\n+        }\r\n+\r\n+        if (exportMode) { \r\n+            worldFile = new File(serverDir, \"AdvancedBackups.temp\");\r\n+            worldFile.mkdirs();\r\n+        }\r\n+\r\n+\r\n+        if (!CLIIOHelpers.confirmWarningMessage()) {\r\n+            CLIIOHelpers.error(\"ABORTED - WILL NOT PROCEED.\");\r\n+            return;\r\n+        }\r\n+\r\n+        CLIIOHelpers.info(\"Preparing...\");\r\n+        \r\n+\r\n+\r\n+        switch(restore) {\r\n+            case \"Restore entire world\" : {\r\n+                //No going back now!\r\n+                CLIIOHelpers.info(\"Backing up current world state...\");\r\n+                CLIIOHelpers.info(\"Backup saved to : \" + deleteEntireWorld(worldFile, false));\r\n+                switch(type) {\r\n+                    case \"snapshots\" :\r\n+                    case \"zips\" : { \r\n+                        restoreFullZip(backupDateIndex, worldFile);\r\n+                        return;\r\n+                    }\r\n+                    case \"differential\" : {\r\n+                        restoreFullDifferential(backupDateIndex, worldFile);\r\n+                        return;\r\n+                    }\r\n+                    case \"incremental\" : {\r\n+                        restoreFullIncremental(backupDateIndex, worldFile);\r\n+                        return;\r\n+                    }\r\n+                }\r\n+            }\r\n+            case \"Restore single file\" : {\r\n+                switch(type) {\r\n+                    case \"snapshots\" :\r\n+                    case \"zips\" : {\r\n+                        restorePartialZip(backupDateIndex, worldFile);\r\n+                        return;\r\n+                    }\r\n+                    case \"differential\" : {\r\n+                        restorePartialDifferential(backupDateIndex, worldFile);\r\n+                        return;\r\n+                    }\r\n+                    case \"incremental\" : {\r\n+                        restorePartialIncremental(backupDateIndex, worldFile);\r\n+                        return;\r\n+                    }\r\n+                }\r\n+            }\r\n+            case \"Export backup as zip\" : {\r\n+\r\n+                CLIIOHelpers.info(\"Restoring to temporary directory...\");\r\n+\r\n+                switch(type) {\r\n+                    case \"snapshots\" :\r\n+                    case \"zips\" : { \r\n+                        restoreFullZip(backupDateIndex, worldFile);\r\n+                        break;\r\n+                    }\r\n+                    case \"differential\" : {\r\n+                        restoreFullDifferential(backupDateIndex, worldFile);\r\n+                        break;\r\n+                    }\r\n+                    case \"incremental\" : {\r\n+                        restoreFullIncremental(backupDateIndex, worldFile);\r\n+                        break;\r\n+                    }\r\n+                }\r\n+\r\n+                CLIIOHelpers.info(\"Done. Preparing to write to zip...\");\r\n+                CLIIOHelpers.info(\"Export saved to : \" + deleteEntireWorld(worldFile, true));\r\n+            }\r\n+\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    private static String getStackTrace(final Throwable throwable) {\r\n+        final StringWriter sw = new StringWriter();\r\n+        final PrintWriter pw = new PrintWriter(sw, true);\r\n+        throwable.printStackTrace(pw);\r\n+        return sw.getBuffer().toString();\r\n+    }\r\n+\r\n+\r\n+\r\n+    private static int getBackupDate(File backupDir, boolean exportMode) throws IOException {\r\n+        fileNames.clear();\r\n+        int inputType;\r\n+\r\n+        CLIIOHelpers.info(\"Select a backup to restore.\");\r\n+\r\n+        String[] fileNameArray = backupDir.list();\r\n+        if (fileNameArray == null || fileNameArray.length <=0) {\r\n+            throw new IOException(String.format(\"Selected backup directory %s is empty, or is a file!\", backupDir.getAbsolutePath()));\r\n+        }\r\n+        ArrayList<String> fileNameList = new ArrayList<String>(Arrays.asList(fileNameArray)); //i need to do this. i hate this.\r\n+        fileNameList.removeIf((name) -> {\r\n+            return (name.endsWith(\"json\") ||\r\n+                name.contains(\"incomplete\") ||\r\n+                name.contains(\"DS_Store\"));\r\n+        });\r\n+\r\n+        if (fileNameList.isEmpty()) {\r\n+            throw new IOException(String.format(\"Selected backup directory %s is empty, or is a file!\", backupDir.getAbsolutePath()));\r\n+        }\r\n+\r\n+        for (String fileName : CLIIOHelpers.sortStringsAlphabeticallyWithDirectoryPriority(fileNameList)) {\r\n+            if (exportMode) {\r\n+                if (fileName.endsWith(\"json\")) continue;\r\n+                if (fileName.contains(\"incomplete\")) continue;\r\n+                File file = new File(backupDir, fileName);\r\n+                fileNames.add(file.getAbsolutePath());\r\n+                String out = file.getName();\r\n+                String[] outs = out.split(\"\\\\_\");\r\n+                if (outs.length >=2) {\r\n+                    out = \". \" + outs[outs.length-2] + \"_\" + outs[outs.length-1];\r\n+                }\r\n+                else {\r\n+                    out = \". \" + out;\r\n+                }\r\n+                CLIIOHelpers.info(fileNames.size() + out);\r\n+\r\n+            }\r\n+            else {\r\n+                if (fileName.endsWith(\"json\")) continue;\r\n+                if (fileName.contains(\"incomplete\")) continue;\r\n+                File file = new File(backupDir, fileName);\r\n+                fileNames.add(file.getAbsolutePath());\r\n+                String out = file.getName();\r\n+                out = out.replaceAll(\".zip\", \"\");\r\n+                //out = out.replaceAll(worldPath + \"_\", \": \");\r\n+                out = out.replaceAll(\"backup_\", \": \");\r\n+                out = out.replaceAll(\"-partial\", \"\\u001B[33m partial\\u001B[0m\");\r\n+                out = out.replaceAll(\"-full\", \"\\u001B[32m full\\u001B[0m\");\r\n+                CLIIOHelpers.info(fileNames.size() + out);\r\n+\r\n+            }\r\n+        }\r\n+\r\n+        try {\r\n+            String line = CLIIOHelpers.input.nextLine();\r\n+            if (line == \"\") {\r\n+                CLIIOHelpers.warn(\"Please enter a number.\");\r\n+                return getBackupDate(backupDir, exportMode);\r\n+            }\r\n+            inputType = Integer.parseInt(line);\r\n+        } catch (InputMismatchException | NumberFormatException e) {\r\n+            CLIIOHelpers.warn(\"That was not a number. Please enter a number.\");\r\n+            return getBackupDate(backupDir, exportMode);\r\n+        }\r\n+\r\n+        if (inputType < 1 || inputType > fileNames.size()) {\r\n+            CLIIOHelpers.warn(\"Please enter a number between \" + fileNames.size() + \".\");\r\n+            return getBackupDate(backupDir, exportMode);\r\n+        }\r\n+        \r\n+        return inputType - 1;\r\n+    }\r\n+\r\n+\r\n+\r\n+    private static void restoreFullZip(int index, File worldFile) throws IllegalBackupException {\r\n+        byte[] buffer = new byte[1024];\r\n+        //The most basic of the bunch.\r\n+        ZipEntry entry;\r\n+        try {\r\n+            FileInputStream fileInputStream = new FileInputStream(fileNames.get(index));\r\n+            ZipInputStream zip = new ZipInputStream(fileInputStream);\r\n+            while ((entry = zip.getNextEntry()) != null) {\r\n+                File outputFile;\r\n+                \r\n+\r\n+                outputFile = new File(worldFile, entry.getName());\r\n+\r\n+                if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                    zip.close();\r\n+                    ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                    throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + entry.getName());\r\n+                }\r\n+                \r\n+                if (!outputFile.getParentFile().exists()) {\r\n+                    outputFile.getParentFile().mkdirs();\r\n+                }\r\n+\r\n+                CLIIOHelpers.info(\"Restoring \" + outputFile.getName());\r\n+\r\n+                FileOutputStream outputStream = new FileOutputStream(outputFile);\r\n+                int length = 0;\r\n+                while ((length = zip.read(buffer)) > 0) {\r\n+                    outputStream.write(buffer, 0, length);\r\n+                }\r\n+                outputStream.close();\r\n+            }\r\n+            zip.close();\r\n+        } catch (IOException e) {\r\n+            // TODO Auto-generated catch block\r\n+            e.printStackTrace();\r\n+        }\r\n+    }\r\n+\r\n+    private static void restoreFullDifferential(int index, File worldFile) throws IllegalBackupException {\r\n+        //Do we need to check for past backups? if selected is a full backup, we do not.\r\n+        File backup = new File(fileNames.get(index));\r\n+        if (backup.getName().contains(\"-full\")) {\r\n+            if (backup.isFile()) {\r\n+                restoreFullZip(index, worldFile);\r\n+                return;\r\n+            }\r\n+            restoreFolder(index, worldFile);\r\n+            return;\r\n+        }\r\n+        //find last FULL backup\r\n+        for (int i = index;i>=0;i--) {\r\n+            String name = fileNames.get(i);\r\n+            if (name.contains(\"-full\")) {\r\n+                CLIIOHelpers.info(\"Restoring last full backup...\");\r\n+                File file = new File(name);\r\n+                if (file.isFile()) {\r\n+                    restoreFullZip(i, worldFile);\r\n+                }\r\n+                else {\r\n+                    restoreFolder(i, worldFile);\r\n+                }\r\n+                break;\r\n+            }\r\n+        }\r\n+        CLIIOHelpers.info(\"\\n\\nRestoring selected backup...\");\r\n+        if (backup.isFile()) {\r\n+            restoreFullZip(index, worldFile);\r\n+        }\r\n+        else {\r\n+            restoreFolder(index, worldFile);\r\n+        }\r\n+    }\r\n+\r\n+    private static void restoreFullIncremental(int index, File worldFile) throws IllegalBackupException {\r\n+        //Do we need to check for past backups? if selected is a full backup, we do not.\r\n+        File backup = new File(fileNames.get(index));\r\n+        if (backup.getName().contains(\"-full\")) {\r\n+            if (backup.isFile()) {\r\n+                restoreFullZip(index, worldFile);\r\n+                return;\r\n+            }\r\n+            restoreFolder(index, worldFile);\r\n+            return;\r\n+        }\r\n+        //find last FULL backup\r\n+        int i = index;\r\n+        while(i >= 0) {\r\n+            String name = fileNames.get(i);\r\n+            if (name.contains(\"-full\")) {\r\n+                CLIIOHelpers.info(\"Restoring last full backup...\");\r\n+                File file = new File(name);\r\n+                if (file.isFile()) {\r\n+                    restoreFullZip(i, worldFile);\r\n+                }\r\n+                else {\r\n+                    restoreFolder(i, worldFile);\r\n+                }\r\n+                break;\r\n+            }\r\n+            i--;\r\n+        }\r\n+        //restore backups up until the selected one\r\n+        while(i < index) {\r\n+            String name = fileNames.get(i);\r\n+            CLIIOHelpers.info(\"Restoring chained backup...\");\r\n+            File file = new File(name);\r\n+            if (file.isFile()) {\r\n+                restoreFullZip(i, worldFile);\r\n+            }\r\n+            else {\r\n+                restoreFolder(i, worldFile);\r\n+            }\r\n+            i++;\r\n+        }\r\n+        \r\n+        \r\n+        CLIIOHelpers.info(\"\\n\\nRestoring selected backup...\");\r\n+        if (backup.isFile()) {\r\n+            restoreFullZip(index, worldFile);\r\n+        }\r\n+        else {\r\n+            restoreFolder(index, worldFile);\r\n+        }\r\n+    }\r\n+\r\n+    private static void restorePartialZip(int index, File worldFile) {\r\n+\r\n+        HashMap<String, Object> filePaths = new HashMap<>();\r\n+        HashMap<String, String> dates = new HashMap<>();\r\n+        HashMap<String, ZipFile> entryOwners = new HashMap<>();\r\n+        try {\r\n+            File backup = new File(fileNames.get(index));\r\n+    \r\n+            addBackupNamesToLists(backup, entryOwners, filePaths, dates, \"\\u001B[32m\");\r\n+\r\n+            ZipEntry select = ((ZipEntry) CLIIOHelpers.getFileToRestore(filePaths, \"\", worldFile));\r\n+\r\n+            File outputFile = new File(worldFile, select.toString());\r\n+            FileOutputStream outputStream = new FileOutputStream(outputFile);\r\n+\r\n+            CLIIOHelpers.info(\"Restoring \" + select.toString() + \"...\");\r\n+\r\n+            byte[] buffer = new byte[1028];\r\n+            InputStream inputSteam = entryOwners.get(select.toString()).getInputStream(select);\r\n+            int length;\r\n+            while ((length = inputSteam.read(buffer, 0, buffer.length)) > 0) {\r\n+                outputStream.write(buffer, 0, length);\r\n+            }\r\n+            outputStream.flush();\r\n+            outputStream.close();\r\n+\r\n+        } catch (IOException e) {\r\n+\r\n+        }\r\n+\r\n+\r\n+\r\n+         \r\n+    }\r\n+\r\n+    private static void restorePartialDifferential(int index, File worldFile) throws IllegalBackupException {\r\n+        //Do we need to check for past backups? if selected is a full backup, we do not.\r\n+        HashMap<String, Object> filePaths = new HashMap<>();\r\n+        HashMap<String, String> dates = new HashMap<>();\r\n+        HashMap<String, ZipFile> entryOwners = new HashMap<>();\r\n+        try {\r\n+            File backup = new File(fileNames.get(index));\r\n+            if (!backup.getName().contains(\"-full\")) {\r\n+                //find last FULL backup\r\n+                for (int i = index;i>=0;i--) {\r\n+                    String name = fileNames.get(i);\r\n+                    if (name.contains(\"-full\")) {\r\n+                        addBackupNamesToLists(new File(name), entryOwners, filePaths, dates, \"\\u001b[31m\");\r\n+                        break;\r\n+                    }    \r\n+                }\r\n+            }\r\n+\r\n+            File file = new File(fileNames.get(index));\r\n+            addBackupNamesToLists(file, entryOwners, filePaths, dates, \"\\u001B[32m\");\r\n+\r\n+            HashMap<String, Object> properMapping = new HashMap<>();\r\n+            for (String date : dates.keySet()) {\r\n+                properMapping.put(\r\n+                    date + \" \" + dates.get(date),\r\n+                    filePaths.get(date)\r\n+                );\r\n+            }\r\n+\r\n+            Object select = CLIIOHelpers.getFileToRestore(properMapping, \"\", worldFile);\r\n+            if (select instanceof Path) {\r\n+                Path input = (Path) select;\r\n+\r\n+\r\n+                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-full/\")) {\r\n+                    select = new File(\r\n+                        select.toString().replace(\"\\\\\", \"/\")\r\n+                        .split(\"-full/\")[1]\r\n+                    ).toPath();\r\n+                }\r\n+                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-partial/\")) {\r\n+                    select = new File(\r\n+                        select.toString().replace(\"\\\\\", \"/\")\r\n+                        .split(\"-partial/\")[1]\r\n+                    ).toPath();\r\n+                }\r\n+    \r\n+                File outputFile = new File(worldFile, select.toString());\r\n+                if (!outputFile.getParentFile().exists()) {\r\n+                    outputFile.getParentFile().mkdirs();\r\n+                }\r\n+\r\n+                if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                    ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                    throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + select.toString());\r\n+                }\r\n+\r\n+                CLIIOHelpers.info(\"\\n\\nRestoring file : \" + select);\r\n+                Files.copy(input, outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n+            }\r\n+            else if (select instanceof ZipEntry) {\r\n+                ZipEntry entry = (ZipEntry) select;\r\n+\r\n+                File outputFile = new File(worldFile, entry.toString());\r\n+\r\n+                if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                    ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                    throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + select.toString());\r\n+                }\r\n+\r\n+                FileOutputStream outputStream = new FileOutputStream(outputFile);\r\n+\r\n+                CLIIOHelpers.info(\"Restoring \" + entry.toString() + \"...\");\r\n+\r\n+                byte[] buffer = new byte[1028];\r\n+                InputStream inputSteam = entryOwners.get(entry.toString()).getInputStream(entry);\r\n+                int length;\r\n+                while ((length = inputSteam.read(buffer, 0, buffer.length)) > 0) {\r\n+                    outputStream.write(buffer, 0, length);\r\n+                }\r\n+                outputStream.flush();\r\n+                outputStream.close();\r\n+            }\r\n+\r\n+\r\n+        }\r\n+        catch (IOException e){\r\n+            //TODO : Scream at user\r\n+            e.printStackTrace();\r\n+        }\r\n+    }\r\n+\r\n+    private static void restorePartialIncremental(int index, File worldFile) throws IllegalBackupException {\r\n+        //Do we need to check for past backups? if selected is a full backup, we do not.\r\n+        HashMap<String, Object> filePaths = new HashMap<>();\r\n+        HashMap<String, String> dates = new HashMap<>();\r\n+        HashMap<String, ZipFile> entryOwners = new HashMap<>();\r\n+        try {\r\n+            File backup = new File(fileNames.get(index));\r\n+            if (!backup.getName().contains(\"-full\")) {\r\n+                int i;\r\n+                //find last FULL backup\r\n+                for (i = index;i>=0;i--) {\r\n+                    String name = fileNames.get(i);\r\n+                    if (name.contains(\"-full\")) {\r\n+                        addBackupNamesToLists(new File(name), entryOwners, filePaths, dates, \"\\u001b[31m\");\r\n+                        break;\r\n+                    }    \r\n+                }\r\n+                while (i < index) {\r\n+                    String name = fileNames.get(i);\r\n+                    addBackupNamesToLists(new File(name), entryOwners, filePaths, dates, \"\\u001b[31m\");\r\n+                    i++;\r\n+                }\r\n+                \r\n+            }\r\n+\r\n+            File file = new File(fileNames.get(index));\r\n+            addBackupNamesToLists(file, entryOwners, filePaths, dates, \"\\u001B[32m\");\r\n+\r\n+            HashMap<String, Object> properMapping = new HashMap<>();\r\n+            for (String date : dates.keySet()) {\r\n+                properMapping.put(\r\n+                    date + \" \" + dates.get(date),\r\n+                    filePaths.get(date)\r\n+                );\r\n+            }\r\n+\r\n+            Object select = CLIIOHelpers.getFileToRestore(properMapping, \"\", worldFile);\r\n+            if (select instanceof Path) {\r\n+                Path input = (Path) select;\r\n+\r\n+\r\n+                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-full/\")) {\r\n+                    select = new File(\r\n+                        select.toString().replace(\"\\\\\", \"/\")\r\n+                        .split(\"-full/\")[1]\r\n+                    ).toPath();\r\n+                }\r\n+                if (select.toString().replace(\"\\\\\", \"/\").contains(\"-partial/\")) {\r\n+                    select = new File(\r\n+                        select.toString().replace(\"\\\\\", \"/\")\r\n+                        .split(\"-partial/\")[1]\r\n+                    ).toPath();\r\n+                }\r\n+    \r\n+                File outputFile = new File(worldFile, select.toString());\r\n+                \r\n+\r\n+                if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                    ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                    throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + select.toString());\r\n+                }\r\n+                \r\n+                if (!outputFile.getParentFile().exists()) {\r\n+                    outputFile.getParentFile().mkdirs();\r\n+                }\r\n+                CLIIOHelpers.info(\"\\n\\nRestoring file : \" + select);\r\n+                Files.copy(input, outputFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n+            }\r\n+            else if (select instanceof ZipEntry) {\r\n+                ZipEntry entry = (ZipEntry) select;\r\n+\r\n+                File outputFile = new File(worldFile, entry.toString());\r\n+                \r\n+                if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                    ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                    throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + select.toString());\r\n+                }\r\n+\r\n+                FileOutputStream outputStream = new FileOutputStream(outputFile);\r\n+\r\n+                CLIIOHelpers.info(\"Restoring \" + entry.toString() + \"...\");\r\n+\r\n+                byte[] buffer = new byte[1028];\r\n+                InputStream inputSteam = entryOwners.get(entry.toString()).getInputStream(entry);\r\n+                int length;\r\n+                while ((length = inputSteam.read(buffer, 0, buffer.length)) > 0) {\r\n+                    outputStream.write(buffer, 0, length);\r\n+                }\r\n+                outputStream.flush();\r\n+                outputStream.close();\r\n+            }\r\n+\r\n+\r\n+        }\r\n+        catch (IOException e){\r\n+            //TODO : Scream at user\r\n+            e.printStackTrace();\r\n+        }\r\n+    }\r\n+\r\n+\r\n+    private static void restoreFolder(int index, File worldFile) throws IllegalBackupException {\r\n+        File backup = new File(fileNames.get(index));\r\n+\r\n+        try {\r\n+            Files.walkFileTree(backup.toPath(), new SimpleFileVisitor<Path>() {\r\n+                @Override\r\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) throws IOException {\r\n+                    File source = backup.toPath().relativize(file).toFile();\r\n+                    File outputFile = new File(worldFile, source.getPath());\r\n+\r\n+                    if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                        ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                        new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + source.getPath()).printStackTrace();\r\n+                        return FileVisitResult.TERMINATE;\r\n+                    }\r\n+\r\n+                    if (!outputFile.getParentFile().exists()) {\r\n+                        outputFile.getParentFile().mkdirs();\r\n+                    }\r\n+                    \r\n+                    CLIIOHelpers.info(\"Restoring \" + outputFile.getName());\r\n+                    Files.copy(file, outputFile.toPath());\r\n+                    return FileVisitResult.CONTINUE;\r\n+                }\r\n+            });\r\n+        } catch (IOException e) {\r\n+            // TODO Auto-generated catch block\r\n+            e.printStackTrace();\r\n+        }\r\n+    }\r\n+\r\n+    \r\n+    private static void restoreOtherModZip(File backupDir) throws IllegalBackupException {\r\n+        worldFile = serverDir;\r\n+        Path file;\r\n+        HashMap<String, File> backups = new HashMap<>();\r\n+        HashMap<String, Path> entries = new HashMap<>();\r\n+\r\n+        for (File b : backupDir.getParentFile().listFiles()) {\r\n+            if (b.getName().endsWith(\"zip\")) {\r\n+                backups.put(b.getName(), b);\r\n+            }\r\n+        }\r\n+\r\n+        String backupName = CLIIOHelpers.getSelectionFromList(\"Select a backup to restore from.\", new ArrayList<String>(backups.keySet()));\r\n+        \r\n+        boolean fullWorld = CLIIOHelpers.getSelectionFromList(\"Do you want to restore the whole world or a singular file?\", \r\n+        Arrays.asList(new String[]{\"Whole world\", \"Single file\"})) == \"Whole world\";\r\n+\r\n+        if (!fullWorld) {\r\n+            if (!CLIIOHelpers.confirmWarningMessage()) return;\r\n+            \r\n+            try {\r\n+                FileSystem zipFs = FileSystems.newFileSystem(backups.get(backupName).toPath(), AdvancedBackupsCLI.class.getClassLoader());\r\n+                Path root = zipFs.getPath(\"\");\r\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\r\n+                    @Override\r\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) throws IOException {\r\n+                        entries.put(file.toString(), file);\r\n+                        return FileVisitResult.CONTINUE;\r\n+                    }\r\n+                });\r\n+\r\n+                file = CLIIOHelpers.getFileToRestore(entries, \"\", worldFile);\r\n+                CLIIOHelpers.info(\"Restoring \" + file.toString() + \"...\");\r\n+                Path outputFile = new File(worldFile, file.toString()).toPath();\r\n+\r\n+                if (!outputFile.normalize().startsWith(worldFile.toPath())) {\r\n+                    ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                    throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + file.toString());\r\n+                }\r\n+                if (!outputFile.getParent().toFile().exists()) {\r\n+                    outputFile.getParent().toFile().mkdirs();\r\n+                }\r\n+                Files.copy(file, outputFile, StandardCopyOption.REPLACE_EXISTING);\r\n+                CLIIOHelpers.info(\"Done.\");\r\n+                \r\n+            } catch (IOException e) {\r\n+                // TODO Auto-generated catch block\r\n+                e.printStackTrace();\r\n+                return;\r\n+            }\r\n+        }\r\n+\r\n+        else {\r\n+            if (!CLIIOHelpers.confirmWarningMessage()) return;\r\n+\r\n+            Path levelDatPath;\r\n+            ArrayList<Path> levelDatPathWrapper = new ArrayList<>();\r\n+            \r\n+            try {\r\n+                FileSystem zipFs = FileSystems.newFileSystem(backups.get(backupName).toPath(), AdvancedBackupsCLI.class.getClassLoader());\r\n+                Path root = zipFs.getPath(\"\");\r\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\r\n+                    @Override\r\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) throws IOException {\r\n+                        if (file.getFileName().toString().equals(\"level.dat\")) levelDatPathWrapper.add(file);\r\n+                        return FileVisitResult.CONTINUE;\r\n+                    }\r\n+                });\r\n+\r\n+                levelDatPath = levelDatPathWrapper.get(0);\r\n+                CLIIOHelpers.info(\"Making backup of existing world...\");\r\n+                CLIIOHelpers.info(\"Backup saved to : \" + deleteEntireWorld(new File(worldFile, levelDatPath.getParent().toString()), false));\r\n+                byte[] buffer = new byte[1024];\r\n+                ZipEntry entry;\r\n+                FileInputStream fileInputStream = new FileInputStream(backups.get(backupName));\r\n+                ZipInputStream zip = new ZipInputStream(fileInputStream);\r\n+                while ((entry = zip.getNextEntry()) != null) {\r\n+                    File outputFile;\r\n+    \r\n+                    outputFile = new File(worldFile, entry.getName());\r\n+\r\n+                    if (!outputFile.toPath().normalize().startsWith(worldFile.toPath())) {\r\n+                        zip.close();\r\n+                        ABCore.errorLogger.accept(\"Found a potentially malicious zip file - cowardly exiting, restoration may be incomplete!\");\r\n+                        throw new IllegalBackupException(\"Zip file is likely malicious! Found an erroneus path: \" + entry.getName());\r\n+                    }\r\n+                    \r\n+                    if (!outputFile.getParentFile().exists()) {\r\n+                        outputFile.getParentFile().mkdirs();\r\n+                    }\r\n+\r\n+                    \r\n+                    CLIIOHelpers.info(\"Restoring \" + outputFile.toString() + \"...\");\r\n+    \r\n+                    FileOutputStream outputStream = new FileOutputStream(outputFile);\r\n+                    int length = 0;\r\n+                    while ((length = zip.read(buffer)) > 0) {\r\n+                        outputStream.write(buffer, 0, length);\r\n+                    }\r\n+                    outputStream.close();\r\n+                }\r\n+                zip.close();\r\n+                \r\n+            } catch (IOException e) {\r\n+                // TODO Auto-generated catch block\r\n+                e.printStackTrace();\r\n+            }\r\n+\r\n+\r\n+            \r\n+        }\r\n+\r\n+        CLIIOHelpers.info(\"Done.\");\r\n+\r\n+    }\r\n+\r\n+\r\n+\r\n+    private static String deleteEntireWorld(File worldDir, boolean exportMode) {\r\n+        String ret = backupExistingWorld(worldDir, exportMode);\r\n+        try {\r\n+            Files.walkFileTree(worldDir.toPath(), new SimpleFileVisitor<Path>() {\r\n+                @Override\r\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\r\n+                    file.toFile().delete();\r\n+                    return FileVisitResult.CONTINUE;\r\n+                }\r\n+                \r\n+                @Override\r\n+                public FileVisitResult postVisitDirectory(Path file, java.io.IOException arg1) {\r\n+                    if (file.toFile().listFiles().length == 0) {\r\n+                        file.toFile().delete();\r\n+                    }\r\n+                    return FileVisitResult.CONTINUE;\r\n+                }\r\n+            });\r\n+        } catch (IOException e) {\r\n+            CLIIOHelpers.warn(\"Failed to delete file :\");\r\n+            e.printStackTrace();\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    private static String backupExistingWorld(File worldDir, boolean export) {\r\n+        File out = new File(worldDir, \"../cli\" + serialiseBackupName(export ? \"export\" : \"backup\") + \".zip\");\r\n+        try {\r\n+            FileOutputStream outputStream = new FileOutputStream(out);\r\n+            ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream);\r\n+            zipOutputStream.setLevel(4);\r\n+            Files.walkFileTree(worldDir.toPath(), new SimpleFileVisitor<Path>() {\r\n+                @Override\r\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {\r\n+                    Path targetFile;\r\n+                    try {\r\n+                        targetFile = worldDir.toPath().relativize(file);\r\n+                        if (targetFile.toFile().getName().compareTo(\"session.lock\") == 0) {\r\n+                            return FileVisitResult.CONTINUE;\r\n+                        }\r\n+                        zipOutputStream.putNextEntry(new ZipEntry(targetFile.toString()));\r\n+                        byte[] bytes = Files.readAllBytes(file);\r\n+                        zipOutputStream.write(bytes, 0, bytes.length);\r\n+                        zipOutputStream.closeEntry();\r\n+\r\n+                    } catch (IOException e) {\r\n+                        // TODO : Scream at user\r\n+                        e.printStackTrace();\r\n+                    }\r\n+                    \r\n+                        return FileVisitResult.CONTINUE;\r\n+                }\r\n+            });\r\n+            zipOutputStream.flush();\r\n+            zipOutputStream.close();\r\n+\r\n+            CLIIOHelpers.info(\"Done.\");\r\n+        } catch (Exception e) {\r\n+            \r\n+        }\r\n+\r\n+        return out.getName();\r\n+    }\r\n+\r\n+\r\n+\r\n+    private static void addBackupNamesToLists(File file, HashMap<String, ZipFile> entryOwners, HashMap<String, Object> filePaths, \r\n+        HashMap<String, String> dates, String colour) throws IOException {\r\n+        \r\n+        if (file.isFile()) {\r\n+            \r\n+            ZipFile zipFile = new ZipFile(file);\r\n+            Enumeration<? extends ZipEntry> entryEnum = zipFile.entries();\r\n+\r\n+            while (entryEnum.hasMoreElements()) {\r\n+                ZipEntry entry = entryEnum.nextElement();\r\n+\r\n+                String backupName = file.toString().replace(\"\\\\\", \"/\");\r\n+                filePaths.put(entry.toString().replace(\"\\\\\", \"/\"), entry);\r\n+                dates.put(entry.toString().replace(\"\\\\\", \"/\"), \"\\u001b[31m\"\r\n+                 + backupName\r\n+                .substring(backupName.toString().lastIndexOf(\"/\") + 1) \r\n+                //.replace(worldPath + \"_\", \"\")\r\n+                .replace(\"backup_\", \"\")\r\n+                .replace(\"-full.zip\", \"\")\r\n+                .replace(\"-partial.zip\", \"\")\r\n+                + \"\\u001B[0m\");\r\n+                entryOwners.put(entry.toString(), zipFile);\r\n+            }\r\n+        }\r\n+\r\n+        else {\r\n+            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {\r\n+                @Override\r\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes attributes) throws IOException {\r\n+                    String backupName = file.toString().replace(\"\\\\\", \"/\");\r\n+                    filePaths.put(file.toPath().relativize(path).toString().replace(\"\\\\\", \"/\"), path);\r\n+                    dates.put(file.toPath().relativize(path).toString().replace(\"\\\\\", \"/\"), \"\\u001b[31m\"\r\n+                     + backupName\r\n+                    .substring(backupName.toString().lastIndexOf(\"/\") + 1) \r\n+                    //.replace(worldPath + \"_\", \"\")\r\n+                    .replace(\"backup_\", \"\")\r\n+                    .replace(\"-full\", \"\")\r\n+                    .replace(\"-partial\", \"\")\r\n+                    + \"\\u001B[0m\");\r\n+                    return FileVisitResult.CONTINUE;\r\n+                }\r\n+            });\r\n+        }\r\n+    }\r\n+\r\n+    \r\n+    public static String serialiseBackupName(String in) {\r\n+        Date date = new Date();\r\n+        String pattern = \"yyyy-MM-dd_HH-mm-ss\";\r\n+        \r\n+        return in + \"_\" + new SimpleDateFormat(pattern).format(date);\r\n+    }\r\n+    \r\n+}\r"
        },
        {
          "filename": "src/main/java/co/uk/mommyheather/advancedbackups/cli/IllegalBackupException.java",
          "status": "added",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -0,0 +1,9 @@\n+package co.uk.mommyheather.advancedbackups.cli;\r\n+\r\n+public class IllegalBackupException extends Exception {\r\n+\r\n+    public IllegalBackupException(String string) {\r\n+        super(string);\r\n+    }\r\n+    \r\n+}\r"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "44e3ffcc3366cff3c5f8da90748717c5476ba4a3",
            "date": "2025-01-12T03:49:26Z",
            "author_login": "HeatherComputer"
          },
          {
            "sha": "30df4a7e9b7fcaa68cd9521953cd0f1fe62407a4",
            "date": "2025-01-12T03:22:12Z",
            "author_login": "HeatherComputer"
          },
          {
            "sha": "98b5c00f53b32256d075c17d56bc753b258dfff5",
            "date": "2025-01-12T03:13:23Z",
            "author_login": "HeatherComputer"
          },
          {
            "sha": "f1b11afcfb09d87f62ac7d5f6e6af9c4e8747465",
            "date": "2025-01-11T20:22:55Z",
            "author_login": "HeatherComputer"
          },
          {
            "sha": "626578c586ca6f304e962d0014583e832f268dfc",
            "date": "2025-01-11T20:06:33Z",
            "author_login": "HeatherComputer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N",
    "cwe_id": null,
    "description": "Mommy Heather Advanced Backups up to v3.5.3 allows attackers to write arbitrary files via restoring a crafted back up.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-09T17:15:48.153",
    "last_modified": "2024-11-21T09:27:12.257",
    "fix_date": "2024-06-16T00:47:11Z"
  },
  "references": [
    {
      "url": "https://gist.github.com/apple502j/193358682885fe1a6708309ce934e4ed",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/MommyHeather/AdvancedBackups/commit/1545f499f73bf434ed292c31121fdda8042ff5d6",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://gist.github.com/apple502j/193358682885fe1a6708309ce934e4ed",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/MommyHeather/AdvancedBackups/commit/1545f499f73bf434ed292c31121fdda8042ff5d6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.423589",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "AdvancedBackups",
    "owner": "MommyHeather",
    "created_at": "2023-04-30T15:49:05Z",
    "updated_at": "2025-01-14T06:39:02Z",
    "pushed_at": "2025-01-12T03:49:27Z",
    "size": 2220,
    "stars": 41,
    "forks": 7,
    "open_issues": 13,
    "watchers": 41,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "feature/manifestv4",
      "main"
    ],
    "languages": {
      "Java": 765877,
      "Shell": 548
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "bsd-3-clause"
    },
    "collected_at": "2025-01-14T15:29:21.567282"
  }
}