{
  "cve_id": "CVE-2024-39677",
  "github_data": {
    "repository": "nhibernate/nhibernate-core",
    "fix_commit": "b4a69d1a5ff5744312478d70308329af496e4ba9",
    "related_commits": [
      "b4a69d1a5ff5744312478d70308329af496e4ba9",
      "b4a69d1a5ff5744312478d70308329af496e4ba9"
    ],
    "patch_url": "https://github.com/nhibernate/nhibernate-core/commit/b4a69d1a5ff5744312478d70308329af496e4ba9.patch",
    "fix_commit_details": {
      "sha": "b4a69d1a5ff5744312478d70308329af496e4ba9",
      "commit_date": "2024-07-02T22:56:52Z",
      "author": {
        "login": "fredericDelaporte",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Handle SQL injection vulnerabilities within ObjectToSQLString (#3547)",
        "length": 202,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1183,
        "additions": 1105,
        "deletions": 78
      },
      "files": [
        {
          "filename": "doc/reference/modules/configuration.xml",
          "status": "modified",
          "additions": 14,
          "deletions": 6,
          "patch": "@@ -871,6 +871,20 @@ var session = sessions.OpenSession(conn);\n                             </para>\n                         </entry>\n                     </row>\n+                    <row>\n+                        <entry>\n+                            <literal>escape_backslash_in_strings</literal>\n+                        </entry>\n+                        <entry>\n+                            Indicates if the database needs to have backslash escaped in string literals.\n+                            The default value is dialect dependant. That is <literal>false</literal> for\n+                            most dialects.\n+                            <para>\n+                                <emphasis role=\"strong\">eg.</emphasis> \n+                                <literal>true</literal> | <literal>false</literal>\n+                            </para>\n+                        </entry>\n+                    </row>\n                     <row>\n                         <entry>\n                             <literal>show_sql</literal>\n@@ -1515,12 +1529,6 @@ in the parameter binding.</programlisting>\n                             <entry><literal>NHibernate.Dialect.PostgreSQLDialect</literal></entry>\n                             <entry></entry>\n                         </row>\n-                        <row>\n-                            <entry>PostgreSQL</entry>\n-                            <entry><literal>NHibernate.Dialect.PostgreSQLDialect</literal></entry>\n-                            <entry>\n-                            </entry>\n-                        </row>\n                         <row>\n                             <entry>PostgreSQL 8.1</entry>\n                             <entry><literal>NHibernate.Dialect.PostgreSQL81Dialect</literal></entry>"
        },
        {
          "filename": "src/NHibernate.Config.Templates/SapSQLAnywhere.cfg.xml",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -15,7 +15,7 @@ for your own use before compiling tests in Visual Studio.\n \t\t<property name=\"connection.connection_string\">\n \t\t\tUID=DBA;PWD=sql;Server=localhost;DBN=nhibernate;DBF=c:\\nhibernate.db;ASTOP=No;Enlist=false;\n \t\t</property>\n-\t\t<property name=\"dialect\">NHibernate.Dialect.SybaseSQLAnywhere12Dialect</property>\n+\t\t<property name=\"dialect\">NHibernate.Dialect.SapSQLAnywhere17Dialect</property>\n \t\t<property name=\"query.substitutions\">true=1;false=0</property>\n \t</session-factory>\n </hibernate-configuration>"
        },
        {
          "filename": "src/NHibernate.Test/Async/NHSpecificTest/GH3516/FixtureByCode.cs",
          "status": "added",
          "additions": 399,
          "deletions": 0,
          "patch": "@@ -0,0 +1,399 @@\n+\ufeff//------------------------------------------------------------------------------\n+// <auto-generated>\n+//     This code was generated by AsyncGenerator.\n+//\n+//     Changes to this file may cause incorrect behavior and will be lost if\n+//     the code is regenerated.\n+// </auto-generated>\n+//------------------------------------------------------------------------------\n+\n+\n+using System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using NHibernate.Cfg.MappingSchema;\n+using NHibernate.Mapping.ByCode;\n+using NHibernate.SqlTypes;\n+using NHibernate.Type;\n+using NUnit.Framework;\n+using NUnit.Framework.Internal;\n+\n+namespace NHibernate.Test.NHSpecificTest.GH3516\n+{\n+\tusing System.Threading.Tasks;\n+\t[TestFixture]\n+\tpublic class FixtureByCodeAsync : TestCaseMappingByCode\n+\t{\n+\n+\t\tprivate readonly HashSet<string> _unsupportedProperties = new();\n+\n+\t\tprotected override HbmMapping GetMappings()\n+\t\t{\n+\t\t\tvar mapper = new ModelMapper();\n+\t\t\tmapper.Class<Entity>(rc =>\n+\t\t\t{\n+\t\t\t\trc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));\n+\t\t\t\trc.Property(x => x.Name);\n+\t\t\t\trc.Property(x => x.FirstChar);\n+\t\t\t\trc.Property(x => x.CharacterEnum, m => m.Type<EnumCharType<CharEnum>>());\n+\t\t\t\trc.Property(x => x.UriProperty);\n+\n+\t\t\t\trc.Property(x => x.ByteProperty);\n+\t\t\t\trc.Property(x => x.DecimalProperty);\n+\t\t\t\trc.Property(x => x.DoubleProperty);\n+\t\t\t\trc.Property(x => x.FloatProperty);\n+\t\t\t\trc.Property(x => x.ShortProperty);\n+\t\t\t\trc.Property(x => x.IntProperty);\n+\t\t\t\trc.Property(x => x.LongProperty);\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.SByte))\n+\t\t\t\t\trc.Property(x => x.SByteProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.SByteProperty));\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.UInt16))\n+\t\t\t\t\trc.Property(x => x.UShortProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.UShortProperty));\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.UInt32))\n+\t\t\t\t\trc.Property(x => x.UIntProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.UIntProperty));\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.UInt64))\n+\t\t\t\t\trc.Property(x => x.ULongProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.ULongProperty));\n+\n+\t\t\t\trc.Property(x => x.DateTimeProperty);\n+\t\t\t\trc.Property(x => x.DateProperty, m => m.Type(NHibernateUtil.Date));\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.DateTimeOffSet))\n+\t\t\t\t\trc.Property(x => x.DateTimeOffsetProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.DateTimeOffsetProperty));\n+\t\t\t\trc.Property(x => x.TimeProperty, m => m.Type(NHibernateUtil.Time));\n+\n+\t\t\t\trc.Property(x => x.GuidProperty);\n+\t\t\t});\n+\n+\t\t\tmapper.Class<BaseClass>(rc =>\n+\t\t\t{\n+\t\t\t\trc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));\n+\t\t\t\trc.Discriminator(x => x.Column(\"StringDiscriminator\"));\n+\t\t\t\trc.Property(x => x.Name);\n+\t\t\t\trc.Abstract(true);\n+\t\t\t});\n+\t\t\tmapper.Subclass<Subclass1>(rc => rc.DiscriminatorValue(Entity.NameWithSingleQuote));\n+\t\t\tmapper.Subclass<Subclass2>(rc => rc.DiscriminatorValue(Entity.NameWithEscapedSingleQuote));\n+\n+\t\t\tmapper.Import<CharEnum>();\n+\n+\t\t\treturn mapper.CompileMappingForAllExplicitlyAddedEntities();\n+\t\t}\n+\n+\t\tprivate CultureInfo _backupCulture;\n+\t\tprivate CultureInfo _backupUICulture;\n+\n+\t\tprotected override void OnSetUp()\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\t\t\tusing var transaction = session.BeginTransaction();\n+\t\t\tsession.Save(\n+\t\t\t\tnew Entity\n+\t\t\t\t{\n+\t\t\t\t\tName = Entity.NameWithSingleQuote,\n+\t\t\t\t\tFirstChar = Entity.QuoteInitial,\n+\t\t\t\t\tCharacterEnum = CharEnum.SingleQuote,\n+\t\t\t\t\tUriProperty = Entity.UriWithSingleQuote\n+\t\t\t\t});\n+\t\t\tsession.Save(\n+\t\t\t\tnew Entity\n+\t\t\t\t{\n+\t\t\t\t\tName = Entity.NameWithEscapedSingleQuote,\n+\t\t\t\t\tFirstChar = Entity.BackslashInitial,\n+\t\t\t\t\tCharacterEnum = CharEnum.Backslash,\n+\t\t\t\t\tUriProperty = Entity.UriWithEscapedSingleQuote\n+\t\t\t\t});\n+\n+\t\t\ttransaction.Commit();\n+\n+\t\t\t_backupCulture = CultureInfo.CurrentCulture;\n+\t\t\t_backupUICulture = CultureInfo.CurrentUICulture;\n+\t\t}\n+\n+\t\tprotected override void OnTearDown()\n+\t\t{\n+\t\t\tif (_backupCulture != null)\n+\t\t\t{\n+\t\t\t\tCultureInfo.CurrentCulture = _backupCulture;\n+\t\t\t\tCultureInfo.CurrentUICulture = _backupUICulture;\n+\t\t\t}\n+\n+\t\t\tusing var session = OpenSession();\n+\t\t\tusing var transaction = session.BeginTransaction();\n+\t\t\tsession.CreateQuery(\"delete from System.Object\").ExecuteUpdate();\n+\n+\t\t\ttransaction.Commit();\n+\t\t}\n+\n+\t\tprivate static readonly string[] StringInjectionsProperties =\n+\t\t{\n+\t\t\tnameof(Entity.NameWithSingleQuote), nameof(Entity.NameWithEscapedSingleQuote)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(StringInjectionsProperties))]\n+\t\tpublic void SqlInjectionInStringsAsync(string propertyName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.Name = Entity.{propertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(async () => list = await (query.ListAsync<Entity>()), Throws.Nothing);\n+\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find entity with name {propertyName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] SpecialNames =\n+\t\t{\n+\t\t\t\"\\0; drop table Entity; --\",\n+\t\t\t\"\\b; drop table Entity; --\",\n+\t\t\t\"\\n; drop table Entity; --\",\n+\t\t\t\"\\r; drop table Entity; --\",\n+\t\t\t\"\\t; drop table Entity; --\",\n+\t\t\t\"\\x1A; drop table Entity; --\",\n+\t\t\t\"\\\"; drop table Entity; --\",\n+\t\t\t\"\\\\; drop table Entity; --\"\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(SpecialNames))]\n+\t\tpublic async Task StringsWithSpecialCharactersAsync(string name)\n+\t\t{\n+\t\t\t// We may not even be able to insert the entity.\n+\t\t\tvar wasInserted = false;\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tusing var s = OpenSession();\n+\t\t\t\tusing var t = s.BeginTransaction();\n+\t\t\t\tvar e = new Entity { Name = name };\n+\t\t\t\tawait (s.SaveAsync(e));\n+\t\t\t\tawait (t.CommitAsync());\n+\n+\t\t\t\twasInserted = true;\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tAssert.Warn($\"The entity insertion failed with message {e}\");\n+\t\t\t}\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tusing var session = OpenSession();\n+\t\t\t\tEntity.ArbitraryStringValue = name;\n+\t\t\t\tvar list = await (session.CreateQuery($\"from Entity e where e.Name = Entity.{nameof(Entity.ArbitraryStringValue)}\").ListAsync<Entity>());\n+\t\t\t\tif (wasInserted && list.Count != 1)\n+\t\t\t\t\tAssert.Warn($\"Unable to find entity with name {nameof(Entity.ArbitraryStringValue)}\");\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tAssert.Warn($\"The query has failed with message {e}\");\n+\t\t\t}\n+\n+\t\t\t// Check the db is not wrecked.\n+\t\t\tif (wasInserted)\n+\t\t\t{\n+\t\t\t\tusing var session = OpenSession();\n+\t\t\t\tvar list = await (session\n+\t\t\t\t\t.CreateQuery(\"from Entity e where e.Name = :name\")\n+\t\t\t\t\t.SetString(\"name\", name)\n+\t\t\t\t\t.ListAsync<Entity>());\n+\t\t\t\tAssert.That(list, Has.Count.EqualTo(1));\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tusing var session = OpenSession();\n+\t\t\t\tvar all = await (session.CreateQuery(\"from Entity e\").ListAsync<Entity>());\n+\t\t\t\tAssert.That(all, Has.Count.GreaterThan(0));\n+\t\t\t}\n+\t\t}\n+\n+\t\t[Test]\n+\t\tpublic async Task SqlInjectionInStringDiscriminatorAsync()\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tawait (session.SaveAsync(new Subclass1 { Name = \"Subclass1\" }));\n+\t\t\tawait (session.SaveAsync(new Subclass2 { Name = \"Subclass2\" }));\n+\n+\t\t\t// ObjectToSQLString is used for generating the inserts.\n+\t\t\tAssert.That(session.Flush, Throws.Nothing, \"Unable to flush the subclasses\");\n+\n+\t\t\tforeach (var entityName in new[] { nameof(Subclass1), nameof(Subclass2) })\n+\t\t\t{\n+\t\t\t\tvar query = session.CreateQuery($\"from {entityName}\");\n+\t\t\t\tIList list = null;\n+\t\t\t\tAssert.That(async () => list = await (query.ListAsync()), Throws.Nothing, $\"Unable to list entities of {entityName}\");\n+\t\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find the {entityName} entity\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static readonly string[] CharInjectionsProperties =\n+\t\t{\n+\t\t\tnameof(Entity.QuoteInitial), nameof(Entity.BackslashInitial)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(CharInjectionsProperties))]\n+\t\tpublic void SqlInjectionInCharAsync(string propertyName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.FirstChar = Entity.{propertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(async () => list = await (query.ListAsync<Entity>()), Throws.Nothing);\n+\t\t\tAssert.That(list, Is.Not.Null.And.Count.EqualTo(1), $\"Unable to find entity with initial {propertyName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] CharEnumInjections =\n+\t\t{\n+\t\t\tnameof(CharEnum.SingleQuote), nameof(CharEnum.Backslash)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(CharEnumInjections))]\n+\t\tpublic void SqlInjectionWithCharEnumAsync(string enumName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.CharacterEnum = CharEnum.{enumName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(async () => list = await (query.ListAsync<Entity>()), Throws.Nothing);\n+\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find entity with CharacterEnum {enumName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] UriInjections =\n+\t\t{\n+\t\t\tnameof(Entity.UriWithSingleQuote), nameof(Entity.UriWithEscapedSingleQuote)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(UriInjections))]\n+\t\tpublic void SqlInjectionWithUriAsync(string propertyName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.UriProperty = Entity.{propertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(async () => list = await (query.ListAsync<Entity>()), Throws.Nothing);\n+\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find entity with UriProperty {propertyName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] NumericalTypesInjections =\n+\t\t{\n+\t\t\tnameof(Entity.ByteProperty),\n+\t\t\tnameof(Entity.DecimalProperty),\n+\t\t\tnameof(Entity.DoubleProperty),\n+\t\t\tnameof(Entity.FloatProperty),\n+\t\t\tnameof(Entity.ShortProperty),\n+\t\t\tnameof(Entity.IntProperty),\n+\t\t\tnameof(Entity.LongProperty),\n+\t\t\tnameof(Entity.SByteProperty),\n+\t\t\tnameof(Entity.UShortProperty),\n+\t\t\tnameof(Entity.UIntProperty),\n+\t\t\tnameof(Entity.ULongProperty)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(NumericalTypesInjections))]\n+\t\tpublic async Task SqlInjectionInNumericalTypeAsync(string propertyName)\n+\t\t{\n+\t\t\tAssume.That(_unsupportedProperties, Does.Not.Contains((object) propertyName), $\"The {propertyName} property is unsupported by the dialect\");\n+\n+\t\t\tEntity.ArbitraryStringValue = \"0; drop table Entity; --\";\n+\t\t\tusing (var session = OpenSession())\n+\t\t\t{\n+\t\t\t\tIQuery query;\n+\t\t\t\t// Defining that query is invalid and should throw.\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tquery = session.CreateQuery($\"from Entity e where e.{propertyName} = Entity.{nameof(Entity.ArbitraryStringValue)}\");\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex)\n+\t\t\t\t{\n+\t\t\t\t\t// All good.\n+\t\t\t\t\tAssert.Pass($\"The wicked query creation has been rejected, as it should: {ex}\");\n+\t\t\t\t\t// Needed for the compiler who does not know \"Pass\" always throw.\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\t// The query definition has been accepted, run it.\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tawait (query.ListAsync<Entity>());\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex)\n+\t\t\t\t{\n+\t\t\t\t\t// Expecting no exception at that point, but the test is to check if the injection succeeded.\n+\t\t\t\t\tAssert.Warn($\"The wicked query execution has failed: {ex}\");\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Check if we can still query Entity. If it succeeds, at least it means the injection failed.\n+\t\t\tusing (var session = OpenSession())\n+\t\t\t{\n+\t\t\t\tIList<Entity> list = null;\n+\t\t\t\tAssert.That(async () => list = await (session.CreateQuery(\"from Entity e\").ListAsync<Entity>()), Throws.Nothing);\n+\t\t\t\tAssert.That(list, Has.Count.GreaterThan(0));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static readonly string[] DateTypesInjections =\n+\t\t{\n+\t\t\tnameof(Entity.DateTimeProperty),\n+\t\t\tnameof(Entity.DateProperty),\n+\t\t\tnameof(Entity.DateTimeOffsetProperty),\n+\t\t\tnameof(Entity.TimeProperty)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(DateTypesInjections))]\n+\t\tpublic void SqlInjectionWithDatetimeAsync(string propertyName)\n+\t\t{\n+\t\t\tAssume.That(_unsupportedProperties, Does.Not.Contains((object) propertyName), $\"The {propertyName} property is unsupported by the dialect\");\n+\n+\t\t\tvar wickedCulture = new CultureInfo(\"en-US\");\n+\t\t\tif (propertyName == nameof(Entity.TimeProperty))\n+\t\t\t\twickedCulture.DateTimeFormat.ShortTimePattern = \"HH:mm:ss\\\\'\\\"; drop table Entity; --\\\"\";\n+\t\t\telse\n+\t\t\t\twickedCulture.DateTimeFormat.ShortDatePattern = \"yyyy-MM-ddTHH:mm:ss\\\\'\\\"; drop table Entity; --\\\"\";\n+\t\t\tCultureInfo.CurrentCulture = wickedCulture;\n+\t\t\tCultureInfo.CurrentUICulture = wickedCulture;\n+\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar staticPropertyName = propertyName == nameof(Entity.DateTimeOffsetProperty) ?\n+\t\t\t\tnameof(Entity.StaticDateTimeOffsetProperty) : nameof(Entity.StaticDateProperty);\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.{propertyName} = Entity.{staticPropertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssume.That(() => list = query.List<Entity>(), Throws.Nothing,\n+\t\t\t\t\"The first execution of the query failed, the injection has likely failed\");\n+\t\t\t// Execute again to check the table is still here.\n+\t\t\tAssert.That(async () => list = await (query.ListAsync<Entity>()), Throws.Nothing,\n+\t\t\t\t\"The second execution of the query failed although the first one did not: the injection has succeeded\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] GuidInjections =\n+\t\t{\n+\t\t\tEntity.NameWithSingleQuote, Entity.NameWithEscapedSingleQuote\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(GuidInjections))]\n+\t\tpublic void SqlInjectionWithGuidAsync(string injection)\n+\t\t{\n+\t\t\tEntity.ArbitraryStringValue = $\"{Guid.NewGuid()}{injection}\";\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.GuidProperty = Entity.{nameof(Entity.ArbitraryStringValue)}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssume.That(() => list = query.List<Entity>(), Throws.Nothing,\n+\t\t\t\t\"The first execution of the query failed, the injection has likely failed\");\n+\t\t\t// Execute again to check the table is still here.\n+\t\t\tAssert.That(async () => list = await (query.ListAsync<Entity>()), Throws.Nothing,\n+\t\t\t\t\"The second execution of the query failed although the first one did not: the injection has succeeded\");\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "src/NHibernate.Test/NHSpecificTest/GH3516/Entity.cs",
          "status": "added",
          "additions": 54,
          "deletions": 0,
          "patch": "@@ -0,0 +1,54 @@\n+\ufeffusing System;\n+\n+namespace NHibernate.Test.NHSpecificTest.GH3516\n+{\n+\tpublic class Entity\n+\t{\n+\t\tpublic virtual Guid Id { get; set; }\n+\t\tpublic virtual string Name { get; set; }\n+\t\tpublic virtual char FirstChar { get; set; }\n+\t\tpublic virtual CharEnum CharacterEnum { get; set; } = CharEnum.SimpleChar;\n+\t\tpublic virtual Uri UriProperty { get; set; }\n+\n+\t\tpublic virtual byte ByteProperty { get; set; }\n+\t\tpublic virtual decimal DecimalProperty { get; set; }\n+\t\tpublic virtual double DoubleProperty { get; set; }\n+\t\tpublic virtual float FloatProperty { get; set; }\n+\t\tpublic virtual short ShortProperty { get; set; }\n+\t\tpublic virtual int IntProperty { get; set; }\n+\t\tpublic virtual long LongProperty { get; set; }\n+\t\tpublic virtual sbyte SByteProperty { get; set; }\n+\t\tpublic virtual ushort UShortProperty { get; set; }\n+\t\tpublic virtual uint UIntProperty { get; set; }\n+\t\tpublic virtual ulong ULongProperty { get; set; }\n+\n+\t\tpublic virtual DateTime DateTimeProperty { get; set; } = StaticDateProperty;\n+\t\tpublic virtual DateTime DateProperty { get; set; } = StaticDateProperty;\n+\t\tpublic virtual DateTimeOffset DateTimeOffsetProperty { get; set; } = StaticDateProperty;\n+\t\tpublic virtual DateTime TimeProperty { get; set; } = StaticDateProperty;\n+\n+\t\tpublic virtual Guid GuidProperty { get; set; } = Guid.Empty;\n+\n+\t\tpublic const string NameWithSingleQuote = \"'; drop table Entity; --\";\n+\t\tpublic const string NameWithEscapedSingleQuote = @\"\\'; drop table Entity; --\";\n+\n+\t\t// Do not switch to property, the feature of referencing static fields in HQL does not work with properties.\n+\t\tpublic static string ArbitraryStringValue;\n+\n+\t\tpublic const char QuoteInitial = '\\'';\n+\t\tpublic const char BackslashInitial = '\\\\';\n+\n+\t\tpublic static readonly Uri UriWithSingleQuote = new(\"https://somewhere/?sql='; drop table Entity; --\");\n+\t\tpublic static readonly Uri UriWithEscapedSingleQuote = new(@\"https://somewhere/?sql=\\'; drop table Entity; --\");\n+\n+\t\tpublic static readonly DateTime StaticDateProperty = DateTime.Today;\n+\t\tpublic static readonly DateTimeOffset StaticDateTimeOffsetProperty = DateTimeOffset.Now;\n+\t}\n+\n+\tpublic enum CharEnum\n+\t{\n+\t\tSimpleChar = 'A',\n+\t\tSingleQuote = '\\'',\n+\t\tBackslash = '\\\\'\n+\t}\n+}"
        },
        {
          "filename": "src/NHibernate.Test/NHSpecificTest/GH3516/FixtureByCode.cs",
          "status": "added",
          "additions": 388,
          "deletions": 0,
          "patch": "@@ -0,0 +1,388 @@\n+\ufeffusing System;\n+using System.Collections;\n+using System.Collections.Generic;\n+using System.Globalization;\n+using NHibernate.Cfg.MappingSchema;\n+using NHibernate.Mapping.ByCode;\n+using NHibernate.SqlTypes;\n+using NHibernate.Type;\n+using NUnit.Framework;\n+using NUnit.Framework.Internal;\n+\n+namespace NHibernate.Test.NHSpecificTest.GH3516\n+{\n+\t[TestFixture]\n+\tpublic class FixtureByCode : TestCaseMappingByCode\n+\t{\n+\n+\t\tprivate readonly HashSet<string> _unsupportedProperties = new();\n+\n+\t\tprotected override HbmMapping GetMappings()\n+\t\t{\n+\t\t\tvar mapper = new ModelMapper();\n+\t\t\tmapper.Class<Entity>(rc =>\n+\t\t\t{\n+\t\t\t\trc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));\n+\t\t\t\trc.Property(x => x.Name);\n+\t\t\t\trc.Property(x => x.FirstChar);\n+\t\t\t\trc.Property(x => x.CharacterEnum, m => m.Type<EnumCharType<CharEnum>>());\n+\t\t\t\trc.Property(x => x.UriProperty);\n+\n+\t\t\t\trc.Property(x => x.ByteProperty);\n+\t\t\t\trc.Property(x => x.DecimalProperty);\n+\t\t\t\trc.Property(x => x.DoubleProperty);\n+\t\t\t\trc.Property(x => x.FloatProperty);\n+\t\t\t\trc.Property(x => x.ShortProperty);\n+\t\t\t\trc.Property(x => x.IntProperty);\n+\t\t\t\trc.Property(x => x.LongProperty);\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.SByte))\n+\t\t\t\t\trc.Property(x => x.SByteProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.SByteProperty));\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.UInt16))\n+\t\t\t\t\trc.Property(x => x.UShortProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.UShortProperty));\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.UInt32))\n+\t\t\t\t\trc.Property(x => x.UIntProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.UIntProperty));\n+\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.UInt64))\n+\t\t\t\t\trc.Property(x => x.ULongProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.ULongProperty));\n+\n+\t\t\t\trc.Property(x => x.DateTimeProperty);\n+\t\t\t\trc.Property(x => x.DateProperty, m => m.Type(NHibernateUtil.Date));\n+\t\t\t\tif (TestDialect.SupportsSqlType(SqlTypeFactory.DateTimeOffSet))\n+\t\t\t\t\trc.Property(x => x.DateTimeOffsetProperty);\n+\t\t\t\telse\n+\t\t\t\t\t_unsupportedProperties.Add(nameof(Entity.DateTimeOffsetProperty));\n+\t\t\t\trc.Property(x => x.TimeProperty, m => m.Type(NHibernateUtil.Time));\n+\n+\t\t\t\trc.Property(x => x.GuidProperty);\n+\t\t\t});\n+\n+\t\t\tmapper.Class<BaseClass>(rc =>\n+\t\t\t{\n+\t\t\t\trc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));\n+\t\t\t\trc.Discriminator(x => x.Column(\"StringDiscriminator\"));\n+\t\t\t\trc.Property(x => x.Name);\n+\t\t\t\trc.Abstract(true);\n+\t\t\t});\n+\t\t\tmapper.Subclass<Subclass1>(rc => rc.DiscriminatorValue(Entity.NameWithSingleQuote));\n+\t\t\tmapper.Subclass<Subclass2>(rc => rc.DiscriminatorValue(Entity.NameWithEscapedSingleQuote));\n+\n+\t\t\tmapper.Import<CharEnum>();\n+\n+\t\t\treturn mapper.CompileMappingForAllExplicitlyAddedEntities();\n+\t\t}\n+\n+\t\tprivate CultureInfo _backupCulture;\n+\t\tprivate CultureInfo _backupUICulture;\n+\n+\t\tprotected override void OnSetUp()\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\t\t\tusing var transaction = session.BeginTransaction();\n+\t\t\tsession.Save(\n+\t\t\t\tnew Entity\n+\t\t\t\t{\n+\t\t\t\t\tName = Entity.NameWithSingleQuote,\n+\t\t\t\t\tFirstChar = Entity.QuoteInitial,\n+\t\t\t\t\tCharacterEnum = CharEnum.SingleQuote,\n+\t\t\t\t\tUriProperty = Entity.UriWithSingleQuote\n+\t\t\t\t});\n+\t\t\tsession.Save(\n+\t\t\t\tnew Entity\n+\t\t\t\t{\n+\t\t\t\t\tName = Entity.NameWithEscapedSingleQuote,\n+\t\t\t\t\tFirstChar = Entity.BackslashInitial,\n+\t\t\t\t\tCharacterEnum = CharEnum.Backslash,\n+\t\t\t\t\tUriProperty = Entity.UriWithEscapedSingleQuote\n+\t\t\t\t});\n+\n+\t\t\ttransaction.Commit();\n+\n+\t\t\t_backupCulture = CultureInfo.CurrentCulture;\n+\t\t\t_backupUICulture = CultureInfo.CurrentUICulture;\n+\t\t}\n+\n+\t\tprotected override void OnTearDown()\n+\t\t{\n+\t\t\tif (_backupCulture != null)\n+\t\t\t{\n+\t\t\t\tCultureInfo.CurrentCulture = _backupCulture;\n+\t\t\t\tCultureInfo.CurrentUICulture = _backupUICulture;\n+\t\t\t}\n+\n+\t\t\tusing var session = OpenSession();\n+\t\t\tusing var transaction = session.BeginTransaction();\n+\t\t\tsession.CreateQuery(\"delete from System.Object\").ExecuteUpdate();\n+\n+\t\t\ttransaction.Commit();\n+\t\t}\n+\n+\t\tprivate static readonly string[] StringInjectionsProperties =\n+\t\t{\n+\t\t\tnameof(Entity.NameWithSingleQuote), nameof(Entity.NameWithEscapedSingleQuote)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(StringInjectionsProperties))]\n+\t\tpublic void SqlInjectionInStrings(string propertyName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.Name = Entity.{propertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(() => list = query.List<Entity>(), Throws.Nothing);\n+\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find entity with name {propertyName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] SpecialNames =\n+\t\t{\n+\t\t\t\"\\0; drop table Entity; --\",\n+\t\t\t\"\\b; drop table Entity; --\",\n+\t\t\t\"\\n; drop table Entity; --\",\n+\t\t\t\"\\r; drop table Entity; --\",\n+\t\t\t\"\\t; drop table Entity; --\",\n+\t\t\t\"\\x1A; drop table Entity; --\",\n+\t\t\t\"\\\"; drop table Entity; --\",\n+\t\t\t\"\\\\; drop table Entity; --\"\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(SpecialNames))]\n+\t\tpublic void StringsWithSpecialCharacters(string name)\n+\t\t{\n+\t\t\t// We may not even be able to insert the entity.\n+\t\t\tvar wasInserted = false;\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tusing var s = OpenSession();\n+\t\t\t\tusing var t = s.BeginTransaction();\n+\t\t\t\tvar e = new Entity { Name = name };\n+\t\t\t\ts.Save(e);\n+\t\t\t\tt.Commit();\n+\n+\t\t\t\twasInserted = true;\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tAssert.Warn($\"The entity insertion failed with message {e}\");\n+\t\t\t}\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tusing var session = OpenSession();\n+\t\t\t\tEntity.ArbitraryStringValue = name;\n+\t\t\t\tvar list = session.CreateQuery($\"from Entity e where e.Name = Entity.{nameof(Entity.ArbitraryStringValue)}\").List<Entity>();\n+\t\t\t\tif (wasInserted && list.Count != 1)\n+\t\t\t\t\tAssert.Warn($\"Unable to find entity with name {nameof(Entity.ArbitraryStringValue)}\");\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tAssert.Warn($\"The query has failed with message {e}\");\n+\t\t\t}\n+\n+\t\t\t// Check the db is not wrecked.\n+\t\t\tif (wasInserted)\n+\t\t\t{\n+\t\t\t\tusing var session = OpenSession();\n+\t\t\t\tvar list = session\n+\t\t\t\t\t.CreateQuery(\"from Entity e where e.Name = :name\")\n+\t\t\t\t\t.SetString(\"name\", name)\n+\t\t\t\t\t.List<Entity>();\n+\t\t\t\tAssert.That(list, Has.Count.EqualTo(1));\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tusing var session = OpenSession();\n+\t\t\t\tvar all = session.CreateQuery(\"from Entity e\").List<Entity>();\n+\t\t\t\tAssert.That(all, Has.Count.GreaterThan(0));\n+\t\t\t}\n+\t\t}\n+\n+\t\t[Test]\n+\t\tpublic void SqlInjectionInStringDiscriminator()\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tsession.Save(new Subclass1 { Name = \"Subclass1\" });\n+\t\t\tsession.Save(new Subclass2 { Name = \"Subclass2\" });\n+\n+\t\t\t// ObjectToSQLString is used for generating the inserts.\n+\t\t\tAssert.That(session.Flush, Throws.Nothing, \"Unable to flush the subclasses\");\n+\n+\t\t\tforeach (var entityName in new[] { nameof(Subclass1), nameof(Subclass2) })\n+\t\t\t{\n+\t\t\t\tvar query = session.CreateQuery($\"from {entityName}\");\n+\t\t\t\tIList list = null;\n+\t\t\t\tAssert.That(() => list = query.List(), Throws.Nothing, $\"Unable to list entities of {entityName}\");\n+\t\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find the {entityName} entity\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static readonly string[] CharInjectionsProperties =\n+\t\t{\n+\t\t\tnameof(Entity.QuoteInitial), nameof(Entity.BackslashInitial)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(CharInjectionsProperties))]\n+\t\tpublic void SqlInjectionInChar(string propertyName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.FirstChar = Entity.{propertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(() => list = query.List<Entity>(), Throws.Nothing);\n+\t\t\tAssert.That(list, Is.Not.Null.And.Count.EqualTo(1), $\"Unable to find entity with initial {propertyName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] CharEnumInjections =\n+\t\t{\n+\t\t\tnameof(CharEnum.SingleQuote), nameof(CharEnum.Backslash)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(CharEnumInjections))]\n+\t\tpublic void SqlInjectionWithCharEnum(string enumName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.CharacterEnum = CharEnum.{enumName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(() => list = query.List<Entity>(), Throws.Nothing);\n+\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find entity with CharacterEnum {enumName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] UriInjections =\n+\t\t{\n+\t\t\tnameof(Entity.UriWithSingleQuote), nameof(Entity.UriWithEscapedSingleQuote)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(UriInjections))]\n+\t\tpublic void SqlInjectionWithUri(string propertyName)\n+\t\t{\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.UriProperty = Entity.{propertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssert.That(() => list = query.List<Entity>(), Throws.Nothing);\n+\t\t\tAssert.That(list, Has.Count.EqualTo(1), $\"Unable to find entity with UriProperty {propertyName}\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] NumericalTypesInjections =\n+\t\t{\n+\t\t\tnameof(Entity.ByteProperty),\n+\t\t\tnameof(Entity.DecimalProperty),\n+\t\t\tnameof(Entity.DoubleProperty),\n+\t\t\tnameof(Entity.FloatProperty),\n+\t\t\tnameof(Entity.ShortProperty),\n+\t\t\tnameof(Entity.IntProperty),\n+\t\t\tnameof(Entity.LongProperty),\n+\t\t\tnameof(Entity.SByteProperty),\n+\t\t\tnameof(Entity.UShortProperty),\n+\t\t\tnameof(Entity.UIntProperty),\n+\t\t\tnameof(Entity.ULongProperty)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(NumericalTypesInjections))]\n+\t\tpublic void SqlInjectionInNumericalType(string propertyName)\n+\t\t{\n+\t\t\tAssume.That(_unsupportedProperties, Does.Not.Contains((object) propertyName), $\"The {propertyName} property is unsupported by the dialect\");\n+\n+\t\t\tEntity.ArbitraryStringValue = \"0; drop table Entity; --\";\n+\t\t\tusing (var session = OpenSession())\n+\t\t\t{\n+\t\t\t\tIQuery query;\n+\t\t\t\t// Defining that query is invalid and should throw.\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tquery = session.CreateQuery($\"from Entity e where e.{propertyName} = Entity.{nameof(Entity.ArbitraryStringValue)}\");\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex)\n+\t\t\t\t{\n+\t\t\t\t\t// All good.\n+\t\t\t\t\tAssert.Pass($\"The wicked query creation has been rejected, as it should: {ex}\");\n+\t\t\t\t\t// Needed for the compiler who does not know \"Pass\" always throw.\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\t// The query definition has been accepted, run it.\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tquery.List<Entity>();\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception ex)\n+\t\t\t\t{\n+\t\t\t\t\t// Expecting no exception at that point, but the test is to check if the injection succeeded.\n+\t\t\t\t\tAssert.Warn($\"The wicked query execution has failed: {ex}\");\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Check if we can still query Entity. If it succeeds, at least it means the injection failed.\n+\t\t\tusing (var session = OpenSession())\n+\t\t\t{\n+\t\t\t\tIList<Entity> list = null;\n+\t\t\t\tAssert.That(() => list = session.CreateQuery(\"from Entity e\").List<Entity>(), Throws.Nothing);\n+\t\t\t\tAssert.That(list, Has.Count.GreaterThan(0));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static readonly string[] DateTypesInjections =\n+\t\t{\n+\t\t\tnameof(Entity.DateTimeProperty),\n+\t\t\tnameof(Entity.DateProperty),\n+\t\t\tnameof(Entity.DateTimeOffsetProperty),\n+\t\t\tnameof(Entity.TimeProperty)\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(DateTypesInjections))]\n+\t\tpublic void SqlInjectionWithDatetime(string propertyName)\n+\t\t{\n+\t\t\tAssume.That(_unsupportedProperties, Does.Not.Contains((object) propertyName), $\"The {propertyName} property is unsupported by the dialect\");\n+\n+\t\t\tvar wickedCulture = new CultureInfo(\"en-US\");\n+\t\t\tif (propertyName == nameof(Entity.TimeProperty))\n+\t\t\t\twickedCulture.DateTimeFormat.ShortTimePattern = \"HH:mm:ss\\\\'\\\"; drop table Entity; --\\\"\";\n+\t\t\telse\n+\t\t\t\twickedCulture.DateTimeFormat.ShortDatePattern = \"yyyy-MM-ddTHH:mm:ss\\\\'\\\"; drop table Entity; --\\\"\";\n+\t\t\tCultureInfo.CurrentCulture = wickedCulture;\n+\t\t\tCultureInfo.CurrentUICulture = wickedCulture;\n+\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar staticPropertyName = propertyName == nameof(Entity.DateTimeOffsetProperty) ?\n+\t\t\t\tnameof(Entity.StaticDateTimeOffsetProperty) : nameof(Entity.StaticDateProperty);\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.{propertyName} = Entity.{staticPropertyName}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssume.That(() => list = query.List<Entity>(), Throws.Nothing,\n+\t\t\t\t\"The first execution of the query failed, the injection has likely failed\");\n+\t\t\t// Execute again to check the table is still here.\n+\t\t\tAssert.That(() => list = query.List<Entity>(), Throws.Nothing,\n+\t\t\t\t\"The second execution of the query failed although the first one did not: the injection has succeeded\");\n+\t\t}\n+\n+\t\tprivate static readonly string[] GuidInjections =\n+\t\t{\n+\t\t\tEntity.NameWithSingleQuote, Entity.NameWithEscapedSingleQuote\n+\t\t};\n+\n+\t\t[TestCaseSource(nameof(GuidInjections))]\n+\t\tpublic void SqlInjectionWithGuid(string injection)\n+\t\t{\n+\t\t\tEntity.ArbitraryStringValue = $\"{Guid.NewGuid()}{injection}\";\n+\t\t\tusing var session = OpenSession();\n+\n+\t\t\tvar query = session.CreateQuery($\"from Entity e where e.GuidProperty = Entity.{nameof(Entity.ArbitraryStringValue)}\");\n+\t\t\tIList<Entity> list = null;\n+\t\t\tAssume.That(() => list = query.List<Entity>(), Throws.Nothing,\n+\t\t\t\t\"The first execution of the query failed, the injection has likely failed\");\n+\t\t\t// Execute again to check the table is still here.\n+\t\t\tAssert.That(() => list = query.List<Entity>(), Throws.Nothing,\n+\t\t\t\t\"The second execution of the query failed although the first one did not: the injection has succeeded\");\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "src/NHibernate.Test/NHSpecificTest/GH3516/Hierarchy.cs",
          "status": "added",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -0,0 +1,18 @@\n+\ufeffusing System;\n+\n+namespace NHibernate.Test.NHSpecificTest.GH3516\n+{\n+\tpublic class BaseClass\n+\t{\n+\t\tpublic virtual Guid Id { get; set; }\n+\t\tpublic virtual string Name { get; set; }\n+\t}\n+\n+\tpublic class Subclass1 : BaseClass\n+\t{\n+\t}\n+\n+\tpublic class Subclass2 : BaseClass\n+\t{\n+\t}\n+}"
        },
        {
          "filename": "src/NHibernate.Test/SqlCommandTest/SqlInsertBuilderFixture.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -56,7 +56,7 @@ public void Commented()\n \t\t\tinsert.SetTableName(\"test_insert_builder\");\n \n #pragma warning disable CS0618 // Type or member is obsolete\n-\t\t\tinsert.AddColumn(\"stringColumn\", \"aSQLValue\", (ILiteralType)NHibernateUtil.String);\n+\t\t\tinsert.AddColumn(\"stringColumn\", \"aSQLValue\", (ILiteralType)NHibernateUtil.AnsiString);\n #pragma warning restore CS0618 // Type or member is obsolete\n \t\t\tinsert.SetComment(\"Test insert\");\n \t\t\tstring expectedSql ="
        },
        {
          "filename": "src/NHibernate.Test/TestDialect.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -105,7 +105,7 @@ public bool SupportsEmptyInsertsOrHasNonIdentityNativeGenerator\n \t\t/// </summary>\n \t\tpublic virtual bool SupportsNonDataBoundCondition => true;\n \n-\t\tpublic bool SupportsSqlType(SqlType sqlType)\n+\t\tpublic virtual bool SupportsSqlType(SqlType sqlType)\n \t\t{\n \t\t\ttry\n \t\t\t{"
        },
        {
          "filename": "src/NHibernate.Test/TestDialects/Oracle10gTestDialect.cs",
          "status": "modified",
          "additions": 13,
          "deletions": 1,
          "patch": "@@ -1,4 +1,6 @@\n-\ufeffusing System.Runtime.InteropServices;\n+\ufeffusing System.Data;\n+using System.Runtime.InteropServices;\n+using NHibernate.SqlTypes;\n \n namespace NHibernate.Test.TestDialects\n {\n@@ -15,6 +17,16 @@ public Oracle10gTestDialect(Dialect.Dialect dialect) : base(dialect)\n \n \t\tpublic override bool SupportsAggregateInSubSelect => true;\n \n+\t\tpublic override bool SupportsSqlType(SqlType sqlType)\n+\t\t{\n+\t\t\t// The Oracle dialects define types for DbType the Oracle driver does not support.\n+\t\t\treturn sqlType.DbType switch\n+\t\t\t{\n+\t\t\t\tDbType.UInt16 or DbType.UInt32 or DbType.UInt64 => false,\n+\t\t\t\t_ => base.SupportsSqlType(sqlType)\n+\t\t\t};\n+\t\t}\n+\n \t\t/// <inheritdoc />\n \t\t/// <remarks>Canceling a query hangs under Linux with OracleManagedDataClientDriver 21.6.1.</remarks>\n \t\tpublic override bool SupportsCancelQuery => !RuntimeInformation.IsOSPlatform(OSPlatform.Linux);"
        },
        {
          "filename": "src/NHibernate.Test/TestDialects/SapSQLAnywhere17TestDialect.cs",
          "status": "modified",
          "additions": 15,
          "deletions": 2,
          "patch": "@@ -1,4 +1,7 @@\n-\ufeffnamespace NHibernate.Test.TestDialects\n+\ufeffusing System.Data;\n+using NHibernate.SqlTypes;\n+\n+namespace NHibernate.Test.TestDialects\n {\n \tpublic class SapSQLAnywhere17TestDialect : TestDialect\n \t{\n@@ -40,8 +43,18 @@ public SapSQLAnywhere17TestDialect(Dialect.Dialect dialect)\n \t\tpublic override bool HasBrokenTypeInferenceOnSelectedParameters => true;\n \n \t\t/// <summary>\n-\t\t/// Does not support SELECT FOR UPDATE \n+\t\t/// Does not support SELECT FOR UPDATE.\n \t\t/// </summary>\n \t\tpublic override bool SupportsSelectForUpdate => false;\n+\n+\t\tpublic override bool SupportsSqlType(SqlType sqlType)\n+\t\t{\n+\t\t\t// The Anywhere dialects define types for DbType the Anywhere driver does not support.\n+\t\t\treturn sqlType.DbType switch\n+\t\t\t{\n+\t\t\t\tDbType.SByte => false,\n+\t\t\t\t_ => base.SupportsSqlType(sqlType)\n+\t\t\t};\n+\t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Async/Type/ByteType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -12,6 +12,7 @@\n using System.Collections;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n "
        },
        {
          "filename": "src/NHibernate/Async/Type/Int16Type.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -10,11 +10,12 @@\n \n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {"
        },
        {
          "filename": "src/NHibernate/Async/Type/Int32Type.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -10,11 +10,12 @@\n \n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {"
        },
        {
          "filename": "src/NHibernate/Async/Type/Int64Type.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n "
        },
        {
          "filename": "src/NHibernate/Async/Type/TicksType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -11,6 +11,7 @@\n using System;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n "
        },
        {
          "filename": "src/NHibernate/Async/Type/TimeAsTimeSpanType.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -10,11 +10,12 @@\n \n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {"
        },
        {
          "filename": "src/NHibernate/Async/Type/TimeSpanType.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -10,11 +10,12 @@\n \n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {"
        },
        {
          "filename": "src/NHibernate/Async/Type/UInt16Type.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n "
        },
        {
          "filename": "src/NHibernate/Async/Type/UInt32Type.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n "
        },
        {
          "filename": "src/NHibernate/Async/Type/UInt64Type.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n "
        },
        {
          "filename": "src/NHibernate/Cfg/Environment.cs",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -119,6 +119,12 @@ public static string Version\n \t\t/// <summary> Enable formatting of SQL logged to the console</summary>\n \t\tpublic const string FormatSql = \"format_sql\";\n \n+\t\t/// <summary>\n+\t\t/// Indicates if the database needs to have backslash escaped in string literals.\n+\t\t/// </summary>\n+\t\t/// <remarks>The default value is dialect dependent.</remarks>\n+\t\tpublic const string EscapeBackslashInStrings = \"escape_backslash_in_strings\";\n+\n \t\t// Since v5.0.1\n \t\t[Obsolete(\"This setting has no usages and will be removed in a future version\")]\n \t\tpublic const string UseGetGeneratedKeys = \"jdbc.use_get_generated_keys\";"
        },
        {
          "filename": "src/NHibernate/Dialect/DB2Dialect.cs",
          "status": "modified",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@\n using NHibernate.Dialect.Function;\n using NHibernate.Dialect.Schema;\n using NHibernate.SqlCommand;\n+using NHibernate.SqlTypes;\n \n namespace NHibernate.Dialect\n {\n@@ -296,6 +297,30 @@ public override string ForUpdateString\n \n \t\tpublic override long TimestampResolutionInTicks => 10L; // Microseconds.\n \n+\t\t/// <inheritdoc />\n+\t\tpublic override string ToStringLiteral(string value, SqlType type)\n+\t\t{\n+\t\t\tif (value == null)\n+\t\t\t\tthrow new System.ArgumentNullException(nameof(value));\n+\t\t\tif (type == null)\n+\t\t\t\tthrow new System.ArgumentNullException(nameof(value));\n+\n+\t\t\t// See https://www.ibm.com/docs/en/db2/11.5?topic=elements-constants#r0000731__title__7\n+\t\t\tvar literal = new StringBuilder(value);\n+\t\t\tvar isUnicode = type.DbType == DbType.String || type.DbType == DbType.StringFixedLength;\n+\t\t\tif (isUnicode)\n+\t\t\t\tliteral.Replace(@\"\\\", @\"\\\\\");\n+\n+\t\t\tliteral\n+\t\t\t\t.Replace(\"'\", \"''\")\n+\t\t\t\t.Insert(0, '\\'')\n+\t\t\t\t.Append('\\'');\n+\n+\t\t\tif (isUnicode)\n+\t\t\t\tliteral.Insert(0, \"U&\");\n+\t\t\treturn literal.ToString();\n+\t\t}\n+\n \t\t#region Overridden informational metadata\n \n \t\tpublic override bool SupportsNullInUnique => false;"
        },
        {
          "filename": "src/NHibernate/Dialect/Dialect.cs",
          "status": "modified",
          "additions": 50,
          "deletions": 8,
          "patch": "@@ -208,6 +208,7 @@ public virtual void Configure(IDictionary<string, string> settings)\n \t\t\tDefaultCastLength = PropertiesHelper.GetInt32(Environment.QueryDefaultCastLength, settings, 4000);\n \t\t\tDefaultCastPrecision = PropertiesHelper.GetByte(Environment.QueryDefaultCastPrecision, settings, null) ?? 29;\n \t\t\tDefaultCastScale = PropertiesHelper.GetByte(Environment.QueryDefaultCastScale, settings, null) ?? 10;\n+\t\t\tEscapeBackslashInStrings = PropertiesHelper.GetBoolean(Environment.EscapeBackslashInStrings, settings, EscapeBackslashInStrings);\n \t\t}\n \n \t\t#endregion\n@@ -1354,14 +1355,6 @@ public virtual CaseFragment CreateCaseFragment()\n \t\t\treturn new ANSICaseFragment(this);\n \t\t}\n \n-\t\t/// <summary> The SQL literal value to which this database maps boolean values. </summary>\n-\t\t/// <param name=\"value\">The boolean value </param>\n-\t\t/// <returns> The appropriate SQL literal. </returns>\n-\t\tpublic virtual string ToBooleanValueString(bool value)\n-\t\t{\n-\t\t\treturn value ? \"1\" : \"0\";\n-\t\t}\n-\n \t\tinternal static void ExtractColumnOrAliasNames(SqlString select, out List<SqlString> columnsOrAliases, out Dictionary<SqlString, SqlString> aliasToColumn, out Dictionary<SqlString, SqlString> columnToAlias)\n \t\t{\n \t\t\tcolumnsOrAliases = new List<SqlString>();\n@@ -2076,6 +2069,55 @@ public virtual string ConvertQuotesForCatalogName(string catalogName)\n \n \t\t#endregion\n \n+\t\t#region Literals support\n+\n+\t\t/// <summary>The SQL literal value to which this database maps boolean values.</summary>\n+\t\t/// <param name=\"value\">The boolean value.</param>\n+\t\t/// <returns>The appropriate SQL literal.</returns>\n+\t\tpublic virtual string ToBooleanValueString(bool value)\n+\t\t\t=> value ? \"1\" : \"0\";\n+\n+\t\t/// <summary>\n+\t\t/// <see langword=\"true\" /> if the database needs to have backslash escaped in string literals.\n+\t\t/// </summary>\n+\t\t/// <remarks><see langword=\"false\" /> by default in the base dialect, to conform to SQL standard.</remarks>\n+\t\tprotected virtual bool EscapeBackslashInStrings { get; set; }\n+\n+\t\t/// <summary>\n+\t\t/// <see langword=\"true\" /> if the database needs to have Unicode literals prefixed by <c>N</c>.\n+\t\t/// </summary>\n+\t\t/// <remarks><see langword=\"false\" /> by default in the base dialect.</remarks>\n+\t\tprotected virtual bool UseNPrefixForUnicodeStrings => false;\n+\n+\t\t/// <summary>The SQL string literal value to which this database maps string values.</summary>\n+\t\t/// <param name=\"value\">The string value.</param>\n+\t\t/// <param name=\"type\">The SQL type of the string value.</param>\n+\t\t/// <returns>The appropriate SQL string literal.</returns>\n+\t\t/// <exception cref=\"ArgumentNullException\">Thrown if <paramref name=\"value\"/> or\n+\t\t/// <paramref name=\"type\"/> is <see langword=\"null\" />.</exception>\n+\t\tpublic virtual string ToStringLiteral(string value, SqlType type)\n+\t\t{\n+\t\t\tif (value == null)\n+\t\t\t\tthrow new ArgumentNullException(nameof(value));\n+\t\t\tif (type == null)\n+\t\t\t\tthrow new ArgumentNullException(nameof(type));\n+\n+\t\t\tvar literal = new StringBuilder(value);\n+\t\t\tif (EscapeBackslashInStrings)\n+\t\t\t\tliteral.Replace(@\"\\\", @\"\\\\\");\n+\n+\t\t\tliteral\n+\t\t\t\t.Replace(\"'\", \"''\")\n+\t\t\t\t.Insert(0, '\\'')\n+\t\t\t\t.Append('\\'');\n+\n+\t\t\tif (UseNPrefixForUnicodeStrings && (type.DbType == DbType.String || type.DbType == DbType.StringFixedLength))\n+\t\t\t\tliteral.Insert(0, 'N');\n+\t\t\treturn literal.ToString();\n+\t\t}\n+\n+\t\t#endregion\n+\n \t\t#region Union subclass support\n \n \t\t/// <summary> "
        },
        {
          "filename": "src/NHibernate/Dialect/IngresDialect.cs",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -62,6 +62,11 @@ public IngresDialect()\n \t\t/// <inheritdoc />\n \t\tpublic override int MaxAliasLength => 32;\n \n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for Ingres,\n+\t\t/// <see href=\"https://docs.actian.com/ingres/11.0/index.html#page/SQLRef/String_Literals.htm#ww110572\" />.</remarks>\n+\t\tprotected override bool UseNPrefixForUnicodeStrings => true;\n+\n \t\t#region Overridden informational metadata\n \n \t\tpublic override bool SupportsEmptyInList => false;"
        },
        {
          "filename": "src/NHibernate/Dialect/MsSql2000Dialect.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -755,6 +755,10 @@ public override bool SupportsSqlBatches\n \t\t/// </summary>\n \t\tpublic override int? MaxNumberOfParameters => 2097;\n \n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for SQL Server.</remarks>\n+\t\tprotected override bool UseNPrefixForUnicodeStrings => true;\n+\n \t\t#region Overridden informational metadata\n \n \t\tpublic override bool SupportsEmptyInList => false;"
        },
        {
          "filename": "src/NHibernate/Dialect/MySQLDialect.cs",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -530,6 +530,16 @@ public override long TimestampResolutionInTicks\n \t\t/// </remarks>\n \t\tpublic override bool SupportsConcurrentWritingConnectionsInSameTransaction => false;\n \n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for MySQL,\n+\t\t/// <see href=\"https://dev.mysql.com/doc/refman/8.0/en/string-literals.html\" />.</remarks>\n+\t\tprotected override bool EscapeBackslashInStrings { get; set; } = true;\n+\n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for MySQL,\n+\t\t/// <see href=\"https://dev.mysql.com/doc/refman/8.0/en/string-literals.html\" />.</remarks>\n+\t\tprotected override bool UseNPrefixForUnicodeStrings => true;\n+\n \t\t#region Overridden informational metadata\n \n \t\tpublic override bool SupportsEmptyInList => false;"
        },
        {
          "filename": "src/NHibernate/Dialect/Oracle8iDialect.cs",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -102,6 +102,7 @@ public override void Configure(IDictionary<string, string> settings)\n \n \t\t\t// If changing the default value, keep it in sync with OracleDataClientDriverBase.Configure.\n \t\t\tUseNPrefixedTypesForUnicode = PropertiesHelper.GetBoolean(Environment.OracleUseNPrefixedTypesForUnicode, settings, false);\n+\n \t\t\tRegisterCharacterTypeMappings();\n \t\t\tRegisterFloatingPointTypeMappings();\n \t\t}\n@@ -561,6 +562,10 @@ public override long TimestampResolutionInTicks\n \t\t/// <inheritdoc />\n \t\tpublic override int MaxAliasLength => 30;\n \n+\t\t/// <inheritdoc />\n+\t\t/// <remarks>Returns the same value as <see cref=\"UseNPrefixedTypesForUnicode\" />.</remarks>\n+\t\tprotected override bool UseNPrefixForUnicodeStrings => UseNPrefixedTypesForUnicode;\n+\n \t\t#region Overridden informational metadata\n \n \t\tpublic override bool SupportsEmptyInList"
        },
        {
          "filename": "src/NHibernate/Dialect/SybaseASA9Dialect.cs",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -9,7 +9,7 @@\n namespace NHibernate.Dialect\n {\n \t/// <summary>\n-\t/// An SQL dialect for Sybase Adaptive Server Anywhere 9.0\n+\t/// An SQL dialect for Sybase Adaptive Server Anywhere 9.0. (Renamed SQL Anywhere from its version 10.)\n \t/// </summary>\n \t/// <remarks>\n \t/// <p>\n@@ -188,5 +188,15 @@ private static int GetAfterSelectInsertPoint(SqlString sql)\n \t\t\t}\n \t\t\treturn 0;\n \t\t}\n+\n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for SQL Anywhere,\n+\t\t/// <see href=\"https://help.sap.com/docs/SAP_SQL_Anywhere/93079d4ba8e44920ae63ffb4def91f5b/817a3ded6ce21014bd99f3e554573180.html?version=17.0\" />.</remarks>\n+\t\tprotected override bool EscapeBackslashInStrings { get; set; } = true;\n+\n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for SQL Anywhere,\n+\t\t/// <see href=\"https://help.sap.com/docs/SAP_SQL_Anywhere/93079d4ba8e44920ae63ffb4def91f5b/817a2c5f6ce21014aceea962de72126c.html?version=17.0\" />.</remarks>\n+\t\tprotected override bool UseNPrefixForUnicodeStrings => true;\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Dialect/SybaseSQLAnywhere10Dialect.cs",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -969,5 +969,15 @@ public override IDataBaseSchema GetDataBaseSchema(DbConnection connection)\n \t\t/// <inheritdoc />\n \t\t/// <remarks>SQL Anywhere has a micro-second resolution.</remarks>\n \t\tpublic override long TimestampResolutionInTicks => 10L;\n+\n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for SQL Anywhere,\n+\t\t/// <see href=\"https://help.sap.com/docs/SAP_SQL_Anywhere/93079d4ba8e44920ae63ffb4def91f5b/817a3ded6ce21014bd99f3e554573180.html?version=17.0\" />.</remarks>\n+\t\tprotected override bool EscapeBackslashInStrings { get; set; } = true;\n+\n+\t\t/// <inheritdoc />\n+\t\t/// <remarks><see langword=\"true\" /> by default for SQL Anywhere,\n+\t\t/// <see href=\"https://help.sap.com/docs/SAP_SQL_Anywhere/93079d4ba8e44920ae63ffb4def91f5b/817a2c5f6ce21014aceea962de72126c.html?version=17.0\" />.</remarks>\n+\t\tprotected override bool UseNPrefixForUnicodeStrings => true;\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/AbstractCharType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -51,9 +51,7 @@ public override void Set(DbCommand cmd, object value, int index, ISessionImpleme\n \t\t}\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn '\\'' + value.ToString() + '\\'';\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral(value.ToString(), SqlType);\n \n \t\t// 6.0 TODO: rename \"xml\" parameter as \"value\": it is not a xml string. The fact it generally comes from a xml\n \t\t// attribute value is irrelevant to the method behavior."
        },
        {
          "filename": "src/NHibernate/Type/AbstractDateTimeType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -176,7 +176,7 @@ public override object FromStringValue(string xml)\n \t\tpublic override object DefaultValue => BaseDateValue;\n \n \t\t/// <inheritdoc />\n-\t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect) =>\n-\t\t\t\"'\" + (DateTime) value + \"'\";\n+\t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n+\t\t\t=> dialect.ToStringLiteral(((DateTime) value).ToString(), SqlTypeFactory.GetAnsiString(50));\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/AbstractStringType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 3,
          "patch": "@@ -134,10 +134,9 @@ public object StringToObject(string xml)\n \n \t\t#region ILiteralType Members\n \n+\t\t/// <inheritdoc />\n \t\tpublic string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn \"'\" + (string)value + \"'\";\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral((string)value, SqlType);\n \n \t\t#endregion\n "
        },
        {
          "filename": "src/NHibernate/Type/ByteType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -2,6 +2,7 @@\n using System.Collections;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -54,7 +55,7 @@ public override string Name\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((byte)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \n \t\t// 6.0 TODO: rename \"xml\" parameter as \"value\": it is not a xml string. The fact it generally comes from a xml"
        },
        {
          "filename": "src/NHibernate/Type/CharBooleanType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 4,
          "patch": "@@ -3,7 +3,6 @@\n using System.Data.Common;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using NHibernate.Util;\n \n namespace NHibernate.Type\n {\n@@ -57,9 +56,7 @@ private string ToCharacter(object value)\n \t\t}\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn \"'\" + ToCharacter(value) + \"'\";\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral(ToCharacter(value), SqlType);\n \n \t\t// 6.0 TODO: rename \"xml\" parameter as \"value\": it is not a xml string. The fact it generally comes from a xml\n \t\t// attribute value is irrelevant to the method behavior."
        },
        {
          "filename": "src/NHibernate/Type/DateTimeOffSetType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -155,8 +155,6 @@ public override object FromStringValue(string xml)\n \t\t}\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn \"'\" + ((DateTimeOffset) value) + \"'\";\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral(((DateTimeOffset) value).ToString(), SqlTypeFactory.GetAnsiString(50));\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/DateType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -93,8 +93,8 @@ public override string ToString(object val) =>\n \t\tpublic override object DefaultValue => customBaseDate;\n \n \t\t/// <inheritdoc />\n-\t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect) =>\n-\t\t\t\"\\'\" + ((DateTime)value).ToShortDateString() + \"\\'\";\n+\t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n+\t\t\t=> dialect.ToStringLiteral(((DateTime) value).ToShortDateString(), SqlTypeFactory.GetAnsiString(50));\n \n \t\t// Since v5\n \t\t[Obsolete(\"Its only parameter, BaseValue, is obsolete.\")]"
        },
        {
          "filename": "src/NHibernate/Type/DecimalType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n using System;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -66,7 +67,7 @@ public override object FromStringValue(string xml)\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((decimal)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \n \t\t// 6.0 TODO: rename \"xml\" parameter as \"value\": it is not a xml string. The fact it generally comes from a xml"
        },
        {
          "filename": "src/NHibernate/Type/DoubleType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n using System;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -66,7 +67,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((double)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/EnumCharType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -171,8 +171,6 @@ public override object FromStringValue(string xml)\n \t\t}\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn '\\'' + GetValue(value).ToString() + '\\'';\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral(GetValue(value).ToString(), SqlType);\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/GuidType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -88,7 +88,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn \"'\" + value + \"'\";\n+\t\t\treturn dialect.ToStringLiteral(value.ToString(), SqlTypeFactory.GetAnsiString(50));\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/Int16Type.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -1,10 +1,11 @@\n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {\n@@ -114,7 +115,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((short)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/Int32Type.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -1,10 +1,11 @@\n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {\n@@ -114,7 +115,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((int)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/Int64Type.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,6 +3,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -114,7 +115,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((long)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/SByteType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,6 +3,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -116,7 +117,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((sbyte)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/SingleType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n using System;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -91,7 +92,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((float)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/TicksType.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,6 +1,7 @@\n using System;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -100,7 +101,7 @@ public override object Seed(ISessionImplementor session)\n \t\t/// <inheritdoc />\n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn '\\'' + ((DateTime)value).Ticks.ToString() + '\\'';\n+\t\t\treturn '\\'' + ((DateTime)value).Ticks.ToString(CultureInfo.InvariantCulture) + '\\'';\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/TimeAsTimeSpanType.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -1,10 +1,11 @@\n \ufeffusing System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {\n@@ -141,7 +142,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn '\\'' + ((TimeSpan)value).Ticks.ToString() + '\\'';\n+\t\t\treturn '\\'' + ((TimeSpan)value).Ticks.ToString(CultureInfo.InvariantCulture) + '\\'';\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/TimeSpanType.cs",
          "status": "modified",
          "additions": 4,
          "deletions": 3,
          "patch": "@@ -1,10 +1,11 @@\n using System;\n using System.Collections;\n+using System.Collections.Generic;\n+using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n-using System.Collections.Generic;\n-using System.Data;\n \n namespace NHibernate.Type\n {\n@@ -128,7 +129,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn '\\'' + ((TimeSpan)value).Ticks.ToString() + '\\'';\n+\t\t\treturn '\\'' + ((TimeSpan)value).Ticks.ToString(CultureInfo.InvariantCulture) + '\\'';\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/TimeType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -171,8 +171,6 @@ public override object DefaultValue\n \t\t}\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn \"'\" + ((DateTime)value).ToShortTimeString() + \"'\";\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral(((DateTime) value).ToShortTimeString(), SqlTypeFactory.GetAnsiString(50));\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/UInt16Type.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,6 +3,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -114,7 +115,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((ushort)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/UInt32Type.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,6 +3,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -114,7 +115,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((uint)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/UInt64Type.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -3,6 +3,7 @@\n using System.Collections.Generic;\n using System.Data;\n using System.Data.Common;\n+using System.Globalization;\n using NHibernate.Engine;\n using NHibernate.SqlTypes;\n \n@@ -113,7 +114,7 @@ public override object DefaultValue\n \n \t\tpublic override string ObjectToSQLString(object value, Dialect.Dialect dialect)\n \t\t{\n-\t\t\treturn value.ToString();\n+\t\t\treturn ((ulong)value).ToString(CultureInfo.InvariantCulture);\n \t\t}\n \t}\n }"
        },
        {
          "filename": "src/NHibernate/Type/UriType.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -84,9 +84,7 @@ public override object FromStringValue(string xml)\n \t\t}\n \n \t\tpublic string ObjectToSQLString(object value, Dialect.Dialect dialect)\n-\t\t{\n-\t\t\treturn \"'\" + ((Uri)value).OriginalString + \"'\";\n-\t\t}\n+\t\t\t=> dialect.ToStringLiteral(((Uri) value).OriginalString, SqlType);\n \n \t\t/// <inheritdoc />\n \t\tpublic override object Assemble(object cached, ISessionImplementor session, object owner)"
        },
        {
          "filename": "src/NHibernate/nhibernate-configuration.xsd",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -176,6 +176,14 @@\n \t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"default_flush_mode\" />\n \t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"use_sql_comments\" />\n \t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"format_sql\" />\n+\t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"escape_backslash_in_strings\">\n+\t\t\t\t\t\t\t\t\t\t\t<xs:annotation>\n+\t\t\t\t\t\t\t\t\t\t\t\t<xs:documentation>\n+\t\t\t\t\t\t\t\t\t\t\t\t\tIndicates if the database needs to have backslash escaped in string literals. The default is\n+\t\t\t\t\t\t\t\t\t\t\t\t\tdialect dependent.\n+\t\t\t\t\t\t\t\t\t\t\t\t</xs:documentation>\n+\t\t\t\t\t\t\t\t\t\t\t</xs:annotation>\n+\t\t\t\t\t\t\t\t\t\t</xs:enumeration>\n \t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"collectiontype.factory_class\" />\n \t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"order_inserts\" />\n \t\t\t\t\t\t\t\t\t\t<xs:enumeration value=\"order_updates\" />"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 8,
        "unique_directories": 12,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "0c9e4421933b613676913a312926eeb1ee673142",
            "date": "2024-11-07T23:10:20Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "a591fb5c4d13acf3dc43e2c02ffb92a7c749441d",
            "date": "2024-11-01T10:36:32Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "894529983457c110f2934904f27e2c3e9398c581",
            "date": "2024-09-05T13:38:46Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "095e557c044e171eeb87e548eeef7c93088c0cf9",
            "date": "2024-09-05T07:17:48Z",
            "author_login": "fredericDelaporte"
          },
          {
            "sha": "26f8d351c9639cb6a9644a61968db868c55efbcd",
            "date": "2024-09-01T17:06:39Z",
            "author_login": "nfplee"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-89",
    "description": "NHibernate is an object-relational mapper for the .NET framework. A SQL injection vulnerability exists in some types implementing ILiteralType.ObjectToSQLString. Callers of these methods are exposed to the vulnerability, which includes mappings using inheritance with discriminator values; HQL queries referencing a static field of the application; users of the SqlInsertBuilder and SqlUpdateBuilder utilities, calling their AddColumn overload taking a literal value; and any direct use of the ObjectToSQLString methods for building SQL queries on the user side. This vulnerability is fixed in 5.4.9 and 5.5.2.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-07-08T15:15:22.450",
    "last_modified": "2024-11-21T09:28:12.080",
    "fix_date": "2024-07-02T22:56:52Z"
  },
  "references": [
    {
      "url": "https://github.com/nhibernate/nhibernate-core/commit/b4a69d1a5ff5744312478d70308329af496e4ba9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/issues/3516",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/pull/3517",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/pull/3547",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/security/advisories/GHSA-fg4q-ccq8-3r5q",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/commit/b4a69d1a5ff5744312478d70308329af496e4ba9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/issues/3516",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/pull/3517",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/pull/3547",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking",
        "Patch"
      ]
    },
    {
      "url": "https://github.com/nhibernate/nhibernate-core/security/advisories/GHSA-fg4q-ccq8-3r5q",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.897077",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "nhibernate-core",
    "owner": "nhibernate",
    "created_at": "2011-08-14T17:51:09Z",
    "updated_at": "2025-01-10T14:36:47Z",
    "pushed_at": "2024-11-07T23:10:21Z",
    "size": 94778,
    "stars": 2136,
    "forks": 933,
    "open_issues": 680,
    "watchers": 2136,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "1.2.x",
      "2.0.x",
      "2.1.x",
      "3.3.x",
      "3.4.x",
      "4.0.x",
      "4.1.x",
      "5.0.x",
      "5.1.x",
      "5.2.x",
      "5.3.x",
      "5.4.x",
      "5.5.x",
      "master"
    ],
    "languages": {
      "C#": 23805767,
      "TSQL": 935047,
      "GAP": 44395,
      "JavaScript": 34059,
      "Visual Basic .NET": 14311,
      "Batchfile": 11357,
      "PowerShell": 7787,
      "Shell": 4665,
      "HTML": 1164
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "lgpl-2.1"
    },
    "collected_at": "2025-01-14T16:32:28.046453"
  }
}