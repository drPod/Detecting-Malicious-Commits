{
  "cve_id": "CVE-2024-39690",
  "github_data": {
    "repository": "projectcapsule/capsule",
    "fix_commit": "d620b0457ddec01616b8eab8512a10611611f584",
    "related_commits": [
      "d620b0457ddec01616b8eab8512a10611611f584"
    ],
    "patch_url": "https://github.com/projectcapsule/capsule/commit/d620b0457ddec01616b8eab8512a10611611f584.patch",
    "fix_commit_details": {
      "sha": "d620b0457ddec01616b8eab8512a10611611f584",
      "commit_date": "2024-08-20T08:19:14Z",
      "author": {
        "login": "oliverbaehler",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 80,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 157,
        "additions": 152,
        "deletions": 5
      },
      "files": [
        {
          "filename": "charts/capsule/templates/configuration-default.yaml",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -25,4 +25,5 @@ spec:\n   nodeMetadata:\n     {{- toYaml . | nindent 4 }}\n   {{- end }}\n-{{- end }}\n\\ No newline at end of file\n+{{- end }}\n+"
        },
        {
          "filename": "e2e/namespace_hijacking_test.go",
          "status": "added",
          "additions": 119,
          "deletions": 0,
          "patch": "@@ -0,0 +1,119 @@\n+//go:build e2e\n+\n+// Copyright 2020-2023 Project Capsule Authors.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package e2e\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\t\"math/rand\"\n+\n+\t. \"github.com/onsi/ginkgo/v2\"\n+\t. \"github.com/onsi/gomega\"\n+\tcapsulev1beta2 \"github.com/projectcapsule/capsule/api/v1beta2\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/types\"\n+)\n+\n+var _ = Describe(\"creating several Namespaces for a Tenant\", func() {\n+\ttnt := &capsulev1beta2.Tenant{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName: \"capsule-ns-attack-1\",\n+\t\t},\n+\t\tSpec: capsulev1beta2.TenantSpec{\n+\t\t\tOwners: capsulev1beta2.OwnerListSpec{\n+\t\t\t\t{\n+\t\t\t\t\tName: \"charlie\",\n+\t\t\t\t\tKind: \"User\",\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tKind: \"ServiceAccount\",\n+\t\t\t\t\tName: \"system:serviceaccount:attacker-system:attacker\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tkubeSystem := &corev1.Namespace{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName: \"kube-system\",\n+\t\t},\n+\t}\n+\tJustBeforeEach(func() {\n+\t\tEventuallyCreation(func() (err error) {\n+\t\t\ttnt.ResourceVersion = \"\"\n+\t\t\terr = k8sClient.Create(context.TODO(), tnt)\n+\n+\t\t\treturn\n+\t\t}).Should(Succeed())\n+\t})\n+\tJustAfterEach(func() {\n+\t\tExpect(k8sClient.Delete(context.TODO(), tnt)).Should(Succeed())\n+\n+\t})\n+\n+\tIt(\"Can't hijack offlimits namespace\", func() {\n+\t\ttenant := &capsulev1beta2.Tenant{}\n+\t\tExpect(k8sClient.Get(context.TODO(), types.NamespacedName{Name: tnt.Name}, tenant)).Should(Succeed())\n+\n+\t\t// Get the namespace\n+\t\tExpect(k8sClient.Get(context.TODO(), types.NamespacedName{Name: kubeSystem.GetName()}, kubeSystem)).Should(Succeed())\n+\n+\t\tfor _, owner := range tnt.Spec.Owners {\n+\t\t\tcs := ownerClient(owner)\n+\n+\t\t\tpatch := []byte(fmt.Sprintf(`{\"metadata\":{\"ownerReferences\":[{\"apiVersion\":\"%s/%s\",\"kind\":\"Tenant\",\"name\":\"%s\",\"uid\":\"%s\"}]}}`, capsulev1beta2.GroupVersion.Group, capsulev1beta2.GroupVersion.Version, tenant.GetName(), tenant.GetUID()))\n+\n+\t\t\t_, err := cs.CoreV1().Namespaces().Patch(context.TODO(), kubeSystem.Name, types.StrategicMergePatchType, patch, metav1.PatchOptions{})\n+\t\t\tExpect(err).To(HaveOccurred())\n+\n+\t\t}\n+\t})\n+\n+\tIt(\"Owners can create and attempt to patch new namespaces but patches should not be applied\", func() {\n+\t\tfor _, owner := range tnt.Spec.Owners {\n+\t\t\tcs := ownerClient(owner)\n+\n+\t\t\t// Each owner creates a new namespace\n+\t\t\tns := NewNamespace(\"\")\n+\t\t\tNamespaceCreation(ns, owner, defaultTimeoutInterval).Should(Succeed())\n+\n+\t\t\t// Attempt to patch the owner references of the new namespace\n+\t\t\ttenant := &capsulev1beta2.Tenant{}\n+\t\t\tExpect(k8sClient.Get(context.TODO(), types.NamespacedName{Name: tnt.Name}, tenant)).Should(Succeed())\n+\n+\t\t\trandomUID := types.UID(fmt.Sprintf(\"%d\", rand.Int()))\n+\t\t\trandomName := fmt.Sprintf(\"random-tenant-%d\", rand.Int())\n+\t\t\tpatch := []byte(fmt.Sprintf(`{\"metadata\":{\"ownerReferences\":[{\"apiVersion\":\"%s/%s\",\"kind\":\"Tenant\",\"name\":\"%s\",\"uid\":\"%s\"}]}}`, capsulev1beta2.GroupVersion.Group, capsulev1beta2.GroupVersion.Version, randomName, randomUID))\n+\n+\t\t\t_, err := cs.CoreV1().Namespaces().Patch(context.TODO(), ns.Name, types.StrategicMergePatchType, patch, metav1.PatchOptions{})\n+\t\t\tExpect(err).ToNot(HaveOccurred())\n+\n+\t\t\tretrievedNs := &corev1.Namespace{}\n+\t\t\tExpect(k8sClient.Get(context.TODO(), types.NamespacedName{Name: ns.Name}, retrievedNs)).Should(Succeed())\n+\n+\t\t\t// Check if the namespace has an owner reference with the specific UID and name\n+\t\t\thasSpecificOwnerRef := false\n+\t\t\tfor _, ownerRef := range retrievedNs.OwnerReferences {\n+\t\t\t\tif ownerRef.UID == randomUID && ownerRef.Name == randomName {\n+\t\t\t\t\thasSpecificOwnerRef = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tExpect(hasSpecificOwnerRef).To(BeFalse(), \"Namespace should not have owner reference with UID %s and name %s\", randomUID, randomName)\n+\n+\t\t\thasOriginReference := false\n+\t\t\tfor _, ownerRef := range retrievedNs.OwnerReferences {\n+\t\t\t\tif ownerRef.UID == tenant.GetUID() && ownerRef.Name == tenant.GetName() {\n+\t\t\t\t\thasOriginReference = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tExpect(hasOriginReference).To(BeTrue(), \"Namespace should have origin reference\", tenant.GetUID(), tenant.GetName())\n+\t\t}\n+\t})\n+\n+})"
        },
        {
          "filename": "pkg/webhook/ownerreference/patching.go",
          "status": "modified",
          "additions": 31,
          "deletions": 4,
          "patch": "@@ -7,6 +7,7 @@ import (\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"k8s.io/apimachinery/pkg/fields\"\n \t\"net/http\"\n \t\"sort\"\n \t\"strings\"\n@@ -49,15 +50,26 @@ func (h *handler) OnDelete(client.Client, admission.Decoder, record.EventRecorde\n \t}\n }\n \n-func (h *handler) OnUpdate(_ client.Client, decoder admission.Decoder, _ record.EventRecorder) capsulewebhook.Func {\n-\treturn func(_ context.Context, req admission.Request) *admission.Response {\n+func (h *handler) OnUpdate(c client.Client, decoder admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {\n+\treturn func(ctx context.Context, req admission.Request) *admission.Response {\n \t\toldNs := &corev1.Namespace{}\n \t\tif err := decoder.DecodeRaw(req.OldObject, oldNs); err != nil {\n \t\t\treturn utils.ErroredResponse(err)\n \t\t}\n \n-\t\tif len(oldNs.OwnerReferences) == 0 {\n-\t\t\treturn nil\n+\t\ttntList := &capsulev1beta2.TenantList{}\n+\t\tif err := c.List(ctx, tntList, client.MatchingFieldsSelector{\n+\t\t\tSelector: fields.OneTermEqualSelector(\".status.namespaces\", oldNs.Name),\n+\t\t}); err != nil {\n+\t\t\treturn utils.ErroredResponse(err)\n+\t\t}\n+\n+\t\tif !h.namespaceIsOwned(oldNs, tntList, req) {\n+\t\t\trecorder.Eventf(oldNs, corev1.EventTypeWarning, \"OfflimitNamespace\", \"Namespace %s can not be patched\", oldNs.GetName())\n+\n+\t\t\tresponse := admission.Denied(\"Denied patch request for this namespace\")\n+\n+\t\t\treturn &response\n \t\t}\n \n \t\tnewNs := &corev1.Namespace{}\n@@ -101,6 +113,21 @@ func (h *handler) OnUpdate(_ client.Client, decoder admission.Decoder, _ record.\n \t}\n }\n \n+func (h *handler) namespaceIsOwned(ns *corev1.Namespace, tenantList *capsulev1beta2.TenantList, req admission.Request) bool {\n+\tfor _, tenant := range tenantList.Items {\n+\t\tfor _, ownerRef := range ns.OwnerReferences {\n+\t\t\tif !capsuleutils.IsTenantOwnerReference(ownerRef) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif ownerRef.UID == tenant.UID && utils.IsTenantOwner(tenant.Spec.Owners, req.UserInfo) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n func (h *handler) setOwnerRef(ctx context.Context, req admission.Request, client client.Client, decoder admission.Decoder, recorder record.EventRecorder) *admission.Response {\n \tns := &corev1.Namespace{}\n \tif err := decoder.Decode(req, ns); err != nil {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "49fb3075298adb12ab3d5bfe867aedb61c8ab507",
            "date": "2025-01-13T14:24:06Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "ace0d74c23da860eaf1fd56414333e52ef37560c",
            "date": "2025-01-10T01:12:06Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "b74095be25bb762c05d3951b740840d4bef7c82a",
            "date": "2025-01-05T08:39:59Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "8ba9e9af1bd6f4c95a8ed5ae375f09b9354daa8b",
            "date": "2025-01-02T21:51:42Z",
            "author_login": "renovate[bot]"
          },
          {
            "sha": "7d7adf9c5811c650c2b17088ddaa9364b4f8fac5",
            "date": "2025-01-02T21:51:04Z",
            "author_login": "renovate[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.4,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-863",
    "description": "Capsule is a multi-tenancy and policy-based framework for Kubernetes. In Capsule v0.7.0 and earlier, the tenant-owner can patch any arbitrary namespace that has not been taken over by a tenant (i.e., namespaces without the ownerReference field), thereby gaining control of that namespace.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-08-20T15:15:21.340",
    "last_modified": "2024-08-21T16:01:47.157",
    "fix_date": "2024-08-20T08:19:14Z"
  },
  "references": [
    {
      "url": "https://github.com/projectcapsule/capsule/commit/d620b0457ddec01616b8eab8512a10611611f584",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/projectcapsule/capsule/security/advisories/GHSA-mq69-4j5w-3qwp",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.374153",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "capsule",
    "owner": "projectcapsule",
    "created_at": "2020-06-29T20:27:51Z",
    "updated_at": "2025-01-14T15:33:49Z",
    "pushed_at": "2025-01-14T15:22:18Z",
    "size": 6171,
    "stars": 1711,
    "forks": 163,
    "open_issues": 47,
    "watchers": 1711,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 664313,
      "Shell": 14873,
      "Makefile": 10200,
      "Smarty": 8214,
      "Dockerfile": 1160,
      "JavaScript": 686
    },
    "commit_activity": {
      "total_commits_last_year": 221,
      "avg_commits_per_week": 4.25,
      "days_active_last_year": 76
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:13:17.968960"
  }
}