{
  "cve_id": "CVE-2024-39697",
  "github_data": {
    "repository": "whisperfish/rust-phonenumber",
    "fix_commit": "b792151b17fc90231c232a23935830c2266f3203",
    "related_commits": [
      "b792151b17fc90231c232a23935830c2266f3203",
      "f69abee1481fac0d6d531407bae90020e39c6407",
      "b792151b17fc90231c232a23935830c2266f3203",
      "f69abee1481fac0d6d531407bae90020e39c6407"
    ],
    "patch_url": "https://github.com/whisperfish/rust-phonenumber/commit/b792151b17fc90231c232a23935830c2266f3203.patch",
    "fix_commit_details": {
      "sha": "b792151b17fc90231c232a23935830c2266f3203",
      "commit_date": "2024-07-09T13:27:34Z",
      "author": {
        "login": "rubdos",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge branch 'proptest' for CVE-2024-39697",
        "length": 42,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 91,
        "additions": 79,
        "deletions": 12
      },
      "files": [
        {
          "filename": ".github/workflows/build.yml",
          "status": "modified",
          "additions": 16,
          "deletions": 1,
          "patch": "@@ -25,7 +25,13 @@ jobs:\n         toolchain: [\"stable\", \"beta\"]\n         coverage: [false]\n         tests: [true]\n+        proptest_max: [false]\n         include:\n+          # We run the proptests with the stable toolchain on more iterations\n+          - toolchain: \"stable\"\n+            coverage: false\n+            tests: true\n+            proptest_max: true\n           - toolchain: \"nightly\"\n             coverage: true\n             tests: true\n@@ -60,11 +66,20 @@ jobs:\n \n       - name: Run tests\n         uses: actions-rs/cargo@v1\n-        if: ${{ !matrix.coverage && matrix.tests }}\n+        if: ${{ !matrix.coverage && matrix.tests && !matrix.proptest_max }}\n         with:\n           command: test\n           args: --all-targets --no-fail-fast\n \n+      - name: Run tests\n+        uses: actions-rs/cargo@v1\n+        if: ${{ !matrix.coverage && matrix.tests && matrix.proptest_max }}\n+        env:\n+          PROPTEST_CASES: 65536\n+        with:\n+          command: test\n+          args: --all-targets --release --no-fail-fast\n+\n       - name: Run tests\n         uses: actions-rs/cargo@v1\n         if: ${{ matrix.coverage && matrix.tests }}"
        },
        {
          "filename": "Cargo.toml",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -41,6 +41,7 @@ criterion = \">=0.4, <=0.5\"\n doc-comment = \"0.3\"\n rstest = \">= 0.13, <=0.19\"\n rstest_reuse = \"0.6\"\n+proptest = \"1.0.0\"\n \n [[bench]]\n name = \"parsing\""
        },
        {
          "filename": "src/national_number.rs",
          "status": "modified",
          "additions": 7,
          "deletions": 4,
          "patch": "@@ -22,13 +22,16 @@ pub struct NationalNumber {\n }\n \n impl NationalNumber {\n-    pub fn new(value: u64, zeros: u8) -> Self {\n+    pub fn new(value: u64, zeros: u8) -> Result<Self, crate::error::Parse> {\n         // E.164 specifies a maximum of 15 decimals, which corresponds to slightly over 48.9 bits.\n         // 56 bits ought to cut it here.\n-        assert!(value < (1 << 56), \"number too long\");\n-        Self {\n-            value: ((zeros as u64) << 56) | value,\n+        if value >= (1 << 56) {\n+            return Err(crate::error::Parse::TooLong);\n         }\n+\n+        Ok(Self {\n+            value: ((zeros as u64) << 56) | value,\n+        })\n     }\n \n     /// The number without any leading zeroes."
        },
        {
          "filename": "src/parser/mod.rs",
          "status": "modified",
          "additions": 13,
          "deletions": 7,
          "patch": "@@ -86,7 +86,7 @@ pub fn parse_with<S: AsRef<str>>(\n         national: NationalNumber::new(\n             number.national.parse()?,\n             number.national.chars().take_while(|&c| c == '0').count() as u8,\n-        ),\n+        )?,\n \n         extension: number.extension.map(|s| Extension(s.into_owned())),\n         carrier: number.carrier.map(|s| Carrier(s.into_owned())),\n@@ -108,7 +108,7 @@ mod test {\n                 source: country::Source::Default,\n             },\n \n-            national: NationalNumber::new(33316005, 0),\n+            national: NationalNumber::new(33316005, 0).unwrap(),\n \n             extension: None,\n             carrier: None,\n@@ -196,7 +196,7 @@ mod test {\n                 source: country::Source::Number,\n             },\n \n-            national: NationalNumber::new(64123456, 0),\n+            national: NationalNumber::new(64123456, 0).unwrap(),\n \n             extension: None,\n             carrier: None,\n@@ -214,7 +214,7 @@ mod test {\n                     source: country::Source::Default,\n                 },\n \n-                national: NationalNumber::new(30123456, 0),\n+                national: NationalNumber::new(30123456, 0).unwrap(),\n \n                 extension: None,\n                 carrier: None,\n@@ -229,7 +229,7 @@ mod test {\n                     source: country::Source::Plus,\n                 },\n \n-                national: NationalNumber::new(2345, 0,),\n+                national: NationalNumber::new(2345, 0,).unwrap(),\n \n                 extension: None,\n                 carrier: None,\n@@ -244,7 +244,7 @@ mod test {\n                     source: country::Source::Default,\n                 },\n \n-                national: NationalNumber::new(12, 0,),\n+                national: NationalNumber::new(12, 0,).unwrap(),\n \n                 extension: None,\n                 carrier: None,\n@@ -259,7 +259,7 @@ mod test {\n                     source: country::Source::Default,\n                 },\n \n-                national: NationalNumber::new(3121286979, 0),\n+                national: NationalNumber::new(3121286979, 0).unwrap(),\n \n                 extension: None,\n                 carrier: Some(\"12\".into()),\n@@ -279,4 +279,10 @@ mod test {\n         let res = parser::parse(None, \".;phone-context=\");\n         assert!(res.is_err(), \"{res:?}\");\n     }\n+\n+    #[test]\n+    fn advisory_2() {\n+        let res = parser::parse(None, \"+dwPAA;phone-context=AA\");\n+        assert!(res.is_err(), \"{res:?}\");\n+    }\n }"
        },
        {
          "filename": "tests/prop.proptest-regressions",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+# Seeds for failure cases proptest has generated in the past. It is\n+# automatically read and these particular cases re-run before any\n+# novel cases are generated.\n+#\n+# It is recommended to check this file in to source control so that\n+# everyone who runs the test benefits from these saved cases.\n+cc f4f1a19cf143c767508ab557480843e4f4093898768fbbea1034d19d4308257d # shrinks to tel_prefix = false, use_plus = true, s = \"da\", phone_context = Some(\"A0A0a\")\n+cc 4ea103e574793bd24b0267cc8a80962299ee50746d69332fbd0b85532fb707e2 # shrinks to tel_prefix = false, use_plus = false, s = \"0\", phone_context = Some(\"\u09aa\")"
        },
        {
          "filename": "tests/prop.rs",
          "status": "added",
          "additions": 34,
          "deletions": 0,
          "patch": "@@ -0,0 +1,34 @@\n+use phonenumber::parse;\n+use proptest::prelude::*;\n+\n+proptest! {\n+    #[test]\n+    fn rfc3966_crash_test(\n+        tel_prefix: bool,\n+        use_plus: bool,\n+        s: String,\n+        phone_context: Option<String>,\n+    ) {\n+        let context = if let Some(phone_context) = &phone_context { format!(\";phone-context={phone_context}\") } else { \"\".to_string() };\n+        let tel_prefix = if tel_prefix { \"tel:\" } else { \"\" };\n+        let plus = if use_plus { \"+\" } else { \"\" };\n+        let s = format!(\"{}{}{}{}\", tel_prefix, plus, s, context);\n+        let _ = parse(None, &s);\n+    }\n+\n+    #[test]\n+    fn doesnt_crash(s in \"\\\\PC*\") {\n+        let _ = parse(None, &s);\n+    }\n+\n+    #[test]\n+    fn doesnt_crash_2(s in \"\\\\+\\\\PC*\") {\n+        let _ = parse(None, &s);\n+    }\n+\n+    #[test]\n+    fn parse_belgian_phonenumbers(s in \"\\\\+32[0-9]{8,9}\") {\n+        let parsed = parse(None, &s).expect(\"valid Belgian number\");\n+        prop_assert_eq!(parsed.country().id(), phonenumber::country::BE.into());\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "31dd5fb50567203eac78e256332d7978bbd353a4",
            "date": "2025-01-11T12:48:39Z",
            "author_login": "rubdos"
          },
          {
            "sha": "4e98bd15a77a7ac0978572299df42a295cce822f",
            "date": "2025-01-11T12:40:51Z",
            "author_login": "rubdos"
          },
          {
            "sha": "2418e06b2effb37df27e972a4533edadc5e9ecf7",
            "date": "2025-01-11T12:36:20Z",
            "author_login": "rubdos"
          },
          {
            "sha": "31831b90fdea5ad8ee016e39e0eec237c65cd742",
            "date": "2025-01-11T12:14:26Z",
            "author_login": "rubdos"
          },
          {
            "sha": "3d839ace7a576211fce67d284f705f1db868a3f4",
            "date": "2024-07-09T15:39:56Z",
            "author_login": "rubdos"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H",
    "cwe_id": "CWE-284",
    "description": "phonenumber is a library for parsing, formatting and validating international phone numbers. Since 0.3.4, the phonenumber parsing code may panic due to a panic-guarded out-of-bounds access on the phonenumber string. In a typical deployment of rust-phonenumber, this may get triggered by feeding a maliciously crafted phonenumber, e.g. over the network, specifically strings of the form `+dwPAA;phone-context=AA`, where the \"number\" part potentially parses as a number larger than 2^56. This vulnerability is fixed in 0.3.6.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-09T15:15:11.290",
    "last_modified": "2024-11-21T09:28:14.540",
    "fix_date": "2024-07-09T13:27:34Z"
  },
  "references": [
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/commit/b792151b17fc90231c232a23935830c2266f3203",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/commit/f69abee1481fac0d6d531407bae90020e39c6407",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/issues/69",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/pull/52",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/security/advisories/GHSA-mjw4-jj88-v687",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/commit/b792151b17fc90231c232a23935830c2266f3203",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/commit/f69abee1481fac0d6d531407bae90020e39c6407",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/issues/69",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/pull/52",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/whisperfish/rust-phonenumber/security/advisories/GHSA-mjw4-jj88-v687",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.422726",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "rust-phonenumber",
    "owner": "whisperfish",
    "created_at": "2017-06-29T10:30:17Z",
    "updated_at": "2025-01-11T16:16:11Z",
    "pushed_at": "2025-01-11T12:53:33Z",
    "size": 4781,
    "stars": 167,
    "forks": 58,
    "open_issues": 27,
    "watchers": 167,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 159572,
      "Shell": 502
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T18:32:47.164623"
  }
}