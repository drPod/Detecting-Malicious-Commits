{
  "cve_id": "CVE-2024-40094",
  "github_data": {
    "repository": "graphql-java/graphql-java",
    "fix_commit": "97743bc1b5caa2b0bd894dc8e128b47e4d771e4a",
    "related_commits": [
      "97743bc1b5caa2b0bd894dc8e128b47e4d771e4a",
      "97743bc1b5caa2b0bd894dc8e128b47e4d771e4a"
    ],
    "patch_url": "https://github.com/graphql-java/graphql-java/commit/97743bc1b5caa2b0bd894dc8e128b47e4d771e4a.patch",
    "fix_commit_details": {
      "sha": "97743bc1b5caa2b0bd894dc8e128b47e4d771e4a",
      "commit_date": "2024-03-22T04:15:39Z",
      "author": {
        "login": "bbakerman",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #3539 from graphql-java/max-enf-count",
        "length": 139,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 709,
        "additions": 657,
        "deletions": 52
      },
      "files": [
        {
          "filename": "src/main/java/graphql/execution/ExecutionContext.java",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -86,7 +86,7 @@ public class ExecutionContext {\n         this.errors.set(builder.errors);\n         this.localContext = builder.localContext;\n         this.executionInput = builder.executionInput;\n-        queryTree = FpKit.interThreadMemoize(() -> ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphQLSchema, operationDefinition, fragmentsByName, coercedVariables));\n+        this.queryTree = FpKit.interThreadMemoize(() -> ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphQLSchema, operationDefinition, fragmentsByName, coercedVariables));\n     }\n \n "
        },
        {
          "filename": "src/main/java/graphql/introspection/GoodFaithIntrospection.java",
          "status": "modified",
          "additions": 34,
          "deletions": 1,
          "patch": "@@ -18,6 +18,8 @@\n import java.util.Optional;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n+import static graphql.normalized.ExecutableNormalizedOperationFactory.Options;\n+import static graphql.normalized.ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation;\n import static graphql.schema.FieldCoordinates.coordinates;\n \n /**\n@@ -44,6 +46,14 @@ public class GoodFaithIntrospection {\n     public static final String GOOD_FAITH_INTROSPECTION_DISABLED = \"GOOD_FAITH_INTROSPECTION_DISABLED\";\n \n     private static final AtomicBoolean ENABLED_STATE = new AtomicBoolean(true);\n+    /**\n+     * This is the maximum number of executable fields that can be in a good faith introspection query\n+     */\n+    public static final int GOOD_FAITH_MAX_FIELDS_COUNT = 500;\n+    /**\n+     * This is the maximum depth a good faith introspection query can be\n+     */\n+    public static final int GOOD_FAITH_MAX_DEPTH_COUNT = 20;\n \n     /**\n      * @return true if good faith introspection is enabled\n@@ -75,7 +85,7 @@ public static boolean enabledJvmWide(boolean flag) {\n \n     public static Optional<ExecutionResult> checkIntrospection(ExecutionContext executionContext) {\n         if (isIntrospectionEnabled(executionContext.getGraphQLContext())) {\n-            ExecutableNormalizedOperation operation = executionContext.getNormalizedQueryTree().get();\n+            ExecutableNormalizedOperation operation = mkOperation(executionContext);\n             ImmutableListMultimap<FieldCoordinates, ExecutableNormalizedField> coordinatesToENFs = operation.getCoordinatesToNormalizedFields();\n             for (Map.Entry<FieldCoordinates, Integer> entry : ALLOWED_FIELD_INSTANCES.entrySet()) {\n                 FieldCoordinates coordinates = entry.getKey();\n@@ -90,6 +100,29 @@ public static Optional<ExecutionResult> checkIntrospection(ExecutionContext exec\n         return Optional.empty();\n     }\n \n+    /**\n+     * This makes an executable operation limited in size then which suits a good faith introspection query.  This helps guard\n+     * against malicious queries.\n+     *\n+     * @param executionContext the execution context\n+     *\n+     * @return an executable operation\n+     */\n+    private static ExecutableNormalizedOperation mkOperation(ExecutionContext executionContext) {\n+        Options options = Options.defaultOptions()\n+                .maxFieldsCount(GOOD_FAITH_MAX_FIELDS_COUNT)\n+                .maxChildrenDepth(GOOD_FAITH_MAX_DEPTH_COUNT)\n+                .locale(executionContext.getLocale())\n+                .graphQLContext(executionContext.getGraphQLContext());\n+\n+        return createExecutableNormalizedOperation(executionContext.getGraphQLSchema(),\n+                executionContext.getOperationDefinition(),\n+                executionContext.getFragmentsByName(),\n+                executionContext.getCoercedVariables(),\n+                options);\n+\n+    }\n+\n     private static boolean isIntrospectionEnabled(GraphQLContext graphQlContext) {\n         if (!isEnabledJvmWide()) {\n             return false;"
        },
        {
          "filename": "src/main/java/graphql/introspection/Introspection.java",
          "status": "modified",
          "additions": 12,
          "deletions": 12,
          "patch": "@@ -115,20 +115,20 @@ public static boolean isEnabledJvmWide() {\n      */\n     public static Optional<ExecutionResult> isIntrospectionSensible(MergedSelectionSet mergedSelectionSet, ExecutionContext executionContext) {\n         GraphQLContext graphQLContext = executionContext.getGraphQLContext();\n-        MergedField schemaField = mergedSelectionSet.getSubField(SchemaMetaFieldDef.getName());\n-        if (schemaField != null) {\n-            if (!isIntrospectionEnabled(graphQLContext)) {\n-                return mkDisabledError(schemaField);\n-            }\n-        }\n-        MergedField typeField = mergedSelectionSet.getSubField(TypeMetaFieldDef.getName());\n-        if (typeField != null) {\n-            if (!isIntrospectionEnabled(graphQLContext)) {\n-                return mkDisabledError(typeField);\n+\n+        boolean isIntrospection = false;\n+        for (String key : mergedSelectionSet.getKeys()) {\n+            String fieldName = mergedSelectionSet.getSubField(key).getName();\n+            if (fieldName.equals(SchemaMetaFieldDef.getName())\n+                    || fieldName.equals(TypeMetaFieldDef.getName())) {\n+                if (!isIntrospectionEnabled(graphQLContext)) {\n+                    return mkDisabledError(mergedSelectionSet.getSubField(key));\n+                }\n+                isIntrospection = true;\n+                break;\n             }\n         }\n-        if (schemaField != null || typeField != null)\n-        {\n+        if (isIntrospection) {\n             return GoodFaithIntrospection.checkIntrospection(executionContext);\n         }\n         return Optional.empty();"
        },
        {
          "filename": "src/main/java/graphql/normalized/ExecutableNormalizedOperation.java",
          "status": "modified",
          "additions": 21,
          "deletions": 2,
          "patch": "@@ -31,6 +31,8 @@ public class ExecutableNormalizedOperation {\n     private final Map<ExecutableNormalizedField, MergedField> normalizedFieldToMergedField;\n     private final Map<ExecutableNormalizedField, QueryDirectives> normalizedFieldToQueryDirectives;\n     private final ImmutableListMultimap<FieldCoordinates, ExecutableNormalizedField> coordinatesToNormalizedFields;\n+    private final int operationFieldCount;\n+    private final int operationDepth;\n \n     public ExecutableNormalizedOperation(\n             OperationDefinition.Operation operation,\n@@ -39,15 +41,18 @@ public ExecutableNormalizedOperation(\n             ImmutableListMultimap<Field, ExecutableNormalizedField> fieldToNormalizedField,\n             Map<ExecutableNormalizedField, MergedField> normalizedFieldToMergedField,\n             Map<ExecutableNormalizedField, QueryDirectives> normalizedFieldToQueryDirectives,\n-            ImmutableListMultimap<FieldCoordinates, ExecutableNormalizedField> coordinatesToNormalizedFields\n-    ) {\n+            ImmutableListMultimap<FieldCoordinates, ExecutableNormalizedField> coordinatesToNormalizedFields,\n+            int operationFieldCount,\n+            int operationDepth) {\n         this.operation = operation;\n         this.operationName = operationName;\n         this.topLevelFields = topLevelFields;\n         this.fieldToNormalizedField = fieldToNormalizedField;\n         this.normalizedFieldToMergedField = normalizedFieldToMergedField;\n         this.normalizedFieldToQueryDirectives = normalizedFieldToQueryDirectives;\n         this.coordinatesToNormalizedFields = coordinatesToNormalizedFields;\n+        this.operationFieldCount = operationFieldCount;\n+        this.operationDepth = operationDepth;\n     }\n \n     /**\n@@ -64,6 +69,20 @@ public String getOperationName() {\n         return operationName;\n     }\n \n+    /**\n+     * @return This returns how many {@link ExecutableNormalizedField}s are in the operation.\n+     */\n+    public int getOperationFieldCount() {\n+        return operationFieldCount;\n+    }\n+\n+    /**\n+     * @return This returns the depth of the operation\n+     */\n+    public int getOperationDepth() {\n+        return operationDepth;\n+    }\n+\n     /**\n      * This multimap shows how a given {@link ExecutableNormalizedField} maps to a one or more field coordinate in the schema\n      *"
        },
        {
          "filename": "src/main/java/graphql/normalized/ExecutableNormalizedOperationFactory.java",
          "status": "modified",
          "additions": 77,
          "deletions": 15,
          "patch": "@@ -64,6 +64,7 @@\n import static graphql.util.FpKit.filterSet;\n import static graphql.util.FpKit.groupingBy;\n import static graphql.util.FpKit.intersection;\n+import static java.util.Collections.max;\n import static java.util.Collections.singleton;\n import static java.util.Collections.singletonList;\n import static java.util.stream.Collectors.toCollection;\n@@ -80,24 +81,28 @@ public static class Options {\n         private final GraphQLContext graphQLContext;\n         private final Locale locale;\n         private final int maxChildrenDepth;\n+        private final int maxFieldsCount;\n \n         private final boolean deferSupport;\n \n         private Options(GraphQLContext graphQLContext,\n                         Locale locale,\n                         int maxChildrenDepth,\n+                        int maxFieldsCount,\n                         boolean deferSupport) {\n             this.graphQLContext = graphQLContext;\n             this.locale = locale;\n             this.maxChildrenDepth = maxChildrenDepth;\n             this.deferSupport = deferSupport;\n+            this.maxFieldsCount = maxFieldsCount;\n         }\n \n         public static Options defaultOptions() {\n             return new Options(\n                     GraphQLContext.getDefault(),\n                     Locale.getDefault(),\n                     Integer.MAX_VALUE,\n+                    Integer.MAX_VALUE,\n                     false);\n         }\n \n@@ -111,7 +116,7 @@ public static Options defaultOptions() {\n          * @return new options object to use\n          */\n         public Options locale(Locale locale) {\n-            return new Options(this.graphQLContext, locale, this.maxChildrenDepth, this.deferSupport);\n+            return new Options(this.graphQLContext, locale, this.maxChildrenDepth, this.maxFieldsCount, this.deferSupport);\n         }\n \n         /**\n@@ -124,7 +129,7 @@ public Options locale(Locale locale) {\n          * @return new options object to use\n          */\n         public Options graphQLContext(GraphQLContext graphQLContext) {\n-            return new Options(graphQLContext, this.locale, this.maxChildrenDepth, this.deferSupport);\n+            return new Options(graphQLContext, this.locale, this.maxChildrenDepth, this.maxFieldsCount, this.deferSupport);\n         }\n \n         /**\n@@ -136,7 +141,19 @@ public Options graphQLContext(GraphQLContext graphQLContext) {\n          * @return new options object to use\n          */\n         public Options maxChildrenDepth(int maxChildrenDepth) {\n-            return new Options(this.graphQLContext, this.locale, maxChildrenDepth, this.deferSupport);\n+            return new Options(this.graphQLContext, this.locale, maxChildrenDepth, this.maxFieldsCount, this.deferSupport);\n+        }\n+\n+        /**\n+         * Controls the maximum number of ENFs created. Can be used to prevent\n+         * against malicious operations.\n+         *\n+         * @param maxFieldsCount the max number of ENFs created\n+         *\n+         * @return new options object to use\n+         */\n+        public Options maxFieldsCount(int maxFieldsCount) {\n+            return new Options(this.graphQLContext, this.locale, maxChildrenDepth, maxFieldsCount, this.deferSupport);\n         }\n \n         /**\n@@ -148,7 +165,7 @@ public Options maxChildrenDepth(int maxChildrenDepth) {\n          */\n         @ExperimentalApi\n         public Options deferSupport(boolean deferSupport) {\n-            return new Options(this.graphQLContext, this.locale, this.maxChildrenDepth, deferSupport);\n+            return new Options(this.graphQLContext, this.locale, this.maxChildrenDepth, this.maxFieldsCount, deferSupport);\n         }\n \n         /**\n@@ -178,6 +195,10 @@ public int getMaxChildrenDepth() {\n             return maxChildrenDepth;\n         }\n \n+        public int getMaxFieldsCount() {\n+            return maxFieldsCount;\n+        }\n+\n         /**\n          * @return whether support for defer is enabled\n          *\n@@ -266,13 +287,36 @@ public static ExecutableNormalizedOperation createExecutableNormalizedOperation(\n                                                                                     OperationDefinition operationDefinition,\n                                                                                     Map<String, FragmentDefinition> fragments,\n                                                                                     CoercedVariables coercedVariableValues) {\n+        return createExecutableNormalizedOperation(graphQLSchema,\n+                operationDefinition,\n+                fragments,\n+                coercedVariableValues,\n+                Options.defaultOptions());\n+    }\n+\n+    /**\n+     * This will create a runtime representation of the graphql operation that would be executed\n+     * in a runtime sense.\n+     *\n+     * @param graphQLSchema         the schema to be used\n+     * @param operationDefinition   the operation to be executed\n+     * @param fragments             a set of fragments associated with the operation\n+     * @param coercedVariableValues the coerced variables to use\n+     *\n+     * @return a runtime representation of the graphql operation.\n+     */\n+    public static ExecutableNormalizedOperation createExecutableNormalizedOperation(GraphQLSchema graphQLSchema,\n+                                                                                    OperationDefinition operationDefinition,\n+                                                                                    Map<String, FragmentDefinition> fragments,\n+                                                                                    CoercedVariables coercedVariableValues,\n+                                                                                    Options options) {\n         return new ExecutableNormalizedOperationFactoryImpl(\n                 graphQLSchema,\n                 operationDefinition,\n                 fragments,\n                 coercedVariableValues,\n                 null,\n-                Options.defaultOptions()\n+                options\n         ).createNormalizedQueryImpl();\n     }\n \n@@ -386,6 +430,8 @@ private static class ExecutableNormalizedOperationFactoryImpl {\n         private final ImmutableMap.Builder<ExecutableNormalizedField, MergedField> normalizedFieldToMergedField = ImmutableMap.builder();\n         private final ImmutableMap.Builder<ExecutableNormalizedField, QueryDirectives> normalizedFieldToQueryDirectives = ImmutableMap.builder();\n         private final ImmutableListMultimap.Builder<FieldCoordinates, ExecutableNormalizedField> coordinatesToNormalizedFields = ImmutableListMultimap.builder();\n+        private int fieldCount = 0;\n+        private int maxDepthSeen = 0;\n \n         private ExecutableNormalizedOperationFactoryImpl(\n                 GraphQLSchema graphQLSchema,\n@@ -420,10 +466,11 @@ private ExecutableNormalizedOperation createNormalizedQueryImpl() {\n                 updateFieldToNFMap(topLevel, fieldAndAstParents);\n                 updateCoordinatedToNFMap(topLevel);\n \n-                buildFieldWithChildren(\n+                int depthSeen = buildFieldWithChildren(\n                         topLevel,\n                         fieldAndAstParents,\n                         1);\n+                maxDepthSeen = Math.max(maxDepthSeen,depthSeen);\n             }\n             // getPossibleMergerList\n             for (PossibleMerger possibleMerger : possibleMergerList) {\n@@ -437,7 +484,9 @@ private ExecutableNormalizedOperation createNormalizedQueryImpl() {\n                     fieldToNormalizedField.build(),\n                     normalizedFieldToMergedField.build(),\n                     normalizedFieldToQueryDirectives.build(),\n-                    coordinatesToNormalizedFields.build()\n+                    coordinatesToNormalizedFields.build(),\n+                    fieldCount,\n+                    maxDepthSeen\n             );\n         }\n \n@@ -448,15 +497,14 @@ private void captureMergedField(ExecutableNormalizedField enf, MergedField merge\n             normalizedFieldToMergedField.put(enf, mergedFld);\n         }\n \n-        private void buildFieldWithChildren(ExecutableNormalizedField executableNormalizedField,\n+        private int buildFieldWithChildren(ExecutableNormalizedField executableNormalizedField,\n                                             ImmutableList<FieldAndAstParent> fieldAndAstParents,\n                                             int curLevel) {\n-            if (curLevel > this.options.getMaxChildrenDepth()) {\n-                throw new AbortExecutionException(\"Maximum query depth exceeded \" + curLevel + \" > \" + this.options.getMaxChildrenDepth());\n-            }\n+            checkMaxDepthExceeded(curLevel);\n \n             CollectNFResult nextLevel = collectFromMergedField(executableNormalizedField, fieldAndAstParents, curLevel + 1);\n \n+            int maxDepthSeen = curLevel;\n             for (ExecutableNormalizedField childENF : nextLevel.children) {\n                 executableNormalizedField.addChild(childENF);\n                 ImmutableList<FieldAndAstParent> childFieldAndAstParents = nextLevel.normalizedFieldToAstFields.get(childENF);\n@@ -467,9 +515,19 @@ private void buildFieldWithChildren(ExecutableNormalizedField executableNormaliz\n                 updateFieldToNFMap(childENF, childFieldAndAstParents);\n                 updateCoordinatedToNFMap(childENF);\n \n-                buildFieldWithChildren(childENF,\n+                int depthSeen = buildFieldWithChildren(childENF,\n                         childFieldAndAstParents,\n                         curLevel + 1);\n+                maxDepthSeen = Math.max(maxDepthSeen,depthSeen);\n+\n+                checkMaxDepthExceeded(maxDepthSeen);\n+            }\n+            return maxDepthSeen;\n+        }\n+\n+        private void checkMaxDepthExceeded(int depthSeen) {\n+            if (depthSeen > this.options.getMaxChildrenDepth()) {\n+                throw new AbortExecutionException(\"Maximum query depth exceeded. \" + depthSeen + \" > \" + this.options.getMaxChildrenDepth());\n             }\n         }\n \n@@ -578,6 +636,11 @@ private void createNFs(ImmutableList.Builder<ExecutableNormalizedField> nfListBu\n         private ExecutableNormalizedField createNF(CollectedFieldGroup collectedFieldGroup,\n                                                    int level,\n                                                    ExecutableNormalizedField parent) {\n+\n+            this.fieldCount++;\n+            if (this.fieldCount > this.options.getMaxFieldsCount()) {\n+                throw new AbortExecutionException(\"Maximum field count exceeded. \" + this.fieldCount + \" > \" + this.options.getMaxFieldsCount());\n+            }\n             Field field;\n             Set<GraphQLObjectType> objectTypes = collectedFieldGroup.objectTypes;\n             field = collectedFieldGroup.fields.iterator().next().field;\n@@ -590,7 +653,6 @@ private ExecutableNormalizedField createNF(CollectedFieldGroup collectedFieldGro\n                 normalizedArgumentValues = ValuesResolver.getNormalizedArgumentValues(fieldDefinition.getArguments(), field.getArguments(), this.normalizedVariableValues);\n             }\n             ImmutableList<String> objectTypeNames = map(objectTypes, GraphQLObjectType::getName);\n-\n             return ExecutableNormalizedField.newNormalizedField()\n                     .alias(field.getAlias())\n                     .resolvedArguments(argumentValues)\n@@ -763,8 +825,8 @@ private void collectInlineFragment(List<CollectedField> result,\n \n         private NormalizedDeferredExecution buildDeferredExecution(\n                 List<Directive> directives,\n-                Set<GraphQLObjectType> newPossibleObjects)  {\n-            if(!options.deferSupport) {\n+                Set<GraphQLObjectType> newPossibleObjects) {\n+            if (!options.deferSupport) {\n                 return null;\n             }\n "
        },
        {
          "filename": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy",
          "status": "modified",
          "additions": 36,
          "deletions": 8,
          "patch": "@@ -893,16 +893,31 @@ class InterfacesImplementingInterfacesTest extends Specification {\n         given:\n         def graphQLSchema = createComplexSchema()\n \n+        GraphQL graphQL = GraphQL.newGraphQL(graphQLSchema).build()\n+\n         when:\n-        def result = GraphQL.newGraphQL(graphQLSchema).build().execute(\"\"\"\n+        String query = \"\"\"\n             { \n                 nodeType: __type(name: \"Node\") {\n                     possibleTypes {\n                         kind\n                         name\n                     }\n                 }\n-                resourceType: __type(name: \"Resource\") {\n+            }\n+        \"\"\"\n+        def result = graphQL.execute(query)\n+\n+        then:\n+        !result.errors\n+        result.data == [\n+                nodeType: [possibleTypes: [[kind: 'OBJECT', name: 'File'], [kind: 'OBJECT', name: 'Image']]],\n+        ]\n+\n+        when:\n+        query = \"\"\"         \n+        {       \n+            resourceType: __type(name: \"Resource\") {\n                     possibleTypes {\n                         kind\n                         name\n@@ -911,22 +926,35 @@ class InterfacesImplementingInterfacesTest extends Specification {\n                         kind\n                         name\n                     }\n-                } \n-                imageType: __type(name: \"Image\") {\n+                }\n+        } \n+        \"\"\"\n+        result = graphQL.execute(query)\n+\n+        then:\n+        !result.errors\n+        result.data == [\n+                resourceType: [possibleTypes: [[kind: 'OBJECT', name: 'File'], [kind: 'OBJECT', name: 'Image']], interfaces: [[kind: 'INTERFACE', name: 'Node']]]\n+        ]\n+\n+        when:\n+\n+        query = \"\"\"   \n+        {             \n+            imageType: __type(name: \"Image\") {\n                     interfaces {\n                         kind\n                         name\n                     }\n                 }\n-            }\n-        \"\"\")\n+        }\n+        \"\"\"\n+        result = graphQL.execute(query)\n \n         then:\n         !result.errors\n         result.data == [\n-                nodeType    : [possibleTypes: [[kind: 'OBJECT', name: 'File'], [kind: 'OBJECT', name: 'Image']]],\n                 imageType   : [interfaces: [[kind: 'INTERFACE', name: 'Resource'], [kind: 'INTERFACE', name: 'Node']]],\n-                resourceType: [possibleTypes: [[kind: 'OBJECT', name: 'File'], [kind: 'OBJECT', name: 'Image']], interfaces: [[kind: 'INTERFACE', name: 'Node']]]\n         ]\n     }\n "
        },
        {
          "filename": "src/test/groovy/graphql/UnionTest.groovy",
          "status": "modified",
          "additions": 27,
          "deletions": 12,
          "patch": "@@ -4,7 +4,7 @@ import spock.lang.Specification\n \n class UnionTest extends Specification {\n \n-    def \"can introspect on union and intersection types\"() {\n+    def \"can introspect on union types\"() {\n         def query = \"\"\"\n             {\n                 Named: __type(name: \"Named\") {\n@@ -15,15 +15,6 @@ class UnionTest extends Specification {\n                   possibleTypes { name }\n                   enumValues { name }\n                   inputFields { name }\n-            }\n-                Pet: __type(name: \"Pet\") {\n-                  kind\n-                  name\n-                  fields { name }\n-                  interfaces { name }\n-                  possibleTypes { name }\n-                  enumValues { name }\n-                  inputFields { name }\n                 }\n             }\n             \"\"\"\n@@ -42,8 +33,32 @@ class UnionTest extends Specification {\n                 ],\n                 enumValues   : null,\n                 inputFields  : null\n-        ],\n-                              Pet  : [\n+        ]]\n+        when:\n+        def executionResult = GraphQL.newGraphQL(GarfieldSchema.GarfieldSchema).build().execute(query)\n+\n+        then:\n+        executionResult.data == expectedResult\n+\n+\n+    }\n+\n+    def \"can introspect on intersection types\"() {\n+        def query = \"\"\"\n+            {\n+                Pet: __type(name: \"Pet\") {\n+                  kind\n+                  name\n+                  fields { name }\n+                  interfaces { name }\n+                  possibleTypes { name }\n+                  enumValues { name }\n+                  inputFields { name }\n+                }\n+            }\n+            \"\"\"\n+\n+        def expectedResult = [Pet  : [\n                                       kind         : 'UNION',\n                                       name         : 'Pet',\n                                       fields       : null,"
        },
        {
          "filename": "src/test/groovy/graphql/introspection/GoodFaithIntrospectionInstrumentationTest.groovy",
          "status": "modified",
          "additions": 96,
          "deletions": 0,
          "patch": "@@ -3,6 +3,10 @@ package graphql.introspection\n import graphql.ExecutionInput\n import graphql.ExecutionResult\n import graphql.TestUtil\n+import graphql.execution.AbortExecutionException\n+import graphql.execution.CoercedVariables\n+import graphql.language.Document\n+import graphql.normalized.ExecutableNormalizedOperationFactory\n import spock.lang.Specification\n \n class GoodFaithIntrospectionInstrumentationTest extends Specification {\n@@ -12,10 +16,23 @@ class GoodFaithIntrospectionInstrumentationTest extends Specification {\n     def setup() {\n         GoodFaithIntrospection.enabledJvmWide(true)\n     }\n+\n     def cleanup() {\n         GoodFaithIntrospection.enabledJvmWide(true)\n     }\n \n+    def \"standard introspection query is inside limits just in general\"() {\n+\n+        when:\n+        Document document = TestUtil.toDocument(IntrospectionQuery.INTROSPECTION_QUERY)\n+        def eno = ExecutableNormalizedOperationFactory.createExecutableNormalizedOperation(graphql.getGraphQLSchema(), document,\n+                \"IntrospectionQuery\", CoercedVariables.emptyVariables())\n+\n+        then:\n+        eno.getOperationFieldCount() < GoodFaithIntrospection.GOOD_FAITH_MAX_FIELDS_COUNT  // currently 189\n+        eno.getOperationDepth() < GoodFaithIntrospection.GOOD_FAITH_MAX_DEPTH_COUNT  // currently 13\n+    }\n+\n     def \"test asking for introspection in good faith\"() {\n \n         when:\n@@ -69,12 +86,25 @@ class GoodFaithIntrospectionInstrumentationTest extends Specification {\n                 alias1 :  __type(name : \"t1\") { name }\n             }\n         \"\"\"                                                                                           | _\n+        // a case for __type with aliases\n+        \"\"\" query badActor {\n+                a1: __type(name : \"t\") { name }\n+                a2 :  __type(name : \"t1\") { name }\n+            }\n+        \"\"\"                                                                                           | _\n         // a case for schema repeated - dont ask twice\n         \"\"\" query badActor {\n                 __schema { types { name} }\n                 alias1 : __schema { types { name} }\n             }\n         \"\"\"                                                                                           | _\n+        // a case for used aliases\n+        \"\"\" query badActor {\n+                a1: __schema { types { name} }\n+                a2 : __schema { types { name} }\n+            }\n+        \"\"\"                                                                                           | _\n+\n     }\n \n     def \"mixed general queries and introspections will be stopped anyway\"() {\n@@ -133,4 +163,70 @@ class GoodFaithIntrospectionInstrumentationTest extends Specification {\n         !er.errors.isEmpty()\n         er.errors[0] instanceof GoodFaithIntrospection.BadFaithIntrospectionError\n     }\n+\n+    def \"can stop deep queries\"() {\n+\n+        when:\n+        def query = createDeepQuery(depth)\n+        def then = System.currentTimeMillis()\n+        ExecutionResult er = graphql.execute(query)\n+        def ms = System.currentTimeMillis()-then\n+\n+        then:\n+        !er.errors.isEmpty()\n+        er.errors[0].class == targetError\n+        er.data == null // it stopped hard - it did not continue to normal business\n+        println \"Took \" + ms + \"ms\"\n+\n+        where:\n+        depth | targetError\n+        2     | GoodFaithIntrospection.BadFaithIntrospectionError.class\n+        10    | AbortExecutionException.class\n+        15    | AbortExecutionException.class\n+        20    | AbortExecutionException.class\n+        25    | AbortExecutionException.class\n+        50    | AbortExecutionException.class\n+        100    | AbortExecutionException.class\n+    }\n+\n+    String createDeepQuery(int depth = 25) {\n+        def result = \"\"\"\n+query test {\n+  __schema {\n+    types {\n+      ...F1\n+    }\n+  }\n+}\n+\"\"\"\n+        for (int i = 1; i < depth; i++) {\n+            result += \"\"\"\n+        fragment F$i on __Type {\n+          fields {\n+            type {\n+              ...F${i + 1}\n+            }\n+          }\n+\n+  ofType {\n+    ...F${i + 1}\n+  }\n+}\n+\n+\n+\"\"\"\n+        }\n+        result += \"\"\"\n+        fragment F$depth on __Type {\n+          fields {\n+            type {\n+name\n+            }\n+          }\n+}\n+\n+\n+\"\"\"\n+        return result\n+    }\n }"
        },
        {
          "filename": "src/test/groovy/graphql/normalized/ExecutableNormalizedOperationFactoryTest.groovy",
          "status": "modified",
          "additions": 231,
          "deletions": 1,
          "patch": "@@ -3,10 +3,12 @@ package graphql.normalized\n import graphql.ExecutionInput\n import graphql.GraphQL\n import graphql.TestUtil\n+import graphql.execution.AbortExecutionException\n import graphql.execution.CoercedVariables\n import graphql.execution.MergedField\n import graphql.execution.RawVariables\n import graphql.execution.directives.QueryAppliedDirective\n+import graphql.introspection.IntrospectionQuery\n import graphql.language.Document\n import graphql.language.Field\n import graphql.language.FragmentDefinition\n@@ -1285,7 +1287,6 @@ type Dog implements Animal{\n         Document document = TestUtil.parseQuery(query)\n \n \n-\n         when:\n         def tree = localCreateExecutableNormalizedOperation(graphQLSchema, document, null, CoercedVariables.emptyVariables())\n         def coordinatesToNormalizedFields = tree.coordinatesToNormalizedFields\n@@ -2876,6 +2877,235 @@ fragment personName on Person {\n         noExceptionThrown()\n     }\n \n+    def \"big query exceeding fields count\"() {\n+        String schema = \"\"\"\n+        type Query {\n+            animal: Animal\n+        }\n+        interface Animal {\n+            name: String\n+            friends: [Friend]\n+        }\n+        union Pet = Dog | Cat\n+        type Friend {\n+            name: String\n+            isBirdOwner: Boolean\n+            isCatOwner: Boolean\n+            pets: [Pet] \n+        }\n+        type Bird implements Animal {\n+            name: String \n+            friends: [Friend]\n+        }\n+        type Cat implements Animal {\n+            name: String \n+            friends: [Friend]\n+            breed: String \n+        }\n+        type Dog implements Animal {\n+            name: String \n+            breed: String\n+            friends: [Friend]\n+        }\n+        \"\"\"\n+\n+        def garbageFields = IntStream.range(0, 1000)\n+                .mapToObj {\n+                    \"\"\"test_$it: friends { name }\"\"\"\n+                }\n+                .collect(Collectors.joining(\"\\n\"))\n+\n+        GraphQLSchema graphQLSchema = TestUtil.schema(schema)\n+\n+        String query = \"\"\"\n+        {\n+            animal {\n+                name\n+                otherName: name\n+                ... on Animal {\n+                    name\n+                }\n+                ... on Cat {\n+                    name\n+                    friends {\n+                        ... on Friend {\n+                            isCatOwner\n+                            pets {\n+                                ... on Dog {\n+                                    name\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                ... on Bird {\n+                    friends {\n+                        isBirdOwner\n+                    }\n+                    friends {\n+                        name\n+                        pets {\n+                            ... on Cat {\n+                                breed\n+                            }\n+                        }\n+                    }\n+                }\n+                ... on Dog {\n+                    name\n+                }\n+                $garbageFields\n+            }\n+        }        \n+        \"\"\"\n+\n+        assertValidQuery(graphQLSchema, query)\n+\n+        Document document = TestUtil.parseQuery(query)\n+\n+        when:\n+        def result = ExecutableNormalizedOperationFactory.createExecutableNormalizedOperationWithRawVariables(\n+                graphQLSchema,\n+                document,\n+                null,\n+                RawVariables.emptyVariables(),\n+                ExecutableNormalizedOperationFactory.Options.defaultOptions().maxFieldsCount(2013))\n+\n+        then:\n+        def e = thrown(AbortExecutionException)\n+        e.message == \"Maximum field count exceeded. 2014 > 2013\"\n+    }\n+\n+    def \"small query exceeding fields count\"() {\n+        String schema = \"\"\"\n+        type Query {\n+            hello: String\n+        }\n+        \"\"\"\n+\n+        GraphQLSchema graphQLSchema = TestUtil.schema(schema)\n+\n+        String query = \"\"\" {hello a1: hello}\"\"\"\n+\n+        assertValidQuery(graphQLSchema, query)\n+\n+        Document document = TestUtil.parseQuery(query)\n+\n+        when:\n+        def result = ExecutableNormalizedOperationFactory.createExecutableNormalizedOperationWithRawVariables(\n+                graphQLSchema,\n+                document,\n+                null,\n+                RawVariables.emptyVariables(),\n+                ExecutableNormalizedOperationFactory.Options.defaultOptions().maxFieldsCount(1))\n+\n+        then:\n+        def e = thrown(AbortExecutionException)\n+        e.message == \"Maximum field count exceeded. 2 > 1\"\n+\n+\n+    }\n+\n+    def \"query not exceeding fields count\"() {\n+        String schema = \"\"\"\n+        type Query {\n+            dogs: [Dog]\n+        }\n+        type Dog {\n+            name: String\n+            breed: String\n+        }\n+        \"\"\"\n+\n+        GraphQLSchema graphQLSchema = TestUtil.schema(schema)\n+\n+        String query = \"\"\" {dogs{name breed }}\"\"\"\n+\n+        assertValidQuery(graphQLSchema, query)\n+\n+        Document document = TestUtil.parseQuery(query)\n+\n+        when:\n+        def result = ExecutableNormalizedOperationFactory.createExecutableNormalizedOperationWithRawVariables(\n+                graphQLSchema,\n+                document,\n+                null,\n+                RawVariables.emptyVariables(),\n+                ExecutableNormalizedOperationFactory.Options.defaultOptions().maxFieldsCount(3))\n+\n+        then:\n+        notThrown(AbortExecutionException)\n+\n+\n+    }\n+\n+    def \"query with meta fields exceeding fields count\"() {\n+        String schema = \"\"\"\n+        type Query {\n+            hello: String\n+        }\n+        \"\"\"\n+\n+        GraphQLSchema graphQLSchema = TestUtil.schema(schema)\n+\n+        String query = IntrospectionQuery.INTROSPECTION_QUERY\n+\n+        assertValidQuery(graphQLSchema, query)\n+\n+        Document document = TestUtil.parseQuery(query)\n+\n+        when:\n+        def result = ExecutableNormalizedOperationFactory.createExecutableNormalizedOperationWithRawVariables(\n+                graphQLSchema,\n+                document,\n+                null,\n+                RawVariables.emptyVariables(),\n+                ExecutableNormalizedOperationFactory.Options.defaultOptions().maxFieldsCount(188))\n+        println result.normalizedFieldToMergedField.size()\n+\n+        then:\n+        def e = thrown(AbortExecutionException)\n+        e.message == \"Maximum field count exceeded. 189 > 188\"\n+    }\n+\n+    def \"can capture depth and field count\"() {\n+        String schema = \"\"\"\n+        type Query {\n+            foo: Foo\n+        }\n+        \n+        type Foo {\n+            stop : String\n+            bar : Bar\n+        }\n+        \n+        type Bar {\n+            stop : String\n+            foo : Foo\n+        }\n+        \"\"\"\n+\n+        GraphQLSchema graphQLSchema = TestUtil.schema(schema)\n+\n+        String query = \"{ foo { bar { foo { bar { foo { stop bar { stop }}}}}}}\"\n+\n+        assertValidQuery(graphQLSchema, query)\n+\n+        Document document = TestUtil.parseQuery(query)\n+\n+        when:\n+        def result = ExecutableNormalizedOperationFactory.createExecutableNormalizedOperationWithRawVariables(\n+                graphQLSchema,\n+                document,\n+                null,\n+                RawVariables.emptyVariables()\n+                )\n+\n+        then:\n+        result.getOperationDepth() == 7\n+        result.getOperationFieldCount() == 8\n+    }\n+\n     private static ExecutableNormalizedOperation localCreateExecutableNormalizedOperation(\n             GraphQLSchema graphQLSchema,\n             Document document,"
        },
        {
          "filename": "src/test/java/benchmark/ENFBenchmarkDeepIntrospection.java",
          "status": "added",
          "additions": 122,
          "deletions": 0,
          "patch": "@@ -0,0 +1,122 @@\n+package benchmark;\n+\n+import graphql.execution.CoercedVariables;\n+import graphql.language.Document;\n+import graphql.normalized.ExecutableNormalizedOperation;\n+import graphql.normalized.ExecutableNormalizedOperationFactory;\n+import graphql.parser.Parser;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.idl.SchemaGenerator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static graphql.normalized.ExecutableNormalizedOperationFactory.*;\n+\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 2, time = 5)\n+@Measurement(iterations = 3, time = 5)\n+@Fork(2)\n+public class ENFBenchmarkDeepIntrospection {\n+\n+    @Param({\"2\", \"10\", \"20\"})\n+    int howDeep = 2;\n+\n+    String query = \"\";\n+\n+    GraphQLSchema schema;\n+    Document document;\n+\n+    @Setup(Level.Trial)\n+    public void setUp() {\n+        String schemaString = BenchmarkUtils.loadResource(\"large-schema-2.graphqls\");\n+        schema = SchemaGenerator.createdMockedSchema(schemaString);\n+\n+        query = createDeepQuery(howDeep);\n+        document = Parser.parse(query);\n+    }\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public ExecutableNormalizedOperation benchMarkAvgTime() {\n+        ExecutableNormalizedOperationFactory.Options options  = ExecutableNormalizedOperationFactory.Options.defaultOptions();\n+        ExecutableNormalizedOperation executableNormalizedOperation = createExecutableNormalizedOperation(schema,\n+                document,\n+                null,\n+                CoercedVariables.emptyVariables(),\n+                options);\n+        return executableNormalizedOperation;\n+    }\n+\n+    public static void main(String[] args) throws RunnerException {\n+        runAtStartup();\n+\n+        Options opt = new OptionsBuilder()\n+                .include(\"benchmark.ENFBenchmarkDeepIntrospection\")\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+\n+    private static void runAtStartup() {\n+\n+        ENFBenchmarkDeepIntrospection benchmarkIntrospection = new ENFBenchmarkDeepIntrospection();\n+        benchmarkIntrospection.howDeep = 2;\n+\n+        BenchmarkUtils.runInToolingForSomeTimeThenExit(\n+                benchmarkIntrospection::setUp,\n+                () -> { while (true) { benchmarkIntrospection.benchMarkAvgTime(); }},\n+                () ->{}\n+        );\n+    }\n+\n+\n+\n+    private static String createDeepQuery(int depth) {\n+        String result = \"query test {\\n\" +\n+                \"  __schema {\\n\" +\n+                \"    types {\\n\" +\n+                \"      ...F1\\n\" +\n+                \"    }\\n\" +\n+                \"  }\\n\" +\n+                \"}\\n\";\n+\n+        for (int i = 1; i < depth; i++) {\n+            result += \"        fragment F\" + i + \" on __Type {\\n\" +\n+                    \"          fields {\\n\" +\n+                    \"            type {\\n\" +\n+                    \"              ...F\" + (i + 1) +\"\\n\" +\n+                    \"            }\\n\" +\n+                    \"          }\\n\" +\n+                    \"\\n\" +\n+                    \"          ofType {\\n\" +\n+                    \"            ...F\"+ (i + 1) + \"\\n\" +\n+                    \"          }\\n\" +\n+                    \"        }\\n\";\n+        }\n+        result += \"        fragment F\" + depth + \" on __Type {\\n\" +\n+                \"          fields {\\n\" +\n+                \"            type {\\n\" +\n+                \"name\\n\" +\n+                \"            }\\n\" +\n+                \"          }\\n\" +\n+                \"}\\n\";\n+        return result;\n+    }\n+\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 7,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5ce0eadb434848910cb417c646cfd30b8e75a72b",
            "date": "2025-01-06T23:22:16Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "e0f6b66266fac13aeecaef1c2ef1b458828b6cc2",
            "date": "2025-01-06T23:05:39Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "dbf5bdbe2b2fd441fdcdbc69d362edf6ba9a632f",
            "date": "2025-01-06T22:51:25Z",
            "author_login": "github-actions[bot]"
          },
          {
            "sha": "9b4739e8f4dfc1f84a50807d8f4f511a9c84766b",
            "date": "2025-01-06T22:35:23Z",
            "author_login": "dondonz"
          },
          {
            "sha": "a54f7b91b791f6b6fb94e875265e7252b0181455",
            "date": "2025-01-05T06:23:16Z",
            "author_login": "dondonz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": null,
    "description": "GraphQL Java (aka graphql-java) before 21.5 does not properly consider ExecutableNormalizedFields (ENFs) as part of preventing denial of service via introspection queries. 20.9 and 19.11 are also fixed versions.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-30T07:15:01.840",
    "last_modified": "2024-11-21T09:30:56.560",
    "fix_date": "2024-03-22T04:15:39Z"
  },
  "references": [
    {
      "url": "https://github.com/graphql-java/graphql-java/commit/97743bc1b5caa2b0bd894dc8e128b47e4d771e4a",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/discussions/3641",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/pull/3539",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/releases/tag/v19.11",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/releases/tag/v20.9",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/releases/tag/v21.5",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/commit/97743bc1b5caa2b0bd894dc8e128b47e4d771e4a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/discussions/3641",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/pull/3539",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/releases/tag/v19.11",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/releases/tag/v20.9",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/graphql-java/graphql-java/releases/tag/v21.5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:34.500535",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "graphql-java",
    "owner": "graphql-java",
    "created_at": "2015-07-06T06:52:20Z",
    "updated_at": "2025-01-14T10:13:17Z",
    "pushed_at": "2025-01-06T23:22:17Z",
    "size": 15832,
    "stars": 6144,
    "forks": 1121,
    "open_issues": 32,
    "watchers": 6144,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 3820601,
      "Groovy": 3028099,
      "ANTLR": 8545,
      "HTML": 4949
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:59:13.328100"
  }
}