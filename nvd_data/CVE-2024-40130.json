{
  "cve_id": "CVE-2024-40130",
  "github_data": {
    "repository": "open5gs/open5gs",
    "fix_commit": "2f8ae91b0b9467f94f128090c88cae91bd73e008",
    "related_commits": [
      "2f8ae91b0b9467f94f128090c88cae91bd73e008",
      "2f8ae91b0b9467f94f128090c88cae91bd73e008"
    ],
    "patch_url": "https://github.com/open5gs/open5gs/commit/2f8ae91b0b9467f94f128090c88cae91bd73e008.patch",
    "fix_commit_details": {
      "sha": "2f8ae91b0b9467f94f128090c88cae91bd73e008",
      "commit_date": "2023-09-05T12:56:53Z",
      "author": {
        "login": "acetcom",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixed dynamic-stack-buffer-overflow (#2578, #2577)",
        "length": 50,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 253,
        "additions": 179,
        "deletions": 74
      },
      "files": [
        {
          "filename": "src/main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -111,7 +111,7 @@ int main(int argc, const char *const argv[])\n         bool enable_debug;\n         bool enable_trace;\n     } optarg;\n-    const char *argv_out[argc];\n+    const char *argv_out[argc+1];\n \n     memset(&optarg, 0, sizeof(optarg));\n "
        },
        {
          "filename": "tests/app/5gc-init.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -37,7 +37,7 @@ int app_initialize(const char *const argv[])\n     bool user_config = false;\n     int i = 0;\n \n-    for (i = 0; argv[i]; i++) {\n+    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {\n         if (strcmp(\"-c\", argv[i]) == 0) {\n             user_config = true; \n         }"
        },
        {
          "filename": "tests/app/app-init.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -42,7 +42,7 @@ int app_initialize(const char *const argv[])\n     bool user_config = false;\n     int i = 0;\n \n-    for (i = 0; argv[i]; i++) {\n+    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {\n         if (strcmp(\"-c\", argv[i]) == 0) {\n             user_config = true;\n         }"
        },
        {
          "filename": "tests/app/epc-init.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -33,7 +33,7 @@ int app_initialize(const char *const argv[])\n     bool user_config = false;\n     int i = 0;\n \n-    for (i = 0; argv[i]; i++) {\n+    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {\n         if (strcmp(\"-c\", argv[i]) == 0) {\n             user_config = true; \n         }"
        },
        {
          "filename": "tests/common/application.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -27,7 +27,7 @@ static void run(int argc, const char *const argv[],\n     bool user_config;\n \n     /* '-f sample-XXXX.conf -e error' is always added */\n-    const char *argv_out[argc+4], *new_argv[argc+4];\n+    const char *argv_out[argc+5], *new_argv[argc+5];\n     int argc_out;\n \n     char conf_file[OGS_MAX_FILEPATH_LEN];"
        },
        {
          "filename": "tests/common/context.c",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -127,7 +127,8 @@ static int test_context_validation(void)\n \n     if (test_self()->nr_served_tai[index].list2.num) {\n         memcpy(&test_self()->nr_tai,\n-            &test_self()->nr_served_tai[index].list2.tai[0], sizeof(ogs_5gs_tai_t));\n+            &test_self()->nr_served_tai[index].list2.tai[0],\n+            sizeof(ogs_5gs_tai_t));\n     } else if (test_self()->nr_served_tai[index].list1.tai[0].num) {\n         test_self()->nr_tai.tac =\n             test_self()->nr_served_tai[index].list1.tai[0].tac;"
        },
        {
          "filename": "tests/common/context.h",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -477,6 +477,13 @@ typedef struct test_bearer_s {\n \n     uint32_t        sgw_s1u_teid;   /* SGW-S1U TEID */\n     ogs_ip_t        sgw_s1u_ip;     /* SGW-S1U IPv4/IPv6 */\n+    struct {\n+        /* Indirect Forwarding */\n+        uint32_t dl_teid;\n+        ogs_ip_t dl_ip;\n+        uint32_t ul_teid;\n+        ogs_ip_t ul_ip;\n+    } handover;\n \n     uint32_t        enb_s1u_teid;   /* eNB-S1U TEID */\n     ogs_sockaddr_t  *enb_s1u_addr;  /* eNB-S1U IPv4 */"
        },
        {
          "filename": "tests/common/gtpu.c",
          "status": "modified",
          "additions": 1,
          "deletions": 3,
          "patch": "@@ -535,9 +535,7 @@ int test_gtpu_send_indirect_data_forwarding(\n         ext_hdesc.qos_flow_identifier = bearer->qfi;\n \n     } else if (bearer->ebi) {\n-\n-        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n-        ogs_assert_if_reached();\n+        gtp_hdesc.teid = bearer->handover.ul_teid;\n \n     } else {\n         ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);"
        },
        {
          "filename": "tests/common/ngap-build.c",
          "status": "modified",
          "additions": 85,
          "deletions": 61,
          "patch": "@@ -37,7 +37,7 @@ static ogs_pkbuf_t *testngap_build_handover_request_ack_transfer(\n ogs_pkbuf_t *testngap_build_ng_setup_request(uint32_t gnb_id, uint8_t bitsize)\n {\n     ogs_pkbuf_t *pkbuf = NULL;\n-    int i, j;\n+    int i, j, k, num = 0;\n     ogs_plmn_id_t *plmn_id = NULL;\n     const char *ran_node_name = \"5G gNB-CU\";\n \n@@ -118,48 +118,58 @@ ogs_pkbuf_t *testngap_build_ng_setup_request(uint32_t gnb_id, uint8_t bitsize)\n     ogs_asn_buffer_to_OCTET_STRING((char*)ran_node_name,\n             strlen(ran_node_name), RANNodeName);\n \n-    SupportedTAItem = CALLOC(1, sizeof(NGAP_SupportedTAItem_t));\n     if (test_self()->nr_served_tai[0].list2.num)\n-        ogs_asn_uint24_to_OCTET_STRING(\n-            test_self()->nr_served_tai[0].list2.tai[0].tac,\n-            &SupportedTAItem->tAC);\n+        num = test_self()->nr_served_tai[0].list2.num;\n     else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n-        ogs_asn_uint24_to_OCTET_STRING(\n-            test_self()->nr_served_tai[0].list0.tai[0].tac[0],\n-                &SupportedTAItem->tAC);\n+        num = test_self()->nr_served_tai[0].list0.tai[0].num;\n     else\n         ogs_assert_if_reached();\n \n-    for (i = 0; i < test_self()->num_of_plmn_support; i++) {\n-        plmn_id = &test_self()->plmn_support[i].plmn_id;\n+    for (i = 0; i < num; i++) {\n+        SupportedTAItem = CALLOC(1, sizeof(NGAP_SupportedTAItem_t));\n+        if (test_self()->nr_served_tai[0].list2.num)\n+            ogs_asn_uint24_to_OCTET_STRING(\n+                test_self()->nr_served_tai[0].list2.tai[i].tac,\n+                &SupportedTAItem->tAC);\n+        else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n+            ogs_asn_uint24_to_OCTET_STRING(\n+                test_self()->nr_served_tai[0].list0.tai[0].tac[i],\n+                    &SupportedTAItem->tAC);\n+        else\n+            ogs_assert_if_reached();\n \n-        BroadcastPLMNItem = CALLOC(1, sizeof(NGAP_BroadcastPLMNItem_t));\n+        for (j = 0; j < test_self()->num_of_plmn_support; j++) {\n+            plmn_id = &test_self()->plmn_support[j].plmn_id;\n \n-        ogs_asn_buffer_to_OCTET_STRING(\n-                plmn_id, OGS_PLMN_ID_LEN, &BroadcastPLMNItem->pLMNIdentity);\n+            BroadcastPLMNItem = CALLOC(1, sizeof(NGAP_BroadcastPLMNItem_t));\n \n-        for (j = 0; j < test_self()->plmn_support[i].num_of_s_nssai; j++) {\n-            ogs_s_nssai_t *s_nssai = &test_self()->plmn_support[i].s_nssai[j];\n+            ogs_asn_buffer_to_OCTET_STRING(\n+                    plmn_id, OGS_PLMN_ID_LEN, &BroadcastPLMNItem->pLMNIdentity);\n \n-            SliceSupportItem = CALLOC(1, sizeof(NGAP_SliceSupportItem_t));\n-            ogs_asn_uint8_to_OCTET_STRING(s_nssai->sst,\n-                    &SliceSupportItem->s_NSSAI.sST);\n-            if (s_nssai->sd.v != OGS_S_NSSAI_NO_SD_VALUE) {\n-                SliceSupportItem->s_NSSAI.sD = CALLOC(1, sizeof(NGAP_SD_t));\n-                ogs_asn_uint24_to_OCTET_STRING(\n-                        s_nssai->sd, SliceSupportItem->s_NSSAI.sD);\n+            for (k = 0; k < test_self()->plmn_support[j].num_of_s_nssai; k++) {\n+                ogs_s_nssai_t *s_nssai =\n+                    &test_self()->plmn_support[j].s_nssai[k];\n+\n+                SliceSupportItem = CALLOC(1, sizeof(NGAP_SliceSupportItem_t));\n+                ogs_asn_uint8_to_OCTET_STRING(s_nssai->sst,\n+                        &SliceSupportItem->s_NSSAI.sST);\n+                if (s_nssai->sd.v != OGS_S_NSSAI_NO_SD_VALUE) {\n+                    SliceSupportItem->s_NSSAI.sD = CALLOC(1, sizeof(NGAP_SD_t));\n+                    ogs_asn_uint24_to_OCTET_STRING(\n+                            s_nssai->sd, SliceSupportItem->s_NSSAI.sD);\n+                }\n+\n+                ASN_SEQUENCE_ADD(&BroadcastPLMNItem->tAISliceSupportList.list,\n+                                SliceSupportItem);\n             }\n \n-            ASN_SEQUENCE_ADD(&BroadcastPLMNItem->tAISliceSupportList.list,\n-                            SliceSupportItem);\n+            ASN_SEQUENCE_ADD(&SupportedTAItem->broadcastPLMNList.list,\n+                    BroadcastPLMNItem);\n         }\n \n-        ASN_SEQUENCE_ADD(&SupportedTAItem->broadcastPLMNList.list,\n-                BroadcastPLMNItem);\n+        ASN_SEQUENCE_ADD(&SupportedTAList->list, SupportedTAItem);\n     }\n \n-    ASN_SEQUENCE_ADD(&SupportedTAList->list, SupportedTAItem);\n-\n     *PagingDRX = NGAP_PagingDRX_v32;\n \n     return ogs_ngap_encode(&pdu);\n@@ -168,7 +178,7 @@ ogs_pkbuf_t *testngap_build_ng_setup_request(uint32_t gnb_id, uint8_t bitsize)\n ogs_pkbuf_t *testngap_build_ran_configuration_update(bool supported_ta_list)\n {\n     ogs_pkbuf_t *pkbuf = NULL;\n-    int i, j;\n+    int i, j, k, num;\n     ogs_plmn_id_t *plmn_id = NULL;\n \n     NGAP_NGAP_PDU_t pdu;\n@@ -210,48 +220,62 @@ ogs_pkbuf_t *testngap_build_ran_configuration_update(bool supported_ta_list)\n \n         SupportedTAList = &ie->value.choice.SupportedTAList;\n \n-        SupportedTAItem = CALLOC(1, sizeof(NGAP_SupportedTAItem_t));\n         if (test_self()->nr_served_tai[0].list2.num)\n-            ogs_asn_uint24_to_OCTET_STRING(\n-                test_self()->nr_served_tai[0].list2.tai[0].tac,\n-                &SupportedTAItem->tAC);\n+            num = test_self()->nr_served_tai[0].list2.num;\n         else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n-            ogs_asn_uint24_to_OCTET_STRING(\n-                test_self()->nr_served_tai[0].list0.tai[0].tac[0],\n-                    &SupportedTAItem->tAC);\n+            num = test_self()->nr_served_tai[0].list0.tai[0].num;\n         else\n             ogs_assert_if_reached();\n \n-        for (i = 0; i < test_self()->num_of_plmn_support; i++) {\n-            plmn_id = &test_self()->plmn_support[i].plmn_id;\n-\n-            BroadcastPLMNItem = CALLOC(1, sizeof(NGAP_BroadcastPLMNItem_t));\n-\n-            ogs_asn_buffer_to_OCTET_STRING(\n-                    plmn_id, OGS_PLMN_ID_LEN, &BroadcastPLMNItem->pLMNIdentity);\n-\n-            for (j = 0; j < test_self()->plmn_support[i].num_of_s_nssai; j++) {\n-                ogs_s_nssai_t *s_nssai =\n-                    &test_self()->plmn_support[i].s_nssai[j];\n-\n-                SliceSupportItem = CALLOC(1, sizeof(NGAP_SliceSupportItem_t));\n-                ogs_asn_uint8_to_OCTET_STRING(s_nssai->sst,\n-                        &SliceSupportItem->s_NSSAI.sST);\n-                if (s_nssai->sd.v != OGS_S_NSSAI_NO_SD_VALUE) {\n-                    SliceSupportItem->s_NSSAI.sD = CALLOC(1, sizeof(NGAP_SD_t));\n-                    ogs_asn_uint24_to_OCTET_STRING(\n-                            s_nssai->sd, SliceSupportItem->s_NSSAI.sD);\n+        for (i = 0; i < num; i++) {\n+            SupportedTAItem = CALLOC(1, sizeof(NGAP_SupportedTAItem_t));\n+            if (test_self()->nr_served_tai[0].list2.num)\n+                ogs_asn_uint24_to_OCTET_STRING(\n+                    test_self()->nr_served_tai[0].list2.tai[i].tac,\n+                    &SupportedTAItem->tAC);\n+            else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n+                ogs_asn_uint24_to_OCTET_STRING(\n+                    test_self()->nr_served_tai[0].list0.tai[0].tac[i],\n+                        &SupportedTAItem->tAC);\n+            else\n+                ogs_assert_if_reached();\n+\n+            for (j = 0; j < test_self()->num_of_plmn_support; j++) {\n+                plmn_id = &test_self()->plmn_support[j].plmn_id;\n+\n+                BroadcastPLMNItem = CALLOC(1, sizeof(NGAP_BroadcastPLMNItem_t));\n+\n+                ogs_asn_buffer_to_OCTET_STRING(\n+                        plmn_id, OGS_PLMN_ID_LEN,\n+                        &BroadcastPLMNItem->pLMNIdentity);\n+\n+                for (k = 0; k < test_self()->plmn_support[j].num_of_s_nssai;\n+                        k++) {\n+                    ogs_s_nssai_t *s_nssai =\n+                        &test_self()->plmn_support[j].s_nssai[k];\n+\n+                    SliceSupportItem = CALLOC(1,\n+                            sizeof(NGAP_SliceSupportItem_t));\n+                    ogs_asn_uint8_to_OCTET_STRING(s_nssai->sst,\n+                            &SliceSupportItem->s_NSSAI.sST);\n+                    if (s_nssai->sd.v != OGS_S_NSSAI_NO_SD_VALUE) {\n+                        SliceSupportItem->s_NSSAI.sD = CALLOC(\n+                                1, sizeof(NGAP_SD_t));\n+                        ogs_asn_uint24_to_OCTET_STRING(\n+                                s_nssai->sd, SliceSupportItem->s_NSSAI.sD);\n+                    }\n+\n+                    ASN_SEQUENCE_ADD(\n+                            &BroadcastPLMNItem->tAISliceSupportList.list,\n+                            SliceSupportItem);\n                 }\n \n-                ASN_SEQUENCE_ADD(&BroadcastPLMNItem->tAISliceSupportList.list,\n-                                SliceSupportItem);\n+                ASN_SEQUENCE_ADD(&SupportedTAItem->broadcastPLMNList.list,\n+                        BroadcastPLMNItem);\n             }\n \n-            ASN_SEQUENCE_ADD(&SupportedTAItem->broadcastPLMNList.list,\n-                    BroadcastPLMNItem);\n+            ASN_SEQUENCE_ADD(&SupportedTAList->list, SupportedTAItem);\n         }\n-\n-        ASN_SEQUENCE_ADD(&SupportedTAList->list, SupportedTAItem);\n     }\n \n     return ogs_ngap_encode(&pdu);"
        },
        {
          "filename": "tests/common/s1ap-handler.c",
          "status": "modified",
          "additions": 45,
          "deletions": 0,
          "patch": "@@ -479,6 +479,7 @@ void tests1ap_handle_handover_command(\n     char buf[OGS_ADDRSTRLEN];\n \n     test_sess_t *sess = NULL;\n+    test_bearer_t *bearer = NULL;\n \n     S1AP_S1AP_PDU_t pdu;\n     S1AP_SuccessfulOutcome_t *successfulOutcome = NULL;\n@@ -487,6 +488,8 @@ void tests1ap_handle_handover_command(\n     S1AP_HandoverCommandIEs_t *ie = NULL;\n     S1AP_MME_UE_S1AP_ID_t *MME_UE_S1AP_ID = NULL;\n     S1AP_ENB_UE_S1AP_ID_t *ENB_UE_S1AP_ID = NULL;\n+    S1AP_E_RABSubjecttoDataForwardingList_t\n+        *E_RABSubjecttoDataForwardingList = NULL;\n \n     ogs_assert(test_ue);\n     ogs_assert(message);\n@@ -505,6 +508,10 @@ void tests1ap_handle_handover_command(\n         case S1AP_ProtocolIE_ID_id_eNB_UE_S1AP_ID:\n             ENB_UE_S1AP_ID = &ie->value.choice.ENB_UE_S1AP_ID;\n             break;\n+        case S1AP_ProtocolIE_ID_id_E_RABSubjecttoDataForwardingList:\n+            E_RABSubjecttoDataForwardingList =\n+                &ie->value.choice.E_RABSubjecttoDataForwardingList;\n+            break;\n         default:\n             break;\n         }\n@@ -514,6 +521,44 @@ void tests1ap_handle_handover_command(\n         test_ue->mme_ue_s1ap_id = *MME_UE_S1AP_ID;\n     if (ENB_UE_S1AP_ID)\n         test_ue->enb_ue_s1ap_id = *ENB_UE_S1AP_ID;\n+\n+    if (E_RABSubjecttoDataForwardingList) {\n+        for (i = 0; i < E_RABSubjecttoDataForwardingList->list.count; i++) {\n+            S1AP_E_RABDataForwardingItemIEs_t *ie = NULL;\n+            S1AP_E_RABDataForwardingItem_t *e_rab = NULL;\n+\n+            ie = (S1AP_E_RABDataForwardingItemIEs_t *)\n+                    E_RABSubjecttoDataForwardingList->list.array[i];\n+            ogs_assert(ie);\n+            e_rab = &ie->value.choice.E_RABDataForwardingItem;\n+\n+            bearer = test_bearer_find_by_ue_ebi(test_ue, e_rab->e_RAB_ID);\n+            ogs_assert(bearer);\n+\n+            if (e_rab->dL_gTP_TEID) {\n+                memcpy(&bearer->handover.dl_teid, e_rab->dL_gTP_TEID->buf,\n+                        sizeof(bearer->handover.dl_teid));\n+                bearer->handover.dl_teid = be32toh(bearer->handover.dl_teid);\n+            }\n+            if (e_rab->dL_transportLayerAddress) {\n+                ogs_assert(OGS_OK ==\n+                        ogs_asn_BIT_STRING_to_ip(\n+                            e_rab->dL_transportLayerAddress,\n+                            &bearer->handover.dl_ip));\n+            }\n+            if (e_rab->uL_GTP_TEID) {\n+                memcpy(&bearer->handover.ul_teid, e_rab->uL_GTP_TEID->buf,\n+                        sizeof(bearer->handover.ul_teid));\n+                bearer->handover.ul_teid = be32toh(bearer->handover.ul_teid);\n+            }\n+            if (e_rab->uL_TransportLayerAddress) {\n+                ogs_assert(OGS_OK ==\n+                        ogs_asn_BIT_STRING_to_ip(\n+                            e_rab->uL_TransportLayerAddress,\n+                            &bearer->handover.ul_ip));\n+            }\n+        }\n+    }\n }\n \n void tests1ap_handle_handover_preparation_failure("
        },
        {
          "filename": "tests/core/abts-main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -77,7 +77,7 @@ int main(int argc, const char *const argv[])\n         char *log_level;\n         char *domain_mask;\n     } optarg;\n-    const char *argv_out[argc+2]; /* '-e error' is always added */\n+    const char *argv_out[argc+3]; /* '-e error' is always added */\n     \n     abts_suite *suite = NULL;\n     ogs_pkbuf_config_t config;"
        },
        {
          "filename": "tests/crypt/abts-main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -50,7 +50,7 @@ int main(int argc, const char *const argv[])\n         char *log_level;\n         char *domain_mask;\n     } optarg;\n-    const char *argv_out[argc+2]; /* '-e error' is always added */\n+    const char *argv_out[argc+3]; /* '-e error' is always added */\n     \n     abts_suite *suite = NULL;\n     ogs_pkbuf_config_t config;"
        },
        {
          "filename": "tests/handover/epc-s1-test.c",
          "status": "modified",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -28,6 +28,7 @@ static void test1_func(abts_case *tc, void *data)\n     ogs_pkbuf_t *esmbuf;\n     ogs_pkbuf_t *sendbuf;\n     ogs_pkbuf_t *recvbuf;\n+    ogs_pkbuf_t *pkbuf;\n     ogs_s1ap_message_t message;\n \n     ogs_nas_5gs_mobile_identity_suci_t mobile_identity_suci;\n@@ -329,6 +330,35 @@ static void test1_func(abts_case *tc, void *data)\n     ABTS_PTR_NOTNULL(tc, recvbuf);\n     tests1ap_recv(test_ue, recvbuf);\n \n+    /* Send GTP-U ICMP Packet */\n+    bearer = test_bearer_find_by_ue_ebi(test_ue, 5);\n+    ogs_assert(bearer);\n+    rv = test_gtpu_send_ping(gtpu1, bearer, TEST_PING_IPV4);\n+    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n+\n+    /* Receive GTP-U ICMP Packet */\n+    recvbuf = test_gtpu_read(gtpu1);\n+    ABTS_PTR_NOTNULL(tc, recvbuf);\n+\n+    /* Copy ICMP Packet */\n+    pkbuf = ogs_pkbuf_alloc(NULL, 200);\n+    ogs_assert(pkbuf);\n+    ogs_pkbuf_reserve(pkbuf, OGS_GTPV1U_5GC_HEADER_LEN);\n+    ogs_pkbuf_put(pkbuf, 200-OGS_GTPV1U_5GC_HEADER_LEN);\n+    memset(pkbuf->data, 0, pkbuf->len);\n+    memcpy(pkbuf->data, recvbuf->data + 8, recvbuf->len - 8);\n+\n+    ogs_pkbuf_free(recvbuf);\n+\n+    /* Send GTP-U Packet with Indirect Data Forwarding */\n+    rv = test_gtpu_send_indirect_data_forwarding(gtpu1, bearer, pkbuf);\n+    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n+\n+    /* Receive GTP-U ICMP Packet */\n+    recvbuf = testgnb_gtpu_read(gtpu2);\n+    ABTS_PTR_NOTNULL(tc, recvbuf);\n+    ogs_pkbuf_free(recvbuf);\n+\n     /* Send eNB Status Transfer */\n     sendbuf = test_s1ap_build_enb_status_transfer(test_ue);\n     ABTS_PTR_NOTNULL(tc, sendbuf);"
        },
        {
          "filename": "tests/sctp/abts-main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -45,7 +45,7 @@ int main(int argc, const char *const argv[])\n         char *log_level;\n         char *domain_mask;\n     } optarg;\n-    const char *argv_out[argc+2]; /* '-e error' is always added */\n+    const char *argv_out[argc+3]; /* '-e error' is always added */\n     \n     abts_suite *suite = NULL;\n     ogs_pkbuf_config_t config;"
        },
        {
          "filename": "tests/unit/abts-main.c",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -67,7 +67,7 @@ int main(int argc, const char *const argv[])\n         char *log_level;\n         char *domain_mask;\n     } optarg;\n-    const char *argv_out[argc+2]; /* '-e error' is always added */\n+    const char *argv_out[argc+3]; /* '-e error' is always added */\n     \n     abts_suite *suite = NULL;\n     ogs_pkbuf_config_t config;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 14,
        "unique_directories": 8,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "13585a34e3d5505dd86d2cdf78c91829f3936851",
            "date": "2025-01-12T02:47:12Z",
            "author_login": "acetcom"
          },
          {
            "sha": "d181ab54ccf9fb829ec491dfc18ab42e4179ae8f",
            "date": "2025-01-11T05:32:39Z",
            "author_login": "acetcom"
          },
          {
            "sha": "8ff1d1b66675c69e2916e3289e481899df5bfc23",
            "date": "2025-01-06T01:38:51Z",
            "author_login": "acetcom"
          },
          {
            "sha": "df079b48d85e26ffe03fc18579ed9f7d69e1bff5",
            "date": "2025-01-05T13:17:38Z",
            "author_login": "acetcom"
          },
          {
            "sha": "ff917e9436a1925fb7a84729ae6b083918d2d9d1",
            "date": "2025-01-04T05:11:08Z",
            "author_login": "acetcom"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-787",
    "description": "open5gs v2.6.4 is vulnerable to Buffer Overflow. via /lib/core/abts.c.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-16T19:15:12.683",
    "last_modified": "2024-11-21T09:30:58.570",
    "fix_date": "2023-09-05T12:56:53Z"
  },
  "references": [
    {
      "url": "https://github.com/open5gs/open5gs/commit/2f8ae91b0b9467f94f128090c88cae91bd73e008",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/open5gs/open5gs/issues/2577",
      "source": "cve@mitre.org",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/open5gs/open5gs/commit/2f8ae91b0b9467f94f128090c88cae91bd73e008",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/open5gs/open5gs/issues/2577",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Issue Tracking",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.486791",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "open5gs",
    "owner": "open5gs",
    "created_at": "2017-02-01T10:48:49Z",
    "updated_at": "2025-01-14T11:52:37Z",
    "pushed_at": "2025-01-12T02:47:33Z",
    "size": 70375,
    "stars": 1936,
    "forks": 783,
    "open_issues": 203,
    "watchers": 1936,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "C": 49736410,
      "Mustache": 466439,
      "JavaScript": 248805,
      "Meson": 241352,
      "Python": 187063,
      "Shell": 84460,
      "Dockerfile": 6508,
      "C++": 3446,
      "Awk": 2639,
      "CSS": 2192
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T15:34:10.765143"
  }
}