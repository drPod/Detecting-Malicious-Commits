{
  "cve_id": "CVE-2024-40634",
  "github_data": {
    "repository": "argoproj/argo-cd",
    "fix_commit": "46c0c0b64deaab1ece70cb701030b76668ad0cdc",
    "related_commits": [
      "46c0c0b64deaab1ece70cb701030b76668ad0cdc",
      "540e3a57b90eb3655db54793332fac86bcc38b36",
      "d881ee78949e23160a0b280bb159e4d3d625a4df",
      "46c0c0b64deaab1ece70cb701030b76668ad0cdc",
      "540e3a57b90eb3655db54793332fac86bcc38b36",
      "d881ee78949e23160a0b280bb159e4d3d625a4df"
    ],
    "patch_url": "https://github.com/argoproj/argo-cd/commit/46c0c0b64deaab1ece70cb701030b76668ad0cdc.patch",
    "fix_commit_details": {
      "sha": "46c0c0b64deaab1ece70cb701030b76668ad0cdc",
      "commit_date": "2024-07-22T14:08:18Z",
      "author": {
        "login": "pasha-codefresh",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 701,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 91,
        "additions": 80,
        "deletions": 11
      },
      "files": [
        {
          "filename": "docs/operator-manual/argocd-cm.yaml",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -412,3 +412,5 @@ data:\n               cluster:\n                 name: some-cluster\n                 server: https://some-cluster\n+  # The maximum size of the payload that can be sent to the webhook server.\n+  webhook.maxPayloadSizeMB: 1024\n\\ No newline at end of file"
        },
        {
          "filename": "docs/operator-manual/webhook.md",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -19,6 +19,8 @@ URL configured in the Git provider should use the `/api/webhook` endpoint of you\n (e.g. `https://argocd.example.com/api/webhook`). If you wish to use a shared secret, input an\n arbitrary value in the secret. This value will be used when configuring the webhook in the next step.\n \n+To prevent DDoS attacks with unauthenticated webhook events (the `/api/webhook` endpoint currently lacks rate limiting protection), it is recommended to limit the payload size. You can achieve this by configuring the `argocd-cm` ConfigMap with the `webhook.maxPayloadSizeMB` attribute. The default value is 1GB.\n+\n ## Github\n \n ![Add Webhook](../assets/webhook-config.png \"Add Webhook\")"
        },
        {
          "filename": "server/server.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1034,7 +1034,7 @@ func (a *ArgoCDServer) newHTTPServer(ctx context.Context, port int, grpcWebHandl\n \n \t// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)\n \targoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)\n-\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), 24*time.Hour, 3*time.Minute), a.Cache, argoDB)\n+\tacdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), 24*time.Hour, 3*time.Minute), a.Cache, argoDB, a.settingsMgr.GetMaxWebhookPayloadSize())\n \n \tmux.HandleFunc(\"/api/webhook\", acdWebhookHandler.Handler)\n "
        },
        {
          "filename": "util/settings/settings.go",
          "status": "modified",
          "additions": 30,
          "deletions": 6,
          "patch": "@@ -429,6 +429,8 @@ const (\n \tsettingsWebhookAzureDevOpsUsernameKey = \"webhook.azuredevops.username\"\n \t// settingsWebhookAzureDevOpsPasswordKey is the key for Azure DevOps webhook password\n \tsettingsWebhookAzureDevOpsPasswordKey = \"webhook.azuredevops.password\"\n+\t// settingsWebhookMaxPayloadSize is the key for the maximum payload size for webhooks in MB\n+\tsettingsWebhookMaxPayloadSizeMB = \"webhook.maxPayloadSizeMB\"\n \t// settingsApplicationInstanceLabelKey is the key to configure injected app instance label key\n \tsettingsApplicationInstanceLabelKey = \"application.instanceLabelKey\"\n \t// settingsResourceTrackingMethodKey is the key to configure tracking method for application resources\n@@ -506,14 +508,17 @@ const (\n \tRespectRBACValueNormal = \"normal\"\n )\n \n-var (\n-\tsourceTypeToEnableGenerationKey = map[v1alpha1.ApplicationSourceType]string{\n-\t\tv1alpha1.ApplicationSourceTypeKustomize: \"kustomize.enable\",\n-\t\tv1alpha1.ApplicationSourceTypeHelm:      \"helm.enable\",\n-\t\tv1alpha1.ApplicationSourceTypeDirectory: \"jsonnet.enable\",\n-\t}\n+const (\n+\t// default max webhook payload size is 1GB\n+\tdefaultMaxWebhookPayloadSize = int64(1) * 1024 * 1024 * 1024\n )\n \n+var sourceTypeToEnableGenerationKey = map[v1alpha1.ApplicationSourceType]string{\n+\tv1alpha1.ApplicationSourceTypeKustomize: \"kustomize.enable\",\n+\tv1alpha1.ApplicationSourceTypeHelm:      \"helm.enable\",\n+\tv1alpha1.ApplicationSourceTypeDirectory: \"jsonnet.enable\",\n+}\n+\n // SettingsManager holds config info for a new manager with which to access Kubernetes ConfigMaps.\n type SettingsManager struct {\n \tctx             context.Context\n@@ -2209,3 +2214,22 @@ func (mgr *SettingsManager) GetResourceCustomLabels() ([]string, error) {\n \t}\n \treturn []string{}, nil\n }\n+\n+func (mgr *SettingsManager) GetMaxWebhookPayloadSize() int64 {\n+\targoCDCM, err := mgr.getConfigMap()\n+\tif err != nil {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tif argoCDCM.Data[settingsWebhookMaxPayloadSizeMB] == \"\" {\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\tmaxPayloadSizeMB, err := strconv.ParseInt(argoCDCM.Data[settingsWebhookMaxPayloadSizeMB], 10, 64)\n+\tif err != nil {\n+\t\tlog.Warnf(\"Failed to parse '%s' key: %v\", settingsWebhookMaxPayloadSizeMB, err)\n+\t\treturn defaultMaxWebhookPayloadSize\n+\t}\n+\n+\treturn maxPayloadSizeMB * 1024 * 1024\n+}"
        },
        {
          "filename": "util/webhook/webhook.go",
          "status": "modified",
          "additions": 17,
          "deletions": 1,
          "patch": "@@ -42,6 +42,8 @@ type settingsSource interface {\n // https://github.com/shadow-maint/shadow/blob/master/libmisc/chkname.c#L36\n const usernameRegex = `[a-zA-Z0-9_\\.][a-zA-Z0-9_\\.-]{0,30}[a-zA-Z0-9_\\.\\$-]?`\n \n+const payloadQueueSize = 50000\n+\n var (\n \t_                              settingsSource = &settings.SettingsManager{}\n \terrBasicAuthVerificationFailed                = errors.New(\"basic auth verification failed\")\n@@ -62,9 +64,11 @@ type ArgoCDWebhookHandler struct {\n \tazuredevopsAuthHandler func(r *http.Request) error\n \tgogs                   *gogs.Webhook\n \tsettingsSrc            settingsSource\n+\tqueue                  chan interface{}\n+\tmaxWebhookPayloadSizeB int64\n }\n \n-func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB) *ArgoCDWebhookHandler {\n+func NewHandler(namespace string, applicationNamespaces []string, appClientset appclientset.Interface, set *settings.ArgoCDSettings, settingsSrc settingsSource, repoCache *cache.Cache, serverCache *servercache.Cache, argoDB db.ArgoDB, maxWebhookPayloadSizeB int64) *ArgoCDWebhookHandler {\n \tgithubWebhook, err := github.New(github.Options.Secret(set.WebhookGitHubSecret))\n \tif err != nil {\n \t\tlog.Warnf(\"Unable to init the GitHub webhook\")\n@@ -114,6 +118,8 @@ func NewHandler(namespace string, applicationNamespaces []string, appClientset a\n \t\trepoCache:              repoCache,\n \t\tserverCache:            serverCache,\n \t\tdb:                     argoDB,\n+\t\tqueue:                  make(chan interface{}, payloadQueueSize),\n+\t\tmaxWebhookPayloadSizeB: maxWebhookPayloadSizeB,\n \t}\n \n \treturn &acdWebhook\n@@ -458,6 +464,8 @@ func (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \tvar payload interface{}\n \tvar err error\n \n+\tr.Body = http.MaxBytesReader(w, r.Body, a.maxWebhookPayloadSizeB)\n+\n \tswitch {\n \tcase r.Header.Get(\"X-Vss-Activityid\") != \"\":\n \t\tif err = a.azuredevopsAuthHandler(r); err != nil {\n@@ -500,6 +508,14 @@ func (a *ArgoCDWebhookHandler) Handler(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tif err != nil {\n+\t\t// If the error is due to a large payload, return a more user-friendly error message\n+\t\tif err.Error() == \"error parsing payload\" {\n+\t\t\tmsg := fmt.Sprintf(\"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under %v MB) and ensure it is valid JSON\", a.maxWebhookPayloadSizeB/1024/1024)\n+\t\t\tlog.WithField(common.SecurityField, common.SecurityHigh).Warn(msg)\n+\t\t\thttp.Error(w, msg, http.StatusBadRequest)\n+\t\t\treturn\n+\t\t}\n+\n \t\tlog.Infof(\"Webhook processing failed: %s\", err)\n \t\tstatus := http.StatusBadRequest\n \t\tif r.Method != http.MethodPost {"
        },
        {
          "filename": "util/webhook/webhook_test.go",
          "status": "modified",
          "additions": 28,
          "deletions": 3,
          "patch": "@@ -4,6 +4,7 @@ import (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"github.com/stretchr/testify/require\"\n \t\"io\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n@@ -56,6 +57,11 @@ type reactorDef struct {\n }\n \n func NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects ...runtime.Object) *ArgoCDWebhookHandler {\n+\tdefaultMaxPayloadSize := int64(1) * 1024 * 1024 * 1024\n+\treturn NewMockHandlerWithPayloadLimit(reactor, applicationNamespaces, defaultMaxPayloadSize, objects...)\n+}\n+\n+func NewMockHandlerWithPayloadLimit(reactor *reactorDef, applicationNamespaces []string, maxPayloadSize int64, objects ...runtime.Object) *ArgoCDWebhookHandler {\n \tappClientset := appclientset.NewSimpleClientset(objects...)\n \tif reactor != nil {\n \t\tdefaultReactor := appClientset.ReactionChain[0]\n@@ -71,7 +77,7 @@ func NewMockHandler(reactor *reactorDef, applicationNamespaces []string, objects\n \t\tcacheClient,\n \t\t1*time.Minute,\n \t\t1*time.Minute,\n-\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{})\n+\t), servercache.NewCache(appstate.NewCache(cacheClient, time.Minute), time.Minute, time.Minute, time.Minute), &mocks.ArgoDB{}, maxPayloadSize)\n }\n \n func TestGitHubCommitEvent(t *testing.T) {\n@@ -391,8 +397,9 @@ func TestInvalidEvent(t *testing.T) {\n \treq.Header.Set(\"X-GitHub-Event\", \"push\")\n \tw := httptest.NewRecorder()\n \th.Handler(w, req)\n-\tassert.Equal(t, w.Code, http.StatusBadRequest)\n-\texpectedLogResult := \"Webhook processing failed: error parsing payload\"\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 1024 MB) and ensure it is valid JSON\"\n \tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n \tassert.Equal(t, expectedLogResult+\"\\n\", w.Body.String())\n \thook.Reset()\n@@ -683,3 +690,21 @@ func Test_getWebUrlRegex(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestGitHubCommitEventMaxPayloadSize(t *testing.T) {\n+\thook := test.NewGlobal()\n+\tmaxPayloadSize := int64(100)\n+\th := NewMockHandlerWithPayloadLimit(nil, []string{}, maxPayloadSize)\n+\treq := httptest.NewRequest(http.MethodPost, \"/api/webhook\", nil)\n+\treq.Header.Set(\"X-GitHub-Event\", \"push\")\n+\teventJSON, err := os.ReadFile(\"testdata/github-commit-event.json\")\n+\trequire.NoError(t, err)\n+\treq.Body = io.NopCloser(bytes.NewReader(eventJSON))\n+\tw := httptest.NewRecorder()\n+\th.Handler(w, req)\n+\tclose(h.queue)\n+\tassert.Equal(t, http.StatusBadRequest, w.Code)\n+\texpectedLogResult := \"Webhook processing failed: The payload is either too large or corrupted. Please check the payload size (must be under 0 MB) and ensure it is valid JSON\"\n+\tassert.Equal(t, expectedLogResult, hook.LastEntry().Message)\n+\thook.Reset()\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d23e6ac79bb95a911b988551ba33bfc9939c5f18",
            "date": "2025-01-14T16:10:14Z",
            "author_login": "crenshaw-dev"
          },
          {
            "sha": "9a51757049dc028596d4950d7a6c7cd5a446301a",
            "date": "2025-01-14T15:41:32Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "c3600d240a42a4708ec65091ffb23689b4513f85",
            "date": "2025-01-14T12:37:06Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "b77d9d9f5f9cf3862ef75e14a5877a3fcf60fa40",
            "date": "2025-01-14T12:16:41Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "2f579404f68ded0b0156fc25d6e554640c4ad009",
            "date": "2025-01-14T12:12:38Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. This report details a security vulnerability in Argo CD, where an unauthenticated attacker can send a specially crafted large JSON payload to the /api/webhook endpoint, causing excessive memory allocation that leads to service disruption by triggering an Out Of Memory (OOM) kill. The issue poses a high risk to the availability of Argo CD deployments. This vulnerability is fixed in 2.11.6, 2.10.15, and 2.9.20.\n",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-22T18:15:03.770",
    "last_modified": "2025-01-09T16:55:20.183",
    "fix_date": "2024-07-22T14:08:18Z"
  },
  "references": [
    {
      "url": "https://github.com/argoproj/argo-cd/commit/46c0c0b64deaab1ece70cb701030b76668ad0cdc",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/540e3a57b90eb3655db54793332fac86bcc38b36",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/d881ee78949e23160a0b280bb159e4d3d625a4df",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-jmvp-698c-4x3w",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/46c0c0b64deaab1ece70cb701030b76668ad0cdc",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/540e3a57b90eb3655db54793332fac86bcc38b36",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/commit/d881ee78949e23160a0b280bb159e4d3d625a4df",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-jmvp-698c-4x3w",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.510477",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "argo-cd",
    "owner": "argoproj",
    "created_at": "2018-02-09T11:12:01Z",
    "updated_at": "2025-01-14T12:37:12Z",
    "pushed_at": "2025-01-14T12:37:08Z",
    "size": 125601,
    "stars": 18420,
    "forks": 5620,
    "open_issues": 3601,
    "watchers": 18420,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 6686751,
      "TypeScript": 1298168,
      "Lua": 199797,
      "SCSS": 92938,
      "Shell": 58329,
      "Makefile": 24983,
      "Dockerfile": 15204,
      "Procfile": 10040,
      "JavaScript": 5975,
      "CSS": 2209,
      "Mustache": 1066,
      "HTML": 895
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:15:10.212233"
  }
}