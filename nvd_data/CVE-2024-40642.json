{
  "cve_id": "CVE-2024-40642",
  "github_data": {
    "repository": "netty/netty-incubator-codec-ohttp",
    "fix_commit": "b687a0cf6ea1030232ea204d73bce82f2698e571",
    "related_commits": [
      "b687a0cf6ea1030232ea204d73bce82f2698e571",
      "b687a0cf6ea1030232ea204d73bce82f2698e571"
    ],
    "patch_url": "https://github.com/netty/netty-incubator-codec-ohttp/commit/b687a0cf6ea1030232ea204d73bce82f2698e571.patch",
    "fix_commit_details": {
      "sha": "b687a0cf6ea1030232ea204d73bce82f2698e571",
      "commit_date": "2024-07-18T20:04:46Z",
      "author": {
        "login": "normanmaurer",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 279,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 151,
        "additions": 150,
        "deletions": 1
      },
      "files": [
        {
          "filename": "codec-bhttp/src/main/java/io/netty/incubator/codec/bhttp/BinaryHttpParser.java",
          "status": "modified",
          "additions": 48,
          "deletions": 1,
          "patch": "@@ -73,12 +73,51 @@ private enum State {\n         }\n     }\n \n+    private static final boolean[] ALLOWED_TOKEN;\n+    private static final boolean[] ALLOWED_SCHEME;\n+\n+    static {\n+        ALLOWED_TOKEN = new boolean[256];\n+        for (byte b = Byte.MIN_VALUE; b < Byte.MAX_VALUE; b++) {\n+            ALLOWED_TOKEN[128 + b] = !Character.isWhitespace(b);\n+        }\n+\n+        // See https://www.rfc-editor.org/rfc/rfc3986.html\n+        //    scheme        = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n+        ALLOWED_SCHEME = new boolean[256];\n+        for (byte b = Byte.MIN_VALUE; b < Byte.MAX_VALUE; b++) {\n+            ALLOWED_SCHEME[128 + b] = Character.isAlphabetic(b) || Character.isDigit(b) ||\n+                    b == (byte) '+' || b == (byte) '-' || b == (byte) '.';\n+        }\n+    }\n+\n+    // See https://www.rfc-editor.org/rfc/rfc9110.html#section-5.6.2\n+    private static final ByteProcessor TOKEN_VALIDATOR = b -> {\n+        // Is whitespace will match whitespaces and delimiters.\n+        if (ALLOWED_TOKEN[b + 128]) {\n+            return true;\n+        }\n+        throw new IllegalArgumentException(\n+                \"Invalid char in token received: '\" + b + \"' (0x\" + Integer.toHexString(b) + \")\");\n+    };\n+\n+    // See https://www.rfc-editor.org/rfc/rfc3986.html\n+    private static final ByteProcessor SCHEME_VALIDATOR = b -> {\n+        // Is whitespace will match whitespaces and delimiters.\n+        if (ALLOWED_SCHEME[b + 128]) {\n+            return true;\n+        }\n+        throw new IllegalArgumentException(\n+                \"Invalid char in scheme received : '\" + b + \"' (0x\" + Integer.toHexString(b) + \")\");\n+    };\n+\n     private static final ByteProcessor PADDING_VALIDATOR = b -> {\n         // Let's validate that only 0 is used for padding. While this is not strictly required\n         // it can't harm to enforce it.\n         // See https://www.rfc-editor.org/rfc/rfc9292.html#section-3.8\n         if (b != 0) {\n-            throw new CorruptedFrameException(\"Invalid byte used for padding: \" + b);\n+            throw new CorruptedFrameException(\n+                    \"Invalid byte used for padding: '\" + b + \"' (0x\" + Integer.toHexString(b) + \")\");\n         }\n         return true;\n     };\n@@ -418,6 +457,14 @@ private static BinaryHttpRequest readRequestHead(ByteBuf in, boolean knownLength\n         // Add the bytes of the field section as well.\n         sumBytes += fieldSectionReadableBytes - fieldSectionSlice.readableBytes();\n \n+        // Let's validate method, scheme, authority and path.\n+        in.forEachByte(methodIdx, (int) methodLength, TOKEN_VALIDATOR);\n+        in.forEachByte(schemeIdx, (int) schemeLength, SCHEME_VALIDATOR);\n+\n+        // We only do very limited validation for these to ensure there can nothing be injected.\n+        in.forEachByte(authorityIdx, (int) authorityLength, TOKEN_VALIDATOR);\n+        in.forEachByte(pathIdx, (int) pathLength, TOKEN_VALIDATOR);\n+\n         String method = in.toString(methodIdx, (int) methodLength, StandardCharsets.US_ASCII);\n         String scheme = in.toString(schemeIdx, (int) schemeLength, StandardCharsets.US_ASCII);\n         String authority = in.toString(authorityIdx, (int) authorityLength, StandardCharsets.US_ASCII);"
        },
        {
          "filename": "codec-bhttp/src/test/java/io/netty/incubator/codec/bhttp/BinaryHttpParserTest.java",
          "status": "added",
          "additions": 102,
          "deletions": 0,
          "patch": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2024 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.incubator.codec.bhttp;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.CharsetUtil;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class BinaryHttpParserTest {\n+\n+    @ParameterizedTest(name = \"{index} => {0}, {1}, {2}\")\n+    @MethodSource(\"invalidChars\")\n+    void testInvalidMethodSuffix(Position p, Part part, String hexString, Character c) {\n+        ByteBuf buffer = Unpooled.buffer();\n+        VarIntCodecUtils.writeVariableLengthInteger(buffer, 0);\n+\n+        writeString(Part.METHOD, \"GET\", buffer, p, part, c);\n+        writeString(Part.SCHEME, \"HTTPS\", buffer, p, part, c);\n+        writeString(Part.AUTHORITY, \"something\", buffer, p, part, c);\n+        writeString(Part.PATH, \"/somepath\", buffer, p, part, c);\n+        VarIntCodecUtils.writeVariableLengthInteger(buffer, 0);\n+        testInvalidHead(buffer);\n+    }\n+\n+    private void writeString(Part currentPart, String str, ByteBuf out, Position p, Part part, Character c) {\n+        if (currentPart == part) {\n+            switch (p) {\n+                case PREFIX:\n+                    writeString(out, c + str);\n+                    break;\n+                case SUFFIX:\n+                    writeString(out, str + c);\n+                    break;\n+                case MIDDLE:\n+                    writeString(out, str.substring(0, 1) + c + str.substring(1));\n+                    break;\n+            }\n+        } else {\n+            writeString(out, str);\n+        }\n+    }\n+    private static Stream<Arguments> invalidChars() {\n+        List<Arguments> invalid = new ArrayList<>();\n+        for (int i = Byte.MIN_VALUE; i < Byte.MAX_VALUE; i++) {\n+            char c = (char) i;\n+            if (Character.isWhitespace(c)) {\n+                for (Position p: Position.values()) {\n+                    for (Part part: Part.values()) {\n+                        invalid.add(Arguments.of(p, part, \"0x\" + Integer.toHexString(c), c));\n+                    }\n+                }\n+            }\n+        }\n+        return invalid.stream();\n+    }\n+\n+    private static void writeString(ByteBuf out, String str) {\n+        byte[] bytes = str.getBytes(CharsetUtil.US_ASCII);\n+        VarIntCodecUtils.writeVariableLengthInteger(out, bytes.length);\n+        out.writeBytes(bytes);\n+    }\n+\n+    private static void testInvalidHead(ByteBuf input) {\n+        BinaryHttpParser parser = new BinaryHttpParser(8192);\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> parser.parse(input, false));\n+        input.release();\n+    }\n+\n+    private enum Position {\n+        PREFIX,\n+        MIDDLE,\n+        SUFFIX;\n+    }\n+\n+    private enum Part {\n+        METHOD,\n+        SCHEME,\n+        AUTHORITY,\n+        PATH\n+    }\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 9
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1418a21913799bea6a754e929bcce66e89812e13",
            "date": "2024-12-09T11:48:22Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a5c91142e361a4b2440d858fbe267b9dc6fde226",
            "date": "2024-11-12T16:07:29Z",
            "author_login": "normanmaurer"
          },
          {
            "sha": "0b272ee14eb4bb9260425e5a243cdd60f8451d0b",
            "date": "2024-11-11T15:20:50Z",
            "author_login": "normanmaurer"
          },
          {
            "sha": "67b75ca59c2b6cb1152e7dbe1f841271831c08bf",
            "date": "2024-11-04T10:54:14Z",
            "author_login": "normanmaurer"
          },
          {
            "sha": "8e0ab9486af45b90f723f26c76b55cd2a72ec230",
            "date": "2024-11-01T10:36:08Z",
            "author_login": "normanmaurer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-20",
    "description": "The netty incubator codec.bhttp is a java language binary http parser. In affected versions the `BinaryHttpParser` class does not properly validate input values thus giving attackers almost complete control over the HTTP requests constructed from the parsed output. Attackers can abuse several issues individually to perform various injection attacks including HTTP request smuggling, desync attacks, HTTP header injections, request queue poisoning, caching attacks and Server Side Request Forgery (SSRF). Attacker could also combine several issues to create well-formed messages for other text-based protocols which may result in attacks beyond the HTTP protocol. The BinaryHttpParser class implements the readRequestHead method which performs most of the relevant parsing of the received request. The data structure prefixes values with a variable length integer value. The parsing code below first gets the lengths of the values from the prefixed variable length integer. After it has all of the lengths and calculates all of the indices, the parser casts the applicable slices of the ByteBuf to String. Finally, it passes these values into a new `DefaultBinaryHttpRequest` object where no further parsing or validation occurs. Method is partially validated while other values are not validated at all. Software that relies on netty to apply input validation for binary HTTP data may be vulnerable to various injection and protocol based attacks. This issue has been addressed in version 0.0.13.Final. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-07-18T23:15:02.000",
    "last_modified": "2024-11-21T09:31:25.017",
    "fix_date": "2024-07-18T20:04:46Z"
  },
  "references": [
    {
      "url": "https://github.com/netty/netty-incubator-codec-ohttp/commit/b687a0cf6ea1030232ea204d73bce82f2698e571",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/netty/netty-incubator-codec-ohttp/security/advisories/GHSA-q8f2-hxq5-cp4h",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/netty/netty-incubator-codec-ohttp/commit/b687a0cf6ea1030232ea204d73bce82f2698e571",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/netty/netty-incubator-codec-ohttp/security/advisories/GHSA-q8f2-hxq5-cp4h",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.494808",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "netty-incubator-codec-ohttp",
    "owner": "netty",
    "created_at": "2023-12-06T09:14:09Z",
    "updated_at": "2024-12-27T21:54:01Z",
    "pushed_at": "2024-12-09T11:48:28Z",
    "size": 539,
    "stars": 3,
    "forks": 3,
    "open_issues": 0,
    "watchers": 3,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Java": 373478,
      "C": 28860,
      "Shell": 1837,
      "Ruby": 125
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T17:02:24.848213"
  }
}