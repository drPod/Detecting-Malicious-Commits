{
  "cve_id": "CVE-2024-40648",
  "github_data": {
    "repository": "matrix-org/matrix-rust-sdk",
    "fix_commit": "76a7052149bb8f722df12da915b3a06d19a6695a",
    "related_commits": [
      "76a7052149bb8f722df12da915b3a06d19a6695a",
      "76a7052149bb8f722df12da915b3a06d19a6695a"
    ],
    "patch_url": "https://github.com/matrix-org/matrix-rust-sdk/commit/76a7052149bb8f722df12da915b3a06d19a6695a.patch",
    "fix_commit_details": {
      "sha": "76a7052149bb8f722df12da915b3a06d19a6695a",
      "commit_date": "2024-07-16T14:02:39Z",
      "author": {
        "login": "poljar",
        "type": "User",
        "stats": {
          "total_commits": 2425,
          "average_weekly_commits": 8.85036496350365,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 223
        }
      },
      "commit_message": {
        "title": "crypto: Fix UserIdentity::is_verified to take into account our own identity",
        "length": 601,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 99,
        "additions": 94,
        "deletions": 5
      },
      "files": [
        {
          "filename": "crates/matrix-sdk-crypto/src/identities/user.rs",
          "status": "modified",
          "additions": 92,
          "deletions": 3,
          "patch": "@@ -227,7 +227,11 @@ impl Deref for UserIdentity {\n impl UserIdentity {\n     /// Is this user identity verified.\n     pub fn is_verified(&self) -> bool {\n-        self.own_identity.as_ref().is_some_and(|o| o.is_identity_signed(&self.inner).is_ok())\n+        self.own_identity.as_ref().is_some_and(|own_identity| {\n+            // The identity of another user is verified iff our own identity is verified and\n+            // if our own identity has signed the other user's identity.\n+            own_identity.is_verified() && own_identity.is_identity_signed(&self.inner).is_ok()\n+        })\n     }\n \n     /// Manually verify this user.\n@@ -789,7 +793,7 @@ pub(crate) mod tests {\n \n     use assert_matches::assert_matches;\n     use matrix_sdk_test::async_test;\n-    use ruma::{device_id, user_id};\n+    use ruma::{device_id, user_id, UserId};\n     use serde_json::{json, Value};\n     use tokio::sync::Mutex;\n \n@@ -799,10 +803,15 @@ pub(crate) mod tests {\n     };\n     use crate::{\n         identities::{manager::testing::own_key_query, Device},\n+        machine::tests::{\n+            get_machine_pair, mark_alice_identity_as_verified_test_helper,\n+            setup_cross_signing_for_machine_test_helper,\n+        },\n         olm::{Account, PrivateCrossSigningIdentity},\n-        store::{CryptoStoreWrapper, MemoryStore},\n+        store::{Changes, CryptoStoreWrapper, MemoryStore},\n         types::{CrossSigningKey, MasterPubkey, SelfSigningPubkey, Signatures, UserSigningPubkey},\n         verification::VerificationMachine,\n+        OlmMachine,\n     };\n \n     #[test]\n@@ -1017,4 +1026,84 @@ pub(crate) mod tests {\n             [second_device_id]\n         );\n     }\n+\n+    async fn get_machine_pair_with_signed_identities(\n+        alice: &UserId,\n+        bob: &UserId,\n+    ) -> (OlmMachine, OlmMachine) {\n+        let (alice, bob, _) = get_machine_pair(alice, bob, false).await;\n+        setup_cross_signing_for_machine_test_helper(&alice, &bob).await;\n+        mark_alice_identity_as_verified_test_helper(&alice, &bob).await;\n+\n+        (alice, bob)\n+    }\n+\n+    #[async_test]\n+    async fn test_other_user_is_verified_if_my_identity_is_verified_and_they_are_cross_signed() {\n+        let alice_user_id = user_id!(\"@alice:localhost\");\n+        let bob_user_id = user_id!(\"@bob:localhost\");\n+        let (alice, bob) =\n+            get_machine_pair_with_signed_identities(alice_user_id, bob_user_id).await;\n+\n+        let bobs_own_identity =\n+            bob.get_identity(bob.user_id(), None).await.unwrap().unwrap().own().unwrap();\n+        let bobs_alice_identity =\n+            bob.get_identity(alice.user_id(), None).await.unwrap().unwrap().other().unwrap();\n+\n+        assert!(bobs_own_identity.is_verified(), \"Bob's identity should be verified.\");\n+        assert!(bobs_alice_identity.is_verified(), \"Alice's identity should be verified as well.\");\n+    }\n+\n+    #[async_test]\n+    async fn test_other_user_is_not_verified_if_they_are_not_cross_signed() {\n+        let alice_user_id = user_id!(\"@alice:localhost\");\n+        let bob_user_id = user_id!(\"@bob:localhost\");\n+        let (alice, bob, _) = get_machine_pair(alice_user_id, bob_user_id, false).await;\n+        setup_cross_signing_for_machine_test_helper(&alice, &bob).await;\n+\n+        let bobs_own_identity =\n+            bob.get_identity(bob.user_id(), None).await.unwrap().unwrap().own().unwrap();\n+        let bobs_alice_identity =\n+            bob.get_identity(alice.user_id(), None).await.unwrap().unwrap().other().unwrap();\n+\n+        assert!(bobs_own_identity.is_verified(), \"Bob's identity should be verified.\");\n+        assert!(!bobs_alice_identity.is_verified(), \"Alice's identity should not be considered verified since Bob has not signed it.\");\n+    }\n+\n+    #[async_test]\n+    async fn test_other_user_is_not_verified_if_my_identity_is_not_verified() {\n+        let alice_user_id = user_id!(\"@alice:localhost\");\n+        let bob_user_id = user_id!(\"@bob:localhost\");\n+\n+        let (alice, bob, _) = get_machine_pair(alice_user_id, bob_user_id, false).await;\n+        setup_cross_signing_for_machine_test_helper(&alice, &bob).await;\n+        mark_alice_identity_as_verified_test_helper(&alice, &bob).await;\n+\n+        let bobs_own_identity =\n+            bob.get_identity(bob.user_id(), None).await.unwrap().unwrap().own().unwrap();\n+        let bobs_alice_identity =\n+            bob.get_identity(alice.user_id(), None).await.unwrap().unwrap().other().unwrap();\n+\n+        assert!(bobs_own_identity.is_verified(), \"Bob's identity should be verified.\");\n+        assert!(bobs_alice_identity.is_verified(), \"Alice's identity should be verified as well.\");\n+\n+        bobs_own_identity.mark_as_unverified();\n+\n+        bob.store()\n+            .save_changes(Changes {\n+                identities: crate::store::IdentityChanges {\n+                    changed: vec![bobs_own_identity.inner.clone().into()],\n+                    ..Default::default()\n+                },\n+                ..Default::default()\n+            })\n+            .await\n+            .unwrap();\n+\n+        assert!(!bobs_own_identity.is_verified(), \"Bob's identity should not be verified anymore.\");\n+        assert!(\n+            !bobs_alice_identity.is_verified(),\n+            \"Alice's identity should not be verified either.\"\n+        );\n+    }\n }"
        },
        {
          "filename": "crates/matrix-sdk-crypto/src/machine.rs",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -3514,7 +3514,7 @@ pub(crate) mod tests {\n         );\n     }\n \n-    async fn setup_cross_signing_for_machine_test_helper(alice: &OlmMachine, bob: &OlmMachine) {\n+    pub async fn setup_cross_signing_for_machine_test_helper(alice: &OlmMachine, bob: &OlmMachine) {\n         let CrossSigningBootstrapRequests { upload_signing_keys_req: alice_upload_signing, .. } =\n             alice.bootstrap_cross_signing(false).await.expect(\"Expect Alice x-signing key request\");\n \n@@ -3635,7 +3635,7 @@ pub(crate) mod tests {\n         bob.receive_keys_query_response(&TransactionId::new(), &kq_response).await.unwrap();\n     }\n \n-    async fn mark_alice_identity_as_verified_test_helper(alice: &OlmMachine, bob: &OlmMachine) {\n+    pub async fn mark_alice_identity_as_verified_test_helper(alice: &OlmMachine, bob: &OlmMachine) {\n         let alice_device =\n             bob.get_device(alice.user_id(), alice.device_id(), None).await.unwrap().unwrap();\n "
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bd5d7aafee3cac797e709eadc2f914438211a526",
            "date": "2025-01-10T12:20:10Z",
            "author_login": "jmartinesp"
          },
          {
            "sha": "e015a531da018e6dece8be1e5369392c743475d9",
            "date": "2025-01-10T12:19:58Z",
            "author_login": "jmartinesp"
          },
          {
            "sha": "b9014a5e2a20b0c58cd5b8d0cf0f283c44498142",
            "date": "2025-01-14T10:15:08Z",
            "author_login": "bnjbvr"
          },
          {
            "sha": "e9487b085125d3cd2057c8258a5a1a2c25edc4eb",
            "date": "2025-01-13T16:32:07Z",
            "author_login": "jmartinesp"
          },
          {
            "sha": "c60bfb877af9f5aa34eac20725e50f857d640a8e",
            "date": "2025-01-13T16:16:37Z",
            "author_login": "poljar"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N",
    "cwe_id": "CWE-287",
    "description": "matrix-rust-sdk is an implementation of a Matrix client-server library in Rust. The `UserIdentity::is_verified()` method in the matrix-sdk-crypto crate before version 0.7.2 doesn't take into account the verification status of the user's own identity while performing the check and may as a result return a value contrary to what is implied by its name and documentation. If the method is used to decide whether to perform sensitive operations towards a user identity, a malicious homeserver could manipulate the outcome in order to make the identity appear trusted. This is not a typical usage of the method, which lowers the impact. The method itself is not used inside the `matrix-sdk-crypto` crate. The 0.7.2 release of the `matrix-sdk-crypto` crate includes a fix. All users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-18T17:15:05.427",
    "last_modified": "2024-11-21T09:31:25.720",
    "fix_date": "2024-07-16T14:02:39Z"
  },
  "references": [
    {
      "url": "https://github.com/matrix-org/matrix-rust-sdk/commit/76a7052149bb8f722df12da915b3a06d19a6695a",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/matrix-rust-sdk/security/advisories/GHSA-4qg4-cvh2-crgg",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/matrix-rust-sdk/commit/76a7052149bb8f722df12da915b3a06d19a6695a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/matrix-org/matrix-rust-sdk/security/advisories/GHSA-4qg4-cvh2-crgg",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.494371",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "matrix-rust-sdk",
    "owner": "matrix-org",
    "created_at": "2020-02-21T15:47:16Z",
    "updated_at": "2025-01-14T15:23:56Z",
    "pushed_at": "2025-01-14T16:44:52Z",
    "size": 59856,
    "stars": 1304,
    "forks": 267,
    "open_issues": 221,
    "watchers": 1304,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 9387606,
      "Shell": 5632,
      "Swift": 3872,
      "Python": 2588,
      "Ruby": 2075,
      "Perl": 782,
      "Makefile": 288,
      "Dockerfile": 125
    },
    "commit_activity": {
      "total_commits_last_year": 2761,
      "avg_commits_per_week": 53.09615384615385,
      "days_active_last_year": 272
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T20:52:29.886936"
  }
}