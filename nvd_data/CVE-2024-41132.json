{
  "cve_id": "CVE-2024-41132",
  "github_data": {
    "repository": "SixLabors/ImageSharp",
    "fix_commit": "59de13c8cc47f2b402e2c43aa7024511d029d515",
    "related_commits": [
      "59de13c8cc47f2b402e2c43aa7024511d029d515",
      "9816ca45016c5d3859986f3c600e8934bc450a56",
      "b496109051cc39feee1f6cde48fca6481de17f9a",
      "59de13c8cc47f2b402e2c43aa7024511d029d515",
      "9816ca45016c5d3859986f3c600e8934bc450a56",
      "b496109051cc39feee1f6cde48fca6481de17f9a"
    ],
    "patch_url": "https://github.com/SixLabors/ImageSharp/commit/59de13c8cc47f2b402e2c43aa7024511d029d515.patch",
    "fix_commit_details": {
      "sha": "59de13c8cc47f2b402e2c43aa7024511d029d515",
      "commit_date": "2024-07-07T06:40:08Z",
      "author": {
        "login": "JimBobSquarePants",
        "type": "User",
        "stats": {
          "total_commits": 8599,
          "average_weekly_commits": 13.02878787878788,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 514
        }
      },
      "commit_message": {
        "title": "Merge pull request #2764 from SixLabors/js/v4-merge-2758-fix",
        "length": 73,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 581,
        "additions": 295,
        "deletions": 286
      },
      "files": [
        {
          "filename": "src/ImageSharp/Formats/Gif/GifDecoderCore.cs",
          "status": "modified",
          "additions": 91,
          "deletions": 97,
          "patch": "@@ -427,68 +427,49 @@ private void ReadFrame<TPixel>(BufferedReadStream stream, ref Image<TPixel>? ima\n     {\n         this.ReadImageDescriptor(stream);\n \n-        Buffer2D<byte>? indices = null;\n-        try\n-        {\n-            // Determine the color table for this frame. If there is a local one, use it otherwise use the global color table.\n-            bool hasLocalColorTable = this.imageDescriptor.LocalColorTableFlag;\n-\n-            if (hasLocalColorTable)\n-            {\n-                // Read and store the local color table. We allocate the maximum possible size and slice to match.\n-                int length = this.currentLocalColorTableSize = this.imageDescriptor.LocalColorTableSize * 3;\n-                this.currentLocalColorTable ??= this.configuration.MemoryAllocator.Allocate<byte>(768, AllocationOptions.Clean);\n-                stream.Read(this.currentLocalColorTable.GetSpan()[..length]);\n-            }\n-\n-            indices = this.configuration.MemoryAllocator.Allocate2D<byte>(this.imageDescriptor.Width, this.imageDescriptor.Height, AllocationOptions.Clean);\n-            this.ReadFrameIndices(stream, indices);\n+        // Determine the color table for this frame. If there is a local one, use it otherwise use the global color table.\n+        bool hasLocalColorTable = this.imageDescriptor.LocalColorTableFlag;\n \n-            Span<byte> rawColorTable = default;\n-            if (hasLocalColorTable)\n-            {\n-                rawColorTable = this.currentLocalColorTable!.GetSpan()[..this.currentLocalColorTableSize];\n-            }\n-            else if (this.globalColorTable != null)\n-            {\n-                rawColorTable = this.globalColorTable.GetSpan();\n-            }\n-\n-            ReadOnlySpan<Rgb24> colorTable = MemoryMarshal.Cast<byte, Rgb24>(rawColorTable);\n-            this.ReadFrameColors(ref image, ref previousFrame, indices, colorTable, this.imageDescriptor);\n+        if (hasLocalColorTable)\n+        {\n+            // Read and store the local color table. We allocate the maximum possible size and slice to match.\n+            int length = this.currentLocalColorTableSize = this.imageDescriptor.LocalColorTableSize * 3;\n+            this.currentLocalColorTable ??= this.configuration.MemoryAllocator.Allocate<byte>(768, AllocationOptions.Clean);\n+            stream.Read(this.currentLocalColorTable.GetSpan()[..length]);\n+        }\n \n-            // Skip any remaining blocks\n-            SkipBlock(stream);\n+        Span<byte> rawColorTable = default;\n+        if (hasLocalColorTable)\n+        {\n+            rawColorTable = this.currentLocalColorTable!.GetSpan()[..this.currentLocalColorTableSize];\n         }\n-        finally\n+        else if (this.globalColorTable != null)\n         {\n-            indices?.Dispose();\n+            rawColorTable = this.globalColorTable.GetSpan();\n         }\n-    }\n \n-    /// <summary>\n-    /// Reads the frame indices marking the color to use for each pixel.\n-    /// </summary>\n-    /// <param name=\"stream\">The <see cref=\"BufferedReadStream\"/> containing image data.</param>\n-    /// <param name=\"indices\">The 2D pixel buffer to write to.</param>\n-    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n-    private void ReadFrameIndices(BufferedReadStream stream, Buffer2D<byte> indices)\n-    {\n-        int minCodeSize = stream.ReadByte();\n-        using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream);\n-        lzwDecoder.DecodePixels(minCodeSize, indices);\n+        ReadOnlySpan<Rgb24> colorTable = MemoryMarshal.Cast<byte, Rgb24>(rawColorTable);\n+        this.ReadFrameColors(stream, ref image, ref previousFrame, colorTable, this.imageDescriptor);\n+\n+        // Skip any remaining blocks\n+        SkipBlock(stream);\n     }\n \n     /// <summary>\n     /// Reads the frames colors, mapping indices to colors.\n     /// </summary>\n     /// <typeparam name=\"TPixel\">The pixel format.</typeparam>\n+    /// <param name=\"stream\">The <see cref=\"BufferedReadStream\"/> containing image data.</param>\n     /// <param name=\"image\">The image to decode the information to.</param>\n     /// <param name=\"previousFrame\">The previous frame.</param>\n-    /// <param name=\"indices\">The indexed pixels.</param>\n     /// <param name=\"colorTable\">The color table containing the available colors.</param>\n     /// <param name=\"descriptor\">The <see cref=\"GifImageDescriptor\"/></param>\n-    private void ReadFrameColors<TPixel>(ref Image<TPixel>? image, ref ImageFrame<TPixel>? previousFrame, Buffer2D<byte> indices, ReadOnlySpan<Rgb24> colorTable, in GifImageDescriptor descriptor)\n+    private void ReadFrameColors<TPixel>(\n+        BufferedReadStream stream,\n+        ref Image<TPixel>? image,\n+        ref ImageFrame<TPixel>? previousFrame,\n+        ReadOnlySpan<Rgb24> colorTable,\n+        in GifImageDescriptor descriptor)\n         where TPixel : unmanaged, IPixel<TPixel>\n     {\n         int imageWidth = this.logicalScreenDescriptor.Width;\n@@ -549,69 +530,79 @@ private void ReadFrameColors<TPixel>(ref Image<TPixel>? image, ref ImageFrame<TP\n         byte transIndex = this.graphicsControlExtension.TransparencyIndex;\n         int colorTableMaxIdx = colorTable.Length - 1;\n \n-        for (int y = descriptorTop; y < descriptorBottom && y < imageHeight; y++)\n+        // For a properly encoded gif the descriptor dimensions will never exceed the logical screen dimensions.\n+        // However we have images that exceed this that can be decoded by other libraries. #1530\n+        using IMemoryOwner<byte> indicesRowOwner = this.memoryAllocator.Allocate<byte>(descriptor.Width);\n+        Span<byte> indicesRow = indicesRowOwner.Memory.Span;\n+        ref byte indicesRowRef = ref MemoryMarshal.GetReference(indicesRow);\n+\n+        int minCodeSize = stream.ReadByte();\n+        if (LzwDecoder.IsValidMinCodeSize(minCodeSize))\n         {\n-            ref byte indicesRowRef = ref MemoryMarshal.GetReference(indices.DangerousGetRowSpan(y - descriptorTop));\n+            using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream, minCodeSize);\n \n-            // Check if this image is interlaced.\n-            int writeY; // the target y offset to write to\n-            if (descriptor.InterlaceFlag)\n+            for (int y = descriptorTop; y < descriptorBottom && y < imageHeight; y++)\n             {\n-                // If so then we read lines at predetermined offsets.\n-                // When an entire image height worth of offset lines has been read we consider this a pass.\n-                // With each pass the number of offset lines changes and the starting line changes.\n-                if (interlaceY >= descriptor.Height)\n+                // Check if this image is interlaced.\n+                int writeY; // the target y offset to write to\n+                if (descriptor.InterlaceFlag)\n                 {\n-                    interlacePass++;\n-                    switch (interlacePass)\n+                    // If so then we read lines at predetermined offsets.\n+                    // When an entire image height worth of offset lines has been read we consider this a pass.\n+                    // With each pass the number of offset lines changes and the starting line changes.\n+                    if (interlaceY >= descriptor.Height)\n                     {\n-                        case 1:\n-                            interlaceY = 4;\n-                            break;\n-                        case 2:\n-                            interlaceY = 2;\n-                            interlaceIncrement = 4;\n-                            break;\n-                        case 3:\n-                            interlaceY = 1;\n-                            interlaceIncrement = 2;\n-                            break;\n+                        interlacePass++;\n+                        switch (interlacePass)\n+                        {\n+                            case 1:\n+                                interlaceY = 4;\n+                                break;\n+                            case 2:\n+                                interlaceY = 2;\n+                                interlaceIncrement = 4;\n+                                break;\n+                            case 3:\n+                                interlaceY = 1;\n+                                interlaceIncrement = 2;\n+                                break;\n+                        }\n                     }\n-                }\n \n-                writeY = interlaceY + descriptor.Top;\n-                interlaceY += interlaceIncrement;\n-            }\n-            else\n-            {\n-                writeY = y;\n-            }\n+                    writeY = Math.Min(interlaceY + descriptor.Top, image.Height);\n+                    interlaceY += interlaceIncrement;\n+                }\n+                else\n+                {\n+                    writeY = y;\n+                }\n \n-            ref TPixel rowRef = ref MemoryMarshal.GetReference(imageFrame.PixelBuffer.DangerousGetRowSpan(writeY));\n+                lzwDecoder.DecodePixelRow(indicesRow);\n+                ref TPixel rowRef = ref MemoryMarshal.GetReference(imageFrame.PixelBuffer.DangerousGetRowSpan(writeY));\n \n-            if (!transFlag)\n-            {\n-                // #403 The left + width value can be larger than the image width\n-                for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)\n+                if (!transFlag)\n                 {\n-                    int index = Numerics.Clamp(Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft)), 0, colorTableMaxIdx);\n-                    Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);\n+                    // #403 The left + width value can be larger than the image width\n+                    for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)\n+                    {\n+                        int index = Numerics.Clamp(Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft)), 0, colorTableMaxIdx);\n+                        Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);\n+                    }\n                 }\n-            }\n-            else\n-            {\n-                for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)\n+                else\n                 {\n-                    int rawIndex = Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft));\n-\n-                    // Treat any out of bounds values as transparent.\n-                    if (rawIndex > colorTableMaxIdx || rawIndex == transIndex)\n+                    for (int x = descriptorLeft; x < descriptorRight && x < imageWidth; x++)\n                     {\n-                        continue;\n-                    }\n+                        int index = Unsafe.Add(ref indicesRowRef, (uint)(x - descriptorLeft));\n+\n+                        // Treat any out of bounds values as transparent.\n+                        if (index > colorTableMaxIdx || index == transIndex)\n+                        {\n+                            continue;\n+                        }\n \n-                    int index = Numerics.Clamp(rawIndex, 0, colorTableMaxIdx);\n-                    Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);\n+                        Unsafe.Add(ref rowRef, (uint)x) = TPixel.FromRgb24(colorTable[index]);\n+                    }\n                 }\n             }\n         }\n@@ -652,8 +643,11 @@ private void ReadFrameMetadata(BufferedReadStream stream, List<ImageFrameMetadat\n         // Skip the frame indices. Pixels length + mincode size.\n         // The gif format does not tell us the length of the compressed data beforehand.\n         int minCodeSize = stream.ReadByte();\n-        using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream);\n-        lzwDecoder.SkipIndices(minCodeSize, this.imageDescriptor.Width * this.imageDescriptor.Height);\n+        if (LzwDecoder.IsValidMinCodeSize(minCodeSize))\n+        {\n+            using LzwDecoder lzwDecoder = new(this.configuration.MemoryAllocator, stream, minCodeSize);\n+            lzwDecoder.SkipIndices(this.imageDescriptor.Width * this.imageDescriptor.Height);\n+        }\n \n         ImageFrameMetadata currentFrame = new();\n         frameMetadata.Add(currentFrame);"
        },
        {
          "filename": "src/ImageSharp/Formats/Gif/LzwDecoder.cs",
          "status": "modified",
          "additions": 146,
          "deletions": 184,
          "patch": "@@ -44,346 +44,307 @@ internal sealed class LzwDecoder : IDisposable\n     /// </summary>\n     private readonly IMemoryOwner<int> suffix;\n \n+    /// <summary>\n+    /// The scratch buffer for reading data blocks.\n+    /// </summary>\n+    private readonly IMemoryOwner<byte> scratchBuffer;\n+\n     /// <summary>\n     /// The pixel stack buffer.\n     /// </summary>\n     private readonly IMemoryOwner<int> pixelStack;\n+    private readonly int minCodeSize;\n+    private readonly int clearCode;\n+    private readonly int endCode;\n+    private int code;\n+    private int codeSize;\n+    private int codeMask;\n+    private int availableCode;\n+    private int oldCode = NullCode;\n+    private int bits;\n+    private int top;\n+    private int count;\n+    private int bufferIndex;\n+    private int data;\n+    private int first;\n \n     /// <summary>\n     /// Initializes a new instance of the <see cref=\"LzwDecoder\"/> class\n     /// and sets the stream, where the compressed data should be read from.\n     /// </summary>\n     /// <param name=\"memoryAllocator\">The <see cref=\"MemoryAllocator\"/> to use for buffer allocations.</param>\n     /// <param name=\"stream\">The stream to read from.</param>\n+    /// <param name=\"minCodeSize\">The minimum code size.</param>\n     /// <exception cref=\"ArgumentNullException\"><paramref name=\"stream\"/> is null.</exception>\n-    public LzwDecoder(MemoryAllocator memoryAllocator, BufferedReadStream stream)\n+    public LzwDecoder(MemoryAllocator memoryAllocator, BufferedReadStream stream, int minCodeSize)\n     {\n         this.stream = stream ?? throw new ArgumentNullException(nameof(stream));\n \n         this.prefix = memoryAllocator.Allocate<int>(MaxStackSize, AllocationOptions.Clean);\n         this.suffix = memoryAllocator.Allocate<int>(MaxStackSize, AllocationOptions.Clean);\n         this.pixelStack = memoryAllocator.Allocate<int>(MaxStackSize + 1, AllocationOptions.Clean);\n+        this.scratchBuffer = memoryAllocator.Allocate<byte>(byte.MaxValue, AllocationOptions.None);\n+        this.minCodeSize = minCodeSize;\n+\n+        // Calculate the clear code. The value of the clear code is 2 ^ minCodeSize\n+        this.clearCode = 1 << minCodeSize;\n+        this.codeSize = minCodeSize + 1;\n+        this.codeMask = (1 << this.codeSize) - 1;\n+        this.endCode = this.clearCode + 1;\n+        this.availableCode = this.clearCode + 2;\n+\n+        ref int suffixRef = ref MemoryMarshal.GetReference(this.suffix.GetSpan());\n+        for (this.code = 0; this.code < this.clearCode; this.code++)\n+        {\n+            Unsafe.Add(ref suffixRef, (uint)this.code) = (byte)this.code;\n+        }\n     }\n \n     /// <summary>\n-    /// Decodes and decompresses all pixel indices from the stream, assigning the pixel values to the buffer.\n+    /// Gets a value indicating whether the minimum code size is valid.\n     /// </summary>\n-    /// <param name=\"minCodeSize\">Minimum code size of the data.</param>\n-    /// <param name=\"pixels\">The pixel array to decode to.</param>\n-    public void DecodePixels(int minCodeSize, Buffer2D<byte> pixels)\n+    /// <param name=\"minCodeSize\">The minimum code size.</param>\n+    /// <returns>\n+    /// <see langword=\"true\"/> if the minimum code size is valid; otherwise, <see langword=\"false\"/>.\n+    /// </returns>\n+    public static bool IsValidMinCodeSize(int minCodeSize)\n     {\n-        // Calculate the clear code. The value of the clear code is 2 ^ minCodeSize\n-        int clearCode = 1 << minCodeSize;\n-\n         // It is possible to specify a larger LZW minimum code size than the palette length in bits\n         // which may leave a gap in the codes where no colors are assigned.\n         // http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp#lzw_compression\n+        int clearCode = 1 << minCodeSize;\n         if (minCodeSize < 2 || minCodeSize > MaximumLzwBits || clearCode > MaxStackSize)\n         {\n             // Don't attempt to decode the frame indices.\n             // Theoretically we could determine a min code size from the length of the provided\n             // color palette but we won't bother since the image is most likely corrupted.\n-            return;\n+            return false;\n         }\n \n-        // The resulting index table length.\n-        int width = pixels.Width;\n-        int height = pixels.Height;\n-        int length = width * height;\n-\n-        int codeSize = minCodeSize + 1;\n-\n-        // Calculate the end code\n-        int endCode = clearCode + 1;\n-\n-        // Calculate the available code.\n-        int availableCode = clearCode + 2;\n-\n-        // Jillzhangs Code see: http://giflib.codeplex.com/\n-        // Adapted from John Cristy's ImageMagick.\n-        int code;\n-        int oldCode = NullCode;\n-        int codeMask = (1 << codeSize) - 1;\n-        int bits = 0;\n-\n-        int top = 0;\n-        int count = 0;\n-        int bi = 0;\n-        int xyz = 0;\n+        return true;\n+    }\n \n-        int data = 0;\n-        int first = 0;\n+    /// <summary>\n+    /// Decodes and decompresses all pixel indices for a single row from the stream, assigning the pixel values to the buffer.\n+    /// </summary>\n+    /// <param name=\"indices\">The pixel indices array to decode to.</param>\n+    public void DecodePixelRow(Span<byte> indices)\n+    {\n+        indices.Clear();\n \n+        ref byte pixelsRowRef = ref MemoryMarshal.GetReference(indices);\n         ref int prefixRef = ref MemoryMarshal.GetReference(this.prefix.GetSpan());\n         ref int suffixRef = ref MemoryMarshal.GetReference(this.suffix.GetSpan());\n         ref int pixelStackRef = ref MemoryMarshal.GetReference(this.pixelStack.GetSpan());\n+        Span<byte> buffer = this.scratchBuffer.GetSpan();\n \n-        for (code = 0; code < clearCode; code++)\n-        {\n-            Unsafe.Add(ref suffixRef, (uint)code) = (byte)code;\n-        }\n-\n-        Span<byte> buffer = stackalloc byte[byte.MaxValue];\n-\n-        int y = 0;\n         int x = 0;\n-        int rowMax = width;\n-        ref byte pixelsRowRef = ref MemoryMarshal.GetReference(pixels.DangerousGetRowSpan(y));\n-        while (xyz < length)\n+        int xyz = 0;\n+        while (xyz < indices.Length)\n         {\n-            // Reset row reference.\n-            if (xyz == rowMax)\n-            {\n-                x = 0;\n-                pixelsRowRef = ref MemoryMarshal.GetReference(pixels.DangerousGetRowSpan(++y));\n-                rowMax = (y * width) + width;\n-            }\n-\n-            if (top == 0)\n+            if (this.top == 0)\n             {\n-                if (bits < codeSize)\n+                if (this.bits < this.codeSize)\n                 {\n                     // Load bytes until there are enough bits for a code.\n-                    if (count == 0)\n+                    if (this.count == 0)\n                     {\n                         // Read a new data block.\n-                        count = this.ReadBlock(buffer);\n-                        if (count == 0)\n+                        this.count = this.ReadBlock(buffer);\n+                        if (this.count == 0)\n                         {\n                             break;\n                         }\n \n-                        bi = 0;\n+                        this.bufferIndex = 0;\n                     }\n \n-                    data += buffer[bi] << bits;\n+                    this.data += buffer[this.bufferIndex] << this.bits;\n \n-                    bits += 8;\n-                    bi++;\n-                    count--;\n+                    this.bits += 8;\n+                    this.bufferIndex++;\n+                    this.count--;\n                     continue;\n                 }\n \n                 // Get the next code\n-                code = data & codeMask;\n-                data >>= codeSize;\n-                bits -= codeSize;\n+                this.code = this.data & this.codeMask;\n+                this.data >>= this.codeSize;\n+                this.bits -= this.codeSize;\n \n                 // Interpret the code\n-                if (code > availableCode || code == endCode)\n+                if (this.code > this.availableCode || this.code == this.endCode)\n                 {\n                     break;\n                 }\n \n-                if (code == clearCode)\n+                if (this.code == this.clearCode)\n                 {\n                     // Reset the decoder\n-                    codeSize = minCodeSize + 1;\n-                    codeMask = (1 << codeSize) - 1;\n-                    availableCode = clearCode + 2;\n-                    oldCode = NullCode;\n+                    this.codeSize = this.minCodeSize + 1;\n+                    this.codeMask = (1 << this.codeSize) - 1;\n+                    this.availableCode = this.clearCode + 2;\n+                    this.oldCode = NullCode;\n                     continue;\n                 }\n \n-                if (oldCode == NullCode)\n+                if (this.oldCode == NullCode)\n                 {\n-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);\n-                    oldCode = code;\n-                    first = code;\n+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);\n+                    this.oldCode = this.code;\n+                    this.first = this.code;\n                     continue;\n                 }\n \n-                int inCode = code;\n-                if (code == availableCode)\n+                int inCode = this.code;\n+                if (this.code == this.availableCode)\n                 {\n-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = (byte)first;\n+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = (byte)this.first;\n \n-                    code = oldCode;\n+                    this.code = this.oldCode;\n                 }\n \n-                while (code > clearCode)\n+                while (this.code > this.clearCode)\n                 {\n-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);\n-                    code = Unsafe.Add(ref prefixRef, (uint)code);\n+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);\n+                    this.code = Unsafe.Add(ref prefixRef, (uint)this.code);\n                 }\n \n-                int suffixCode = Unsafe.Add(ref suffixRef, (uint)code);\n-                first = suffixCode;\n-                Unsafe.Add(ref pixelStackRef, (uint)top++) = suffixCode;\n+                int suffixCode = Unsafe.Add(ref suffixRef, (uint)this.code);\n+                this.first = suffixCode;\n+                Unsafe.Add(ref pixelStackRef, (uint)this.top++) = suffixCode;\n \n                 // Fix for Gifs that have \"deferred clear code\" as per here :\n                 // https://bugzilla.mozilla.org/show_bug.cgi?id=55918\n-                if (availableCode < MaxStackSize)\n+                if (this.availableCode < MaxStackSize)\n                 {\n-                    Unsafe.Add(ref prefixRef, (uint)availableCode) = oldCode;\n-                    Unsafe.Add(ref suffixRef, (uint)availableCode) = first;\n-                    availableCode++;\n-                    if (availableCode == codeMask + 1 && availableCode < MaxStackSize)\n+                    Unsafe.Add(ref prefixRef, (uint)this.availableCode) = this.oldCode;\n+                    Unsafe.Add(ref suffixRef, (uint)this.availableCode) = this.first;\n+                    this.availableCode++;\n+                    if (this.availableCode == this.codeMask + 1 && this.availableCode < MaxStackSize)\n                     {\n-                        codeSize++;\n-                        codeMask = (1 << codeSize) - 1;\n+                        this.codeSize++;\n+                        this.codeMask = (1 << this.codeSize) - 1;\n                     }\n                 }\n \n-                oldCode = inCode;\n+                this.oldCode = inCode;\n             }\n \n             // Pop a pixel off the pixel stack.\n-            top--;\n+            this.top--;\n \n             // Clear missing pixels\n             xyz++;\n-            Unsafe.Add(ref pixelsRowRef, (uint)x++) = (byte)Unsafe.Add(ref pixelStackRef, (uint)top);\n+            Unsafe.Add(ref pixelsRowRef, (uint)x++) = (byte)Unsafe.Add(ref pixelStackRef, (uint)this.top);\n         }\n     }\n \n     /// <summary>\n     /// Decodes and decompresses all pixel indices from the stream allowing skipping of the data.\n     /// </summary>\n-    /// <param name=\"minCodeSize\">Minimum code size of the data.</param>\n     /// <param name=\"length\">The resulting index table length.</param>\n-    public void SkipIndices(int minCodeSize, int length)\n+    public void SkipIndices(int length)\n     {\n-        // Calculate the clear code. The value of the clear code is 2 ^ minCodeSize\n-        int clearCode = 1 << minCodeSize;\n-\n-        // It is possible to specify a larger LZW minimum code size than the palette length in bits\n-        // which may leave a gap in the codes where no colors are assigned.\n-        // http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp#lzw_compression\n-        if (minCodeSize < 2 || minCodeSize > MaximumLzwBits || clearCode > MaxStackSize)\n-        {\n-            // Don't attempt to decode the frame indices.\n-            // Theoretically we could determine a min code size from the length of the provided\n-            // color palette but we won't bother since the image is most likely corrupted.\n-            return;\n-        }\n-\n-        int codeSize = minCodeSize + 1;\n-\n-        // Calculate the end code\n-        int endCode = clearCode + 1;\n-\n-        // Calculate the available code.\n-        int availableCode = clearCode + 2;\n-\n-        // Jillzhangs Code see: http://giflib.codeplex.com/\n-        // Adapted from John Cristy's ImageMagick.\n-        int code;\n-        int oldCode = NullCode;\n-        int codeMask = (1 << codeSize) - 1;\n-        int bits = 0;\n-\n-        int top = 0;\n-        int count = 0;\n-        int bi = 0;\n-        int xyz = 0;\n-\n-        int data = 0;\n-        int first = 0;\n-\n         ref int prefixRef = ref MemoryMarshal.GetReference(this.prefix.GetSpan());\n         ref int suffixRef = ref MemoryMarshal.GetReference(this.suffix.GetSpan());\n         ref int pixelStackRef = ref MemoryMarshal.GetReference(this.pixelStack.GetSpan());\n+        Span<byte> buffer = this.scratchBuffer.GetSpan();\n \n-        for (code = 0; code < clearCode; code++)\n-        {\n-            Unsafe.Add(ref suffixRef, (uint)code) = (byte)code;\n-        }\n-\n-        Span<byte> buffer = stackalloc byte[byte.MaxValue];\n+        int xyz = 0;\n         while (xyz < length)\n         {\n-            if (top == 0)\n+            if (this.top == 0)\n             {\n-                if (bits < codeSize)\n+                if (this.bits < this.codeSize)\n                 {\n                     // Load bytes until there are enough bits for a code.\n-                    if (count == 0)\n+                    if (this.count == 0)\n                     {\n                         // Read a new data block.\n-                        count = this.ReadBlock(buffer);\n-                        if (count == 0)\n+                        this.count = this.ReadBlock(buffer);\n+                        if (this.count == 0)\n                         {\n                             break;\n                         }\n \n-                        bi = 0;\n+                        this.bufferIndex = 0;\n                     }\n \n-                    data += buffer[bi] << bits;\n+                    this.data += buffer[this.bufferIndex] << this.bits;\n \n-                    bits += 8;\n-                    bi++;\n-                    count--;\n+                    this.bits += 8;\n+                    this.bufferIndex++;\n+                    this.count--;\n                     continue;\n                 }\n \n                 // Get the next code\n-                code = data & codeMask;\n-                data >>= codeSize;\n-                bits -= codeSize;\n+                this.code = this.data & this.codeMask;\n+                this.data >>= this.codeSize;\n+                this.bits -= this.codeSize;\n \n                 // Interpret the code\n-                if (code > availableCode || code == endCode)\n+                if (this.code > this.availableCode || this.code == this.endCode)\n                 {\n                     break;\n                 }\n \n-                if (code == clearCode)\n+                if (this.code == this.clearCode)\n                 {\n                     // Reset the decoder\n-                    codeSize = minCodeSize + 1;\n-                    codeMask = (1 << codeSize) - 1;\n-                    availableCode = clearCode + 2;\n-                    oldCode = NullCode;\n+                    this.codeSize = this.minCodeSize + 1;\n+                    this.codeMask = (1 << this.codeSize) - 1;\n+                    this.availableCode = this.clearCode + 2;\n+                    this.oldCode = NullCode;\n                     continue;\n                 }\n \n-                if (oldCode == NullCode)\n+                if (this.oldCode == NullCode)\n                 {\n-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);\n-                    oldCode = code;\n-                    first = code;\n+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);\n+                    this.oldCode = this.code;\n+                    this.first = this.code;\n                     continue;\n                 }\n \n-                int inCode = code;\n-                if (code == availableCode)\n+                int inCode = this.code;\n+                if (this.code == this.availableCode)\n                 {\n-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = (byte)first;\n+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = (byte)this.first;\n \n-                    code = oldCode;\n+                    this.code = this.oldCode;\n                 }\n \n-                while (code > clearCode)\n+                while (this.code > this.clearCode)\n                 {\n-                    Unsafe.Add(ref pixelStackRef, (uint)top++) = Unsafe.Add(ref suffixRef, (uint)code);\n-                    code = Unsafe.Add(ref prefixRef, (uint)code);\n+                    Unsafe.Add(ref pixelStackRef, (uint)this.top++) = Unsafe.Add(ref suffixRef, (uint)this.code);\n+                    this.code = Unsafe.Add(ref prefixRef, (uint)this.code);\n                 }\n \n-                int suffixCode = Unsafe.Add(ref suffixRef, (uint)code);\n-                first = suffixCode;\n-                Unsafe.Add(ref pixelStackRef, (uint)top++) = suffixCode;\n+                int suffixCode = Unsafe.Add(ref suffixRef, (uint)this.code);\n+                this.first = suffixCode;\n+                Unsafe.Add(ref pixelStackRef, (uint)this.top++) = suffixCode;\n \n                 // Fix for Gifs that have \"deferred clear code\" as per here :\n                 // https://bugzilla.mozilla.org/show_bug.cgi?id=55918\n-                if (availableCode < MaxStackSize)\n+                if (this.availableCode < MaxStackSize)\n                 {\n-                    Unsafe.Add(ref prefixRef, (uint)availableCode) = oldCode;\n-                    Unsafe.Add(ref suffixRef, (uint)availableCode) = first;\n-                    availableCode++;\n-                    if (availableCode == codeMask + 1 && availableCode < MaxStackSize)\n+                    Unsafe.Add(ref prefixRef, (uint)this.availableCode) = this.oldCode;\n+                    Unsafe.Add(ref suffixRef, (uint)this.availableCode) = this.first;\n+                    this.availableCode++;\n+                    if (this.availableCode == this.codeMask + 1 && this.availableCode < MaxStackSize)\n                     {\n-                        codeSize++;\n-                        codeMask = (1 << codeSize) - 1;\n+                        this.codeSize++;\n+                        this.codeMask = (1 << this.codeSize) - 1;\n                     }\n                 }\n \n-                oldCode = inCode;\n+                this.oldCode = inCode;\n             }\n \n             // Pop a pixel off the pixel stack.\n-            top--;\n+            this.top--;\n \n             // Clear missing pixels\n             xyz++;\n@@ -419,5 +380,6 @@ public void Dispose()\n         this.prefix.Dispose();\n         this.suffix.Dispose();\n         this.pixelStack.Dispose();\n+        this.scratchBuffer.Dispose();\n     }\n }"
        },
        {
          "filename": "src/ImageSharp/Formats/Jpeg/Components/Quantization.cs",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -146,7 +146,7 @@ public static int EstimateQuality(ref Block8x8F table, ReadOnlySpan<byte> target\n             quality = (int)Math.Round(5000.0 / sumPercent);\n         }\n \n-        return quality;\n+        return Numerics.Clamp(quality, MinQualityFactor, MaxQualityFactor);\n     }\n \n     /// <summary>"
        },
        {
          "filename": "tests/ImageSharp.Tests/Formats/Gif/GifDecoderTests.cs",
          "status": "modified",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -204,6 +204,17 @@ public void Issue1530_BadDescriptorDimensions<TPixel>(TestImageProvider<TPixel>\n         image.CompareToReferenceOutputMultiFrame(provider, ImageComparer.Exact);\n     }\n \n+    // https://github.com/SixLabors/ImageSharp/issues/2758\n+    [Theory]\n+    [WithFile(TestImages.Gif.Issues.Issue2758, PixelTypes.Rgba32)]\n+    public void Issue2758_BadDescriptorDimensions<TPixel>(TestImageProvider<TPixel> provider)\n+        where TPixel : unmanaged, IPixel<TPixel>\n+    {\n+        using Image<TPixel> image = provider.GetImage();\n+        image.DebugSaveMultiFrame(provider);\n+        image.CompareToReferenceOutputMultiFrame(provider, ImageComparer.Exact);\n+    }\n+\n     // https://github.com/SixLabors/ImageSharp/issues/405\n     [Theory]\n     [WithFile(TestImages.Gif.Issues.BadAppExtLength, PixelTypes.Rgba32)]"
        },
        {
          "filename": "tests/ImageSharp.Tests/Formats/Jpg/JpegDecoderTests.Metadata.cs",
          "status": "modified",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -8,6 +8,7 @@\n using SixLabors.ImageSharp.Metadata.Profiles.Exif;\n using SixLabors.ImageSharp.Metadata.Profiles.Icc;\n using SixLabors.ImageSharp.PixelFormats;\n+using SixLabors.ImageSharp.Processing;\n using SixLabors.ImageSharp.Tests.TestUtilities;\n \n // ReSharper disable InconsistentNaming\n@@ -438,6 +439,33 @@ public void JpegDecoder_DecodeMetadataComment<TPixel>(TestImageProvider<TPixel>\n         Assert.Equal(expectedComment, metadata.Comments.ElementAtOrDefault(0).ToString());\n         image.DebugSave(provider);\n         image.CompareToOriginal(provider);\n+\n+    }\n+    \n+    // https://github.com/SixLabors/ImageSharp/issues/2758\n+    [Theory]\n+    [WithFile(TestImages.Jpeg.Issues.Issue2758, PixelTypes.L8)]\n+    public void Issue2758_DecodeWorks<TPixel>(TestImageProvider<TPixel> provider)\n+        where TPixel : unmanaged, IPixel<TPixel>\n+    {\n+        using Image<TPixel> image = provider.GetImage(JpegDecoder.Instance);\n+\n+        Assert.Equal(59787, image.Width);\n+        Assert.Equal(511, image.Height);\n+\n+        JpegMetadata meta = image.Metadata.GetJpegMetadata();\n+\n+        // Quality determination should be between 1-100.\n+        Assert.Equal(15, meta.LuminanceQuality);\n+        Assert.Equal(1, meta.ChrominanceQuality);\n+\n+        // We want to test the encoder to ensure the determined values can be encoded but not by encoding\n+        // the full size image as it would be too slow.\n+        // We will crop the image to a smaller size and then encode it.\n+        image.Mutate(x => x.Crop(new(0, 0, 100, 100)));\n+\n+        using MemoryStream ms = new();\n+        image.Save(ms, new JpegEncoder());\n     }\n \n     private static void VerifyEncodedStrings(ExifProfile exif)"
        },
        {
          "filename": "tests/ImageSharp.Tests/TestImages.cs",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -321,6 +321,7 @@ public static class Issues\n             public const string Issue2517 = \"Jpg/issues/issue2517-bad-d7.jpg\";\n             public const string Issue2067_CommentMarker = \"Jpg/issues/issue-2067-comment.jpg\";\n             public const string Issue2638 = \"Jpg/issues/Issue2638.jpg\";\n+            public const string Issue2758 = \"Jpg/issues/issue-2758.jpg\";\n \n             public static class Fuzz\n             {\n@@ -531,6 +532,7 @@ public static class Issues\n             public const string Issue2450_A = \"Gif/issues/issue_2450.gif\";\n             public const string Issue2450_B = \"Gif/issues/issue_2450_2.gif\";\n             public const string Issue2198 = \"Gif/issues/issue_2198.gif\";\n+            public const string Issue2758 = \"Gif/issues/issue_2758.gif\";\n         }\n \n         public static readonly string[] Animated ="
        },
        {
          "filename": "tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2012BadMinCode_Rgba32_issue2012_drona1.png",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,3 +1,3 @@\n version https://git-lfs.github.com/spec/v1\n-oid sha256:a3a24c066895fd3a76649da376485cbc1912d6a3ae15369575f523e66364b3b6\n-size 141563\n+oid sha256:588d055a93c7b4fdb62e8b77f3ae08753a9e8990151cb0523f5e761996189b70\n+size 142244"
        },
        {
          "filename": "tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/00.png",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:4f39b23217f1d095eeb8eed5ccea36be813c307a60ef4b1942e9f74028451c38\n+size 81944"
        },
        {
          "filename": "tests/Images/External/ReferenceOutput/GifDecoderTests/Issue2758_BadDescriptorDimensions_Rgba32_issue_2758.gif/01.png",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:4f39b23217f1d095eeb8eed5ccea36be813c307a60ef4b1942e9f74028451c38\n+size 81944"
        },
        {
          "filename": "tests/Images/External/ReferenceOutput/GifDecoderTests/IssueTooLargeLzwBits_Rgba32_issue_2743.gif/07.png",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,3 +1,3 @@\n version https://git-lfs.github.com/spec/v1\n-oid sha256:489642f0c81fd12e97007fe6feb11b0e93e351199a922ce038069a3782ad0722\n-size 135\n+oid sha256:5016a323018f09e292165ad5392d82dcbad5e79c2b6b93aff3322dffff80b309\n+size 126"
        },
        {
          "filename": "tests/Images/Input/Gif/issues/issue_2758.gif",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:13e9374181c7536d1d2ecb514753a5290c0ec06234ca079c6c8c8a832586b668\n+size 199"
        },
        {
          "filename": "tests/Images/Input/Jpg/issues/issue-2758.jpg",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:f32a238b57b7073f7442f8ae7efd6ba3ae4cda30d57e6666fb8a1eaa27108558\n+size 1412"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 9,
        "unique_directories": 10,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e08651bbf6a8108865b1b2605751faa5cfc44a06",
            "date": "2024-12-18T01:48:59Z",
            "author_login": "JimBobSquarePants"
          },
          {
            "sha": "b38146dfaa2d25ea7fa85847a4012c88caa902f9",
            "date": "2024-12-17T00:37:18Z",
            "author_login": "antonfirsov"
          },
          {
            "sha": "dee312df7e491a5d1448d97cddb06a32aab1ffde",
            "date": "2024-12-16T22:48:24Z",
            "author_login": "antonfirsov"
          },
          {
            "sha": "4be26452b9366b0a4fe67aab91cfcb360916c5ea",
            "date": "2024-12-11T02:34:20Z",
            "author_login": "JimBobSquarePants"
          },
          {
            "sha": "502a35426225e22ebff965ffaa2be31ecc286880",
            "date": "2024-11-27T12:21:39Z",
            "author_login": "JimBobSquarePants"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-789",
    "description": "ImageSharp is a 2D graphics API. A vulnerability discovered in the ImageSharp library, where the processing of specially crafted files can lead to excessive memory usage in the Gif decoder. The vulnerability is triggered when ImageSharp attempts to process image files that are designed to exploit this flaw. All users are advised to upgrade to v3.1.5 or v2.1.9.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-22T15:15:04.160",
    "last_modified": "2024-11-21T09:32:17.817",
    "fix_date": "2024-07-07T06:40:08Z"
  },
  "references": [
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp.web/processingcommands.html#securing-processing-commands",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp/security.html",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/59de13c8cc47f2b402e2c43aa7024511d029d515",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/9816ca45016c5d3859986f3c600e8934bc450a56",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/b496109051cc39feee1f6cde48fca6481de17f9a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/pull/2759",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/pull/2764",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/pull/2770",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/security/advisories/GHSA-qxrv-gp6x-rc23",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp.web/processingcommands.html#securing-processing-commands",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://docs.sixlabors.com/articles/imagesharp/security.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/59de13c8cc47f2b402e2c43aa7024511d029d515",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/9816ca45016c5d3859986f3c600e8934bc450a56",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/commit/b496109051cc39feee1f6cde48fca6481de17f9a",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/pull/2759",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/pull/2764",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/pull/2770",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/SixLabors/ImageSharp/security/advisories/GHSA-qxrv-gp6x-rc23",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.509493",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "ImageSharp",
    "owner": "SixLabors",
    "created_at": "2016-10-28T04:46:36Z",
    "updated_at": "2025-01-14T14:21:12Z",
    "pushed_at": "2025-01-06T10:46:24Z",
    "size": 132452,
    "stars": 7554,
    "forks": 853,
    "open_issues": 45,
    "watchers": 7554,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "C#": 10815585,
      "JavaScript": 40805,
      "HTML": 5210,
      "PowerShell": 5178,
      "Batchfile": 121
    },
    "commit_activity": {
      "total_commits_last_year": 390,
      "avg_commits_per_week": 7.5,
      "days_active_last_year": 121
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:51:16.290801"
  }
}