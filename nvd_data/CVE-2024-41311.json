{
  "cve_id": "CVE-2024-41311",
  "github_data": {
    "repository": "strukturag/libheif",
    "fix_commit": "a3ed1b1eb178c5d651d6ac619c8da3d71ac2be36",
    "related_commits": [
      "a3ed1b1eb178c5d651d6ac619c8da3d71ac2be36"
    ],
    "patch_url": "https://github.com/strukturag/libheif/commit/a3ed1b1eb178c5d651d6ac619c8da3d71ac2be36.patch",
    "fix_commit_details": {
      "sha": "a3ed1b1eb178c5d651d6ac619c8da3d71ac2be36",
      "commit_date": "2024-07-08T10:26:24Z",
      "author": {
        "login": "farindk",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "rewrite overlay image area intersection (#1226)",
        "length": 47,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 145,
        "additions": 81,
        "deletions": 64
      },
      "files": [
        {
          "filename": "libheif/context.cc",
          "status": "modified",
          "additions": 9,
          "deletions": 3,
          "patch": "@@ -326,9 +326,9 @@ Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n     std::stringstream sstr;\n     sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n \n-    return Error(heif_error_Unsupported_feature,\n-                 heif_suberror_Unsupported_data_version,\n-                 sstr.str());\n+    return {heif_error_Unsupported_feature,\n+            heif_suberror_Unsupported_data_version,\n+            sstr.str()};\n   }\n \n   int field_len = ((m_flags & 1) ? 4 : 2);\n@@ -346,6 +346,12 @@ Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n   m_width = readvec(data, ptr, field_len);\n   m_height = readvec(data, ptr, field_len);\n \n+  if (m_width==0 || m_height==0) {\n+    return {heif_error_Invalid_input,\n+            heif_suberror_Invalid_overlay_data,\n+            \"Overlay image with zero width or height.\"};\n+  }\n+\n   m_offsets.resize(num_images);\n \n   for (size_t i = 0; i < num_images; i++) {"
        },
        {
          "filename": "libheif/pixelimage.cc",
          "status": "modified",
          "additions": 71,
          "deletions": 60,
          "patch": "@@ -748,7 +748,20 @@ Error HeifPixelImage::fill_RGB_16bit(uint16_t r, uint16_t g, uint16_t b, uint16_\n }\n \n \n-Error HeifPixelImage::overlay(std::shared_ptr<HeifPixelImage>& overlay, int dx, int dy)\n+uint32_t negate_negative_int32(int32_t x)\n+{\n+  assert(x <= 0);\n+\n+  if (x == INT32_MIN) {\n+    return static_cast<uint32_t>(INT32_MAX) + 1;\n+  }\n+  else {\n+    return static_cast<uint32_t>(-x);\n+  }\n+}\n+\n+\n+Error HeifPixelImage::overlay(std::shared_ptr<HeifPixelImage>& overlay, int32_t dx, int32_t dy)\n {\n   std::set<enum heif_channel> channels = overlay->get_channel_set();\n \n@@ -773,90 +786,88 @@ Error HeifPixelImage::overlay(std::shared_ptr<HeifPixelImage>& overlay, int dx,\n     in_p = overlay->get_plane(channel, &in_stride);\n     out_p = get_plane(channel, &out_stride);\n \n-    int in_w = overlay->get_width(channel);\n-    int in_h = overlay->get_height(channel);\n-    assert(in_w >= 0);\n-    assert(in_h >= 0);\n+    uint32_t in_w = overlay->get_width(channel);\n+    uint32_t in_h = overlay->get_height(channel);\n \n-    int out_w = get_width(channel);\n-    int out_h = get_height(channel);\n-    assert(out_w >= 0);\n-    assert(out_h >= 0);\n+    uint32_t out_w = get_width(channel);\n+    uint32_t out_h = get_height(channel);\n \n-    // overlay image extends past the right border -> cut width for copy\n-    if (dx + in_w > out_w) {\n-      in_w = out_w - dx;\n-    }\n+    // top-left points where to start copying in source and destination\n+    uint32_t in_x0;\n+    uint32_t in_y0;\n+    uint32_t out_x0;\n+    uint32_t out_y0;\n \n-    // overlay image extends past the bottom border -> cut height for copy\n-    if (dy + in_h > out_h) {\n-      in_h = out_h - dy;\n+    if (dx > 0 && static_cast<uint32_t>(dx) >= out_w) {\n+      // the overlay image is completely outside the right border -> skip overlaying\n+      return Error::Ok;\n+    }\n+    else if (dx < 0 && in_w <= negate_negative_int32(dx)) {\n+      // the overlay image is completely outside the left border -> skip overlaying\n+      return Error::Ok;\n     }\n \n-    // overlay image completely outside right or bottom border -> do not copy\n-    if (in_w < 0 || in_h < 0) {\n-      return Error(heif_error_Invalid_input,\n-                   heif_suberror_Overlay_image_outside_of_canvas,\n-                   \"Overlay image outside of right or bottom canvas border\");\n+    if (dx < 0) {\n+      // overlay image started partially outside of left border\n+\n+      in_x0 = negate_negative_int32(dx);\n+      out_x0 = 0;\n+      in_w = in_w - in_x0; // in_x0 < in_w because in_w > -dx = in_x0\n+    }\n+    else {\n+      in_x0 = 0;\n+      out_x0 = static_cast<uint32_t>(dx);\n     }\n \n+    // we know that dx >= 0 && dx < out_w\n \n-    // calculate top-left point where to start copying in source and destination\n-    int in_x0 = 0;\n-    int in_y0 = 0;\n-    int out_x0 = dx;\n-    int out_y0 = dy;\n+    if (static_cast<uint32_t>(dx) > UINT32_MAX - in_w ||\n+        dx + in_w > out_w) {\n+      // overlay image extends partially outside of right border\n \n-    // overlay image started outside of left border\n-    // -> move start into the image and start at left output column\n-    if (dx < 0) {\n-      in_x0 = -dx;\n-      out_x0 = 0;\n+      in_w = out_w - static_cast<uint32_t>(dx); // we know that dx < out_w from first condition\n+    }\n+\n+\n+    if (dy > 0 && static_cast<uint32_t>(dy) >= out_h) {\n+      // the overlay image is completely outside the bottom border -> skip overlaying\n+      return Error::Ok;\n+    }\n+    else if (dy < 0 && in_h <= negate_negative_int32(dy)) {\n+      // the overlay image is completely outside the top border -> skip overlaying\n+      return Error::Ok;\n     }\n \n-    // overlay image started outside of top border\n-    // -> move start into the image and start at top output row\n     if (dy < 0) {\n-      in_y0 = -dy;\n+      // overlay image started partially outside of top border\n+\n+      in_y0 = negate_negative_int32(dy);\n       out_y0 = 0;\n+      in_h = in_h - in_y0; // in_y0 < in_h because in_h > -dy = in_y0\n     }\n-\n-    // if overlay image is completely outside at left border, do not copy anything.\n-    if (in_w <= in_x0 ||\n-        in_h <= in_y0) {\n-      return Error(heif_error_Invalid_input,\n-                   heif_suberror_Overlay_image_outside_of_canvas,\n-                   \"Overlay image outside of left or top canvas border\");\n+    else {\n+      in_y0 = 0;\n+      out_y0 = static_cast<uint32_t>(dy);\n     }\n \n-    // verify that the destination points are within the bounds of the image's dimensions\n-    if (out_x0 < 0 ||\n-        out_x0 >= out_w ||\n-        out_y0 < 0 ||\n-        out_y0 >= out_h) {\n-      return Error(heif_error_Invalid_input,\n-                   heif_suberror_Invalid_overlay_data,\n-                   \"Overlay image has invalid offsets\");\n-    }\n+    // we know that dy >= 0 && dy < out_h\n+\n+    if (static_cast<uint32_t>(dy) > UINT32_MAX - in_h ||\n+        dy + in_h > out_h) {\n+      // overlay image extends partially outside of bottom border\n \n-    // verify that the source points are within the bounds of the image's dimensions\n-    if (in_x0 < 0 ||\n-        in_x0 >= in_w ||\n-        in_y0 < 0 ||\n-        in_y0 >= in_h) {\n-      return Error(heif_error_Invalid_input,\n-                   heif_suberror_Invalid_overlay_data,\n-                   \"Overlay image has invalid offsets\");\n+      in_h = out_h - static_cast<uint32_t>(dy); // we know that dy < out_h from first condition\n     }\n \n-    for (int y = in_y0; y < in_h; y++) {\n+\n+    for (uint32_t y = in_y0; y < in_h; y++) {\n       if (!has_alpha) {\n         memcpy(out_p + out_x0 + (out_y0 + y - in_y0) * out_stride,\n                in_p + in_x0 + y * in_stride,\n                in_w - in_x0);\n       }\n       else {\n-        for (int x = in_x0; x < in_w; x++) {\n+        for (uint32_t x = in_x0; x < in_w; x++) {\n           uint8_t* outptr = &out_p[out_x0 + (out_y0 + y - in_y0) * out_stride + x];\n           uint8_t in_val = in_p[in_x0 + y * in_stride + x];\n           uint8_t alpha_val = alpha_p[in_x0 + y * in_stride + x];"
        },
        {
          "filename": "libheif/pixelimage.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -109,7 +109,7 @@ class HeifPixelImage : public std::enable_shared_from_this<HeifPixelImage>,\n \n   Error fill_RGB_16bit(uint16_t r, uint16_t g, uint16_t b, uint16_t a);\n \n-  Error overlay(std::shared_ptr<HeifPixelImage>& overlay, int dx, int dy);\n+  Error overlay(std::shared_ptr<HeifPixelImage>& overlay, int32_t dx, int32_t dy);\n \n   Error scale_nearest_neighbor(std::shared_ptr<HeifPixelImage>& output, int width, int height) const;\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "e52035eaeb0697c09f4d70dd52c02281b51f2a0a",
            "date": "2025-01-14T11:06:04Z",
            "author_login": "farindk"
          },
          {
            "sha": "e7c6d712902d4e0d97d2946636fec40e8be1797e",
            "date": "2025-01-14T11:03:46Z",
            "author_login": "farindk"
          },
          {
            "sha": "b44c4ecbc500d8d5fb91911b43b9461b48102859",
            "date": "2025-01-14T10:43:50Z",
            "author_login": "lovell"
          },
          {
            "sha": "2b736bf786292da16b34a73bf82dad745f3c3115",
            "date": "2025-01-10T14:51:01Z",
            "author_login": "farindk"
          },
          {
            "sha": "1630460fdb747f2d3c803e9ce38c22469eeadc83",
            "date": "2025-01-06T15:08:25Z",
            "author_login": "farindk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-125",
    "description": "In Libheif 1.17.6, insufficient checks in ImageOverlay::parse() decoding a heif file containing an overlay image with forged offsets can lead to an out-of-bounds read and write.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-15T21:15:10.923",
    "last_modified": "2024-11-21T09:32:30.190",
    "fix_date": "2024-07-08T10:26:24Z"
  },
  "references": [
    {
      "url": "https://gist.github.com/flyyee/79f1b224069842ee320115cafa5c35c0",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/strukturag/libheif/commit/a3ed1b1eb178c5d651d6ac619c8da3d71ac2be36",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/strukturag/libheif/issues/1226",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/strukturag/libheif/pull/1227",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/10/msg00025.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.151003",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libheif",
    "owner": "strukturag",
    "created_at": "2017-12-21T14:06:21Z",
    "updated_at": "2025-01-14T12:03:23Z",
    "pushed_at": "2025-01-14T11:38:18Z",
    "size": 11679,
    "stars": 1812,
    "forks": 312,
    "open_issues": 245,
    "watchers": 1812,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "coverity"
    ],
    "languages": {
      "C++": 3265751,
      "C": 205335,
      "CMake": 68394,
      "Go": 50734,
      "Shell": 43462,
      "JavaScript": 6472
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T12:57:41.565599"
  }
}