{
  "cve_id": "CVE-2024-41799",
  "github_data": {
    "repository": "tgstation/tgstation-server",
    "fix_commit": "374852fe5ae306415eb5aafb2d16b06897d7afe4",
    "related_commits": [
      "374852fe5ae306415eb5aafb2d16b06897d7afe4",
      "374852fe5ae306415eb5aafb2d16b06897d7afe4"
    ],
    "patch_url": "https://github.com/tgstation/tgstation-server/commit/374852fe5ae306415eb5aafb2d16b06897d7afe4.patch",
    "fix_commit_details": {
      "sha": "374852fe5ae306415eb5aafb2d16b06897d7afe4",
      "commit_date": "2024-07-26T22:26:23Z",
      "author": {
        "login": "Cyberboss",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #1835 from tgstation/BarGoesUpInFlames [APIDeploy][NugetDeploy]",
        "length": 180,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 232,
        "additions": 149,
        "deletions": 83
      },
      "files": [
        {
          "filename": "build/Version.props",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -3,12 +3,12 @@\n   <!-- Integration tests will ensure they match across the board -->\n   <Import Project=\"WebpanelVersion.props\" />\n   <PropertyGroup>\n-    <TgsCoreVersion>6.7.0</TgsCoreVersion>\n+    <TgsCoreVersion>6.8.0</TgsCoreVersion>\n     <TgsConfigVersion>5.1.0</TgsConfigVersion>\n-    <TgsApiVersion>10.5.0</TgsApiVersion>\n+    <TgsApiVersion>10.6.0</TgsApiVersion>\n     <TgsCommonLibraryVersion>7.0.0</TgsCommonLibraryVersion>\n-    <TgsApiLibraryVersion>13.5.0</TgsApiLibraryVersion>\n-    <TgsClientVersion>15.5.0</TgsClientVersion>\n+    <TgsApiLibraryVersion>13.6.0</TgsApiLibraryVersion>\n+    <TgsClientVersion>15.6.0</TgsClientVersion>\n     <TgsDmapiVersion>7.1.3</TgsDmapiVersion>\n     <TgsInteropVersion>5.9.0</TgsInteropVersion>\n     <TgsHostWatchdogVersion>1.4.1</TgsHostWatchdogVersion>"
        },
        {
          "filename": "src/Tgstation.Server.Api/Models/ErrorCode.cs",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -651,5 +651,11 @@ public enum ErrorCode : uint\n \t\t/// </summary>\n \t\t[Description(\"Could not create dump as dotnet diagnostics threw an exception!\")]\n \t\tDotnetDiagnosticsFailure,\n+\n+\t\t/// <summary>\n+\t\t/// The configured .dme could not be found.\n+\t\t/// </summary>\n+\t\t[Description(\"Could not load configured .dme due to it being outside the deployment directory! This should be a relative path.\")]\n+\t\tDeploymentWrongDme,\n \t}\n }"
        },
        {
          "filename": "src/Tgstation.Server.Host/Components/Deployment/DreamMaker.cs",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -607,6 +607,9 @@ await eventConsumer.HandleEvent(\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\tvar targetDme = ioManager.ConcatPath(outputDirectory, String.Join('.', job.DmeName, DmeExtension));\n+\t\t\t\t\tif (!await ioManager.PathIsChildOf(outputDirectory, targetDme, cancellationToken))\n+\t\t\t\t\t\tthrow new JobException(ErrorCode.DeploymentWrongDme);\n+\n \t\t\t\t\tvar targetDmeExists = await ioManager.FileExists(targetDme, cancellationToken);\n \t\t\t\t\tif (!targetDmeExists)\n \t\t\t\t\t\tthrow new JobException(ErrorCode.DeploymentMissingDme);"
        },
        {
          "filename": "src/Tgstation.Server.Host/Controllers/InstanceController.cs",
          "status": "modified",
          "additions": 41,
          "deletions": 67,
          "patch": "@@ -103,8 +103,8 @@ public InstanceController(\n \t\t\tIInstanceManager instanceManager,\n \t\t\tIJobManager jobManager,\n \t\t\tIIOManager ioManager,\n-\t\t\tIPortAllocator portAllocator,\n \t\t\tIPlatformIdentifier platformIdentifier,\n+\t\t\tIPortAllocator portAllocator,\n \t\t\tIPermissionsUpdateNotifyee permissionsUpdateNotifyee,\n \t\t\tIOptions<GeneralConfiguration> generalConfigurationOptions,\n \t\t\tIOptions<SwarmConfiguration> swarmConfigurationOptions,\n@@ -150,77 +150,52 @@ public async ValueTask<IActionResult> Create([FromBody] InstanceCreateRequest mo\n \t\t\tif (earlyOut != null)\n \t\t\t\treturn earlyOut;\n \n-\t\t\tvar unNormalizedPath = model.Path;\n-\t\t\tvar targetInstancePath = NormalizePath(unNormalizedPath);\n+\t\t\tvar targetInstancePath = NormalizePath(model.Path!);\n \t\t\tmodel.Path = targetInstancePath;\n \n-\t\t\tvar installationDirectoryPath = NormalizePath(DefaultIOManager.CurrentDirectory);\n-\n-\t\t\tbool InstanceIsChildOf(string otherPath)\n-\t\t\t{\n-\t\t\t\tif (!targetInstancePath.StartsWith(otherPath, StringComparison.Ordinal))\n-\t\t\t\t\treturn false;\n-\n-\t\t\t\tbool sameLength = targetInstancePath.Length == otherPath.Length;\n-\t\t\t\tchar dirSeparatorChar = targetInstancePath.ToCharArray()[Math.Min(otherPath.Length, targetInstancePath.Length - 1)];\n-\t\t\t\treturn sameLength\n-\t\t\t\t\t|| dirSeparatorChar == Path.DirectorySeparatorChar\n-\t\t\t\t\t|| dirSeparatorChar == Path.AltDirectorySeparatorChar;\n-\t\t\t}\n-\n-\t\t\tif (InstanceIsChildOf(installationDirectoryPath))\n+\t\t\tvar installationDirectoryPath = DefaultIOManager.CurrentDirectory;\n+\t\t\tif (await ioManager.PathIsChildOf(installationDirectoryPath, targetInstancePath, cancellationToken))\n \t\t\t\treturn Conflict(new ErrorMessageResponse(ErrorCode.InstanceAtConflictingPath));\n \n \t\t\t// Validate it's not a child of any other instance\n-\t\t\tulong countOfOtherInstances = 0;\n-\t\t\tusing (var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))\n-\t\t\t{\n-\t\t\t\tvar newCancellationToken = cts.Token;\n-\t\t\t\ttry\n-\t\t\t\t{\n-\t\t\t\t\tawait DatabaseContext\n-\t\t\t\t\t\t.Instances\n-\t\t\t\t\t\t.AsQueryable()\n-\t\t\t\t\t\t.Where(x => x.SwarmIdentifer == swarmConfiguration.Identifier)\n-\t\t\t\t\t\t.Select(x => new Models.Instance\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tPath = x.Path,\n-\t\t\t\t\t\t})\n-\t\t\t\t\t\t.ForEachAsync(\n-\t\t\t\t\t\t\totherInstance =>\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tif (++countOfOtherInstances >= generalConfiguration.InstanceLimit)\n-\t\t\t\t\t\t\t\t\tearlyOut ??= Conflict(new ErrorMessageResponse(ErrorCode.InstanceLimitReached));\n-\t\t\t\t\t\t\t\telse if (InstanceIsChildOf(otherInstance.Path!))\n-\t\t\t\t\t\t\t\t\tearlyOut ??= Conflict(new ErrorMessageResponse(ErrorCode.InstanceAtConflictingPath));\n-\n-\t\t\t\t\t\t\t\tif (earlyOut != null && !newCancellationToken.IsCancellationRequested)\n-\t\t\t\t\t\t\t\t\tcts.Cancel();\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\tnewCancellationToken);\n-\t\t\t\t}\n-\t\t\t\tcatch (OperationCanceledException)\n+\t\t\tvar instancePaths = await DatabaseContext\n+\t\t\t\t.Instances\n+\t\t\t\t.AsQueryable()\n+\t\t\t\t.Where(x => x.SwarmIdentifer == swarmConfiguration.Identifier)\n+\t\t\t\t.Select(x => new Models.Instance\n \t\t\t\t{\n-\t\t\t\t\tcancellationToken.ThrowIfCancellationRequested();\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\t\t\tPath = x.Path,\n+\t\t\t\t})\n+\t\t\t\t.ToListAsync(cancellationToken);\n \n-\t\t\tif (earlyOut != null)\n-\t\t\t\treturn earlyOut;\n+\t\t\tif ((instancePaths.Count + 1) >= generalConfiguration.InstanceLimit)\n+\t\t\t\treturn Conflict(new ErrorMessageResponse(ErrorCode.InstanceLimitReached));\n+\n+\t\t\tvar instancePathChecks = instancePaths\n+\t\t\t\t.Select(otherInstance => ioManager.PathIsChildOf(otherInstance.Path!, targetInstancePath, cancellationToken))\n+\t\t\t\t.ToArray();\n+\n+\t\t\tawait Task.WhenAll(instancePathChecks);\n+\n+\t\t\tif (instancePathChecks.Any(task => task.Result))\n+\t\t\t\treturn Conflict(new ErrorMessageResponse(ErrorCode.InstanceAtConflictingPath));\n \n \t\t\t// Last test, ensure it's in the list of valid paths\n-\t\t\tif (!(generalConfiguration.ValidInstancePaths?\n-\t\t\t\t.Select(path => NormalizePath(path))\n-\t\t\t\t.Any(path => InstanceIsChildOf(path)) ?? true))\n+\t\t\tvar pathChecks = generalConfiguration.ValidInstancePaths?\n+\t\t\t\t.Select(path => ioManager.PathIsChildOf(path, targetInstancePath, cancellationToken))\n+\t\t\t\t.ToArray()\n+\t\t\t\t?? Enumerable.Empty<Task<bool>>();\n+\t\t\tawait Task.WhenAll(pathChecks);\n+\t\t\tif (!pathChecks.All(task => task.Result))\n \t\t\t\treturn BadRequest(new ErrorMessageResponse(ErrorCode.InstanceNotAtWhitelistedPath));\n \n \t\t\tasync ValueTask<bool> DirExistsAndIsNotEmpty()\n \t\t\t{\n-\t\t\t\tif (!await ioManager.DirectoryExists(model.Path, cancellationToken))\n+\t\t\t\tif (!await ioManager.DirectoryExists(targetInstancePath, cancellationToken))\n \t\t\t\t\treturn false;\n \n-\t\t\t\tvar filesTask = ioManager.GetFiles(model.Path, cancellationToken);\n-\t\t\t\tvar dirsTask = ioManager.GetDirectories(model.Path, cancellationToken);\n+\t\t\t\tvar filesTask = ioManager.GetFiles(targetInstancePath, cancellationToken);\n+\t\t\t\tvar dirsTask = ioManager.GetDirectories(targetInstancePath, cancellationToken);\n \n \t\t\t\tvar files = await filesTask;\n \t\t\t\tvar dirs = await dirsTask;\n@@ -230,8 +205,8 @@ async ValueTask<bool> DirExistsAndIsNotEmpty()\n \n \t\t\tvar dirExistsTask = DirExistsAndIsNotEmpty();\n \t\t\tbool attached = false;\n-\t\t\tif (await ioManager.FileExists(model.Path, cancellationToken) || await dirExistsTask)\n-\t\t\t\tif (!await ioManager.FileExists(ioManager.ConcatPath(model.Path, InstanceAttachFileName), cancellationToken))\n+\t\t\tif (await ioManager.FileExists(targetInstancePath, cancellationToken) || await dirExistsTask)\n+\t\t\t\tif (!await ioManager.FileExists(ioManager.ConcatPath(targetInstancePath, InstanceAttachFileName), cancellationToken))\n \t\t\t\t\treturn Conflict(new ErrorMessageResponse(ErrorCode.InstanceAtExistingPath));\n \t\t\t\telse\n \t\t\t\t\tattached = true;\n@@ -248,7 +223,7 @@ async ValueTask<bool> DirExistsAndIsNotEmpty()\n \t\t\t\ttry\n \t\t\t\t{\n \t\t\t\t\t// actually reserve it now\n-\t\t\t\t\tawait ioManager.CreateDirectory(unNormalizedPath, cancellationToken);\n+\t\t\t\t\tawait ioManager.CreateDirectory(targetInstancePath, cancellationToken);\n \t\t\t\t\tawait ioManager.DeleteFile(ioManager.ConcatPath(targetInstancePath, InstanceAttachFileName), cancellationToken);\n \t\t\t\t}\n \t\t\t\tcatch\n@@ -397,13 +372,13 @@ bool CheckModified<T>(Expression<Func<Api.Models.Instance, T>> expression, Insta\n \t\t\t}\n \n \t\t\tstring? originalModelPath = null;\n-\t\t\tstring? rawPath = null;\n+\t\t\tstring? normalizedPath = null;\n \t\t\tvar originalOnline = originalModel.Online!.Value;\n \t\t\tif (model.Path != null)\n \t\t\t{\n-\t\t\t\trawPath = NormalizePath(model.Path);\n+\t\t\t\tnormalizedPath = NormalizePath(model.Path);\n \n-\t\t\t\tif (rawPath != originalModel.Path)\n+\t\t\t\tif (normalizedPath != originalModel.Path)\n \t\t\t\t{\n \t\t\t\t\tif (!userRights.HasFlag(InstanceManagerRights.Relocate))\n \t\t\t\t\t\treturn Forbid();\n@@ -415,7 +390,7 @@ bool CheckModified<T>(Expression<Func<Api.Models.Instance, T>> expression, Insta\n \t\t\t\t\t\treturn Conflict(new ErrorMessageResponse(ErrorCode.InstanceAtExistingPath));\n \n \t\t\t\t\toriginalModelPath = originalModel.Path;\n-\t\t\t\t\toriginalModel.Path = rawPath;\n+\t\t\t\t\toriginalModel.Path = normalizedPath;\n \t\t\t\t}\n \t\t\t}\n \n@@ -505,7 +480,7 @@ await WithComponentInstanceNullable(\n \t\t\tvar moving = originalModelPath != null;\n \t\t\tif (moving)\n \t\t\t{\n-\t\t\t\tvar description = $\"Move instance ID {originalModel.Id} from {originalModelPath} to {rawPath}\";\n+\t\t\t\tvar description = $\"Move instance ID {originalModel.Id} from {originalModelPath} to {normalizedPath}\";\n \t\t\t\tvar job = Job.Create(JobCode.Move, AuthenticationContext.User, originalModel, InstanceManagerRights.Relocate);\n \t\t\t\tjob.Description = description;\n \n@@ -823,8 +798,7 @@ InstancePermissionSet InstanceAdminPermissionSet(InstancePermissionSet? permissi\n \t\t\t\treturn null;\n \n \t\t\tpath = ioManager.ResolvePath(path);\n-\t\t\tif (platformIdentifier.IsWindows)\n-\t\t\t\tpath = path.ToUpperInvariant().Replace('\\\\', '/');\n+\t\t\tpath = platformIdentifier.NormalizePath(path);\n \n \t\t\treturn path;\n \t\t}"
        },
        {
          "filename": "src/Tgstation.Server.Host/Database/DatabaseSeeder.cs",
          "status": "modified",
          "additions": 16,
          "deletions": 10,
          "patch": "@@ -51,6 +51,11 @@ sealed class DatabaseSeeder : IDatabaseSeeder\n \t\t/// </summary>\n \t\treadonly DatabaseConfiguration databaseConfiguration;\n \n+\t\t/// <summary>\n+\t\t/// The <see cref=\"SwarmConfiguration\"/> for the <see cref=\"DatabaseSeeder\"/>.\n+\t\t/// </summary>\n+\t\treadonly SwarmConfiguration swarmConfiguration;\n+\n \t\t/// <summary>\n \t\t/// Add a default system <see cref=\"User\"/> to a given <paramref name=\"databaseContext\"/>.\n \t\t/// </summary>\n@@ -83,20 +88,23 @@ static User SeedSystemUser(IDatabaseContext databaseContext, User? tgsUser = nul\n \t\t/// <param name=\"platformIdentifier\">The value of <see cref=\"platformIdentifier\"/>.</param>\n \t\t/// <param name=\"generalConfigurationOptions\">The <see cref=\"IOptions{TOptions}\"/> containing the value of <see cref=\"generalConfiguration\"/>.</param>\n \t\t/// <param name=\"databaseConfigurationOptions\">The <see cref=\"IOptions{TOptions}\"/> containing the value of <see cref=\"databaseConfiguration\"/>.</param>\n+\t\t/// <param name=\"swarmConfigurationOptions\">The <see cref=\"IOptions{TOptions}\"/> containing the value of <see cref=\"swarmConfiguration\"/>.</param>\n \t\t/// <param name=\"databaseLogger\">The value of <see cref=\"databaseLogger\"/>.</param>\n \t\t/// <param name=\"logger\">The value of <see cref=\"logger\"/>.</param>\n \t\tpublic DatabaseSeeder(\n \t\t\tICryptographySuite cryptographySuite,\n \t\t\tIPlatformIdentifier platformIdentifier,\n \t\t\tIOptions<GeneralConfiguration> generalConfigurationOptions,\n \t\t\tIOptions<DatabaseConfiguration> databaseConfigurationOptions,\n+\t\t\tIOptions<SwarmConfiguration> swarmConfigurationOptions,\n \t\t\tILogger<DatabaseContext> databaseLogger,\n \t\t\tILogger<DatabaseSeeder> logger)\n \t\t{\n \t\t\tthis.cryptographySuite = cryptographySuite ?? throw new ArgumentNullException(nameof(cryptographySuite));\n \t\t\tthis.platformIdentifier = platformIdentifier ?? throw new ArgumentNullException(nameof(platformIdentifier));\n \t\t\tdatabaseConfiguration = databaseConfigurationOptions?.Value ?? throw new ArgumentNullException(nameof(databaseConfigurationOptions));\n \t\t\tgeneralConfiguration = generalConfigurationOptions?.Value ?? throw new ArgumentNullException(nameof(generalConfigurationOptions));\n+\t\t\tswarmConfiguration = swarmConfigurationOptions?.Value ?? throw new ArgumentNullException(nameof(swarmConfigurationOptions));\n \t\t\tthis.databaseLogger = databaseLogger ?? throw new ArgumentNullException(nameof(databaseLogger));\n \t\t\tthis.logger = logger ?? throw new ArgumentNullException(nameof(logger));\n \t\t}\n@@ -223,16 +231,14 @@ async ValueTask SanitizeDatabase(IDatabaseContext databaseContext, CancellationT\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (platformIdentifier.IsWindows)\n-\t\t\t{\n-\t\t\t\t// normalize backslashes to forward slashes\n-\t\t\t\tvar allInstances = await databaseContext\n-\t\t\t\t\t.Instances\n-\t\t\t\t\t.AsQueryable()\n-\t\t\t\t\t.ToListAsync(cancellationToken);\n-\t\t\t\tforeach (var instance in allInstances)\n-\t\t\t\t\tinstance.Path = instance.Path!.Replace('\\\\', '/');\n-\t\t\t}\n+\t\t\t// normalize backslashes to forward slashes\n+\t\t\tvar allInstances = await databaseContext\n+\t\t\t\t.Instances\n+\t\t\t\t.AsQueryable()\n+\t\t\t\t.Where(instance => instance.SwarmIdentifer == swarmConfiguration.Identifier)\n+\t\t\t\t.ToListAsync(cancellationToken);\n+\t\t\tforeach (var instance in allInstances)\n+\t\t\t\tinstance.Path = platformIdentifier.NormalizePath(instance.Path!.Replace('\\\\', '/'));\n \n \t\t\tif (generalConfiguration.ByondTopicTimeout != 0)\n \t\t\t{"
        },
        {
          "filename": "src/Tgstation.Server.Host/IO/DefaultIOManager.cs",
          "status": "modified",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -358,6 +358,33 @@ public Task<DateTimeOffset> GetLastModified(string path, CancellationToken cance\n \t\t\tDefaultBufferSize,\n \t\t\ttrue);\n \n+\t\t/// <inheritdoc />\n+\t\tpublic Task<bool> PathIsChildOf(string parentPath, string childPath, CancellationToken cancellationToken) => Task.Factory.StartNew(\n+\t\t\t() =>\n+\t\t\t{\n+\t\t\t\tparentPath = ResolvePath(parentPath);\n+\t\t\t\tchildPath = ResolvePath(childPath);\n+\n+\t\t\t\tif (parentPath == childPath)\n+\t\t\t\t\treturn true;\n+\n+\t\t\t\t// https://stackoverflow.com/questions/5617320/given-full-path-check-if-path-is-subdirectory-of-some-other-path-or-otherwise?lq=1\n+\t\t\t\tvar di1 = new DirectoryInfo(parentPath);\n+\t\t\t\tvar di2 = new DirectoryInfo(childPath);\n+\t\t\t\twhile (di2.Parent != null)\n+\t\t\t\t{\n+\t\t\t\t\tif (di2.Parent.FullName == di1.FullName)\n+\t\t\t\t\t\treturn true;\n+\n+\t\t\t\t\tdi2 = di2.Parent;\n+\t\t\t\t}\n+\n+\t\t\t\treturn false;\n+\t\t\t},\n+\t\t\tcancellationToken,\n+\t\t\tBlockingTaskCreationOptions,\n+\t\t\tTaskScheduler.Current);\n+\n \t\t/// <summary>\n \t\t/// Copies a directory from <paramref name=\"src\"/> to <paramref name=\"dest\"/>.\n \t\t/// </summary>"
        },
        {
          "filename": "src/Tgstation.Server.Host/IO/IIOManager.cs",
          "status": "modified",
          "additions": 10,
          "deletions": 1,
          "patch": "@@ -45,6 +45,15 @@ public interface IIOManager\n \t\t/// <returns><see langword=\"true\"/> if <paramref name=\"path\"/> contains a '..' accessor, <see langword=\"false\"/> otherwise.</returns>\n \t\tbool PathContainsParentAccess(string path);\n \n+\t\t/// <summary>\n+\t\t/// Check if a given <paramref name=\"parentPath\"/> is a parent of a given <paramref name=\"parentPath\"/>.\n+\t\t/// </summary>\n+\t\t/// <param name=\"parentPath\">The parent path.</param>\n+\t\t/// <param name=\"childPath\">The child path.</param>\n+\t\t/// <param name=\"cancellationToken\">The <see cref=\"CancellationToken\"/> for the operation.</param>\n+\t\t/// <returns>A <see cref=\"Task{TResult}\"/> resulting in <see langword=\"true\"/> if <paramref name=\"childPath\"/> is a child of <paramref name=\"parentPath\"/> or they are equivalent.</returns>\n+\t\tTask<bool> PathIsChildOf(string parentPath, string childPath, CancellationToken cancellationToken);\n+\n \t\t/// <summary>\n \t\t/// Copies a directory from <paramref name=\"src\"/> to <paramref name=\"dest\"/>.\n \t\t/// </summary>\n@@ -68,7 +77,7 @@ ValueTask CopyDirectory(\n \t\t/// </summary>\n \t\t/// <param name=\"path\">The file to check for existence.</param>\n \t\t/// <param name=\"cancellationToken\">The <see cref=\"CancellationToken\"/> for the operation.</param>\n-\t\t/// <returns>A <see cref=\"Task\"/> resulting in <see langword=\"true\"/> if the file at <paramref name=\"path\"/> exists, <see langword=\"false\"/> otherwise.</returns>\n+\t\t/// <returns>A <see cref=\"Task{TResult}\"/> resulting in <see langword=\"true\"/> if the file at <paramref name=\"path\"/> exists, <see langword=\"false\"/> otherwise.</returns>\n \t\tTask<bool> FileExists(string path, CancellationToken cancellationToken);\n \n \t\t/// <summary>"
        },
        {
          "filename": "src/Tgstation.Server.Host/System/IPlatformIdentifier.cs",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -17,5 +17,12 @@ public interface IPlatformIdentifier\n \t\t/// The extension of executable script files for the system.\n \t\t/// </summary>\n \t\tstring ScriptFileExtension { get; }\n+\n+\t\t/// <summary>\n+\t\t/// Normalize a path for consistency.\n+\t\t/// </summary>\n+\t\t/// <param name=\"path\">The path to normalize.</param>\n+\t\t/// <returns>The normalized path.</returns>\n+\t\tstring NormalizePath(string path);\n \t}\n }"
        },
        {
          "filename": "src/Tgstation.Server.Host/System/PlatformIdentifier.cs",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -1,4 +1,5 @@\n-\ufeffusing System.Runtime.InteropServices;\n+\ufeffusing System;\n+using System.Runtime.InteropServices;\n using System.Runtime.Versioning;\n \n namespace Tgstation.Server.Host.System\n@@ -21,5 +22,15 @@ public PlatformIdentifier()\n \t\t\tIsWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);\n \t\t\tScriptFileExtension = IsWindows ? \"bat\" : \"sh\";\n \t\t}\n+\n+\t\t/// <inheritdoc />\n+\t\tpublic string NormalizePath(string path)\n+\t\t{\n+\t\t\tArgumentNullException.ThrowIfNull(path);\n+\t\t\tif (IsWindows)\n+\t\t\t\tpath = path.Replace('\\\\', '/');\n+\n+\t\t\treturn path;\n+\t\t}\n \t}\n }"
        },
        {
          "filename": "tests/Tgstation.Server.Tests/Live/Instance/DeploymentTest.cs",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -1,4 +1,6 @@\n \ufeffusing System;\n+using System.IO;\n+using System.Linq;\n using System.Threading;\n using System.Threading.Tasks;\n \n@@ -200,6 +202,27 @@ await dreamMakerClient.Update(new DreamMakerRequest\n \t\t\tdeployJob = await dreamMakerClient.Compile(cancellationToken);\n \t\t\tawait WaitForJob(deployJob, 40, true, ErrorCode.DeploymentMissingDme, cancellationToken);\n \n+\t\t\t// set to an absolute path that does exist\n+\t\t\tvar tempFile = Path.GetTempFileName().Replace('\\\\', '/');\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\t// for testing purposes, assume same drive for windows\n+\t\t\t\tvar relativePath = $\"../../{String.Join(\"/\", instanceClient.Metadata.Path.Replace('\\\\', '/').Where(pathChar => pathChar == '/').Select(x => \"..\"))}{tempFile.Substring(tempFile.IndexOf('/'))}\";\n+\t\t\t\tvar dmePath = $\"{tempFile}.dme\";\n+\t\t\t\tFile.Move(tempFile, dmePath);\n+\t\t\t\ttempFile = dmePath;\n+\t\t\t\tawait dreamMakerClient.Update(new DreamMakerRequest\n+\t\t\t\t{\n+\t\t\t\t\tProjectName = relativePath\n+\t\t\t\t}, cancellationToken);\n+\t\t\t\tdeployJob = await dreamMakerClient.Compile(cancellationToken);\n+\t\t\t\tawait WaitForJob(deployJob, 40, true, ErrorCode.DeploymentWrongDme, cancellationToken);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tFile.Delete(tempFile);\n+\t\t\t}\n+\n \t\t\t// check that we can change the visibility\n \n \t\t\tawait vpTest;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 8,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "69bbacc353ab8432b62670032771c44a84f73200",
            "date": "2025-01-04T18:43:46Z",
            "author_login": "tgstation-server-ci[bot]"
          },
          {
            "sha": "71c41ccb76ddcc3c86e7603057d832dd38da2d0c",
            "date": "2025-01-04T18:41:36Z",
            "author_login": "Cyberboss"
          },
          {
            "sha": "43be54c8a1c3be5b62be878b7e2e86108298f48a",
            "date": "2025-01-04T15:12:02Z",
            "author_login": "Cyberboss"
          },
          {
            "sha": "7e5ad85d079c27e522ee4c859fa926412917af75",
            "date": "2025-01-04T15:09:19Z",
            "author_login": "tgstation-server-ci[bot]"
          },
          {
            "sha": "5f3f78ed23562bd479967fd2acd34f9da07e0ed6",
            "date": "2025-01-04T15:07:03Z",
            "author_login": "Cyberboss"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:H",
    "cwe_id": "CWE-22",
    "description": "tgstation-server is a production scale tool for BYOND server management. Prior to 6.8.0, low permission users using the \"Set .dme Path\" privilege could potentially set malicious .dme files existing on the host machine to be compiled and executed. These .dme files could be uploaded via tgstation-server (requiring a separate, isolated privilege) or some other means. A server configured to execute in BYOND's trusted security level (requiring a third separate, isolated privilege OR being set by another user) could lead to this escalating into remote code execution via BYOND's shell() proc. The ability to execute this kind of attack is a known side effect of having privileged TGS users, but normally requires multiple privileges with known weaknesses. This vector is not intentional as it does not require control over the where deployment code is sourced from and _may_ not require remote write access to an instance's `Configuration` directory. This problem is fixed in versions 6.8.0 and above.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-07-29T15:15:16.267",
    "last_modified": "2024-11-21T09:33:05.673",
    "fix_date": "2024-07-26T22:26:23Z"
  },
  "references": [
    {
      "url": "https://github.com/tgstation/tgstation-server/commit/374852fe5ae306415eb5aafb2d16b06897d7afe4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/tgstation/tgstation-server/pull/1835",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/tgstation/tgstation-server/security/advisories/GHSA-c3h4-9gc2-f7h4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/tgstation/tgstation-server/commit/374852fe5ae306415eb5aafb2d16b06897d7afe4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/tgstation/tgstation-server/pull/1835",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/tgstation/tgstation-server/security/advisories/GHSA-c3h4-9gc2-f7h4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:34.496412",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "tgstation-server",
    "owner": "tgstation",
    "created_at": "2017-05-31T14:11:40Z",
    "updated_at": "2025-01-04T18:43:51Z",
    "pushed_at": "2025-01-14T09:41:57Z",
    "size": 1426067,
    "stars": 67,
    "forks": 82,
    "open_issues": 60,
    "watchers": 67,
    "has_security_policy": false,
    "default_branch": "dev",
    "protected_branches": [
      "dev",
      "gh-pages",
      "master"
    ],
    "languages": {
      "C#": 3774143,
      "DM": 113888,
      "Shell": 8703,
      "Nix": 7660,
      "PowerShell": 5821,
      "Dockerfile": 2025,
      "Makefile": 1694,
      "Roff": 1216,
      "Batchfile": 734,
      "HTML": 589
    },
    "commit_activity": {
      "total_commits_last_year": 799,
      "avg_commits_per_week": 15.365384615384615,
      "days_active_last_year": 152
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T13:22:44.285570"
  }
}