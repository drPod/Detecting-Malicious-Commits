{
  "cve_id": "CVE-2024-41818",
  "github_data": {
    "repository": "NaturalIntelligence/fast-xml-parser",
    "fix_commit": "ba5f35e7680468acd7906eaabb2f69e28ed8b2aa",
    "related_commits": [
      "ba5f35e7680468acd7906eaabb2f69e28ed8b2aa",
      "d0bfe8a3a2813a185f39591bbef222212d856164",
      "d0bfe8a3a2813a185f39591bbef222212d856164"
    ],
    "patch_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/ba5f35e7680468acd7906eaabb2f69e28ed8b2aa.patch",
    "fix_commit_details": {
      "sha": "ba5f35e7680468acd7906eaabb2f69e28ed8b2aa",
      "commit_date": "2024-02-24T04:38:30Z",
      "author": {
        "login": "amitguptagwl",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "XML Parser v5",
        "length": 13,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 2200,
        "additions": 2183,
        "deletions": 17
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -1,5 +1,8 @@\n Note: If you find missing information about particular minor version, that version must have been changed without any functional change in this library.\n \n+**4.3.5 / 2024-02-24**\n+* code for v5 is added for experimental use\n+\n **4.3.4 / 2024-01-10**\n * fix: Don't escape entities in CDATA sections (#633) (By [wackbyte](https://github.com/wackbyte))\n "
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 7,
          "deletions": 14,
          "patch": "@@ -11,7 +11,8 @@\n \n Validate XML, Parse XML to JS Object, or Build XML from JS Object without C/C++ based libraries and no callback.\n \n-<font size=\"6\">I need a Career advice. I've posted the query on my <a href=\"github.com/amitguptagwl\">profile</a>. Your support would be appreciable.</font>\n+> XML Parser v5 is added for experimental use\n+> https://solothought.com\n \n Sponsor this project \ud83d\udc49 \n <a href=\"https://github.com/sponsors/NaturalIntelligence\"> \n@@ -91,6 +92,11 @@ If you want to be an anonymous user of this application and don't want to be hig\n * Supports parsing of PI (Processing Instruction) tags with XML declaration tags\n * And many more other features.\n \n+## v5\n+I developed v5 in Apr 2023. And I didn't get the chance to complete all the features. I've ensured that new features don't impact performance. With v5, you have more control on parsing output. Check [docs](./docs/v5) for syntax help and basic understanding.\n+\n+Please leave a comment in discussion forum for your suggestions and if you really need v5.\n+\n ## How to use\n \n To use as package dependency\n@@ -174,19 +180,6 @@ Check lib folder for different browser bundles\n \n [![](static/img/ni_ads_ads.gif)](https://github.com/NaturalIntelligence/ads/)\n \n-## Our other projects and research you must try\n-\n-* **[BigBit standard](https://github.com/amitguptagwl/bigbit)** : \n-  * Single text encoding to replace UTF-8, UTF-16, UTF-32 and more with less memory.\n-  * Single Numeric datatype alternative of integer, float, double, long, decimal and more without precision loss.\n-* **[Cytorus](https://github.com/NaturalIntelligence/cytorus)**:  Be specific and flexible while running E2E tests.\n-  * Run tests only for a particular User Story\n-  * Run tests for a route or from a route\n-  * Customizable reporting\n-  * Central dashboard for better monitoring\n-  * Options to integrate E2E tests with Jira, Github etc using Central dashboard `Tian`.\n-* **[Stubmatic](https://github.com/NaturalIntelligence/Stubmatic)** : Create fake webservices, DynamoDB or S3 servers, Manage fake/mock stub data, Or fake any HTTP(s) call.\n-\n \n ## Supporters\n ### Contributors"
        },
        {
          "filename": "docs/v5/1. Getting Started.md",
          "status": "added",
          "additions": 217,
          "deletions": 0,
          "patch": "@@ -0,0 +1,217 @@\n+\n+\n+Example\n+\n+```js\n+const options = {\n+  preserveOrder: true,\n+  removeNSPrefix: false, // remove NS from tag name or attribute name if true\n+  stopNodes: [], //nested tags will not be parsed even for errors\n+  htmlEntities: false,\n+  tags:{\n+    unpaired: [],\n+    nameFor:{\n+      cdata: false,\n+      comment: false,\n+      text: '#text'\n+    },\n+    separateTextProperty: false,\n+    //\"join\" only if preserveOrder: true\n+    valueParsers: [\"trim\",\"entities\",\"join\",\"boolean\",\"number\",\"currency\",\"date\"]\n+  },\n+  attributes: {\n+      ignore: false,\n+      booleanType:true,\n+      entities: true,\n+      //\"groupBy\": \"att\"\n+  },\n+  OutputBuilder: new JsObjOutputBuilder()\n+};\n+const parser = new XMLParser(options);\n+let result = parser.parse(xmlData, true);\n+```\n+\n+- You can build your own Output Builder. FXP provides 3 builders\n+  - JsObjOutputBuilder\n+  - JsArrBuilder\n+  - JsMinArrBuilder\n+- You can control the sequence of value parsing for a tag or attribute\n+- You can pass a string or bytes array as input.\n+\n+### Value Parser\n+You can change the sequence of value parsers or remove one or provide your own parser to control the parsing.\n+\n+### Output builders\n+You can use provided output builds or your own output builder.\n+\n+JsObjOutputBuilder\n+```js\n+{\n+    \"soap:Envelope\": {\n+        \"@_xmlns:soap\": \"http://schemas.xmlsoap.org/soap/envelope/\",\n+        \"soap:Body\": {\n+            \"rpt:loadReportFileResponseElem\": {\n+                \"@_xmlns:s\": \"http://bus.x.com/common/support/v1\",\n+                \"@_xmlns:rpt\": \"http://bus.x.com/service/statement/v1\",\n+                \"s:code\": 0,\n+                \"s:responseTime\": 2588,\n+                \"s:responseDbTime\": 1893,\n+                \"s:requestId\": \"6b408fd09eb211e7a0807e34820340ec\",\n+                \"s:route\": \"172.16.x.x:9192\",\n+                \"rpt:result\": {\n+                    \"rpt:file\": \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n    <soap:Body>\\n        <rpt:loadReportFileResponseElem\\n                xmlns:s=\\\"http://bus.x.com/common/support/v1\\\"\\n                xmlns:rpt=\\\"http://bus.x.com/service/statement/v1\\\">\\n            <s:code>0</s:code>\\n            <s:responseTime>2588</s:responseTime>\\n            <s:responseDbTime>1893</s:responseDbTime>\\n            <s:requestId>6b408fd09eb211e7a0807e34820340ec</s:requestId>\\n            <s:route>172.16.x.x:9192</s:route>\\n            <rpt:result>\\n <rpt:file></rpt:file>\\n            </rpt:result>\\n        </rpt:loadReportFileResponseElem>\\n    </soap:Body>\\n</soap:Envelope>\"\n+                }\n+            }\n+        }\n+    }\n+}\n+```\n+\n+JsArrBuilder\n+```js\n+{\n+    \"tagname\": \"soap:Envelope\",\n+    \"child\": [\n+        {\n+            \"tagname\": \"soap:Body\",\n+            \"child\": [\n+                {\n+                    \"tagname\": \"rpt:loadReportFileResponseElem\",\n+                    \"child\": [\n+                        {\n+                            \"tagname\": \"s:code\",\n+                            \"child\": [\n+                                {\n+                                    \"#text\": 0\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"tagname\": \"s:responseTime\",\n+                            \"child\": [\n+                                {\n+                                    \"#text\": 2588\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"tagname\": \"s:responseDbTime\",\n+                            \"child\": [\n+                                {\n+                                    \"#text\": 1893\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"tagname\": \"s:requestId\",\n+                            \"child\": [\n+                                {\n+                                    \"#text\": \"6b408fd09eb211e7a0807e34820340ec\"\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"tagname\": \"s:route\",\n+                            \"child\": [\n+                                {\n+                                    \"#text\": \"172.16.x.x:9192\"\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"tagname\": \"rpt:result\",\n+                            \"child\": [\n+                                {\n+                                    \"tagname\": \"rpt:file\",\n+                                    \"child\": [\n+                                        {\n+                                            \"#text\": \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n    <soap:Body>\\n        <rpt:loadReportFileResponseElem\\n                xmlns:s=\\\"http://bus.x.com/common/support/v1\\\"\\n                xmlns:rpt=\\\"http://bus.x.com/service/statement/v1\\\">\\n            <s:code>0</s:code>\\n            <s:responseTime>2588</s:responseTime>\\n            <s:responseDbTime>1893</s:responseDbTime>\\n            <s:requestId>6b408fd09eb211e7a0807e34820340ec</s:requestId>\\n            <s:route>172.16.x.x:9192</s:route>\\n            <rpt:result>\\n <rpt:file></rpt:file>\\n            </rpt:result>\\n        </rpt:loadReportFileResponseElem>\\n    </soap:Body>\\n</soap:Envelope>\"\n+                                        }\n+                                    ]\n+                                }\n+                            ]\n+                        }\n+                    ],\n+                    \":@\": {\n+                        \"@_xmlns:s\": \"http://bus.x.com/common/support/v1\",\n+                        \"@_xmlns:rpt\": \"http://bus.x.com/service/statement/v1\"\n+                    }\n+                }\n+            ]\n+        }\n+    ],\n+    \":@\": {\n+        \"@_xmlns:soap\": \"http://schemas.xmlsoap.org/soap/envelope/\"\n+    }\n+}\n+```\n+\n+JsMinArrBuilder\n+```js\n+{\n+    \"soap:Envelope\": [\n+        {\n+            \"soap:Body\": [\n+                {\n+                    \"rpt:loadReportFileResponseElem\": [\n+                        {\n+                            \"s:code\": [\n+                                {\n+                                    \"#text\": 0\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"s:responseTime\": [\n+                                {\n+                                    \"#text\": 2588\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"s:responseDbTime\": [\n+                                {\n+                                    \"#text\": 1893\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"s:requestId\": [\n+                                {\n+                                    \"#text\": \"6b408fd09eb211e7a0807e34820340ec\"\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"s:route\": [\n+                                {\n+                                    \"#text\": \"172.16.x.x:9192\"\n+                                }\n+                            ]\n+                        },\n+                        {\n+                            \"rpt:result\": [\n+                                {\n+                                    \"rpt:file\": [\n+                                        {\n+                                            \"#text\": \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n    <soap:Body>\\n        <rpt:loadReportFileResponseElem\\n                xmlns:s=\\\"http://bus.x.com/common/support/v1\\\"\\n                xmlns:rpt=\\\"http://bus.x.com/service/statement/v1\\\">\\n            <s:code>0</s:code>\\n            <s:responseTime>2588</s:responseTime>\\n            <s:responseDbTime>1893</s:responseDbTime>\\n            <s:requestId>6b408fd09eb211e7a0807e34820340ec</s:requestId>\\n            <s:route>172.16.x.x:9192</s:route>\\n            <rpt:result>\\n <rpt:file></rpt:file>\\n            </rpt:result>\\n        </rpt:loadReportFileResponseElem>\\n    </soap:Body>\\n</soap:Envelope>\"\n+                                        }\n+                                    ]\n+                                }\n+                            ]\n+                        }\n+                    ],\n+                    \":@\": {\n+                        \"@_xmlns:s\": \"http://bus.x.com/common/support/v1\",\n+                        \"@_xmlns:rpt\": \"http://bus.x.com/service/statement/v1\"\n+                    }\n+                }\n+            ]\n+        }\n+    ],\n+    \":@\": {\n+        \"@_xmlns:soap\": \"http://schemas.xmlsoap.org/soap/envelope/\"\n+    }\n+}\n+```\n+"
        },
        {
          "filename": "package-lock.json",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,12 +1,12 @@\n {\n   \"name\": \"fast-xml-parser\",\n-  \"version\": \"4.3.4\",\n+  \"version\": \"4.3.5\",\n   \"lockfileVersion\": 2,\n   \"requires\": true,\n   \"packages\": {\n     \"\": {\n       \"name\": \"fast-xml-parser\",\n-      \"version\": \"4.3.4\",\n+      \"version\": \"4.3.5\",\n       \"funding\": [\n         {\n           \"type\": \"paypal\","
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"fast-xml-parser\",\n-  \"version\": \"4.3.4\",\n+  \"version\": \"4.3.5\",\n   \"description\": \"Validate XML, Parse XML, Build XML without C/C++ based libraries\",\n   \"main\": \"./src/fxp.js\",\n   \"scripts\": {"
        },
        {
          "filename": "spec/v5/test.js",
          "status": "added",
          "additions": 32,
          "deletions": 0,
          "patch": "@@ -0,0 +1,32 @@\n+const XMLParser = require(\"../../src/v5/XMLParser\");\n+const JsObjOutputBuilder = require(\"../../src/v5/OutputBuilders/JsObjBuilder\");\n+const JsArrBuilder = require(\"../../src/v5/OutputBuilders/JsArrBuilder\");\n+const JsMinArrBuilder = require(\"../../src/v5/OutputBuilders/JsMinArrBuilder\");\n+\n+const fs = require(\"fs\");\n+const path = require(\"path\");\n+const fileNamePath = path.join(__dirname, \"../assets/ptest.xml\");//with CDATA\n+// const fileNamePath = path.join(__dirname, \"../assets/ptest_with_prolog.xml\");//with CDATA\n+// const fileNamePath = path.join(__dirname, \"../assets/sample.xml\");//1.5k\n+// const fileNamePath = path.join(__dirname, \"../assets/midsize.xml\");//13m\n+// const fileNamePath = path.join(__dirname, \"../assets/large.xml\");//98m\n+const xmlData = fs.readFileSync(fileNamePath).toString();\n+\n+describe(\"XMLParser Entities\", function() {\n+\n+  it(\"should parse\", function() {\n+      \n+      const options = {\n+          attributes: {\n+              ignore: false,\n+              booleanType:true\n+          },\n+          OutputBuilder: new JsMinArrBuilder()\n+      };\n+      const parser = new XMLParser(options);\n+      let result = parser.parse(xmlData);\n+\n+      console.log(JSON.stringify(result,null,4));\n+    //   expect(result).toEqual(expected);\n+  });\n+});\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/CharsSymbol.js",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+modules.export = {\n+  \"<\" : \"<\", //tag start\n+  \">\" : \">\", //tag end\n+  \"/\" : \"/\", //close tag\n+  \"!\" : \"!\", //comment or docttype\n+  \"!--\" : \"!--\", //comment\n+  \"-->\" : \"-->\", //comment end\n+  \"?\" : \"?\", //pi\n+  \"?>\" : \"?>\", //pi end\n+  \"?xml\" : \"?xml\", //pi end\n+  \"![\" : \"![\", //cdata\n+  \"]]>\" : \"]]>\", //cdata end\n+  \"[\" : \"[\",\n+  \"-\" : \"-\",\n+  \"D\" : \"D\",\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/EntitiesParser.js",
          "status": "added",
          "additions": 105,
          "deletions": 0,
          "patch": "@@ -0,0 +1,105 @@\n+const ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n+const htmlEntities = {\n+    \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n+    // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n+    // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n+    // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n+    // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n+    // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n+    \"cent\" : { regex: /&(cent|#162);/g, val: \"\u00a2\" },\n+    \"pound\" : { regex: /&(pound|#163);/g, val: \"\u00a3\" },\n+    \"yen\" : { regex: /&(yen|#165);/g, val: \"\u00a5\" },\n+    \"euro\" : { regex: /&(euro|#8364);/g, val: \"\u20ac\" },\n+    \"copyright\" : { regex: /&(copy|#169);/g, val: \"\u00a9\" },\n+    \"reg\" : { regex: /&(reg|#174);/g, val: \"\u00ae\" },\n+    \"inr\" : { regex: /&(inr|#8377);/g, val: \"\u20b9\" },\n+};\n+\n+class EntitiesParser{\n+    constructor(replaceHtmlEntities) {\n+      this.replaceHtmlEntities = replaceHtmlEntities;\n+      this.docTypeEntities = {};\n+      this.lastEntities = {\n+        \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n+        \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n+        \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n+        \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n+      };\n+    }\n+\n+    addExternalEntities(externalEntities){\n+        const entKeys = Object.keys(externalEntities);\n+        for (let i = 0; i < entKeys.length; i++) {\n+          const ent = entKeys[i];\n+          this.addExternalEntity(ent,externalEntities[ent])\n+        }\n+    }\n+    addExternalEntity(key,val){\n+      validateEntityName(key);\n+      if(val.indexOf(\"&\") !== -1) {\n+        reportWarning(`Entity ${key} is not added as '&' is found in value;`)\n+        return;\n+      }else{\n+        this.lastEntities[ent] = {\n+          regex: new RegExp(\"&\"+key+\";\",\"g\"),\n+          val : val\n+        }\n+      }\n+    }\n+\n+    addDocTypeEntities(entities){\n+        const entKeys = Object.keys(entities);\n+        for (let i = 0; i < entKeys.length; i++) {\n+          const ent = entKeys[i];\n+          this.docTypeEntities[ent] = {\n+             regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n+             val : entities[ent]\n+          }\n+        }\n+    }\n+\n+    parse(val){\n+        return this.replaceEntitiesValue(val)\n+    }\n+\n+    /**\n+     * 1. Replace DOCTYPE entities \n+     * 2. Replace external entities \n+     * 3. Replace HTML entities if asked\n+     * @param {string} val \n+     */\n+    replaceEntitiesValue(val){\n+        if(typeof val === \"string\" && val.length > 0){\n+            for(let entityName in this.docTypeEntities){\n+                const entity = this.docTypeEntities[entityName];\n+                val = val.replace( entity.regx, entity.val);\n+              }\n+              for(let entityName in this.lastEntities){\n+                const entity = this.lastEntities[entityName];\n+                val = val.replace( entity.regex, entity.val);\n+              }\n+              if(this.replaceHtmlEntities){\n+                for(let entityName in htmlEntities){\n+                  const entity = htmlEntities[entityName];\n+                  val = val.replace( entity.regex, entity.val);\n+                }\n+              }\n+            val = val.replace( ampEntity.regex, ampEntity.val);\n+        }\n+        return val;\n+    }\n+};\n+\n+//an entity name should not contains special characters that may be used in regex\n+//Eg !?\\\\\\/[]$%{}^&*()<>\n+const specialChar = \"!?\\\\\\/[]$%{}^&*()<>|+\";\n+\n+function validateEntityName(name){\n+    for (let i = 0; i < specialChar.length; i++) {\n+        const ch = specialChar[i];\n+        if(name.indexOf(ch) !== -1) throw new Error(`Invalid character ${ch} in entity name`);\n+    }\n+    return name;\n+}\n+\n+module.exports = EntitiesParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/OptionsBuilder.js",
          "status": "added",
          "additions": 73,
          "deletions": 0,
          "patch": "@@ -0,0 +1,73 @@\n+\n+const JsArrBuilder = require(\"./OutputBuilders/JsArrBuilder\");\n+\n+const defaultOptions = {\n+  preserveOrder: false,\n+  removeNSPrefix: false, // remove NS from tag name or attribute name if true\n+  //ignoreRootElement : false,\n+  stopNodes: [], //nested tags will not be parsed even for errors\n+  // isArray: () => false, //User will set it\n+  htmlEntities: false,\n+  // skipEmptyListItem: false\n+  tags:{\n+    unpaired: [],\n+    nameFor:{\n+      cdata: false,\n+      comment: false,\n+      text: '#text'\n+    },\n+    separateTextProperty: false,\n+    valueParsers: []\n+  },\n+  attributes:{\n+    ignore: false,\n+    booleanType: true,\n+    entities: true\n+  },\n+\n+  // select: [\"img[src]\"],\n+  // stop: [\"anim\", \"[ads]\"]\n+  only: [], // rest tags will be skipped. It will result in flat array\n+  hierarchy: false, //will be used when a particular tag is set to be parsed.\n+  skip: [], // will be skipped from parse result. on('skip') will be triggered\n+\n+  select: [], // on('select', tag => tag ) will be called if match\n+  stop: [], //given tagPath will not be parsed. innerXML will be set as string value\n+  OutputBuilder: new JsArrBuilder(),\n+};\n+   \n+const buildOptions = function(options) {\n+  const finalOptions = { ... defaultOptions};\n+  finalOptions.tags.valueParsers.push(\"trim\");\n+  finalOptions.tags.valueParsers.push(\"entities\");\n+  if(!this.preserveOrder)\n+    finalOptions.tags.valueParsers.push(\"join\");\n+  finalOptions.tags.valueParsers.push(\"boolean\");\n+  finalOptions.tags.valueParsers.push(\"number\");\n+  finalOptions.tags.valueParsers.push(\"currency\");\n+  finalOptions.tags.valueParsers.push(\"date\");\n+  copyProperties(finalOptions,options)\n+  return  finalOptions;\n+};\n+\n+function copyProperties(target, source) {\n+  for (let key in source) {\n+    if (source.hasOwnProperty(key)) {\n+      if (key === 'OutputBuilder') {\n+        target[key] = source[key];\n+      }else if (typeof source[key] === 'object' && !Array.isArray(source[key])) {\n+        // Recursively copy nested properties\n+        if (typeof target[key] === 'undefined') {\n+          target[key] = {};\n+        }\n+        copyProperties(target[key], source[key]);\n+      } else {\n+        // Copy non-nested properties\n+        target[key] = source[key];\n+      }\n+    }\n+  }\n+}\n+\n+exports.buildOptions = buildOptions;\n+exports.defaultOptions = defaultOptions;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/OutputBuilders/BaseOutputBuilder.js",
          "status": "added",
          "additions": 69,
          "deletions": 0,
          "patch": "@@ -0,0 +1,69 @@\n+class BaseOutputBuilder{\n+  constructor(){\n+    // this.attributes = {};\n+  }\n+\n+  addAttribute(name, value){\n+    if(this.options.onAttribute){\n+      //TODO: better to pass tag path\n+      const v = this.options.onAttribute(name, value, this.tagName);\n+      if(!v) this.attributes[v.name] = v.value;\n+    }else{\n+      name = this.options.attributes.prefix + name + this.options.attributes.suffix;\n+      this.attributes[name] = this.parseValue(value, this.options.attributes.valueParsers);\n+    }\n+  }\n+\n+  /**\n+   * parse value by chain of parsers\n+   * @param {string} val \n+   * @returns {any} parsed value if matching parser found\n+   */\n+    parseValue = function(val, valParsers){\n+      for (let i = 0; i < valParsers.length; i++) {\n+        let valParser = this.registeredParsers[valParsers[i]];\n+        if(valParser){\n+          val = valParser.parse(val);\n+          // if(!valParser.chainable) break;\n+        }\n+      }\n+      return val;\n+    }\n+\n+  /**\n+   * To add a nested empty tag.\n+   * @param {string} key \n+   * @param {any} val \n+   */\n+  _addChild(key, val){}\n+\n+  /**\n+   * skip the comment if property is not set\n+   */\n+  addComment(text){\n+    if(this.options.nameFor.comment)\n+      this._addChild(this.options.nameFor.comment, text);\n+  }\n+\n+  //store CDATA separately if property is set\n+  //otherwise add to tag's value\n+  addCdata(text){\n+    if (this.options.nameFor.cdata) {\n+      this._addChild(this.options.nameFor.cdata, text);\n+    } else {\n+      this.addRawValue(text || \"\");\n+    }\n+  }\n+\n+  addRawValue = text => this.addValue(text);\n+\n+  addDeclaration(){\n+    if(!this.options.declaration){\n+    }else{\n+      this.addPi(\"?xml\");\n+    }\n+    this.attributes = {}\n+  }\n+}\n+\n+module.exports = BaseOutputBuilder;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/OutputBuilders/JsArrBuilder.js",
          "status": "added",
          "additions": 102,
          "deletions": 0,
          "patch": "@@ -0,0 +1,102 @@\n+const {buildOptions,registerCommonValueParsers} = require(\"./ParserOptionsBuilder\");\n+\n+class OutputBuilder{\n+  constructor(options){\n+    this.options = buildOptions(options);\n+      this.registeredParsers = registerCommonValueParsers();\n+    }\n+    \n+    registerValueParser(name,parserInstance){//existing name will override the parser without warning\n+      this.registeredParsers[name] = parserInstance;\n+    }\n+\n+  getInstance(){\n+    return new JsArrBuilder(this.options, this.registeredParsers);\n+  }\n+}\n+\n+const rootName = '!js_arr';\n+const BaseOutputBuilder = require(\"./BaseOutputBuilder\");\n+\n+class JsArrBuilder extends BaseOutputBuilder{\n+\n+  constructor(options,registeredParsers) {\n+    super();\n+    this.tagsStack = [];\n+    this.options = options;\n+    this.registeredParsers = registeredParsers;\n+\n+    this.root = new Node(rootName);\n+    this.currentNode = this.root;\n+    this.attributes = {};\n+  }\n+\n+  addTag(tag){\n+    //when a new tag is added, it should be added as child of current node\n+    //TODO: shift this check to the parser\n+    if(tag.name === \"__proto__\") tag.name = \"#__proto__\";\n+\n+    this.tagsStack.push(this.currentNode);\n+    this.currentNode = new Node(tag.name, this.attributes);\n+    this.attributes = {};\n+  }\n+\n+  /**\n+   * Check if the node should be added by checking user's preference\n+   * @param {Node} node \n+   * @returns boolean: true if the node should not be added\n+   */\n+  closeTag(){\n+    const node = this.currentNode;\n+    this.currentNode = this.tagsStack.pop(); //set parent node in scope\n+    if(this.options.onClose !== undefined){\n+      //TODO TagPathMatcher \n+      const resultTag = this.options.onClose(node, \n+        new TagPathMatcher(this.tagsStack,node));\n+\n+      if(resultTag) return;\n+    }\n+    this.currentNode.child.push(node);  //to parent node\n+  }\n+\n+  //Called by parent class methods\n+  _addChild(key, val){\n+    // if(key === \"__proto__\") tagName = \"#__proto__\";\n+    this.currentNode.child.push( {[key]: val });\n+    // this.currentNode.leafType = false;\n+  }\n+\n+  /**\n+   * Add text value child node \n+   * @param {string} text \n+   */\n+  addValue(text){\n+    this.currentNode.child.push( {[this.options.nameFor.text]: this.parseValue(text, this.options.tags.valueParsers) });\n+  }\n+\n+  addPi(name){\n+    //TODO: set pi flag\n+    if(!this.options.ignorePiTags){\n+      const node = new Node(name, this.attributes);\n+      this.currentNode[\":@\"] = this.attributes;\n+      this.currentNode.child.push(node);\n+    }\n+    this.attributes = {};\n+  }\n+  getOutput(){\n+    return this.root.child[0];\n+  }\n+}\n+\n+\n+\n+class Node{\n+  constructor(tagname, attributes){\n+    this.tagname = tagname;\n+    this.child = []; //nested tags, text, cdata, comments\n+    if(attributes && Object.keys(attributes).length > 0)\n+      this[\":@\"] = attributes;\n+  }\n+}\n+\n+module.exports = OutputBuilder;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/OutputBuilders/JsMinArrBuilder.js",
          "status": "added",
          "additions": 101,
          "deletions": 0,
          "patch": "@@ -0,0 +1,101 @@\n+const {buildOptions,registerCommonValueParsers} = require(\"./ParserOptionsBuilder\");\n+\n+class OutputBuilder{\n+  constructor(options){\n+    this.options = buildOptions(options);\n+      this.registeredParsers = registerCommonValueParsers();\n+    }\n+    \n+    registerValueParser(name,parserInstance){//existing name will override the parser without warning\n+      this.registeredParsers[name] = parserInstance;\n+    }\n+\n+  getInstance(){\n+    return new JsMinArrBuilder(this.options, this.registeredParsers);\n+  }\n+}\n+\n+const BaseOutputBuilder = require(\"./BaseOutputBuilder\");\n+const rootName = '^';\n+\n+class JsMinArrBuilder extends BaseOutputBuilder{\n+\n+  constructor(options,registeredParsers) {\n+    super();\n+    this.tagsStack = [];\n+    this.options = options;\n+    this.registeredParsers = registeredParsers;\n+\n+    this.root = {[rootName]: []};\n+    this.currentNode = this.root;\n+    this.currentNodeTagName = rootName;\n+    this.attributes = {};\n+  }\n+\n+  addTag(tag){\n+    //when a new tag is added, it should be added as child of current node\n+    //TODO: shift this check to the parser\n+    if(tag.name === \"__proto__\") tag.name = \"#__proto__\";\n+\n+    this.tagsStack.push([this.currentNodeTagName,this.currentNode]); //this.currentNode is parent node here\n+    this.currentNodeTagName = tag.name;\n+    this.currentNode = { [tag.name]:[]}\n+    if(Object.keys(this.attributes).length > 0){\n+      this.currentNode[\":@\"] = this.attributes;\n+      this.attributes = {};\n+    }\n+  }\n+\n+  /**\n+   * Check if the node should be added by checking user's preference\n+   * @param {Node} node \n+   * @returns boolean: true if the node should not be added\n+   */\n+  closeTag(){\n+    const node = this.currentNode;\n+    const nodeName = this.currentNodeTagName;\n+    const arr = this.tagsStack.pop(); //set parent node in scope\n+    this.currentNodeTagName = arr[0];\n+    this.currentNode = arr[1];\n+\n+    if(this.options.onClose !== undefined){\n+      //TODO TagPathMatcher \n+      const resultTag = this.options.onClose(node, \n+        new TagPathMatcher(this.tagsStack,node));\n+\n+      if(resultTag) return;\n+    }\n+    this.currentNode[this.currentNodeTagName].push(node);  //to parent node\n+  }\n+\n+  //Called by parent class methods\n+  _addChild(key, val){\n+    // if(key === \"__proto__\") tagName = \"#__proto__\";\n+    this.currentNode.push( {[key]: val });\n+    // this.currentNode.leafType = false;\n+  }\n+\n+  /**\n+   * Add text value child node \n+   * @param {string} text \n+   */\n+  addValue(text){\n+    this.currentNode[this.currentNodeTagName].push( {[this.options.nameFor.text]: this.parseValue(text, this.options.tags.valueParsers) });\n+  }\n+\n+  addPi(name){\n+    if(!this.options.ignorePiTags){\n+      const node = { [name]:[]}\n+      if(this.attributes){\n+        node[\":@\"] = this.attributes;\n+      }\n+      this.currentNode.push(node);\n+    }\n+    this.attributes = {};\n+  }\n+  getOutput(){\n+    return this.root[rootName];\n+  }\n+}\n+\n+module.exports = OutputBuilder;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/OutputBuilders/JsObjBuilder.js",
          "status": "added",
          "additions": 155,
          "deletions": 0,
          "patch": "@@ -0,0 +1,155 @@\n+\n+\n+const {buildOptions,registerCommonValueParsers} = require(\"./ParserOptionsBuilder\");\n+\n+class OutputBuilder{\n+  constructor(options){\n+      this.options = buildOptions(options);\n+      this.registeredParsers = registerCommonValueParsers();\n+  }\n+\n+  registerValueParser(name,parserInstance){//existing name will override the parser without warning\n+    this.registeredParsers[name] = parserInstance;\n+  }\n+\n+  getInstance(){\n+    return new JsObjBuilder(this.options, this.registeredParsers);\n+  }\n+}\n+\n+const BaseOutputBuilder = require(\"./BaseOutputBuilder\");\n+const rootName = '^';\n+\n+class JsObjBuilder extends BaseOutputBuilder{\n+\n+  constructor(options,registeredParsers) {\n+    super();\n+    //hold the raw detail of a tag and sequence with reference to the output\n+    this.tagsStack = [];\n+    this.options = options;\n+    this.registeredParsers = registeredParsers;\n+\n+    this.root = {};\n+    this.parent = this.root;\n+    this.tagName = rootName;\n+    this.value = {};\n+    this.textValue = \"\";\n+    this.attributes = {};\n+  }\n+\n+  addTag(tag){\n+\n+    let value = \"\";\n+    if( !isEmpty(this.attributes)){\n+      value = {};\n+      if(this.options.attributes.groupBy){\n+        value[this.options.attributes.groupBy] = this.attributes;\n+      }else{\n+        value = this.attributes;\n+      }\n+    }\n+\n+    this.tagsStack.push([this.tagName, this.textValue, this.value]); //parent tag, parent text value, parent tag value (jsobj)\n+    this.tagName = tag.name;\n+    this.value = value;\n+    this.textValue = \"\";\n+    this.attributes = {};\n+  }\n+\n+  /**\n+   * Check if the node should be added by checking user's preference\n+   * @param {Node} node \n+   * @returns boolean: true if the node should not be added\n+   */\n+  closeTag(){\n+    const tagName = this.tagName;\n+    let value = this.value;\n+    let textValue = this.textValue;\n+\n+    //update tag text value\n+    if(typeof value !== \"object\" && !Array.isArray(value)){\n+      value = this.parseValue(textValue.trim(), this.options.tags.valueParsers);\n+    }else if(textValue.length > 0){\n+      value[this.options.nameFor.text] = this.parseValue(textValue.trim(), this.options.tags.valueParsers);\n+    }\n+\n+    \n+    let resultTag= {\n+      tagName: this.tagName,\n+      value: value\n+    };\n+\n+    if(this.options.onTagClose !== undefined){\n+      //TODO TagPathMatcher \n+      resultTag = this.options.onClose(this.tagName, value, this.textValue, new TagPathMatcher(this.tagsStack,node));\n+\n+      if(!resultTag) return;\n+    }\n+\n+    //set parent node in scope\n+    let arr = this.tagsStack.pop(); \n+    let parentTag = arr[2];\n+    parentTag=this._addChildTo(resultTag.tagName, resultTag.value, parentTag);\n+\n+    this.tagName = arr[0];\n+    this.textValue = arr[1];\n+    this.value = parentTag;\n+  }\n+\n+  _addChild(key, val){\n+    if(typeof this.value === \"string\"){\n+      this.value = { [this.options.nameFor.text] : this.value };\n+    }\n+\n+    this._addChildTo(key, val, this.value);\n+    // this.currentNode.leafType = false;\n+    this.attributes = {};\n+  }\n+\n+  _addChildTo(key, val, node){\n+    if(typeof node === 'string') node = {};\n+    if(!node[key]){\n+      node[key] = val;\n+    }else{ //Repeated\n+      if(!Array.isArray(node[key])){ //but not stored as array\n+        node[key] = [node[key]];\n+      }\n+      node[key].push(val);\n+    }\n+    return node;\n+  }\n+\n+\n+  /**\n+   * Add text value child node \n+   * @param {string} text \n+   */\n+  addValue(text){\n+    //TODO: use bytes join\n+    if(this.textValue.length > 0) this.textValue += \" \" + text;\n+    else this.textValue = text;\n+  }\n+\n+  addPi(name){\n+    let value = \"\";\n+    if( !isEmpty(this.attributes)){\n+      value = {};\n+      if(this.options.attributes.groupBy){\n+        value[this.options.attributes.groupBy] = this.attributes;\n+      }else{\n+        value = this.attributes;\n+      }\n+    }\n+    this._addChild(name, value);\n+    \n+  }\n+  getOutput(){\n+    return this.value;\n+  }\n+}\n+\n+function isEmpty(obj) {\n+  return Object.keys(obj).length === 0;\n+}\n+\n+module.exports = OutputBuilder;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/OutputBuilders/ParserOptionsBuilder.js",
          "status": "added",
          "additions": 94,
          "deletions": 0,
          "patch": "@@ -0,0 +1,94 @@\n+const trimParser = require(\"../valueParsers/trim\")\n+const booleanParser = require(\"../valueParsers/booleanParser\")\n+const currencyParser = require(\"../valueParsers/currency\")\n+const numberParser = require(\"../valueParsers/number\")\n+\n+const defaultOptions={\n+  nameFor:{\n+    text: \"#text\",\n+    comment: \"\",\n+    cdata: \"\",\n+  },\n+  // onTagClose: () => {},\n+  // onAttribute: () => {},\n+  piTag: false,\n+  declaration: false, //\"?xml\"\n+  tags: {\n+    valueParsers: [\n+      // \"trim\",\n+      // \"boolean\",\n+      // \"number\",\n+      // \"currency\",\n+      // \"date\",\n+    ]\n+  },\n+  attributes:{\n+    prefix: \"@_\",\n+    suffix: \"\",\n+    groupBy: \"\",\n+    \n+    valueParsers: [\n+      // \"trim\",\n+      // \"boolean\",\n+      // \"number\",\n+      // \"currency\",\n+      // \"date\",\n+    ]\n+  }\n+}\n+function buildOptions(options){\n+  //clone\n+  const finalOptions = { ... defaultOptions};\n+\n+  //add config missed in cloning\n+  finalOptions.tags.valueParsers.push(\"trim\")\n+  finalOptions.tags.valueParsers.push(\"boolean\")\n+  finalOptions.tags.valueParsers.push(\"number\")\n+  finalOptions.tags.valueParsers.push(\"currency\")\n+\n+  //add config missed in cloning\n+  finalOptions.attributes.valueParsers.push(\"trim\")\n+  finalOptions.attributes.valueParsers.push(\"boolean\")\n+  finalOptions.attributes.valueParsers.push(\"number\")\n+  finalOptions.attributes.valueParsers.push(\"currency\")\n+\n+  copyProperties(finalOptions,options);\n+  return finalOptions;\n+}\n+\n+function copyProperties(target, source) {\n+  for (let key in source) {\n+    if (source.hasOwnProperty(key)) {\n+      if (typeof source[key] === 'object' && !Array.isArray(source[key])) {\n+        // Recursively copy nested properties\n+        if (typeof target[key] === 'undefined') {\n+          target[key] = {};\n+        }\n+        copyProperties(target[key], source[key]);\n+      } else {\n+        // Copy non-nested properties\n+        target[key] = source[key];\n+      }\n+    }\n+  }\n+}\n+\n+function registerCommonValueParsers(){\n+  return {\n+    \"trim\": new trimParser(),\n+    // \"join\": this.entityParser.parse,\n+    \"boolean\": new booleanParser(),\n+    \"number\": new numberParser({\n+          hex: true,\n+          leadingZeros: true,\n+          eNotation: true\n+        }),\n+    \"currency\": new currencyParser(),\n+    // \"date\": this.entityParser.parse,\n+  }\n+}\n+\n+module.exports = {\n+  buildOptions : buildOptions,\n+  registerCommonValueParsers: registerCommonValueParsers\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/Report.js",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "src/v5/TagPath.js",
          "status": "added",
          "additions": 81,
          "deletions": 0,
          "patch": "@@ -0,0 +1,81 @@\n+class TagPath{\n+  constructor(pathStr){\n+    let text = \"\";\n+    let tName = \"\";\n+    let pos;\n+    let aName = \"\";\n+    let aVal = \"\";\n+    this.stack = []\n+\n+    for (let i = 0; i < pathStr.length; i++) {\n+      let ch = pathStr[i];\n+      if(ch === \" \") {\n+        if(text.length === 0) continue;        \n+        tName = text; text = \"\";\n+      }else if(ch === \"[\"){\n+        if(tName.length === 0){\n+          tName = text; text = \"\";\n+        }\n+        i++;\n+        for (; i < pathStr.length; i++) {\n+          ch = pathStr[i];\n+          if(ch=== \"=\") continue;\n+          else if(ch=== \"]\") {aName = text.trim(); text=\"\"; break; i--;}\n+          else if(ch === \"'\" || ch === '\"'){\n+            let attrEnd = pathStr.indexOf(ch,i+1);\n+            aVal = pathStr.substring(i+1, attrEnd);\n+            i = attrEnd;\n+          }else{\n+            text +=ch;\n+          }\n+        }\n+      }else if(ch !== \" \" && text.length === 0 && tName.length > 0){//reading tagName\n+        //save previous tag\n+        this.stack.push(new TagPathNode(tName,pos,aName,aVal));\n+        text = ch; tName = \"\"; aName = \"\"; aVal = \"\";\n+      }else{\n+        text+=ch;\n+      }\n+    }\n+\n+    //last tag in the path\n+    if(tName.length >0 || text.length>0){\n+      this.stack.push(new TagPathNode(text||tName,pos,aName,aVal));\n+    }\n+  }\n+\n+  match(tagStack,node){\n+    if(this.stack[0].name !== \"*\"){\n+      if(this.stack.length !== tagStack.length +1) return false;\n+  \n+      //loop through tagPath and tagStack and match\n+      for (let i = 0; i < this.tagStack.length; i++) {\n+        if(!this.stack[i].match(tagStack[i])) return false;\n+      }\n+    }\n+    if(!this.stack[this.stack.length - 1].match(node)) return false;\n+    return true;\n+  }\n+}\n+\n+class TagPathNode{\n+  constructor(name,position,attrName,attrVal){\n+    this.name = name;\n+    this.position = position;\n+    this.attrName = attrName,\n+    this.attrVal = attrVal;\n+  }\n+\n+  match(node){\n+    let matching = true;\n+    matching = node.name === this.name;\n+    if(this.position) matching = node.position === this.position;\n+    if(this.attrName) matching = node.attrs[this.attrName !== undefined];\n+    if(this.attrVal) matching = node.attrs[this.attrName !== this.attrVal];\n+    return matching;\n+  }\n+}\n+\n+// console.log((new TagPath(\"* b[b]\")).stack);\n+// console.log((new TagPath(\"a[a] b[b] c\")).stack);\n+// console.log((new TagPath(\" b [ b= 'cf  sdadwa' ] a  \")).stack);\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/TagPathMatcher.js",
          "status": "added",
          "additions": 15,
          "deletions": 0,
          "patch": "@@ -0,0 +1,15 @@\n+const TagPath = require(\"./TagPath\");\n+\n+class TagPathMatcher{\n+  constructor(stack,node){\n+    this.stack = stack;\n+    this.node= node;\n+  }\n+\n+  match(path){\n+    const tagPath = new TagPath(path);\n+    return tagPath.match(this.stack, this.node);\n+  }\n+}\n+\n+module.exports = TagPathMatcher;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/XMLParser.js",
          "status": "added",
          "additions": 85,
          "deletions": 0,
          "patch": "@@ -0,0 +1,85 @@\n+const { buildOptions} = require(\"./OptionsBuilder\");\n+const Xml2JsParser = require(\"./Xml2JsParser\");\n+\n+class XMLParser{\n+    \n+    constructor(options){\n+        this.externalEntities = {};\n+        this.options = buildOptions(options);\n+        // console.log(this.options)\n+    }\n+    /**\n+     * Parse XML data string to JS object \n+     * @param {string|Buffer} xmlData \n+     * @param {boolean|Object} validationOption \n+     */\n+    parse(xmlData){\n+        if(Array.isArray(xmlData) && xmlData.byteLength !== undefined){\n+            return this.parse(xmlData);\n+        }else if( xmlData.toString){\n+            xmlData = xmlData.toString();\n+        }else{\n+            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n+        }\n+        // if( validationOption){\n+        //     if(validationOption === true) validationOption = {}; //validate with default options\n+            \n+        //     const result = validator.validate(xmlData, validationOption);\n+        //     if (result !== true) {\n+        //       throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n+        //     }\n+        //   }\n+        const parser = new Xml2JsParser(this.options);\n+        parser.entityParser.addExternalEntities(this.externalEntities);\n+        return parser.parse(xmlData);\n+    }\n+    /**\n+     * Parse XML data buffer to JS object \n+     * @param {string|Buffer} xmlData \n+     * @param {boolean|Object} validationOption \n+     */\n+    parseBytesArr(xmlData){\n+        if(Array.isArray(xmlData) && xmlData.byteLength !== undefined){\n+        }else{\n+            throw new Error(\"XML data is accepted in Bytes[] form.\")\n+        }\n+        const parser = new Xml2JsParser(this.options);\n+        parser.entityParser.addExternalEntities(this.externalEntities);\n+        return parser.parseBytesArr(xmlData);\n+    }\n+    /**\n+     * Parse XML data stream to JS object \n+     * @param {fs.ReadableStream} xmlDataStream \n+     */\n+    parseStream(xmlDataStream){\n+        if(!isStream(xmlDataStream)) throw new Error(\"FXP: Invalid stream input\");\n+        \n+        const orderedObjParser = new Xml2JsParser(this.options);\n+        orderedObjParser.entityParser.addExternalEntities(this.externalEntities);\n+        return orderedObjParser.parseStream(xmlDataStream);\n+    }\n+\n+    /**\n+     * Add Entity which is not by default supported by this library\n+     * @param {string} key \n+     * @param {string} value \n+     */\n+    addEntity(key, value){\n+        if(value.indexOf(\"&\") !== -1){\n+            throw new Error(\"Entity value can't have '&'\")\n+        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n+            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n+        }else if(value === \"&\"){\n+            throw new Error(\"An entity with value '&' is not permitted\");\n+        }else{\n+            this.externalEntities[key] = value;\n+        }\n+    }\n+}\n+\n+function isStream(stream){\n+    if(stream && typeof stream.read === \"function\" && typeof stream.on === \"function\" && typeof stream.readableEnded === \"boolean\") return true;\n+    return false;\n+}\n+\n+module.exports = XMLParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/Xml2JsParser.js",
          "status": "added",
          "additions": 237,
          "deletions": 0,
          "patch": "@@ -0,0 +1,237 @@\n+const StringSource = require(\"./inputSource/StringSource\");\n+const BufferSource = require(\"./inputSource/BufferSource\");\n+const {readTagExp,readClosingTagName} = require(\"./XmlPartReader\");\n+const {readComment, readCdata,readDocType,readPiTag} = require(\"./XmlSpecialTagsReader\");\n+const TagPath = require(\"./TagPath\");\n+const TagPathMatcher = require(\"./TagPathMatcher\");\n+const EntitiesParser = require('./EntitiesParser');\n+\n+//To hold the data of current tag\n+//This is usually used to compare jpath expression against current tag\n+class TagDetail{\n+  constructor(name){\n+    this.name = name;\n+    this.position = 0;\n+    // this.attributes = {};\n+  }\n+}\n+\n+class Xml2JsParser {\n+    constructor(options) {\n+      this.options = options;\n+      \n+      this.currentTagDetail = null;\n+      this.tagTextData = \"\";\n+      this.tagsStack = [];\n+      this.entityParser = new EntitiesParser(options.htmlEntities);\n+      this.stopNodes = [];\n+      for (let i = 0; i < this.options.stopNodes.length; i++) {\n+        this.stopNodes.push(new TagPath(this.options.stopNodes[i]));\n+      }\n+    }\n+\n+    parse(strData) {\n+        this.source = new StringSource(strData);\n+        this.parseXml();\n+        return this.outputBuilder.getOutput();\n+    }\n+    parseBytesArr(data) {\n+        this.source = new BufferSource(data );\n+        this.parseXml();\n+        return this.outputBuilder.getOutput();\n+    }\n+  \n+    parseXml() {\n+      //TODO: Separate TagValueParser as separate class. So no scope issue in node builder class \n+\n+      //OutputBuilder should be set in XML Parser\n+      this.outputBuilder = this.options.OutputBuilder.getInstance(this.options);\n+      this.root = { root: true};\n+      this.currentTagDetail = this.root;\n+\n+      while(this.source.canRead()){\n+        let ch = this.source.readCh();\n+        if (ch === \"\") break;\n+        \n+        if(ch === \"<\"){//tagStart\n+          let nextChar = this.source.readChAt(0);\n+          if (nextChar === \"\" ) throw new Error(\"Unexpected end of source\");\n+          \n+        \n+          if(nextChar === \"!\" || nextChar === \"?\"){\n+            this.source.updateBufferBoundary();\n+            //previously collected text should be added to current node\n+            this.addTextNode(); \n+            \n+            this.readSpecialTag(nextChar);// Read DOCTYPE, comment, CDATA, PI tag\n+          }else if(nextChar === \"/\"){\n+            this.source.updateBufferBoundary();\n+            this.readClosingTag();\n+            // console.log(this.source.buffer.length, this.source.readable);\n+            // console.log(this.tagsStack.length);\n+          }else{//opening tag\n+            this.readOpeningTag();\n+          }\n+        }else{\n+          this.tagTextData += ch;\n+        }\n+      }//End While loop\n+      if(this.tagsStack.length > 0 || ( this.tagTextData !== \"undefined\" && this.tagTextData.trimEnd().length > 0) ) throw new Error(\"Unexpected data in the end of document\");\n+    }\n+  \n+    /**\n+     * read closing paired tag. Set parent tag in scope.\n+     * skip a node on user's choice\n+     */\n+    readClosingTag(){\n+      const tagName = this.processTagName(readClosingTagName(this.source));\n+      // console.log(tagName, this.tagsStack.length);\n+      this.validateClosingTag(tagName);\n+      // All the text data collected, belongs to current tag.\n+      if(!this.currentTagDetail.root) this.addTextNode();\n+      this.outputBuilder.closeTag();\n+      // Since the tag is closed now, parent tag comes in scope\n+      this.currentTagDetail = this.tagsStack.pop(); \n+    }\n+\n+    validateClosingTag(tagName){\n+      // This can't be unpaired tag, or a stop tag.\n+      if(this.isUnpaired(tagName) || this.isStopNode(tagName)) throw new Error(`Unexpected closing tag '${tagName}'`);\n+      // This must match with last opening tag\n+      else if(tagName !== this.currentTagDetail.name) \n+        throw new Error(`Unexpected closing tag '${tagName}' expecting '${this.currentTagDetail.name}'`)\n+    }\n+\n+    /**\n+     * Read paired, unpaired, self-closing, stop and special tags.\n+     * Create a new node\n+     * Push paired tag in stack.\n+     */\n+    readOpeningTag(){\n+      //save previously collected text data to current node\n+      this.addTextNode();\n+\n+      //create new tag\n+      let tagExp = readTagExp(this, \">\" );\n+      \n+      // process and skip from tagsStack For unpaired tag, self closing tag, and stop node\n+      const tagDetail = new TagDetail(tagExp.tagName);\n+      if(this.isUnpaired(tagExp.tagName)) {\n+        //TODO: this will lead 2 extra stack operation\n+        this.outputBuilder.addTag(tagDetail);\n+        this.outputBuilder.closeTag();\n+      } else if(tagExp.selfClosing){\n+        this.outputBuilder.addTag(tagDetail);\n+        this.outputBuilder.closeTag();\n+      } else if(this.isStopNode(this.currentTagDetail)){\n+        // TODO: let's user set a stop node boundary detector for complex contents like script tag\n+        //TODO: pass tag name only to avoid string operations\n+        const content = source.readUptoCloseTag(`</${tagExp.tagName}`);\n+        this.outputBuilder.addTag(tagDetail);\n+        this.outputBuilder.addValue(content);\n+        this.outputBuilder.closeTag();\n+      }else{//paired tag\n+        //set new nested tag in scope.\n+        this.tagsStack.push(this.currentTagDetail);\n+        this.outputBuilder.addTag(tagDetail);\n+        this.currentTagDetail = tagDetail;\n+      }\n+      // console.log(tagExp.tagName,this.tagsStack.length);\n+      // this.options.onClose()\n+\n+    }\n+\n+    readSpecialTag(startCh){\n+      if(startCh == \"!\"){\n+        let nextChar = this.source.readCh();\n+        if (nextChar === null || nextChar === undefined) throw new Error(\"Unexpected ending of the source\");\n+        \n+        if(nextChar === \"-\"){//comment\n+          readComment(this);\n+        }else if(nextChar === \"[\"){//CDATA\n+          readCdata(this);\n+        }else if(nextChar === \"D\"){//DOCTYPE\n+          readDocType(this);\n+        }\n+      }else if(startCh === \"?\"){\n+        readPiTag(this);\n+      }else{\n+        throw new Error(`Invalid tag '<${startCh}' at ${this.source.line}:${this.source.col}`)\n+      }\n+    }\n+    addTextNode = function() {\n+      // if(this.currentTagDetail){\n+        //save text as child node\n+        // if(this.currentTagDetail.tagname !== '!xml')\n+        if (this.tagTextData !== undefined && this.tagTextData !== \"\") { //store previously collected data as textNode\n+          if(this.tagTextData.trim().length > 0){\n+            //TODO: shift parsing to output builder\n+\n+            this.outputBuilder.addValue(this.replaceEntities(this.tagTextData));\n+          }\n+          this.tagTextData = \"\";\n+        }\n+      // }\n+    }\n+\n+    processAttrName(name){\n+      if(name === \"__proto__\") name  = \"#__proto__\";\n+      name = resolveNameSpace(name, this.removeNSPrefix);\n+      return name;\n+    }\n+    \n+    processTagName(name){\n+      if(name === \"__proto__\") name  = \"#__proto__\";\n+      name = resolveNameSpace(name, this.removeNSPrefix);\n+      return name;\n+    }\n+\n+    /**\n+     * Generate tags path from tagsStack\n+     */\n+    tagsPath(tagName){\n+      //TODO: return TagPath Object. User can call match method with path\n+      return \"\";\n+    }\n+\n+    isUnpaired(tagName){\n+      return this.options.tags.unpaired.indexOf(tagName) !== -1;\n+    }\n+\n+    /**\n+     * valid expressions are \n+     * tag nested\n+     * * nested\n+     * tag nested[attribute]\n+     * tag nested[attribute=\"\"]\n+     * tag nested[attribute!=\"\"]\n+     * tag nested:0 //for future\n+     * @param {string} tagName \n+     * @returns \n+     */\n+    isStopNode(node){\n+      for (let i = 0; i < this.stopNodes.length; i++) {\n+        const givenPath = this.stopNodes[i];\n+        if(givenPath.match(this.tagsStack, node)) return true;\n+      }\n+      return false \n+    }\n+\n+    replaceEntities(text){\n+      //TODO: if option is set then replace entities\n+      return this.entityParser.parse(text)\n+    }\n+}\n+\n+function resolveNameSpace(name, removeNSPrefix) {\n+  if (removeNSPrefix) {\n+    const parts = name.split(':');\n+    if(parts.length === 2){\n+      if (parts[0] === 'xmlns') return '';\n+      else return parts[1];\n+    }else reportError(`Multiple namespaces ${name}`)\n+  }\n+  return name;\n+}\n+\n+module.exports = Xml2JsParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/XmlPartReader.js",
          "status": "added",
          "additions": 212,
          "deletions": 0,
          "patch": "@@ -0,0 +1,212 @@\n+'use strict';\n+\n+/**\n+ * find paired tag for a stop node\n+ * @param {string} xmlDoc \n+ * @param {string} tagName \n+ * @param {number} i : start index\n+ */\n+function readStopNode(xmlDoc, tagName, i){\n+    const startIndex = i;\n+    // Starting at 1 since we already have an open tag\n+    let openTagCount = 1;\n+  \n+    for (; i < xmlDoc.length; i++) {\n+      if( xmlDoc[i] === \"<\"){ \n+        if (xmlDoc[i+1] === \"/\") {//close tag\n+            const closeIndex = findSubStrIndex(xmlDoc, \">\", i, `${tagName} is not closed`);\n+            let closeTagName = xmlDoc.substring(i+2,closeIndex).trim();\n+            if(closeTagName === tagName){\n+              openTagCount--;\n+              if (openTagCount === 0) {\n+                return {\n+                  tagContent: xmlDoc.substring(startIndex, i),\n+                  i : closeIndex\n+                }\n+              }\n+            }\n+            i=closeIndex;\n+          } else if(xmlDoc[i+1] === '?') { \n+            const closeIndex = findSubStrIndex(xmlDoc, \"?>\", i+1, \"StopNode is not closed.\")\n+            i=closeIndex;\n+          } else if(xmlDoc.substr(i + 1, 3) === '!--') { \n+            const closeIndex = findSubStrIndex(xmlDoc, \"-->\", i+3, \"StopNode is not closed.\")\n+            i=closeIndex;\n+          } else if(xmlDoc.substr(i + 1, 2) === '![') { \n+            const closeIndex = findSubStrIndex(xmlDoc, \"]]>\", i, \"StopNode is not closed.\") - 2;\n+            i=closeIndex;\n+          } else {\n+            const tagData = readTagExp(xmlDoc, i, '>')\n+  \n+            if (tagData) {\n+              const openTagName = tagData && tagData.tagName;\n+              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n+                openTagCount++;\n+              }\n+              i=tagData.closeIndex;\n+            }\n+          }\n+        }\n+    }//end for loop\n+}\n+\n+/**\n+ * Read closing tag name\n+ * @param {Source} source \n+ * @returns tag name\n+ */\n+function readClosingTagName(source){\n+  let text = \"\"; //temporary data\n+  while(source.canRead()){\n+    let ch = source.readCh();\n+    // if (ch === null || ch === undefined) break;\n+    // source.updateBuffer();\n+\n+    if (ch === \">\") return text.trimEnd();\n+    else text += ch;\n+  }\n+  throw new Error(`Unexpected end of source. Reading '${substr}'`);\n+}\n+\n+/**\n+ * Read XML tag and build attributes map\n+ * This function can be used to read normal tag, pi tag.\n+ * This function can't be used to read comment, CDATA, DOCTYPE.\n+ * Eg <tag attr = ' some\"' attr= \">\" bool>\n+ * @param {string} xmlDoc \n+ * @param {number} startIndex starting index\n+ * @returns tag expression includes tag name & attribute string \n+ */\n+function readTagExp(parser) {\n+  let inSingleQuotes = false;\n+  let inDoubleQuotes = false;\n+  let i;\n+  let EOE = false;\n+\n+  for (i = 0; parser.source.canRead(i); i++) {\n+    const char = parser.source.readChAt(i);\n+\n+    if (char === \"'\" && !inDoubleQuotes) {\n+      inSingleQuotes = !inSingleQuotes;\n+    } else if (char === '\"' && !inSingleQuotes) {\n+      inDoubleQuotes = !inDoubleQuotes;\n+    } else if (char === '>' && !inSingleQuotes && !inDoubleQuotes) {\n+      // If not inside quotes, stop reading at '>'\n+      EOE = true;\n+      break;\n+    }\n+\n+  }\n+  if(inSingleQuotes || inDoubleQuotes){\n+    throw new Error(\"Invalid attribute expression. Quote is not properly closed\");\n+  }else if(!EOE) throw new Error(\"Unexpected closing of source. Waiting for '>'\");\n+  \n+  \n+  const exp = parser.source.readStr(i);\n+  parser.source.updateBufferBoundary(i + 1);\n+  return buildTagExpObj(exp, parser)\n+}\n+\n+function readPiExp(parser) {\n+  let inSingleQuotes = false;\n+  let inDoubleQuotes = false;\n+  let i;\n+  let EOE = false;\n+\n+  for (i = 0; parser.source.canRead(i) ; i++) {\n+    const currentChar = parser.source.readChAt(i);\n+    const nextChar =  parser.source.readChAt(i+1);\n+\n+    if (currentChar === \"'\" && !inDoubleQuotes) {\n+      inSingleQuotes = !inSingleQuotes;\n+    } else if (currentChar === '\"' && !inSingleQuotes) {\n+      inDoubleQuotes = !inDoubleQuotes;\n+    }\n+\n+    if (!inSingleQuotes && !inDoubleQuotes) {\n+      if (currentChar === '?' && nextChar === '>') {\n+        EOE = true;\n+        break; // Exit the loop when '?>' is found\n+      }\n+    }\n+  }\n+  if(inSingleQuotes || inDoubleQuotes){\n+    throw new Error(\"Invalid attribute expression. Quote is not properly closed in PI tag expression\");\n+  }else if(!EOE) throw new Error(\"Unexpected closing of source. Waiting for '?>'\");\n+  \n+  if(!parser.options.attributes.ignore){\n+    //TODO: use regex to verify attributes if not set to ignore\n+  }\n+\n+  const exp = parser.source.readStr(i);\n+  parser.source.updateBufferBoundary(i + 1);\n+  return buildTagExpObj(exp, parser)\n+}\n+\n+function buildTagExpObj(exp, parser){\n+  const tagExp = {\n+    tagName: \"\",\n+    selfClosing: false\n+  };\n+  let attrsExp = \"\";\n+\n+  if(exp[exp.length -1] === \"/\") tagExp.selfClosing = true;\n+\n+  //separate tag name\n+  let i = 0;\n+  for (; i < exp.length; i++) {\n+    const char = exp[i];\n+    if(char === \" \"){\n+      tagExp.tagName = exp.substring(0, i);\n+      attrsExp = exp.substring(i + 1);\n+      break;\n+    }\n+  }\n+  //only tag\n+  if(tagExp.tagName.length === 0 && i === exp.length)tagExp.tagName = exp;\n+\n+  tagExp.tagName = tagExp.tagName.trimEnd();\n+\n+  if(!parser.options.attributes.ignore && attrsExp.length > 0){\n+    parseAttributesExp(attrsExp,parser)\n+  }\n+\n+  return tagExp;\n+}\n+\n+const attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n+\n+function parseAttributesExp(attrStr, parser) {\n+  const matches = getAllMatches(attrStr, attrsRegx);\n+  const len = matches.length; //don't make it inline\n+  for (let i = 0; i < len; i++) {\n+    let attrName = parser.processAttrName(matches[i][1]);\n+    let attrVal = parser.replaceEntities(matches[i][4] || true);\n+    \n+    parser.outputBuilder.addAttribute(attrName, attrVal);\n+  }\n+}\n+\n+\n+const getAllMatches = function(string, regex) {\n+  const matches = [];\n+  let match = regex.exec(string);\n+  while (match) {\n+    const allmatches = [];\n+    allmatches.startIndex = regex.lastIndex - match[0].length;\n+    const len = match.length;\n+    for (let index = 0; index < len; index++) {\n+      allmatches.push(match[index]);\n+    }\n+    matches.push(allmatches);\n+    match = regex.exec(string);\n+  }\n+  return matches;\n+};\n+\n+module.exports = {\n+    readStopNode: readStopNode,\n+    readClosingTagName: readClosingTagName,\n+    readTagExp: readTagExp,\n+    readPiExp: readPiExp,\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/XmlSpecialTagsReader.js",
          "status": "added",
          "additions": 118,
          "deletions": 0,
          "patch": "@@ -0,0 +1,118 @@\n+const {readPiExp} = require(\"./XmlPartReader\");\n+\n+function readCdata(parser){\n+  //<![ are already read till this point\n+  let str = parser.source.readStr(6); //CDATA[\n+  parser.source.updateBufferBoundary(6);\n+\n+  if(str !== \"CDATA[\") throw new Error(`Invalid CDATA expression at ${parser.source.line}:${parser.source.cols}`);\n+\n+  let text = parser.source.readUpto(\"]]>\");\n+  parser.outputBuilder.addCdata(text);\n+}\n+function readPiTag(parser){\n+  //<? are already read till this point\n+  let tagExp = readPiExp(parser, \"?>\");\n+  if(!tagExp) throw new Error(\"Invalid Pi Tag expression.\");\n+\n+  if (tagExp.tagName === \"?xml\") {//TODO: test if tagName is just xml\n+    parser.outputBuilder.addDeclaration();\n+  } else {\n+    parser.outputBuilder.addPi(\"?\"+tagExp.tagName);\n+  }\n+}\n+\n+function readComment(parser){\n+  //<!- are already read till this point\n+  let ch = parser.source.readCh();\n+  if(ch !== \"-\") throw new Error(`Invalid comment expression at ${parser.source.line}:${parser.source.cols}`);\n+\n+  let text = parser.source.readUpto(\"-->\");\n+  parser.outputBuilder.addComment(text);\n+}\n+\n+const DOCTYPE_tags = {\n+  \"EL\":/^EMENT\\s+([^\\s>]+)\\s+(ANY|EMPTY|\\(.+\\)\\s*$)/m,\n+  \"AT\":/^TLIST\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+[^\\s]+\\s+$/m,\n+  \"NO\":/^TATION.+$/m\n+}\n+function readDocType(parser){\n+  //<!D are already read till this point\n+  let str = parser.source.readStr(6); //OCTYPE\n+  parser.source.updateBufferBoundary(6);\n+\n+  if(str !== \"OCTYPE\") throw new Error(`Invalid DOCTYPE expression at ${parser.source.line}:${parser.source.cols}`);\n+\n+  let hasBody = false, lastch = \"\";\n+\n+  while(parser.source.canRead()){\n+    //TODO: use readChAt like used in partReader\n+    let ch = parser.source.readCh();\n+    if(hasBody){\n+      if (ch === '<') { //Determine the tag type\n+        let str = parser.source.readStr(2);\n+        parser.source.updateBufferBoundary(2);\n+        if(str === \"EN\"){ //ENTITY\n+          let str = parser.source.readStr(4);\n+          parser.source.updateBufferBoundary(4);\n+          if(str !== \"TITY\") throw new Error(\"Invalid DOCTYPE ENTITY expression\");\n+\n+          registerEntity(parser);\n+        }else if(str === \"!-\") {//comment\n+          readComment(parser);\n+        }else{ //ELEMENT, ATTLIST, NOTATION\n+          let dTagExp = parser.source.readUpto(\">\");\n+          const regx = DOCTYPE_tags[str];\n+          if(regx){\n+            const match = dTagExp.match(regx);\n+            if(!match) throw new Error(\"Invalid DOCTYPE\");\n+          }else throw new Error(\"Invalid DOCTYPE\");\n+        }\n+      }else if( ch === '>' && lastch === \"]\"){//end of doctype\n+        return;  \n+      }\n+    }else if( ch === '>'){//end of doctype\n+      return;\n+    }else if( ch === '['){\n+      hasBody = true;\n+    }else{\n+      lastch = ch;\n+    }\n+  }//End While loop\n+\n+}\n+\n+function registerEntity(parser){\n+  //read Entity\n+  let attrBoundary=\"\";\n+  let name =\"\", val =\"\";\n+  while(source.canRead()){\n+    let ch = source.readCh();\n+\n+    if(attrBoundary){\n+      if (ch === attrBoundary){\n+        val = text;\n+        text = \"\"\n+      }\n+    }else if(ch === \" \" || ch === \"\\t\"){\n+      if(!name){\n+        name = text.trimStart();\n+        text = \"\";\n+      }\n+    }else if (ch === '\"' || ch === \"'\") {//start of attrBoundary\n+      attrBoundary = ch;\n+    }else if(ch === \">\"){\n+      parser.entityParser.addExternalEntity(name,val);\n+      return;\n+    }else{\n+      text+=ch;\n+    }\n+  }\n+}\n+\n+module.exports = {\n+  readCdata: readCdata,\n+  readComment:readComment,\n+  readDocType:readDocType,\n+  readPiTag:readPiTag\n+}\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/inputSource/BufferSource.js",
          "status": "added",
          "additions": 118,
          "deletions": 0,
          "patch": "@@ -0,0 +1,118 @@\n+const Constants = {\n+  space: 32,\n+  tab: 9\n+}\n+class BufferSource{\n+  constructor(bytesArr){\n+    this.line = 1;\n+    this.cols = 0;\n+    this.buffer = bytesArr;\n+    this.startIndex = 0;\n+  }\n+\n+\n+\n+  readCh() {\n+    return String.fromCharCode(this.buffer[this.startIndex++]);\n+  }\n+\n+  readChAt(index) {\n+    return String.fromCharCode(this.buffer[this.startIndex+index]);\n+  }\n+\n+  readStr(n,from){\n+    if(typeof from === \"undefined\") from = this.startIndex;\n+    return this.buffer.slice(from, from + n).toString();\n+  }\n+\n+  readUpto(stopStr) {\n+    const inputLength = this.buffer.length;\n+    const stopLength = stopStr.length;\n+    const stopBuffer = Buffer.from(stopStr);\n+\n+    for (let i = this.startIndex; i < inputLength; i++) {\n+        let match = true;\n+        for (let j = 0; j < stopLength; j++) {\n+            if (this.buffer[i + j] !== stopBuffer[j]) {\n+                match = false;\n+                break;\n+            }\n+        }\n+\n+        if (match) {\n+            const result = this.buffer.slice(this.startIndex, i).toString();\n+            this.startIndex = i + stopLength;\n+            return result;\n+        }\n+    }\n+\n+    throw new Error(`Unexpected end of source. Reading '${stopStr}'`);\n+}\n+\n+readUptoCloseTag(stopStr) { //stopStr: \"</tagname\"\n+    const inputLength = this.buffer.length;\n+    const stopLength = stopStr.length;\n+    const stopBuffer = Buffer.from(stopStr);\n+    let stopIndex = 0;\n+    //0: non-matching, 1: matching stop string, 2: matching closing\n+    let match = 0;\n+\n+    for (let i = this.startIndex; i < inputLength; i++) {\n+        if(match === 1){//initial part matched\n+            if(stopIndex === 0) stopIndex = i;\n+            if(this.buffer[i] === Constants.space || this.buffer[i] === Constants.tab) continue;\n+            else if(this.buffer[i] === '>'){ //TODO: if it should be equivalent ASCII\n+                match = 2;\n+                //tag boundary found\n+                // this.startIndex\n+            }\n+        }else{\n+            match = 1;\n+            for (let j = 0; j < stopLength; j++) {\n+                if (this.buffer[i + j] !== stopBuffer[j]) {\n+                    match = 0;\n+                    break;\n+                }\n+            }\n+        }\n+        if (match === 2) {//matched closing part\n+            const result = this.buffer.slice(this.startIndex, stopIndex - 1 ).toString();\n+            this.startIndex = i + 1;\n+            return result;\n+        }\n+    }\n+\n+    throw new Error(`Unexpected end of source. Reading '${stopStr}'`);\n+}\n+\n+  readFromBuffer(n, shouldUpdate) {\n+    let ch;\n+    if (n === 1) {\n+      ch = this.buffer[this.startIndex];\n+      if (ch === 10) {\n+        this.line++;\n+        this.cols = 1;\n+      } else {\n+        this.cols++;\n+      }\n+      ch = String.fromCharCode(ch);\n+    } else {\n+      this.cols += n;\n+      ch = this.buffer.slice(this.startIndex, this.startIndex + n).toString();\n+    }\n+    if (shouldUpdate) this.updateBuffer(n);\n+    return ch;\n+  }\n+\n+  updateBufferBoundary(n = 1) { //n: number of characters read\n+    this.startIndex += n;\n+  }\n+\n+  canRead(n){\n+    n = n || this.startIndex;\n+    return this.buffer.length - n + 1 > 0;\n+  }\n+  \n+}\n+\n+module.exports = BufferSource;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/inputSource/StringSource.js",
          "status": "added",
          "additions": 123,
          "deletions": 0,
          "patch": "@@ -0,0 +1,123 @@\n+const whiteSpaces = [\" \", \"\\n\", \"\\t\"];\n+\n+\n+class StringSource{\n+  constructor(str){\n+    this.line = 1;\n+    this.cols = 0;\n+    this.buffer = str;\n+    //a boundary pointer to indicate where from the buffer dat should be read\n+    // data before this pointer can be deleted to free the memory\n+    this.startIndex = 0;\n+  }\n+\n+  readCh() {\n+    return this.buffer[this.startIndex++];\n+  }\n+\n+  readChAt(index) {\n+    return this.buffer[this.startIndex+index];\n+  }\n+\n+  readStr(n,from){\n+    if(typeof from === \"undefined\") from = this.startIndex;\n+    return this.buffer.substring(from, from + n);\n+  }\n+\n+  readUpto(stopStr) {\n+    const inputLength = this.buffer.length;\n+    const stopLength = stopStr.length;\n+\n+    for (let i = this.startIndex; i < inputLength; i++) {\n+      let match = true;\n+      for (let j = 0; j < stopLength; j++) {\n+        if (this.buffer[i + j] !== stopStr[j]) {\n+          match = false;\n+          break;\n+        }\n+      }\n+\n+      if (match) {\n+        const result = this.buffer.substring(this.startIndex, i);\n+        this.startIndex = i + stopLength;\n+        return result;\n+      }\n+    }\n+\n+    throw new Error(`Unexpected end of source. Reading '${stopStr}'`);\n+  }\n+\n+  readUptoCloseTag(stopStr) { //stopStr: \"</tagname\"\n+    const inputLength = this.buffer.length;\n+    const stopLength = stopStr.length;\n+    let stopIndex = 0;\n+    //0: non-matching, 1: matching stop string, 2: matching closing\n+    let match = 0;\n+\n+    for (let i = this.startIndex; i < inputLength; i++) {\n+      if(match === 1){//initial part matched\n+        if(stopIndex === 0) stopIndex = i;\n+        if(this.buffer[i] === ' ' || this.buffer[i] === '\\t') continue;\n+        else if(this.buffer[i] === '>'){\n+          match = 2;\n+          //tag boundary found\n+          // this.startIndex\n+        }\n+      }else{\n+        match = 1;\n+        for (let j = 0; j < stopLength; j++) {\n+          if (this.buffer[i + j] !== stopStr[j]) {\n+            match = 0;\n+            break;\n+          }\n+        }\n+      }\n+      if (match === 2) {//matched closing part\n+        const result = this.buffer.substring(this.startIndex, stopIndex - 1 );\n+        this.startIndex = i + 1;\n+        return result;\n+      }\n+    }\n+\n+    throw new Error(`Unexpected end of source. Reading '${stopStr}'`);\n+  }\n+\n+  readFromBuffer(n, updateIndex){\n+    let ch;\n+    if(n===1){\n+      ch = this.buffer[this.startIndex];\n+      // if(ch === \"\\n\") {\n+      //   this.line++;\n+      //   this.cols = 1;\n+      // }else{\n+      //   this.cols++;\n+      // }\n+    }else{\n+      ch = this.buffer.substring(this.startIndex, this.startIndex + n);\n+      // if(\"\".indexOf(\"\\n\") !== -1){\n+      //   //TODO: handle the scenario when there are multiple lines\n+      //   //TODO: col should be set to number of chars after last '\\n'\n+      //   // this.cols = 1;\n+      // }else{\n+      //   this.cols += n;\n+\n+      // }\n+    }\n+    if(updateIndex) this.updateBufferBoundary(n);\n+    return ch;\n+  }\n+\n+  //TODO: rename to updateBufferReadIndex\n+  \n+  updateBufferBoundary(n = 1) { //n: number of characters read\n+    this.startIndex += n;\n+  }\n+\n+  canRead(n){\n+    n = n || this.startIndex;\n+    return this.buffer.length - n + 1 > 0;\n+  }\n+  \n+}\n+\n+module.exports = StringSource;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/EntitiesParser.js",
          "status": "added",
          "additions": 105,
          "deletions": 0,
          "patch": "@@ -0,0 +1,105 @@\n+const ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n+const htmlEntities = {\n+    \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n+    // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n+    // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n+    // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n+    // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n+    // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n+    \"cent\" : { regex: /&(cent|#162);/g, val: \"\u00a2\" },\n+    \"pound\" : { regex: /&(pound|#163);/g, val: \"\u00a3\" },\n+    \"yen\" : { regex: /&(yen|#165);/g, val: \"\u00a5\" },\n+    \"euro\" : { regex: /&(euro|#8364);/g, val: \"\u20ac\" },\n+    \"copyright\" : { regex: /&(copy|#169);/g, val: \"\u00a9\" },\n+    \"reg\" : { regex: /&(reg|#174);/g, val: \"\u00ae\" },\n+    \"inr\" : { regex: /&(inr|#8377);/g, val: \"\u20b9\" },\n+};\n+\n+class EntitiesParser{\n+    constructor(replaceHtmlEntities) {\n+      this.replaceHtmlEntities = replaceHtmlEntities;\n+      this.docTypeEntities = {};\n+      this.lastEntities = {\n+        \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n+        \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n+        \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n+        \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n+      };\n+    }\n+\n+    addExternalEntities(externalEntities){\n+        const entKeys = Object.keys(externalEntities);\n+        for (let i = 0; i < entKeys.length; i++) {\n+          const ent = entKeys[i];\n+          this.addExternalEntity(ent,externalEntities[ent])\n+        }\n+    }\n+    addExternalEntity(key,val){\n+      validateEntityName(key);\n+      if(val.indexOf(\"&\") !== -1) {\n+        reportWarning(`Entity ${key} is not added as '&' is found in value;`)\n+        return;\n+      }else{\n+        this.lastEntities[ent] = {\n+          regex: new RegExp(\"&\"+key+\";\",\"g\"),\n+          val : val\n+        }\n+      }\n+    }\n+\n+    addDocTypeEntities(entities){\n+        const entKeys = Object.keys(entities);\n+        for (let i = 0; i < entKeys.length; i++) {\n+          const ent = entKeys[i];\n+          this.docTypeEntities[ent] = {\n+             regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n+             val : entities[ent]\n+          }\n+        }\n+    }\n+\n+    parse(val){\n+        return this.replaceEntitiesValue(val)\n+    }\n+\n+    /**\n+     * 1. Replace DOCTYPE entities \n+     * 2. Replace external entities \n+     * 3. Replace HTML entities if asked\n+     * @param {string} val \n+     */\n+    replaceEntitiesValue(val){\n+        if(typeof val === \"string\" && val.length > 0){\n+            for(let entityName in this.docTypeEntities){\n+                const entity = this.docTypeEntities[entityName];\n+                val = val.replace( entity.regx, entity.val);\n+              }\n+              for(let entityName in this.lastEntities){\n+                const entity = this.lastEntities[entityName];\n+                val = val.replace( entity.regex, entity.val);\n+              }\n+              if(this.replaceHtmlEntities){\n+                for(let entityName in htmlEntities){\n+                  const entity = htmlEntities[entityName];\n+                  val = val.replace( entity.regex, entity.val);\n+                }\n+              }\n+            val = val.replace( ampEntity.regex, ampEntity.val);\n+        }\n+        return val;\n+    }\n+};\n+\n+//an entity name should not contains special characters that may be used in regex\n+//Eg !?\\\\\\/[]$%{}^&*()<>\n+const specialChar = \"!?\\\\\\/[]$%{}^&*()<>|+\";\n+\n+function validateEntityName(name){\n+    for (let i = 0; i < specialChar.length; i++) {\n+        const ch = specialChar[i];\n+        if(name.indexOf(ch) !== -1) throw new Error(`Invalid character ${ch} in entity name`);\n+    }\n+    return name;\n+}\n+\n+module.exports = EntitiesParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/booleanParser.js",
          "status": "added",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -0,0 +1,23 @@\n+class boolParser{\n+    constructor(trueList, falseList){\n+        if(trueList)\n+            this.trueList = trueList;\n+        else\n+            this.trueList = [\"true\"];\n+        \n+        if(falseList)\n+            this.falseList = falseList;\n+        else\n+            this.falseList = [\"false\"];\n+    }\n+    parse(val){\n+        if (typeof val === 'string') {\n+            //TODO: performance: don't convert\n+            const temp = val.toLowerCase();\n+            if(this.trueList.indexOf(temp) !== -1) return true;\n+            else if(this.falseList.indexOf(temp) !== -1 ) return false;\n+        }\n+        return val;\n+    }\n+}\n+module.exports = boolParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/booleanParserExt.js",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+function boolParserExt(val){\n+    if(isArray(val)){\n+        for (let i = 0; i < val.length; i++) {\n+            val[i] = parse(val[i])\n+        }\n+    }else{\n+        val = parse(val)\n+    }\n+    return val;\n+}\n+\n+function parse(val){\n+    if (typeof val === 'string') {\n+        const temp = val.toLowerCase();\n+        if(temp === 'true' || temp ===\"yes\" || temp===\"1\") return true;\n+        else if(temp === 'false' || temp ===\"no\" || temp===\"0\") return false;\n+    }\n+    return val;\n+}\n+module.exports = boolParserExt;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/currency.js",
          "status": "added",
          "additions": 31,
          "deletions": 0,
          "patch": "@@ -0,0 +1,31 @@\n+\n+const localeMap = {\n+    \"$\":\"en-US\",\n+    \"\u20ac\":\"de-DE\",\n+    \"\u00a3\":\"en-GB\",\n+    \"\u00a5\":\"ja-JP\",\n+    \"\u20b9\":\"en-IN\",\n+}\n+\n+const currencyCheckRegex = /^\\s*(?:-|\\+)?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d{1,2})?\\s*(?:\\$|\u20ac|\u00a5|\u20b9)?\\s*$/u;\n+\n+class CurrencyParser{\n+    constructor(options){\n+        this.options = options;\n+    }\n+    parse(val){\n+        if (typeof val === 'string') {\n+            if(val.indexOf(\",,\") !== -1 && val.indexOf(\"..\" !== -1)){\n+                const match = val.match(currencyCheckRegex);\n+                if(match){\n+                    const locale = this.options.locale || localeMap[match[2]||match[5]||\"\u20b9\"];\n+                    const formatter = new Intl.NumberFormat(locale)\n+                    val = val.replace(/[^0-9,.]/g, '').trim();\n+                    val = Number(val.replace(formatter.format(1000)[1], ''));\n+                }\n+            }\n+        }\n+        return val;\n+    }\n+}\n+module.exports = CurrencyParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/join.js",
          "status": "added",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -0,0 +1,14 @@\n+/**\n+ * \n+ * @param {array} val \n+ * @param {string} by \n+ * @returns \n+ */\n+function join(val, by=\" \"){\n+    if(isArray(val)){\n+        val.join(by)\n+    }\n+    return val;\n+}\n+\n+module.exports = join;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/number.js",
          "status": "added",
          "additions": 16,
          "deletions": 0,
          "patch": "@@ -0,0 +1,16 @@\n+const toNumber = require(\"strnum\");\n+\n+\n+class numParser{\n+    constructor(options){\n+        this.options = options;\n+    }\n+    parse(val){\n+        if (typeof val === 'string') {\n+            val = toNumber(val,this.options);\n+        }\n+        return val;\n+    }\n+}\n+\n+module.exports = numParser;\n\\ No newline at end of file"
        },
        {
          "filename": "src/v5/valueParsers/trim.js",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+class trimmer{\n+    parse(val){\n+        if(typeof val === \"string\") return val.trim();\n+        else return val;\n+    }\n+}\n+\n+module.exports = trimmer;\n\\ No newline at end of file"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 1,
        "test_files": 1,
        "unique_directories": 7,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "280cd63b8df2a6ad1f17ee95cc9f7cf9b4094fba",
            "date": "2024-12-20T05:47:14Z",
            "author_login": "Kelgors"
          },
          {
            "sha": "e132656533533886f7dc9eadbd8e790ae5572b4c",
            "date": "2024-12-15T07:12:54Z",
            "author_login": "amitguptagwl"
          },
          {
            "sha": "74e2651811c5ff969b782417a1632e03e67b5969",
            "date": "2024-12-14T09:26:00Z",
            "author_login": "jhulford"
          },
          {
            "sha": "408290231ed0aeb38cdfc55f9866dda1669c123c",
            "date": "2024-11-22T06:11:10Z",
            "author_login": "LivioGama"
          },
          {
            "sha": "eb8aa89a3cdf195164d120c60d4bf0d6e730488f",
            "date": "2024-11-14T12:28:40Z",
            "author_login": "ThePlenkov"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-400",
    "description": "fast-xml-parser is an open source, pure javascript xml parser. a ReDOS exists on currency.js. This vulnerability is fixed in 4.4.1.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-29T16:15:05.570",
    "last_modified": "2024-11-21T09:33:08.093",
    "fix_date": "2024-02-24T04:38:30Z"
  },
  "references": [
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/src/v5/valueParsers/currency.js#L10",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/ba5f35e7680468acd7906eaabb2f69e28ed8b2aa",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/d0bfe8a3a2813a185f39591bbef222212d856164",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/security/advisories/GHSA-mpg4-rc92-vx8v",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/src/v5/valueParsers/currency.js#L10",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/d0bfe8a3a2813a185f39591bbef222212d856164",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/NaturalIntelligence/fast-xml-parser/security/advisories/GHSA-mpg4-rc92-vx8v",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:34.497259",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fast-xml-parser",
    "owner": "NaturalIntelligence",
    "created_at": "2017-01-28T23:25:42Z",
    "updated_at": "2025-01-14T17:42:10Z",
    "pushed_at": "2024-12-20T05:47:14Z",
    "size": 6879,
    "stars": 2635,
    "forks": 309,
    "open_issues": 65,
    "watchers": 2635,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "JavaScript": 354230,
      "HTML": 15007,
      "TypeScript": 869
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:00:17.006006"
  }
}