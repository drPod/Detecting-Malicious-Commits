{
  "cve_id": "CVE-2024-41952",
  "github_data": {
    "repository": "zitadel/zitadel",
    "fix_commit": "0ab0c645ef914298c343fa39cccb1290aba48bf6",
    "related_commits": [
      "0ab0c645ef914298c343fa39cccb1290aba48bf6",
      "3c7d12834e32426416235b9e3374be0f4b9380b8",
      "5c2526c98aafd1ba206be2fa4291b1d24c384f6d",
      "8565d24fd8df5bd35294313cfbfcc2e15aea20e9",
      "b0e71a81ef39667ce2a149ce037c1ca0edbe059d",
      "fc1d415b8db5b8d481bb65206ce3fc944c0eecea"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "0ab0c645ef914298c343fa39cccb1290aba48bf6",
      "commit_date": "2024-07-31T12:23:57Z",
      "author": {
        "login": "livio-a",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: prevent error reason leakage in case of IgnoreUnknownUsernames (#8372)",
        "length": 978,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 229,
        "additions": 207,
        "deletions": 22
      },
      "files": [
        {
          "filename": "internal/auth/repository/eventsourcing/eventstore/auth_request.go",
          "status": "modified",
          "additions": 23,
          "deletions": 8,
          "patch": "@@ -2,6 +2,7 @@ package eventstore\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"slices\"\n \t\"strings\"\n \t\"time\"\n@@ -29,6 +30,12 @@ import (\n \n const unknownUserID = \"UNKNOWN\"\n \n+var (\n+\tErrUserNotFound = func(err error) error {\n+\t\treturn zerrors.ThrowNotFound(err, \"EVENT-hodc6\", \"Errors.User.NotFound\")\n+\t}\n+)\n+\n type AuthRequestRepo struct {\n \tCommand      *command.Commands\n \tQuery        *query.Queries\n@@ -52,6 +59,7 @@ type AuthRequestRepo struct {\n \tProjectProvider           projectProvider\n \tApplicationProvider       applicationProvider\n \tCustomTextProvider        customTextProvider\n+\tPasswordChecker           passwordChecker\n \n \tIdGenerator id.Generator\n }\n@@ -71,7 +79,7 @@ type userSessionViewProvider interface {\n }\n \n type userViewProvider interface {\n-\tUserByID(string, string) (*user_view_model.UserView, error)\n+\tUserByID(context.Context, string, string) (*user_view_model.UserView, error)\n }\n \n type loginPolicyViewProvider interface {\n@@ -125,6 +133,10 @@ type customTextProvider interface {\n \tCustomTextListByTemplate(ctx context.Context, aggregateID string, text string, withOwnerRemoved bool) (texts *query.CustomTexts, err error)\n }\n \n+type passwordChecker interface {\n+\tHumanCheckPassword(ctx context.Context, resourceOwner, userID, password string, authReq *domain.AuthRequest) error\n+}\n+\n func (repo *AuthRequestRepo) Health(ctx context.Context) error {\n \treturn repo.AuthRequests.Health(ctx)\n }\n@@ -341,23 +353,25 @@ func (repo *AuthRequestRepo) VerifyPassword(ctx context.Context, authReqID, user\n \trequest, err := repo.getAuthRequestEnsureUser(ctx, authReqID, userAgentID, userID)\n \tif err != nil {\n \t\tif isIgnoreUserNotFoundError(err, request) {\n+\t\t\t// use the same errorID as below (otherwise it would expose the error reason)\n \t\t\treturn zerrors.ThrowInvalidArgument(nil, \"EVENT-SDe2f\", \"Errors.User.UsernameOrPassword.Invalid\")\n \t\t}\n \t\treturn err\n \t}\n-\terr = repo.Command.HumanCheckPassword(ctx, resourceOwner, userID, password, request.WithCurrentInfo(info))\n+\terr = repo.PasswordChecker.HumanCheckPassword(ctx, resourceOwner, userID, password, request.WithCurrentInfo(info))\n \tif isIgnoreUserInvalidPasswordError(err, request) {\n-\t\treturn zerrors.ThrowInvalidArgument(nil, \"EVENT-Jsf32\", \"Errors.User.UsernameOrPassword.Invalid\")\n+\t\t// use the same errorID as above (otherwise it would expose the error reason)\n+\t\treturn zerrors.ThrowInvalidArgument(nil, \"EVENT-SDe2f\", \"Errors.User.UsernameOrPassword.Invalid\")\n \t}\n \treturn err\n }\n \n func isIgnoreUserNotFoundError(err error, request *domain.AuthRequest) bool {\n-\treturn request != nil && request.LoginPolicy != nil && request.LoginPolicy.IgnoreUnknownUsernames && zerrors.IsNotFound(err) && zerrors.Contains(err, \"Errors.User.NotFound\")\n+\treturn request != nil && request.LoginPolicy != nil && request.LoginPolicy.IgnoreUnknownUsernames && errors.Is(err, ErrUserNotFound(nil))\n }\n \n func isIgnoreUserInvalidPasswordError(err error, request *domain.AuthRequest) bool {\n-\treturn request != nil && request.LoginPolicy != nil && request.LoginPolicy.IgnoreUnknownUsernames && zerrors.IsErrorInvalidArgument(err) && zerrors.Contains(err, \"Errors.User.Password.Invalid\")\n+\treturn request != nil && request.LoginPolicy != nil && request.LoginPolicy.IgnoreUnknownUsernames && errors.Is(err, command.ErrPasswordInvalid(nil))\n }\n \n func lockoutPolicyToDomain(policy *query.LockoutPolicy) *domain.LockoutPolicy {\n@@ -1629,7 +1643,7 @@ func userByID(ctx context.Context, viewProvider userViewProvider, eventProvider\n \tctx, span := tracing.NewSpan(ctx)\n \tdefer func() { span.EndWithError(err) }()\n \n-\tuser, viewErr := viewProvider.UserByID(userID, authz.GetInstance(ctx).InstanceID())\n+\tuser, viewErr := viewProvider.UserByID(ctx, userID, authz.GetInstance(ctx).InstanceID())\n \tif viewErr != nil && !zerrors.IsNotFound(viewErr) {\n \t\treturn nil, viewErr\n \t} else if user == nil {\n@@ -1642,9 +1656,10 @@ func userByID(ctx context.Context, viewProvider userViewProvider, eventProvider\n \t}\n \tif len(events) == 0 {\n \t\tif viewErr != nil {\n-\t\t\treturn nil, viewErr\n+\t\t\t// We already returned all errors apart from not found, but need to make sure that can be checked in case IgnoreUnknownUsernames option is active.\n+\t\t\treturn nil, ErrUserNotFound(viewErr)\n \t\t}\n-\t\treturn user_view_model.UserToModel(user), viewErr\n+\t\treturn user_view_model.UserToModel(user), nil\n \t}\n \tuserCopy := *user\n \tfor _, event := range events {"
        },
        {
          "filename": "internal/auth/repository/eventsourcing/eventstore/auth_request_test.go",
          "status": "modified",
          "additions": 162,
          "deletions": 2,
          "patch": "@@ -10,9 +10,11 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \t\"go.uber.org/mock/gomock\"\n \n+\t\"github.com/zitadel/zitadel/internal/api/authz\"\n \t\"github.com/zitadel/zitadel/internal/auth/repository/eventsourcing/view\"\n \tcache \"github.com/zitadel/zitadel/internal/auth_request/repository\"\n \t\"github.com/zitadel/zitadel/internal/auth_request/repository/mock\"\n+\t\"github.com/zitadel/zitadel/internal/command\"\n \t\"github.com/zitadel/zitadel/internal/crypto\"\n \t\"github.com/zitadel/zitadel/internal/database\"\n \t\"github.com/zitadel/zitadel/internal/domain\"\n@@ -103,7 +105,7 @@ func (m *mockViewUserSession) GetLatestUserSessionSequence(ctx context.Context,\n \n type mockViewNoUser struct{}\n \n-func (m *mockViewNoUser) UserByID(string, string) (*user_view_model.UserView, error) {\n+func (m *mockViewNoUser) UserByID(context.Context, string, string) (*user_view_model.UserView, error) {\n \treturn nil, zerrors.ThrowNotFound(nil, \"id\", \"user not found\")\n }\n \n@@ -198,7 +200,7 @@ func (m *mockPasswordAgePolicy) PasswordAgePolicyByOrg(context.Context, bool, st\n \treturn m.policy, nil\n }\n \n-func (m *mockViewUser) UserByID(string, string) (*user_view_model.UserView, error) {\n+func (m *mockViewUser) UserByID(context.Context, string, string) (*user_view_model.UserView, error) {\n \treturn &user_view_model.UserView{\n \t\tState:    int32(user_model.UserStateActive),\n \t\tUserName: \"UserName\",\n@@ -298,6 +300,14 @@ func (m *mockIDPUserLinks) IDPUserLinks(ctx context.Context, queries *query.IDPU\n \treturn &query.IDPUserLinks{Links: m.idps}, nil\n }\n \n+type mockPasswordChecker struct {\n+\terr error\n+}\n+\n+func (m *mockPasswordChecker) HumanCheckPassword(ctx context.Context, resourceOwner, userID, password string, authReq *domain.AuthRequest) error {\n+\treturn m.err\n+}\n+\n func TestAuthRequestRepo_nextSteps(t *testing.T) {\n \ttype fields struct {\n \t\tAuthRequests              cache.AuthRequestCache\n@@ -2403,3 +2413,153 @@ func Test_userByID(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestAuthRequestRepo_VerifyPassword_IgnoreUnknownUsernames(t *testing.T) {\n+\tauthRequest := func(userID string) *domain.AuthRequest {\n+\t\ta := &domain.AuthRequest{\n+\t\t\tID:      \"authRequestID\",\n+\t\t\tAgentID: \"userAgentID\",\n+\t\t\tUserID:  userID,\n+\t\t\tLoginPolicy: &domain.LoginPolicy{\n+\t\t\t\tObjectRoot:            es_models.ObjectRoot{},\n+\t\t\t\tDefault:               true,\n+\t\t\t\tAllowUsernamePassword: true,\n+\t\t\t\tAllowRegister:         true,\n+\t\t\t\tAllowExternalIDP:      true,\n+\t\t\t\tIDPProviders: []*domain.IDPProvider{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tObjectRoot:  es_models.ObjectRoot{},\n+\t\t\t\t\t\tType:        domain.IdentityProviderTypeSystem,\n+\t\t\t\t\t\tIDPConfigID: \"idpConfig1\",\n+\t\t\t\t\t\tName:        \"IdP\",\n+\t\t\t\t\t\tIDPType:     domain.IDPTypeOIDC,\n+\t\t\t\t\t\tIDPState:    domain.IDPConfigStateActive,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tIgnoreUnknownUsernames: true,\n+\t\t\t},\n+\t\t\tAllowedExternalIDPs: []*domain.IDPProvider{\n+\t\t\t\t{\n+\t\t\t\t\tObjectRoot:  es_models.ObjectRoot{},\n+\t\t\t\t\tType:        domain.IdentityProviderTypeSystem,\n+\t\t\t\t\tIDPConfigID: \"idpConfig1\",\n+\t\t\t\t\tName:        \"IdP\",\n+\t\t\t\t\tIDPType:     domain.IDPTypeOIDC,\n+\t\t\t\t\tIDPState:    domain.IDPConfigStateActive,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tLabelPolicy: &domain.LabelPolicy{\n+\t\t\t\tObjectRoot: es_models.ObjectRoot{},\n+\t\t\t\tState:      domain.LabelPolicyStateActive,\n+\t\t\t\tDefault:    true,\n+\t\t\t},\n+\t\t\tPrivacyPolicy: &domain.PrivacyPolicy{\n+\t\t\t\tObjectRoot: es_models.ObjectRoot{},\n+\t\t\t\tState:      domain.PolicyStateActive,\n+\t\t\t\tDefault:    true,\n+\t\t\t},\n+\t\t\tLockoutPolicy: &domain.LockoutPolicy{\n+\t\t\t\tDefault: true,\n+\t\t\t},\n+\t\t\tPasswordAgePolicy: &domain.PasswordAgePolicy{\n+\t\t\t\tObjectRoot:     es_models.ObjectRoot{},\n+\t\t\t\tMaxAgeDays:     0,\n+\t\t\t\tExpireWarnDays: 0,\n+\t\t\t},\n+\t\t\tDefaultTranslations: []*domain.CustomText{{}},\n+\t\t\tOrgTranslations:     []*domain.CustomText{{}},\n+\t\t\tSAMLRequestID:       \"\",\n+\t\t}\n+\t\ta.SetPolicyOrgID(\"instance1\")\n+\t\treturn a\n+\t}\n+\ttype fields struct {\n+\t\tAuthRequests      func(*testing.T, string) cache.AuthRequestCache\n+\t\tUserViewProvider  userViewProvider\n+\t\tUserEventProvider userEventProvider\n+\t\tOrgViewProvider   orgViewProvider\n+\t\tPasswordChecker   passwordChecker\n+\t}\n+\ttype args struct {\n+\t\tctx           context.Context\n+\t\tauthReqID     string\n+\t\tuserID        string\n+\t\tresourceOwner string\n+\t\tpassword      string\n+\t\tuserAgentID   string\n+\t\tinfo          *domain.BrowserInfo\n+\t}\n+\ttests := []struct {\n+\t\tname   string\n+\t\tfields fields\n+\t\targs   args\n+\t}{\n+\t\t{\n+\t\t\tname: \"no user\",\n+\t\t\tfields: fields{\n+\t\t\t\tAuthRequests: func(tt *testing.T, userID string) cache.AuthRequestCache {\n+\t\t\t\t\tm := mock.NewMockAuthRequestCache(gomock.NewController(tt))\n+\t\t\t\t\ta := authRequest(userID)\n+\t\t\t\t\tm.EXPECT().GetAuthRequestByID(gomock.Any(), \"authRequestID\").Return(a, nil)\n+\t\t\t\t\tm.EXPECT().CacheAuthRequest(gomock.Any(), a)\n+\t\t\t\t\treturn m\n+\t\t\t\t},\n+\t\t\t\tUserViewProvider:  &mockViewNoUser{},\n+\t\t\t\tUserEventProvider: &mockEventUser{},\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\tctx:           authz.NewMockContext(\"instance1\", \"\", \"\"),\n+\t\t\t\tauthReqID:     \"authRequestID\",\n+\t\t\t\tuserID:        unknownUserID,\n+\t\t\t\tresourceOwner: \"org1\",\n+\t\t\t\tpassword:      \"password\",\n+\t\t\t\tuserAgentID:   \"userAgentID\",\n+\t\t\t\tinfo: &domain.BrowserInfo{\n+\t\t\t\t\tUserAgent: \"useragent\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"invalid password\",\n+\t\t\tfields: fields{\n+\t\t\t\tAuthRequests: func(tt *testing.T, userID string) cache.AuthRequestCache {\n+\t\t\t\t\tm := mock.NewMockAuthRequestCache(gomock.NewController(tt))\n+\t\t\t\t\ta := authRequest(userID)\n+\t\t\t\t\tm.EXPECT().GetAuthRequestByID(gomock.Any(), \"authRequestID\").Return(a, nil)\n+\t\t\t\t\tm.EXPECT().CacheAuthRequest(gomock.Any(), a)\n+\t\t\t\t\treturn m\n+\t\t\t\t},\n+\t\t\t\tUserViewProvider:  &mockViewUser{},\n+\t\t\t\tUserEventProvider: &mockEventUser{},\n+\t\t\t\tOrgViewProvider:   &mockViewOrg{State: domain.OrgStateActive},\n+\t\t\t\tPasswordChecker: &mockPasswordChecker{\n+\t\t\t\t\terr: command.ErrPasswordInvalid(nil),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\targs: args{\n+\t\t\t\tctx:           authz.NewMockContext(\"instance1\", \"\", \"\"),\n+\t\t\t\tauthReqID:     \"authRequestID\",\n+\t\t\t\tuserID:        \"user1\",\n+\t\t\t\tresourceOwner: \"org1\",\n+\t\t\t\tpassword:      \"password\",\n+\t\t\t\tuserAgentID:   \"userAgentID\",\n+\t\t\t\tinfo: &domain.BrowserInfo{\n+\t\t\t\t\tUserAgent: \"useragent\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\trepo := &AuthRequestRepo{\n+\t\t\t\tAuthRequests:      tt.fields.AuthRequests(t, tt.args.userID),\n+\t\t\t\tUserViewProvider:  tt.fields.UserViewProvider,\n+\t\t\t\tUserEventProvider: tt.fields.UserEventProvider,\n+\t\t\t\tOrgViewProvider:   tt.fields.OrgViewProvider,\n+\t\t\t\tPasswordChecker:   tt.fields.PasswordChecker,\n+\t\t\t}\n+\t\t\terr := repo.VerifyPassword(tt.args.ctx, tt.args.authReqID, tt.args.userID, tt.args.resourceOwner, tt.args.password, tt.args.userAgentID, tt.args.info)\n+\t\t\tassert.ErrorIs(t, err, zerrors.ThrowInvalidArgument(nil, \"EVENT-SDe2f\", \"Errors.User.UsernameOrPassword.Invalid\"))\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "internal/auth/repository/eventsourcing/repository.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -78,6 +78,7 @@ func Start(ctx context.Context, conf Config, systemDefaults sd.SystemDefaults, c\n \t\t\tProjectProvider:           queryView,\n \t\t\tApplicationProvider:       queries,\n \t\t\tCustomTextProvider:        queries,\n+\t\t\tPasswordChecker:           command,\n \t\t\tIdGenerator:               id.SonyFlakeGenerator(),\n \t\t},\n \t\teventstore.TokenRepo{"
        },
        {
          "filename": "internal/auth/repository/eventsourcing/view/user.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -16,8 +16,8 @@ const (\n \tuserTable = \"auth.users3\"\n )\n \n-func (v *View) UserByID(userID, instanceID string) (*model.UserView, error) {\n-\treturn view.UserByID(v.Db, userTable, userID, instanceID)\n+func (v *View) UserByID(ctx context.Context, userID, instanceID string) (*model.UserView, error) {\n+\treturn view.UserByID(ctx, v.Db, userID, instanceID)\n }\n \n func (v *View) UserByLoginName(ctx context.Context, loginName, instanceID string) (*model.UserView, error) {\n@@ -27,7 +27,7 @@ func (v *View) UserByLoginName(ctx context.Context, loginName, instanceID string\n \t}\n \n \t//nolint: contextcheck // no lint was added because refactor would change too much code\n-\treturn view.UserByID(v.Db, userTable, queriedUser.ID, instanceID)\n+\treturn view.UserByID(ctx, v.Db, queriedUser.ID, instanceID)\n }\n \n func (v *View) UserByLoginNameAndResourceOwner(ctx context.Context, loginName, resourceOwner, instanceID string) (*model.UserView, error) {\n@@ -37,7 +37,7 @@ func (v *View) UserByLoginNameAndResourceOwner(ctx context.Context, loginName, r\n \t}\n \n \t//nolint: contextcheck // no lint was added because refactor would change too much code\n-\tuser, err := view.UserByID(v.Db, userTable, queriedUser.ID, instanceID)\n+\tuser, err := view.UserByID(ctx, v.Db, queriedUser.ID, instanceID)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -103,7 +103,7 @@ func (v *View) userByID(ctx context.Context, instanceID string, queries ...query\n \t\tOnError(err).\n \t\tErrorf(\"could not get current sequence for userByID\")\n \n-\tuser, err := view.UserByID(v.Db, userTable, queriedUser.ID, instanceID)\n+\tuser, err := view.UserByID(ctx, v.Db, queriedUser.ID, instanceID)\n \tif err != nil && !zerrors.IsNotFound(err) {\n \t\treturn nil, err\n \t}"
        },
        {
          "filename": "internal/command/user_human_password.go",
          "status": "modified",
          "additions": 11,
          "deletions": 2,
          "patch": "@@ -16,6 +16,15 @@ import (\n \t\"github.com/zitadel/zitadel/internal/zerrors\"\n )\n \n+var (\n+\tErrPasswordInvalid = func(err error) error {\n+\t\treturn zerrors.ThrowInvalidArgument(err, \"COMMAND-3M0fs\", \"Errors.User.Password.Invalid\")\n+\t}\n+\tErrPasswordUnchanged = func(err error) error {\n+\t\treturn zerrors.ThrowPreconditionFailed(err, \"COMMAND-Aesh5\", \"Errors.User.Password.NotChanged\")\n+\t}\n+)\n+\n func (c *Commands) SetPassword(ctx context.Context, orgID, userID, password string, oneTime bool) (objectDetails *domain.ObjectDetails, err error) {\n \tctx, span := tracing.NewSpan(ctx)\n \tdefer func() { span.EndWithError(err) }()\n@@ -393,10 +402,10 @@ func convertPasswapErr(err error) error {\n \t\treturn nil\n \t}\n \tif errors.Is(err, passwap.ErrPasswordMismatch) {\n-\t\treturn zerrors.ThrowInvalidArgument(err, \"COMMAND-3M0fs\", \"Errors.User.Password.Invalid\")\n+\t\treturn ErrPasswordInvalid(err)\n \t}\n \tif errors.Is(err, passwap.ErrPasswordNoChange) {\n-\t\treturn zerrors.ThrowPreconditionFailed(err, \"COMMAND-Aesh5\", \"Errors.User.Password.NotChanged\")\n+\t\treturn ErrPasswordUnchanged(err)\n \t}\n \treturn zerrors.ThrowInternal(err, \"COMMAND-CahN2\", \"Errors.Internal\")\n }"
        },
        {
          "filename": "internal/user/repository/view/user_view.go",
          "status": "modified",
          "additions": 5,
          "deletions": 5,
          "patch": "@@ -16,12 +16,12 @@ import (\n //go:embed user_by_id.sql\n var userByIDQuery string\n \n-func UserByID(db *gorm.DB, table, userID, instanceID string) (*model.UserView, error) {\n+func UserByID(ctx context.Context, db *gorm.DB, userID, instanceID string) (*model.UserView, error) {\n \tuser := new(model.UserView)\n \n \tquery := db.Raw(userByIDQuery, instanceID, userID)\n \n-\ttx := query.BeginTx(context.Background(), &sql.TxOptions{ReadOnly: true})\n+\ttx := query.BeginTx(ctx, &sql.TxOptions{ReadOnly: true})\n \tdefer func() {\n \t\tif err := tx.Commit().Error; err != nil {\n \t\t\tlogging.OnError(err).Info(\"commit failed\")\n@@ -35,8 +35,8 @@ func UserByID(db *gorm.DB, table, userID, instanceID string) (*model.UserView, e\n \t\treturn user, nil\n \t}\n \tif errors.Is(err, gorm.ErrRecordNotFound) {\n-\t\treturn nil, zerrors.ThrowNotFound(err, \"VIEW-hodc6\", \"object not found\")\n+\t\treturn nil, zerrors.ThrowNotFound(err, \"VIEW-hodc6\", \"Errors.User.NotFound\")\n \t}\n-\tlogging.WithFields(\"table \", table).WithError(err).Warn(\"get from cache error\")\n-\treturn nil, zerrors.ThrowInternal(err, \"VIEW-qJBg9\", \"cache error\")\n+\tlogging.WithError(err).Warn(\"unable to get user by id\")\n+\treturn nil, zerrors.ThrowInternal(err, \"VIEW-qJBg9\", \"unable to get user by id\")\n }"
        }
      ],
      "file_patterns": {
        "security_files": 5,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 5,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ec5f18c16899627bdd8ecf90844641a9bdd8ca47",
            "date": "2025-01-24T10:24:35Z",
            "author_login": "muhlemmer"
          },
          {
            "sha": "73577885bf9f7972365e86dbf9e5cbd63542f030",
            "date": "2025-01-23T13:12:49Z",
            "author_login": "kkrime"
          },
          {
            "sha": "e4bbfcccc878eef185f912e414e03375224e173e",
            "date": "2025-01-22T16:02:37Z",
            "author_login": "zhirschtritt"
          },
          {
            "sha": "c9aa5db2a55ef3c4f6fb62292b69b01973b264e7",
            "date": "2025-01-22T07:37:37Z",
            "author_login": "livio-a"
          },
          {
            "sha": "1915d356052c9b260211ededad1aa0d5cefd256a",
            "date": "2025-01-21T12:31:54Z",
            "author_login": "latonz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-203",
    "description": "Zitadel is an open source identity management system. ZITADEL administrators can enable a setting called \"Ignoring unknown usernames\" which helps mitigate attacks that try to guess/enumerate usernames. If enabled, ZITADEL will show the password prompt even if the user doesn't exist and report \"Username or Password invalid\". Due to a implementation change to prevent deadlocks calling the database, the flag would not be correctly respected in all cases and an attacker would gain information if an account exist within ZITADEL, since the error message shows \"object not found\" instead of the generic error message. This vulnerability is fixed in 2.58.1, 2.57.1, 2.56.2, 2.55.5, 2.54.8, and 2.53.9.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-31T17:15:10.597",
    "last_modified": "2025-01-08T18:27:21.500",
    "fix_date": "2024-07-31T12:23:57Z"
  },
  "references": [
    {
      "url": "https://github.com/zitadel/zitadel/commit/0ab0c645ef914298c343fa39cccb1290aba48bf6",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/commit/3c7d12834e32426416235b9e3374be0f4b9380b8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/commit/5c2526c98aafd1ba206be2fa4291b1d24c384f6d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/commit/8565d24fd8df5bd35294313cfbfcc2e15aea20e9",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/commit/b0e71a81ef39667ce2a149ce037c1ca0edbe059d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/commit/fc1d415b8db5b8d481bb65206ce3fc944c0eecea",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.53.9",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.54.8",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.55.5",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.56.2",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.57.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/releases/tag/v2.58.1",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/zitadel/zitadel/security/advisories/GHSA-567v-6hmg-6qg7",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:34.514123",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "zitadel",
    "owner": "zitadel",
    "created_at": "2020-03-16T13:51:31Z",
    "updated_at": "2025-01-26T07:34:02Z",
    "pushed_at": "2025-01-24T18:31:43Z",
    "size": 475624,
    "stars": 9508,
    "forks": 626,
    "open_issues": 677,
    "watchers": 9508,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "1.87.x",
      "alpha"
    ],
    "languages": {
      "Go": 15106163,
      "TypeScript": 1840621,
      "HTML": 757979,
      "SCSS": 351442,
      "CSS": 112445,
      "JavaScript": 29126,
      "PLpgSQL": 15558,
      "Makefile": 9966,
      "Dockerfile": 9249,
      "Shell": 238
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T07:51:10.617984"
  }
}