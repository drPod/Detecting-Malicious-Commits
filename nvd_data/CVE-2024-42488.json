{
  "cve_id": "CVE-2024-42488",
  "github_data": {
    "repository": "cilium/cilium",
    "fix_commit": "aa44dd148a9be95e07782e4f990e61678ef0abf8",
    "related_commits": [
      "aa44dd148a9be95e07782e4f990e61678ef0abf8"
    ],
    "patch_url": "https://github.com/cilium/cilium/commit/aa44dd148a9be95e07782e4f990e61678ef0abf8.patch",
    "fix_commit_details": {
      "sha": "aa44dd148a9be95e07782e4f990e61678ef0abf8",
      "commit_date": "2024-07-01T17:28:49Z",
      "author": {
        "login": "skmatti",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Track node labels propagated to the endpoint manager correctly",
        "length": 843,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 59,
        "additions": 52,
        "deletions": 7
      },
      "files": [
        {
          "filename": "pkg/endpoint/endpoint.go",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -506,6 +506,11 @@ func (e *Endpoint) IsHost() bool {\n \treturn e.isHost\n }\n \n+// SetIsHost is a convenient method to create host endpoints for testing.\n+func (ep *Endpoint) SetIsHost(isHost bool) {\n+\tep.isHost = isHost\n+}\n+\n // closeBPFProgramChannel closes the channel that signals whether the endpoint\n // has had its BPF program compiled. If the channel is already closed, this is\n // a no-op."
        },
        {
          "filename": "pkg/endpointmanager/host.go",
          "status": "modified",
          "additions": 14,
          "deletions": 7,
          "patch": "@@ -35,24 +35,31 @@ func (mgr *endpointManager) startNodeLabelsObserver(old map[string]string) {\n \t\t\treturn\n \t\t}\n \n-\t\tmgr.updateHostEndpointLabels(old, ln.Labels)\n-\t\told = ln.Labels\n+\t\tif mgr.updateHostEndpointLabels(old, ln.Labels) {\n+\t\t\t// Endpoint's label update logic rejects a request if any of the old labels are\n+\t\t\t// not present in the endpoint manager's state. So, overwrite old labels only if\n+\t\t\t// the update is successful to avoid node labels being outdated indefinitely (GH-29649).\n+\t\t\told = ln.Labels\n+\t\t}\n+\n \t}, func(error) { /* Executed only when we are shutting down */ })\n }\n \n-func (mgr *endpointManager) updateHostEndpointLabels(oldNodeLabels, newNodeLabels map[string]string) {\n+// updateHostEndpointLabels updates the local node labels in the endpoint manager.\n+// Returns true if the update is successful.\n+func (mgr *endpointManager) updateHostEndpointLabels(oldNodeLabels, newNodeLabels map[string]string) bool {\n \tnodeEP := mgr.GetHostEndpoint()\n \tif nodeEP == nil {\n \t\tlog.Error(\"Host endpoint not found\")\n-\t\treturn\n+\t\treturn false\n \t}\n \n-\terr := nodeEP.UpdateLabelsFrom(oldNodeLabels, newNodeLabels, labels.LabelSourceK8s)\n-\tif err != nil {\n+\tif err := nodeEP.UpdateLabelsFrom(oldNodeLabels, newNodeLabels, labels.LabelSourceK8s); err != nil {\n \t\t// An error can only occur if either the endpoint is terminating, or the\n \t\t// old labels are not found. Both are impossible, hence there's no point\n \t\t// in retrying.\n \t\tlog.WithError(err).Error(\"Unable to update host endpoint labels\")\n-\t\treturn\n+\t\treturn false\n \t}\n+\treturn true\n }"
        },
        {
          "filename": "pkg/endpointmanager/manager_test.go",
          "status": "modified",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -19,7 +19,10 @@ import (\n \t\"github.com/cilium/cilium/pkg/endpoint\"\n \tendpointid \"github.com/cilium/cilium/pkg/endpoint/id\"\n \t\"github.com/cilium/cilium/pkg/fqdn/restore\"\n+\t\"github.com/cilium/cilium/pkg/labelsfilter\"\n \tmonitorAPI \"github.com/cilium/cilium/pkg/monitor/api\"\n+\t\"github.com/cilium/cilium/pkg/node\"\n+\t\"github.com/cilium/cilium/pkg/node/types\"\n \t\"github.com/cilium/cilium/pkg/option\"\n \t\"github.com/cilium/cilium/pkg/policy\"\n \ttestidentity \"github.com/cilium/cilium/pkg/testutils/identity\"\n@@ -958,3 +961,33 @@ func TestWaitForEndpointsAtPolicyRev(t *testing.T) {\n \t\ttt.postTestRun()\n \t}\n }\n+\n+func TestMissingNodeLabelsUpdate(t *testing.T) {\n+\t// Initialize label filter config.\n+\tlabelsfilter.ParseLabelPrefixCfg(nil, nil, \"\")\n+\ts := setupEndpointManagerSuite(t)\n+\tmgr := New(&dummyEpSyncher{}, nil, nil)\n+\thostEPID := uint16(17)\n+\n+\t// Initialize the local node watcher before the host endpoint is created.\n+\t// These labels are not propagated to the endpoint manager.\n+\tmgr.localNodeStore = node.NewTestLocalNodeStore(node.LocalNode{Node: types.Node{}})\n+\tmgr.startNodeLabelsObserver(nil)\n+\tmgr.localNodeStore.Update(func(ln *node.LocalNode) { ln.Labels = map[string]string{\"k1\": \"v1\"} })\n+\t_, ok := mgr.endpoints[hostEPID]\n+\trequire.EqualValues(t, ok, false)\n+\n+\t// Create host endpoint and expose it in the endpoint manager.\n+\tep := endpoint.NewTestEndpointWithState(t, s, s, testipcache.NewMockIPCache(), &endpoint.FakeEndpointProxy{}, testidentity.NewMockIdentityAllocator(nil), 1, endpoint.StateReady)\n+\tep.SetIsHost(true)\n+\tep.ID = hostEPID\n+\trequire.Nil(t, mgr.expose(ep))\n+\n+\t// Update node labels and verify that the node labels are updated correctly even if the old\n+\t// labels {k1=v1} are not present in the endpoint manager's state.\n+\tmgr.localNodeStore.Update(func(ln *node.LocalNode) { ln.Labels = map[string]string{\"k2\": \"v2\"} })\n+\thostEP, ok := mgr.endpoints[hostEPID]\n+\trequire.EqualValues(t, ok, true)\n+\tgot := hostEP.OpLabels.IdentityLabels().K8sStringMap()\n+\trequire.EqualValues(t, map[string]string{\"k2\": \"v2\"}, got)\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "af495b29115b8091dcab48ffa46f57bb63e29fb9",
            "date": "2025-01-13T14:02:43Z",
            "author_login": "HadrienPatte"
          },
          {
            "sha": "081d2b0dd8c3ac70ce9b1d44333d43cb719af528",
            "date": "2025-01-13T14:01:05Z",
            "author_login": "HadrienPatte"
          },
          {
            "sha": "b0382b5258660a2b464e46b29a3e33dca6d9ef59",
            "date": "2025-01-10T11:12:30Z",
            "author_login": "pippolo84"
          },
          {
            "sha": "6ee68135db4a2e6a6142f5e2ad438f4239b18797",
            "date": "2025-01-10T11:09:24Z",
            "author_login": "pippolo84"
          },
          {
            "sha": "5fc47e9521e085ef441c14360f305cb8cb69314e",
            "date": "2025-01-10T09:55:48Z",
            "author_login": "pippolo84"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N",
    "cwe_id": "CWE-362",
    "description": "Cilium is a networking, observability, and security solution with an eBPF-based dataplane. Prior to versions 1.14.14 and 1.15.8, a race condition in the Cilium agent can cause the agent to ignore labels that should be applied to a node. This could in turn cause CiliumClusterwideNetworkPolicies intended for nodes with the ignored label to not apply, leading to policy bypass. This issue has been patched in Cilium v1.14.14 and v1.15.8 As the underlying issue depends on a race condition, users unable to upgrade can restart the Cilium agent on affected nodes until the affected policies are confirmed to be working as expected.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-08-15T21:15:17.270",
    "last_modified": "2024-09-27T18:49:05.410",
    "fix_date": "2024-07-01T17:28:49Z"
  },
  "references": [
    {
      "url": "https://github.com/cilium/cilium/commit/aa44dd148a9be95e07782e4f990e61678ef0abf8",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/cilium/cilium/pull/33511",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/cilium/cilium/security/advisories/GHSA-q7w8-72mr-vpgw",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.357051",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cilium",
    "owner": "cilium",
    "created_at": "2015-12-16T12:33:31Z",
    "updated_at": "2025-01-14T13:11:02Z",
    "pushed_at": "2025-01-14T13:10:58Z",
    "size": 368013,
    "stars": 20686,
    "forks": 3031,
    "open_issues": 1031,
    "watchers": 20686,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "feature/main/svc-icmp-response",
      "feature/v1.11/beta-test",
      "feature/v1.11/k8s-ingress"
    ],
    "languages": {
      "Go": 18625849,
      "C": 1840788,
      "Shell": 217614,
      "Makefile": 77186,
      "Dockerfile": 31925,
      "Smarty": 25264,
      "Python": 12413,
      "SmPL": 12369,
      "HTML": 3439,
      "Lua": 2517,
      "Mustache": 1457,
      "TeX": 416
    },
    "commit_activity": {
      "total_commits_last_year": 5449,
      "avg_commits_per_week": 104.78846153846153,
      "days_active_last_year": 339
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:14:57.009385"
  }
}