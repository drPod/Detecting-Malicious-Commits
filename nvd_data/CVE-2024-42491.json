{
  "cve_id": "CVE-2024-42491",
  "github_data": {
    "repository": "asterisk/asterisk",
    "fix_commit": "42a2f4ccfa2c7062a15063e765916b3332e34cc4",
    "related_commits": [
      "42a2f4ccfa2c7062a15063e765916b3332e34cc4",
      "4f01669c7c41c9184f3cce9a3cf1b2ebf6201742",
      "50bf8d4d3064930d28ecf1ce3397b14574d514d2",
      "7a0090325bfa9d778a39ae5f7d0a98109e4651c8",
      "a15050650abf09c10a3c135fab148220cd41d3a0"
    ],
    "patch_url": "https://github.com/asterisk/asterisk/commit/42a2f4ccfa2c7062a15063e765916b3332e34cc4.patch",
    "fix_commit_details": {
      "sha": "42a2f4ccfa2c7062a15063e765916b3332e34cc4",
      "commit_date": "2024-07-22T14:05:03Z",
      "author": {
        "login": "gtjoseph",
        "type": "User",
        "stats": {
          "total_commits": 1056,
          "average_weekly_commits": 0.9271290605794557,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 351
        }
      },
      "commit_message": {
        "title": "manager.c: Add entries to Originate blacklist",
        "length": 638,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 161,
        "additions": 141,
        "deletions": 20
      },
      "files": [
        {
          "filename": "main/manager.c",
          "status": "modified",
          "additions": 141,
          "deletions": 20,
          "patch": "@@ -6243,6 +6243,145 @@ static int action_aocmessage(struct mansession *s, const struct message *m)\n \treturn 0;\n }\n \n+struct originate_permissions_entry {\n+\tconst char *search;\n+\tint permission;\n+\tint (*searchfn)(const char *app, const char *data, const char *search);\n+};\n+\n+/*!\n+ * \\internal\n+ * \\brief Check if the application is allowed for Originate\n+ *\n+ * \\param app The \"app\" parameter\n+ * \\param data The \"appdata\" parameter (ignored)\n+ * \\param search The search string\n+ * \\retval 1 Match\n+ * \\retval 0 No match\n+ */\n+static int app_match(const char *app, const char *data, const char *search)\n+{\n+\t/*\n+\t * We use strcasestr so we don't have to trim any blanks\n+\t * from the front or back of the string.\n+\t */\n+\treturn !!(strcasestr(app, search));\n+}\n+\n+/*!\n+ * \\internal\n+ * \\brief Check if the appdata is allowed for Originate\n+ *\n+ * \\param app The \"app\" parameter (ignored)\n+ * \\param data The \"appdata\" parameter\n+ * \\param search The search string\n+ * \\retval 1 Match\n+ * \\retval 0 No match\n+ */\n+static int appdata_match(const char *app, const char *data, const char *search)\n+{\n+\treturn !!(strstr(data, search));\n+}\n+\n+/*!\n+ * \\internal\n+ * \\brief Check if the Queue application is allowed for Originate\n+ *\n+ * It's only allowed if there's no AGI parameter set\n+ *\n+ * \\param app The \"app\" parameter\n+ * \\param data The \"appdata\" parameter\n+ * \\param search The search string\n+ * \\retval 1 Match\n+ * \\retval 0 No match\n+ */\n+static int queue_match(const char *app, const char *data, const char *search)\n+{\n+\tchar *parse;\n+\tAST_DECLARE_APP_ARGS(args,\n+\t\tAST_APP_ARG(queuename);\n+\t\tAST_APP_ARG(options);\n+\t\tAST_APP_ARG(url);\n+\t\tAST_APP_ARG(announceoverride);\n+\t\tAST_APP_ARG(queuetimeoutstr);\n+\t\tAST_APP_ARG(agi);\n+\t\tAST_APP_ARG(gosub);\n+\t\tAST_APP_ARG(rule);\n+\t\tAST_APP_ARG(position);\n+\t);\n+\n+\tif (!strcasestr(app, \"queue\")) {\n+\t\treturn 0;\n+\t}\n+\n+\tparse = ast_strdupa(data);\n+\tAST_STANDARD_APP_ARGS(args, parse);\n+\n+\t/*\n+\t * The Queue application is fine unless the AGI parameter is set.\n+\t * If it is, we need to check the user's permissions.\n+\t */\n+\treturn !ast_strlen_zero(args.agi);\n+}\n+\n+/*\n+ * The Originate application and application data are passed\n+ * to each searchfn in the list.  If a searchfn returns true\n+ * and the user's permissions don't include the permissions specified\n+ * in the list entry, the Originate action will be denied.\n+ *\n+ * If no searchfn returns true, the Originate action is allowed.\n+ */\n+static struct originate_permissions_entry originate_app_permissions[] = {\n+\t/*\n+\t * The app_match function checks if the search string is\n+\t * anywhere in the app parameter.  The check is case-insensitive.\n+\t */\n+\t{ \"agi\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"dbdeltree\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"exec\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"externalivr\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"mixmonitor\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"originate\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"reload\", EVENT_FLAG_SYSTEM, app_match },\n+\t{ \"system\", EVENT_FLAG_SYSTEM, app_match },\n+\t/*\n+\t * Since the queue_match function specifically checks\n+\t * for the presence of the AGI parameter, we'll allow\n+\t * the call if the user has either the AGI or SYSTEM\n+\t * permission.\n+\t */\n+\t{ \"queue\", EVENT_FLAG_AGI | EVENT_FLAG_SYSTEM, queue_match },\n+\t/*\n+\t * The appdata_match function checks if the search string is\n+\t * anywhere in the appdata parameter.  Unlike app_match,\n+\t * the check is case-sensitive.  These are generally\n+\t * dialplan functions.\n+\t */\n+\t{ \"CURL\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ \"DB\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ \"EVAL\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ \"FILE\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ \"ODBC\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ \"REALTIME\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ \"SHELL\", EVENT_FLAG_SYSTEM, appdata_match },\n+\t{ NULL, 0 },\n+};\n+\n+static int is_originate_app_permitted(const char *app, const char *data,\n+\tint permission)\n+{\n+\tint i;\n+\n+\tfor (i = 0; originate_app_permissions[i].search; i++) {\n+\t\tif (originate_app_permissions[i].searchfn(app, data, originate_app_permissions[i].search)) {\n+\t\t\treturn !!(permission & originate_app_permissions[i].permission);\n+\t\t}\n+\t}\n+\n+\treturn 1;\n+}\n+\n static int action_originate(struct mansession *s, const struct message *m)\n {\n \tconst char *name = astman_get_header(m, \"Channel\");\n@@ -6334,26 +6473,8 @@ static int action_originate(struct mansession *s, const struct message *m)\n \t}\n \n \tif (!ast_strlen_zero(app) && s->session) {\n-\t\tint bad_appdata = 0;\n-\t\t/* To run the System application (or anything else that goes to\n-\t\t * shell), you must have the additional System privilege */\n-\t\tif (!(s->session->writeperm & EVENT_FLAG_SYSTEM)\n-\t\t\t&& (\n-\t\t\t\tstrcasestr(app, \"system\") ||      /* System(rm -rf /)\n-\t\t\t\t                                     TrySystem(rm -rf /)       */\n-\t\t\t\tstrcasestr(app, \"exec\") ||        /* Exec(System(rm -rf /))\n-\t\t\t\t                                     TryExec(System(rm -rf /)) */\n-\t\t\t\tstrcasestr(app, \"agi\") ||         /* AGI(/bin/rm,-rf /)\n-\t\t\t\t                                     EAGI(/bin/rm,-rf /)       */\n-\t\t\t\tstrcasestr(app, \"mixmonitor\") ||  /* MixMonitor(blah,,rm -rf)  */\n-\t\t\t\tstrcasestr(app, \"externalivr\") || /* ExternalIVR(rm -rf)       */\n-\t\t\t\tstrcasestr(app, \"originate\") ||   /* Originate(Local/1234,app,System,rm -rf) */\n-\t\t\t\t(strstr(appdata, \"SHELL\") && (bad_appdata = 1)) ||       /* NoOp(${SHELL(rm -rf /)})  */\n-\t\t\t\t(strstr(appdata, \"EVAL\") && (bad_appdata = 1))           /* NoOp(${EVAL(${some_var_containing_SHELL})}) */\n-\t\t\t\t)) {\n-\t\t\tchar error_buf[64];\n-\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Originate Access Forbidden: %s\", bad_appdata ? \"Data\" : \"Application\");\n-\t\t\tastman_send_error(s, m, error_buf);\n+\t\tif (!is_originate_app_permitted(app, appdata, s->session->writeperm)) {\n+\t\t\tastman_send_error(s, m, \"Originate Access Forbidden: app or data blacklisted\");\n \t\t\tres = 0;\n \t\t\tgoto fast_orig_cleanup;\n \t\t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "831b5ec11d8bfd12cb82818639f0bbbab1e779e2",
            "date": "2025-01-07T20:17:56Z",
            "author_login": "seuros"
          },
          {
            "sha": "468601fd13e9543744c33118abc544b5c942d691",
            "date": "2025-01-02T19:38:30Z",
            "author_login": "seanbright"
          },
          {
            "sha": "4ef68fbce8df8b63759995e2cddc2331ec344b79",
            "date": "2025-01-08T16:57:54Z",
            "author_login": "DooMMasteR"
          },
          {
            "sha": "7b71efd172333fbeb9ffcda45070bacded7a91ba",
            "date": "2025-01-09T19:34:39Z",
            "author_login": "seanbright"
          },
          {
            "sha": "a24853ecdf0593f2d25a04a28a8f0977cf436a9d",
            "date": "2025-01-08T22:00:39Z",
            "author_login": "seuros"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-252",
    "description": "Asterisk is an open-source private branch exchange (PBX). Prior to versions 18.24.3, 20.9.3, and 21.4.3 of Asterisk and versions 18.9-cert12 and 20.7-cert2 of certified-asterisk, if Asterisk attempts to send a SIP request to a URI whose host portion starts with `.1` or `[.1]`, and res_resolver_unbound is loaded, Asterisk will crash with a SEGV. To receive a patch, users should upgrade to one of the following versions: 18.24.3, 20.9.3, 21.4.3, certified-18.9-cert12, certified-20.7-cert2. Two workarounds are available. Disable res_resolver_unbound by setting `noload = res_resolver_unbound.so` in modules.conf, or set `rewrite_contact = yes` on all PJSIP endpoints. NOTE: This may not be appropriate for all Asterisk configurations.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-05T18:15:05.707",
    "last_modified": "2024-09-06T12:08:21.290",
    "fix_date": "2024-07-22T14:05:03Z"
  },
  "references": [
    {
      "url": "https://github.com/asterisk/asterisk/commit/42a2f4ccfa2c7062a15063e765916b3332e34cc4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/commit/4f01669c7c41c9184f3cce9a3cf1b2ebf6201742",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/commit/50bf8d4d3064930d28ecf1ce3397b14574d514d2",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/commit/7a0090325bfa9d778a39ae5f7d0a98109e4651c8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/commit/a15050650abf09c10a3c135fab148220cd41d3a0",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/asterisk/asterisk/security/advisories/GHSA-v428-g3cw-7hv9",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.098993",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "asterisk",
    "owner": "asterisk",
    "created_at": "2015-04-11T17:07:55Z",
    "updated_at": "2025-01-13T17:09:18Z",
    "pushed_at": "2025-01-13T17:09:13Z",
    "size": 374114,
    "stars": 2344,
    "forks": 988,
    "open_issues": 128,
    "watchers": 2344,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 36851690,
      "Python": 358820,
      "Shell": 260947,
      "M4": 191704,
      "Makefile": 139089,
      "Perl": 111005,
      "Yacc": 64828,
      "Mustache": 31730,
      "Lex": 26043,
      "XSLT": 15366,
      "Vim Script": 11793,
      "HTML": 11310,
      "Roff": 10448,
      "JavaScript": 7906,
      "Tcl": 4198,
      "PHP": 2106,
      "Mako": 1730,
      "CSS": 1031,
      "Awk": 642
    },
    "commit_activity": {
      "total_commits_last_year": 211,
      "avg_commits_per_week": 4.0576923076923075,
      "days_active_last_year": 152
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:58:39.405654"
  }
}