{
  "cve_id": "CVE-2024-4323",
  "github_data": {
    "repository": "fluent/fluent-bit",
    "fix_commit": "9311b43a258352797af40749ab31a63c32acfd04",
    "related_commits": [
      "9311b43a258352797af40749ab31a63c32acfd04",
      "9311b43a258352797af40749ab31a63c32acfd04"
    ],
    "patch_url": "https://github.com/fluent/fluent-bit/commit/9311b43a258352797af40749ab31a63c32acfd04.patch",
    "fix_commit_details": {
      "sha": "9311b43a258352797af40749ab31a63c32acfd04",
      "commit_date": "2024-05-15T14:51:02Z",
      "author": {
        "login": "pwhelan",
        "type": "User",
        "stats": {
          "total_commits": 319,
          "average_weekly_commits": 0.5686274509803921,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 74
        }
      },
      "commit_message": {
        "title": "Merge pull request from GHSA-5rjf-prwh-pp7q",
        "length": 1449,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 219,
        "additions": 135,
        "deletions": 84
      },
      "files": [
        {
          "filename": "src/http_server/api/v1/trace.c",
          "status": "modified",
          "additions": 135,
          "deletions": 84,
          "patch": "@@ -30,16 +30,39 @@\n #include <fluent-bit/flb_utils.h>\n #include <msgpack.h>\n \n-\n-static struct flb_input_instance *find_input(struct flb_hs *hs, const char *name)\n+#define STR_INPUTS \"inputs\"\n+#define STR_INPUTS_LEN (sizeof(STR_INPUTS)-1)\n+\n+#define HTTP_FIELD_MESSAGE        \"message\"\n+#define HTTP_FIELD_MESSAGE_LEN    (sizeof(HTTP_FIELD_MESSAGE)-1)\n+#define HTTP_FIELD_STATUS         \"status\"\n+#define HTTP_FIELD_STATUS_LEN     (sizeof(HTTP_FIELD_STATUS)-1)\n+#define HTTP_FIELD_RETURNCODE     \"returncode\"\n+#define HTTP_FIELD_RETURNCODE_LEN (sizeof(HTTP_FIELD_RETURNCODE)-1)\n+\n+#define HTTP_RESULT_OK                   \"ok\"\n+#define HTTP_RESULT_OK_LEN               (sizeof(HTTP_RESULT_OK)-1)\n+#define HTTP_RESULT_ERROR                \"error\"\n+#define HTTP_RESULT_ERROR_LEN            (sizeof(HTTP_RESULT_ERROR)-1)\n+#define HTTP_RESULT_NOTFOUND             \"not found\"\n+#define HTTP_RESULT_NOTFOUND_LEN         (sizeof(HTTP_RESULT_NOTFOUND)-1)\n+#define HTTP_RESULT_METHODNOTALLOWED     \"method not allowed\"\n+#define HTTP_RESULT_METHODNOTALLOWED_LEN (sizeof(HTTP_RESULT_METHODNOTALLOWED)-1)\n+#define HTTP_RESULT_UNKNOWNERROR         \"unknown error\"\n+#define HTTP_RESULT_UNKNOWNERROR_LEN     (sizeof(HTTP_RESULT_UNKNOWNERROR)-1)\n+\n+static struct flb_input_instance *find_input(struct flb_hs *hs, const char *name, size_t nlen)\n {\n     struct mk_list *head;\n     struct flb_input_instance *in;\n \n \n     mk_list_foreach(head, &hs->config->inputs) {\n         in = mk_list_entry(head, struct flb_input_instance, _head);\n-        if (strcmp(name, in->name) == 0) {\n+        if (strlen(in->name) != nlen) {\n+            continue;\n+        }\n+        if (strncmp(name, in->name, nlen) == 0) {\n             return in;\n         }\n         if (in->alias) {\n@@ -51,26 +74,33 @@ static struct flb_input_instance *find_input(struct flb_hs *hs, const char *name\n     return NULL;\n }\n \n-static int enable_trace_input(struct flb_hs *hs, const char *name, const char *prefix, const char *output_name, struct mk_list *props)\n+static int enable_trace_input(struct flb_hs *hs, const char *name, ssize_t nlen, const char *prefix,\n+                              const char *output_name, struct mk_list *props)\n {\n     struct flb_input_instance *in;\n \n-\n-    in = find_input(hs, name);\n+    in = find_input(hs, name, nlen);\n     if (in == NULL) {\n+        flb_error(\"unable to find input: [%d]%.*s\", (int)nlen, (int)nlen, name);\n         return 404;\n     }\n \n     flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n-    return (in->chunk_trace_ctxt == NULL ? 503 : 0);\n+\n+    if (in->chunk_trace_ctxt == NULL) {\n+        flb_error(\"unable to start tracing\");\n+        return 503;\n+    }\n+\n+    return 0;\n }\n \n-static int disable_trace_input(struct flb_hs *hs, const char *name)\n+static int disable_trace_input(struct flb_hs *hs, const char *name, size_t nlen)\n {\n     struct flb_input_instance *in;\n-    \n \n-    in = find_input(hs, name);\n+\n+    in = find_input(hs, name, nlen);\n     if (in == NULL) {\n         return 404;\n     }\n@@ -89,32 +119,35 @@ static flb_sds_t get_input_name(mk_request_t *request)\n     if (request->real_path.data == NULL) {\n         return NULL;\n     }\n-    if (request->real_path.len < strlen(base)) {\n+    if (request->real_path.len < sizeof(base)-1) {\n         return NULL;\n     }\n \n-    return flb_sds_create_len(&request->real_path.data[strlen(base)],\n-                              request->real_path.len - strlen(base));\n+    return flb_sds_create_len(&request->real_path.data[sizeof(base)-1],\n+                              request->real_path.len - sizeof(base)-1);\n }\n \n-static int http_disable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)\n+static int http_disable_trace(mk_request_t *request, void *data,\n+                              const char *input_name, size_t input_nlen,\n+                              msgpack_packer *mp_pck)\n {\n     struct flb_hs *hs = data;\n     int toggled_on = 503;\n \n \n-    toggled_on = disable_trace_input(hs, input_name);\n+    toggled_on = disable_trace_input(hs, input_name, input_nlen);\n     if (toggled_on < 300) {\n         msgpack_pack_map(mp_pck, 1);\n-        msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n-        msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n+        msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+        msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n         return 201;\n     }\n \n     return toggled_on;\n }\n \n-static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *result, const char *input_name)\n+static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *result,\n+                                       const char *input_name, ssize_t input_nlen)\n {\n     int ret = -1;\n     int i;\n@@ -130,11 +163,11 @@ static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *resu\n     msgpack_object_str *param_val;\n \n \n-    if (result->data.type == MSGPACK_OBJECT_MAP) {    \n+    if (result->data.type == MSGPACK_OBJECT_MAP) {\n         for (i = 0; i < result->data.via.map.size; i++) {\n             key = &result->data.via.map.ptr[i].key;\n             val = &result->data.via.map.ptr[i].val;\n-            \n+\n             if (key->type != MSGPACK_OBJECT_STR) {\n                 ret = -1;\n                 goto parse_error;\n@@ -193,7 +226,7 @@ static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *resu\n             output_name = flb_sds_create(\"stdout\");\n         }\n \n-        toggled_on = enable_trace_input(hs, input_name, prefix, output_name, props);\n+        toggled_on = enable_trace_input(hs, input_name, input_nlen, prefix, output_name, props);\n         if (!toggled_on) {\n             ret = -1;\n             goto parse_error;\n@@ -210,7 +243,9 @@ static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *resu\n     return ret;\n }\n \n-static int http_enable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)\n+static int http_enable_trace(mk_request_t *request, void *data,\n+                             const char *input_name, ssize_t input_nlen,\n+                             msgpack_packer *mp_pck)\n {\n     char *buf = NULL;\n     size_t buf_size;\n@@ -229,18 +264,18 @@ static int http_enable_trace(mk_request_t *request, void *data, const char *inpu\n     struct mk_list *props = NULL;\n     struct flb_chunk_trace_limit limit = { 0 };\n     struct flb_input_instance *input_instance;\n-    \n+\n \n     if (request->method == MK_METHOD_GET) {\n-        ret = enable_trace_input(hs, input_name, \"trace.\", \"stdout\", NULL);\n+        ret = enable_trace_input(hs, input_name, input_nlen, \"trace.\", \"stdout\", NULL);\n         if (ret == 0) {\n                 msgpack_pack_map(mp_pck, 1);\n-                msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n-                msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n+                msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+                msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n                 return 200;\n         }\n         else {\n-            flb_error(\"unable to enable tracing for %s\", input_name);\n+            flb_error(\"unable to enable tracing for %.*s\", (int)input_nlen, input_name);\n             goto input_error;\n         }\n     }\n@@ -257,15 +292,15 @@ static int http_enable_trace(mk_request_t *request, void *data, const char *inpu\n     rc = msgpack_unpack_next(&result, buf, buf_size, &off);\n     if (rc != MSGPACK_UNPACK_SUCCESS) {\n         ret = 503;\n-        flb_error(\"unable to unpack msgpack parameters for %s\", input_name);\n+        flb_error(\"unable to unpack msgpack parameters for %.*s\", (int)input_nlen, input_name);\n         goto unpack_error;\n     }\n \n     if (result.data.type == MSGPACK_OBJECT_MAP) {\n         for (i = 0; i < result.data.via.map.size; i++) {\n             key = &result.data.via.map.ptr[i].key;\n             val = &result.data.via.map.ptr[i].val;\n-            \n+\n             if (key->type != MSGPACK_OBJECT_STR) {\n                 ret = 503;\n                 flb_error(\"non string key in parameters\");\n@@ -359,14 +394,14 @@ static int http_enable_trace(mk_request_t *request, void *data, const char *inpu\n             output_name = flb_sds_create(\"stdout\");\n         }\n \n-        ret = enable_trace_input(hs, input_name, prefix, output_name, props);\n+        ret = enable_trace_input(hs, input_name, input_nlen, prefix, output_name, props);\n         if (ret != 0) {\n             flb_error(\"error when enabling tracing\");\n             goto parse_error;\n         }\n \n         if (limit.type != 0) {\n-            input_instance = find_input(hs, input_name);\n+            input_instance = find_input(hs, input_name, input_nlen);\n             if (limit.type == FLB_CHUNK_TRACE_LIMIT_TIME) {\n                 flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.seconds);\n             }\n@@ -377,8 +412,8 @@ static int http_enable_trace(mk_request_t *request, void *data, const char *inpu\n     }\n \n     msgpack_pack_map(mp_pck, 1);\n-    msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n-    msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n+    msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+    msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n \n     ret = 200;\n parse_error:\n@@ -417,21 +452,21 @@ static void cb_trace(mk_request_t *request, void *data)\n     }\n \n     if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {\n-        response = http_enable_trace(request, data, input_name, &mp_pck);\n+        response = http_enable_trace(request, data, input_name, flb_sds_len(input_name), &mp_pck);\n     }\n     else if (request->method == MK_METHOD_DELETE) {\n-        response = http_disable_trace(request, data, input_name, &mp_pck);\n+        response = http_disable_trace(request, data, input_name, flb_sds_len(input_name), &mp_pck);\n     }\n error:\n     if (response == 404) {\n         msgpack_pack_map(&mp_pck, 1);\n-        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-        msgpack_pack_str_with_body(&mp_pck, \"not found\", strlen(\"not found\"));\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n     }\n     else if (response == 503) {\n         msgpack_pack_map(&mp_pck, 1);\n-        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-        msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n     }\n \n     if (input_name != NULL) {\n@@ -466,11 +501,11 @@ static void cb_traces(mk_request_t *request, void *data)\n     msgpack_unpacked result;\n     flb_sds_t error_msg = NULL;\n     int response = 200;\n-    flb_sds_t input_name;\n+    const char *input_name;\n+    ssize_t input_nlen;\n     msgpack_object_array *inputs = NULL;\n     size_t off = 0;\n     int i;\n-    \n \n     /* initialize buffers */\n     msgpack_sbuffer_init(&mp_sbuf);\n@@ -503,10 +538,10 @@ static void cb_traces(mk_request_t *request, void *data)\n         if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n             continue;\n         }\n-        if (result.data.via.map.ptr[i].key.via.str.size < strlen(\"inputs\")) {\n+        if (result.data.via.map.ptr[i].key.via.str.size < STR_INPUTS_LEN) {\n             continue;\n         }\n-        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, \"inputs\", strlen(\"inputs\"))) {\n+        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, STR_INPUTS, STR_INPUTS_LEN)) {\n             continue;\n         }\n         inputs = &result.data.via.map.ptr[i].val.via.array;\n@@ -517,48 +552,61 @@ static void cb_traces(mk_request_t *request, void *data)\n         error_msg = flb_sds_create(\"inputs not found\");\n         goto unpack_error;\n     }\n-    \n+\n     msgpack_pack_map(&mp_pck, 2);\n \n-    msgpack_pack_str_with_body(&mp_pck, \"inputs\", strlen(\"inputs\"));\n+    msgpack_pack_str_with_body(&mp_pck, STR_INPUTS, STR_INPUTS_LEN);\n     msgpack_pack_map(&mp_pck, inputs->size);\n \n     for (i = 0; i < inputs->size; i++) {\n-        input_name = flb_sds_create_len(inputs->ptr[i].via.str.ptr, inputs->ptr[i].via.str.size);\n-        msgpack_pack_str_with_body(&mp_pck, input_name, flb_sds_len(input_name));\n \n-        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR) {\n-            msgpack_pack_map(&mp_pck, 1);\n-            msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-            msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n+        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR || inputs->ptr[i].via.str.ptr == NULL) {\n+            response = 503;\n+            error_msg = flb_sds_create(\"invalid input\");\n+            msgpack_sbuffer_clear(&mp_sbuf);\n+            goto unpack_error;\n         }\n-        else {\n-            if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {\n-                ret = msgpack_params_enable_trace((struct flb_hs *)data, &result, input_name);\n-                if (ret != 0) {\n-                    msgpack_pack_map(&mp_pck, 2);\n-                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-                    msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n-                    msgpack_pack_str_with_body(&mp_pck, \"returncode\", strlen(\"returncode\"));\n-                    msgpack_pack_int64(&mp_pck, ret);\n-                }\n-                else {\n-                    msgpack_pack_map(&mp_pck, 1);\n-                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-                    msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n-                }\n-            }\n-            else if (request->method == MK_METHOD_DELETE) {\n-                disable_trace_input((struct flb_hs *)data, input_name);\n+    }\n+\n+    for (i = 0; i < inputs->size; i++) {\n+\n+        input_name = inputs->ptr[i].via.str.ptr;\n+        input_nlen = inputs->ptr[i].via.str.size;\n+\n+        msgpack_pack_str_with_body(&mp_pck, input_name, input_nlen);\n+\n+        if (request->method == MK_METHOD_POST) {\n+\n+            ret = msgpack_params_enable_trace((struct flb_hs *)data, &result,\n+                                              input_name, input_nlen);\n+\n+            if (ret != 0) {\n+                msgpack_pack_map(&mp_pck, 2);\n+                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n+                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_RETURNCODE,\n+                                           HTTP_FIELD_RETURNCODE_LEN);\n+                msgpack_pack_int64(&mp_pck, ret);\n             }\n             else {\n-                msgpack_pack_map(&mp_pck, 2);\n-                msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-                msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n-                msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n-                msgpack_pack_str_with_body(&mp_pck, \"method not allowed\", strlen(\"method not allowed\"));\n+                msgpack_pack_map(&mp_pck, 1);\n+                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n             }\n         }\n+        else if (request->method == MK_METHOD_DELETE) {\n+            disable_trace_input((struct flb_hs *)data, input_name, input_nlen);\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n+        }\n+        else {\n+            msgpack_pack_map(&mp_pck, 2);\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_METHODNOTALLOWED,\n+                                       HTTP_RESULT_METHODNOTALLOWED_LEN);\n+        }\n     }\n \n     msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\n@@ -569,26 +617,27 @@ static void cb_traces(mk_request_t *request, void *data)\n     msgpack_unpacked_destroy(&result);\n     if (response == 404) {\n         msgpack_pack_map(&mp_pck, 1);\n-        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-        msgpack_pack_str_with_body(&mp_pck, \"not found\", strlen(\"not found\"));\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n     }\n     else if (response == 503) {\n         msgpack_pack_map(&mp_pck, 2);\n-        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-        msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n-        msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n         if (error_msg) {\n             msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n             flb_sds_destroy(error_msg);\n         }\n         else {\n-            msgpack_pack_str_with_body(&mp_pck, \"unknown error\", strlen(\"unknown error\"));\n+            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_UNKNOWNERROR,\n+                                       HTTP_RESULT_UNKNOWNERROR_LEN);\n         }\n     }\n     else {\n         msgpack_pack_map(&mp_pck, 1);\n-        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n-        msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n+        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n     }\n \n     /* Export to JSON */\n@@ -609,7 +658,9 @@ static void cb_traces(mk_request_t *request, void *data)\n /* Perform registration */\n int api_v1_trace(struct flb_hs *hs)\n {\n-    mk_vhost_handler(hs->ctx, hs->vid, \"/api/v1/traces/\", cb_traces, hs);\n-    mk_vhost_handler(hs->ctx, hs->vid, \"/api/v1/trace/*\", cb_trace, hs);\n+    if (hs->config->enable_chunk_trace == FLB_TRUE) {\n+        mk_vhost_handler(hs->ctx, hs->vid, \"/api/v1/traces/\", cb_traces, hs);\n+        mk_vhost_handler(hs->ctx, hs->vid, \"/api/v1/trace/*\", cb_trace, hs);\n+    }\n     return 0;\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "27734ee3e6e6360fe0760259a696fd7e09007625",
            "date": "2025-01-13T10:45:08Z",
            "author_login": "patrick-stephens"
          },
          {
            "sha": "417d12964b92a5d5f29639eb844092caf184cd6e",
            "date": "2025-01-10T15:17:21Z",
            "author_login": "patrick-stephens"
          },
          {
            "sha": "14ca011ff8cfc12cc706fd6c79a0ff9b87798f56",
            "date": "2025-01-09T05:02:48Z",
            "author_login": "erikbledsoe"
          },
          {
            "sha": "e347d3baec32d82021b05abd1243b9a849643d1b",
            "date": "2024-12-19T20:04:32Z",
            "author_login": "leonardo-albertovich"
          },
          {
            "sha": "e70578bf71d71a4cdee0edb5a505104d84cb5033",
            "date": "2024-12-19T20:00:35Z",
            "author_login": "leonardo-albertovich"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-122",
    "description": "A memory corruption vulnerability in Fluent Bit versions 2.0.7 thru 3.0.3. This issue lies in the embedded http server\u2019s parsing of trace requests and may result in denial of service conditions, information disclosure, or remote code execution.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-05-20T12:15:08.720",
    "last_modified": "2024-11-21T09:42:37.500",
    "fix_date": "2024-05-15T14:51:02Z"
  },
  "references": [
    {
      "url": "https://github.com/fluent/fluent-bit/commit/9311b43a258352797af40749ab31a63c32acfd04",
      "source": "vulnreport@tenable.com",
      "tags": []
    },
    {
      "url": "https://tenable.com/security/research/tra-2024-17",
      "source": "vulnreport@tenable.com",
      "tags": []
    },
    {
      "url": "https://github.com/fluent/fluent-bit/commit/9311b43a258352797af40749ab31a63c32acfd04",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://tenable.com/security/research/tra-2024-17",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://www.vicarius.io/vsociety/posts/linguistic-lumberjack-memory-corruption-in-fluent-bit-cve-2024-4323",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:24.265150",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fluent-bit",
    "owner": "fluent",
    "created_at": "2015-01-27T20:41:52Z",
    "updated_at": "2025-01-13T13:13:15Z",
    "pushed_at": "2025-01-14T13:20:46Z",
    "size": 102325,
    "stars": 6449,
    "forks": 1624,
    "open_issues": 657,
    "watchers": 6449,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 55165965,
      "C++": 5639035,
      "Shell": 1682716,
      "CMake": 1103363,
      "Python": 928658,
      "Makefile": 864067,
      "Lua": 490819,
      "Roff": 397957,
      "M4": 388783,
      "HTML": 270237,
      "Go": 216395,
      "Perl": 182667,
      "TypeScript": 117989,
      "Ruby": 77997,
      "JavaScript": 55010,
      "Dockerfile": 52829,
      "Batchfile": 41876,
      "Assembly": 37634,
      "CSS": 33321,
      "WebAssembly": 32148,
      "Yacc": 24607,
      "Lex": 13467,
      "Java": 13004,
      "PowerShell": 4255,
      "BitBake": 3367,
      "Rust": 2600,
      "jq": 1065,
      "Awk": 787,
      "Meson": 772,
      "sed": 588,
      "XSLT": 415,
      "Emacs Lisp": 305,
      "GDB": 199
    },
    "commit_activity": {
      "total_commits_last_year": 930,
      "avg_commits_per_week": 17.884615384615383,
      "days_active_last_year": 242
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:11:51.407298"
  }
}