{
  "cve_id": "CVE-2024-43374",
  "github_data": {
    "repository": "vim/vim",
    "fix_commit": "0a6e57b09bc8c76691b367a5babfb79b31b770e8",
    "related_commits": [
      "0a6e57b09bc8c76691b367a5babfb79b31b770e8"
    ],
    "patch_url": "https://github.com/vim/vim/commit/0a6e57b09bc8c76691b367a5babfb79b31b770e8.patch",
    "fix_commit_details": {
      "sha": "0a6e57b09bc8c76691b367a5babfb79b31b770e8",
      "commit_date": "2024-08-15T20:15:28Z",
      "author": {
        "login": "chrisbra",
        "type": "User",
        "stats": {
          "total_commits": 629,
          "average_weekly_commits": 0.5851162790697675,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 115
        }
      },
      "commit_message": {
        "title": "patch 9.1.0678: [security]: use-after-free in alist_add()",
        "length": 312,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 75,
        "additions": 58,
        "deletions": 17
      },
      "files": [
        {
          "filename": "src/arglist.c",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -184,6 +184,8 @@ alist_set(\n /*\n  * Add file \"fname\" to argument list \"al\".\n  * \"fname\" must have been allocated and \"al\" must have been checked for room.\n+ *\n+ * May trigger Buf* autocommands\n  */\n     void\n alist_add(\n@@ -196,6 +198,7 @@ alist_add(\n     if (check_arglist_locked() == FAIL)\n \treturn;\n     arglist_locked = TRUE;\n+    curwin->w_locked = TRUE;\n \n #ifdef BACKSLASH_IN_FILENAME\n     slash_adjust(fname);\n@@ -207,6 +210,7 @@ alist_add(\n     ++al->al_ga.ga_len;\n \n     arglist_locked = FALSE;\n+    curwin->w_locked = FALSE;\n }\n \n #if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n@@ -365,6 +369,7 @@ alist_add_list(\n \t    mch_memmove(&(ARGLIST[after + count]), &(ARGLIST[after]),\n \t\t\t\t       (ARGCOUNT - after) * sizeof(aentry_T));\n \targlist_locked = TRUE;\n+\tcurwin->w_locked = TRUE;\n \tfor (i = 0; i < count; ++i)\n \t{\n \t    int flags = BLN_LISTED | (will_edit ? BLN_CURBUF : 0);\n@@ -373,6 +378,7 @@ alist_add_list(\n \t    ARGLIST[after + i].ae_fnum = buflist_add(files[i], flags);\n \t}\n \targlist_locked = FALSE;\n+\tcurwin->w_locked = FALSE;\n \tALIST(curwin)->al_ga.ga_len += count;\n \tif (old_argcount > 0 && curwin->w_arg_idx >= after)\n \t    curwin->w_arg_idx += count;"
        },
        {
          "filename": "src/buffer.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1484,7 +1484,7 @@ do_buffer_ext(\n \t// (unless it's the only window).  Repeat this so long as we end up in\n \t// a window with this buffer.\n \twhile (buf == curbuf\n-\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n+\t\t   && !(win_locked(curwin) || curwin->w_buffer->b_locked > 0)\n \t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n \t{\n \t    if (win_close(curwin, FALSE) == FAIL)\n@@ -5470,7 +5470,7 @@ ex_buffer_all(exarg_T *eap)\n \t\t\t    : wp->w_width != Columns)\n \t\t\t|| (had_tab > 0 && wp != firstwin))\n \t\t    && !ONE_WINDOW\n-\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n+\t\t    && !(win_locked(wp) || wp->w_buffer->b_locked > 0)\n \t\t    && !win_unlisted(wp))\n \t    {\n \t\tif (win_close(wp, FALSE) == FAIL)"
        },
        {
          "filename": "src/ex_cmds.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -2840,7 +2840,7 @@ do_ecmd(\n \n \t\t// Set the w_closing flag to avoid that autocommands close the\n \t\t// window.  And set b_locked for the same reason.\n-\t\tthe_curwin->w_closing = TRUE;\n+\t\tthe_curwin->w_locked = TRUE;\n \t\t++buf->b_locked;\n \n \t\tif (curbuf == old_curbuf.br_buf)\n@@ -2854,7 +2854,7 @@ do_ecmd(\n \n \t\t// Autocommands may have closed the window.\n \t\tif (win_valid(the_curwin))\n-\t\t    the_curwin->w_closing = FALSE;\n+\t\t    the_curwin->w_locked = FALSE;\n \t\t--buf->b_locked;\n \n #ifdef FEAT_EVAL"
        },
        {
          "filename": "src/proto/window.pro",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -100,4 +100,5 @@ int get_win_number(win_T *wp, win_T *first_win);\n int get_tab_number(tabpage_T *tp);\n char *check_colorcolumn(win_T *wp);\n int get_last_winid(void);\n+int win_locked(win_T *wp);\n /* vim: set ft=c : */"
        },
        {
          "filename": "src/structs.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -3785,7 +3785,7 @@ struct window_S\n     synblock_T\t*w_s;\t\t    // for :ownsyntax\n #endif\n \n-    int\t\tw_closing;\t    // window is being closed, don't let\n+    int\t\tw_locked;\t    // window is being closed, don't let\n \t\t\t\t    // autocommands close it too.\n \n     frame_T\t*w_frame;\t    // frame containing this window"
        },
        {
          "filename": "src/terminal.c",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -3680,10 +3680,10 @@ term_after_channel_closed(term_T *term)\n \t\tif (is_aucmd_win(curwin))\n \t\t    do_set_w_closing = TRUE;\n \t\tif (do_set_w_closing)\n-\t\t    curwin->w_closing = TRUE;\n+\t\t    curwin->w_locked = TRUE;\n \t\tdo_bufdel(DOBUF_WIPE, (char_u *)\"\", 1, fnum, fnum, FALSE);\n \t\tif (do_set_w_closing)\n-\t\t    curwin->w_closing = FALSE;\n+\t\t    curwin->w_locked = FALSE;\n \t\taucmd_restbuf(&aco);\n \t    }\n #ifdef FEAT_PROP_POPUP"
        },
        {
          "filename": "src/testdir/test_arglist.vim",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -359,6 +359,7 @@ func Test_argv()\n   call assert_equal('', argv(1, 100))\n   call assert_equal([], argv(-1, 100))\n   call assert_equal('', argv(10, -1))\n+  %argdelete\n endfunc\n \n \" Test for the :argedit command\n@@ -744,4 +745,26 @@ func Test_all_command()\n   %bw!\n endfunc\n \n+\" Test for deleting buffer when creating an arglist. This was accessing freed\n+\" memory\n+func Test_crash_arglist_uaf()\n+  \"%argdelete\n+  new one\n+  au BufAdd XUAFlocal :bw\n+  \"call assert_fails(':arglocal XUAFlocal', 'E163:')\n+  arglocal XUAFlocal\n+  au! BufAdd\n+  bw! XUAFlocal\n+\n+  au BufAdd XUAFlocal2 :bw\n+  new two\n+  new three\n+  arglocal\n+  argadd XUAFlocal2 Xfoobar\n+  bw! XUAFlocal2\n+  bw! two\n+\n+  au! BufAdd\n+endfunc\n+\n \" vim: shiftwidth=2 sts=2 expandtab"
        },
        {
          "filename": "src/version.c",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -704,6 +704,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   /* Add new patch number below this line */\n+/**/\n+    678,\n /**/\n     677,\n /**/"
        },
        {
          "filename": "src/window.c",
          "status": "modified",
          "additions": 19,
          "deletions": 10,
          "patch": "@@ -2511,7 +2511,7 @@ close_windows(\n     for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n     {\n \tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n-\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n+\t\t&& !(win_locked(wp) || wp->w_buffer->b_locked > 0))\n \t{\n \t    if (win_close(wp, FALSE) == FAIL)\n \t\t// If closing the window fails give up, to avoid looping\n@@ -2532,7 +2532,7 @@ close_windows(\n \tif (tp != curtab)\n \t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n \t\tif (wp->w_buffer == buf\n-\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n+\t\t    && !(win_locked(wp) || wp->w_buffer->b_locked > 0))\n \t\t{\n \t\t    win_close_othertab(wp, FALSE, tp);\n \n@@ -2654,10 +2654,10 @@ win_close_buffer(win_T *win, int action, int abort_if_last)\n \tbufref_T    bufref;\n \n \tset_bufref(&bufref, curbuf);\n-\twin->w_closing = TRUE;\n+\twin->w_locked = TRUE;\n \tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n \tif (win_valid_any_tab(win))\n-\t    win->w_closing = FALSE;\n+\t    win->w_locked = FALSE;\n \t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n \t// \"wipe\".\n \tif (!bufref_valid(&bufref))\n@@ -2705,7 +2705,7 @@ win_close(win_T *win, int free_buf)\n     if (window_layout_locked(CMD_close))\n \treturn FAIL;\n \n-    if (win->w_closing || (win->w_buffer != NULL\n+    if (win_locked(win) || (win->w_buffer != NULL\n \t\t\t\t\t       && win->w_buffer->b_locked > 0))\n \treturn FAIL; // window is already being closed\n     if (win_unlisted(win))\n@@ -2754,19 +2754,19 @@ win_close(win_T *win, int free_buf)\n \t    other_buffer = TRUE;\n \t    if (!win_valid(win))\n \t\treturn FAIL;\n-\t    win->w_closing = TRUE;\n+\t    win->w_locked = TRUE;\n \t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n \t    if (!win_valid(win))\n \t\treturn FAIL;\n-\t    win->w_closing = FALSE;\n+\t    win->w_locked = FALSE;\n \t    if (last_window())\n \t\treturn FAIL;\n \t}\n-\twin->w_closing = TRUE;\n+\twin->w_locked = TRUE;\n \tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n \tif (!win_valid(win))\n \t    return FAIL;\n-\twin->w_closing = FALSE;\n+\twin->w_locked = FALSE;\n \tif (last_window())\n \t    return FAIL;\n #ifdef FEAT_EVAL\n@@ -3346,7 +3346,7 @@ win_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n \n     // Get here with win->w_buffer == NULL when win_close() detects the tab\n     // page changed.\n-    if (win->w_closing || (win->w_buffer != NULL\n+    if (win_locked(win) || (win->w_buffer != NULL\n \t\t\t\t\t       && win->w_buffer->b_locked > 0))\n \treturn; // window is already being closed\n \n@@ -8000,3 +8000,12 @@ get_last_winid(void)\n {\n     return last_win_id;\n }\n+\n+/*\n+ * Don't let autocommands close the given window\n+ */\n+   int\n+win_locked(win_T *wp)\n+{\n+    return wp->w_locked;\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1aefe1de0b20fe4966863e07efa14b6aa87323ee",
            "date": "2025-01-14T16:29:42Z",
            "author_login": "yegappan"
          },
          {
            "sha": "1ac53b84ada3a992f320566737e66fa00d48611f",
            "date": "2025-01-14T16:25:02Z",
            "author_login": "chrisbra"
          },
          {
            "sha": "57f0119358ed7f060d5020309b9043463121435f",
            "date": "2025-01-14T16:21:42Z",
            "author_login": "h-east"
          },
          {
            "sha": "045564d0a73218594691953c0c8bf2035e1e176e",
            "date": "2025-01-14T16:15:59Z",
            "author_login": "habamax"
          },
          {
            "sha": "6289f9159102e0855bedc566636b5e7ca6ced72c",
            "date": "2025-01-14T16:13:36Z",
            "author_login": "yegappan"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 4.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-416",
    "description": "The UNIX editor Vim prior to version 9.1.0678 has a use-after-free error in argument list handling. When adding a new file to the argument list, this triggers `Buf*` autocommands. If in such an autocommand the buffer that was just opened is closed (including the window where it is shown), this causes the window structure to be freed which contains a reference to the argument list that we are actually modifying. Once the autocommands are completed, the references to the window and argument list are no longer valid and as such cause an use-after-free. Impact is low since the user must either intentionally add some unusual autocommands that wipe a buffer during creation (either manually or by sourcing a malicious plugin), but it will crash Vim. The issue has been fixed as of Vim patch v9.1.0678.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-08-16T02:15:17.687",
    "last_modified": "2024-11-21T09:35:23.467",
    "fix_date": "2024-08-15T20:15:28Z"
  },
  "references": [
    {
      "url": "https://github.com/vim/vim/commit/0a6e57b09bc8c76691b367a5babfb79b31b770e8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/vim/vim/security/advisories/GHSA-2w8m-443v-cgvw",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/15/6",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240920-0004/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.358428",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vim",
    "owner": "vim",
    "created_at": "2015-08-18T21:03:56Z",
    "updated_at": "2025-01-14T08:58:33Z",
    "pushed_at": "2025-01-13T07:25:13Z",
    "size": 153925,
    "stars": 37215,
    "forks": 5529,
    "open_issues": 1516,
    "watchers": 37215,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Vim Script": 20025864,
      "C": 14374546,
      "Roff": 576344,
      "Makefile": 490522,
      "C++": 246793,
      "NSIS": 180936,
      "M4": 159971,
      "Java": 85446,
      "Shell": 71333,
      "PostScript": 64070,
      "Module Management System": 56375,
      "Python": 51761,
      "XS": 51261,
      "Ruby": 40309,
      "JavaScript": 37774,
      "NewLisp": 37431,
      "Raku": 34258,
      "Emacs Lisp": 30304,
      "Perl": 29735,
      "SystemVerilog": 27883,
      "Smalltalk": 25762,
      "Awk": 19481,
      "Batchfile": 18475,
      "Objective-C": 13147,
      "DIGITAL Command Language": 10835,
      "HTML": 6885,
      "Prolog": 4336,
      "KRL": 4206,
      "MATLAB": 1970,
      "Thrift": 1670,
      "OpenEdge ABL": 1490,
      "sed": 826,
      "Tcl": 745,
      "Lua": 738,
      "BitBake": 388
    },
    "commit_activity": {
      "total_commits_last_year": 1872,
      "avg_commits_per_week": 36.0,
      "days_active_last_year": 324
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "vim"
    },
    "collected_at": "2025-01-14T12:54:52.772009"
  }
}