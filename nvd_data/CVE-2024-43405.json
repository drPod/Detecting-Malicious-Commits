{
  "cve_id": "CVE-2024-43405",
  "github_data": {
    "repository": "projectdiscovery/nuclei",
    "fix_commit": "0da993afe6d41b4b1b814e8fad23a2acba13c60a",
    "related_commits": [
      "0da993afe6d41b4b1b814e8fad23a2acba13c60a"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "0da993afe6d41b4b1b814e8fad23a2acba13c60a",
      "commit_date": "2024-08-19T12:32:54Z",
      "author": {
        "login": "Mzack9999",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 590,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 186,
        "additions": 161,
        "deletions": 25
      },
      "files": [
        {
          "filename": "pkg/templates/signer/tmpl_signer.go",
          "status": "modified",
          "additions": 33,
          "deletions": 24,
          "patch": "@@ -11,7 +11,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"os\"\n-\t\"regexp\"\n \t\"strings\"\n \t\"sync\"\n \n@@ -21,18 +20,21 @@ import (\n )\n \n var (\n-\tReDigest            = regexp.MustCompile(`(?m)^#\\sdigest:\\s.+$`)\n \tErrUnknownAlgorithm = errors.New(\"unknown algorithm\")\n \tSignaturePattern    = \"# digest: \"\n \tSignatureFmt        = SignaturePattern + \"%x\" + \":%v\" // `#digest: <signature>:<fragment>`\n )\n \n-func RemoveSignatureFromData(data []byte) []byte {\n-\treturn bytes.Trim(ReDigest.ReplaceAll(data, []byte(\"\")), \"\\n\")\n-}\n-\n-func GetSignatureFromData(data []byte) []byte {\n-\treturn ReDigest.Find(data)\n+// ExtractSignatureAndContent extracts the signature (if present) and returns the content without the signature\n+func ExtractSignatureAndContent(data []byte) (signature, content []byte) {\n+\tdataStr := string(data)\n+\tif idx := strings.LastIndex(dataStr, SignaturePattern); idx != -1 {\n+\t\tsignature = []byte(strings.TrimSpace(dataStr[idx:]))\n+\t\tcontent = []byte(strings.TrimSpace(dataStr[:idx]))\n+\t} else {\n+\t\tcontent = data\n+\t}\n+\treturn\n }\n \n // SignableTemplate is a template that can be signed\n@@ -69,26 +71,29 @@ func (t *TemplateSigner) GetUserFragment() string {\n \n // Sign signs the given template with the template signer and returns the signature\n func (t *TemplateSigner) Sign(data []byte, tmpl SignableTemplate) (string, error) {\n+\texistingSignature, content := ExtractSignatureAndContent(data)\n+\n \t// while re-signing template check if it has a code protocol\n \t// if it does then verify that it is signed by current signer\n \t// if not then return error\n \tif tmpl.HasCodeProtocol() {\n-\t\tsig := GetSignatureFromData(data)\n-\t\tarr := strings.SplitN(string(sig), \":\", 3)\n-\t\tif len(arr) == 2 {\n-\t\t\t// signature has no fragment\n-\t\t\treturn \"\", errorutil.NewWithTag(\"signer\", \"re-signing code templates are not allowed for security reasons.\")\n-\t\t}\n-\t\tif len(arr) == 3 {\n-\t\t\t// signature has fragment verify if it is equal to current fragment\n-\t\t\tfragment := t.GetUserFragment()\n-\t\t\tif fragment != arr[2] {\n+\t\tif len(existingSignature) > 0 {\n+\t\t\tarr := strings.SplitN(string(existingSignature), \":\", 3)\n+\t\t\tif len(arr) == 2 {\n+\t\t\t\t// signature has no fragment\n \t\t\t\treturn \"\", errorutil.NewWithTag(\"signer\", \"re-signing code templates are not allowed for security reasons.\")\n \t\t\t}\n+\t\t\tif len(arr) == 3 {\n+\t\t\t\t// signature has fragment verify if it is equal to current fragment\n+\t\t\t\tfragment := t.GetUserFragment()\n+\t\t\t\tif fragment != arr[2] {\n+\t\t\t\t\treturn \"\", errorutil.NewWithTag(\"signer\", \"re-signing code templates are not allowed for security reasons.\")\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n \n-\tbuff := bytes.NewBuffer(RemoveSignatureFromData(data))\n+\tbuff := bytes.NewBuffer(content)\n \t// if file has any imports process them\n \tfor _, file := range tmpl.GetFileImports() {\n \t\tbin, err := os.ReadFile(file)\n@@ -123,20 +128,24 @@ func (t *TemplateSigner) sign(data []byte) (string, error) {\n \n // Verify verifies the given template with the template signer\n func (t *TemplateSigner) Verify(data []byte, tmpl SignableTemplate) (bool, error) {\n-\tdigestData := ReDigest.Find(data)\n-\tif len(digestData) == 0 {\n-\t\treturn false, errors.New(\"digest not found\")\n+\tsignature, content := ExtractSignatureAndContent(data)\n+\tif len(signature) == 0 {\n+\t\treturn false, errors.New(\"no signature found\")\n+\t}\n+\n+\tif !bytes.HasPrefix(signature, []byte(SignaturePattern)) {\n+\t\treturn false, errors.New(\"signature must be at the end of the template\")\n \t}\n \n-\tdigestData = bytes.TrimSpace(bytes.TrimPrefix(digestData, []byte(SignaturePattern)))\n+\tdigestData := bytes.TrimSpace(bytes.TrimPrefix(signature, []byte(SignaturePattern)))\n \t// remove fragment from digest as it is used for re-signing purposes only\n \tdigestString := strings.TrimSuffix(string(digestData), \":\"+t.GetUserFragment())\n \tdigest, err := hex.DecodeString(digestString)\n \tif err != nil {\n \t\treturn false, err\n \t}\n \n-\tbuff := bytes.NewBuffer(RemoveSignatureFromData(data))\n+\tbuff := bytes.NewBuffer(content)\n \t// if file has any imports process them\n \tfor _, file := range tmpl.GetFileImports() {\n \t\tbin, err := os.ReadFile(file)"
        },
        {
          "filename": "pkg/templates/signer/tmpl_signer_test.go",
          "status": "added",
          "additions": 126,
          "deletions": 0,
          "patch": "@@ -0,0 +1,126 @@\n+package signer\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+const (\n+\ttestCertFile = \"../../../integration_tests/protocols/keys/ci.crt\"\n+\ttestKeyFile  = \"../../../integration_tests/protocols/keys/ci-private-key.pem\"\n+)\n+\n+type mockSignableTemplate struct {\n+\timports []string\n+\thasCode bool\n+}\n+\n+func (m *mockSignableTemplate) GetFileImports() []string {\n+\treturn m.imports\n+}\n+\n+func (m *mockSignableTemplate) HasCodeProtocol() bool {\n+\treturn m.hasCode\n+}\n+\n+var signer, _ = NewTemplateSignerFromFiles(testCertFile, testKeyFile)\n+\n+func TestTemplateSignerSignAndVerify(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\n+\ttests := []struct {\n+\t\tname            string\n+\t\tdata            []byte\n+\t\ttmpl            SignableTemplate\n+\t\twantSignErr     bool\n+\t\twantVerifyErr   bool\n+\t\twantVerified    bool\n+\t\tmodifyAfterSign func([]byte) []byte\n+\t}{\n+\t\t{\n+\t\t\tname:         \"Simple template\",\n+\t\t\tdata:         []byte(\"id: test-template\\ninfo:\\n  name: Test Template\"),\n+\t\t\ttmpl:         &mockSignableTemplate{},\n+\t\t\twantVerified: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Template with imports\",\n+\t\t\tdata: []byte(\"id: test-template\\ninfo:\\n  name: Test Template\"),\n+\t\t\ttmpl: &mockSignableTemplate{imports: []string{\n+\t\t\t\tfilepath.Join(tempDir, \"import1.yaml\"),\n+\t\t\t\tfilepath.Join(tempDir, \"import2.yaml\"),\n+\t\t\t}},\n+\t\t\twantVerified: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"Template with code protocol\",\n+\t\t\tdata:         []byte(\"id: test-template\\ninfo:\\n  name: Test Template\\n\\ncode:\\n  - engine: bash\\n    source: echo 'Hello, World!'\"),\n+\t\t\ttmpl:         &mockSignableTemplate{hasCode: true},\n+\t\t\twantSignErr:  false,\n+\t\t\twantVerified: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Tampered template\",\n+\t\t\tdata: []byte(\"id: test-template\\ninfo:\\n  name: Test Template\"),\n+\t\t\ttmpl: &mockSignableTemplate{},\n+\t\t\tmodifyAfterSign: func(data []byte) []byte {\n+\t\t\t\tsignatureIndex := bytes.LastIndex(data, []byte(SignaturePattern))\n+\t\t\t\tif signatureIndex == -1 {\n+\t\t\t\t\treturn data\n+\t\t\t\t}\n+\t\t\t\treturn append(data[:signatureIndex], append([]byte(\"# Tampered content\\n\"), data[signatureIndex:]...)...)\n+\t\t\t},\n+\t\t\twantVerified: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Invalid signature\",\n+\t\t\tdata: []byte(\"id: test-template\\ninfo:\\n  name: Test Template\"),\n+\t\t\ttmpl: &mockSignableTemplate{},\n+\t\t\tmodifyAfterSign: func(data []byte) []byte {\n+\t\t\t\treturn append(bytes.TrimSuffix(data, []byte(\"\\n\")), []byte(\"\\n# digest: invalid_signature:fragment\")...)\n+\t\t\t},\n+\t\t\twantVerifyErr: true,\n+\t\t\twantVerified:  false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Create import files if needed\n+\t\t\tfor _, imp := range tt.tmpl.GetFileImports() {\n+\t\t\t\terr := os.WriteFile(imp, []byte(\"imported content\"), 0644)\n+\t\t\t\trequire.NoError(t, err, \"Failed to create import file\")\n+\t\t\t}\n+\n+\t\t\t// Sign the template\n+\t\t\tsignature, err := signer.Sign(tt.data, tt.tmpl)\n+\t\t\tif tt.wantSignErr {\n+\t\t\t\tassert.Error(t, err, \"Expected an error during signing\")\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\trequire.NoError(t, err, \"Failed to sign template\")\n+\n+\t\t\t// Append signature to the template data\n+\t\t\tsignedData := append(tt.data, []byte(\"\\n\"+signature)...)\n+\n+\t\t\t// Apply any modifications after signing if specified\n+\t\t\tif tt.modifyAfterSign != nil {\n+\t\t\t\tsignedData = tt.modifyAfterSign(signedData)\n+\t\t\t}\n+\n+\t\t\t// Verify the signature\n+\t\t\tverified, err := signer.Verify(signedData, tt.tmpl)\n+\t\t\tif tt.wantVerifyErr {\n+\t\t\t\tassert.Error(t, err, \"Expected an error during verification\")\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err, \"Unexpected error during verification\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, tt.wantVerified, verified, \"Unexpected verification result\")\n+\t\t})\n+\t}\n+}"
        },
        {
          "filename": "pkg/templates/template_sign.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -75,11 +75,12 @@ func SignTemplate(templateSigner *signer.TemplateSigner, templatePath string) er\n \t\treturn ErrNotATemplate\n \t}\n \tif !template.Verified {\n+\t\t_, content := signer.ExtractSignatureAndContent(bin)\n \t\tsignatureData, err := templateSigner.Sign(bin, template)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tbuff := bytes.NewBuffer(signer.RemoveSignatureFromData(bin))\n+\t\tbuff := bytes.NewBuffer(content)\n \t\tbuff.WriteString(\"\\n\" + signatureData)\n \t\treturn os.WriteFile(templatePath, buff.Bytes(), 0644)\n \t}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a0c30755f3f057ceb353cbcde8939e7e0cb3ccce",
            "date": "2025-01-22T12:09:03Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1bb22b69daca079a12b10923ec6587cb9907ccd1",
            "date": "2025-01-20T05:40:56Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "e4a0b8ec6054410887fcd8cfc569f7e388b2c8d0",
            "date": "2025-01-14T18:59:30Z",
            "author_login": "doug-threatmate"
          },
          {
            "sha": "08c46ffaeb0ba39dec949015eda3342d465188bf",
            "date": "2025-01-14T10:05:12Z",
            "author_login": "meme-lord"
          },
          {
            "sha": "2450ecb50359ac5e9df42be6c0e92e9d15cd547d",
            "date": "2025-01-14T10:00:17Z",
            "author_login": "dwisiswant0"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "cwe_id": "CWE-78",
    "description": "Nuclei is a vulnerability scanner powered by YAML based templates. Starting in version 3.0.0 and prior to version 3.3.2, a vulnerability in Nuclei's template signature verification system could allow an attacker to bypass the signature check and possibly execute malicious code via custom code template. The vulnerability is present in the template signature verification process, specifically in the `signer` package. The vulnerability stems from a discrepancy between how the signature verification process and the YAML parser handle newline characters, combined with the way multiple signatures are processed. This allows an attacker to inject malicious content into a template while maintaining a valid signature for the benign part of the template. CLI users are affected if they execute custom code templates from unverified sources. This includes templates authored by third parties or obtained from unverified repositories. SDK Users are affected if they are developers integrating Nuclei into their platforms, particularly if they permit the execution of custom code templates by end-users. The vulnerability is addressed in Nuclei v3.3.2. Users are strongly recommended to update to this version to mitigate the security risk. As an interim measure, users should refrain from using custom templates if unable to upgrade immediately. Only trusted, verified templates should be executed. Those who are unable to upgrade Nuclei should disable running custom code templates as a workaround.",
    "attack_vector": "LOCAL",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-09-04T16:15:06.853",
    "last_modified": "2024-10-01T15:37:37.337",
    "fix_date": "2024-08-19T12:32:54Z"
  },
  "references": [
    {
      "url": "https://github.com/projectdiscovery/nuclei/commit/0da993afe6d41b4b1b814e8fad23a2acba13c60a",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/projectdiscovery/nuclei/security/advisories/GHSA-7h5p-mmpp-hgmm",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.462253",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "nuclei",
    "owner": "projectdiscovery",
    "created_at": "2020-04-03T18:47:11Z",
    "updated_at": "2025-01-25T23:07:37Z",
    "pushed_at": "2025-01-24T08:33:59Z",
    "size": 39914,
    "stars": 21911,
    "forks": 2581,
    "open_issues": 388,
    "watchers": 21911,
    "has_security_policy": false,
    "default_branch": "dev",
    "protected_branches": [
      "dev",
      "main"
    ],
    "languages": {
      "Go": 2490272,
      "TypeScript": 74911,
      "JavaScript": 6977,
      "Shell": 5554,
      "Makefile": 3971,
      "Smarty": 2565,
      "Dockerfile": 332,
      "Python": 50
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T07:57:26.352118"
  }
}