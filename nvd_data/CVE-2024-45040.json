{
  "cve_id": "CVE-2024-45040",
  "github_data": {
    "repository": "Consensys/gnark",
    "fix_commit": "afda68a38acca37becb8ba6d8982d03fee9559a0",
    "related_commits": [
      "afda68a38acca37becb8ba6d8982d03fee9559a0"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "afda68a38acca37becb8ba6d8982d03fee9559a0",
      "commit_date": "2024-08-22T09:40:23Z",
      "author": {
        "login": "Tabaie",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "feat add random mask to groth16 commitment (#1245)",
        "length": 441,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 135,
        "additions": 130,
        "deletions": 5
      },
      "files": [
        {
          "filename": "constraint/solver/hint_registry.go",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -2,14 +2,15 @@ package solver\n \n import (\n \t\"fmt\"\n+\t\"github.com/consensys/gnark/internal/hints\"\n \t\"math/big\"\n \t\"sync\"\n \n \t\"github.com/consensys/gnark/logger\"\n )\n \n func init() {\n-\tRegisterHint(InvZeroHint)\n+\tRegisterHint(InvZeroHint, hints.Randomize)\n }\n \n var ("
        },
        {
          "filename": "frontend/cs/r1cs/api.go",
          "status": "modified",
          "additions": 14,
          "deletions": 0,
          "patch": "@@ -19,6 +19,7 @@ package r1cs\n import (\n \t\"errors\"\n \t\"fmt\"\n+\t\"github.com/consensys/gnark/internal/hints\"\n \t\"path/filepath\"\n \t\"reflect\"\n \t\"runtime\"\n@@ -687,6 +688,19 @@ func (builder *builder) Compiler() frontend.Compiler {\n \n func (builder *builder) Commit(v ...frontend.Variable) (frontend.Variable, error) {\n \n+\t// add a random mask to v\n+\t{\n+\t\tvCp := make([]frontend.Variable, len(v)+1)\n+\t\tcopy(vCp, v)\n+\t\tmask, err := builder.NewHint(hints.Randomize, 1)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tvCp[len(v)] = mask[0]\n+\t\tbuilder.cs.AddR1C(builder.newR1C(mask[0], builder.eOne, mask[0]), builder.genericGate) // the variable needs to be involved in a constraint otherwise it will not affect the commitment\n+\t\tv = vCp\n+\t}\n+\n \tcommitments := builder.cs.GetCommitments().(constraint.Groth16Commitments)\n \texistingCommitmentIndexes := commitments.CommitmentIndexes()\n \tprivateCommittedSeeker := utils.MultiListSeeker(commitments.GetPrivateCommitted())"
        },
        {
          "filename": "internal/hints/hints.go",
          "status": "added",
          "additions": 20,
          "deletions": 0,
          "patch": "@@ -0,0 +1,20 @@\n+package hints\n+\n+import (\n+\t\"crypto/rand\"\n+\t\"errors\"\n+\t\"math/big\"\n+)\n+\n+func Randomize(mod *big.Int, ins, outs []*big.Int) error {\n+\tif len(ins) != 0 {\n+\t\treturn errors.New(\"randomize takes no input\")\n+\t}\n+\tvar err error\n+\tfor i := range outs {\n+\t\tif outs[i], err = rand.Int(rand.Reader, mod); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}"
        },
        {
          "filename": "internal/security_tests/advisory-9xcg/advisory_test.go",
          "status": "added",
          "additions": 89,
          "deletions": 0,
          "patch": "@@ -0,0 +1,89 @@\n+// Package advisory9xcg implements a test for advisory GHSA-9xcg-3q8v-7fq6.\n+package advisory9xcg\n+\n+import (\n+\t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"math/big\"\n+\t\"testing\"\n+\n+\t\"github.com/consensys/gnark-crypto/ecc\"\n+\t\"github.com/consensys/gnark-crypto/ecc/bn254\"\n+\t\"github.com/consensys/gnark/backend/groth16\"\n+\tgroth16_bn254 \"github.com/consensys/gnark/backend/groth16/bn254\"\n+\t\"github.com/consensys/gnark/frontend\"\n+\t\"github.com/consensys/gnark/frontend/cs/r1cs\"\n+\t\"github.com/consensys/gnark/test\"\n+)\n+\n+type Circuit struct {\n+\tSecretWitness frontend.Variable `gnark:\",private\"`\n+}\n+\n+func (circuit *Circuit) Define(api frontend.API) error {\n+\t// the goal of the test is to show that we are able to predict the private\n+\t// input solely from the stored commitment.\n+\tcommitCompiler, ok := api.Compiler().(frontend.Committer)\n+\tif !ok {\n+\t\treturn fmt.Errorf(\"compiler does not commit\")\n+\t}\n+\n+\tcommit, err := commitCompiler.Commit(circuit.SecretWitness)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tapi.AssertIsDifferent(commit, 0)\n+\tapi.AssertIsDifferent(circuit.SecretWitness, 0)\n+\treturn nil\n+}\n+\n+func TestAdvisory_ghsa_9xcg_3q8v_7fq6(t *testing.T) {\n+\tassert := test.NewAssert(t)\n+\t// the goal of the test is to show that we are able to predict the private\n+\t// input solely from the stored commitment\n+\n+\t// Generating a random secret witness.\n+\tvar bound int64 = 1024 // ten bits of entropy for testing\n+\tsecretWitness, err := rand.Int(rand.Reader, big.NewInt(bound))\n+\tassert.NoError(err, \"random generation failed\")\n+\tassert.Log(\"random secret witness: \", secretWitness)\n+\n+\t// Assigning some values.\n+\tassignment := Circuit{SecretWitness: secretWitness}\n+\twitness, err := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())\n+\tassert.NoError(err, \"witness creation failed\")\n+\twitnessPublic, err := witness.Public()\n+\tassert.NoError(err, \"witness public failed\")\n+\n+\t// Setup circuit\n+\tccs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &Circuit{})\n+\tassert.NoError(err, \"compilation failed\")\n+\n+\t// run the setup and prover\n+\tpk, vk, err := groth16.Setup(ccs)\n+\tassert.NoError(err, \"setup failed\")\n+\tproof, err := groth16.Prove(ccs, pk, witness)\n+\tassert.NoError(err, \"proof failed\")\n+\n+\t// sanity check, check that the proof verifies\n+\terr = groth16.Verify(proof, vk, witnessPublic)\n+\tassert.NoError(err, \"verification failed\")\n+\n+\t// we're ready to set up the attack. For that first we need to assert the\n+\t// exact types for being able to extract the proving key information.\n+\tpkConcrete, ok := pk.(*groth16_bn254.ProvingKey)\n+\tassert.True(ok, \"unexpected type for proving key\")\n+\tproofConcrete, ok := proof.(*groth16_bn254.Proof)\n+\tassert.True(ok, \"unexpected type for proof\")\n+\n+\tvar guessedCommitment bn254.G1Affine\n+\tfor i := int64(0); i < bound; i++ {\n+\t\t// We check our guess for the secret witness.\n+\t\tguessedCommitment.ScalarMultiplication(&pkConcrete.CommitmentKeys[0].Basis[0], big.NewInt(int64(i)))\n+\t\tif guessedCommitment.Equal(&proofConcrete.Commitments[0]) {\n+\t\t\tassert.Fail(\"secret witness found: \", i)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "internal/stats/latest.stats",
          "status": "modified",
          "additions": 0,
          "deletions": 0,
          "patch": null
        },
        {
          "filename": "std/multicommit/nativecommit_test.go",
          "status": "modified",
          "additions": 5,
          "deletions": 4,
          "patch": "@@ -4,7 +4,6 @@ import (\n \t\"testing\"\n \n \t\"github.com/consensys/gnark-crypto/ecc\"\n-\t\"github.com/consensys/gnark/backend\"\n \t\"github.com/consensys/gnark/frontend\"\n \t\"github.com/consensys/gnark/frontend/cs/r1cs\"\n \t\"github.com/consensys/gnark/test\"\n@@ -52,7 +51,7 @@ func TestMultipleCommitments(t *testing.T) {\n \tcircuit := multipleCommitmentCircuit{}\n \tassignment := multipleCommitmentCircuit{X: 10}\n \tassert := test.NewAssert(t)\n-\tassert.ProverSucceeded(&circuit, &assignment, test.WithCurves(ecc.BN254), test.WithBackends(backend.GROTH16)) // right now PLONK doesn't implement commitment\n+\tassert.ProverSucceeded(&circuit, &assignment, test.WithCurves(ecc.BN254)) // right now PLONK doesn't implement commitment\n }\n \n type noCommitVariable struct {\n@@ -64,9 +63,11 @@ func (c *noCommitVariable) Define(api frontend.API) error {\n \treturn nil\n }\n \n+// TestNoCommitVariable checks that a circuit that doesn't use the commitment variable\n+// compiles and prover succeeds. This is due to the randomization of the commitment.\n func TestNoCommitVariable(t *testing.T) {\n \tcircuit := noCommitVariable{}\n+\tassignment := noCommitVariable{X: 10}\n \tassert := test.NewAssert(t)\n-\t_, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)\n-\tassert.Error(err)\n+\tassert.ProverSucceeded(&circuit, &assignment, test.WithCurves(ecc.BN254))\n }"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 6,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eb1876387732c2d8fe9ab9601e1fdb5df52f6311",
            "date": "2025-01-24T00:16:49Z",
            "author_login": "ivokub"
          },
          {
            "sha": "ac1472ae0218fbb7a8509635ade9385c77c349f8",
            "date": "2025-01-21T21:52:57Z",
            "author_login": "ivokub"
          },
          {
            "sha": "5a846d131dbca54af4193055f1a4463baee6121f",
            "date": "2025-01-21T15:34:24Z",
            "author_login": "ivokub"
          },
          {
            "sha": "52291fae4c98b985d584043135e2b81b69e1c8b5",
            "date": "2025-01-21T15:25:31Z",
            "author_login": "yelhousni"
          },
          {
            "sha": "3a407c10927bda2b2ed04cc04757b4ba2bf81c32",
            "date": "2025-01-17T10:14:14Z",
            "author_login": "ThomasPiellard"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.9,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
    "cwe_id": "CWE-200",
    "description": "gnark is a fast zk-SNARK library that offers a high-level API to design circuits. Prior to version 0.11.0, commitments to private witnesses in Groth16 as implemented break the zero-knowledge property. The vulnerability affects only Groth16 proofs with commitments. Notably, PLONK proofs are not affected. The vulnerability affects the zero-knowledge property of the proofs - in case the witness (secret or internal) values are small, then the attacker may be able to enumerate all possible choices to deduce the actual value. If the possible choices for the variables to be committed is large or there are many values committed, then it would be computationally infeasible to enumerate all valid choices. It doesn't affect the completeness/soundness of the proofs. The vulnerability has been fixed in version 0.11.0. The patch to fix the issue is to add additional randomized value to the list of committed value at proving time to mask the rest of the values which were committed. As a workaround, the user can manually commit to a randomized value.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-09-06T13:15:04.893",
    "last_modified": "2024-09-20T00:13:23.323",
    "fix_date": "2024-08-22T09:40:23Z"
  },
  "references": [
    {
      "url": "https://github.com/Consensys/gnark/commit/afda68a38acca37becb8ba6d8982d03fee9559a0",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Consensys/gnark/pull/1245",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/Consensys/gnark/security/advisories/GHSA-9xcg-3q8v-7fq6",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.100230",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "gnark",
    "owner": "Consensys",
    "created_at": "2020-02-24T16:08:21Z",
    "updated_at": "2025-01-24T06:23:59Z",
    "pushed_at": "2025-01-24T04:03:58Z",
    "size": 26153,
    "stars": 1487,
    "forks": 410,
    "open_issues": 120,
    "watchers": 1487,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "Go": 2661381
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-26T08:04:46.581151"
  }
}