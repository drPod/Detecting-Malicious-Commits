{
  "cve_id": "CVE-2024-45044",
  "github_data": {
    "repository": "bareos/bareos",
    "fix_commit": "2a026698b87d13bd1c6275726b5e826702f81dd5",
    "related_commits": [
      "2a026698b87d13bd1c6275726b5e826702f81dd5"
    ],
    "patch_url": "https://github.com/bareos/bareos/commit/2a026698b87d13bd1c6275726b5e826702f81dd5.patch",
    "fix_commit_details": {
      "sha": "2a026698b87d13bd1c6275726b5e826702f81dd5",
      "commit_date": "2024-07-12T14:41:08Z",
      "author": {
        "login": "BareosBot",
        "type": "User",
        "stats": {
          "total_commits": 437,
          "average_weekly_commits": 0.7003205128205128,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 71
        }
      },
      "commit_message": {
        "title": "Merge pull request #1875",
        "length": 56,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1166,
        "additions": 516,
        "deletions": 650
      },
      "files": [
        {
          "filename": ".gitignore",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -1,6 +1,9 @@\n # generated version files\n cmake/BareosVersion.cmake\n \n+# python\n+__pycache__\n+\n # docs\n docs/manuals/source/include/autogenerated/*.rst.inc\n docs/manuals/source/include/autogenerated/autosummary/"
        },
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -112,6 +112,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n - fix warnings on FreeBSD 13.3 compiler [PR #1881]\n - dir: fix crash on purge with job without client [PR #1857]\n - fix runtime status [PR #1872]\n+- Fix multiple ACL handling bugs [PR #1875]\n \n [PR #1538]: https://github.com/bareos/bareos/pull/1538\n [PR #1581]: https://github.com/bareos/bareos/pull/1581\n@@ -208,6 +209,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n [PR #1865]: https://github.com/bareos/bareos/pull/1865\n [PR #1868]: https://github.com/bareos/bareos/pull/1868\n [PR #1872]: https://github.com/bareos/bareos/pull/1872\n+[PR #1875]: https://github.com/bareos/bareos/pull/1875\n [PR #1878]: https://github.com/bareos/bareos/pull/1878\n [PR #1881]: https://github.com/bareos/bareos/pull/1881\n [PR #1883]: https://github.com/bareos/bareos/pull/1883"
        },
        {
          "filename": "core/src/dird/dird_conf.cc",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -174,7 +174,7 @@ static ResourceItem dir_items[] = {\n   { \"CatalogAcl\", CFG_TYPE_ACL, ITEM(resource, ACL_lists), Catalog_ACL, 0, NULL, NULL,\\\n      \"Lists the Catalog resources, this resource has access to. The special keyword *all* allows access to all Catalog resources.\" },\\\n   { \"WhereAcl\", CFG_TYPE_ACL, ITEM(resource, ACL_lists), Where_ACL, 0, NULL, NULL,\\\n-     \"Specifies the base directories, where files could be restored. An empty string allows restores to all directories.\" },\\\n+     \"Specifies the base directories, where files could be restored.\" },\\\n   { \"PluginOptionsAcl\", CFG_TYPE_ACL, ITEM(resource, ACL_lists), PluginOptions_ACL, 0, NULL, NULL,\\\n      \"Specifies the allowed plugin options. An empty strings allows all Plugin Options.\" }\n \n@@ -2790,7 +2790,7 @@ static void StoreAcl(LEX* lc, ResourceItem* item, int index, int pass)\n     LexGetToken(lc, BCT_STRING);\n     if (pass == 1) {\n       if (!IsAclEntryValid(lc->str, msg)) {\n-        Emsg1(M_ERROR, 0, T_(\"Cannot store Acl: %s\\n\"), msg.data());\n+        scan_err1(lc, T_(\"Cannot store Acl: %s\"), msg.data());\n         return;\n       }\n       list->append(strdup(lc->str));"
        },
        {
          "filename": "core/src/dird/ua_acl.cc",
          "status": "modified",
          "additions": 92,
          "deletions": 131,
          "patch": "@@ -3,7 +3,7 @@\n \n    Copyright (C) 2004-2008 Free Software Foundation Europe e.V.\n    Copyright (C) 2014-2016 Planets Communications B.V.\n-   Copyright (C) 2014-2022 Bareos GmbH & Co. KG\n+   Copyright (C) 2014-2024 Bareos GmbH & Co. KG\n \n    This program is Free Software; you can redistribute it and/or\n    modify it under the terms of version three of the GNU Affero General Public\n@@ -47,141 +47,104 @@ bool UaContext::AclAccessOk(int acl, const char* item, bool audit_event)\n  * A regexp uses the following chars:\n  * ., (, ), [, ], |, ^, $, +, ?, *\n  */\n-static bool is_regex(std::string string_to_check)\n+constexpr bool is_regex(std::string_view string_to_check)\n {\n-  return std::string::npos != string_to_check.find_first_of(\".()[]|^$+?*\");\n+  return string_to_check.npos != string_to_check.find_first_of(\".()[]|^$+?*\");\n }\n \n /**\n- * Loop over the items in the alist and verify if they match the given item\n- * that access was requested for.\n+ * acl_list_value: value of the ACL definition.\n+ * acl_list_compare_value: value ot compare against. This is identical to\n+ * acl_list_value or a modified acl_list_value to compare against.\n  */\n-static inline bool FindInAclList(alist<const char*>* list,\n-                                 int acl,\n-                                 const char* item,\n-                                 int len)\n+static inline bool CompareAclListValueWithItem(\n+    int acl,\n+    const char* acl_list_value,\n+    const char* acl_list_compare_value,\n+    const char* item,\n+    int item_length)\n {\n-  int rc;\n-  regex_t preg{};\n-  int nmatch = 1;\n-  bool retval = false;\n-  regmatch_t pmatch[1]{};\n-  const char* list_value;\n+  // gives full access\n+  if (Bstrcasecmp(\"*all*\", acl_list_compare_value)) {\n+    Dmsg2(1400, \"Global ACL found in %d %s\\n\", acl, acl_list_value);\n+    return true;\n+  }\n \n-  // See if we have an empty list.\n-  if (!list) {\n-    /*\n-     * Empty list for Where => empty where accept anything.\n-     * For any other list, reject everything.\n-     */\n-    if (len == 0 && acl == Where_ACL) {\n-      Dmsg0(1400, \"Empty Where_ACL allowing restore anywhere\\n\");\n-      retval = true;\n-    }\n-    goto bail_out;\n+  if (Bstrcasecmp(item, acl_list_compare_value)) {\n+    // Explicit match.\n+    Dmsg3(1400, \"ACL found %s in %d %s\\n\", item, acl, acl_list_value);\n+    return true;\n   }\n \n-  // Search list for item\n-  for (int i = 0; i < list->size(); i++) {\n-    list_value = (char*)list->get(i);\n+  /* If we didn't get an exact match see if we can use the pattern as a\n+   * regex. */\n+  if (is_regex(acl_list_compare_value)) {\n+    regex_t preg{};\n+    int rc = regcomp(&preg, acl_list_compare_value, REG_EXTENDED | REG_ICASE);\n+    if (rc != 0) {\n+      // Not a valid regular expression so skip it.\n+      Dmsg1(1400, \"Not a valid regex %s, ignoring for regex compare\\n\",\n+            acl_list_value);\n+      return false;\n+    }\n \n-    // See if this is a deny acl.\n-    if (*list_value == '!') {\n-      if (Bstrcasecmp(item, list_value + 1)) {\n-        // Explicit deny.\n-        Dmsg3(1400, \"Deny ACL found %s in %d %s\\n\", item, acl, list_value);\n-        goto bail_out;\n+    int nmatch = 1;\n+    regmatch_t pmatch[1]{};\n+    if (regexec(&preg, item, nmatch, pmatch, 0) == 0) {\n+      // Make sure its not a partial match but a full match.\n+      Dmsg2(1400, \"Found match start offset %d end offset %d\\n\",\n+            pmatch[0].rm_so, pmatch[0].rm_eo);\n+      if ((pmatch[0].rm_eo - pmatch[0].rm_so) >= item_length) {\n+        Dmsg3(1400, \"ACL found %s in %d using regex %s\\n\", item, acl,\n+              acl_list_value);\n+        regfree(&preg);\n+        return true;\n       }\n+    }\n+    regfree(&preg);\n+  }\n+  return false;\n+}\n \n-      /*\n-       * If we didn't get an exact match see if we can use the pattern as a\n-       * regex.\n-       */\n-      if (is_regex(list_value + 1)) {\n-        int match_length;\n-\n-        match_length = strlen(item);\n-        rc = regcomp(&preg, list_value + 1, REG_EXTENDED | REG_ICASE);\n-        if (rc != 0) {\n-          // Not a valid regular expression so skip it.\n-          Dmsg1(1400, \"Not a valid regex %s, ignoring for regex compare\\n\",\n-                list_value);\n-          continue;\n-        }\n-\n-        if (regexec(&preg, item, nmatch, pmatch, 0) == 0) {\n-          // Make sure its not a partial match but a full match.\n-          Dmsg2(1400, \"Found match start offset %d end offset %d\\n\",\n-                pmatch[0].rm_so, pmatch[0].rm_eo);\n-          if ((pmatch[0].rm_eo - pmatch[0].rm_so) >= match_length) {\n-            Dmsg3(1400, \"ACL found %s in %d using regex %s\\n\", item, acl,\n-                  list_value);\n-            regfree(&preg);\n-            goto bail_out;\n-          }\n-        }\n+/**\n+ * Loop over the items in the alist and verify if they match the given item\n+ * that access was requested for.\n+ */\n+static inline std::optional<bool> FindInAclList(alist<const char*>* list,\n+                                                int acl,\n+                                                const char* item,\n+                                                int item_length)\n+{\n+  // See if we have an empty list.\n+  if (!list || list->empty()) { return std::nullopt; }\n \n-        regfree(&preg);\n+  // Search list for item\n+  const char* list_value = nullptr;\n+  foreach_alist (list_value, list) {\n+    // See if this is a deny acl.\n+    if (*list_value == '!') {\n+      if (CompareAclListValueWithItem(acl, list_value, list_value + 1, item,\n+                                      item_length)) {\n+        return false;\n       }\n     } else {\n-      // gives full access\n-      if (Bstrcasecmp(\"*all*\", list_value)) {\n-        Dmsg2(1400, \"Global ACL found in %d %s\\n\", acl, list_value);\n-        retval = true;\n-        goto bail_out;\n-      }\n-\n-      if (Bstrcasecmp(item, list_value)) {\n-        Dmsg3(1400, \"ACL found %s in %d %s\\n\", item, acl, list_value);\n-        retval = true;\n-        goto bail_out;\n-      }\n-\n-      /*\n-       * If we didn't get an exact match see if we can use the pattern as a\n-       * regex.\n-       */\n-      if (is_regex(list_value)) {\n-        int match_length;\n-\n-        match_length = strlen(item);\n-        rc = regcomp(&preg, list_value, REG_EXTENDED | REG_ICASE);\n-        if (rc != 0) {\n-          // Not a valid regular expression so skip it.\n-          Dmsg1(1400, \"Not a valid regex %s, ignoring for regex compare\\n\",\n-                list_value);\n-          continue;\n-        }\n-\n-        if (regexec(&preg, item, nmatch, pmatch, 0) == 0) {\n-          // Make sure its not a partial match but a full match.\n-          Dmsg2(1400, \"Found match start offset %d end offset %d\\n\",\n-                pmatch[0].rm_so, pmatch[0].rm_eo);\n-          if ((pmatch[0].rm_eo - pmatch[0].rm_so) >= match_length) {\n-            Dmsg3(1400, \"ACL found %s in %d using regex %s\\n\", item, acl,\n-                  list_value);\n-            retval = true;\n-            regfree(&preg);\n-            goto bail_out;\n-          }\n-        }\n-\n-        regfree(&preg);\n+      if (CompareAclListValueWithItem(acl, list_value, list_value, item,\n+                                      item_length)) {\n+        return true;\n       }\n     }\n   }\n \n-bail_out:\n-  return retval;\n+  return std::nullopt;\n }\n \n // This version expects the length of the item which we must check.\n bool UaContext::AclAccessOk(int acl,\n                             const char* item,\n-                            int len,\n+                            int item_length,\n                             bool audit_event)\n {\n-  bool retval = false;\n+  std::optional<bool> retval;\n \n   // The resource name contains nasty characters\n   switch (acl) {\n@@ -203,27 +166,29 @@ bool UaContext::AclAccessOk(int acl,\n     goto bail_out;\n   }\n \n-  retval = FindInAclList(user_acl->ACL_lists[acl], acl, item, len);\n+  retval = FindInAclList(user_acl->ACL_lists[acl], acl, item, item_length);\n \n-  /*\n-   * If we didn't find a matching ACL try to use the profiles this console is\n-   * connected to.\n-   */\n-  if (!retval && user_acl->profiles && user_acl->profiles->size()) {\n-    ProfileResource* profile = nullptr;\n+  /* If we didn't find a matching ACL try to use the profiles this console is\n+   * connected to. */\n+  if (!retval.has_value()) {\n+    if (user_acl->profiles && user_acl->profiles->size()) {\n+      ProfileResource* profile = nullptr;\n \n-    foreach_alist (profile, user_acl->profiles) {\n-      retval = FindInAclList(profile->ACL_lists[acl], acl, item, len);\n+      foreach_alist (profile, user_acl->profiles) {\n+        retval = FindInAclList(profile->ACL_lists[acl], acl, item, item_length);\n \n-      // If we found a match break the loop.\n-      if (retval) { break; }\n+        // If we found a match break the loop.\n+        if (retval.has_value()) { break; }\n+      }\n     }\n   }\n \n bail_out:\n-  if (audit_event && !retval) { LogAuditEventAclFailure(acl, item); }\n+  if (audit_event && !retval.value_or(false)) {\n+    LogAuditEventAclFailure(acl, item);\n+  }\n \n-  return retval;\n+  return retval.value_or(false);\n }\n \n /**\n@@ -306,11 +271,9 @@ bool UaContext::IsResAllowed(BareosResource* res)\n \n   acl = RcodeToAcltype(res->rcode_);\n   if (acl == -1) {\n-    /*\n-     * For all resources for which we don't know an explicit mapping\n+    /* For all resources for which we don't know an explicit mapping\n      * to the right ACL we check if the Command ACL has access to the\n-     * configure command just as we do for suppressing sensitive data.\n-     */\n+     * configure command just as we do for suppressing sensitive data. */\n     return AclAccessOk(Command_ACL, \"configure\", false);\n   }\n \n@@ -330,11 +293,9 @@ BareosResource* UaContext::GetResWithName(int rcode,\n \n   acl = RcodeToAcltype(rcode);\n   if (acl == -1) {\n-    /*\n-     * For all resources for which we don't know an explicit mapping\n+    /* For all resources for which we don't know an explicit mapping\n      * to the right ACL we check if the Command ACL has access to the\n-     * configure command just as we do for suppressing sensitive data.\n-     */\n+     * configure command just as we do for suppressing sensitive data. */\n     if (!AclAccessOk(Command_ACL, \"configure\", false)) { goto bail_out; }\n   } else {\n     if (!AclAccessOk(acl, name, audit_event)) { goto bail_out; }"
        },
        {
          "filename": "core/src/dird/ua_cmds.cc",
          "status": "modified",
          "additions": 120,
          "deletions": 128,
          "patch": "@@ -177,9 +177,9 @@ static struct ua_cmdstruct commands[] = {\n     {NT_(\".api\"), DotApiCmd, T_(\"Switch between different api modes\"),\n      NT_(\"[ 0 | 1 | 2 | off | on | json ] [compact=<yes|no>]\"), false, false},\n     {NT_(\".authorized\"), DotAuthorizedCmd, T_(\"Check for authorization\"),\n-     NT_(\"job=<job-name> | client=<client-name> | storage=<storage-name | \\n\"\n-         \"schedule=<schedule-name> | pool=<pool-name> | cmd=<command> | \\n\"\n-         \"fileset=<fileset-name> | catalog=<catalog>\"),\n+     NT_(\"job=<job-name> | client=<client-name> | storage=<storage-name> \"\n+         \"| schedule=<schedule-name> | pool=<pool-name> | cmd=<command> \"\n+         \"| fileset=<fileset-name> | catalog=<catalog>\"),\n      false, false},\n     {NT_(\".catalogs\"), DotCatalogsCmd, T_(\"List all catalog resources\"), NULL,\n      false, false},\n@@ -224,9 +224,9 @@ static struct ua_cmdstruct commands[] = {\n      NT_(\"[enabled | disabled]\"), false, false},\n     {NT_(\".status\"), DotStatusCmd, T_(\"Report status\"),\n      NT_(\"dir ( current | last | header | scheduled | running | terminated ) \"\n-         \"|\\n\"\n+         \"| \"\n          \"storage=<storage> [ header | waitreservation | devices | volumes | \"\n-         \"spooling | running | terminated ] |\\n\"\n+         \"spooling | running | terminated ] | \"\n          \"client=<client> [ header | terminated | running ]\"),\n      false, true},\n     {NT_(\".storages\"), DotStorageCmd, T_(\"List all storage resources\"),\n@@ -303,13 +303,12 @@ static struct ua_cmdstruct commands[] = {\n         \"mode\"),\n      NT_(\"on | off\"), false, false},\n     {NT_(\"help\"), help_cmd, T_(\"Print help on specific command\"),\n-     NT_(\"add autodisplay automount cancel configure create delete disable\\n\"\n-         \"\\tenable estimate exit gui label list llist\\n\"\n-         \"\\tmessages memory mount prune purge quit query\\n\"\n-         \"\\trestore relabel release reload run status\\n\"\n-         \"\\tsetbandwidth setdebug setip show sqlquery time trace truncate \"\n-         \"unmount\\n\"\n-         \"\\tumount update use var version wait\"),\n+     NT_(\"add autodisplay automount cancel configure create delete disable \"\n+         \"enable estimate exit gui label list llist \"\n+         \"messages memory mount prune purge quit query \"\n+         \"restore relabel release reload run status \"\n+         \"setbandwidth setdebug setip show sqlquery time trace truncate \"\n+         \"unmount umount update use var version wait\"),\n      false, false},\n     {NT_(\"import\"), ImportCmd,\n      T_(\"Import volumes from import/export slots to normal slots\"),\n@@ -321,127 +320,126 @@ static struct ua_cmdstruct commands[] = {\n          \"slot=<slot> [ drive = <drivenum>] [ barcodes ] [ encrypt ] [ yes ]\"),\n      false, true},\n     {NT_(\"list\"), list_cmd, T_(\"List objects from catalog\"),\n-     NT_(\"basefiles jobid=<jobid> | basefiles ujobid=<complete_name> |\\n\"\n+     NT_(\"basefiles jobid=<jobid> | basefiles ujobid=<complete_name> | \"\n          \"backups client=<client-name> [fileset=<fileset-name>] \"\n          \"[jobstatus=<status>] [level=<level>] [order=<asc|desc>] \"\n-         \"[limit=<number>] |\\n\"\n-         \"clients | copies jobid=<jobid> |\\n\"\n-         \"files jobid=<jobid> | files ujobid=<complete_name> |\\n\"\n-         \"filesets |\\n\"\n-         \"fileset [ jobid=<jobid> ] | fileset [ ujobid=<complete_name> ] |\\n\"\n-         \"fileset [ filesetid=<filesetid> ] | fileset [ jobid=<jobid> ] |\\n\"\n+         \"[limit=<number>] | \"\n+         \"clients | copies jobid=<jobid> | \"\n+         \"files jobid=<jobid> | files ujobid=<complete_name> | \"\n+         \"filesets | \"\n+         \"fileset [ jobid=<jobid> ] | fileset [ ujobid=<complete_name> ] | \"\n+         \"fileset [ filesetid=<filesetid> ] | fileset [ jobid=<jobid> ] | \"\n          \"jobs [job=<job-name>] [client=<client-name>] [jobstatus=<status>] \"\n          \"[jobtype=<jobtype>] [joblevel=<joblevel>] [volume=<volumename>] \"\n          \"[pool=<pool>] \"\n-         \"[days=<number>] [hours=<number>] [last] [count] |\\n\"\n+         \"[days=<number>] [hours=<number>] [last] [count] | \"\n          \"job=<job-name> [client=<client-name>] [jobstatus=<status>] \"\n          \"[jobtype=<jobtype>] [volume=<volumename>] [days=<number>] \"\n-         \"[hours=<number>] |\\n\"\n-         \"jobid=<jobid> | ujobid=<complete_name> |\\n\"\n-         \"joblog jobid=<jobid> | joblog ujobid=<complete_name> |\\n\"\n-         \"jobmedia jobid=<jobid> | jobmedia ujobid=<complete_name> |\\n\"\n-         \"jobtotals |\\n\"\n-         \"jobstatistics jobid=<jobid> |\\n\"\n-         \"log [ limit=<number> [ offset=<number> ] ] [reverse]|\\n\"\n+         \"[hours=<number>] | \"\n+         \"jobid=<jobid> | ujobid=<complete_name> | \"\n+         \"joblog jobid=<jobid> | joblog ujobid=<complete_name> | \"\n+         \"jobmedia jobid=<jobid> | jobmedia ujobid=<complete_name> | \"\n+         \"jobtotals | \"\n+         \"jobstatistics jobid=<jobid> | \"\n+         \"log [ limit=<number> [ offset=<number> ] ] [reverse]| \"\n          \"media [ jobid=<jobid> | ujobid=<complete_name> | pool=<pool-name> | \"\n-         \"all ] |\\n\"\n-         \"media=<media-name> |\\n\"\n-         \"nextvol job=<job-name> | nextvolume ujobid=<complete_name> |\\n\"\n-         \"pools |\\n\"\n-         \"pool=<pool-name> |\\n\"\n-         \"poolid=<poolid> |\\n\"\n-         \"storages |\\n\"\n+         \"all ] | \"\n+         \"media=<media-name> | \"\n+         \"nextvol job=<job-name> | nextvolume ujobid=<complete_name> | \"\n+         \"pools | \"\n+         \"pool=<pool-name> | \"\n+         \"poolid=<poolid> | \"\n+         \"storages | \"\n          \"volumes [ jobid=<jobid> | ujobid=<complete_name> | pool=<pool-name> \"\n-         \"| all ] [count] |\\n\"\n-         \"volume=<volume-name> |\\n\"\n-         \"volumeid=<volumeid> | mediaid=<volumeid> |\\n\"\n-         \"[current] | [enabled | disabled] |\\n\"\n+         \"| all ] [count] | \"\n+         \"volume=<volume-name> | \"\n+         \"volumeid=<volumeid> | mediaid=<volumeid> | \"\n+         \"[current] | [enabled | disabled] | \"\n          \"[limit=<number> [offset=<number>]]\"),\n      true, true},\n     {NT_(\"llist\"), LlistCmd, T_(\"Full or long list like list command\"),\n-     NT_(\"basefiles jobid=<jobid> | basefiles ujobid=<complete_name> |\\n\"\n+     NT_(\"basefiles jobid=<jobid> | basefiles ujobid=<complete_name> | \"\n          \"backups client=<client-name> [fileset=<fileset-name>] \"\n          \"[jobstatus=<status>] [level=<level>] [order=<asc|desc>] \"\n-         \"[limit=<number>] [days=<number>] [hours=<number>]|\\n\"\n-         \"clients | copies jobid=<jobid> |\\n\"\n-         \"files jobid=<jobid> | files ujobid=<complete_name> |\\n\"\n-         \"filesets |\\n\"\n-         \"fileset jobid=<jobid> | fileset ujobid=<complete_name> |\\n\"\n-         \"fileset [ filesetid=<filesetid> ] | fileset [ jobid=<jobid> ] |\\n\"\n+         \"[limit=<number>] [days=<number>] [hours=<number>] | \"\n+         \"clients | copies jobid=<jobid> | \"\n+         \"files jobid=<jobid> | files ujobid=<complete_name> | \"\n+         \"filesets | \"\n+         \"fileset jobid=<jobid> | fileset ujobid=<complete_name> | \"\n+         \"fileset [ filesetid=<filesetid> ] | fileset [ jobid=<jobid> ] | \"\n          \"jobs [job=<job-name>] [client=<client-name>] [jobstatus=<status>] \"\n          \"[jobtype=<jobtype>] [volume=<volumename>] [pool=<pool>] \"\n          \"[days=<number>] \"\n-         \"[hours=<number>] [last] [count] |\\n\"\n+         \"[hours=<number>] [last] [count] | \"\n          \"job=<job-name> [client=<client-name>] [jobstatus=<status>] \"\n          \"[jobtype=<jobtype>] [joblevel=<joblevel>] [volume=<volumename>] \"\n-         \"[days=<number>] [hours=<number>] |\\n\"\n-         \"jobid=<jobid> | ujobid=<complete_name> |\\n\"\n+         \"[days=<number>] [hours=<number>] | \"\n+         \"jobid=<jobid> | ujobid=<complete_name> | \"\n          \"joblog jobid=<jobid> [count] | joblog ujobid=<complete_name> [count] \"\n-         \"|\\n\"\n-         \"jobmedia jobid=<jobid> | jobmedia ujobid=<complete_name> |\\n\"\n-         \"jobtotals |\\n\"\n-         \"media [ jobid=<jobid> | ujobid=<complete_name> | pool=<pool-name> | \"\n-         \"all ] |\\n\"\n-         \"media=<media-name> |\\n\"\n-         \"nextvol job=<job-name> | nextvolume ujobid=<complete_name> |\\n\"\n-         \"pools |\\n\"\n-         \"pool=<pool-name> |\\n\"\n-         \"poolid=<poolid> |\\n\"\n+         \"| jobmedia jobid=<jobid> | jobmedia ujobid=<complete_name> \"\n+         \"| jobtotals \"\n+         \"| media [ jobid=<jobid> | ujobid=<complete_name> | pool=<pool-name> \"\n+         \"| all ] \"\n+         \"| media=<media-name> | \"\n+         \"nextvol job=<job-name> | nextvolume ujobid=<complete_name> | \"\n+         \"pools | \"\n+         \"pool=<pool-name> | \"\n+         \"poolid=<poolid> | \"\n          \"volumes [ jobid=<jobid> | ujobid=<complete_name> | pool=<pool-name> \"\n-         \"| all ] [count] |\\n\"\n-         \"volume=<volume-name> |\\n\"\n-         \"volumeid=<volumeid> | mediaid=<volumeid> |\\n\"\n-         \"[current] | [enabled | disabled] |\\n\"\n+         \"| all ] [count] | \"\n+         \"volume=<volume-name> | \"\n+         \"volumeid=<volumeid> | mediaid=<volumeid> | \"\n+         \"[current] | [enabled | disabled] | \"\n          \"[limit=<num> [offset=<number>]]\"),\n      true, true},\n     {NT_(\"messages\"), MessagesCmd, T_(\"Display pending messages\"), NT_(\"\"),\n      false, false},\n     {NT_(\"memory\"), MemoryCmd, T_(\"Print current memory usage\"), NT_(\"\"), true,\n      false},\n     {NT_(\"mount\"), MountCmd, T_(\"Mount storage\"),\n-     NT_(\"storage=<storage-name> slot=<num> drive=<drivenum>\\n\"\n-         \"\\tjobid=<jobid> | job=<job-name> | ujobid=<complete_name>\"),\n+     NT_(\"storage=<storage-name> slot=<num> drive=<drivenum> \"\n+         \"jobid=<jobid> | job=<job-name> | ujobid=<complete_name>\"),\n      false, true},\n     {NT_(\"move\"), move_cmd, T_(\"Move slots in an autochanger\"),\n      NT_(\"storage=<storage-name> srcslots=<slot-selection> \"\n          \"dstslots=<slot-selection>\"),\n      true, true},\n     {NT_(\"prune\"), PruneCmd, T_(\"Prune records from catalog\"),\n-     NT_(\"files [client=<client>] [pool=<pool>] [yes] |\\n\"\n-         \"jobs [client=<client>] [pool=<pool>] [yes] |\\n\"\n-         \"volume [all] [=volume] [pool=<pool>] [yes] |\\n\"\n-         \"stats [yes] |\\n\"\n-         \"directory [=directory] [client=<client>] [recursive] [yes] |\\n\"),\n+     NT_(\"files [client=<client>] [pool=<pool>] [yes] | \"\n+         \"jobs [client=<client>] [pool=<pool>] [yes] | \"\n+         \"volume [all] [=volume] [pool=<pool>] [yes] | \"\n+         \"stats [yes] | \"\n+         \"directory [=directory] [client=<client>] [recursive] [yes]\"),\n      true, true},\n     {NT_(\"purge\"), PurgeCmd, T_(\"Purge records from catalog\"),\n      NT_(\"[files [job=<job> | jobid=<jobid> | client=<client> | \"\n-         \"volume=<volume>]] |\\n\"\n+         \"volume=<volume>]] | \"\n          \"[jobs [client=<client> | volume=<volume>] | pool=<pool>] \"\n-         \"[jobstatus=<status>]] |\\n\"\n+         \"[jobstatus=<status>]] | \"\n          \"[volume[=<volume>] [storage=<storage>] [pool=<pool> | allpools] \"\n-         \"[devicetype=<type>] [drive=<drivenum>] [action=<action>]] |\\n\"\n+         \"[devicetype=<type>] [drive=<drivenum>] [action=<action>]] | \"\n          \"[quota [client=<client>]]\"),\n      true, true},\n     {NT_(\"quit\"), quit_cmd, T_(\"Terminate Bconsole session\"), NT_(\"\"), false,\n      false},\n     {NT_(\"query\"), QueryCmd, T_(\"Query catalog\"), NT_(\"\"), false, true},\n     {NT_(\"restore\"), RestoreCmd, T_(\"Restore files\"),\n      NT_(\"where=</path> client=<client-name> storage=<storage-name> \"\n-         \"bootstrap=<file>\\n\"\n-         \"\\trestorejob=<job-name> comment=<text> jobid=<jobid> \"\n-         \"fileset=<fileset-name>\\n\"\n-         \"\\treplace=<always|never|ifolder|ifnewer> \"\n-         \"pluginoptions=<plugin-options-string>\\n\"\n-         \"\\tregexwhere=<regex> fileregex=<regex> \"\n-         \"restoreclient=<client-name> backupformat=<format>\\n\"\n-         \"\\tpool=<pool-name> file=<filename> directory=<directory> \"\n-         \"before=<date>\\n\"\n-         \"\\tstrip_prefix=<prefix> add_prefix=<prefix> add_suffix=<suffix>\\n\"\n-         \"\\tselect=<date> select before current copies done all\"),\n+         \"bootstrap=<file> \"\n+         \"restorejob=<job-name> comment=<text> jobid=<jobid> \"\n+         \"fileset=<fileset-name> \"\n+         \"replace=<always|never|ifolder|ifnewer> \"\n+         \"pluginoptions=<plugin-options-string> \"\n+         \"regexwhere=<regex> fileregex=<regex> \"\n+         \"restoreclient=<client-name> backupformat=<format> \"\n+         \"pool=<pool-name> file=<filename> directory=<directory> \"\n+         \"before=<date> \"\n+         \"strip_prefix=<prefix> add_prefix=<prefix> add_suffix=<suffix> \"\n+         \"select=<date> select before current copies done all\"),\n      false, true},\n     {NT_(\"relabel\"), RelabelCmd, T_(\"Relabel a tape\"),\n-     NT_(\"storage=<storage-name> oldvolume=<old-volume-name>\\n\"\n-         \"\\tvolume=<new-volume-name> pool=<pool-name> [ encrypt ]\"),\n+     NT_(\"storage=<storage-name> oldvolume=<old-volume-name> \"\n+         \" volume=<new-volume-name> pool=<pool-name> [ encrypt ]\"),\n      false, true},\n     {NT_(\"release\"), ReleaseCmd, T_(\"Release storage\"),\n      NT_(\"storage=<storage-name> [ drive=<drivenum> ] [ alldrives ]\"), true,\n@@ -456,29 +454,29 @@ static struct ua_cmdstruct commands[] = {\n      true},\n     {NT_(\"run\"), RunCmd, T_(\"Run a job\"),\n      NT_(\"job=<job-name> client=<client-name> fileset=<fileset-name> \"\n-         \"level=<level>\\n\"\n-         \"\\tstorage=<storage-name> where=<directory-prefix> \"\n-         \"when=<universal-time-specification>\\n\"\n-         \"\\tpool=<pool-name> pluginoptions=<plugin-options-string> \"\n-         \"accurate=<yes|no> comment=<text>\\n\"\n-         \"\\tspooldata=<yes|no> priority=<number> jobid=<jobid> \"\n-         \"catalog=<catalog> migrationjob=<job-name>\\n\"\n-         \"\\tbackupclient=<client-name> backupformat=<format> \"\n-         \"nextpool=<pool-name>\\n\"\n-         \"\\tsince=<universal-time-specification> verifyjob=<job-name> \"\n-         \"verifylist=<verify-list>\\n\"\n-         \"\\tmigrationjob=<complete_name> yes\"),\n+         \"level=<level> \"\n+         \"storage=<storage-name> where=<directory-prefix> \"\n+         \"when=<universal-time-specification> \"\n+         \"pool=<pool-name> pluginoptions=<plugin-options-string> \"\n+         \"accurate=<yes|no> comment=<text> \"\n+         \"spooldata=<yes|no> priority=<number> jobid=<jobid> \"\n+         \"catalog=<catalog> migrationjob=<job-name> \"\n+         \"backupclient=<client-name> backupformat=<format> \"\n+         \"nextpool=<pool-name> \"\n+         \"since=<universal-time-specification> verifyjob=<job-name> \"\n+         \"verifylist=<verify-list> \"\n+         \"migrationjob=<complete_name> [ yes ]\"),\n      false, true},\n     {NT_(\"status\"), StatusCmd, T_(\"Report status\"),\n      NT_(\"all | dir=<dir-name> | director | scheduler | \"\n-         \"schedule=<schedule-name> | client=<client-name> |\\n\"\n-         \"storage=<storage-name> slots | days=<nr_days> | job=<job-name> |\\n\"\n+         \"schedule=<schedule-name> | client=<client-name> | \"\n+         \"storage=<storage-name> slots | days=<nr_days> | job=<job-name> | \"\n          \"subscriptions [detail] [unknown] [all] | configuration\"),\n      true, true},\n     {NT_(\"setbandwidth\"), SetbwlimitCmd, T_(\"Sets bandwidth\"),\n-     NT_(\"client=<client-name> | storage=<storage-name> | jobid=<jobid> |\\n\"\n-         \"\\tjob=<job-name> | ujobid=<unique-jobid> state=<job_state> | all\\n\"\n-         \"\\tlimit=<nn-kbs> [ yes ]\"),\n+     NT_(\"[ client=<client-name> | storage=<storage-name> | jobid=<jobid> \"\n+         \"| job=<job-name> | ujobid=<unique-jobid> state=<job_state> | all ] \"\n+         \"limit=<nn-kbs> [ yes ]\"),\n      true, true},\n     {NT_(\"setdebug\"), SetdebugCmd, T_(\"Sets debug level\"),\n      NT_(\"level=<nn> trace=0/1 timestamp=0/1 client=<client-name> | dir | \"\n@@ -497,14 +495,11 @@ static struct ua_cmdstruct commands[] = {\n          \"message=<message-resource-name> | \"\n          \"pool=<pool-name> | profile=<profile-name> | \"\n          \"schedule=<schedule-name> | storage=<storage-name> \"\n-         \"|\\n\"\n-         \"catalog | clients | consoles | directors | filesets | jobdefs | jobs \"\n-         \"| \"\n-         \"messages | pools | profiles | schedules | storages \"\n-         \"|\\n\"\n-         \"disabled [ clients | jobs | schedules ] \"\n-         \"|\\n\"\n-         \"all [verbose]\"),\n+         \"| catalog | clients | consoles | directors | filesets \"\n+         \"| jobdefs | jobs \"\n+         \"| messages | pools | profiles | schedules | storages \"\n+         \"| disabled [ clients | jobs | schedules ] \"\n+         \"| all [verbose]\"),\n      true, true},\n     {NT_(\"sqlquery\"), SqlqueryCmd, T_(\"Use SQL to query catalog\"), NT_(\"\"),\n      false, true},\n@@ -517,13 +512,13 @@ static struct ua_cmdstruct commands[] = {\n          \"[yes]\"),\n      true, true},\n     {NT_(\"unmount\"), UnmountCmd, T_(\"Unmount storage\"),\n-     NT_(\"storage=<storage-name> [ drive=<drivenum> ]\\n\"\n-         \"\\tjobid=<jobid> | job=<job-name> | ujobid=<complete_name>\"),\n+     NT_(\"storage=<storage-name> [ drive=<drivenum> ] \"\n+         \"jobid=<jobid> | job=<job-name> | ujobid=<complete_name>\"),\n      false, true},\n     {NT_(\"umount\"), UnmountCmd,\n      T_(\"Umount - for old-time Unix guys, see unmount\"),\n-     NT_(\"storage=<storage-name> [ drive=<drivenum> ]\\n\"\n-         \"\\tjobid=<jobid> | job=<job-name> | ujobid=<complete_name>\"),\n+     NT_(\"storage=<storage-name> [ drive=<drivenum> ] \"\n+         \"jobid=<jobid> | job=<job-name> | ujobid=<complete_name>\"),\n      false, true},\n     {NT_(\"update\"), UpdateCmd,\n      T_(\"Update volume, pool, slots, job or statistics\"),\n@@ -532,19 +527,15 @@ static struct ua_cmdstruct commands[] = {\n          \"actiononpurge=<action>] \"\n          \"[pool=<pool-name>] [recycle=<yes/no>] [slot=<number>] \"\n          \"[inchanger=<yes/no>]] \"\n-         \"|\\n\"\n-         \"[pool=<pool-name> \"\n+         \"| [pool=<pool-name> \"\n          \"[maxvolbytes=<size>] [maxvolfiles=<nb>] [maxvoljobs=<nb>]\"\n          \"[enabled=<yes/no>] [recyclepool=<pool-name>] \"\n-         \"[actiononpurge=<action>] |\\n\"\n+         \"[actiononpurge=<action>] | \"\n          \"slots [storage=<storage-name>] [scan]] \"\n-         \"|\\n\"\n-         \"[jobid=<jobid> [jobname=<name>] [starttime=<time-def>] \"\n-         \"[client=<client-name>]\\n\"\n+         \"| [jobid=<jobid> [jobname=<name>] [starttime=<time-def>] \"\n+         \"[client=<client-name>] \"\n          \"[filesetid=<fileset-id>] [jobtype=<job-type>]] \"\n-         \"|\\n\"\n-         \"[stats \"\n-         \"[days=<number>]]\"),\n+         \"| [stats [days=<number>]]\"),\n      true, true},\n     {NT_(\"use\"), use_cmd, T_(\"Use specific catalog\"), NT_(\"catalog=<catalog>\"),\n      false, true},\n@@ -587,16 +578,17 @@ bool Do_a_command(UaContext* ua)\n   len = strlen(ua->argk[0]);\n   for (i = 0; i < comsize; i++) { /* search for command */\n     if (bstrncasecmp(ua->argk[0], commands[i].key, len)) {\n-      // Check if command permitted, but \"quit\" and \"whoami\" is always OK\n-      if (!bstrcmp(ua->argk[0], NT_(\"quit\"))\n-          && !bstrcmp(ua->argk[0], NT_(\"whoami\"))\n-          && !ua->AclAccessOk(Command_ACL, ua->argk[0], true)) {\n+      const char* command = commands[i].key;\n+      // Check if command permitted, but \"exit/quit\" and \"whoami\" is always OK\n+      if (!bstrcmp(command, NT_(\"exit\")) && !bstrcmp(command, NT_(\"quit\"))\n+          && !bstrcmp(command, NT_(\"whoami\"))\n+          && !ua->AclAccessOk(Command_ACL, command, true)) {\n         break;\n       }\n \n       // Check if this command is authorized in RunScript\n       if (ua->runscript && !commands[i].allowed_in_runscript) {\n-        ua->ErrorMsg(T_(\"Can't use %s command in a runscript\"), ua->argk[0]);\n+        ua->ErrorMsg(T_(\"Can't use %s command in a runscript\"), command);\n         break;\n       }\n "
        },
        {
          "filename": "core/src/dird/ua_run.cc",
          "status": "modified",
          "additions": 60,
          "deletions": 41,
          "patch": "@@ -2,7 +2,7 @@\n \n    Copyright (C) 2001-2012 Free Software Foundation Europe e.V.\n    Copyright (C) 2011-2016 Planets Communications B.V.\n-   Copyright (C) 2013-2023 Bareos GmbH & Co. KG\n+   Copyright (C) 2013-2024 Bareos GmbH & Co. KG\n \n    This program is Free Software; you can redistribute it and/or\n    modify it under the terms of version three of the GNU Affero General Public\n@@ -49,6 +49,7 @@ static bool DisplayJobParameters(UaContext* ua,\n                                  JobControlRecord* jcr,\n                                  RunContext& rc);\n static void SelectWhereRegexp(UaContext* ua, JobControlRecord* jcr);\n+static bool GetPluginOptions(UaContext* ua, JobControlRecord* jcr);\n static bool ScanCommandLineArguments(UaContext* ua, RunContext& rc);\n static bool ResetRestoreContext(UaContext* ua,\n                                 JobControlRecord* jcr,\n@@ -723,29 +724,29 @@ int ModifyJobParameters(UaContext* ua, JobControlRecord* jcr, RunContext& rc)\n         } else if (jcr->is_JobType(JT_RESTORE)) { /* Where */\n           if (GetCmd(ua, T_(\"Please enter the full path prefix for restore (/ \"\n                             \"for none): \"))) {\n-            if (jcr->RegexWhere) { /* cannot use regexwhere and where */\n-              free(jcr->RegexWhere);\n-              jcr->RegexWhere = NULL;\n-            }\n-            if (jcr->where) {\n-              free(jcr->where);\n-              jcr->where = NULL;\n-            }\n-            if (IsPathSeparator(ua->cmd[0]) && ua->cmd[1] == '\\0') {\n-              ua->cmd[0] = 0;\n+            if (!ua->AclAccessOk(Where_ACL, ua->cmd, true)) {\n+              ua->SendMsg(\n+                  T_(\"No authorization for \\\"where\\\" specification.\\n\"));\n+            } else {\n+              if (jcr->RegexWhere) { /* cannot use regexwhere and where */\n+                free(jcr->RegexWhere);\n+                jcr->RegexWhere = NULL;\n+              }\n+              if (jcr->where) {\n+                free(jcr->where);\n+                jcr->where = NULL;\n+              }\n+              // \"/\" is treated as no prefix.\n+              if (IsPathSeparator(ua->cmd[0]) && ua->cmd[1] == '\\0') {\n+                ua->cmd[0] = 0;\n+              }\n+              jcr->where = strdup(ua->cmd);\n             }\n-            jcr->where = strdup(ua->cmd);\n             goto try_again;\n           }\n         } else { /* Plugin Options */\n-          if (GetCmd(ua, T_(\"Please enter Plugin Options string: \"))) {\n-            if (jcr->dir_impl->plugin_options) {\n-              free(jcr->dir_impl->plugin_options);\n-              jcr->dir_impl->plugin_options = NULL;\n-            }\n-            jcr->dir_impl->plugin_options = strdup(ua->cmd);\n-            goto try_again;\n-          }\n+          GetPluginOptions(ua, jcr);\n+          goto try_again;\n         }\n         break;\n       case 10:\n@@ -754,14 +755,8 @@ int ModifyJobParameters(UaContext* ua, JobControlRecord* jcr, RunContext& rc)\n           SelectWhereRegexp(ua, jcr);\n           goto try_again;\n         } else if (jcr->is_JobType(JT_BACKUP)) {\n-          if (GetCmd(ua, T_(\"Please enter Plugin Options string: \"))) {\n-            if (jcr->dir_impl->plugin_options) {\n-              free(jcr->dir_impl->plugin_options);\n-              jcr->dir_impl->plugin_options = NULL;\n-            }\n-            jcr->dir_impl->plugin_options = strdup(ua->cmd);\n-            goto try_again;\n-          }\n+          GetPluginOptions(ua, jcr);\n+          goto try_again;\n         }\n         break;\n       case 11:\n@@ -788,14 +783,8 @@ int ModifyJobParameters(UaContext* ua, JobControlRecord* jcr, RunContext& rc)\n         goto try_again;\n       case 13:\n         /* Plugin Options */\n-        if (GetCmd(ua, T_(\"Please enter Plugin Options string: \"))) {\n-          if (jcr->dir_impl->plugin_options) {\n-            free(jcr->dir_impl->plugin_options);\n-            jcr->dir_impl->plugin_options = NULL;\n-          }\n-          jcr->dir_impl->plugin_options = strdup(ua->cmd);\n-          goto try_again;\n-        }\n+        GetPluginOptions(ua, jcr);\n+        goto try_again;\n         break;\n       case -1: /* error or cancel */\n         return -1;\n@@ -1059,6 +1048,10 @@ static void SelectWhereRegexp(UaContext* ua, JobControlRecord* jcr)\n     case 3:\n       /* Add rwhere */\n       if (GetCmd(ua, T_(\"Please enter a valid regexp (!from!to!): \"))) {\n+        if (!ua->AclAccessOk(Where_ACL, ua->cmd, true)) {\n+          ua->SendMsg(T_(\"Denied by \\\"WhereACL\\\" configuration.\\n\"));\n+          goto try_again_reg;\n+        }\n         if (rwhere) free(rwhere);\n         rwhere = strdup(ua->cmd);\n       }\n@@ -1125,6 +1118,13 @@ static void SelectWhereRegexp(UaContext* ua, JobControlRecord* jcr)\n     jcr->RegexWhere = (char*)malloc(len * sizeof(char));\n     bregexp_build_where(jcr->RegexWhere, len, strip_prefix, add_prefix,\n                         add_suffix);\n+    if (!ua->AclAccessOk(Where_ACL, jcr->RegexWhere, true)) {\n+      ua->SendMsg(T_(\"Regex (%s) denied by \\\"WhereACL\\\" configuration.\\n\"),\n+                  jcr->RegexWhere);\n+      free(jcr->RegexWhere);\n+      jcr->RegexWhere = NULL;\n+      goto try_again_reg;\n+    }\n   }\n \n   regs = get_bregexps(jcr->RegexWhere);\n@@ -1146,6 +1146,24 @@ static void SelectWhereRegexp(UaContext* ua, JobControlRecord* jcr)\n   if (rwhere) { free(rwhere); }\n }\n \n+static bool GetPluginOptions(UaContext* ua, JobControlRecord* jcr)\n+{\n+  if (GetCmd(ua, T_(\"Please enter Plugin Options string: \"))) {\n+    if (!ua->AclAccessOk(PluginOptions_ACL, ua->cmd, true)) {\n+      ua->SendMsg(\n+          T_(\"No authorization for \\\"PluginOptions\\\" specification.\\n\"));\n+      return false;\n+    }\n+    if (jcr->dir_impl->plugin_options) {\n+      free(jcr->dir_impl->plugin_options);\n+      jcr->dir_impl->plugin_options = NULL;\n+    }\n+    jcr->dir_impl->plugin_options = strdup(ua->cmd);\n+    return true;\n+  }\n+  return false;\n+}\n+\n static void SelectJobLevel(UaContext* ua, JobControlRecord* jcr)\n {\n   if (jcr->is_JobType(JT_BACKUP)) {\n@@ -1606,16 +1624,16 @@ static bool DisplayJobParameters(UaContext* ua,\n       } else {\n         if (ua->api) ua->signal(BNET_RUN_CMD);\n         ua->SendMsg(T_(\"Run Restore job\\n\"\n-                       \"JobName:    %s\\n\"\n-                       \"Bootstrap:  %s\\n\"),\n+                       \"JobName:         %s\\n\"\n+                       \"Bootstrap:       %s\\n\"),\n                     job->resource_name_, NPRT(jcr->RestoreBootstrap));\n \n         /* RegexWhere is take before RestoreWhere */\n         if (jcr->RegexWhere || (job->RegexWhere && !jcr->where)) {\n-          ua->SendMsg(T_(\"RegexWhere: %s\\n\"),\n+          ua->SendMsg(T_(\"RegexWhere:      %s\\n\"),\n                       jcr->RegexWhere ? jcr->RegexWhere : job->RegexWhere);\n         } else {\n-          ua->SendMsg(T_(\"Where:      %s\\n\"),\n+          ua->SendMsg(T_(\"Where:           %s\\n\"),\n                       jcr->where ? jcr->where : NPRT(job->RestoreWhere));\n         }\n \n@@ -1880,7 +1898,8 @@ static bool ScanCommandLineArguments(UaContext* ua, RunContext& rc)\n             }\n             rc.where = ua->argv[i];\n             if (!ua->AclAccessOk(Where_ACL, rc.where, true)) {\n-              ua->SendMsg(T_(\"No authoriztion for \\\"where\\\" specification.\\n\"));\n+              ua->SendMsg(\n+                  T_(\"No authorization for \\\"where\\\" specification.\\n\"));\n               return false;\n             }\n             kw_ok = true;"
        },
        {
          "filename": "docs/manuals/source/include/autogenerated/bareos-dir-config-schema.json",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -2384,7 +2384,7 @@\n           \"datatype\": \"ACL\",\n           \"code\": 8,\n           \"equals\": true,\n-          \"description\": \"Specifies the base directories, where files could be restored. An empty string allows restores to all directories.\"\n+          \"description\": \"Specifies the base directories, where files could be restored.\"\n         },\n         \"PluginOptionsAcl\": {\n           \"datatype\": \"ACL\",\n@@ -2463,7 +2463,7 @@\n           \"datatype\": \"ACL\",\n           \"code\": 8,\n           \"equals\": true,\n-          \"description\": \"Specifies the base directories, where files could be restored. An empty string allows restores to all directories.\"\n+          \"description\": \"Specifies the base directories, where files could be restored.\"\n         },\n         \"PluginOptionsAcl\": {\n           \"datatype\": \"ACL\",\n@@ -2651,7 +2651,7 @@\n           \"datatype\": \"ACL\",\n           \"code\": 8,\n           \"equals\": true,\n-          \"description\": \"Specifies the base directories, where files could be restored. An empty string allows restores to all directories.\"\n+          \"description\": \"Specifies the base directories, where files could be restored.\"\n         },\n         \"PluginOptionsAcl\": {\n           \"datatype\": \"ACL\","
        },
        {
          "filename": "docs/manuals/source/manually_added_config_directive_descriptions/dir-console-WhereAcl.rst.inc",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -1,2 +1,9 @@\n-This directive permits you to specify where a restricted console can restore files. If this directive is not specified, only the default restore location is permitted (normally :file:`/tmp/bareos-restores`. If :strong:`*all*` is specified any path the user enters will be accepted. Any other value specified (there may be multiple :strong:`Where ACL`\\  directives) will restrict the user to use that path. For example, on a Unix system, if you specify\n-\"/\", the file will be restored to the original location.\n+This directive permits you to specify where a restricted console can restore files.\n+This ACL is only evaluated when changing the default restore path\n+specified in the restore job (typically :file:`/tmp/bareos-restores`).\n+If :strong:`*all*` is specified any path the user enters will be accepted.\n+Any other value specified\n+(there may be multiple :strong:`Where ACL`\\  directives)\n+will restrict the user to use that path.\n+For example, on a Unix system, if you specify \"/\",\n+the file will be restored to the original location."
        },
        {
          "filename": "python-bareos/.gitignore",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -16,7 +16,6 @@ develop-eggs\n .installed.cfg\n lib\n lib64\n-__pycache__\n \n # Installer logs\n pip-log.txt"
        },
        {
          "filename": "systemtests/python-modules/bareos_unittest/json.py",
          "status": "modified",
          "additions": 46,
          "deletions": 24,
          "patch": "@@ -2,7 +2,7 @@\n #\n #   BAREOS - Backup Archiving REcovery Open Sourced\n #\n-#   Copyright (C) 2019-2022 Bareos GmbH & Co. KG\n+#   Copyright (C) 2019-2024 Bareos GmbH & Co. KG\n #\n #   This program is Free Software; you can redistribute it and/or\n #   modify it under the terms of version three of the GNU Affero General Public\n@@ -51,12 +51,20 @@ def check_resource(director, resourcesname, name):\n         logger = logging.getLogger()\n         rc = False\n         try:\n-            result = director.call(u\".{}\".format(resourcesname))\n-            for i in result[resourcesname]:\n-                if i[\"name\"] == name:\n-                    rc = True\n+            # .<resourcesname> only returns one result key,\n+            # but that can differ slightly from the called command,\n+            # e.g. \".console\" returns\n+            # \"result\": { \"consoles\": [ ... ] }\n+            # Therefore we check \"all\" keys of result\n+            # and do a substring match.\n+            result = director.call(\".{}\".format(resourcesname))\n+            for resourcetype in result.keys():\n+                if resourcetype.startswith(resourcesname):\n+                    for i in result[resourcetype]:\n+                        if i[\"name\"] == name:\n+                            rc = True\n         except Exception as e:\n-            logger.warn(str(e))\n+            logger.warning(str(e))\n         return rc\n \n     @staticmethod\n@@ -73,12 +81,10 @@ def configure_add(self, director, resourcesname, resourcename, cmd):\n             self.assertEqual(result[\"configure\"][\"add\"][\"name\"], resourcename)\n             self.assertTrue(\n                 self.check_resource(director, resourcesname, resourcename),\n-                u\"Failed to find resource {} in {}.\".format(\n-                    resourcename, resourcesname\n-                ),\n+                \"Failed to find resource {} in {}.\".format(resourcename, resourcesname),\n             )\n \n-    def wait_job(self, director, jobId, expected_status=u\"OK\"):\n+    def wait_job(self, director, jobId, expected_status=\"OK\"):\n         result = director.call(\"wait jobid={}\".format(jobId))\n         # \"result\": {\n         #    \"job\": {\n@@ -90,14 +96,14 @@ def wait_job(self, director, jobId, expected_status=u\"OK\"):\n         # }\n         self.assertEqual(result[\"job\"][\"jobstatuslong\"], expected_status)\n \n-    def run_job(self, director, jobname=None, level=None, extra=None, wait=False):\n+    def run_job(self, director, jobname, level=None, extra=None, wait=False):\n         logger = logging.getLogger()\n         run_parameter = [\"job={}\".format(jobname), \"yes\"]\n         if level:\n-            run_parameter.append(u\"level={}\".format(level))\n+            run_parameter.append(\"level={}\".format(level))\n         if extra:\n-            run_parameter.append(u\"{}\".format(extra))\n-        result = director.call(\"run {}\".format(u\" \".join(run_parameter)))\n+            run_parameter.append(\"{}\".format(extra))\n+        result = director.call(\"run {}\".format(\" \".join(run_parameter)))\n         jobId = result[\"run\"][\"jobid\"]\n         if wait:\n             self.wait_job(director, jobId)\n@@ -115,29 +121,45 @@ def run_restore(\n     ):\n         logger = logging.getLogger()\n         run_parameter = [\"client={}\".format(client)]\n-\n         if jobname:\n-            run_parameter.append(u\"restorejob={}\".format(jobname))\n+            run_parameter.append(\"restorejob={}\".format(jobname))\n         if jobid:\n-            run_parameter.append(u\"jobid={}\".format(jobid))\n+            run_parameter.append(\"jobid={}\".format(jobid))\n         if fileset:\n-            run_parameter.append(u\"fileset={}\".format(fileset))\n+            run_parameter.append(\"fileset={}\".format(fileset))\n         if extra:\n-            run_parameter.append(u\"{}\".format(extra))\n+            run_parameter.append(\"{}\".format(extra))\n         run_parameter += [\"select\", \"all\", \"done\", \"yes\"]\n-        result = director.call(\"restore {}\".format(u\" \".join(run_parameter)))\n+        result = director.call(\"restore {}\".format(\" \".join(run_parameter)))\n         jobId = result[\"run\"][\"jobid\"]\n         if wait:\n             self.wait_job(director, jobId)\n         return jobId\n \n+    def get_backup_jobid(self, director, jobname, level=\"F\", extra=None):\n+        \"\"\"\n+        Get a valid backup job jobid.\n+        If no such job exists,\n+        run such a job.\n+        \"\"\"\n+        result = director.call(\n+            \"list jobs job={} level={} jobstatus=T last\".format(jobname, level)\n+        )\n+        try:\n+            jobid = result[\"jobs\"][0][\"jobid\"]\n+            return jobid\n+        except IndexError:\n+            # there is no valid backup for these parameters.\n+            # run a backup job.\n+            return self.run_job(director, jobname, level, extra, wait=True)\n+\n     def _test_job_result(self, jobs, jobid):\n         logger = logging.getLogger()\n         for job in jobs:\n             if job[\"jobid\"] == jobid:\n                 files = int(job[\"jobfiles\"])\n-                logger.debug(u\"Job {} contains {} files.\".format(jobid, files))\n-                self.assertTrue(files >= 1, u\"Job {} contains no files.\".format(jobid))\n+                logger.debug(\"Job {} contains {} files.\".format(jobid, files))\n+                self.assertTrue(files >= 1, \"Job {} contains no files.\".format(jobid))\n                 return True\n         self.fail(\"Failed to find job {}\".format(jobid))\n         # add return to prevent pylint warning\n@@ -184,7 +206,7 @@ def _test_list_with_invalid_jobid(self, director, jobid):\n             self.assertEqual(\n                 len(result),\n                 0,\n-                u\"Command {} should not return results. Current result: {} visible\".format(\n+                \"Command {} should not return results. Current result: {} visible\".format(\n                     listcmd, str(result)\n                 ),\n             )\n@@ -222,4 +244,4 @@ def list_jobid(self, director, jobid):\n         try:\n             return result[\"jobs\"][0]\n         except KeyError:\n-            raise ValueError(u\"jobid {} does not exist\".format(jobid))\n+            raise ValueError(\"jobid {} does not exist\".format(jobid))"
        },
        {
          "filename": "systemtests/tests/CMakeLists.txt",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -37,7 +37,6 @@ add_subdirectory(chflags)\n add_subdirectory(client-initiated)\n add_subdirectory(commandline-options)\n add_subdirectory(config-dump)\n-add_subdirectory(config-syntax-crash)\n add_subdirectory(copy-migrate)\n add_subdirectory(copy-archive-job)\n add_subdirectory(copy-remote-bscan)"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/CMakeLists.txt",
          "status": "removed",
          "additions": 0,
          "deletions": 21,
          "patch": "@@ -1,21 +0,0 @@\n-#   BAREOS\u00ae - Backup Archiving REcovery Open Sourced\n-#\n-#   Copyright (C) 2021-2021 Bareos GmbH & Co. KG\n-#\n-#   This program is Free Software; you can redistribute it and/or\n-#   modify it under the terms of version three of the GNU Affero General Public\n-#   License as published by the Free Software Foundation and included\n-#   in the file LICENSE.\n-#\n-#   This program is distributed in the hope that it will be useful, but\n-#   WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n-#   Affero General Public License for more details.\n-#\n-#   You should have received a copy of the GNU Affero General Public License\n-#   along with this program; if not, write to the Free Software\n-#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-#   02110-1301, USA.\n-\n-get_filename_component(BASENAME ${CMAKE_CURRENT_BINARY_DIR} NAME)\n-create_systemtest(${SYSTEMTEST_PREFIX} ${BASENAME})"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/catalog/MyCatalog.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 6,
          "patch": "@@ -1,6 +0,0 @@\n-Catalog {\n-  Name = MyCatalog\n-  dbname = \"@db_name@\"\n-  dbuser = \"@db_user@\"\n-  dbpassword = \"@db_password@\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/client/bareos-fd.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 7,
          "patch": "@@ -1,7 +0,0 @@\n-Client {\n-  Name = bareos-fd\n-  Description = \"Client resource of the Director itself.\"\n-  Address = @hostname@\n-  Password = \"@fd_password@\"          # password for FileDaemon\n-  FD PORT = @fd_port@\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/director/bareos-dir.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 23,
          "patch": "@@ -1,23 +0,0 @@\n-Director {                            # define myself\n-  Name = bareos-dir\n-  QueryFile = \"@scriptdir@/query.sql\"\n-  Maximum Concurrent Jobs = 10\n-  Password = \"@dir_password@\"         # Console password\n-  Messages = Daemon\n-  Auditing = yes\n-\n-  # Enable the Heartbeat if you experience connection losses\n-  # (eg. because of your router or firewall configuration).\n-  # Additionally the Heartbeat can be enabled in bareos-sd and bareos-fd.\n-  #\n-  # Heartbeat Interval = 1 min\n-\n-  # remove comment from \"Plugin Directory\" to load plugins from specified directory.\n-  # if \"Plugin Names\" is defined, only the specified plugins will be loaded,\n-  # otherwise all director plugins (*-dir.so) from the \"Plugin Directory\".\n-  #\n-  # Plugin Directory = \"@python_plugin_module_src_dir@\"\n-  # Plugin Names = \"\"\n-  Working Directory =  \"@working_dir@\"\n-  DirPort = @dir_port@\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/fileset/Catalog.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 11,
          "patch": "@@ -1,11 +0,0 @@\n-FileSet {\n-  Name = \"Catalog\"\n-  Description = \"Backup the catalog dump and Bareos configuration files.\"\n-  Include {\n-    Options {\n-      Signature = XXH128\n-    }\n-    File = \"@working_dir@/@db_name@.sql\" # database dump\n-    File = \"@confdir@\"                   # configuration\n-  }\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/fileset/SelfTest.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 11,
          "patch": "@@ -1,11 +0,0 @@\n-FileSet {\n-  Name = \"SelfTest\"\n-  Description = \"fileset just to backup some files for selftest\"\n-  Include {\n-    Options {\n-      Signature = XXH128\n-    }\n-   #File = \"@sbindir@\"\n-    File=<@tmpdir@/file-list\n-  }\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/job/RestoreFiles.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 11,
          "patch": "@@ -1,11 +0,0 @@\n-Job {\n-  Name = \"RestoreFiles\"\n-  Description = \"Standard Restore template. Only one such job is needed for all standard Jobs/Clients/Storage ...\"\n-  Type = Restore\n-  Client = bareos-fd\n-  FileSet = SelfTest\n-  Storage = File\n-  Pool = Incremental\n-  Messages = Standard\n-  Where = @tmp@/bareos-restores\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/job/backup-bareos-fd.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1,5 +0,0 @@\n-Job {\n-  Name = \"backup-bareos-fd\"\n-  JobDefs = \"DefaultJob\"\n-  Client = \"bareos-fd\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/jobdefs/DefaultJob.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 15,
          "patch": "@@ -1,15 +0,0 @@\n-JobDefs {\n-  Name = \"DefaultJob\"\n-  Type = Backup\n-  Level = Incremental\n-  Client = bareos-fd\n-  FileSet = \"SelfTest\"\n-  Storage = File\n-  Messages = Standard\n-  Pool = Incremental\n-  Priority = 10\n-  Write Bootstrap = \"@working_dir@/%c.bsr\"\n-  Full Backup Pool = Full                  # write Full Backups into \"Full\" Pool\n-  Differential Backup Pool = Differential  # write Diff Backups into \"Differential\" Pool\n-  Incremental Backup Pool = Incremental    # write Incr Backups into \"Incremental\" Pool\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/messages/Daemon.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 7,
          "patch": "@@ -1,7 +0,0 @@\n-Messages {\n-  Name = Daemon\n-  Description = \"Message delivery for daemon messages (no job).\"\n-  console = all, !skipped, !saved, !audit\n-  append = \"@logdir@/bareos.log\" = all, !skipped, !audit\n-  append = \"@logdir@/bareos-audit.log\" = audit\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/messages/Standard.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 7,
          "patch": "@@ -1,7 +0,0 @@\n-Messages {\n-  Name = Standard\n-  Description = \"Reasonable message delivery -- send most everything to email address and to the console.\"\n-  console = all, !skipped, !saved, !audit\n-  append = \"@logdir@/bareos.log\" = all, !skipped, !saved, !audit\n-  catalog = all, !skipped, !saved, !audit\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/pool/Differential.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 10,
          "patch": "@@ -1,10 +0,0 @@\n-Pool {\n-  Name = Differential\n-  Pool Type = Backup\n-  Recycle = yes                       # Bareos can automatically recycle Volumes\n-  AutoPrune = yes                     # Prune expired volumes\n-  Volume Retention = 90 days          # How long should the Differential Backups be kept? (#09)\n-  Maximum Volume Bytes = 10G          # Limit Volume size to something reasonable\n-  Maximum Volumes = 100               # Limit number of Volumes in Pool\n-  Label Format = \"Differential-\"      # Volumes will be labeled \"Differential-<volume-id>\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/pool/Full.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 10,
          "patch": "@@ -1,10 +0,0 @@\n-Pool {\n-  Name = Full\n-  Pool Type = Backup\n-  Recycle = yes                       # Bareos can automatically recycle Volumes\n-  AutoPrune = yes                     # Prune expired volumes\n-  Volume Retention = 365 days         # How long should the Full Backups be kept? (#06)\n-  Maximum Volume Bytes = 50G          # Limit Volume size to something reasonable\n-  Maximum Volumes = 100               # Limit number of Volumes in Pool\n-  Label Format = \"Full-\"              # Volumes will be labeled \"Full-<volume-id>\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/pool/Incremental.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 10,
          "patch": "@@ -1,10 +0,0 @@\n-Pool {\n-  Name = Incremental\n-  Pool Type = Backup\n-  Recycle = yes                       # Bareos can automatically recycle Volumes\n-  AutoPrune = yes                     # Prune expired volumes\n-  Volume Retention = 30 days          # How long should the Incremental Backups be kept?  (#12)\n-  Maximum Volume Bytes = 1G           # Limit Volume size to something reasonable\n-  Maximum Volumes = 100               # Limit number of Volumes in Pool\n-  Label Format = \"Incremental-\"       # Volumes will be labeled \"Incremental-<volume-id>\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/pool/Scratch.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -1,4 +0,0 @@\n-Pool {\n-  Name = Scratch\n-  Pool Type = Scratch\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/profile/operator.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 18,
          "patch": "@@ -1,18 +0,0 @@\n-Profile {\n-   Name = operator\n-   Description = \"Profile allowing normal Bareos operations.\"\n-\n-   Command ACL = !.bvfs_clear_cache, !.exit, !.sql\n-   Command ACL = !configure, !create, !delete, !purge, !prune, !sqlquery, !umount, !unmount\n-   Command ACL = *all*\n-\n-   Catalog ACL = *all*\n-   Client ACL = *all*\n-   FileSet ACL = *all*\n-   Job ACL = *all*\n-   Plugin Options ACL = *all*\n-   Pool ACL = *all*\n-   Schedule ACL = *all*\n-   Storage ACL = *all*\n-   Where ACL = \"|!(){}\" # invalid chars\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-dir.d/storage/File.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 8,
          "patch": "@@ -1,8 +0,0 @@\n-Storage {\n-  Name = File\n-  Address = @hostname@\n-  Password = \"@sd_password@\"\n-  Device = FileStorage\n-  Media Type = File\n-  SD Port = @sd_port@\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-fd.d/client/myself.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 15,
          "patch": "@@ -1,15 +0,0 @@\n-Client {\n-  Name = @basename@-fd\n-  Maximum Concurrent Jobs = 20\n-\n-  # remove comment from \"Plugin Directory\" to load plugins from specified directory.\n-  # if \"Plugin Names\" is defined, only the specified plugins will be loaded,\n-  # otherwise all filedaemon plugins (*-fd.so) from the \"Plugin Directory\".\n-  #\n-  # Plugin Directory = \"@python_plugin_module_src_fd@\"\n-  # Plugin Names = \"\"\n-\n-  Working Directory =  \"@working_dir@\"\n-  FD Port = @fd_port@\n-\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-fd.d/director/bareos-dir.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1,5 +0,0 @@\n-Director {\n-  Name = bareos-dir\n-  Password = \"@fd_password@\"\n-  Description = \"Allow the configured Director to access this file daemon.\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-fd.d/messages/Standard.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1,5 +0,0 @@\n-Messages {\n-  Name = Standard\n-  Director = bareos-dir = all, !skipped, !restored\n-  Description = \"Send relevant messages to the Director.\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-sd.d/device/FileStorage.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 11,
          "patch": "@@ -1,11 +0,0 @@\n-Device {\n-  Name = FileStorage\n-  Media Type = File\n-  Archive Device = storage\n-  LabelMedia = yes;                   # lets Bareos label unlabeled media\n-  Random Access = yes;\n-  AutomaticMount = yes;               # when device opened, read it\n-  RemovableMedia = no;\n-  AlwaysOpen = no;\n-  Description = \"File device. A connecting Director must have the same Name and MediaType.\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-sd.d/director/bareos-dir.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1,5 +0,0 @@\n-Director {\n-  Name = bareos-dir\n-  Password = \"@sd_password@\"\n-  Description = \"Director, who is permitted to contact this storage daemon.\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-sd.d/messages/Standard.conf",
          "status": "removed",
          "additions": 0,
          "deletions": 5,
          "patch": "@@ -1,5 +0,0 @@\n-Messages {\n-  Name = Standard\n-  Director = bareos-dir = all\n-  Description = \"Send all messages to the Director.\"\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/etc/bareos/bareos-sd.d/storage/bareos-sd.conf.in",
          "status": "removed",
          "additions": 0,
          "deletions": 14,
          "patch": "@@ -1,14 +0,0 @@\n-Storage {\n-  Name = bareos-sd\n-  Maximum Concurrent Jobs = 20\n-\n-  # remove comment from \"Plugin Directory\" to load plugins from specified directory.\n-  # if \"Plugin Names\" is defined, only the specified plugins will be loaded,\n-  # otherwise all storage plugins (*-sd.so) from the \"Plugin Directory\".\n-  #\n-  # Plugin Directory = \"@python_plugin_module_src_sd@\"\n-  # Plugin Names = \"\"\n-  Working Directory =  \"@working_dir@\"\n-  SD Port = @sd_port@\n-  @sd_backend_config@\n-}"
        },
        {
          "filename": "systemtests/tests/config-syntax-crash/testrunner",
          "status": "removed",
          "additions": 0,
          "deletions": 28,
          "patch": "@@ -1,28 +0,0 @@\n-#!/bin/bash\n-set -e\n-set -o pipefail\n-set -u\n-#\n-# Start and stop the daemons to make sure our configuration does not crash them.\n-# This checks\n-# - an invalid entry in an ACL\n-#\n-TestName=\"$(basename \"$(pwd)\")\"\n-export TestName\n-\n-JobName=backup-bareos-fd\n-\n-#shellcheck source=../environment.in\n-. ./environment\n-\n-#shellcheck source=../scripts/functions\n-. \"${rscripts}\"/functions\n-\"${rscripts}\"/cleanup\n-\"${rscripts}\"/setup\n-\n-start_test\n-\n-start_bareos\n-stop_bareos\n-\n-end_test"
        },
        {
          "filename": "systemtests/tests/python-bareos/etc/bareos/bareos-dir.d/console/client-bareos-fd.conf",
          "status": "modified",
          "additions": 4,
          "deletions": 15,
          "patch": "@@ -1,20 +1,9 @@\n Console {\n-   Name = client-bareos-fd\n-   Password = secret\n+   Name = \"client-bareos-fd\"\n+   Password = \"secret\"\n    TLS Enable = no\n \n-   # Command ACL from operator profile.\n-   Command ACL = !.bvfs_clear_cache, !.exit, !.sql\n-   Command ACL = !configure, !create, !delete, !purge, !prune, !sqlquery, !umount, !unmount\n-   Command ACL = *all*\n+   Profile = \"operator\"\n \n-   Catalog ACL = *all*\n-   Client ACL = \"bareos-fd\"\n-   FileSet ACL = *all*\n-   Job ACL = *all*\n-   Plugin Options ACL = *all*\n-   Pool ACL = *all*\n-   Schedule ACL = *all*\n-   Storage ACL = *all*\n-   Where ACL = *all*\n+   Client ACL = \"bareos-fd\", \"!*all*\"\n }"
        },
        {
          "filename": "systemtests/tests/python-bareos/etc/bareos/bareos-dir.d/console/limited-operator.conf",
          "status": "added",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -0,0 +1,10 @@\n+Console {\n+   Name = \"limited-operator\"\n+   Password = \"secret\"\n+   TLS Enable = no\n+\n+   Profile = \"operator\"\n+\n+   Command ACL = \"!.consoles\"\n+   Where ACL = \"/.*/tmp/bareos-restores-limited-operator\", \"!*all*\"\n+}"
        },
        {
          "filename": "systemtests/tests/python-bareos/etc/bareos/bconsole-limited-operator.conf.in",
          "status": "renamed",
          "additions": 6,
          "deletions": 1,
          "patch": "@@ -6,5 +6,10 @@ Director {\n   Name = @basename@-dir\n   DIRport = @dir_port@\n   Address = @hostname@\n-  Password = \"@dir_password@\"\n+  Password = \"INVALID\"\n+}\n+\n+Console {\n+  name = limited-operator\n+  password = secret\n }"
        },
        {
          "filename": "systemtests/tests/python-bareos/list_unittests.py",
          "status": "modified",
          "additions": 8,
          "deletions": 15,
          "patch": "@@ -3,7 +3,7 @@\n #\n #   BAREOS\u00ae - Backup Archiving REcovery Open Sourced\n #\n-#   Copyright (C) 2021-2022 Bareos GmbH & Co. KG\n+#   Copyright (C) 2021-2024 Bareos GmbH & Co. KG\n #\n #   This program is Free Software; you can redistribute it and/or\n #   modify it under the terms of version three of the GNU Affero General Public\n@@ -20,22 +20,15 @@\n #   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n #   02110-1301, USA.\n \n-\n-from __future__ import print_function\n import unittest\n \n \n-def list_tests_from(path, **kwargs):\n-    loader = unittest.TestLoader()\n-    suite = loader.discover(path, **kwargs)\n-    for atest in suite:\n-        tests = atest._tests\n-        for atest in tests:\n-            for btest in atest._tests:\n-                btestname = btest.__str__().split()\n-                print(btestname[1][1:-1] + \".\" + btestname[0])\n+def print_suite(suite):\n+    if hasattr(suite, \"__iter__\"):\n+        for x in suite:\n+            print_suite(x)\n+    else:\n+        print(suite)\n \n \n-if __name__ == \"__main__\":\n-    # list_tests_from(\".\", pattern=\"*test*.py\")\n-    list_tests_from(\".\")\n+print_suite(unittest.defaultTestLoader.discover(\".\"))"
        },
        {
          "filename": "systemtests/tests/python-bareos/test_acl.py",
          "status": "modified",
          "additions": 101,
          "deletions": 9,
          "patch": "@@ -1,7 +1,7 @@\n #\n #   BAREOS - Backup Archiving REcovery Open Sourced\n #\n-#   Copyright (C) 2019-2023 Bareos GmbH & Co. KG\n+#   Copyright (C) 2019-2024 Bareos GmbH & Co. KG\n #\n #   This program is Free Software; you can redistribute it and/or\n #   modify it under the terms of version three of the GNU Affero General Public\n@@ -20,7 +20,6 @@\n \n # -*- coding: utf-8 -*-\n \n-from __future__ import print_function\n import json\n import logging\n import os\n@@ -136,7 +135,7 @@ def test_restore_with_client_acl(self):\n         logger.debug(str(result))\n         # TODO: This is a bug.\n         #       ACL checking does not work here,\n-        #       because this jobid should be accessable in this console.\n+        #       because this jobid should be accessible in this console.\n         # self.assertIn(b'No Job found for JobId', result)\n         result = console_bareos_fd.call(\"find *\")\n         logger.debug(str(result))\n@@ -160,7 +159,7 @@ def test_restore_with_client_acl(self):\n         #\n         # 5: Select the most recent backup for a client\n         #\n-        # Only the bareos-fd client should be accessable\n+        # Only the bareos-fd client should be accessible\n         # and is therefore autoselected.\n         #\n         result = console_bareos_fd.call(\"5\")\n@@ -300,12 +299,8 @@ def test_json_list_media_with_pool_acl(self):\n             ),\n         )\n \n-        # TODO:\n-        # IMHO this is a bug.\n         # This console should not see volumes in the Full pool.\n-        # It needs to be fixed in the server side code.\n-        with self.assertRaises(AssertionError):\n-            self._test_no_volume_in_pool(console_overwrite, console_password, \"Full\")\n+        self._test_no_volume_in_pool(console_overwrite, console_password, \"Full\")\n \n     def test_json_list_jobid_with_job_acl(self):\n         \"\"\"\n@@ -402,3 +397,100 @@ def test_status_subscription_admin(self):\n     def test_status_subscription_user_fails(self):\n         with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n             self._test_status_subscription(\"client-bareos-fd\", \"secret\")\n+\n+    def test_limited_command_acl(self):\n+        \"\"\"\n+        The console \"limited-operator\" uses the profile \"operator\",\n+        but disallows the command \".consoles\".\n+        \"\"\"\n+        logger = logging.getLogger()\n+\n+        username = \"limited-operator\"\n+        password = \"secret\"\n+\n+        console = bareos.bsock.DirectorConsoleJson(\n+            address=self.director_address,\n+            port=self.director_port,\n+            name=username,\n+            password=password,\n+            **self.director_extra_options\n+        )\n+\n+        # verify that the command \".consoles\" is not allowed.\n+        # We expect that the Bareos Director will return something like:\n+        # {\n+        #   \"jsonrpc\": \"2.0\",\n+        #   \"id\": null,\n+        #   \"error\": {\n+        #     \"code\": 1,\n+        #     \"message\": \"failed\",\n+        #     \"data\": {\n+        #       \"result\": {},\n+        #       \"messages\": {\n+        #         \"error\": [\n+        #           \".consoles: is an invalid command.\\n\"\n+        #         ]\n+        #       }\n+        #     }\n+        #   }\n+        # }\n+        # DirectorConsoleJson will raise an exception, if the result contains the \"error\" key.\n+        with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n+            result = console.call(\".consoles\")\n+\n+        # verify that substings of the \".consoles\" command are not allowed.\n+        with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n+            result = console.call(\".consol\")\n+\n+        # verify that other commands are allowed.\n+        result = console.call(\".jobs\")\n+        self.assertGreaterEqual(len(result[\"jobs\"]), 1)\n+\n+    def test_limiting_where_acl(self):\n+        \"\"\"\n+        Try different where options on restore.\n+        \"\"\"\n+        logger = logging.getLogger()\n+\n+        username = \"limited-operator\"\n+        password = \"secret\"\n+\n+        jobname = \"backup-bareos-fd\"\n+        client = \"bareos-fd\"\n+        # console WhereACL is expected to be:\n+        # WhereAcl = <allowed_restore_path>, \"!*all*\"\n+        allowed_restore_path = \"{}/tmp/bareos-restores-{}\".format(os.getcwd(), username)\n+\n+        console = bareos.bsock.DirectorConsoleJson(\n+            address=self.director_address,\n+            port=self.director_port,\n+            name=username,\n+            password=password,\n+            **self.director_extra_options\n+        )\n+\n+        # retrieve or create a jobid of a valid backup job\n+        backup_jobid = self.get_backup_jobid(console, jobname)\n+\n+        # restore with default where path\n+        restore_jobid = self.run_restore(console, client=client, jobid=backup_jobid)\n+\n+        # restore with allowed where path\n+        restore_jobid = self.run_restore(\n+            console,\n+            client=client,\n+            jobid=backup_jobid,\n+            extra=\"where={}\".format(allowed_restore_path),\n+        )\n+\n+        # try to restore with non-allowed where path\n+        with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n+            restore_jobid = self.run_restore(\n+                console, client=client, jobid=backup_jobid, extra=\"where=/tmp/INVALID\"\n+            )\n+\n+        # try to restore with non-allowed empty where path\n+        with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n+            restore_jobid = self.run_restore(\n+                console, client=client, jobid=backup_jobid, extra=\"where=\"\n+            )"
        },
        {
          "filename": "systemtests/tests/python-bareos/test_json_config.py",
          "status": "modified",
          "additions": 50,
          "deletions": 5,
          "patch": "@@ -1,7 +1,7 @@\n #\n #   BAREOS - Backup Archiving REcovery Open Sourced\n #\n-#   Copyright (C) 2019-2021 Bareos GmbH & Co. KG\n+#   Copyright (C) 2019-2024 Bareos GmbH & Co. KG\n #\n #   This program is Free Software; you can redistribute it and/or\n #   modify it under the terms of version three of the GNU Affero General Public\n@@ -73,7 +73,7 @@ def test_show_command(self):\n \n         self.assertFalse(\n             self.check_resource(director, resourcesname, newclient),\n-            u\"Resource {} in {} already exists.\".format(newclient, resourcesname),\n+            \"Resource {} in {} already exists.\".format(newclient, resourcesname),\n         )\n \n         with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n@@ -83,7 +83,7 @@ def test_show_command(self):\n             director,\n             resourcesname,\n             newclient,\n-            u\"client={} password={} address=127.0.0.1\".format(newclient, newpassword),\n+            \"client={} password={} address=127.0.0.1\".format(newclient, newpassword),\n         )\n \n         director.call(\"show all\")\n@@ -122,14 +122,14 @@ def test_configure_add_with_quotes(self):\n \n         self.assertFalse(\n             self.check_resource(director, resourcesname, testname),\n-            u\"Resource {} in {} already exists.\".format(testname, resourcesname),\n+            \"Resource {} in {} already exists.\".format(testname, resourcesname),\n         )\n \n         self.configure_add(\n             director,\n             resourcesname,\n             testname,\n-            u'job jobdefs=DefaultJob name={} description=\"{}\" runafterjob=\"{}\" priority={}'.format(\n+            'job jobdefs=DefaultJob name={} description=\"{}\" runafterjob=\"{}\" priority={}'.format(\n                 testname, stringwithwhitespace, testscript, priority\n             ),\n         )\n@@ -150,3 +150,48 @@ def test_configure_add_with_quotes(self):\n             result[\"jobs\"][testname][\"priority\"],\n             priority,\n         )\n+\n+    def _test_configure_add_conole_with_where_acl(self, name, where_acl):\n+        username = self.get_operator_username()\n+        password = self.get_operator_password(username)\n+\n+        director = bareos.bsock.DirectorConsoleJson(\n+            address=self.director_address,\n+            port=self.director_port,\n+            name=username,\n+            password=password,\n+            **self.director_extra_options\n+        )\n+\n+        resourcetype = \"console\"\n+\n+        try:\n+            os.remove(\"etc/bareos/bareos-dir.d/{}/{}.conf\".format(resourcetype, name))\n+            director.call(\"reload\")\n+        except OSError:\n+            pass\n+\n+        self.assertFalse(\n+            self.check_resource(director, resourcetype, name),\n+            \"Resource {} in {} already exists.\".format(name, resourcetype),\n+        )\n+\n+        self.configure_add(\n+            director,\n+            resourcetype,\n+            name,\n+            '{} name={} password=secret profile=operator WhereACL=\"{}\"'.format(\n+                resourcetype, name, where_acl\n+            ),\n+        )\n+\n+        self.assertTrue(self.check_resource(director, resourcetype, name))\n+\n+    def test_configure_add_valid_where_acl(self):\n+        self._test_configure_add_conole_with_where_acl(\n+            \"valid-WhereAcl\", \"/tmp/validpath\"\n+        )\n+\n+    def test_configure_add_invalid_where_acl(self):\n+        with self.assertRaises(bareos.exceptions.JsonRpcErrorReceivedException):\n+            self._test_configure_add_conole_with_where_acl(\"invalid-WhereAcl\", \"|!(){}\")"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 28,
        "dependency_files": 0,
        "test_files": 33,
        "unique_directories": 28,
        "max_directory_depth": 7
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d561478177a6dbe025fadfb0735a3f3c3bbef412",
            "date": "2024-12-31T13:25:23Z",
            "author_login": "BareosBot"
          },
          {
            "sha": "8544927d748ad1d69b64a1200835ac60137076b8",
            "date": "2024-12-31T13:25:17Z",
            "author_login": "BareosBot"
          },
          {
            "sha": "480c77f37c9332ffd2cacc16d9378dd3a5b4a723",
            "date": "2024-12-31T12:27:20Z",
            "author_login": "pstorz"
          },
          {
            "sha": "64d1db9576587ac863c627e32f64b84ecb4e9e1c",
            "date": "2024-12-31T09:53:08Z",
            "author_login": "pstorz"
          },
          {
            "sha": "de86aa52a49012deefa086f1719189bcbc0ca064",
            "date": "2024-12-19T19:13:30Z",
            "author_login": "pstorz"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-285",
    "description": "Bareos is open source software for backup, archiving, and recovery of data for operating systems. When a command ACL is in place and a user executes a command in bconsole using an abbreviation (i.e. \"w\" for \"whoami\") the ACL check did not apply to the full form (i.e. \"whoami\") but to the abbreviated form (i.e. \"w\"). If the command ACL is configured with negative ACL that should forbid using the \"whoami\" command, you could still use \"w\" or \"who\" as a command successfully. Fixes for the problem are shipped in Bareos versions 23.0.4, 22.1.6 and 21.1.11. If only positive command ACLs are used without any negation, the problem does not occur.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-10T15:15:18.217",
    "last_modified": "2024-09-10T15:50:47.237",
    "fix_date": "2024-07-12T14:41:08Z"
  },
  "references": [
    {
      "url": "https://github.com/bareos/bareos/commit/2a026698b87d13bd1c6275726b5e826702f81dd5",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/bareos/bareos/pull/1875",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/bareos/bareos/security/advisories/GHSA-jfww-q346-r2r8",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.110188",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "bareos",
    "owner": "bareos",
    "created_at": "2013-08-12T14:06:47Z",
    "updated_at": "2025-01-13T12:23:12Z",
    "pushed_at": "2025-01-13T06:39:55Z",
    "size": 126911,
    "stars": 1012,
    "forks": 273,
    "open_issues": 77,
    "watchers": 1012,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "bareos-12.4",
      "bareos-13.2",
      "bareos-14.2-debian",
      "bareos-14.2",
      "bareos-15.2",
      "bareos-16.2-droplet",
      "bareos-16.2",
      "bareos-17.2",
      "bareos-18.2",
      "bareos-19.2",
      "bareos-20",
      "bareos-21",
      "bareos-22",
      "bareos-23",
      "bareos-24"
    ],
    "languages": {
      "C++": 7958934,
      "C": 3860973,
      "JavaScript": 2895616,
      "Python": 1203143,
      "Shell": 751981,
      "CMake": 517550,
      "PHP": 456442,
      "HTML": 303689,
      "NSIS": 148376,
      "RPC": 120231,
      "PLpgSQL": 62034,
      "Roff": 46403,
      "CSS": 38534,
      "Yacc": 20990,
      "Makefile": 20893,
      "M4": 14388,
      "TeX": 12112,
      "Vim Script": 6552,
      "Pawn": 5351,
      "Batchfile": 3698,
      "Perl": 3258,
      "QMake": 1227,
      "GDB": 374,
      "sed": 341
    },
    "commit_activity": {
      "total_commits_last_year": 1296,
      "avg_commits_per_week": 24.923076923076923,
      "days_active_last_year": 227
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T14:06:14.452533"
  }
}