{
  "cve_id": "CVE-2024-45052",
  "github_data": {
    "repository": "ethyca/fides",
    "fix_commit": "457b0e9df9f0d337133d6078bca6ed88bbc745f4",
    "related_commits": [
      "457b0e9df9f0d337133d6078bca6ed88bbc745f4"
    ],
    "patch_url": "https://github.com/ethyca/fides/commit/457b0e9df9f0d337133d6078bca6ed88bbc745f4.patch",
    "fix_commit_details": {
      "sha": "457b0e9df9f0d337133d6078bca6ed88bbc745f4",
      "commit_date": "2024-08-29T14:02:12Z",
      "author": {
        "login": "pattisdr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 549,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 159,
        "additions": 129,
        "deletions": 30
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -40,6 +40,10 @@ The types of changes are:\n - Fix bug where Data Detection & Discovery table pagination fails to reset after navigating or searching  [#5234](https://github.com/ethyca/fides/pull/5234)\n - Ignoring HTTP 400 error responses from the unsubscribe endpoint for HubSpot [#5237](https://github.com/ethyca/fides/pull/5237)\n \n+### Security\n+- Reduced timing differences in login endpoint [CVE-2024-45052](https://github.com/ethyca/fides/security/advisories/GHSA-2h46-8gf5-fmxv)\n+\n+\n ## [2.43.1](https://github.com/ethyca/fides/compare/2.43.0...2.43.1)\n \n ### Added"
        },
        {
          "filename": "src/fides/api/api/v1/endpoints/user_endpoints.py",
          "status": "modified",
          "additions": 27,
          "deletions": 9,
          "patch": "@@ -1,4 +1,6 @@\n import json\n+import random\n+import time\n from datetime import datetime\n from typing import List, Optional\n \n@@ -35,6 +37,7 @@\n from fides.api.models.sql_models import System  # type: ignore[attr-defined]\n from fides.api.oauth.roles import APPROVER, VIEWER\n from fides.api.oauth.utils import (\n+    create_temporary_user_for_login_flow,\n     extract_payload,\n     get_current_user,\n     oauth2_scheme,\n@@ -76,6 +79,11 @@\n router = APIRouter(tags=[\"Users\"], prefix=V1_URL_PREFIX)\n \n \n+ARTIFICIAL_TEMP_USER = create_temporary_user_for_login_flow(\n+    CONFIG\n+)  # To reduce likelihood of timing attacks.  Creating once and holding in memory\n+\n+\n def get_system_by_fides_key(db: Session, system_key: FidesKey) -> System:\n     \"\"\"Load a system by FidesKey or throw a 404\"\"\"\n     system = System.get_by(db, field=\"fides_key\", value=system_key)\n@@ -541,6 +549,8 @@ def user_login(\n     generate a token.\"\"\"\n     user: FidesUser\n     client: ClientDetail\n+    should_raise_exception: bool = False\n+\n     if (\n         config.security.root_username\n         and config.security.root_password\n@@ -578,18 +588,15 @@ def user_login(\n             db, field=\"username\", value=user_data.username\n         )\n \n-        invalid_user_error_msg = \"Incorrect username or password.\"\n-\n         if not user_check:\n-            raise HTTPException(\n-                status_code=HTTP_403_FORBIDDEN, detail=invalid_user_error_msg\n-            )\n+            # Postpone raising the exception to reduce the time differences between\n+            # login flows for valid and invalid users. Instead, create a temporary user\n+            # on which we'll perform parallel operations\n+            should_raise_exception = True\n+            user_check = ARTIFICIAL_TEMP_USER\n \n         if not user_check.credentials_valid(user_data.password):\n-            raise HTTPException(\n-                status_code=HTTP_403_FORBIDDEN,\n-                detail=invalid_user_error_msg,\n-            )\n+            should_raise_exception = True\n \n         # We have already checked for None but mypy still complains. This prevents mypy\n         # from complaining.\n@@ -600,10 +607,21 @@ def user_login(\n             config.security.oauth_client_id_length_bytes,\n             config.security.oauth_client_secret_length_bytes,\n             user,\n+            skip_save=should_raise_exception,\n         )\n \n     logger.info(\"Creating login access token\")\n     access_code = client.create_access_code_jwe(config.security.app_encryption_key)\n+\n+    # Sleep for a random time period\n+    time.sleep(random.uniform(0.00, 0.50))\n+\n+    if should_raise_exception:\n+        # Now raise postponed exception!\n+        raise HTTPException(\n+            status_code=HTTP_403_FORBIDDEN, detail=\"Incorrect username or password.\"\n+        )\n+\n     return UserLoginResponse(\n         user_data=user,\n         token_data=AccessToken(access_token=access_code),"
        },
        {
          "filename": "src/fides/api/models/client.py",
          "status": "modified",
          "additions": 22,
          "deletions": 14,
          "patch": "@@ -66,6 +66,7 @@ def create_client_and_secret(\n         roles: list[str] | None = None,\n         systems: list[str] | None = None,\n         connections: list[str] | None = None,\n+        in_memory: bool | None = False,\n     ) -> tuple[\"ClientDetail\", str]:\n         \"\"\"Creates a ClientDetail and returns that along with the unhashed secret\n         so it can be returned to the user on create\n@@ -92,20 +93,27 @@ def create_client_and_secret(\n             salt.encode(encoding),\n         )\n \n-        client = super().create(\n-            db,\n-            data={\n-                \"id\": client_id,\n-                \"salt\": salt,\n-                \"hashed_secret\": hashed_secret,\n-                \"scopes\": scopes,\n-                \"fides_key\": fides_key,\n-                \"user_id\": user_id,\n-                \"roles\": roles,\n-                \"systems\": systems,\n-                \"connections\": connections,\n-            },\n-        )\n+        data = {\n+            \"id\": client_id,\n+            \"salt\": salt,\n+            \"hashed_secret\": hashed_secret,\n+            \"scopes\": scopes,\n+            \"fides_key\": fides_key,\n+            \"user_id\": user_id,\n+            \"roles\": roles,\n+            \"systems\": systems,\n+            \"connections\": connections,\n+        }\n+\n+        if in_memory:\n+            client = ClientDetail(\n+                **data\n+            )  # For creating a temporary ClientDetail for invalid user login flow\n+        else:\n+            client = super().create(\n+                db,\n+                data=data,\n+            )\n         return client, secret  # type: ignore\n \n     @classmethod"
        },
        {
          "filename": "src/fides/api/oauth/utils.py",
          "status": "modified",
          "additions": 48,
          "deletions": 1,
          "patch": "@@ -17,6 +17,7 @@\n \n from fides.api.api.deps import get_db\n from fides.api.common_exceptions import AuthenticationError, AuthorizationError\n+from fides.api.cryptography.cryptographic_util import generate_secure_random_string\n from fides.api.cryptography.schemas.jwt import (\n     JWE_ISSUED_AT,\n     JWE_PAYLOAD_CLIENT_ID,\n@@ -25,14 +26,15 @@\n )\n from fides.api.models.client import ClientDetail\n from fides.api.models.fides_user import FidesUser\n+from fides.api.models.fides_user_permissions import FidesUserPermissions\n from fides.api.models.policy import PolicyPreWebhook\n from fides.api.models.pre_approval_webhook import PreApprovalWebhook\n from fides.api.models.privacy_request import RequestTask\n from fides.api.oauth.roles import get_scopes_from_roles\n from fides.api.schemas.external_https import RequestTaskJWE, WebhookJWE\n from fides.api.schemas.oauth import OAuth2ClientCredentialsBearer\n from fides.common.api.v1.urn_registry import TOKEN, V1_URL_PREFIX\n-from fides.config import CONFIG\n+from fides.config import CONFIG, FidesConfig\n \n JWT_ENCRYPTION_ALGORITHM = ALGORITHMS.A256GCM\n \n@@ -395,5 +397,50 @@ def has_scope_subset(user_scopes: List[str], endpoint_scopes: SecurityScopes) ->\n     return True\n \n \n+def create_temporary_user_for_login_flow(config: FidesConfig) -> FidesUser:\n+    \"\"\"\n+    Create a temporary FidesUser in-memory with an attached in-memory ClientDetail\n+    and attached in-memory FidesUserPermissions\n+\n+    This is for reducing the time differences in the user login flow between a\n+    valid and an invalid user\n+    \"\"\"\n+    hashed_password, salt = FidesUser.hash_password(generate_secure_random_string(16))\n+    user = FidesUser(\n+        **{\n+            \"salt\": salt,\n+            \"hashed_password\": hashed_password,\n+            \"username\": \"temp_user\",\n+            \"email_address\": \"temp_user@example.com\",\n+            \"first_name\": \"temp_first_name\",\n+            \"last_name\": \"temp_surname\",\n+            \"disabled\": True,\n+        }\n+    )\n+\n+    # Create in-memory user permissions\n+    user.permissions = FidesUserPermissions(  # type: ignore[attr-defined]\n+        id=\"temp_user_id\",\n+        user_id=\"temp_user_id\",\n+        roles=[\"fake_role\"],\n+    )\n+\n+    # Create in-memory client, not persisted to db\n+    client, _ = ClientDetail.create_client_and_secret(\n+        None,  # type: ignore[arg-type]\n+        config.security.oauth_client_id_length_bytes,\n+        config.security.oauth_client_secret_length_bytes,\n+        scopes=[],  # type: ignore\n+        roles=user.permissions.roles,  # type: ignore\n+        systems=user.system_ids,  # type: ignore\n+        user_id=\"temp_user_id\",\n+        in_memory=True,\n+    )\n+\n+    user.client = client\n+\n+    return user\n+\n+\n # This allows us to selectively enforce auth depending on user environment settings\n verify_oauth_client_prod = copy_func(verify_oauth_client)"
        },
        {
          "filename": "src/fides/api/service/user/fides_user_service.py",
          "status": "modified",
          "additions": 13,
          "deletions": 5,
          "patch": "@@ -1,6 +1,6 @@\n import uuid\n from datetime import datetime\n-from typing import Tuple\n+from typing import Optional, Tuple\n \n from loguru import logger\n from sqlalchemy.orm import Session\n@@ -87,9 +87,14 @@ def perform_login(\n     client_id_byte_length: int,\n     client_secret_byte_length: int,\n     user: FidesUser,\n+    skip_save: Optional[bool] = False,\n ) -> ClientDetail:\n     \"\"\"Performs a login by updating the FidesUser instance and creating and returning\n     an associated ClientDetail.\n+\n+    If the username or password was bad, skip_save should be True. We still run through\n+    parallel operations to keep the timing of operations similar, but should skip\n+    saving to the database.\n     \"\"\"\n \n     client = user.client\n@@ -103,18 +108,21 @@ def perform_login(\n             roles=user.permissions.roles,  # type: ignore\n             systems=user.system_ids,  # type: ignore\n             user_id=user.id,\n+            in_memory=skip_save,  # If login flow has already errored, don't persist this to the database\n         )\n     else:\n         # Refresh the client just in case - for example, scopes and roles were added via the db directly.\n         client.roles = user.permissions.roles  # type: ignore\n         client.systems = user.system_ids  # type: ignore\n-        client.save(db)\n+        if not skip_save:\n+            client.save(db)\n \n-    if not user.permissions.roles and not user.systems:  # type: ignore\n+    if user.permissions and (not user.permissions.roles and not user.systems):  # type: ignore\n         logger.warning(\"User {} needs roles or systems to login.\", user.id)\n         raise AuthorizationError(detail=\"Not Authorized for this action\")\n \n-    user.last_login_at = datetime.utcnow()\n-    user.save(db)\n+    if not skip_save:\n+        user.last_login_at = datetime.utcnow()\n+        user.save(db)\n \n     return client"
        },
        {
          "filename": "tests/ops/api/v1/endpoints/test_user_endpoints.py",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -1013,14 +1013,28 @@ class TestUserLogin:\n     def url(self) -> str:\n         return V1_URL_PREFIX + LOGIN\n \n-    def test_user_does_not_exist(self, url, api_client):\n+    def test_user_does_not_exist(self, db, url, api_client):\n         body = {\n             \"username\": \"does not exist\",\n             \"password\": str_to_b64_str(\"idonotknowmypassword\"),\n         }\n         response = api_client.post(url, headers={}, json=body)\n         assert response.status_code == HTTP_403_FORBIDDEN\n \n+        user = FidesUser.get_by(db, field=\"username\", value=body[\"username\"])\n+        assert user is None\n+\n+        # The temporary resources created to parallelize operations between the invalid\n+        # and valid flow do not get persisted\n+        user = FidesUser.get_by(db, field=\"username\", value=\"temp_user\")\n+        assert user is None\n+\n+        user_perms = FidesUserPermissions.get_by(db, field=\"id\", value=\"temp_user_id\")\n+        assert user_perms is None\n+\n+        client_search = ClientDetail.get_by(db, field=\"id\", value=\"temp_user_id\")\n+        assert client_search is None\n+\n     def test_bad_login(self, url, user, api_client):\n         body = {\n             \"username\": user.username,"
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 6,
        "max_directory_depth": 6
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "de209feb31ce2619c9db608d41fa5d58877589cd",
            "date": "2025-01-13T18:02:13Z",
            "author_login": "galvana"
          },
          {
            "sha": "83cb612e4bc7f1fe424cab8a0a54c024331dfe53",
            "date": "2025-01-13T17:08:18Z",
            "author_login": "daveqnet"
          },
          {
            "sha": "7ea4ad58d49dfcd525344fdf1de86078797febf5",
            "date": "2025-01-13T16:05:18Z",
            "author_login": "jpople"
          },
          {
            "sha": "73188c53f9479cd6dbd4f3637a4fc03faec9d3cf",
            "date": "2025-01-13T15:06:42Z",
            "author_login": "lucanovera"
          },
          {
            "sha": "5557f79305b7be60ad6294b8960a011dc97e9e12",
            "date": "2025-01-13T14:27:10Z",
            "author_login": "lucanovera"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-208",
    "description": "Fides is an open-source privacy engineering platform. Prior to version 2.44.0, a timing-based username enumeration vulnerability exists in Fides Webserver authentication. This vulnerability allows an unauthenticated attacker to determine the existence of valid usernames by analyzing the time it takes for the server to respond to login requests. The discrepancy in response times between valid and invalid usernames can be leveraged to enumerate users on the system. This vulnerability enables a timing-based username enumeration attack. An attacker can systematically guess and verify which usernames are valid by measuring the server's response time to authentication requests. This information can be used to conduct further attacks on authentication such as password brute-forcing and credential stuffing. The vulnerability has been patched in Fides version `2.44.0`. Users are advised to upgrade to this version or later to secure their systems against this threat. There are no workarounds.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-04T16:15:07.697",
    "last_modified": "2024-09-06T18:18:59.710",
    "fix_date": "2024-08-29T14:02:12Z"
  },
  "references": [
    {
      "url": "https://github.com/ethyca/fides/commit/457b0e9df9f0d337133d6078bca6ed88bbc745f4",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/ethyca/fides/security/advisories/GHSA-2h46-8gf5-fmxv",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.463396",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fides",
    "owner": "ethyca",
    "created_at": "2021-02-04T22:42:33Z",
    "updated_at": "2025-01-13T18:02:18Z",
    "pushed_at": "2025-01-14T12:04:15Z",
    "size": 110359,
    "stars": 382,
    "forks": 73,
    "open_issues": 272,
    "watchers": 382,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 7114450,
      "TypeScript": 4436776,
      "CSS": 38216,
      "JavaScript": 32908,
      "HTML": 32388,
      "SCSS": 14657,
      "Dockerfile": 4511,
      "Jinja": 3618,
      "Mako": 494
    },
    "commit_activity": {
      "total_commits_last_year": 771,
      "avg_commits_per_week": 14.826923076923077,
      "days_active_last_year": 222
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:29:56.287100"
  }
}