{
  "cve_id": "CVE-2024-45244",
  "github_data": {
    "repository": "hyperledger/fabric",
    "fix_commit": "155457a6624b3c74b22e5729c35c8499bfe952cd",
    "related_commits": [
      "155457a6624b3c74b22e5729c35c8499bfe952cd"
    ],
    "patch_url": "https://github.com/hyperledger/fabric/commit/155457a6624b3c74b22e5729c35c8499bfe952cd.patch",
    "fix_commit_details": {
      "sha": "155457a6624b3c74b22e5729c35c8499bfe952cd",
      "commit_date": "2024-08-10T21:15:25Z",
      "author": {
        "login": "pfi79",
        "type": "User",
        "stats": {
          "total_commits": 109,
          "average_weekly_commits": 0.24008810572687225,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 46
        }
      },
      "commit_message": {
        "title": "added timestamp proposal check so that it does not go beyond timewindow (#4942)",
        "length": 135,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 528,
        "additions": 470,
        "deletions": 58
      },
      "files": [
        {
          "filename": "core/deliverservice/testdata/core.yaml",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -441,13 +441,11 @@ peer:\n   #     library: /etc/hyperledger/fabric/plugin/escc.so\n   handlers:\n     authFilters:\n-      -\n-        name: DefaultAuth\n-      -\n-        name: ExpirationCheck    # This filter checks identity x509 certificate expiration\n+      - name: DefaultAuth\n+      - name: ExpirationCheck # This filter checks identity x509 certificate expiration\n+      - name: TimeWindowCheck # This filter checks Timestamp in TimeWindow\n     decorators:\n-      -\n-        name: DefaultDecorator\n+      - name: DefaultDecorator\n     endorsers:\n       escc:\n         name: DefaultEndorsement"
        },
        {
          "filename": "core/handlers/auth/filter/timewindow.go",
          "status": "added",
          "additions": 69,
          "deletions": 0,
          "patch": "@@ -0,0 +1,69 @@\n+/*\n+Copyright IBM Corp, SecureKey Technologies Inc. All Rights Reserved.\n+\n+SPDX-License-Identifier: Apache-2.0\n+*/\n+\n+package filter\n+\n+import (\n+\t\"context\"\n+\t\"time\"\n+\n+\t\"github.com/hyperledger/fabric-protos-go/peer\"\n+\t\"github.com/hyperledger/fabric/core/handlers/auth\"\n+\t\"github.com/hyperledger/fabric/protoutil\"\n+\t\"github.com/pkg/errors\"\n+)\n+\n+// NewTimeWindowCheckFilter creates a new Filter that checks timewindow expiration\n+func NewTimeWindowCheckFilter(timeWindow time.Duration) auth.Filter {\n+\treturn &timewindowCheckFilter{\n+\t\ttimeWindow: timeWindow,\n+\t}\n+}\n+\n+type timewindowCheckFilter struct {\n+\tnext       peer.EndorserServer\n+\ttimeWindow time.Duration\n+}\n+\n+// Init initializes the Filter with the next EndorserServer\n+func (f *timewindowCheckFilter) Init(next peer.EndorserServer) {\n+\tf.next = next\n+}\n+\n+func validateTimewindowProposal(signedProp *peer.SignedProposal, timeWindow time.Duration) error {\n+\tprop, err := protoutil.UnmarshalProposal(signedProp.ProposalBytes)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed parsing proposal\")\n+\t}\n+\n+\thdr, err := protoutil.UnmarshalHeader(prop.Header)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed parsing header\")\n+\t}\n+\n+\tchdr, err := protoutil.UnmarshalChannelHeader(hdr.ChannelHeader)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed parsing channel header\")\n+\t}\n+\n+\ttimeProposal := chdr.Timestamp.AsTime().UTC()\n+\tnow := time.Now().UTC()\n+\n+\tif timeProposal.Add(timeWindow).Before(now) || timeProposal.Add(-timeWindow).After(now) {\n+\t\treturn errors.Errorf(\"request unauthorized due to incorrect timestamp %s, peer time %s, peer.authentication.timewindow %s\",\n+\t\t\ttimeProposal.Format(time.RFC3339), now.Format(time.RFC3339), timeWindow.String())\n+\t}\n+\n+\treturn nil\n+}\n+\n+// ProcessProposal processes a signed proposal\n+func (f *timewindowCheckFilter) ProcessProposal(ctx context.Context, signedProp *peer.SignedProposal) (*peer.ProposalResponse, error) {\n+\tif err := validateTimewindowProposal(signedProp, f.timeWindow); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn f.next.ProcessProposal(ctx, signedProp)\n+}"
        },
        {
          "filename": "core/handlers/auth/filter/timewindow_test.go",
          "status": "added",
          "additions": 64,
          "deletions": 0,
          "patch": "@@ -0,0 +1,64 @@\n+/*\n+Copyright IBM Corp. All Rights Reserved.\n+\n+SPDX-License-Identifier: Apache-2.0\n+*/\n+\n+package filter\n+\n+import (\n+\t\"context\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/hyperledger/fabric-protos-go/common\"\n+\t\"github.com/hyperledger/fabric-protos-go/peer\"\n+\t\"github.com/hyperledger/fabric/protoutil\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"google.golang.org/protobuf/types/known/timestamppb\"\n+)\n+\n+func createSignedProposalForCheckTimeWindow(t *testing.T, tt time.Time) *peer.SignedProposal {\n+\tsHdr := protoutil.MakeSignatureHeader(createX509Identity(t, \"notExpiredCert.pem\"), nil)\n+\thdr := protoutil.MakePayloadHeader(&common.ChannelHeader{\n+\t\tTimestamp: timestamppb.New(tt),\n+\t}, sHdr)\n+\thdrBytes, err := proto.Marshal(hdr)\n+\trequire.NoError(t, err)\n+\tprop := &peer.Proposal{\n+\t\tHeader: hdrBytes,\n+\t}\n+\tpropBytes, err := proto.Marshal(prop)\n+\trequire.NoError(t, err)\n+\treturn &peer.SignedProposal{\n+\t\tProposalBytes: propBytes,\n+\t}\n+}\n+\n+func TestTimeWindowCheckFilter(t *testing.T) {\n+\tnextEndorser := &mockEndorserServer{}\n+\tauth := NewTimeWindowCheckFilter(time.Minute * 15)\n+\tauth.Init(nextEndorser)\n+\n+\tnow := time.Now()\n+\n+\t// Scenario I: Not expired timestamp\n+\tsp := createSignedProposalForCheckTimeWindow(t, now)\n+\t_, err := auth.ProcessProposal(context.Background(), sp)\n+\trequire.NoError(t, err)\n+\trequire.True(t, nextEndorser.invoked)\n+\tnextEndorser.invoked = false\n+\n+\t// Scenario II: Expired timestamp before\n+\tsp = createSignedProposalForCheckTimeWindow(t, now.Add(-time.Minute*30))\n+\t_, err = auth.ProcessProposal(context.Background(), sp)\n+\trequire.Contains(t, err.Error(), \"request unauthorized due to incorrect timestamp\")\n+\trequire.False(t, nextEndorser.invoked)\n+\n+\t// Scenario III: Expired timestamp after\n+\tsp = createSignedProposalForCheckTimeWindow(t, now.Add(time.Minute*30))\n+\t_, err = auth.ProcessProposal(context.Background(), sp)\n+\trequire.Contains(t, err.Error(), \"request unauthorized due to incorrect timestamp\")\n+\trequire.False(t, nextEndorser.invoked)\n+}"
        },
        {
          "filename": "core/handlers/library/config.go",
          "status": "modified",
          "additions": 19,
          "deletions": 8,
          "patch": "@@ -7,17 +7,20 @@\n package library\n \n import (\n+\t\"time\"\n+\n \t\"github.com/mitchellh/mapstructure\"\n \t\"github.com/spf13/viper\"\n )\n \n // Config configures the factory methods\n // and plugins for the registry\n type Config struct {\n-\tAuthFilters []*HandlerConfig `yaml:\"authFilters\"`\n-\tDecorators  []*HandlerConfig `yaml:\"decorators\"`\n-\tEndorsers   PluginMapping    `yaml:\"endorsers\"`\n-\tValidators  PluginMapping    `yaml:\"validators\"`\n+\tAuthFilters              []*HandlerConfig `yaml:\"authFilters\"`\n+\tDecorators               []*HandlerConfig `yaml:\"decorators\"`\n+\tEndorsers                PluginMapping    `yaml:\"endorsers\"`\n+\tValidators               PluginMapping    `yaml:\"validators\"`\n+\tAuthenticationTimeWindow time.Duration    `yaml:\"authenticationTimeWindow\"`\n }\n \n // PluginMapping stores a map between chaincode id to plugin config\n@@ -54,10 +57,18 @@ func LoadConfig() (Config, error) {\n \t\tvalidators[k] = &HandlerConfig{Name: name, Library: library}\n \t}\n \n+\tauthenticationTimeWindow := viper.GetDuration(\"peer.authentication.timewindow\")\n+\tif authenticationTimeWindow == 0 {\n+\t\tdefaultTimeWindow := 15 * time.Minute\n+\t\tlogger.Warningf(\"`peer.authentication.timewindow` not set; defaulting to %s\", defaultTimeWindow)\n+\t\tauthenticationTimeWindow = defaultTimeWindow\n+\t}\n+\n \treturn Config{\n-\t\tAuthFilters: authFilters,\n-\t\tDecorators:  decorators,\n-\t\tEndorsers:   endorsers,\n-\t\tValidators:  validators,\n+\t\tAuthFilters:              authFilters,\n+\t\tDecorators:               decorators,\n+\t\tEndorsers:                endorsers,\n+\t\tValidators:               validators,\n+\t\tAuthenticationTimeWindow: authenticationTimeWindow,\n \t}, nil\n }"
        },
        {
          "filename": "core/handlers/library/config_test.go",
          "status": "modified",
          "additions": 10,
          "deletions": 4,
          "patch": "@@ -10,6 +10,7 @@ import (\n \t\"bytes\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"github.com/spf13/viper\"\n \t\"github.com/stretchr/testify/require\"\n@@ -24,6 +25,8 @@ peer:\n         library: /path/to/default.so\n       - name: ExpirationCheck\n         library: /path/to/expiration.so\n+      - name: TimeWindowCheck\n+        library: /path/to/timewindow.so\n     decorators:\n       - name: DefaultDecorator\n         library: /path/to/decorators.so\n@@ -49,6 +52,7 @@ peer:\n \t\tAuthFilters: []*HandlerConfig{\n \t\t\t{Name: \"DefaultAuth\", Library: \"/path/to/default.so\"},\n \t\t\t{Name: \"ExpirationCheck\", Library: \"/path/to/expiration.so\"},\n+\t\t\t{Name: \"TimeWindowCheck\", Library: \"/path/to/timewindow.so\"},\n \t\t},\n \t\tDecorators: []*HandlerConfig{\n \t\t\t{Name: \"DefaultDecorator\", Library: \"/path/to/decorators.so\"},\n@@ -59,6 +63,7 @@ peer:\n \t\tValidators: PluginMapping{\n \t\t\t\"vscc\": &HandlerConfig{Name: \"DefaultValidation\", Library: \"/path/to/vscc.so\"},\n \t\t},\n+\t\tAuthenticationTimeWindow: 900000000000,\n \t}\n \trequire.EqualValues(t, expect, actual)\n }\n@@ -96,10 +101,11 @@ peer:\n \trequire.NotNil(t, actual)\n \n \texpect := Config{\n-\t\tAuthFilters: nil,\n-\t\tDecorators:  nil,\n-\t\tEndorsers:   PluginMapping{\"escc\": &HandlerConfig{Name: \"DefaultEndorsement\", Library: \"/path/to/foo\"}},\n-\t\tValidators:  PluginMapping{\"vscc\": &HandlerConfig{Name: \"DefaultValidation\"}},\n+\t\tAuthFilters:              nil,\n+\t\tDecorators:               nil,\n+\t\tEndorsers:                PluginMapping{\"escc\": &HandlerConfig{Name: \"DefaultEndorsement\", Library: \"/path/to/foo\"}},\n+\t\tValidators:               PluginMapping{\"vscc\": &HandlerConfig{Name: \"DefaultValidation\"}},\n+\t\tAuthenticationTimeWindow: time.Minute * 15,\n \t}\n \n \trequire.EqualValues(t, expect, actual)"
        },
        {
          "filename": "core/handlers/library/library.go",
          "status": "modified",
          "additions": 11,
          "deletions": 1,
          "patch": "@@ -7,6 +7,8 @@ SPDX-License-Identifier: Apache-2.0\n package library\n \n import (\n+\t\"time\"\n+\n \t\"github.com/hyperledger/fabric/core/handlers/auth\"\n \t\"github.com/hyperledger/fabric/core/handlers/auth/filter\"\n \t\"github.com/hyperledger/fabric/core/handlers/decoration\"\n@@ -19,7 +21,9 @@ import (\n \n // HandlerLibrary is used to assert\n // how to create the various handlers\n-type HandlerLibrary struct{}\n+type HandlerLibrary struct {\n+\tauthenticationTimeWindow time.Duration\n+}\n \n // DefaultAuth creates a default auth.Filter\n // that doesn't do any access control checks - simply\n@@ -36,6 +40,12 @@ func (r *HandlerLibrary) ExpirationCheck() auth.Filter {\n \treturn filter.NewExpirationCheckFilter()\n }\n \n+// TimeWindowCheck is an auth filter which blocks requests\n+// from identities with Timestamp not in window\n+func (r *HandlerLibrary) TimeWindowCheck() auth.Filter {\n+\treturn filter.NewTimeWindowCheckFilter(r.authenticationTimeWindow)\n+}\n+\n // DefaultDecorator creates a default decorator\n // that doesn't do anything with the input, simply\n // returns the input as output."
        },
        {
          "filename": "core/handlers/library/registry.go",
          "status": "modified",
          "additions": 12,
          "deletions": 7,
          "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"sync\"\n+\t\"time\"\n \n \t\"github.com/hyperledger/fabric-lib-go/common/flogging\"\n \t\"github.com/hyperledger/fabric/core/handlers/auth\"\n@@ -47,10 +48,11 @@ const (\n )\n \n type registry struct {\n-\tfilters    []auth.Filter\n-\tdecorators []decoration.Decorator\n-\tendorsers  map[string]endorsement2.PluginFactory\n-\tvalidators map[string]validation.PluginFactory\n+\tfilters                  []auth.Filter\n+\tdecorators               []decoration.Decorator\n+\tendorsers                map[string]endorsement2.PluginFactory\n+\tvalidators               map[string]validation.PluginFactory\n+\tauthenticationTimeWindow time.Duration\n }\n \n var (\n@@ -63,8 +65,9 @@ var (\n func InitRegistry(c Config) Registry {\n \tonce.Do(func() {\n \t\treg = registry{\n-\t\t\tendorsers:  make(map[string]endorsement2.PluginFactory),\n-\t\t\tvalidators: make(map[string]validation.PluginFactory),\n+\t\t\tendorsers:                make(map[string]endorsement2.PluginFactory),\n+\t\t\tvalidators:               make(map[string]validation.PluginFactory),\n+\t\t\tauthenticationTimeWindow: c.AuthenticationTimeWindow,\n \t\t}\n \t\treg.loadHandlers(c)\n \t})\n@@ -100,7 +103,9 @@ func (r *registry) evaluateModeAndLoad(c *HandlerConfig, handlerType HandlerType\n \n // loadCompiled loads a statically compiled handler\n func (r *registry) loadCompiled(handlerFactory string, handlerType HandlerType, extraArgs ...string) {\n-\tregistryMD := reflect.ValueOf(&HandlerLibrary{})\n+\tregistryMD := reflect.ValueOf(&HandlerLibrary{\n+\t\tauthenticationTimeWindow: r.authenticationTimeWindow,\n+\t})\n \n \to := registryMD.MethodByName(handlerFactory)\n \tif !o.IsValid() {"
        },
        {
          "filename": "integration/e2e/filter_proposal_test.go",
          "status": "added",
          "additions": 250,
          "deletions": 0,
          "patch": "@@ -0,0 +1,250 @@\n+/*\n+Copyright IBM Corp All Rights Reserved.\n+\n+SPDX-License-Identifier: Apache-2.0\n+*/\n+\n+package e2e\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rand\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"syscall\"\n+\t\"time\"\n+\n+\tdocker \"github.com/fsouza/go-dockerclient\"\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/hyperledger/fabric-protos-go/common\"\n+\t\"github.com/hyperledger/fabric-protos-go/gateway\"\n+\t\"github.com/hyperledger/fabric-protos-go/peer\"\n+\t\"github.com/hyperledger/fabric/integration/channelparticipation\"\n+\t\"github.com/hyperledger/fabric/integration/nwo\"\n+\t\"github.com/hyperledger/fabric/protoutil\"\n+\t. \"github.com/onsi/ginkgo/v2\"\n+\t. \"github.com/onsi/gomega\"\n+\t\"github.com/pkg/errors\"\n+\t\"github.com/tedsuo/ifrit\"\n+\tginkgomon \"github.com/tedsuo/ifrit/ginkgomon_v2\"\n+\t\"google.golang.org/grpc/status\"\n+\t\"google.golang.org/protobuf/types/known/timestamppb\"\n+)\n+\n+var _ = Describe(\"FilterProposalTimeWindow\", func() {\n+\tvar (\n+\t\ttestDir                     string\n+\t\tclient                      *docker.Client\n+\t\tnetwork                     *nwo.Network\n+\t\tchaincode                   nwo.Chaincode\n+\t\tordererRunner               *ginkgomon.Runner\n+\t\tordererProcess, peerProcess ifrit.Process\n+\t)\n+\n+\tBeforeEach(func() {\n+\t\tvar err error\n+\t\ttestDir, err = os.MkdirTemp(\"\", \"e2e\")\n+\t\tExpect(err).NotTo(HaveOccurred())\n+\n+\t\tclient, err = docker.NewClientFromEnv()\n+\t\tExpect(err).NotTo(HaveOccurred())\n+\n+\t\tchaincode = nwo.Chaincode{\n+\t\t\tName:            \"mycc\",\n+\t\t\tVersion:         \"0.0\",\n+\t\t\tPath:            components.Build(\"github.com/hyperledger/fabric/integration/chaincode/simple/cmd\"),\n+\t\t\tLang:            \"binary\",\n+\t\t\tPackageFile:     filepath.Join(testDir, \"simplecc.tar.gz\"),\n+\t\t\tCtor:            `{\"Args\":[\"init\",\"a\",\"100\",\"b\",\"200\"]}`,\n+\t\t\tSignaturePolicy: `AND ('Org1MSP.member','Org2MSP.member')`,\n+\t\t\tSequence:        \"1\",\n+\t\t\tInitRequired:    true,\n+\t\t\tLabel:           \"my_prebuilt_chaincode\",\n+\t\t}\n+\t})\n+\n+\tAfterEach(func() {\n+\t\tif ordererProcess != nil {\n+\t\t\tordererProcess.Signal(syscall.SIGTERM)\n+\t\t\tEventually(ordererProcess.Wait(), network.EventuallyTimeout).Should(Receive())\n+\t\t}\n+\n+\t\tif peerProcess != nil {\n+\t\t\tpeerProcess.Signal(syscall.SIGTERM)\n+\t\t\tEventually(peerProcess.Wait(), network.EventuallyTimeout).Should(Receive())\n+\t\t}\n+\n+\t\tif network != nil {\n+\t\t\tnetwork.Cleanup()\n+\t\t}\n+\t\tos.RemoveAll(testDir)\n+\t})\n+\n+\tBeforeEach(func() {\n+\t\tnetwork = nwo.New(nwo.BasicEtcdRaft(), testDir, client, StartPort(), components)\n+\t\tnetwork.GenerateConfigTree()\n+\t\tnetwork.Bootstrap()\n+\n+\t\t// Start all the fabric processes\n+\t\tordererRunner, ordererProcess, peerProcess = network.StartSingleOrdererNetwork(\"orderer\")\n+\n+\t\tBy(\"getting the orderer by name\")\n+\t\torderer := network.Orderer(\"orderer\")\n+\n+\t\tBy(\"setting up the channel\")\n+\t\tchannelparticipation.JoinOrdererJoinPeersAppChannel(network, \"testchannel\", orderer, ordererRunner)\n+\n+\t\tBy(\"enabling new lifecycle capabilities\")\n+\t\tnwo.EnableCapabilities(network, \"testchannel\", \"Application\", \"V2_5\", orderer, network.Peer(\"Org1\", \"peer0\"), network.Peer(\"Org2\", \"peer0\"))\n+\n+\t\tBy(\"deploying the chaincode\")\n+\t\tnwo.DeployChaincode(network, \"testchannel\", orderer, chaincode)\n+\n+\t\tBy(\"getting the client peer by name\")\n+\t\tpeer := network.Peer(\"Org1\", \"peer0\")\n+\n+\t\tRunQueryInvokeQuery(network, orderer, peer, \"testchannel\")\n+\t})\n+\n+\tIt(\"filters proposal\", func() {\n+\t\tBy(\"normal time\")\n+\t\terr := endorser(network, timestamppb.Now())\n+\t\tExpect(err).NotTo(HaveOccurred())\n+\n+\t\tBy(\"add 30 minute\")\n+\t\terr = endorser(network, timestamppb.New(time.Now().Add(time.Minute*30)))\n+\t\trpcErr := status.Convert(err)\n+\t\tExpect(rpcErr.Message()).To(Equal(\"failed to collect enough transaction endorsements, see attached details for more info\"))\n+\t\tExpect(len(rpcErr.Details())).To(BeNumerically(\">\", 0))\n+\t\tExpect(rpcErr.Details()[0].(*gateway.ErrorDetail).Message).To(ContainSubstring(\"request unauthorized due to incorrect timestamp\"))\n+\n+\t\tBy(\"sub 30 minute\")\n+\t\terr = endorser(network, timestamppb.New(time.Now().Add(-time.Minute*30)))\n+\t\trpcErr = status.Convert(err)\n+\t\tExpect(rpcErr.Message()).To(Equal(\"failed to collect enough transaction endorsements, see attached details for more info\"))\n+\t\tExpect(len(rpcErr.Details())).To(BeNumerically(\">\", 0))\n+\t\tExpect(rpcErr.Details()[0].(*gateway.ErrorDetail).Message).To(ContainSubstring(\"request unauthorized due to incorrect timestamp\"))\n+\t})\n+})\n+\n+func endorser(network *nwo.Network, needTime *timestamppb.Timestamp) error {\n+\tpeerOrg1 := network.Peer(\"Org1\", \"peer0\")\n+\tsigningIdentity := network.PeerUserSigner(peerOrg1, \"User1\")\n+\tcreator, err := signingIdentity.Serialize()\n+\tExpect(err).NotTo(HaveOccurred())\n+\n+\tconn := network.PeerClientConn(peerOrg1)\n+\tgatewayClient := gateway.NewGatewayClient(conn)\n+\n+\tinvocationSpec := &peer.ChaincodeInvocationSpec{\n+\t\tChaincodeSpec: &peer.ChaincodeSpec{\n+\t\t\tType:        peer.ChaincodeSpec_NODE,\n+\t\t\tChaincodeId: &peer.ChaincodeID{Name: \"mycc\"},\n+\t\t\tInput:       &peer.ChaincodeInput{Args: [][]byte{[]byte(\"invoke\"), []byte(\"a\"), []byte(\"b\"), []byte(\"10\")}},\n+\t\t},\n+\t}\n+\n+\tproposal, transactionID, err := createChaincodeProposalWithTransient(\n+\t\tcommon.HeaderType_ENDORSER_TRANSACTION,\n+\t\t\"testchannel\",\n+\t\tinvocationSpec,\n+\t\tcreator,\n+\t\tnil,\n+\t\tneedTime,\n+\t)\n+\tExpect(err).NotTo(HaveOccurred())\n+\n+\tproposedTransaction, err := protoutil.GetSignedProposal(proposal, signingIdentity)\n+\tExpect(err).NotTo(HaveOccurred())\n+\n+\tmspid := network.Organization(peerOrg1.Organization).MSPID\n+\n+\tendorseRequest := &gateway.EndorseRequest{\n+\t\tTransactionId:          transactionID,\n+\t\tChannelId:              \"testchannel\",\n+\t\tProposedTransaction:    proposedTransaction,\n+\t\tEndorsingOrganizations: []string{mspid},\n+\t}\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), network.EventuallyTimeout)\n+\tdefer cancel()\n+\t_, err = gatewayClient.Endorse(ctx, endorseRequest)\n+\n+\treturn err\n+}\n+\n+// createChaincodeProposalWithTransient creates a proposal from given input\n+// It returns the proposal and the transaction id associated to the proposal\n+func createChaincodeProposalWithTransient(typ common.HeaderType, channelID string, cis *peer.ChaincodeInvocationSpec, creator []byte, transientMap map[string][]byte, needTime *timestamppb.Timestamp) (*peer.Proposal, string, error) {\n+\t// generate a random nonce\n+\tnonce, err := getRandomNonce()\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\t// compute txid\n+\ttxid := protoutil.ComputeTxID(nonce, creator)\n+\n+\treturn createChaincodeProposalWithTxIDNonceAndTransient(txid, typ, channelID, cis, nonce, creator, transientMap, needTime)\n+}\n+\n+func getRandomNonce() ([]byte, error) {\n+\tkey := make([]byte, 24)\n+\n+\t_, err := rand.Read(key)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"error getting random bytes\")\n+\t}\n+\treturn key, nil\n+}\n+\n+// createChaincodeProposalWithTxIDNonceAndTransient creates a proposal from\n+// given input\n+func createChaincodeProposalWithTxIDNonceAndTransient(txid string, typ common.HeaderType, channelID string, cis *peer.ChaincodeInvocationSpec, nonce, creator []byte, transientMap map[string][]byte, needTime *timestamppb.Timestamp) (*peer.Proposal, string, error) {\n+\tccHdrExt := &peer.ChaincodeHeaderExtension{ChaincodeId: cis.ChaincodeSpec.ChaincodeId}\n+\tccHdrExtBytes, err := proto.Marshal(ccHdrExt)\n+\tif err != nil {\n+\t\treturn nil, \"\", errors.Wrap(err, \"error marshaling ChaincodeHeaderExtension\")\n+\t}\n+\n+\tcisBytes, err := proto.Marshal(cis)\n+\tif err != nil {\n+\t\treturn nil, \"\", errors.Wrap(err, \"error marshaling ChaincodeInvocationSpec\")\n+\t}\n+\n+\tccPropPayload := &peer.ChaincodeProposalPayload{Input: cisBytes, TransientMap: transientMap}\n+\tccPropPayloadBytes, err := proto.Marshal(ccPropPayload)\n+\tif err != nil {\n+\t\treturn nil, \"\", errors.Wrap(err, \"error marshaling ChaincodeProposalPayload\")\n+\t}\n+\n+\thdr := &common.Header{\n+\t\tChannelHeader: protoutil.MarshalOrPanic(\n+\t\t\t&common.ChannelHeader{\n+\t\t\t\tType:      int32(typ),\n+\t\t\t\tTxId:      txid,\n+\t\t\t\tTimestamp: needTime,\n+\t\t\t\tChannelId: channelID,\n+\t\t\t\tExtension: ccHdrExtBytes,\n+\t\t\t\tEpoch:     0,\n+\t\t\t},\n+\t\t),\n+\t\tSignatureHeader: protoutil.MarshalOrPanic(\n+\t\t\t&common.SignatureHeader{\n+\t\t\t\tNonce:   nonce,\n+\t\t\t\tCreator: creator,\n+\t\t\t},\n+\t\t),\n+\t}\n+\n+\thdrBytes, err := proto.Marshal(hdr)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\tprop := &peer.Proposal{\n+\t\tHeader:  hdrBytes,\n+\t\tPayload: ccPropPayloadBytes,\n+\t}\n+\treturn prop, txid, nil\n+}"
        },
        {
          "filename": "integration/nwo/template/core_template.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -123,6 +123,7 @@ peer:\n     authFilters:\n     - name: DefaultAuth\n     - name: ExpirationCheck\n+    - name: TimeWindowCheck\n     decorators:\n     - name: DefaultDecorator\n     endorsers:"
        },
        {
          "filename": "internal/peer/node/start.go",
          "status": "modified",
          "additions": 20,
          "deletions": 20,
          "patch": "@@ -834,26 +834,6 @@ func serve(args []string) error {\n \t\tdiscprotos.RegisterDiscoveryServer(peerServer.Server(), discoveryService)\n \t}\n \n-\tif coreConfig.GatewayOptions.Enabled {\n-\t\tif coreConfig.DiscoveryEnabled {\n-\t\t\tlogger.Info(\"Starting peer with Gateway enabled\")\n-\n-\t\t\tgatewayServer := gateway.CreateServer(\n-\t\t\t\tserverEndorser,\n-\t\t\t\tdiscoveryService,\n-\t\t\t\tpeerInstance,\n-\t\t\t\t&serverConfig.SecOpts,\n-\t\t\t\taclProvider,\n-\t\t\t\tcoreConfig.LocalMSPID,\n-\t\t\t\tcoreConfig.GatewayOptions,\n-\t\t\t\tbuiltinSCCs,\n-\t\t\t)\n-\t\t\tgatewayprotos.RegisterGatewayServer(peerServer.Server(), gatewayServer)\n-\t\t} else {\n-\t\t\tlogger.Warning(\"Discovery service must be enabled for embedded gateway\")\n-\t\t}\n-\t}\n-\n \tlogger.Infof(\"Starting peer with ID=[%s], network ID=[%s], address=[%s]\", coreConfig.PeerID, coreConfig.NetworkID, coreConfig.PeerAddress)\n \n \t// Get configuration before starting go routines to avoid\n@@ -913,6 +893,26 @@ func serve(args []string) error {\n \t// Register the Endorser server\n \tpb.RegisterEndorserServer(peerServer.Server(), auth)\n \n+\tif coreConfig.GatewayOptions.Enabled {\n+\t\tif coreConfig.DiscoveryEnabled {\n+\t\t\tlogger.Info(\"Starting peer with Gateway enabled\")\n+\n+\t\t\tgatewayServer := gateway.CreateServer(\n+\t\t\t\tauth,\n+\t\t\t\tdiscoveryService,\n+\t\t\t\tpeerInstance,\n+\t\t\t\t&serverConfig.SecOpts,\n+\t\t\t\taclProvider,\n+\t\t\t\tcoreConfig.LocalMSPID,\n+\t\t\t\tcoreConfig.GatewayOptions,\n+\t\t\t\tbuiltinSCCs,\n+\t\t\t)\n+\t\t\tgatewayprotos.RegisterGatewayServer(peerServer.Server(), gatewayServer)\n+\t\t} else {\n+\t\t\tlogger.Warning(\"Discovery service must be enabled for embedded gateway\")\n+\t\t}\n+\t}\n+\n \t// register the snapshot server\n \tsnapshotSvc := &snapshotgrpc.SnapshotService{LedgerGetter: peerInstance, ACLProvider: aclProvider}\n \tpb.RegisterSnapshotServer(peerServer.Server(), snapshotSvc)"
        },
        {
          "filename": "orderer/common/cluster/testdata/blockverification/core.yaml",
          "status": "modified",
          "additions": 4,
          "deletions": 6,
          "patch": "@@ -448,13 +448,11 @@ peer:\n     #     library: /etc/hyperledger/fabric/plugin/escc.so\n     handlers:\n         authFilters:\n-          -\n-            name: DefaultAuth\n-          -\n-            name: ExpirationCheck    # This filter checks identity x509 certificate expiration\n+          - name: DefaultAuth\n+          - name: ExpirationCheck # This filter checks identity x509 certificate expiration\n+          - name: TimeWindowCheck # This filter checks Timestamp in TimeWindow\n         decorators:\n-          -\n-            name: DefaultDecorator\n+          - name: DefaultDecorator\n         endorsers:\n           escc:\n             name: DefaultEndorsement"
        },
        {
          "filename": "sampleconfig/core.yaml",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -313,6 +313,8 @@ peer:\n     authentication:\n         # the acceptable difference between the current server time and the\n         # client's time as specified in a client request message\n+        # this value is used for delivery service and\n+        # endorsement service (if the authFilter is enabled)\n         timewindow: 15m\n \n     # Path on the file system where peer will store data (eg ledger). This\n@@ -454,13 +456,11 @@ peer:\n     #     library: /etc/hyperledger/fabric/plugin/escc.so\n     handlers:\n         authFilters:\n-          -\n-            name: DefaultAuth\n-          -\n-            name: ExpirationCheck    # This filter checks identity x509 certificate expiration\n+          - name: DefaultAuth\n+          - name: ExpirationCheck # This filter checks identity x509 certificate expiration\n+          - name: TimeWindowCheck # This filter checks the timestamp of an proposal request with the peer.authentication.timewindow parameter from core.yaml\n         decorators:\n-          -\n-            name: DefaultDecorator\n+          - name: DefaultDecorator\n         endorsers:\n           escc:\n             name: DefaultEndorsement"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 5,
        "unique_directories": 8,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "713f8c7702db8cb7387d56ef4d8521e209443f96",
            "date": "2025-01-10T16:45:58Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a074996677c9e9f9bf20957e0a8762d0a247273f",
            "date": "2025-01-10T16:45:43Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "f0498f297e8e8c9ac8b71fef330d40ffae942a84",
            "date": "2025-01-10T16:44:44Z",
            "author_login": "pfi79"
          },
          {
            "sha": "267b251e32995b8b99aa9c74869f2ec3827de4bd",
            "date": "2025-01-08T17:53:50Z",
            "author_login": "ryjones"
          },
          {
            "sha": "68ca5b7088df75394860239068a22b5ef586ce7a",
            "date": "2025-01-08T13:42:25Z",
            "author_login": "chloefeal"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": null,
    "description": "Hyperledger Fabric through 2.5.9 does not verify that a request has a timestamp within the expected time window.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-08-25T02:15:03.383",
    "last_modified": "2024-10-30T19:35:24.600",
    "fix_date": "2024-08-10T21:15:25Z"
  },
  "references": [
    {
      "url": "https://github.com/hyperledger/fabric/commit/155457a6624b3c74b22e5729c35c8499bfe952cd",
      "source": "cve@mitre.org",
      "tags": [
        "Patch"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.394104",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "fabric",
    "owner": "hyperledger",
    "created_at": "2016-08-25T16:05:27Z",
    "updated_at": "2025-01-13T20:11:40Z",
    "pushed_at": "2025-01-10T18:07:15Z",
    "size": 151186,
    "stars": 15876,
    "forks": 8885,
    "open_issues": 190,
    "watchers": 15876,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.1",
      "release-1.2",
      "release-1.3",
      "release-1.4",
      "release-2.0",
      "release-2.1",
      "release-2.2",
      "release-2.3",
      "release-2.4",
      "release-2.5"
    ],
    "languages": {
      "Go": 11838841,
      "Shell": 67867,
      "Makefile": 19092,
      "Dockerfile": 8735
    },
    "commit_activity": {
      "total_commits_last_year": 300,
      "avg_commits_per_week": 5.769230769230769,
      "days_active_last_year": 159
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T13:34:23.884343"
  }
}