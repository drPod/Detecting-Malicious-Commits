{
  "cve_id": "CVE-2024-45296",
  "github_data": {
    "repository": "pillarjs/path-to-regexp",
    "fix_commit": "29b96b4a1de52824e1ca0f49a701183cc4ed476f",
    "related_commits": [
      "29b96b4a1de52824e1ca0f49a701183cc4ed476f",
      "60f2121e9b66b7b622cc01080df0aabda9eedee6"
    ],
    "patch_url": "https://github.com/pillarjs/path-to-regexp/commit/29b96b4a1de52824e1ca0f49a701183cc4ed476f.patch",
    "fix_commit_details": {
      "sha": "29b96b4a1de52824e1ca0f49a701183cc4ed476f",
      "commit_date": "2024-08-28T01:21:48Z",
      "author": {
        "login": "blakeembrey",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Add backtrack protection to parameters",
        "length": 38,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 130,
        "additions": 90,
        "deletions": 40
      },
      "files": [
        {
          "filename": "index.js",
          "status": "modified",
          "additions": 51,
          "deletions": 39,
          "patch": "@@ -1,13 +1,13 @@\n /**\n- * Expose `pathtoRegexp`.\n+ * Expose `pathToRegexp`.\n  */\n \n-module.exports = pathtoRegexp;\n+module.exports = pathToRegexp;\n \n /**\n  * Match matching groups in a regular expression.\n  */\n-var MATCHING_GROUP_REGEXP = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n+var MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\n \n /**\n  * Normalize the given path string,\n@@ -25,7 +25,7 @@ var MATCHING_GROUP_REGEXP = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n  * @api private\n  */\n \n-function pathtoRegexp(path, keys, options) {\n+function pathToRegexp(path, keys, options) {\n   options = options || {};\n   keys = keys || [];\n   var strict = options.strict;\n@@ -36,10 +36,14 @@ function pathtoRegexp(path, keys, options) {\n   var keysOffset = keys.length;\n   var i = 0;\n   var name = 0;\n+  var pos = 0;\n+  var backtrack = '';\n   var m;\n \n   if (path instanceof RegExp) {\n     while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n+      if (m[0][0] === '\\\\') continue;\n+\n       keys.push({\n         name: m[1] || name++,\n         optional: false,\n@@ -55,62 +59,68 @@ function pathtoRegexp(path, keys, options) {\n     // the same keys and options instance into every generation to get\n     // consistent matching groups before we join the sources together.\n     path = path.map(function (value) {\n-      return pathtoRegexp(value, keys, options).source;\n+      return pathToRegexp(value, keys, options).source;\n     });\n \n-    return new RegExp('(?:' + path.join('|') + ')', flags);\n+    return new RegExp(path.join('|'), flags);\n   }\n \n-  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n-    .replace(/\\/\\(/g, '/(?:')\n-    .replace(/([\\/\\.])/g, '\\\\$1')\n-    .replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n+  path = path.replace(\n+    /\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g,\n+    function (match, slash, format, key, capture, star, optional, offset) {\n+      pos = offset + match.length;\n+\n+      if (match[0] === '\\\\') {\n+        backtrack += match;\n+        return match;\n+      }\n+\n+      if (match === '.') {\n+        backtrack += '\\\\.';\n+        extraOffset += 1;\n+        return '\\\\.';\n+      }\n+\n+      backtrack = slash || format ? '' : path.slice(pos, offset);\n+\n+      if (match === '*') {\n+        extraOffset += 3;\n+        return '(.*)';\n+      }\n+\n+      if (match === '/(') {\n+        backtrack += '/';\n+        extraOffset += 2;\n+        return '/(?:';\n+      }\n+\n       slash = slash || '';\n-      format = format || '';\n-      capture = capture || '([^\\\\/' + format + ']+?)';\n+      format = format ? '\\\\.' : '';\n       optional = optional || '';\n+      capture = capture ?\n+        capture.replace(/\\\\.|\\*/, function (m) { return m === '*' ? '(.*)' : m; }) :\n+        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');\n \n       keys.push({\n         name: key,\n         optional: !!optional,\n         offset: offset + extraOffset\n       });\n \n-      var result = ''\n-        + (optional ? '' : slash)\n-        + '(?:'\n-        + format + (optional ? slash : '') + capture\n-        + (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\n+      var result = '(?:'\n+        + format + slash + capture\n+        + (star ? '((?:[/' + format + '].+?)?)' : '')\n         + ')'\n         + optional;\n \n       extraOffset += result.length - match.length;\n \n       return result;\n-    })\n-    .replace(/\\*/g, function (star, index) {\n-      var len = keys.length\n-\n-      while (len-- > keysOffset && keys[len].offset > index) {\n-        keys[len].offset += 3; // Replacement length minus asterisk length.\n-      }\n-\n-      return '(.*)';\n     });\n \n   // This is a workaround for handling unnamed matching groups.\n   while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n-    var escapeCount = 0;\n-    var index = m.index;\n-\n-    while (path.charAt(--index) === '\\\\') {\n-      escapeCount++;\n-    }\n-\n-    // It's possible to escape the bracket.\n-    if (escapeCount % 2 === 1) {\n-      continue;\n-    }\n+    if (m[0][0] === '\\\\') continue;\n \n     if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n       keys.splice(keysOffset + i, 0, {\n@@ -123,12 +133,14 @@ function pathtoRegexp(path, keys, options) {\n     i++;\n   }\n \n+  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\n+\n   // If the path is non-ending, match until the end or a slash.\n   if (end) {\n     path += '$';\n   } else if (path[path.length - 1] !== '/') {\n-    path += lookahead ? '(?=\\\\/|$)' : '(?:\\/|$)';\n+    path += lookahead ? '(?=/|$)' : '(?:/|$)';\n   }\n \n-  return new RegExp(path, flags);\n+  return new RegExp('^' + path, flags);\n };"
        },
        {
          "filename": "test.js",
          "status": "modified",
          "additions": 39,
          "deletions": 1,
          "patch": "@@ -763,6 +763,44 @@ describe('path-to-regexp', function () {\n       assert.equal(m[0], '/test.json');\n       assert.equal(m[1], 'test.json');\n     });\n+\n+    it('should match after a non-slash or format character', function () {\n+      var params = [];\n+      var re = pathToRegExp('/:x-:y', params);\n+      var m;\n+\n+      assert.equal(params.length, 2);\n+      assert.equal(params[0].name, 'x');\n+      assert.equal(params[0].optional, false);\n+      assert.equal(params[1].name, 'y');\n+      assert.equal(params[1].optional, false);\n+\n+      m = re.exec('/1-2');\n+\n+      assert.equal(m.length, 3);\n+      assert.equal(m[0], '/1-2');\n+      assert.equal(m[1], '1');\n+      assert.equal(m[2], '2');\n+    });\n+\n+    it('should replace asterisk in capture group', function () {\n+      var params = [];\n+      var re = pathToRegExp('/files/:file(*)', params);\n+      var m;\n+\n+      assert.equal(params.length, 2);\n+      assert.equal(params[0].name, 'file');\n+      assert.equal(params[0].optional, false);\n+      assert.equal(params[1].name, 0);\n+      assert.equal(params[1].optional, false);\n+\n+      m = re.exec('/files/test');\n+\n+      assert.equal(m.length, 3);\n+      assert.equal(m[0], '/files/test');\n+      assert.equal(m[1], 'test');\n+      assert.equal(m[2], 'test');\n+    })\n   });\n \n   describe('regexps', function () {\n@@ -812,7 +850,7 @@ describe('path-to-regexp', function () {\n       assert.equal(m[1], 'foo');\n       assert.equal(m[2], 'bar');\n       assert.equal(m[3], 'baz');\n-    })\n+    });\n   });\n \n   describe('arrays', function () {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 1,
        "max_directory_depth": 0
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "39e861d02d959ba99d0632af994ab48d4a8eeb14",
            "date": "2025-01-13T02:04:35Z",
            "author_login": "blakeembrey"
          },
          {
            "sha": "d63f44bc54f2c6fe7d35dc77f8515622006bf7cb",
            "date": "2024-09-30T21:27:01Z",
            "author_login": "blakeembrey"
          },
          {
            "sha": "973d15c262f113c4cb88762971920053fdbd31ff",
            "date": "2024-09-26T03:34:22Z",
            "author_login": "blakeembrey"
          },
          {
            "sha": "776c8986b89b29a368f22c1a6c598242b67fb832",
            "date": "2024-09-26T03:25:56Z",
            "author_login": "blakeembrey"
          },
          {
            "sha": "678756a844e16e1d85098343336ea31d743b290b",
            "date": "2024-09-26T03:21:41Z",
            "author_login": "blakeembrey"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-1333",
    "description": "path-to-regexp turns path strings into a regular expressions. In certain cases, path-to-regexp will output a regular expression that can be exploited to cause poor performance. Because JavaScript is single threaded and regex matching runs on the main thread, poor performance will block the event loop and lead to a DoS. The bad regular expression is generated any time you have two parameters within a single segment, separated by something that is not a period (.). For users of 0.1, upgrade to 0.1.10. All other users should upgrade to 8.0.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-09T19:15:13.330",
    "last_modified": "2024-09-10T12:09:50.377",
    "fix_date": "2024-08-28T01:21:48Z"
  },
  "references": [
    {
      "url": "https://github.com/pillarjs/path-to-regexp/commit/29b96b4a1de52824e1ca0f49a701183cc4ed476f",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pillarjs/path-to-regexp/commit/60f2121e9b66b7b622cc01080df0aabda9eedee6",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/pillarjs/path-to-regexp/security/advisories/GHSA-9wv6-86v2-598j",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.107519",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "path-to-regexp",
    "owner": "pillarjs",
    "created_at": "2012-08-01T22:47:17Z",
    "updated_at": "2025-01-14T06:21:22Z",
    "pushed_at": "2025-01-13T02:04:39Z",
    "size": 1046,
    "stars": 8251,
    "forks": 389,
    "open_issues": 2,
    "watchers": 8251,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "TypeScript": 52127
    },
    "commit_activity": {
      "total_commits_last_year": 69,
      "avg_commits_per_week": 1.3269230769230769,
      "days_active_last_year": 25
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T12:59:16.284082"
  }
}