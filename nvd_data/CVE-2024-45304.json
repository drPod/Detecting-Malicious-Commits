{
  "cve_id": "CVE-2024-45304",
  "github_data": {
    "repository": "OpenZeppelin/cairo-contracts",
    "fix_commit": "ef87d7847980e0cf83f4b7f3ff23e6590fb643ec",
    "related_commits": [
      "ef87d7847980e0cf83f4b7f3ff23e6590fb643ec"
    ],
    "patch_url": "https://github.com/OpenZeppelin/cairo-contracts/commit/ef87d7847980e0cf83f4b7f3ff23e6590fb643ec.patch",
    "fix_commit_details": {
      "sha": "ef87d7847980e0cf83f4b7f3ff23e6590fb643ec",
      "commit_date": "2024-08-30T09:51:17Z",
      "author": {
        "login": "ericnordelo",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix pending owner late overwrite issue (#1122)",
        "length": 574,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 131,
        "additions": 61,
        "deletions": 70
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -11,6 +11,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ### Added\n \n+- ERC721Enumerable component (#983)\n - ERC2981 (NFT Royalty Standard) component (#1091)\n - `merkle_tree` package with utilities to verify proofs and multi proofs (#1101)\n \n@@ -22,9 +23,14 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ### Changed (Breaking)\n \n-- Changed ABI suffix to Trait in dual case account and eth account modules (#1096).\n+- Changed ABI suffix to Trait in dual case account and eth account modules (#1096)\n   - `DualCaseAccountABI` renamed to `DualCaseAccountTrait`\n   - `DualCaseEthAccountABI` renamed to `DualCaseEthAccountTrait`\n+- Removed `_accept_ownership` from `OwnableComponent::InternalImpl`\n+\n+### Fixed\n+\n+- `OwnableTwoStep` allowing a pending owner to accept ownership after the original owner has renounced ownership (#1119)\n \n ## 0.15.1 (2024-08-13)\n \n@@ -37,7 +43,6 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ### Added\n \n-- ERC721Enumerable component (#983)\n - TimelockController component (#996)\n - HashCall implementation (#996)\n - Separated package for each submodule (#1065)"
        },
        {
          "filename": "docs/modules/ROOT/pages/api/access.adoc",
          "status": "modified",
          "additions": 0,
          "deletions": 12,
          "patch": "@@ -89,7 +89,6 @@ This module includes the internal `assert_only_owner` to restrict a function to\n * xref:OwnableComponent-assert_only_owner[`++assert_only_owner(self)++`]\n * xref:OwnableComponent-_transfer_ownership[`++_transfer_ownership(self, new_owner)++`]\n * xref:OwnableComponent-_propose_owner[`++_propose_owner(self, new_owner)++`]\n-* xref:OwnableComponent-_accept_ownership[`++_accept_ownership(self)++`]\n --\n \n [.contract-index]\n@@ -239,17 +238,6 @@ Internal function without access restriction.\n \n Emits an xref:OwnableComponent-OwnershipTransferStarted[OwnershipTransferStarted] event.\n \n-[.contract-item]\n-[[OwnableComponent-_accept_ownership]]\n-==== `[.contract-item-name]#++_accept_ownership++#++(ref self: ContractState)++` [.item-kind]#internal#\n-\n-Transfers ownership to the pending owner. Resets pending owner to zero address.\n-Calls xref:OwnableComponent-_transfer_ownership[_transfer_ownership].\n-\n-Internal function without access restriction.\n-\n-Emits an xref:OwnableComponent-OwnershipTransferred[OwnershipTransferred] event.\n-\n [#OwnableComponent-Events]\n ==== Events\n "
        },
        {
          "filename": "packages/access/src/ownable/ownable.cairo",
          "status": "modified",
          "additions": 23,
          "deletions": 13,
          "patch": "@@ -113,14 +113,26 @@ pub mod OwnableComponent {\n \n         /// Finishes the two-step ownership transfer process by accepting the ownership.\n         /// Can only be called by the pending owner.\n+        ///\n+        /// Requirements:\n+        ///\n+        /// - The caller is the pending owner.\n+        ///\n+        /// Emits an `OwnershipTransferred` event.\n         fn accept_ownership(ref self: ComponentState<TContractState>) {\n             let caller = get_caller_address();\n             let pending_owner = self.Ownable_pending_owner.read();\n             assert(caller == pending_owner, Errors::NOT_PENDING_OWNER);\n-            self._accept_ownership();\n+            self._transfer_ownership(pending_owner);\n         }\n \n         /// Starts the two-step ownership transfer process by setting the pending owner.\n+        ///\n+        /// Requirements:\n+        ///\n+        /// - The caller is the contract owner.\n+        ///\n+        /// Emits an `OwnershipTransferStarted` event.\n         fn transfer_ownership(\n             ref self: ComponentState<TContractState>, new_owner: ContractAddress\n         ) {\n@@ -130,6 +142,12 @@ pub mod OwnableComponent {\n \n         /// Leaves the contract without owner. It will not be possible to call `assert_only_owner`\n         /// functions anymore. Can only be called by the current owner.\n+        ///\n+        /// Requirements:\n+        ///\n+        /// - The caller is the contract owner.\n+        ///\n+        /// Emits an `OwnershipTransferred` event.\n         fn renounce_ownership(ref self: ComponentState<TContractState>) {\n             Ownable::renounce_ownership(ref self);\n         }\n@@ -265,14 +283,17 @@ pub mod OwnableComponent {\n             assert(caller == owner, Errors::NOT_OWNER);\n         }\n \n-        /// Transfers ownership of the contract to a new address.\n+        /// Transfers ownership of the contract to a new address and resets\n+        /// the pending owner to the zero address.\n         ///\n         /// Internal function without access restriction.\n         ///\n         /// Emits an `OwnershipTransferred` event.\n         fn _transfer_ownership(\n             ref self: ComponentState<TContractState>, new_owner: ContractAddress\n         ) {\n+            self.Ownable_pending_owner.write(Zero::zero());\n+\n             let previous_owner: ContractAddress = self.Ownable_owner.read();\n             self.Ownable_owner.write(new_owner);\n             self\n@@ -296,16 +317,5 @@ pub mod OwnableComponent {\n                     }\n                 );\n         }\n-\n-        /// Transfers ownership to the pending owner.\n-        ///\n-        /// Internal function without access restriction.\n-        ///\n-        /// Emits an `OwnershipTransferred` event.\n-        fn _accept_ownership(ref self: ComponentState<TContractState>) {\n-            let pending_owner = self.Ownable_pending_owner.read();\n-            self.Ownable_pending_owner.write(Zero::zero());\n-            self._transfer_ownership(pending_owner);\n-        }\n     }\n }"
        },
        {
          "filename": "packages/access/src/tests/test_ownable.cairo",
          "status": "modified",
          "additions": 15,
          "deletions": 1,
          "patch": "@@ -5,7 +5,7 @@ use crate::ownable::interface::{IOwnable, IOwnableCamelOnly};\n use crate::tests::mocks::ownable_mocks::DualCaseOwnableMock;\n \n use openzeppelin_test_common::ownable::OwnableSpyHelpers;\n-use openzeppelin_testing::constants::{ZERO, OTHER, OWNER};\n+use openzeppelin_testing::constants::{ZERO, OTHER, OWNER, RECIPIENT};\n use snforge_std::{spy_events, test_address, start_cheat_caller_address};\n \n //\n@@ -86,6 +86,20 @@ fn test__transfer_ownership() {\n     assert_eq!(current_owner, OTHER());\n }\n \n+#[test]\n+fn test__transfer_ownership_resets_pending_owner() {\n+    let mut state = setup();\n+\n+    state.Ownable_pending_owner.write(OTHER());\n+    let current_pending_owner = state.Ownable_pending_owner.read();\n+    assert_eq!(current_pending_owner, OTHER());\n+\n+    state._transfer_ownership(RECIPIENT());\n+\n+    let current_pending_owner = state.Ownable_pending_owner.read();\n+    assert!(current_pending_owner.is_zero());\n+}\n+\n //\n // transfer_ownership & transferOwnership\n //"
        },
        {
          "filename": "packages/access/src/tests/test_ownable_twostep.cairo",
          "status": "modified",
          "additions": 16,
          "deletions": 42,
          "patch": "@@ -44,23 +44,6 @@ fn test_initializer_owner_pending_owner() {\n     assert!(state.Ownable_pending_owner.read().is_zero());\n }\n \n-//\n-// _accept_ownership\n-//\n-\n-#[test]\n-fn test__accept_ownership() {\n-    let mut state = setup();\n-    let mut spy = spy_events();\n-    state.Ownable_pending_owner.write(OTHER());\n-\n-    state._accept_ownership();\n-\n-    spy.assert_only_event_ownership_transferred(test_address(), OWNER(), OTHER());\n-    assert_eq!(state.owner(), OTHER());\n-    assert!(state.pending_owner().is_zero());\n-}\n-\n //\n // _propose_owner\n //\n@@ -244,6 +227,22 @@ fn test_renounce_ownership() {\n     assert!(state.owner().is_zero());\n }\n \n+#[test]\n+fn test_renounce_ownership_resets_pending_owner() {\n+    let mut state = setup();\n+    let contract_address = test_address();\n+    start_cheat_caller_address(contract_address, OWNER());\n+\n+    state.Ownable_pending_owner.write(OTHER());\n+    let current_pending_owner = state.Ownable_pending_owner.read();\n+    assert_eq!(current_pending_owner, OTHER());\n+\n+    state.renounce_ownership();\n+\n+    let current_pending_owner = state.Ownable_pending_owner.read();\n+    assert!(current_pending_owner.is_zero());\n+}\n+\n #[test]\n #[should_panic(expected: ('Caller is the zero address',))]\n fn test_renounce_ownership_from_zero_address() {\n@@ -307,31 +306,6 @@ fn test_full_two_step_transfer() {\n     assert!(state.pending_owner().is_zero());\n }\n \n-#[test]\n-fn test_pending_accept_after_owner_renounce() {\n-    let mut state = setup();\n-    let mut spy = spy_events();\n-    let contract_address = test_address();\n-    start_cheat_caller_address(contract_address, OWNER());\n-    state.transfer_ownership(OTHER());\n-\n-    spy.assert_event_ownership_transfer_started(contract_address, OWNER(), OTHER());\n-    assert_eq!(state.owner(), OWNER());\n-    assert_eq!(state.pending_owner(), OTHER());\n-\n-    state.renounce_ownership();\n-\n-    spy.assert_only_event_ownership_transferred(contract_address, OWNER(), ZERO());\n-    assert!(state.owner().is_zero());\n-\n-    start_cheat_caller_address(contract_address, OTHER());\n-    state.accept_ownership();\n-\n-    spy.assert_only_event_ownership_transferred(contract_address, ZERO(), OTHER());\n-    assert_eq!(state.owner(), OTHER());\n-    assert!(state.pending_owner().is_zero());\n-}\n-\n //\n // Helpers\n //"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "19674791720bbf2a6627f5a62ca1b8e2e4283d16",
            "date": "2025-01-14T16:01:00Z",
            "author_login": "ericnordelo"
          },
          {
            "sha": "906df739160c6886e40fb0bc77b7fa25079d0a06",
            "date": "2025-01-13T15:38:35Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "dcb8bacff388d9f0b497a50d0b653fc4b66416a9",
            "date": "2025-01-10T13:27:22Z",
            "author_login": "Dahka2321"
          },
          {
            "sha": "ca212cef40ecdd5af0b220ce0b0facb3037472e1",
            "date": "2025-01-09T18:17:47Z",
            "author_login": "immrsd"
          },
          {
            "sha": "39950b704feb356389c979c11d987d957409d0dc",
            "date": "2025-01-06T19:43:20Z",
            "author_login": "andrew-fleming"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-670",
    "description": "Cairo-Contracts are OpenZeppelin Contracts written in Cairo for Starknet, a decentralized ZK Rollup. This vulnerability can lead to unauthorized ownership transfer, contrary to the original owner's intention of leaving the contract without an owner. It introduces a security risk where an unintended party (pending owner) can gain control of the contract after the original owner has renounced ownership. This could also be used by a malicious owner to simulate leaving a contract without an owner, to later regain ownership by previously having proposed himself as a pending owner. This issue has been addressed in release version 0.16.0. All users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-08-31T00:15:05.493",
    "last_modified": "2024-09-19T17:26:37.030",
    "fix_date": "2024-08-30T09:51:17Z"
  },
  "references": [
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/commit/ef87d7847980e0cf83f4b7f3ff23e6590fb643ec",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.16.0",
      "source": "security-advisories@github.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://github.com/OpenZeppelin/cairo-contracts/security/advisories/GHSA-w2px-25pm-2cf9",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.419388",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cairo-contracts",
    "owner": "OpenZeppelin",
    "created_at": "2021-08-18T23:00:24Z",
    "updated_at": "2025-01-13T16:58:31Z",
    "pushed_at": "2025-01-13T15:38:40Z",
    "size": 3614,
    "stars": 841,
    "forks": 358,
    "open_issues": 73,
    "watchers": 841,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 1358456,
      "Python": 2223
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:26:49.806548"
  }
}