{
  "cve_id": "CVE-2024-45310",
  "github_data": {
    "repository": "opencontainers/runc",
    "fix_commit": "63c2908164f3a1daea455bf5bcd8d363d70328c7",
    "related_commits": [
      "63c2908164f3a1daea455bf5bcd8d363d70328c7",
      "8781993968fd964ac723ff5f360b6f259e809a3e",
      "f0b652ea61ff6750a8fcc69865d45a7abf37accf"
    ],
    "patch_url": "https://github.com/opencontainers/runc/commit/63c2908164f3a1daea455bf5bcd8d363d70328c7.patch",
    "fix_commit_details": {
      "sha": "63c2908164f3a1daea455bf5bcd8d363d70328c7",
      "commit_date": "2024-07-02T10:58:43Z",
      "author": {
        "login": "cyphar",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "rootfs: try to scope MkdirAll to stay inside the rootfs",
        "length": 1858,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 184,
        "additions": 174,
        "deletions": 10
      },
      "files": [
        {
          "filename": "libcontainer/rootfs_linux.go",
          "status": "modified",
          "additions": 21,
          "deletions": 10,
          "patch": "@@ -313,7 +313,7 @@ func mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n \t\t\t// inside the tmpfs, so we don't want to resolve symlinks).\n \t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n \t\t\tsubsystemName := filepath.Base(b.Destination)\n-\t\t\tif err := os.MkdirAll(subsystemPath, 0o755); err != nil {\n+\t\t\tif err := utils.MkdirAllInRoot(c.root, subsystemPath, 0o755); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(dstFd string) error {\n@@ -505,15 +505,26 @@ func createMountpoint(rootfs string, m mountEntry) (string, error) {\n \t\t\t\treturn \"\", fmt.Errorf(\"%w: file bind mount over rootfs\", errRootfsToFile)\n \t\t\t}\n \t\t\t// Make the parent directory.\n-\t\t\tif err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n+\t\t\tdestDir, destBase := filepath.Split(dest)\n+\t\t\tdestDirFd, err := utils.MkdirAllInRootOpen(rootfs, destDir, 0o755)\n+\t\t\tif err != nil {\n \t\t\t\treturn \"\", fmt.Errorf(\"make parent dir of file bind-mount: %w\", err)\n \t\t\t}\n-\t\t\t// Make the target file.\n-\t\t\tf, err := os.OpenFile(dest, os.O_CREATE, 0o755)\n-\t\t\tif err != nil {\n-\t\t\t\treturn \"\", fmt.Errorf(\"create target of file bind-mount: %w\", err)\n+\t\t\tdefer destDirFd.Close()\n+\t\t\t// Make the target file. We want to avoid opening any file that is\n+\t\t\t// already there because it could be a \"bad\" file like an invalid\n+\t\t\t// device or hung tty that might cause a DoS, so we use mknodat.\n+\t\t\t// destBase does not contain any \"/\" components, and mknodat does\n+\t\t\t// not follow trailing symlinks, so we can safely just call mknodat\n+\t\t\t// here.\n+\t\t\tif err := unix.Mknodat(int(destDirFd.Fd()), destBase, unix.S_IFREG|0o644, 0); err != nil {\n+\t\t\t\t// If we get EEXIST, there was already an inode there and\n+\t\t\t\t// we can consider that a success.\n+\t\t\t\tif !errors.Is(err, unix.EEXIST) {\n+\t\t\t\t\terr = &os.PathError{Op: \"mknod regular file\", Path: dest, Err: err}\n+\t\t\t\t\treturn \"\", fmt.Errorf(\"create target of file bind-mount: %w\", err)\n+\t\t\t\t}\n \t\t\t}\n-\t\t\t_ = f.Close()\n \t\t\t// Nothing left to do.\n \t\t\treturn dest, nil\n \t\t}\n@@ -532,7 +543,7 @@ func createMountpoint(rootfs string, m mountEntry) (string, error) {\n \t\t}\n \t}\n \n-\tif err := os.MkdirAll(dest, 0o755); err != nil {\n+\tif err := utils.MkdirAllInRoot(rootfs, dest, 0o755); err != nil {\n \t\treturn \"\", err\n \t}\n \treturn dest, nil\n@@ -565,7 +576,7 @@ func mountToRootfs(c *mountConfig, m mountEntry) error {\n \t\t} else if !fi.IsDir() {\n \t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n \t\t}\n-\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n+\t\tif err := utils.MkdirAllInRoot(rootfs, dest, 0o755); err != nil {\n \t\t\treturn err\n \t\t}\n \t\t// Selinux kernels do not support labeling of /proc or /sys.\n@@ -928,7 +939,7 @@ func createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n \tif dest == rootfs {\n \t\treturn fmt.Errorf(\"%w: mknod over rootfs\", errRootfsToFile)\n \t}\n-\tif err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n+\tif err := utils.MkdirAllInRoot(rootfs, filepath.Dir(dest), 0o755); err != nil {\n \t\treturn err\n \t}\n \tif bind {"
        },
        {
          "filename": "libcontainer/system/linux.go",
          "status": "modified",
          "additions": 41,
          "deletions": 0,
          "patch": "@@ -6,7 +6,9 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n+\t\"runtime\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"syscall\"\n \t\"unsafe\"\n \n@@ -214,3 +216,42 @@ func SetLinuxPersonality(personality int) error {\n \t}\n \treturn nil\n }\n+\n+func prepareAt(dir *os.File, path string) (int, string) {\n+\tif dir == nil {\n+\t\treturn unix.AT_FDCWD, path\n+\t}\n+\n+\t// Rather than just filepath.Join-ing path here, do it manually so the\n+\t// error and handle correctly indicate cases like path=\"..\" as being\n+\t// relative to the correct directory. The handle.Name() might end up being\n+\t// wrong but because this is (currently) only used in MkdirAllInRoot, that\n+\t// isn't a problem.\n+\tdirName := dir.Name()\n+\tif !strings.HasSuffix(dirName, \"/\") {\n+\t\tdirName += \"/\"\n+\t}\n+\tfullPath := dirName + path\n+\n+\treturn int(dir.Fd()), fullPath\n+}\n+\n+func Openat(dir *os.File, path string, flags int, mode uint32) (*os.File, error) {\n+\tdirFd, fullPath := prepareAt(dir, path)\n+\tfd, err := unix.Openat(dirFd, path, flags, mode)\n+\tif err != nil {\n+\t\treturn nil, &os.PathError{Op: \"openat\", Path: fullPath, Err: err}\n+\t}\n+\truntime.KeepAlive(dir)\n+\treturn os.NewFile(uintptr(fd), fullPath), nil\n+}\n+\n+func Mkdirat(dir *os.File, path string, mode uint32) error {\n+\tdirFd, fullPath := prepareAt(dir, path)\n+\terr := unix.Mkdirat(dirFd, path, mode)\n+\tif err != nil {\n+\t\terr = &os.PathError{Op: \"mkdirat\", Path: fullPath, Err: err}\n+\t}\n+\truntime.KeepAlive(dir)\n+\treturn err\n+}"
        },
        {
          "filename": "libcontainer/utils/utils_unix.go",
          "status": "modified",
          "additions": 112,
          "deletions": 0,
          "patch": "@@ -3,6 +3,7 @@\n package utils\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"math\"\n \t\"os\"\n@@ -13,6 +14,8 @@ import (\n \t\"sync\"\n \t_ \"unsafe\" // for go:linkname\n \n+\t\"github.com/opencontainers/runc/libcontainer/system\"\n+\n \tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n \t\"github.com/sirupsen/logrus\"\n \t\"golang.org/x/sys/unix\"\n@@ -275,3 +278,112 @@ func IsLexicallyInRoot(root, path string) bool {\n \t}\n \treturn strings.HasPrefix(path, root)\n }\n+\n+// MkdirAllInRootOpen attempts to make\n+//\n+//\tpath, _ := securejoin.SecureJoin(root, unsafePath)\n+//\tos.MkdirAll(path, mode)\n+//\tos.Open(path)\n+//\n+// safer against attacks where components in the path are changed between\n+// SecureJoin returning and MkdirAll (or Open) being called. In particular, we\n+// try to detect any symlink components in the path while we are doing the\n+// MkdirAll.\n+//\n+// NOTE: Unlike os.MkdirAll, mode is not Go's os.FileMode, it is the unix mode\n+// (the suid/sgid/sticky bits are not the same as for os.FileMode).\n+//\n+// NOTE: If unsafePath is a subpath of root, we assume that you have already\n+// called SecureJoin and so we use the provided path verbatim without resolving\n+// any symlinks (this is done in a way that avoids symlink-exchange races).\n+// This means that the path also must not contain \"..\" elements, otherwise an\n+// error will occur.\n+//\n+// This is a somewhat less safe alternative to\n+// <https://github.com/cyphar/filepath-securejoin/pull/13>, but it should\n+// detect attempts to trick us into creating directories outside of the root.\n+// We should migrate to securejoin.MkdirAll once it is merged.\n+func MkdirAllInRootOpen(root, unsafePath string, mode uint32) (_ *os.File, Err error) {\n+\t// If the path is already \"within\" the root, use it verbatim.\n+\tfullPath := unsafePath\n+\tif !IsLexicallyInRoot(root, unsafePath) {\n+\t\tvar err error\n+\t\tfullPath, err = securejoin.SecureJoin(root, unsafePath)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tsubPath, err := filepath.Rel(root, fullPath)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Check for any silly mode bits.\n+\tif mode&^0o7777 != 0 {\n+\t\treturn nil, fmt.Errorf(\"tried to include non-mode bits in MkdirAll mode: 0o%.3o\", mode)\n+\t}\n+\n+\tcurrentDir, err := os.OpenFile(root, unix.O_DIRECTORY|unix.O_CLOEXEC, 0)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"open root handle: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif Err != nil {\n+\t\t\tcurrentDir.Close()\n+\t\t}\n+\t}()\n+\n+\tfor _, part := range strings.Split(subPath, string(filepath.Separator)) {\n+\t\tswitch part {\n+\t\tcase \"\", \".\":\n+\t\t\t// Skip over no-op components.\n+\t\t\tcontinue\n+\t\tcase \"..\":\n+\t\t\treturn nil, fmt.Errorf(\"possible breakout detected: found %q component in SecureJoin subpath %s\", part, subPath)\n+\t\t}\n+\n+\t\tnextDir, err := system.Openat(currentDir, part, unix.O_DIRECTORY|unix.O_NOFOLLOW|unix.O_CLOEXEC, 0)\n+\t\tswitch {\n+\t\tcase err == nil:\n+\t\t\t// Update the currentDir.\n+\t\t\t_ = currentDir.Close()\n+\t\t\tcurrentDir = nextDir\n+\n+\t\tcase errors.Is(err, unix.ENOTDIR):\n+\t\t\t// This might be a symlink or some other random file. Either way,\n+\t\t\t// error out.\n+\t\t\treturn nil, fmt.Errorf(\"cannot mkdir in %s/%s: %w\", currentDir.Name(), part, unix.ENOTDIR)\n+\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\t\t// Luckily, mkdirat will not follow trailing symlinks, so this is\n+\t\t\t// safe to do as-is.\n+\t\t\tif err := system.Mkdirat(currentDir, part, mode); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\t// Open the new directory. There is a race here where an attacker\n+\t\t\t// could swap the directory with a different directory, but\n+\t\t\t// MkdirAll's fuzzy semantics mean we don't care about that.\n+\t\t\tnextDir, err := system.Openat(currentDir, part, unix.O_DIRECTORY|unix.O_NOFOLLOW|unix.O_CLOEXEC, 0)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"open newly created directory: %w\", err)\n+\t\t\t}\n+\t\t\t// Update the currentDir.\n+\t\t\t_ = currentDir.Close()\n+\t\t\tcurrentDir = nextDir\n+\n+\t\tdefault:\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\treturn currentDir, nil\n+}\n+\n+// MkdirAllInRoot is a wrapper around MkdirAllInRootOpen which closes the\n+// returned handle, for callers that don't need to use it.\n+func MkdirAllInRoot(root, unsafePath string, mode uint32) error {\n+\tf, err := MkdirAllInRootOpen(root, unsafePath, mode)\n+\tif err == nil {\n+\t\t_ = f.Close()\n+\t}\n+\treturn err\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "610aa88ab201f289c05c2e262912d0630f46eb35",
            "date": "2025-01-10T20:23:22Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "4120935737a51cbf23676977cc8bf0b6717702f1",
            "date": "2025-01-09T10:45:31Z",
            "author_login": "lifubang"
          },
          {
            "sha": "06f1e0765576dcf6d8c2ef5e56d309618310992c",
            "date": "2024-06-23T23:31:57Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "6171da60058fe58c6bd2f2a4ae8be381cfc12cce",
            "date": "2024-12-23T01:32:02Z",
            "author_login": "kolyshkin"
          },
          {
            "sha": "c49b89168140c70dc1badd17d5ed361788898fe9",
            "date": "2024-12-21T19:52:25Z",
            "author_login": "kolyshkin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.6,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:N/I:L/A:N",
    "cwe_id": "CWE-61",
    "description": "runc is a CLI tool for spawning and running containers according to the OCI specification. runc 1.1.13 and earlier, as well as 1.2.0-rc2 and earlier, can be tricked into creating empty files or directories in arbitrary locations in the host filesystem by sharing a volume between two containers and exploiting a race with `os.MkdirAll`. While this could be used to create empty files, existing files would not be truncated. An attacker must have the ability to start containers using some kind of custom volume configuration. Containers using user namespaces are still affected, but the scope of places an attacker can create inodes can be significantly reduced. Sufficiently strict LSM policies (SELinux/Apparmor) can also in principle block this attack -- we suspect the industry standard SELinux policy may restrict this attack's scope but the exact scope of protection hasn't been analysed. This is exploitable using runc directly as well as through Docker and Kubernetes. The issue is fixed in runc v1.1.14 and v1.2.0-rc3.\n\nSome workarounds are available. Using user namespaces restricts this attack fairly significantly such that the attacker can only create inodes in directories that the remapped root user/group has write access to. Unless the root user is remapped to an actual\nuser on the host (such as with rootless containers that don't use `/etc/sub[ug]id`), this in practice means that an attacker would only be able to create inodes in world-writable directories. A strict enough SELinux or AppArmor policy could in principle also restrict the scope if a specific label is applied to the runc runtime, though neither the extent to which the standard existing policies block this attack nor what exact policies are needed to sufficiently restrict this attack have been thoroughly tested.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-03T19:15:15.243",
    "last_modified": "2024-11-21T09:37:39.410",
    "fix_date": "2024-07-02T10:58:43Z"
  },
  "references": [
    {
      "url": "https://github.com/opencontainers/runc/commit/63c2908164f3a1daea455bf5bcd8d363d70328c7",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/8781993968fd964ac723ff5f360b6f259e809a3e",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/opencontainers/runc/commit/f0b652ea61ff6750a8fcc69865d45a7abf37accf",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/opencontainers/runc/pull/4359",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/opencontainers/runc/security/advisories/GHSA-jfvp-7x6p-h2pv",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/09/03/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.453015",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "runc",
    "owner": "opencontainers",
    "created_at": "2015-06-05T23:30:45Z",
    "updated_at": "2025-01-14T11:33:23Z",
    "pushed_at": "2025-01-13T07:56:10Z",
    "size": 21572,
    "stars": 12051,
    "forks": 2130,
    "open_issues": 365,
    "watchers": 12051,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.0",
      "release-1.1",
      "release-1.2"
    ],
    "languages": {
      "Go": 1253070,
      "Shell": 305324,
      "C": 45119,
      "Makefile": 7226,
      "Dockerfile": 2644,
      "Ruby": 2035
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:26:33.730029"
  }
}