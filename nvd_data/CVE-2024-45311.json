{
  "cve_id": "CVE-2024-45311",
  "github_data": {
    "repository": "quinn-rs/quinn",
    "fix_commit": "e01609ccd8738bd438d86fa7185a0f85598cb58f",
    "related_commits": [
      "e01609ccd8738bd438d86fa7185a0f85598cb58f"
    ],
    "patch_url": "https://github.com/quinn-rs/quinn/commit/e01609ccd8738bd438d86fa7185a0f85598cb58f.patch",
    "fix_commit_details": {
      "sha": "e01609ccd8738bd438d86fa7185a0f85598cb58f",
      "commit_date": "2024-09-02T08:36:03Z",
      "author": {
        "login": "finnbear",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 22,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 64,
        "additions": 55,
        "deletions": 9
      },
      "files": [
        {
          "filename": "quinn-proto/src/endpoint.rs",
          "status": "modified",
          "additions": 21,
          "deletions": 9,
          "patch": "@@ -573,7 +573,7 @@ impl Endpoint {\n \n         if self.cids_exhausted() {\n             debug!(\"refusing connection\");\n-            self.index.remove_initial(incoming.orig_dst_cid);\n+            self.index.remove_initial(dst_cid);\n             return Err(AcceptError {\n                 cause: ConnectionError::CidsExhausted,\n                 response: Some(self.initial_close(\n@@ -602,7 +602,7 @@ impl Endpoint {\n             .is_err()\n         {\n             debug!(packet_number, \"failed to authenticate initial packet\");\n-            self.index.remove_initial(incoming.orig_dst_cid);\n+            self.index.remove_initial(dst_cid);\n             return Err(AcceptError {\n                 cause: TransportError::PROTOCOL_VIOLATION(\"authentication failed\").into(),\n                 response: None,\n@@ -651,9 +651,7 @@ impl Endpoint {\n             transport_config,\n             remote_address_validated,\n         );\n-        if dst_cid.len() != 0 {\n-            self.index.insert_initial(dst_cid, ch);\n-        }\n+        self.index.insert_initial(dst_cid, ch);\n \n         match conn.handle_first_packet(\n             now,\n@@ -802,7 +800,7 @@ impl Endpoint {\n \n     /// Clean up endpoint data structures associated with an `Incoming`.\n     fn clean_up_incoming(&mut self, incoming: &Incoming) {\n-        self.index.remove_initial(incoming.orig_dst_cid);\n+        self.index.remove_initial(incoming.packet.header.dst_cid);\n         let incoming_buffer = self.incoming_buffers.remove(incoming.incoming_idx);\n         self.all_incoming_buffers_total_bytes -= incoming_buffer.total_bytes;\n     }\n@@ -864,6 +862,7 @@ impl Endpoint {\n             cids_issued,\n             loc_cids,\n             addresses,\n+            side,\n             reset_token: None,\n         });\n         debug_assert_eq!(id, ch.0, \"connection handle allocation out of sync\");\n@@ -994,6 +993,8 @@ struct ConnectionIndex {\n     /// Identifies connections based on the initial DCID the peer utilized\n     ///\n     /// Uses a standard `HashMap` to protect against hash collision attacks.\n+    ///\n+    /// Used by the server, not the client.\n     connection_ids_initial: HashMap<ConnectionId, RouteDatagramTo>,\n     /// Identifies connections based on locally created CIDs\n     ///\n@@ -1022,17 +1023,27 @@ struct ConnectionIndex {\n impl ConnectionIndex {\n     /// Associate an incoming connection with its initial destination CID\n     fn insert_initial_incoming(&mut self, dst_cid: ConnectionId, incoming_key: usize) {\n+        if dst_cid.len() == 0 {\n+            return;\n+        }\n         self.connection_ids_initial\n             .insert(dst_cid, RouteDatagramTo::Incoming(incoming_key));\n     }\n \n     /// Remove an association with an initial destination CID\n     fn remove_initial(&mut self, dst_cid: ConnectionId) {\n-        self.connection_ids_initial.remove(&dst_cid);\n+        if dst_cid.len() == 0 {\n+            return;\n+        }\n+        let removed = self.connection_ids_initial.remove(&dst_cid);\n+        debug_assert!(removed.is_some());\n     }\n \n     /// Associate a connection with its initial destination CID\n     fn insert_initial(&mut self, dst_cid: ConnectionId, connection: ConnectionHandle) {\n+        if dst_cid.len() == 0 {\n+            return;\n+        }\n         self.connection_ids_initial\n             .insert(dst_cid, RouteDatagramTo::Connection(connection));\n     }\n@@ -1070,8 +1081,8 @@ impl ConnectionIndex {\n \n     /// Remove all references to a connection\n     fn remove(&mut self, conn: &ConnectionMeta) {\n-        if conn.init_cid.len() > 0 {\n-            self.connection_ids_initial.remove(&conn.init_cid);\n+        if conn.side.is_server() {\n+            self.remove_initial(conn.init_cid);\n         }\n         for cid in conn.loc_cids.values() {\n             self.connection_ids.remove(cid);\n@@ -1126,6 +1137,7 @@ pub(crate) struct ConnectionMeta {\n     /// Only needed to support connections with zero-length CIDs, which cannot migrate, so we don't\n     /// bother keeping it up to date.\n     addresses: FourTuple,\n+    side: Side,\n     /// Reset token provided by the peer for the CID we're currently sending to, and the address\n     /// being sent to\n     reset_token: Option<(SocketAddr, ResetToken)>,"
        },
        {
          "filename": "quinn-proto/src/tests/mod.rs",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -2994,6 +2994,32 @@ fn reject_manually() {\n     ));\n }\n \n+#[test]\n+fn validate_then_reject_manually() {\n+    let _guard = subscribe();\n+    let mut pair = Pair::default();\n+    pair.server.incoming_connection_behavior = IncomingConnectionBehavior::ValidateThenReject;\n+\n+    // The server should now retry and reject incoming connections.\n+    let client_ch = pair.begin_connect(client_config());\n+    pair.drive();\n+    pair.server.assert_no_accept();\n+    let client = pair.client.connections.get_mut(&client_ch).unwrap();\n+    assert!(client.is_closed());\n+    assert!(matches!(\n+        client.poll(),\n+        Some(Event::ConnectionLost {\n+            reason: ConnectionError::ConnectionClosed(close)\n+        }) if close.error_code == TransportErrorCode::CONNECTION_REFUSED\n+    ));\n+    pair.drive();\n+    assert_matches!(pair.client_conn_mut(client_ch).poll(), None);\n+    assert_eq!(pair.client.known_connections(), 0);\n+    assert_eq!(pair.client.known_cids(), 0);\n+    assert_eq!(pair.server.known_connections(), 0);\n+    assert_eq!(pair.server.known_cids(), 0);\n+}\n+\n #[test]\n fn endpoint_and_connection_impl_send_sync() {\n     const fn is_send_sync<T: Send + Sync>() {}"
        },
        {
          "filename": "quinn-proto/src/tests/util.rs",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -306,6 +306,7 @@ pub(super) enum IncomingConnectionBehavior {\n     AcceptAll,\n     RejectAll,\n     Validate,\n+    ValidateThenReject,\n     Wait,\n }\n \n@@ -377,6 +378,13 @@ impl TestEndpoint {\n                                     self.retry(incoming);\n                                 }\n                             }\n+                            IncomingConnectionBehavior::ValidateThenReject => {\n+                                if incoming.remote_address_validated() {\n+                                    self.reject(incoming);\n+                                } else {\n+                                    self.retry(incoming);\n+                                }\n+                            }\n                             IncomingConnectionBehavior::Wait => {\n                                 self.waiting_incoming.push(incoming);\n                             }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6bfd24861e65649a7b00a9a8345273fe1d853a90",
            "date": "2025-01-10T18:58:27Z",
            "author_login": "djc"
          },
          {
            "sha": "3c3d46037884b0bf2b7d64653f88681381489eea",
            "date": "2025-01-09T13:55:09Z",
            "author_login": "mxinden"
          },
          {
            "sha": "e51d0e4b6b157c48863d52914d9a939f464af0e0",
            "date": "2025-01-07T09:07:07Z",
            "author_login": "djc"
          },
          {
            "sha": "fbc795e3cea722996232f2c853772390e05d51fe",
            "date": "2025-01-06T15:58:04Z",
            "author_login": "mxinden"
          },
          {
            "sha": "c32e2e20896e6e1c78222cfcc703c3d36722bfb2",
            "date": "2025-01-05T14:38:42Z",
            "author_login": "mxinden"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-670",
    "description": "Quinn is a pure-Rust, async-compatible implementation of the IETF QUIC transport protocol. As of quinn-proto 0.11, it is possible for a server to `accept()`, `retry()`, `refuse()`, or `ignore()` an `Incoming` connection. However, calling `retry()` on an unvalidated connection exposes the server to a likely panic in the following situations:  1. Calling `refuse` or `ignore` on the resulting validated connection, if a duplicate initial packet is received. This issue can go undetected until a server's `refuse()`/`ignore()` code path is exercised, such as to stop a denial of service attack. 2. Accepting when the initial packet for the resulting validated connection fails to decrypt or exhausts connection IDs, if a similar initial packet that successfully decrypts and doesn't exhaust connection IDs is received. This issue can go undetected if clients are well-behaved. The former situation was observed in a real application, while the latter is only theoretical.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-02T18:15:37.373",
    "last_modified": "2024-09-25T17:03:36.817",
    "fix_date": "2024-09-02T08:36:03Z"
  },
  "references": [
    {
      "url": "https://github.com/quinn-rs/quinn/blob/bb02a12a8435a7732a1d762783eeacbb7e50418e/quinn-proto/src/endpoint.rs#L213",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/quinn-rs/quinn/commit/e01609ccd8738bd438d86fa7185a0f85598cb58f",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/quinn-rs/quinn/security/advisories/GHSA-vr26-jcq5-fjj8",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.422324",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "quinn",
    "owner": "quinn-rs",
    "created_at": "2018-04-03T07:47:41Z",
    "updated_at": "2025-01-14T12:44:28Z",
    "pushed_at": "2025-01-10T21:14:13Z",
    "size": 10300,
    "stars": 3974,
    "forks": 406,
    "open_issues": 115,
    "watchers": 3974,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Rust": 1317739
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:20:26.045879"
  }
}