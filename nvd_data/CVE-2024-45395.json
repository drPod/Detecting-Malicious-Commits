{
  "cve_id": "CVE-2024-45395",
  "github_data": {
    "repository": "sigstore/sigstore-go",
    "fix_commit": "01e70e89e58226286d7977b4dba43b6be472b12c",
    "related_commits": [
      "01e70e89e58226286d7977b4dba43b6be472b12c"
    ],
    "patch_url": "https://github.com/sigstore/sigstore-go/commit/01e70e89e58226286d7977b4dba43b6be472b12c.patch",
    "fix_commit_details": {
      "sha": "01e70e89e58226286d7977b4dba43b6be472b12c",
      "commit_date": "2024-09-04T20:04:37Z",
      "author": {
        "login": "codysoyland",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Add hard limits for number of TSA entries, Tlog entries, and attestation subjects/digests (#286)",
        "length": 676,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 159,
        "additions": 156,
        "deletions": 3
      },
      "files": [
        {
          "filename": "pkg/verify/signature.go",
          "status": "modified",
          "additions": 22,
          "deletions": 0,
          "patch": "@@ -31,6 +31,9 @@ import (\n \t\"github.com/sigstore/sigstore/pkg/signature/options\"\n )\n \n+const maxAllowedSubjects = 1024\n+const maxAllowedSubjectDigests = 32\n+\n var ErrDSSEInvalidSignatureCount = errors.New(\"exactly one signature is required\")\n \n func VerifySignature(sigContent SignatureContent, verificationContent VerificationContent, trustedMaterial root.TrustedMaterial) error { // nolint: revive\n@@ -179,8 +182,17 @@ func verifyEnvelopeWithArtifact(verifier signature.Verifier, envelope EnvelopeCo\n \t}\n \tartifactDigest = hasher.Sum(nil)\n \n+\t// limit the number of subjects to prevent DoS\n+\tif len(statement.Subject) > maxAllowedSubjects {\n+\t\treturn fmt.Errorf(\"too many subjects: %d > %d\", len(statement.Subject), maxAllowedSubjects)\n+\t}\n+\n \t// Look for artifact digest in statement\n \tfor _, subject := range statement.Subject {\n+\t\t// limit the number of digests to prevent DoS\n+\t\tif len(subject.Digest) > maxAllowedSubjectDigests {\n+\t\t\treturn fmt.Errorf(\"too many digests: %d > %d\", len(subject.Digest), maxAllowedSubjectDigests)\n+\t\t}\n \t\tfor alg, digest := range subject.Digest {\n \t\t\thexdigest, err := hex.DecodeString(digest)\n \t\t\tif err != nil {\n@@ -203,7 +215,17 @@ func verifyEnvelopeWithArtifactDigest(verifier signature.Verifier, envelope Enve\n \tif err != nil {\n \t\treturn fmt.Errorf(\"could not verify artifact: unable to extract statement from envelope: %w\", err)\n \t}\n+\n+\t// limit the number of subjects to prevent DoS\n+\tif len(statement.Subject) > maxAllowedSubjects {\n+\t\treturn fmt.Errorf(\"too many subjects: %d > %d\", len(statement.Subject), maxAllowedSubjects)\n+\t}\n+\n \tfor _, subject := range statement.Subject {\n+\t\t// limit the number of digests to prevent DoS\n+\t\tif len(subject.Digest) > maxAllowedSubjectDigests {\n+\t\t\treturn fmt.Errorf(\"too many digests: %d > %d\", len(subject.Digest), maxAllowedSubjectDigests)\n+\t\t}\n \t\tfor alg, digest := range subject.Digest {\n \t\t\tif alg == artifactDigestAlgorithm {\n \t\t\t\thexdigest, err := hex.DecodeString(digest)"
        },
        {
          "filename": "pkg/verify/signature_test.go",
          "status": "modified",
          "additions": 62,
          "deletions": 1,
          "patch": "@@ -18,9 +18,12 @@ import (\n \t\"bytes\"\n \t\"crypto/sha256\"\n \t\"encoding/hex\"\n+\t\"encoding/json\"\n \t\"fmt\"\n \t\"testing\"\n \n+\t\"github.com/in-toto/in-toto-golang/in_toto\"\n+\t\"github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common\"\n \t\"github.com/sigstore/sigstore-go/pkg/testing/ca\"\n \t\"github.com/sigstore/sigstore-go/pkg/verify\"\n \t\"github.com/stretchr/testify/assert\"\n@@ -94,7 +97,7 @@ func TestSignatureVerifierMessageSignature(t *testing.T) {\n \tvirtualSigstore, err := ca.NewVirtualSigstore()\n \tassert.NoError(t, err)\n \n-\tartifact := \"Hi, I am an artifact!\"\n+\tartifact := \"Hi, I am an artifact!\" //nolint:goconst\n \tentity, err := virtualSigstore.Sign(\"foo@example.com\", \"issuer\", []byte(artifact))\n \tassert.NoError(t, err)\n \n@@ -113,3 +116,61 @@ func TestSignatureVerifierMessageSignature(t *testing.T) {\n \tassert.Error(t, err)\n \tassert.Nil(t, result)\n }\n+\n+func TestTooManySubjects(t *testing.T) {\n+\tvirtualSigstore, err := ca.NewVirtualSigstore()\n+\tassert.NoError(t, err)\n+\n+\ttooManySubjectsStatement := in_toto.Statement{}\n+\tfor i := 0; i < 1025; i++ {\n+\t\ttooManySubjectsStatement.Subject = append(tooManySubjectsStatement.Subject, in_toto.Subject{\n+\t\t\tName: fmt.Sprintf(\"subject-%d\", i),\n+\t\t\tDigest: map[string]string{\n+\t\t\t\t\"sha256\": \"\", // actual content of digest does not matter for this test\n+\t\t\t},\n+\t\t})\n+\t}\n+\n+\ttooManySubjectsStatementBytes, err := json.Marshal(tooManySubjectsStatement)\n+\tassert.NoError(t, err)\n+\n+\ttooManySubjectsEntity, err := virtualSigstore.Attest(\"foo@example.com\", \"issuer\", tooManySubjectsStatementBytes)\n+\tassert.NoError(t, err)\n+\n+\tverifier, err := verify.NewSignedEntityVerifier(virtualSigstore, verify.WithTransparencyLog(1), verify.WithObserverTimestamps(1))\n+\tassert.NoError(t, err)\n+\n+\tartifact := \"Hi, I am an artifact!\" //nolint:goconst\n+\t_, err = verifier.Verify(tooManySubjectsEntity, verify.NewPolicy(verify.WithArtifact(bytes.NewBufferString(artifact)), verify.WithoutIdentitiesUnsafe()))\n+\tassert.ErrorContains(t, err, \"too many subjects\")\n+}\n+\n+func TestTooManyDigests(t *testing.T) {\n+\tvirtualSigstore, err := ca.NewVirtualSigstore()\n+\tassert.NoError(t, err)\n+\n+\ttooManyDigestsStatement := in_toto.Statement{}\n+\ttooManyDigestsStatement.Subject = []in_toto.Subject{\n+\t\t{\n+\t\t\tName:   fmt.Sprintf(\"subject\"),\n+\t\t\tDigest: make(common.DigestSet),\n+\t\t},\n+\t}\n+\ttooManyDigestsStatement.Subject[0].Digest[\"sha512\"] = \"\" // verifier requires that at least one known hash algorithm is present in the digest map\n+\tfor i := 0; i < 32; i++ {\n+\t\ttooManyDigestsStatement.Subject[0].Digest[fmt.Sprintf(\"digest-%d\", i)] = \"\"\n+\t}\n+\n+\ttooManySubjectsStatementBytes, err := json.Marshal(tooManyDigestsStatement)\n+\tassert.NoError(t, err)\n+\n+\ttooManySubjectsEntity, err := virtualSigstore.Attest(\"foo@example.com\", \"issuer\", tooManySubjectsStatementBytes)\n+\tassert.NoError(t, err)\n+\n+\tverifier, err := verify.NewSignedEntityVerifier(virtualSigstore, verify.WithTransparencyLog(1), verify.WithObserverTimestamps(1))\n+\tassert.NoError(t, err)\n+\n+\tartifact := \"Hi, I am an artifact!\" //nolint:goconst\n+\t_, err = verifier.Verify(tooManySubjectsEntity, verify.NewPolicy(verify.WithArtifact(bytes.NewBufferString(artifact)), verify.WithoutIdentitiesUnsafe()))\n+\tassert.ErrorContains(t, err, \"too many digests\")\n+}"
        },
        {
          "filename": "pkg/verify/tlog.go",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -34,6 +34,8 @@ import (\n \t\"github.com/sigstore/sigstore-go/pkg/util\"\n )\n \n+const maxAllowedTlogEntries = 32\n+\n // VerifyArtifactTransparencyLog verifies that the given entity has been logged\n // in the transparency log and that the log entry is valid.\n //\n@@ -47,6 +49,11 @@ func VerifyArtifactTransparencyLog(entity SignedEntity, trustedMaterial root.Tru\n \t\treturn nil, err\n \t}\n \n+\t// limit the number of tlog entries to prevent DoS\n+\tif len(entries) > maxAllowedTlogEntries {\n+\t\treturn nil, fmt.Errorf(\"too many tlog entries: %d > %d\", len(entries), maxAllowedTlogEntries)\n+\t}\n+\n \t// disallow duplicate entries, as a malicious actor could use duplicates to bypass the threshold\n \tfor i := 0; i < len(entries); i++ {\n \t\tfor j := i + 1; j < len(entries); j++ {"
        },
        {
          "filename": "pkg/verify/tlog_test.go",
          "status": "modified",
          "additions": 29,
          "deletions": 1,
          "patch": "@@ -191,5 +191,33 @@ func TestDuplicateTlogEntries(t *testing.T) {\n \tassert.NoError(t, err)\n \n \t_, err = verify.VerifyArtifactTransparencyLog(&dupTlogEntity{entity}, virtualSigstore, 1, true, false)\n-\tassert.Error(t, err) // duplicate tlog entries should fail to verify\n+\tassert.ErrorContains(t, err, \"duplicate tlog entries found\") // duplicate tlog entries should fail to verify\n+}\n+\n+type tooManyTlogEntriesEntity struct {\n+\t*ca.TestEntity\n+}\n+\n+func (e *tooManyTlogEntriesEntity) TlogEntries() ([]*tlog.Entry, error) {\n+\tentries, err := e.TestEntity.TlogEntries()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor i := 0; i < 32; i++ {\n+\t\tentries = append(entries, entries[0])\n+\t}\n+\n+\treturn entries, nil\n+}\n+\n+func TestMaxAllowedTlogEntries(t *testing.T) {\n+\tvirtualSigstore, err := ca.NewVirtualSigstore()\n+\tassert.NoError(t, err)\n+\n+\tstatement := []byte(`{\"_type\":\"https://in-toto.io/Statement/v0.1\",\"predicateType\":\"customFoo\",\"subject\":[{\"name\":\"subject\",\"digest\":{\"sha256\":\"deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\"}}],\"predicate\":{}}`)\n+\tentity, err := virtualSigstore.Attest(\"foo@example.com\", \"issuer\", statement)\n+\tassert.NoError(t, err)\n+\n+\t_, err = verify.VerifyArtifactTransparencyLog(&tooManyTlogEntriesEntity{entity}, virtualSigstore, 1, true, false)\n+\tassert.ErrorContains(t, err, \"too many tlog entries\") // too many tlog entries should fail to verify\n }"
        },
        {
          "filename": "pkg/verify/tsa.go",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -26,6 +26,8 @@ import (\n \t\"github.com/sigstore/sigstore-go/pkg/root\"\n )\n \n+const maxAllowedTimestamps = 32\n+\n // VerifyTimestampAuthority verifies that the given entity has been timestamped\n // by a trusted timestamp authority and that the timestamp is valid.\n func VerifyTimestampAuthority(entity SignedEntity, trustedMaterial root.TrustedMaterial) ([]time.Time, error) { //nolint:revive\n@@ -34,6 +36,11 @@ func VerifyTimestampAuthority(entity SignedEntity, trustedMaterial root.TrustedM\n \t\treturn nil, err\n \t}\n \n+\t// limit the number of timestamps to prevent DoS\n+\tif len(signedTimestamps) > maxAllowedTimestamps {\n+\t\treturn nil, fmt.Errorf(\"too many signed timestamps: %d > %d\", len(signedTimestamps), maxAllowedTimestamps)\n+\t}\n+\n \t// disallow duplicate timestamps, as a malicious actor could use duplicates to bypass the threshold\n \tfor i := 0; i < len(signedTimestamps); i++ {\n \t\tfor j := i + 1; j < len(signedTimestamps); j++ {"
        },
        {
          "filename": "pkg/verify/tsa_test.go",
          "status": "modified",
          "additions": 29,
          "deletions": 1,
          "patch": "@@ -113,7 +113,7 @@ func TestDuplicateTimestamps(t *testing.T) {\n \tassert.NoError(t, err)\n \n \t_, err = verify.VerifyTimestampAuthorityWithThreshold(&dupTimestampEntity{entity}, virtualSigstore, 1)\n-\tassert.Error(t, err) // duplicate timestamps should fail to verify\n+\tassert.ErrorContains(t, err, \"duplicate timestamps found\")\n }\n \n type badTSASignatureEntity struct {\n@@ -223,3 +223,31 @@ func TestBadTSACertificateChainOutsideValidityPeriod(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+type tooManyTimestampsEntity struct {\n+\t*ca.TestEntity\n+}\n+\n+func (e *tooManyTimestampsEntity) Timestamps() ([][]byte, error) {\n+\ttimestamps, err := e.TestEntity.Timestamps()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfor i := 0; i < 32; i++ {\n+\t\ttimestamps = append(timestamps, timestamps[0])\n+\t}\n+\n+\treturn timestamps, nil\n+}\n+\n+func TestTooManyTimestamps(t *testing.T) {\n+\tvirtualSigstore, err := ca.NewVirtualSigstore()\n+\tassert.NoError(t, err)\n+\n+\tentity, err := virtualSigstore.Attest(\"foo@example.com\", \"issuer\", []byte(\"statement\"))\n+\tassert.NoError(t, err)\n+\n+\t_, err = verify.VerifyTimestampAuthorityWithThreshold(&tooManyTimestampsEntity{entity}, virtualSigstore, 1)\n+\tassert.ErrorContains(t, err, \"too many signed timestamps\")\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 1,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "5855f01897d5a81d9b61c7c46d3e6dc978fb71e5",
            "date": "2025-01-13T21:06:33Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "8738a0576a60ac5a2f259371e01243be6ce6a7ca",
            "date": "2025-01-13T20:46:06Z",
            "author_login": "codysoyland"
          },
          {
            "sha": "dfd3d70942f9b33556ea0e6d8e27b4c8b738f3e4",
            "date": "2025-01-13T19:08:47Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "a11ad6899cb84d9aaebc4da21ce751d8c6490ad2",
            "date": "2025-01-13T18:51:00Z",
            "author_login": "haydentherapper"
          },
          {
            "sha": "f62d7f4cbf3455cedbbf3f63a46db87825003f8a",
            "date": "2025-01-10T08:20:27Z",
            "author_login": "haydentherapper"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:N/A:L",
    "cwe_id": "CWE-835",
    "description": "sigstore-go, a Go library for Sigstore signing and verification, is susceptible to a denial of service attack in versions prior to 0.6.1 when a verifier is provided a maliciously crafted Sigstore Bundle containing large amounts of verifiable data, in the form of signed transparency log entries, RFC 3161 timestamps, and attestation subjects. The verification of these data structures is computationally expensive. This can be used to consume excessive CPU resources, leading to a denial of service attack. TUF's security model labels this type of vulnerability an \"Endless data attack,\" and can lead to verification failing to complete and disrupting services that rely on sigstore-go for verification. This vulnerability is addressed with sigstore-go 0.6.1, which adds hard limits to the number of verifiable data structures that can be processed in a bundle. Verification will fail if a bundle has data that exceeds these limits. The limits are 32 signed transparency log entries, 32 RFC 3161 timestamps, 1024 attestation subjects, and 32 digests per attestation subject. These limits are intended to be high enough to accommodate the vast majority of use cases, while preventing the verification of maliciously crafted bundles that contain large amounts of verifiable data. Users who are vulnerable but unable to quickly upgrade may consider adding manual bundle validation to enforce limits similar to those in the referenced patch prior to calling sigstore-go's verification functions.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-09-04T21:15:14.237",
    "last_modified": "2024-09-24T16:50:07.930",
    "fix_date": "2024-09-04T20:04:37Z"
  },
  "references": [
    {
      "url": "https://github.com/sigstore/sigstore-go/blob/725e508ed4933e6f5b5206e32af4bbe76f587b54/pkg/verify/signature.go#L183-L193",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/sigstore/sigstore-go/blob/725e508ed4933e6f5b5206e32af4bbe76f587b54/pkg/verify/tlog.go#L74-L178",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/sigstore/sigstore-go/blob/725e508ed4933e6f5b5206e32af4bbe76f587b54/pkg/verify/tsa.go#L59-L68",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/sigstore/sigstore-go/commit/01e70e89e58226286d7977b4dba43b6be472b12c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/sigstore/sigstore-go/security/advisories/GHSA-cq38-jh5f-37mq",
      "source": "security-advisories@github.com",
      "tags": [
        "Mitigation",
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.465606",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "sigstore-go",
    "owner": "sigstore",
    "created_at": "2023-09-22T19:14:58Z",
    "updated_at": "2025-01-13T21:06:38Z",
    "pushed_at": "2025-01-13T21:06:35Z",
    "size": 1036,
    "stars": 53,
    "forks": 27,
    "open_issues": 23,
    "watchers": 53,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 380981,
      "Shell": 2476,
      "Makefile": 1056
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T19:25:27.089513"
  }
}