{
  "cve_id": "CVE-2024-45396",
  "github_data": {
    "repository": "h2o/quicly",
    "fix_commit": "2a95896104901589c495bc41460262e64ffcad5c",
    "related_commits": [
      "2a95896104901589c495bc41460262e64ffcad5c"
    ],
    "patch_url": "https://github.com/h2o/quicly/commit/2a95896104901589c495bc41460262e64ffcad5c.patch",
    "fix_commit_details": {
      "sha": "2a95896104901589c495bc41460262e64ffcad5c",
      "commit_date": "2024-10-11T02:33:58Z",
      "author": {
        "login": "kazuho",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 46,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 32,
        "additions": 21,
        "deletions": 11
      },
      "files": [
        {
          "filename": "lib/quicly.c",
          "status": "modified",
          "additions": 21,
          "deletions": 11,
          "patch": "@@ -1919,6 +1919,9 @@ static int promote_path(quicly_conn_t *conn, size_t path_index)\n \n     do_delete_path(conn, path);\n \n+    /* rearm the loss timer, now that the RTT estimate has been changed */\n+    setup_next_send(conn);\n+\n     return 0;\n }\n \n@@ -5194,7 +5197,7 @@ static int send_other_control_frames(quicly_conn_t *conn, quicly_send_context_t\n \n static int do_send(quicly_conn_t *conn, quicly_send_context_t *s)\n {\n-    int restrict_sending = 0, ack_only = 0, ret;\n+    int restrict_sending = 0, ack_only = 0, ret = 0;\n     size_t min_packets_to_send = 0, orig_bytes_inflight = 0;\n \n     /* handle timeouts */\n@@ -5283,11 +5286,13 @@ static int do_send(quicly_conn_t *conn, quicly_send_context_t *s)\n      *  * quicly running as a client sends either a Handshake probe (or data) if the handshake keys are available, or else an\n      *    Initial probe (or data).\n      *  * quicly running as a server sends both Initial and Handshake probes (or data) if the corresponding keys are available. */\n-    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_INITIAL, s, ack_only,\n-                                   min_packets_to_send != 0 && (!quicly_is_client(conn) || conn->handshake == NULL))) != 0)\n-        goto Exit;\n-    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_HANDSHAKE, s, ack_only, min_packets_to_send != 0)) != 0)\n-        goto Exit;\n+    if (s->path_index == 0) {\n+        if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_INITIAL, s, ack_only,\n+                                       min_packets_to_send != 0 && (!quicly_is_client(conn) || conn->handshake == NULL))) != 0)\n+            goto Exit;\n+        if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_HANDSHAKE, s, ack_only, min_packets_to_send != 0)) != 0)\n+            goto Exit;\n+    }\n \n     /* setup 0-RTT or 1-RTT send context (as the availability of the two epochs are mutually exclusive, we can try 1-RTT first as an\n      * optimization), then send application data if that succeeds */\n@@ -5447,7 +5452,7 @@ static int do_send(quicly_conn_t *conn, quicly_send_context_t *s)\n         if (conn->application == NULL || conn->application->super.unacked_count == 0)\n             conn->egress.send_ack_at = INT64_MAX; /* we have sent ACKs for every epoch (or before address validation) */\n         int can_send_stream_data = scheduler_can_send(conn);\n-        update_send_alarm(conn, can_send_stream_data, 1);\n+        update_send_alarm(conn, can_send_stream_data, s->path_index == 0);\n         update_ratemeter(conn, can_send_stream_data && conn->super.remote.address_validation.validated &&\n                                    (s->num_datagrams == s->max_datagrams ||\n                                     conn->egress.loss.sentmap.bytes_in_flight >= conn->egress.cc.cwnd ||\n@@ -5570,6 +5575,7 @@ int quicly_send(quicly_conn_t *conn, quicly_address_t *dest, quicly_address_t *s\n             }\n             if ((ret = do_send(conn, &s)) != 0)\n                 goto Exit;\n+            assert(conn->stash.now < conn->paths[s.path_index]->path_challenge.send_at);\n             if (s.num_datagrams != 0)\n                 break;\n         }\n@@ -5583,7 +5589,7 @@ int quicly_send(quicly_conn_t *conn, quicly_address_t *dest, quicly_address_t *s\n         ret = 0;\n     }\n \n-    assert_consistency(conn, 1);\n+    assert_consistency(conn, s.path_index == 0);\n \n Exit:\n     if (s.path_index == 0)\n@@ -6934,7 +6940,9 @@ int quicly_accept(quicly_conn_t **conn, quicly_context_t *ctx, struct sockaddr *\n Exit:\n     if (*conn != NULL) {\n         if (ret == 0) {\n-            (*conn)->super.state = QUICLY_STATE_CONNECTED;\n+            /* if CONNECTION_CLOSE was found and the state advanced to DRAINING, we need to retain that state */\n+            if ((*conn)->super.state < QUICLY_STATE_CONNECTED)\n+                (*conn)->super.state = QUICLY_STATE_CONNECTED;\n         } else {\n             initiate_close(*conn, ret, offending_frame_type, \"\");\n             ret = 0;\n@@ -6999,8 +7007,10 @@ int quicly_receive(quicly_conn_t *conn, struct sockaddr *dest_addr, struct socka\n         if (conn->paths[path_index] != NULL && compare_socket_address(src_addr, &conn->paths[path_index]->address.remote.sa) == 0)\n             break;\n     if (path_index == PTLS_ELEMENTSOF(conn->paths) &&\n-        conn->super.stats.num_paths.validation_failed >= conn->super.ctx->max_path_validation_failures)\n-        return QUICLY_ERROR_PACKET_IGNORED;\n+        conn->super.stats.num_paths.validation_failed >= conn->super.ctx->max_path_validation_failures) {\n+        ret = QUICLY_ERROR_PACKET_IGNORED;\n+        goto Exit;\n+    }\n \n     /* add unconditionally, as packet->datagram_size is set only for the first packet within the UDP datagram */\n     conn->super.stats.num_bytes.received += packet->datagram_size;"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fc5beb18d3e1c941eb2c73c178cc40e06af88566",
            "date": "2025-01-12T07:22:00Z",
            "author_login": "kazuho"
          },
          {
            "sha": "898c5d6d026fb46fe313ce5ae9aa9c9dba9b8c3c",
            "date": "2025-01-12T06:06:20Z",
            "author_login": "kazuho"
          },
          {
            "sha": "881c612909cb8dafac2cdc439a978f16a35759bf",
            "date": "2025-01-12T06:04:23Z",
            "author_login": "kazuho"
          },
          {
            "sha": "19231585ac25b9438b7d444a05f2da6f5eb93517",
            "date": "2025-01-12T05:00:40Z",
            "author_login": "kazuho"
          },
          {
            "sha": "1d7e5329e12a1a26479666b118a739f9f6ac3db1",
            "date": "2025-01-12T04:35:06Z",
            "author_login": "kazuho"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-617",
    "description": "Quicly is an IETF QUIC protocol implementation. Quicly up to commtit d720707 is susceptible to a denial-of-service attack. A remote attacker can exploit these bugs to trigger an assertion failure that crashes process using quicly. The vulnerability is addressed with commit 2a95896104901589c495bc41460262e64ffcad5c.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-11T15:15:04.457",
    "last_modified": "2024-11-12T20:05:09.367",
    "fix_date": "2024-10-11T02:33:58Z"
  },
  "references": [
    {
      "url": "https://github.com/h2o/quicly/commit/2a95896104901589c495bc41460262e64ffcad5c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/h2o/quicly/security/advisories/GHSA-mp3c-h5gg-mm6p",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.132778",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "quicly",
    "owner": "h2o",
    "created_at": "2017-06-06T14:27:42Z",
    "updated_at": "2025-01-12T07:22:06Z",
    "pushed_at": "2025-01-14T19:57:32Z",
    "size": 5311,
    "stars": 624,
    "forks": 117,
    "open_issues": 97,
    "watchers": 624,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 951133,
      "Perl": 33695,
      "Python": 21732,
      "DTrace": 12082,
      "CMake": 6610,
      "C++": 4896,
      "Shell": 3617,
      "Makefile": 641,
      "Dockerfile": 572
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T21:41:35.484376"
  }
}