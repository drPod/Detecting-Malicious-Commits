{
  "cve_id": "CVE-2024-45402",
  "github_data": {
    "repository": "h2o/picotls",
    "fix_commit": "9b88159ce763d680e4a13b6e8f3171ae923a535d",
    "related_commits": [
      "9b88159ce763d680e4a13b6e8f3171ae923a535d"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "9b88159ce763d680e4a13b6e8f3171ae923a535d",
      "commit_date": "2024-10-11T02:28:15Z",
      "author": {
        "login": "kazuho",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 101,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 33,
        "additions": 25,
        "deletions": 8
      },
      "files": [
        {
          "filename": "include/picotls.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -348,6 +348,7 @@ typedef struct st_ptls_key_exchange_context_t {\n      * When `secret` is non-NULL, this callback derives the shared secret using the private key of the context and the peer key being\n      * given, and sets the value in `secret`. The memory pointed to by `secret->base` must be freed by the caller by calling `free`.\n      * When `release` is set, the callee frees resources allocated to the context and set *keyex to NULL.\n+     * Upon failure (i.e., when an PTLS error code is returned), `*pubkey` and `*secret` either remain unchanged or are zero-cleared.\n      */\n     int (*on_exchange)(struct st_ptls_key_exchange_context_t **keyex, int release, ptls_iovec_t *secret, ptls_iovec_t peerkey);\n } ptls_key_exchange_context_t;\n@@ -369,6 +370,7 @@ typedef const struct st_ptls_key_exchange_algorithm_t {\n      * Implements synchronous key exchange. Called when ServerHello is generated.\n      * Given a public key provided by the peer (`peerkey`), this callback generates an ephemeral private and public key, and returns\n      * the public key (`pubkey`) and a secret (`secret`) derived from the peerkey and private key.\n+     * Upon failure (i.e., when an PTLS error code is returned), `*pubkey` and `*secret` either remain unchanged or are zero-cleared.\n      */\n     int (*exchange)(const struct st_ptls_key_exchange_algorithm_t *algo, ptls_iovec_t *pubkey, ptls_iovec_t *secret,\n                     ptls_iovec_t peerkey);"
        },
        {
          "filename": "lib/cifra/x25519.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -49,6 +49,7 @@ static int x25519_derive_secret(ptls_iovec_t *secret, const uint8_t *clientpriv,\n     static const uint8_t zeros[X25519_KEY_SIZE] = {0};\n     if (ptls_mem_equal(secret->base, zeros, sizeof(zeros))) {\n         free(secret->base);\n+        secret->base = NULL;\n         return PTLS_ERROR_INCOMPATIBLE_KEY;\n     }\n "
        },
        {
          "filename": "lib/hpke.c",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -129,8 +129,11 @@ static int dh_encap(ptls_hpke_kem_t *kem, void *secret, ptls_iovec_t *pk_s, ptls\n \n     *pk_s = ptls_iovec_init(NULL, 0);\n \n-    if ((ret = kem->keyex->exchange(kem->keyex, pk_s, &dh, pk_r)) != 0)\n+    if ((ret = kem->keyex->exchange(kem->keyex, pk_s, &dh, pk_r)) != 0) {\n+        assert(pk_s->base == NULL);\n+        assert(dh.base == NULL);\n         goto Exit;\n+    }\n \n     if ((ret = dh_derive(kem, secret, *pk_s, pk_r, dh)) != 0)\n         goto Exit;\n@@ -152,8 +155,10 @@ static int dh_decap(ptls_hpke_kem_t *kem, void *secret, ptls_key_exchange_contex\n     ptls_iovec_t dh = {NULL};\n     int ret;\n \n-    if ((ret = keyex->on_exchange(&keyex, 0, &dh, pk_s)) != 0)\n+    if ((ret = keyex->on_exchange(&keyex, 0, &dh, pk_s)) != 0) {\n+        assert(dh.base == NULL);\n         goto Exit;\n+    }\n \n     if ((ret = dh_derive(kem, secret, pk_s, pk_r, dh)) != 0)\n         goto Exit;"
        },
        {
          "filename": "lib/openssl.c",
          "status": "modified",
          "additions": 8,
          "deletions": 4,
          "patch": "@@ -516,7 +516,7 @@ static int evp_keyex_on_exchange(ptls_key_exchange_context_t **_ctx, int release\n         goto Exit;\n     }\n \n-    secret->base = NULL;\n+    *secret = ptls_iovec_init(NULL, 0);\n \n     if (peerkey.len != ctx->super.pubkey.len) {\n         ret = PTLS_ALERT_DECRYPT_ERROR;\n@@ -598,8 +598,10 @@ static int evp_keyex_on_exchange(ptls_key_exchange_context_t **_ctx, int release\n         EVP_PKEY_CTX_free(evpctx);\n     if (evppeer != NULL)\n         EVP_PKEY_free(evppeer);\n-    if (ret != 0)\n+    if (ret != 0) {\n         free(secret->base);\n+        *secret = ptls_iovec_init(NULL, 0);\n+    }\n     if (release) {\n         evp_keyex_free(ctx);\n         *_ctx = NULL;\n@@ -679,7 +681,7 @@ static int evp_keyex_exchange(ptls_key_exchange_algorithm_t *algo, ptls_iovec_t\n     ptls_key_exchange_context_t *ctx = NULL;\n     int ret;\n \n-    outpubkey->base = NULL;\n+    *outpubkey = ptls_iovec_init(NULL, 0);\n \n     if ((ret = evp_keyex_create(algo, &ctx)) != 0)\n         goto Exit;\n@@ -695,8 +697,10 @@ static int evp_keyex_exchange(ptls_key_exchange_algorithm_t *algo, ptls_iovec_t\n Exit:\n     if (ctx != NULL)\n         evp_keyex_on_exchange(&ctx, 1, NULL, ptls_iovec_init(NULL, 0));\n-    if (ret != 0)\n+    if (ret != 0) {\n         free(outpubkey->base);\n+        *outpubkey = ptls_iovec_init(NULL, 0);\n+    }\n     return ret;\n }\n "
        },
        {
          "filename": "lib/picotls.c",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -2848,8 +2848,10 @@ static int client_handle_hello(ptls_t *tls, ptls_message_emitter_t *emitter, ptl\n     ptls__key_schedule_update_hash(tls->key_schedule, message.base, message.len, 0);\n \n     if (sh.peerkey.base != NULL) {\n-        if ((ret = tls->client.key_share_ctx->on_exchange(&tls->client.key_share_ctx, 1, &ecdh_secret, sh.peerkey)) != 0)\n+        if ((ret = tls->client.key_share_ctx->on_exchange(&tls->client.key_share_ctx, 1, &ecdh_secret, sh.peerkey)) != 0) {\n+            assert(ecdh_secret.base == NULL);\n             goto Exit;\n+        }\n     }\n \n     if ((ret = key_schedule_extract(tls->key_schedule, ecdh_secret)) != 0)\n@@ -4677,8 +4679,11 @@ static int server_handle_hello(ptls_t *tls, ptls_message_emitter_t *emitter, ptl\n             ret = ch->key_shares.base != NULL ? PTLS_ALERT_HANDSHAKE_FAILURE : PTLS_ALERT_MISSING_EXTENSION;\n             goto Exit;\n         }\n-        if ((ret = key_share.algorithm->exchange(key_share.algorithm, &pubkey, &ecdh_secret, key_share.peer_key)) != 0)\n+        if ((ret = key_share.algorithm->exchange(key_share.algorithm, &pubkey, &ecdh_secret, key_share.peer_key)) != 0) {\n+            assert(pubkey.base == NULL);\n+            assert(ecdh_secret.base == NULL);\n             goto Exit;\n+        }\n         tls->key_share = key_share.algorithm;\n     }\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bbcdbe6dc31ec5d4b72a7beece4daf58098bad42",
            "date": "2024-12-22T08:11:19Z",
            "author_login": "kazuho"
          },
          {
            "sha": "9a8c4ebe76f345cc3989688aaa0d113de25d20f4",
            "date": "2024-12-22T06:14:13Z",
            "author_login": "kazuho"
          },
          {
            "sha": "14e191c13df61f08db91107dfcdd84b8aab043d6",
            "date": "2024-12-21T04:51:19Z",
            "author_login": "kazuho"
          },
          {
            "sha": "1c8550e19a409eab1436da3a01aa6e677debcd6d",
            "date": "2024-12-21T04:32:54Z",
            "author_login": "sleepybishop"
          },
          {
            "sha": "4ab6fda556e21ef9ab7a51e48347b0289d5d5888",
            "date": "2024-12-20T04:14:29Z",
            "author_login": "kazuho"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H",
    "cwe_id": "CWE-415",
    "description": "Picotls is a TLS protocol library that allows users select different crypto backends based on their use case. When parsing a spoofed TLS handshake message, picotls (specifically, bindings within picotls that call the crypto libraries) may attempt to free the same memory twice. This double free occurs during the disposal of multiple objects without any intervening calls to malloc Typically, this triggers the malloc implementation to detect the error and abort the process. However, depending on the internals of malloc and the crypto backend being used, the flaw could potentially lead to a use-after-free scenario, which might allow for arbitrary code execution. The vulnerability is addressed with commit 9b88159ce763d680e4a13b6e8f3171ae923a535d.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-11T15:15:04.903",
    "last_modified": "2024-11-12T20:02:56.167",
    "fix_date": "2024-10-11T02:28:15Z"
  },
  "references": [
    {
      "url": "https://github.com/h2o/picotls/commit/9b88159ce763d680e4a13b6e8f3171ae923a535d",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/h2o/picotls/security/advisories/GHSA-w7c8-wjx9-vvvv",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.133080",
    "processing_status": "enhanced"
  }
}