{
  "cve_id": "CVE-2024-47175",
  "github_data": {
    "repository": "OpenPrinting/libppd",
    "fix_commit": "d681747ebf12602cb426725eb8ce2753211e2477",
    "related_commits": [
      "d681747ebf12602cb426725eb8ce2753211e2477"
    ],
    "patch_url": "https://github.com/OpenPrinting/libppd/commit/d681747ebf12602cb426725eb8ce2753211e2477.patch",
    "fix_commit_details": {
      "sha": "d681747ebf12602cb426725eb8ce2753211e2477",
      "commit_date": "2024-09-26T21:12:14Z",
      "author": {
        "login": "zdohnal",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Prevent PPD generation based on invalid IPP response",
        "length": 121,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 274,
        "additions": 176,
        "deletions": 98
      },
      "files": [
        {
          "filename": "ppd/ppd-cache.c",
          "status": "modified",
          "additions": 12,
          "deletions": 5,
          "patch": "@@ -1,6 +1,7 @@\n //\n // PPD cache implementation for libppd.\n //\n+// Copyright \u00a9 2024 by OpenPrinting\n // Copyright \u00a9\u00a02010-2019 by Apple Inc.\n //\n // Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n@@ -3434,7 +3435,7 @@ ppdCacheGetBin(\n \n   //\n   // Range check input...\n- \n+\n \n   if (!pc || !output_bin)\n     return (NULL);\n@@ -3935,7 +3936,7 @@ ppdCacheGetPageSize(\n       {\n \t//\n \t// Check not only the base size (like \"A4\") but also variants (like\n-        // \"A4.Borderless\"). We check only the margins and orientation but do \n+        // \"A4.Borderless\"). We check only the margins and orientation but do\n \t// not re-check the size.\n \t//\n \n@@ -4776,7 +4777,7 @@ ppdPwgPpdizeName(const char *ipp,\t// I - IPP keyword\n \t*end;\t\t\t\t// End of name buffer\n \n \n-  if (!ipp)\n+  if (!ipp || !_ppd_isalnum(*ipp))\n   {\n     *name = '\\0';\n     return;\n@@ -4786,13 +4787,19 @@ ppdPwgPpdizeName(const char *ipp,\t// I - IPP keyword\n \n   for (ptr = name + 1, end = name + namesize - 1; *ipp && ptr < end;)\n   {\n-    if (*ipp == '-' && _ppd_isalnum(ipp[1]))\n+    if (*ipp == '-' && isalnum(ipp[1]))\n     {\n       ipp ++;\n       *ptr++ = (char)toupper(*ipp++ & 255);\n     }\n-    else\n+    else if (*ipp == '_' || *ipp == '.' || *ipp == '-' || isalnum(*ipp))\n+    {\n       *ptr++ = *ipp++;\n+    }\n+    else\n+    {\n+      ipp ++;\n+    }\n   }\n \n   *ptr = '\\0';"
        },
        {
          "filename": "ppd/ppd-generator.c",
          "status": "modified",
          "additions": 164,
          "deletions": 93,
          "patch": "@@ -1,15 +1,16 @@\n //\n //   PWG Raster/Apple Raster/PCLm/PDF/IPP legacy PPD generator for libppd.\n //\n-//   Copyright 2016-2019 by Till Kamppeter.\n-//   Copyright 2017-2019 by Sahil Arora.\n-//   Copyright 2018-2019 by Deepak Patankar.\n+//   Copyright \u00a9 2024 by OpenPrinting\n+//   Copyright \u00a9\u00a02016-2019 by Till Kamppeter.\n+//   Copyright \u00a9\u00a02017-2019 by Sahil Arora.\n+//   Copyright \u00a9\u00a02018-2019 by Deepak Patankar.\n //\n //   The PPD generator is based on the PPD generator for the CUPS\n //   \"lpadmin -m everywhere\" functionality in the cups/ppd-cache.c\n //   file. The copyright of this file is:\n //\n-//   Copyright 2010-2016 by Apple Inc.\n+//   Copyright \u00a9\u00a02010-2016 by Apple Inc.\n //\n //   Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n //   information.\n@@ -71,6 +72,7 @@ typedef struct _ppd_size_s                // **** Media Size (cups_size_t of lib\n \n static int\thttp_connect(http_t **http, const char *url, char *resource,\n \t\t\t     size_t ressize);\n+static void\tppd_put_string(cups_file_t *fp, cups_lang_t *lang, const char *ppd_option, const char *ppd_choice, const char *pwg_msgid);\n \n \n //\n@@ -80,7 +82,7 @@ static int\thttp_connect(http_t **http, const char *url, char *resource,\n // than CUPS 2.2.x. We have also an additional test and development\n // platform for this code. Taken from cups/ppd-cache.c,\n // cups/string-private.h, cups/string.c.\n-// \n+//\n // The advantage of PPD generation instead of working with System V\n // interface scripts is that the print dialogs of the clients do not\n // need to ask the printer for its options via IPP. So we have access\n@@ -144,7 +146,7 @@ char ppdgenerator_msg[1024];\n //                           IPP 1.x legacy)\n //\n \n-char *                                             // O - PPD filename or NULL \n+char *                                             // O - PPD filename or NULL\n                                                    //     on error\n ppdCreatePPDFromIPP(char         *buffer,          // I - Filename buffer\n \t\t    size_t       bufsize,          // I - Size of filename\n@@ -195,7 +197,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t\t     cups_array_t *conflicts,       // I - Array of\n \t\t\t\t\t\t    //     constraints\n \t\t     cups_array_t *sizes,           // I - Media sizes we've\n-\t\t\t\t\t\t    //     added \n+\t\t\t\t\t\t    //     added\n \t\t     char*        default_pagesize, // I - Default page size\n \t\t     const char   *default_cluster_color, // I - cluster def\n \t\t\t\t\t\t    //     color (if cluster's\n@@ -207,6 +209,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t\t     size_t       status_msg_size)  // I - Size of status\n \t\t\t\t\t\t    //     message buffer\n {\n+  cups_lang_t\t\t*lang;\t\t// Localization language\n   cups_file_t\t\t*fp;\t\t// PPD file\n   cups_array_t\t\t*printer_sizes;\t// Media sizes we've added\n   _ppd_size_t\t\t*size;\t\t// Current media size\n@@ -219,9 +222,10 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n   ipp_t\t\t\t*media_col,\t// Media collection\n \t\t\t*media_size;\t// Media size collection\n   char\t\t\tmake[256],\t// Make and model\n-\t\t\t*model,\t\t// Model name\n+\t\t\t*mptr,\t\t// Pointer into make and model\n \t\t\tppdname[PPD_MAX_NAME];\n \t\t    \t\t\t// PPD keyword\n+  const char\t\t*model;\t\t// Model name\n   int\t\t\ti, j,\t\t// Looping vars\n \t\t\tcount = 0,\t// Number of values\n \t\t\tbottom,\t\t// Largest bottom margin\n@@ -303,6 +307,68 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n     return (NULL);\n   }\n \n+  //\n+  // Get a sanitized make and model...\n+  //\n+\n+  if ((attr = ippFindAttribute(supported, \"printer-make-and-model\", IPP_TAG_TEXT)) != NULL && ippValidateAttribute(attr))\n+  {\n+    // Sanitize the model name to only contain PPD-safe characters.\n+    strlcpy(make, ippGetString(attr, 0, NULL), sizeof(make));\n+\n+    for (mptr = make; *mptr; mptr ++)\n+    {\n+      if (*mptr < ' ' || *mptr >= 127 || *mptr == '\\\"')\n+      {\n+        // Truncate the make and model on the first bad character...\n+\t*mptr = '\\0';\n+\tbreak;\n+      }\n+    }\n+\n+    while (mptr > make)\n+    {\n+      // Strip trailing whitespace...\n+      mptr --;\n+      if (*mptr == ' ')\n+\t*mptr = '\\0';\n+    }\n+\n+    if (!make[0])\n+    {\n+      // Use a default make and model if nothing remains...\n+      strlcpy(make, \"Unknown\", sizeof(make));\n+    }\n+  }\n+  else\n+  {\n+    // Use a default make and model...\n+    strlcpy(make, \"Unknown\", sizeof(make));\n+  }\n+\n+  if (!strncasecmp(make, \"Hewlett Packard \", 16) || !strncasecmp(make, \"Hewlett-Packard \", 16))\n+  {\n+    // Normalize HP printer make and model...\n+    model = make + 16;\n+    strlcpy(make, \"HP\", sizeof(make));\n+\n+    if (!strncasecmp(model, \"HP \", 3))\n+      model += 3;\n+  }\n+  else if ((mptr = strchr(make, ' ')) != NULL)\n+  {\n+    // Separate \"MAKE MODEL\"...\n+    while (*mptr && *mptr == ' ')\n+      *mptr++ = '\\0';\n+\n+    model = mptr;\n+  }\n+  else\n+  {\n+    // No separate model name...\n+    model = \"Printer\";\n+  }\n+\n   //\n   // Standard stuff for PPD file...\n   //\n@@ -331,25 +397,6 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n     }\n   }\n \n-  if ((attr = ippFindAttribute(supported, \"printer-make-and-model\",\n-\t\t\t       IPP_TAG_TEXT)) != NULL)\n-    strlcpy(make, ippGetString(attr, 0, NULL), sizeof(make));\n-  else if (make_model && make_model[0] != '\\0')\n-    strlcpy(make, make_model, sizeof(make));\n-  else\n-    strlcpy(make, \"Unknown Printer\", sizeof(make));\n-\n-  if (!strncasecmp(make, \"Hewlett Packard \", 16) ||\n-      !strncasecmp(make, \"Hewlett-Packard \", 16))\n-  {\n-    model = make + 16;\n-    strlcpy(make, \"HP\", sizeof(make));\n-  }\n-  else if ((model = strchr(make, ' ')) != NULL)\n-    *model++ = '\\0';\n-  else\n-    model = make;\n-\n   cupsFilePrintf(fp, \"*Manufacturer: \\\"%s\\\"\\n\", make);\n   cupsFilePrintf(fp, \"*ModelName: \\\"%s %s\\\"\\n\", make, model);\n   cupsFilePrintf(fp, \"*Product: \\\"(%s %s)\\\"\\n\", make, model);\n@@ -445,21 +492,19 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n   }\n   cupsFilePuts(fp, \"\\\"\\n\");\n \n-  if ((attr = ippFindAttribute(supported, \"printer-more-info\", IPP_TAG_URI)) !=\n-      NULL)\n+  if ((attr = ippFindAttribute(supported, \"printer-more-info\", IPP_TAG_URI)) != NULL && ippValidateAttribute(attr))\n     cupsFilePrintf(fp, \"*APSupplies: \\\"%s\\\"\\n\", ippGetString(attr, 0, NULL));\n \n-  if ((attr = ippFindAttribute(supported, \"printer-charge-info-uri\",\n-\t\t\t       IPP_TAG_URI)) != NULL)\n-    cupsFilePrintf(fp, \"*cupsChargeInfoURI: \\\"%s\\\"\\n\", ippGetString(attr, 0,\n-\t\t\t\t\t\t\t\t    NULL));\n+  if ((attr = ippFindAttribute(supported, \"printer-charge-info-uri\", IPP_TAG_URI)) != NULL && ippValidateAttribute(attr))\n+    cupsFilePrintf(fp, \"*cupsChargeInfoURI: \\\"%s\\\"\\n\", ippGetString(attr, 0, NULL));\n \n   // Message catalogs for UI strings\n+  lang = cupsLangDefault();\n   opt_strings_catalog = cfCatalogOptionArrayNew();\n   cfCatalogLoad(NULL, NULL, opt_strings_catalog);\n \n   if ((attr = ippFindAttribute(supported, \"printer-strings-uri\",\n-\t\t\t       IPP_TAG_URI)) != NULL)\n+\t\t\t       IPP_TAG_URI)) != NULL && ippValidateAttribute(attr))\n   {\n     printer_opt_strings_catalog = cfCatalogOptionArrayNew();\n     cfCatalogLoad(ippGetString(attr, 0, NULL), NULL,\n@@ -512,7 +557,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t  response = cupsDoRequest(http, request, resource);\n \n \t  if ((attr = ippFindAttribute(response, \"printer-strings-uri\",\n-\t\t\t\t       IPP_TAG_URI)) != NULL)\n+\t\t\t\t       IPP_TAG_URI)) != NULL && ippValidateAttribute(attr))\n \t    cupsFilePrintf(fp, \"*cupsStringsURI %s: \\\"%s\\\"\\n\", keyword,\n \t\t\t   ippGetString(attr, 0, NULL));\n \n@@ -538,13 +583,10 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t\t\t\t     IPP_TAG_BOOLEAN), 0))\n     cupsFilePuts(fp, \"*cupsJobAccountingUserId: True\\n\");\n \n-  if ((attr = ippFindAttribute(supported, \"printer-privacy-policy-uri\",\n-\t\t\t       IPP_TAG_URI)) != NULL)\n-    cupsFilePrintf(fp, \"*cupsPrivacyURI: \\\"%s\\\"\\n\",\n-\t\t   ippGetString(attr, 0, NULL));\n+  if ((attr = ippFindAttribute(supported, \"printer-privacy-policy-uri\", IPP_TAG_URI)) != NULL && ippValidateAttribute(attr))\n+    cupsFilePrintf(fp, \"*cupsPrivacyURI: \\\"%s\\\"\\n\", ippGetString(attr, 0, NULL));\n \n-  if ((attr = ippFindAttribute(supported, \"printer-mandatory-job-attributes\",\n-\t\t\t       IPP_TAG_KEYWORD)) != NULL)\n+  if ((attr = ippFindAttribute(supported, \"printer-mandatory-job-attributes\", IPP_TAG_KEYWORD)) != NULL && ippValidateAttribute(attr))\n   {\n     char\tprefix = '\\\"';\t\t// Prefix for string\n \n@@ -564,8 +606,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n     cupsFilePuts(fp, \"\\\"\\n\");\n   }\n \n-  if ((attr = ippFindAttribute(supported, \"printer-requested-job-attributes\",\n-\t\t\t       IPP_TAG_KEYWORD)) != NULL)\n+  if ((attr = ippFindAttribute(supported, \"printer-requested-job-attributes\", IPP_TAG_KEYWORD)) != NULL && ippValidateAttribute(attr))\n   {\n     char\tprefix = '\\\"';\t\t// Prefix for string\n \n@@ -684,7 +725,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n   }\n \n   //\n-  // Fax \n+  // Fax\n   //\n \n   if (is_fax)\n@@ -734,21 +775,21 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n   else if (cupsArrayFind(pdl_list, \"image/urf\") &&\n \t   (ippFindAttribute(supported, \"urf-supported\", IPP_TAG_KEYWORD) != NULL))\n   {\n-    int resStore = 0; // Variable for storing the no. of resolutions in the resolution array \n+    int resStore = 0; // Variable for storing the no. of resolutions in the resolution array\n     int resArray[__INT16_MAX__]; // Creating a resolution array supporting a maximum of 32767 resolutions.\n     int lowdpi = 0, middpi = 0, hidpi = 0; // Lower , middle and higher resolution\n     if ((attr = ippFindAttribute(supported, \"urf-supported\",\n \t\t\tIPP_TAG_KEYWORD)) != NULL)\n     {\n       for (int i = 0, count = ippGetCount(attr); i < count; i ++)\n-      {  \n+      {\n        \tconst char *rs = ippGetString(attr, i, NULL); // RS values\n-        const char *rsCopy = ippGetString(attr, i, NULL); // RS values(copy) \n+        const char *rsCopy = ippGetString(attr, i, NULL); // RS values(copy)\n \tif (strncasecmp(rs, \"RS\", 2)) // Comparing attributes to have RS in\n \t                              // the beginning to indicate the\n \t                              // resolution feature\n \t  continue;\n-        int resCount = 0; // Using a count variable which can be reset \n+        int resCount = 0; // Using a count variable which can be reset\n         while (*rsCopy != '\\0') // Parsing through the copy pointer to\n \t                        // determine the no. of resolutions\n         {\n@@ -846,7 +887,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t    formatfound = 1;\n \t    is_apple = 1;\n \t  }\n-        } \n+        }\n       }\n     }\n   }\n@@ -924,7 +965,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n   if (manual_copies == 1)\n     cupsFilePuts(fp, \"*cupsManualCopies: True\\n\");\n \n-  // No resolution requirements by any of the supported PDLs? \n+  // No resolution requirements by any of the supported PDLs?\n   // Use \"printer-resolution-supported\" attribute\n   if (common_res == NULL)\n   {\n@@ -1042,7 +1083,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n   //\n   // PageSize/PageRegion/ImageableArea/PaperDimension\n   //\n- \n+\n   cfGenerateSizes(supported, CF_GEN_SIZES_DEFAULT, &printer_sizes, &defattr,\n \t\t  NULL, NULL, NULL, NULL, NULL, NULL,\n \t\t  &min_width, &min_length,\n@@ -1421,15 +1462,15 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n         if (!strcmp(sources[j], keyword))\n \t  break;\n       if (j >= 0)\n-\tcupsFilePrintf(fp, \"*InputSlot %s%s%s: \\\"<</MediaPosition %d>>setpagedevice\\\"\\n\",\n-\t\t       ppdname,\n-\t\t       (human_readable ? \"/\" : \"\"),\n-\t\t       (human_readable ? human_readable : \"\"), j);\n+      {\n+\tcupsFilePrintf(fp, \"*InputSlot %s: \\\"<</MediaPosition %d>>setpagedevice\\\"\\n\", ppdname, j);\n+\tppd_put_string(fp, lang, \"InputSlot\", ppdname, human_readable);\n+      }\n       else\n-\tcupsFilePrintf(fp, \"*InputSlot %s%s%s: \\\"\\\"\\n\",\n-\t\t       ppdname,\n-\t\t       (human_readable ? \"/\" : \"\"),\n-\t\t       (human_readable ? human_readable : \"\"));\n+      {\n+\tcupsFilePrintf(fp, \"*InputSlot %s%s%s:\\\"\\\"\\n\", ppdname, human_readable ? \"/\" : \"\", human_readable ? human_readable : \"\");\n+\tppd_put_string(fp, lang, \"InputSlot\", ppdname, human_readable);\n+      }\n     }\n     cupsFilePuts(fp, \"*CloseUI: *InputSlot\\n\");\n   }\n@@ -1464,11 +1505,8 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n       human_readable = cfCatalogLookUpChoice((char *)keyword, \"media-type\",\n \t\t\t\t\t     opt_strings_catalog,\n \t\t\t\t\t     printer_opt_strings_catalog);\n-      cupsFilePrintf(fp, \"*MediaType %s%s%s: \\\"<</MediaType(%s)>>setpagedevice\\\"\\n\",\n-\t\t     ppdname,\n-\t\t     (human_readable ? \"/\" : \"\"),\n-\t\t     (human_readable ? human_readable : \"\"),\n-\t\t     ppdname);\n+      cupsFilePrintf(fp, \"*MediaType %s: \\\"<</MediaType(%s)>>setpagedevice\\\"\\n\", ppdname, ppdname);\n+      ppd_put_string(fp, lang, \"MediaType\", ppdname, human_readable);\n     }\n     cupsFilePuts(fp, \"*CloseUI: *MediaType\\n\");\n   }\n@@ -1791,10 +1829,8 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n       human_readable = cfCatalogLookUpChoice((char *)keyword, \"output-bin\",\n \t\t\t\t\t     opt_strings_catalog,\n \t\t\t\t\t     printer_opt_strings_catalog);\n-      cupsFilePrintf(fp, \"*OutputBin %s%s%s: \\\"\\\"\\n\",\n-\t\t     ppdname,\n-\t\t     (human_readable ? \"/\" : \"\"),\n-\t\t     (human_readable ? human_readable : \"\"));\n+      cupsFilePrintf(fp, \"*OutputBin %s: \\\"\\\"\\n\", ppdname);\n+      ppd_put_string(fp, lang, \"OutputBin\", ppdname, human_readable);\n       outputorderinfofound = 0;\n       faceupdown = 1;\n       firsttolast = 1;\n@@ -1848,7 +1884,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \n   //\n   // Finishing options...\n-  // \n+  //\n \n   if ((attr = ippFindAttribute(supported, \"finishings-supported\",\n \t\t\t       IPP_TAG_ENUM)) != NULL)\n@@ -1973,9 +2009,8 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \thuman_readable = cfCatalogLookUpChoice(buf, \"finishings\",\n \t\t\t\t\t       opt_strings_catalog,\n \t\t\t\t\t       printer_opt_strings_catalog);\n-\tcupsFilePrintf(fp, \"*StapleLocation %s%s%s: \\\"\\\"\\n\", ppd_keyword,\n-\t\t       (human_readable ? \"/\" : \"\"),\n-\t\t       (human_readable ? human_readable : \"\"));\n+\tcupsFilePrintf(fp, \"*StapleLocation %s: \\\"\\\"\\n\", ppd_keyword);\n+\tppd_put_string(fp, lang, \"StapleLocation\", ppd_keyword, human_readable);\n \tcupsFilePrintf(fp, \"*cupsIPPFinishings %d/%s: \\\"*StapleLocation %s\\\"\\n\",\n \t\t       value, keyword, ppd_keyword);\n       }\n@@ -2065,9 +2100,8 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \thuman_readable = cfCatalogLookUpChoice(buf, \"finishings\",\n \t\t\t\t\t       opt_strings_catalog,\n \t\t\t\t\t       printer_opt_strings_catalog);\n-\tcupsFilePrintf(fp, \"*FoldType %s%s%s: \\\"\\\"\\n\", ppd_keyword,\n-\t\t       (human_readable ? \"/\" : \"\"),\n-\t\t       (human_readable ? human_readable : \"\"));\n+\tcupsFilePrintf(fp, \"*FoldType %s: \\\"\\\"\\n\", ppd_keyword);\n+\tppd_put_string(fp, lang, \"FoldType\", ppd_keyword, human_readable);\n \tcupsFilePrintf(fp, \"*cupsIPPFinishings %d/%s: \\\"*FoldType %s\\\"\\n\",\n \t\t       value, keyword, ppd_keyword);\n       }\n@@ -2164,9 +2198,8 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \thuman_readable = cfCatalogLookUpChoice(buf, \"finishings\",\n \t\t\t\t\t       opt_strings_catalog,\n \t\t\t\t\t       printer_opt_strings_catalog);\n-\tcupsFilePrintf(fp, \"*PunchMedia %s%s%s: \\\"\\\"\\n\", ppd_keyword,\n-\t\t       (human_readable ? \"/\" : \"\"),\n-\t\t       (human_readable ? human_readable : \"\"));\n+\tcupsFilePrintf(fp, \"*PunchMedia %s: \\\"\\\"\\n\", ppd_keyword);\n+\tppd_put_string(fp, lang, \"PunchMedia\", ppd_keyword, human_readable);\n \tcupsFilePrintf(fp, \"*cupsIPPFinishings %d/%s: \\\"*PunchMedia %s\\\"\\n\",\n \t\t       value, keyword, ppd_keyword);\n       }\n@@ -2257,9 +2290,8 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \thuman_readable = cfCatalogLookUpChoice(buf, \"finishings\",\n \t\t\t\t\t       opt_strings_catalog,\n \t\t\t\t\t       printer_opt_strings_catalog);\n-\tcupsFilePrintf(fp, \"*CutMedia %s%s%s: \\\"\\\"\\n\", ppd_keyword,\n-\t\t       (human_readable ? \"/\" : \"\"),\n-\t\t       (human_readable ? human_readable : \"\"));\n+\tcupsFilePrintf(fp, \"*CutMedia %s: \\\"\\\"\\n\", ppd_keyword);\n+\tppd_put_string(fp, lang, \"CutMedia\", ppd_keyword, human_readable);\n \tcupsFilePrintf(fp, \"*cupsIPPFinishings %d/%s: \\\"*CutMedia %s\\\"\\n\",\n \t\t       value, keyword, ppd_keyword);\n       }\n@@ -2283,7 +2315,7 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n     cupsFilePrintf(fp, \"*OpenUI *cupsFinishingTemplate/%s: PickOne\\n\",\n \t\t   (human_readable ? human_readable : \"Finishing Template\"));\n     cupsFilePuts(fp, \"*OrderDependency: 10 AnySetup *cupsFinishingTemplate\\n\");\n-    cupsFilePuts(fp, \"*DefaultcupsFinishingTemplate: none\\n\");\n+    cupsFilePuts(fp, \"*DefaultcupsFinishingTemplate: None\\n\");\n     human_readable = cfCatalogLookUpChoice(\"3\", \"finishings\",\n \t\t\t\t\t   opt_strings_catalog,\n \t\t\t\t\t   printer_opt_strings_catalog);\n@@ -2314,8 +2346,9 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t\t\t\t\t     printer_opt_strings_catalog);\n       if (human_readable == NULL)\n \thuman_readable = (char *)keyword;\n-      cupsFilePrintf(fp, \"*cupsFinishingTemplate %s/%s: \\\"\\n\", keyword,\n-\t\t     human_readable);\n+      ppdPwgPpdizeName(keyword, ppdname, sizeof(ppdname));\n+      cupsFilePrintf(fp, \"*cupsFinishingTemplate %s: \\\"\\n\", ppdname);\n+      ppd_put_string(fp, lang, \"cupsFinishingTemplate\", ppdname, human_readable);\n       for (finishing_attr = ippGetFirstAttribute(finishing_col); finishing_attr;\n \t   finishing_attr = ippGetNextAttribute(finishing_col)) {\n         if (ippGetValueTag(finishing_attr) == IPP_TAG_BEGIN_COLLECTION) {\n@@ -2579,14 +2612,14 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n       if (!preset || !preset_name)\n         continue;\n \n-      if ((localized_name =\n+      ppdPwgPpdizeName(preset_name, ppdname, sizeof(ppdname));\n+\n+      localized_name =\n \t   cfCatalogLookUpOption((char *)preset_name,\n \t\t\t\t opt_strings_catalog,\n-\t\t\t\t printer_opt_strings_catalog)) == NULL)\n-        cupsFilePrintf(fp, \"*APPrinterPreset %s: \\\"\\n\", preset_name);\n-      else\n-        cupsFilePrintf(fp, \"*APPrinterPreset %s/%s: \\\"\\n\", preset_name,\n-\t\t       localized_name);\n+\t\t\t\t printer_opt_strings_catalog);\n+      cupsFilePrintf(fp, \"*APPrinterPreset %s: \\\"\\n\", ppdname);\n+      ppd_put_string(fp, lang, \"APPrinterPreset\", ppdname, localized_name);\n \n       for (member = ippGetFirstAttribute(preset); member;\n \t   member = ippGetNextAttribute(preset))\n@@ -2635,7 +2668,10 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t\t ippGetString(ippFindAttribute(fin_col,\n \t\t\t\t\t       \"finishing-template\",\n \t\t\t\t\t       IPP_TAG_ZERO), 0, NULL)) != NULL)\n-              cupsFilePrintf(fp, \"*cupsFinishingTemplate %s\\n\", keyword);\n+            {\n+\t      ppdPwgPpdizeName(keyword, ppdname, sizeof(ppdname));\n+              cupsFilePrintf(fp, \"*cupsFinishingTemplate %s\\n\", ppdname);\n+            }\n           }\n         }\n \telse if (!strcmp(member_name, \"media\"))\n@@ -2674,15 +2710,15 @@ ppdCreatePPDFromIPP2(char         *buffer,          // I - Filename buffer\n \t\t\t\t      NULL)) != NULL)\n \t  {\n             ppdPwgPpdizeName(keyword, ppdname, sizeof(ppdname));\n-            cupsFilePrintf(fp, \"*InputSlot %s\\n\", keyword);\n+            cupsFilePrintf(fp, \"*InputSlot %s\\n\", ppdname);\n \t  }\n \n           if ((keyword = ippGetString(ippFindAttribute(media_col, \"media-type\",\n \t\t\t\t\t\t       IPP_TAG_ZERO), 0,\n \t\t\t\t      NULL)) != NULL)\n \t  {\n             ppdPwgPpdizeName(keyword, ppdname, sizeof(ppdname));\n-            cupsFilePrintf(fp, \"*MediaType %s\\n\", keyword);\n+            cupsFilePrintf(fp, \"*MediaType %s\\n\", ppdname);\n \t  }\n         }\n \telse if (!strcmp(member_name, \"print-quality\"))\n@@ -2832,3 +2868,38 @@ http_connect(http_t     **http,\t\t// IO - Current HTTP connection\n \n   return (*http != NULL);\n }\n+\n+\n+/*\n+ * 'ppd_put_strings()' - Write localization attributes to a PPD file.\n+ */\n+\n+static void\n+ppd_put_string(cups_file_t  *fp,\t/* I - PPD file */\n+               cups_lang_t  *lang,\t/* I - Language */\n+\t       const char   *ppd_option,/* I - PPD option */\n+\t       const char   *ppd_choice,/* I - PPD choice */\n+\t       const char   *text)\t/* I - Localized text */\n+{\n+  if (!text)\n+    return;\n+\n+  // Add the first line of localized text...\n+#if CUPS_VERSION_MAJOR > 2\n+  cupsFilePrintf(fp, \"*%s.%s %s/\", cupsLangGetName(lang), ppd_option, ppd_choice);\n+#else\n+  cupsFilePrintf(fp, \"*%s.%s %s/\", lang->language, ppd_option, ppd_choice);\n+#endif // CUPS_VERSION_MAJOR > 2\n+\n+  while (*text && *text != '\\n')\n+  {\n+    // Escape \":\" and \"<\"...\n+    if (*text == ':' || *text == '<')\n+      cupsFilePrintf(fp, \"<%02X>\", *text);\n+    else\n+      cupsFilePutChar(fp, *text);\n+\n+    text ++;\n+  }\n+  cupsFilePuts(fp, \": \\\"\\\"\\n\");\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "7da4e588a6794ae12601858bb5d61ca165a0180d",
            "date": "2024-11-06T18:02:46Z",
            "author_login": "tillkamppeter"
          },
          {
            "sha": "f56a972ef5ebbc7cbd6f38f73ee95156db50468b",
            "date": "2024-10-17T22:12:51Z",
            "author_login": "tillkamppeter"
          },
          {
            "sha": "edf139324ae2a8023ff75545d4000c52f8090929",
            "date": "2024-09-26T21:12:28Z",
            "author_login": "zdohnal"
          },
          {
            "sha": "d681747ebf12602cb426725eb8ce2753211e2477",
            "date": "2024-09-26T21:12:14Z",
            "author_login": "zdohnal"
          },
          {
            "sha": "0d90320157135b9ec585617e1545793b274c7f82",
            "date": "2024-08-14T22:01:59Z",
            "author_login": "tillkamppeter"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
    "cwe_id": "CWE-20",
    "description": "CUPS is a standards-based, open-source printing system, and `libppd` can be used for legacy PPD file support. The `libppd` function `ppdCreatePPDFromIPP2` does not sanitize IPP attributes when creating the PPD buffer. When used in combination with other functions such as `cfGetPrinterAttributes5`, can result in user controlled input and ultimately code execution via Foomatic. This vulnerability can be part of an exploit chain leading to remote code execution (RCE), as described in CVE-2024-47176.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-26T22:15:04.283",
    "last_modified": "2024-11-21T09:39:28.730",
    "fix_date": "2024-09-26T21:12:14Z"
  },
  "references": [
    {
      "url": "https://github.com/OpenPrinting/cups-browsed/security/advisories/GHSA-rj88-6mr5-rcw8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OpenPrinting/cups-filters/security/advisories/GHSA-p9rh-jxmq-gq47",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OpenPrinting/libcupsfilters/security/advisories/GHSA-w63j-6g73-wmg5",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OpenPrinting/libppd/security/advisories/GHSA-7xfx-47qg-grp6",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.cups.org",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://www.evilsocket.net/2024/09/26/Attacking-UNIX-systems-via-CUPS-Part-I",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/09/27/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/OpenPrinting/libppd/commit/d681747ebf12602cb426725eb8ce2753211e2477",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/09/msg00047.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.158788",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "libppd",
    "owner": "OpenPrinting",
    "created_at": "2022-11-16T18:30:31Z",
    "updated_at": "2024-11-06T18:09:50Z",
    "pushed_at": "2024-11-06T18:09:46Z",
    "size": 211316,
    "stars": 2,
    "forks": 17,
    "open_issues": 7,
    "watchers": 2,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 1205172,
      "C++": 307302,
      "M4": 50504,
      "Shell": 7034,
      "Makefile": 4079
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T16:09:20.206791"
  }
}