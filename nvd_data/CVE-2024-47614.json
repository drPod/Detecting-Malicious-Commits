{
  "cve_id": "CVE-2024-47614",
  "github_data": {
    "repository": "async-graphql/async-graphql",
    "fix_commit": "7f1791488463d4e9c5adcd543962173e2f6cbd34",
    "related_commits": [
      "7f1791488463d4e9c5adcd543962173e2f6cbd34"
    ],
    "patch_url": "https://github.com/async-graphql/async-graphql/commit/7f1791488463d4e9c5adcd543962173e2f6cbd34.patch",
    "fix_commit_details": {
      "sha": "7f1791488463d4e9c5adcd543962173e2f6cbd34",
      "commit_date": "2024-09-24T02:04:09Z",
      "author": {
        "login": "sunli829",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "add `SchemeBuilder.limit_directives` method to set the maximum number of directives on a single field.",
        "length": 102,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 126,
        "additions": 107,
        "deletions": 19
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -4,6 +4,10 @@ All notable changes to this project will be documented in this file.\n The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n \n+# [7.0.10] 2024-09-24\n+\n+- add `SchemeBuilder.limit_directives` method to set the maximum number of directives on a single field.\n+\n # [7.0.9] 2024-09-02\n \n - add `on_ping` callback to `WebSocket`"
        },
        {
          "filename": "src/dynamic/schema.rs",
          "status": "modified",
          "additions": 13,
          "deletions": 0,
          "patch": "@@ -27,6 +27,7 @@ pub struct SchemaBuilder {\n     extensions: Vec<Box<dyn ExtensionFactory>>,\n     validation_mode: ValidationMode,\n     recursive_depth: usize,\n+    max_directives: Option<usize>,\n     complexity: Option<usize>,\n     depth: Option<usize>,\n     enable_suggestions: bool,\n@@ -90,6 +91,13 @@ impl SchemaBuilder {\n         self\n     }\n \n+    /// Set the maximum number of directives on a single field. (default: no\n+    /// limit)\n+    pub fn limit_directives(mut self, max_directives: usize) -> Self {\n+        self.max_directives = Some(max_directives);\n+        self\n+    }\n+\n     /// Set the validation mode, default is `ValidationMode::Strict`.\n     #[must_use]\n     pub fn validation_mode(mut self, validation_mode: ValidationMode) -> Self {\n@@ -204,6 +212,7 @@ impl SchemaBuilder {\n             extensions: self.extensions,\n             types: self.types,\n             recursive_depth: self.recursive_depth,\n+            max_directives: self.max_directives,\n             complexity: self.complexity,\n             depth: self.depth,\n             validation_mode: self.validation_mode,\n@@ -231,6 +240,7 @@ pub struct SchemaInner {\n     pub(crate) types: IndexMap<String, Type>,\n     extensions: Vec<Box<dyn ExtensionFactory>>,\n     recursive_depth: usize,\n+    max_directives: Option<usize>,\n     complexity: Option<usize>,\n     depth: Option<usize>,\n     validation_mode: ValidationMode,\n@@ -249,6 +259,7 @@ impl Schema {\n             extensions: Default::default(),\n             validation_mode: ValidationMode::Strict,\n             recursive_depth: 32,\n+            max_directives: None,\n             complexity: None,\n             depth: None,\n             enable_suggestions: true,\n@@ -365,6 +376,7 @@ impl Schema {\n                     &self.0.env.registry,\n                     self.0.validation_mode,\n                     self.0.recursive_depth,\n+                    self.0.max_directives,\n                     self.0.complexity,\n                     self.0.depth,\n                 )\n@@ -422,6 +434,7 @@ impl Schema {\n                     &schema.0.env.registry,\n                     schema.0.validation_mode,\n                     schema.0.recursive_depth,\n+                    schema.0.max_directives,\n                     schema.0.complexity,\n                     schema.0.depth,\n                 )"
        },
        {
          "filename": "src/schema.rs",
          "status": "modified",
          "additions": 67,
          "deletions": 14,
          "patch": "@@ -50,6 +50,7 @@ pub struct SchemaBuilder<Query, Mutation, Subscription> {\n     complexity: Option<usize>,\n     depth: Option<usize>,\n     recursive_depth: usize,\n+    max_directives: Option<usize>,\n     extensions: Vec<Box<dyn ExtensionFactory>>,\n     custom_directives: HashMap<String, Box<dyn CustomDirectiveFactory>>,\n }\n@@ -115,6 +116,13 @@ impl<Query, Mutation, Subscription> SchemaBuilder<Query, Mutation, Subscription>\n         self\n     }\n \n+    /// Set the maximum number of directives on a single field. (default: no\n+    /// limit)\n+    pub fn limit_directives(mut self, max_directives: usize) -> Self {\n+        self.max_directives = Some(max_directives);\n+        self\n+    }\n+\n     /// Add an extension to the schema.\n     ///\n     /// # Examples\n@@ -265,6 +273,7 @@ impl<Query, Mutation, Subscription> SchemaBuilder<Query, Mutation, Subscription>\n             complexity: self.complexity,\n             depth: self.depth,\n             recursive_depth: self.recursive_depth,\n+            max_directives: self.max_directives,\n             extensions: self.extensions,\n             env: SchemaEnv(Arc::new(SchemaEnvInner {\n                 registry: self.registry,\n@@ -303,6 +312,7 @@ pub struct SchemaInner<Query, Mutation, Subscription> {\n     pub(crate) complexity: Option<usize>,\n     pub(crate) depth: Option<usize>,\n     pub(crate) recursive_depth: usize,\n+    pub(crate) max_directives: Option<usize>,\n     pub(crate) extensions: Vec<Box<dyn ExtensionFactory>>,\n     pub(crate) env: SchemaEnv,\n }\n@@ -381,6 +391,7 @@ where\n             complexity: None,\n             depth: None,\n             recursive_depth: 32,\n+            max_directives: None,\n             extensions: Default::default(),\n             custom_directives: Default::default(),\n         }\n@@ -518,6 +529,7 @@ where\n                     &self.0.env.registry,\n                     self.0.validation_mode,\n                     self.0.recursive_depth,\n+                    self.0.max_directives,\n                     self.0.complexity,\n                     self.0.depth,\n                 )\n@@ -574,7 +586,8 @@ where\n             async_stream::stream! {\n                 let (env, cache_control) = match prepare_request(\n                         extensions, request, session_data, &env.registry,\n-                        schema.0.validation_mode, schema.0.recursive_depth, schema.0.complexity, schema.0.depth\n+                        schema.0.validation_mode, schema.0.recursive_depth,\n+                        schema.0.max_directives, schema.0.complexity, schema.0.depth\n                 ).await {\n                     Ok(res) => res,\n                     Err(errors) => {\n@@ -658,6 +671,53 @@ where\n     }\n }\n \n+fn check_max_directives(doc: &ExecutableDocument, max_directives: usize) -> ServerResult<()> {\n+    fn check_selection_set(\n+        doc: &ExecutableDocument,\n+        selection_set: &Positioned<SelectionSet>,\n+        limit_directives: usize,\n+    ) -> ServerResult<()> {\n+        for selection in &selection_set.node.items {\n+            match &selection.node {\n+                Selection::Field(field) => {\n+                    if field.node.directives.len() > limit_directives {\n+                        return Err(ServerError::new(\n+                            format!(\n+                                \"The number of directives on the field `{}` cannot be greater than `{}`\",\n+                                field.node.name.node, limit_directives\n+                            ),\n+                            Some(field.pos),\n+                        ));\n+                    }\n+                    check_selection_set(doc, &field.node.selection_set, limit_directives)?;\n+                }\n+                Selection::FragmentSpread(fragment_spread) => {\n+                    if let Some(fragment) =\n+                        doc.fragments.get(&fragment_spread.node.fragment_name.node)\n+                    {\n+                        check_selection_set(doc, &fragment.node.selection_set, limit_directives)?;\n+                    }\n+                }\n+                Selection::InlineFragment(inline_fragment) => {\n+                    check_selection_set(\n+                        doc,\n+                        &inline_fragment.node.selection_set,\n+                        limit_directives,\n+                    )?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    for (_, operation) in doc.operations.iter() {\n+        check_selection_set(doc, &operation.node.selection_set, max_directives)?;\n+    }\n+\n+    Ok(())\n+}\n+\n fn check_recursive_depth(doc: &ExecutableDocument, max_depth: usize) -> ServerResult<()> {\n     fn check_selection_set(\n         doc: &ExecutableDocument,\n@@ -776,6 +836,7 @@ pub(crate) async fn prepare_request(\n     registry: &Registry,\n     validation_mode: ValidationMode,\n     recursive_depth: usize,\n+    max_directives: Option<usize>,\n     complexity: Option<usize>,\n     depth: Option<usize>,\n ) -> Result<(QueryEnv, CacheControl), Vec<ServerError>> {\n@@ -792,6 +853,9 @@ pub(crate) async fn prepare_request(\n                 None => parse_query(query)?,\n             };\n             check_recursive_depth(&doc, recursive_depth)?;\n+            if let Some(max_directives) = max_directives {\n+                check_max_directives(&doc, max_directives)?;\n+            }\n             Ok(doc)\n         };\n         futures_util::pin_mut!(fut_parse);\n@@ -808,25 +872,14 @@ pub(crate) async fn prepare_request(\n                 &document,\n                 Some(&request.variables),\n                 validation_mode,\n+                complexity,\n+                depth,\n             )\n         };\n         futures_util::pin_mut!(validation_fut);\n         extensions.validation(&mut validation_fut).await?\n     };\n \n-    // check limit\n-    if let Some(limit_complexity) = complexity {\n-        if validation_result.complexity > limit_complexity {\n-            return Err(vec![ServerError::new(\"Query is too complex.\", None)]);\n-        }\n-    }\n-\n-    if let Some(limit_depth) = depth {\n-        if validation_result.depth > limit_depth {\n-            return Err(vec![ServerError::new(\"Query is nested too deep.\", None)]);\n-        }\n-    }\n-\n     let operation = if let Some(operation_name) = &request.operation_name {\n         match document.operations {\n             DocumentOperations::Single(_) => None,"
        },
        {
          "filename": "src/validation/mod.rs",
          "status": "modified",
          "additions": 23,
          "deletions": 5,
          "patch": "@@ -39,19 +39,21 @@ pub enum ValidationMode {\n     Fast,\n }\n \n-pub fn check_rules(\n+pub(crate) fn check_rules(\n     registry: &Registry,\n     doc: &ExecutableDocument,\n     variables: Option<&Variables>,\n     mode: ValidationMode,\n+    limit_complexity: Option<usize>,\n+    limit_depth: Option<usize>,\n ) -> Result<ValidationResult, Vec<ServerError>> {\n-    let mut ctx = VisitorContext::new(registry, doc, variables);\n     let mut cache_control = CacheControl::default();\n     let mut complexity = 0;\n     let mut depth = 0;\n \n-    match mode {\n+    let errors = match mode {\n         ValidationMode::Strict => {\n+            let mut ctx = VisitorContext::new(registry, doc, variables);\n             let mut visitor = VisitorNil\n                 .with(rules::ArgumentsOfCorrectType::default())\n                 .with(rules::DefaultValuesOfCorrectType)\n@@ -84,8 +86,10 @@ pub fn check_rules(\n                 .with(visitors::ComplexityCalculate::new(&mut complexity))\n                 .with(visitors::DepthCalculate::new(&mut depth));\n             visit(&mut visitor, &mut ctx, doc);\n+            ctx.errors\n         }\n         ValidationMode::Fast => {\n+            let mut ctx = VisitorContext::new(registry, doc, variables);\n             let mut visitor = VisitorNil\n                 .with(rules::NoFragmentCycles::default())\n                 .with(rules::UploadFile)\n@@ -95,11 +99,25 @@ pub fn check_rules(\n                 .with(visitors::ComplexityCalculate::new(&mut complexity))\n                 .with(visitors::DepthCalculate::new(&mut depth));\n             visit(&mut visitor, &mut ctx, doc);\n+            ctx.errors\n+        }\n+    };\n+\n+    // check limit\n+    if let Some(limit_complexity) = limit_complexity {\n+        if complexity > limit_complexity {\n+            return Err(vec![ServerError::new(\"Query is too complex.\", None)]);\n+        }\n+    }\n+\n+    if let Some(limit_depth) = limit_depth {\n+        if depth > limit_depth {\n+            return Err(vec![ServerError::new(\"Query is nested too deep.\", None)]);\n         }\n     }\n \n-    if !ctx.errors.is_empty() {\n-        return Err(ctx.errors.into_iter().map(Into::into).collect());\n+    if !errors.is_empty() {\n+        return Err(errors.into_iter().map(Into::into).collect());\n     }\n \n     Ok(ValidationResult {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "33282a1bb54912aff2c377fa216df758021fda2c",
            "date": "2024-12-10T02:32:23Z",
            "author_login": "sunli829"
          },
          {
            "sha": "0aa3863f758fbaa51cc953ea64b2ae6ba854fb01",
            "date": "2024-12-10T02:28:27Z",
            "author_login": "sunli829"
          },
          {
            "sha": "816dcb0d2e6c12d9968926fe55cdae5ac7314cde",
            "date": "2024-12-09T16:03:24Z",
            "author_login": "sunli829"
          },
          {
            "sha": "772948029ef66bca679a8873e390a4521ddba4c2",
            "date": "2024-12-08T08:49:48Z",
            "author_login": "sunli829"
          },
          {
            "sha": "91ffca4019936d18047cfe7c6764c3d6ab5a45f3",
            "date": "2024-12-08T08:41:37Z",
            "author_login": "sunli829"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "async-graphql is a GraphQL server library implemented in Rust. async-graphql before 7.0.10 does not limit the number of directives for a field. This can lead to Service Disruption, Resource Exhaustion, and User Experience Degradation. This vulnerability is fixed in 7.0.10.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-03T15:15:14.720",
    "last_modified": "2024-10-04T13:50:43.727",
    "fix_date": "2024-09-24T02:04:09Z"
  },
  "references": [
    {
      "url": "https://github.com/async-graphql/async-graphql/commit/7f1791488463d4e9c5adcd543962173e2f6cbd34",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/async-graphql/async-graphql/security/advisories/GHSA-5gc2-7c65-8fq8",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.105673",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "async-graphql",
    "owner": "async-graphql",
    "created_at": "2020-03-01T10:54:40Z",
    "updated_at": "2025-01-14T17:49:32Z",
    "pushed_at": "2024-12-10T02:50:26Z",
    "size": 12838,
    "stars": 3414,
    "forks": 472,
    "open_issues": 207,
    "watchers": 3414,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Rust": 1967575,
      "Handlebars": 4663
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T21:54:44.687867"
  }
}