{
  "cve_id": "CVE-2024-47768",
  "github_data": {
    "repository": "Lif-Platforms/Lif-Auth-Server",
    "fix_commit": "8dbd7cad914a8b939451c652bfb716aa796f754e",
    "related_commits": [
      "8dbd7cad914a8b939451c652bfb716aa796f754e"
    ],
    "patch_url": "https://github.com/Lif-Platforms/Lif-Auth-Server/commit/8dbd7cad914a8b939451c652bfb716aa796f754e.patch",
    "fix_commit_details": {
      "sha": "8dbd7cad914a8b939451c652bfb716aa796f754e",
      "commit_date": "2024-10-04T06:05:30Z",
      "author": {
        "login": "Superior126",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 44,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 82,
        "additions": 62,
        "deletions": 20
      },
      "files": [
        {
          "filename": "requirements.txt",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1,5 +1,5 @@\n Flask==2.2.5\n-Flask-Cors==4.0.1\n+Flask-Cors==5.0.0\n fastapi==0.111.0\n uvicorn[standard]==0.30.1\n PyYAML==6.0.1\n@@ -8,4 +8,5 @@ uuid==1.30\n mysql-connector-python==8.0.33\n python-multipart==0.0.7\n requests==2.32.0\n-matplotlib==3.8.0\n\\ No newline at end of file\n+matplotlib==3.8.0\n+tldextract==5.1.2\n\\ No newline at end of file"
        },
        {
          "filename": "src/_version.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-__version__='1.7.2'\n\\ No newline at end of file\n+__version__='1.7.3'\n\\ No newline at end of file"
        },
        {
          "filename": "src/auth_server.py",
          "status": "modified",
          "additions": 58,
          "deletions": 17,
          "patch": "@@ -1,7 +1,8 @@\n from fastapi import FastAPI, HTTPException, Request, Form, File, UploadFile, WebSocket\n from fastapi.middleware.cors import CORSMiddleware\n-from fastapi.responses import FileResponse, JSONResponse, HTMLResponse\n+from fastapi.responses import FileResponse, JSONResponse, HTMLResponse, RedirectResponse\n from starlette.responses import Response\n+import tldextract\n import os\n import yaml\n import json\n@@ -224,21 +225,42 @@ async def lif_login(username: str = Form(), password: str = Form(), permissions:\n         raise HTTPException(status_code=401, detail='Incorrect Login Credentials')\n     \n @app.get(\"/auth/logout\")\n-async def log_out(response: Response):\n+async def log_out(response: Response, redirect = None):\n     \"\"\"\n     ## Logout Route For Lif Accounts\n     Handles the logout process for Lif Accounts.\n \n     ### Parameters:\n     none\n \n+    ### Query Parameters\n+    - **redirect:** url to redirect to after the logout completes.\n+\n     ### Returns:\n     - **STRING:** Status of the operation.\n     \"\"\"\n     response.delete_cookie(key=\"LIF_USERNAME\", path=\"/\", domain=\".lifplatforms.com\")\n     response.delete_cookie(key=\"LIF_TOKEN\", path=\"/\", domain=\".lifplatforms.com\")\n \n-    return \"Logout Successful\"\n+    # Create a RedirectResponse\n+    redirect_response = RedirectResponse(url=redirect)\n+\n+    # Copy the cookies from the response to the redirect response\n+    for cookie in response.headers.getlist(\"set-cookie\"):\n+        redirect_response.headers.append(\"set-cookie\", cookie)\n+\n+    if redirect != None:\n+        # Check to ensure redirect URL goes to a Lif Platforms domain\n+        extracted = tldextract.extract(redirect)\n+        domain = f\"{extracted.domain}.{extracted.suffix}\"\n+\n+        if domain == \"lifplatforms.com\":\n+            return redirect_response\n+        else:\n+            print(domain)\n+            raise HTTPException(status_code=400, detail=\"Untrusted redirect url.\")\n+    else:\n+        return \"Log Out Successful\"\n     \n @app.post(\"/update_pfp\")\n @app.post(\"/account/update_avatar\")\n@@ -464,10 +486,15 @@ async def get_pfp(username: str):\n \n     # Check if the file exists and is a regular file\n     if os.path.isfile(avatar_path):\n-        return FileResponse(avatar_path, media_type='image/gif')\n+        response = FileResponse(avatar_path, media_type='image/gif')\n     else:\n         # Return default image if the user's banner doesn't exist\n-        return FileResponse(f'{assets_folder}/default_pfp.png', media_type='image/gif')\n+        response = FileResponse(f'{assets_folder}/default_pfp.png', media_type='image/gif')\n+\n+    # Add caching limit to image\n+    response.headers[\"Cache-Control\"] = \"public, max-age=3600\"\n+\n+    return response\n \n @app.get(\"/get_banner/{username}\")\n @app.get(\"/profile/get_banner/{username}\")\n@@ -490,10 +517,15 @@ async def get_banner(username: str):\n \n     # Check if the file exists and is a regular file\n     if os.path.isfile(banner_path):\n-        return FileResponse(banner_path, media_type='image/gif')\n+        response = FileResponse(banner_path, media_type='image/gif')\n     else:\n         # Return default image if the user's banner doesn't exist\n-        return FileResponse(f'{assets_folder}/default_banner.png', media_type='image/gif')\n+        response = FileResponse(f'{assets_folder}/default_banner.png', media_type='image/gif')\n+\n+    # Add caching time limit to image\n+    response.headers[\"Cache-Control\"] = \"public, max-age=3600\"\n+\n+    return response\n     \n @app.post(\"/create_lif_account\")\n @app.post(\"/account/create_account\")\n@@ -653,6 +685,9 @@ async def account_recovery(websocket: WebSocket):\n     user_email = None\n     user_code = None\n \n+    # Determines if the user has entered the correct code from the recovery email\n+    authenticated = False\n+\n     # Wait for client to send data\n     while True:\n         # Tries to receive data from client, if fails then the connection is closed\n@@ -677,25 +712,31 @@ async def account_recovery(websocket: WebSocket):\n             elif 'code' in data:\n                 # Compare generated code with user provided code\n                 if data['code'] == user_code:\n+                    # Sets the user to authenticated so the password can be updated\n+                    authenticated = True\n+\n                     await websocket.send_json({\"responseType\": \"codeCorrect\", \"message\": \"Code validated successfully.\"})\n                 else:\n                     await websocket.send_json({\"responseType\": \"error\", \"message\": \"Bad Code\"})\n                     \n             elif 'password' in data:\n-                # Get password hash and gen salt\n-                password_hash = hasher.get_hash_gen_salt(data['password'])\n+                if authenticated:\n+                    # Get password hash and gen salt\n+                    password_hash = hasher.get_hash_gen_salt(data['password'])\n \n-                # Get username from email\n-                username = database.get_username_from_email(user_email)\n+                    # Get username from email\n+                    username = database.get_username_from_email(user_email)\n \n-                # Update password and salt in database\n-                database.update.update_password(username, password_hash['password'])\n-                database.update.update_user_salt(username, password_hash['salt'])\n+                    # Update password and salt in database\n+                    database.update.update_password(username, password_hash['password'])\n+                    database.update.update_user_salt(username, password_hash['salt'])\n \n-                # Get user token\n-                token = database.info.retrieve_user_token(username)\n+                    # Get user token\n+                    token = database.info.retrieve_user_token(username)\n \n-                await websocket.send_json({\"responseType\": \"passwordUpdated\", \"username\": username, \"token\": token})\n+                    await websocket.send_json({\"responseType\": \"passwordUpdated\", \"username\": username, \"token\": token})\n+                else:\n+                    await websocket.send_json({\"responseType\": \"error\", \"message\": \"You have not authenticated yet\"})\n             else:\n                 await websocket.send_json({\"responseType\": \"error\", \"message\": \"Bad Request\"})\n "
        }
      ],
      "file_patterns": {
        "security_files": 1,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8becd0c68907f415cccab97285d1f1a3f7d13bed",
            "date": "2024-10-30T22:39:13Z",
            "author_login": "Superior126"
          },
          {
            "sha": "fe9de0d9708aaeb281e0aa1d6fb35b9dac59072d",
            "date": "2024-10-30T20:51:37Z",
            "author_login": "Superior126"
          },
          {
            "sha": "bffb6ae6c3f755b0b4c6a725777c0370f603f080",
            "date": "2024-10-30T20:49:11Z",
            "author_login": "Superior126"
          },
          {
            "sha": "e32176507d907eddd510fd3579dc44ba402f4468",
            "date": "2024-10-30T20:44:50Z",
            "author_login": "Superior126"
          },
          {
            "sha": "5d671fa871872a9d5d3a5fc78075364928d0a96b",
            "date": "2024-10-24T16:57:28Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-287",
    "description": "Lif Authentication Server is a server used by Lif to do various tasks regarding Lif accounts. This vulnerability has to do with the account recovery system where there does not appear to be a check to make sure the user has been sent the recovery email and entered the correct code. If the attacker knew the email of the target, they could supply the email and immediately prompt the server to update the password without ever needing the code. This issue has been patched in version 1.7.3.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-10-04T15:15:13.323",
    "last_modified": "2024-11-13T14:55:39.690",
    "fix_date": "2024-10-04T06:05:30Z"
  },
  "references": [
    {
      "url": "https://github.com/Lif-Platforms/Lif-Auth-Server/commit/8dbd7cad914a8b939451c652bfb716aa796f754e",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Lif-Platforms/Lif-Auth-Server/security/advisories/GHSA-hmv6-8fg8-7m6f",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.108621",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "Lif-Auth-Server",
    "owner": "Lif-Platforms",
    "created_at": "2023-03-28T16:49:21Z",
    "updated_at": "2024-10-30T22:39:19Z",
    "pushed_at": "2024-12-02T22:35:17Z",
    "size": 2975,
    "stars": 0,
    "forks": 0,
    "open_issues": 7,
    "watchers": 0,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 71991,
      "HTML": 9313
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T13:06:29.731385"
  }
}