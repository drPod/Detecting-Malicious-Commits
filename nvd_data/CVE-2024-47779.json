{
  "cve_id": "CVE-2024-47779",
  "github_data": {
    "repository": "element-hq/element-web",
    "fix_commit": "8d7f2b5c1301129a488d3597f3839bd74203ee62",
    "related_commits": [
      "8d7f2b5c1301129a488d3597f3839bd74203ee62"
    ],
    "patch_url": "https://github.com/element-hq/element-web/commit/8d7f2b5c1301129a488d3597f3839bd74203ee62.patch",
    "fix_commit_details": {
      "sha": "8d7f2b5c1301129a488d3597f3839bd74203ee62",
      "commit_date": "2024-10-15T11:37:21Z",
      "author": {
        "login": "dbkr",
        "type": "User",
        "stats": {
          "total_commits": 2515,
          "average_weekly_commits": 5.00996015936255,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 288
        }
      },
      "commit_message": {
        "title": "Fix for CVE-2024-47779 / GHSA-3jm3-x98c-r34x",
        "length": 44,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 51,
        "additions": 33,
        "deletions": 18
      },
      "files": [
        {
          "filename": "src/serviceworker/index.ts",
          "status": "modified",
          "additions": 30,
          "deletions": 18,
          "patch": "@@ -40,47 +40,58 @@ global.addEventListener(\"fetch\", (event: FetchEvent) => {\n \n     // Note: ideally we'd keep the request headers etc, but in practice we can't even see those details.\n     // See https://stackoverflow.com/a/59152482\n-    let url = event.request.url;\n+    const url = new URL(event.request.url);\n \n     // We only intercept v3 download and thumbnail requests as presumably everything else is deliberate.\n     // For example, `/_matrix/media/unstable` or `/_matrix/media/v3/preview_url` are something well within\n     // the control of the application, and appear to be choices made at a higher level than us.\n-    if (!url.includes(\"/_matrix/media/v3/download\") && !url.includes(\"/_matrix/media/v3/thumbnail\")) {\n+    if (\n+        !url.pathname.startsWith(\"/_matrix/media/v3/download\") &&\n+        !url.pathname.startsWith(\"/_matrix/media/v3/thumbnail\")\n+    ) {\n         return; // not a URL we care about\n     }\n \n     // We need to call respondWith synchronously, otherwise we may never execute properly. This means\n     // later on we need to proxy the request through if it turns out the server doesn't support authentication.\n     event.respondWith(\n         (async (): Promise<Response> => {\n-            let accessToken: string | undefined;\n+            let auth: { accessToken?: string; homeserver: string } | undefined;\n             try {\n                 // Figure out which homeserver we're communicating with\n-                const csApi = url.substring(0, url.indexOf(\"/_matrix/media/v3\"));\n+                const csApi = url.origin;\n \n                 // Add jitter to reduce request spam, particularly to `/versions` on initial page load\n                 await new Promise<void>((resolve) => setTimeout(() => resolve(), Math.random() * 10));\n \n-                // Locate our access token, and populate the fetchConfig with the authentication header.\n+                // Locate the access token and homeserver url\n                 // @ts-expect-error - service worker types are not available. See 'fetch' event handler.\n                 const client = await global.clients.get(event.clientId);\n-                accessToken = await getAccessToken(client);\n+                auth = await getAuthData(client);\n+\n+                // Is this request actually going to the homeserver?\n+                const isRequestToHomeServer = url.origin === new URL(auth.homeserver).origin;\n+                if (!isRequestToHomeServer) {\n+                    throw new Error(\"Request appears to be for media endpoint but wrong homeserver!\");\n+                }\n \n                 // Update or populate the server support map using a (usually) authenticated `/versions` call.\n-                await tryUpdateServerSupportMap(csApi, accessToken);\n+                await tryUpdateServerSupportMap(csApi, auth.accessToken);\n \n                 // If we have server support (and a means of authentication), rewrite the URL to use MSC3916 endpoints.\n-                if (serverSupportMap[csApi].supportsAuthedMedia && accessToken) {\n-                    url = url.replace(/\\/media\\/v3\\/(.*)\\//, \"/client/v1/media/$1/\");\n+                if (serverSupportMap[csApi].supportsAuthedMedia && auth.accessToken) {\n+                    url.href = url.href.replace(/\\/media\\/v3\\/(.*)\\//, \"/client/v1/media/$1/\");\n                 } // else by default we make no changes\n             } catch (err) {\n+                // In case of some error, we stay safe by not adding the access-token to the request.\n+                auth = undefined;\n                 console.error(\"SW: Error in request rewrite.\", err);\n             }\n \n             // Add authentication and send the request. We add authentication even if MSC3916 endpoints aren't\n             // being used to ensure patches like this work:\n             // https://github.com/matrix-org/synapse/commit/2390b66bf0ec3ff5ffb0c7333f3c9b239eeb92bb\n-            return fetch(url, fetchConfigForToken(accessToken));\n+            return fetch(url, fetchConfigForToken(auth?.accessToken));\n         })(),\n     );\n });\n@@ -106,35 +117,36 @@ async function tryUpdateServerSupportMap(clientApiUrl: string, accessToken?: str\n \n // Ideally we'd use the `Client` interface for `client`, but since it's not available (see 'fetch' listener), we use\n // unknown for now and force-cast it to something close enough later.\n-async function getAccessToken(client: unknown): Promise<string | undefined> {\n+async function getAuthData(client: unknown): Promise<{ accessToken: string; homeserver: string }> {\n     // Access tokens are encrypted at rest, so while we can grab the \"access token\", we'll need to do work to get the\n     // real thing.\n     const encryptedAccessToken = await idbLoad(\"account\", \"mx_access_token\");\n \n     // We need to extract a user ID and device ID from localstorage, which means calling WebPlatform for the\n     // read operation. Service workers can't access localstorage.\n-    const { userId, deviceId } = await askClientForUserIdParams(client);\n+    const { userId, deviceId, homeserver } = await askClientForUserIdParams(client);\n \n     // ... and this is why we need the user ID and device ID: they're index keys for the pickle key table.\n     const pickleKeyData = await idbLoad(\"pickleKey\", [userId, deviceId]);\n     if (pickleKeyData && (!pickleKeyData.encrypted || !pickleKeyData.iv || !pickleKeyData.cryptoKey)) {\n-        console.error(\"SW: Invalid pickle key loaded - ignoring\");\n-        return undefined;\n+        throw new Error(\"SW: Invalid pickle key loaded - ignoring\");\n     }\n \n     // Finally, try decrypting the thing and return that. This may fail, but that's okay.\n     try {\n         const pickleKey = await buildAndEncodePickleKey(pickleKeyData, userId, deviceId);\n-        return tryDecryptToken(pickleKey, encryptedAccessToken, ACCESS_TOKEN_IV);\n+        const accessToken = await tryDecryptToken(pickleKey, encryptedAccessToken, ACCESS_TOKEN_IV);\n+        return { accessToken, homeserver };\n     } catch (e) {\n-        console.error(\"SW: Error decrypting access token.\", e);\n-        return undefined;\n+        throw new Error(\"SW: Error decrypting access token.\", { cause: e });\n     }\n }\n \n // Ideally we'd use the `Client` interface for `client`, but since it's not available (see 'fetch' listener), we use\n // unknown for now and force-cast it to something close enough inside the function.\n-async function askClientForUserIdParams(client: unknown): Promise<{ userId: string; deviceId: string }> {\n+async function askClientForUserIdParams(\n+    client: unknown,\n+): Promise<{ userId: string; deviceId: string; homeserver: string }> {\n     return new Promise((resolve, reject) => {\n         // Dev note: this uses postMessage, which is a highly insecure channel. postMessage is typically visible to other\n         // tabs, windows, browser extensions, etc, making it far from ideal for sharing sensitive information. This is"
        },
        {
          "filename": "src/vector/platform/WebPlatform.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -14,6 +14,7 @@ import { Action } from \"matrix-react-sdk/src/dispatcher/actions\";\n import { CheckUpdatesPayload } from \"matrix-react-sdk/src/dispatcher/payloads/CheckUpdatesPayload\";\n import UAParser from \"ua-parser-js\";\n import { logger } from \"matrix-js-sdk/src/logger\";\n+import { MatrixClientPeg } from \"matrix-react-sdk/src/MatrixClientPeg\";\n \n import VectorBasePlatform from \"./VectorBasePlatform\";\n import { parseQs } from \"../url_utils\";\n@@ -62,10 +63,12 @@ export default class WebPlatform extends VectorBasePlatform {\n             if (event.data?.[\"type\"] === \"userinfo\" && event.data?.[\"responseKey\"]) {\n                 const userId = localStorage.getItem(\"mx_user_id\");\n                 const deviceId = localStorage.getItem(\"mx_device_id\");\n+                const homeserver = MatrixClientPeg.get()?.getHomeserverUrl();\n                 event.source!.postMessage({\n                     responseKey: event.data[\"responseKey\"],\n                     userId,\n                     deviceId,\n+                    homeserver,\n                 });\n             }\n         } catch (e) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "dbce48b23d5c553836e064b49165397f638d28e7",
            "date": "2025-01-14T18:00:30Z",
            "author_login": "t3chguy"
          },
          {
            "sha": "bb41616d5f9fc6d47c735d4794de1fa46766cb7a",
            "date": "2025-01-14T14:18:55Z",
            "author_login": "RiotRobot"
          },
          {
            "sha": "c75f6dc3a1b7c6b93cb88ac38d695c237301ecbd",
            "date": "2025-01-14T14:18:36Z",
            "author_login": "RiotRobot"
          },
          {
            "sha": "880048d998aa170b73007f4b19508724530f367b",
            "date": "2025-01-14T14:13:47Z",
            "author_login": "RiotRobot"
          },
          {
            "sha": "24685dc7d17e1942255ed15c3e9696b0819523ff",
            "date": "2025-01-14T14:10:44Z",
            "author_login": "RiotRobot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-200",
    "description": "Element is a Matrix web client built using the Matrix React SDK. Element Web versions 1.11.70 through 1.11.80 contain a vulnerability which can, under specially crafted conditions, lead to the access token becoming exposed to third parties. At least one vector has been identified internally, involving malicious widgets, but other vectors may exist. Note that despite superficial similarity to CVE-2024-47771, this is an entirely separate vulnerability, caused by a separate piece of code included only in Element Web. Element Web and Element Desktop share most but not all, of their code and this vulnerability exists in the part of the code base which is not shared between the projects. Users are strongly advised to upgrade to version 1.11.81 to remediate the issue. As a workaround, avoid granting permissions to untrusted widgets.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-10-15T16:15:04.963",
    "last_modified": "2024-11-12T17:15:08.037",
    "fix_date": "2024-10-15T11:37:21Z"
  },
  "references": [
    {
      "url": "https://github.com/element-hq/element-web/commit/8d7f2b5c1301129a488d3597f3839bd74203ee62",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/element-hq/element-web/security/advisories/GHSA-3jm3-x98c-r34x",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.148760",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "element-web",
    "owner": "element-hq",
    "created_at": "2015-07-22T05:32:15Z",
    "updated_at": "2025-01-14T18:13:28Z",
    "pushed_at": "2025-01-14T18:13:25Z",
    "size": 412456,
    "stars": 11362,
    "forks": 2056,
    "open_issues": 3368,
    "watchers": 11362,
    "has_security_policy": false,
    "default_branch": "develop",
    "protected_branches": [],
    "languages": {
      "TypeScript": 12426920,
      "CSS": 846182,
      "HTML": 185989,
      "JavaScript": 160494,
      "Python": 12205,
      "Shell": 8743,
      "Perl": 8613,
      "Dockerfile": 1605
    },
    "commit_activity": {
      "total_commits_last_year": 2661,
      "avg_commits_per_week": 51.17307692307692,
      "days_active_last_year": 259
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T18:27:41.565517"
  }
}