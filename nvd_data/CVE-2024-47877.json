{
  "cve_id": "CVE-2024-47877",
  "github_data": {
    "repository": "codeclysm/extract",
    "fix_commit": "4a98568021b8e289345c7f526ccbd7ed732cf286",
    "related_commits": [
      "4a98568021b8e289345c7f526ccbd7ed732cf286"
    ],
    "patch_url": "https://github.com/codeclysm/extract/commit/4a98568021b8e289345c7f526ccbd7ed732cf286.patch",
    "fix_commit_details": {
      "sha": "4a98568021b8e289345c7f526ccbd7ed732cf286",
      "commit_date": "2024-08-08T08:42:49Z",
      "author": {
        "login": "cmaglie",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 42,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 300,
        "additions": 265,
        "deletions": 35
      },
      "files": [
        {
          "filename": "evil_generator/main.go",
          "status": "modified",
          "additions": 23,
          "deletions": 0,
          "patch": "@@ -22,6 +22,11 @@ func main() {\n \t\tlog.Fatalf(\"Output path %s is not a directory\", outputDir)\n \t}\n \n+\tgenerateEvilZipSlip(outputDir)\n+\tgenerateEvilSymLinkPathTraversalTar(outputDir)\n+}\n+\n+func generateEvilZipSlip(outputDir *paths.Path) {\n \tevilPathTraversalFiles := []string{\n \t\t\"..\",\n \t\t\"../../../../../../../../../../../../../../../../../../../../tmp/evil.txt\",\n@@ -104,3 +109,21 @@ func main() {\n \t\t}\n \t}\n }\n+\n+func generateEvilSymLinkPathTraversalTar(outputDir *paths.Path) {\n+\toutputTarFile, err := outputDir.Join(\"evil-link-traversal.tar\").Create()\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tdefer outputTarFile.Close()\n+\n+\ttw := tar.NewWriter(outputTarFile)\n+\tdefer tw.Close()\n+\n+\tif err := tw.WriteHeader(&tar.Header{\n+\t\tName: \"leak\", Linkname: \"../../../../../../../../../../../../../../../tmp/something-important\",\n+\t\tMode: 0o0777, Size: 0, Typeflag: tar.TypeLink,\n+\t}); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"
        },
        {
          "filename": "extractor.go",
          "status": "modified",
          "additions": 33,
          "deletions": 12,
          "patch": "@@ -217,7 +217,10 @@ func (e *Extractor) Tar(ctx context.Context, body io.Reader, location string, re\n \t\t\t\tname = rename(name)\n \t\t\t}\n \n-\t\t\tname = filepath.Join(location, name)\n+\t\t\tname, err = safeJoin(location, name)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tlinks = append(links, &link{Path: path, Name: name})\n \t\tcase tar.TypeSymlink:\n \t\t\tsymlinks = append(symlinks, &link{Path: path, Name: header.Linkname})\n@@ -237,6 +240,32 @@ func (e *Extractor) Tar(ctx context.Context, body io.Reader, location string, re\n \t\t}\n \t}\n \n+\tif err := e.extractSymlinks(ctx, symlinks); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (e *Extractor) extractSymlinks(ctx context.Context, symlinks []*link) error {\n+\tfor _, symlink := range symlinks {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn errors.New(\"interrupted\")\n+\t\tdefault:\n+\t\t}\n+\n+\t\t// Make a placeholder and replace it after unpacking everything\n+\t\t_ = e.FS.Remove(symlink.Path)\n+\t\tf, err := e.FS.OpenFile(symlink.Path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, os.FileMode(0666))\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"creating symlink placeholder %s: %w\", symlink.Path, err)\n+\t\t}\n+\t\tif err := f.Close(); err != nil {\n+\t\t\treturn fmt.Errorf(\"creating symlink placeholder %s: %w\", symlink.Path, err)\n+\t\t}\n+\t}\n+\n \tfor _, symlink := range symlinks {\n \t\tselect {\n \t\tcase <-ctx.Done():\n@@ -248,6 +277,7 @@ func (e *Extractor) Tar(ctx context.Context, body io.Reader, location string, re\n \t\t\treturn errors.Annotatef(err, \"Create link %s\", symlink.Path)\n \t\t}\n \t}\n+\n \treturn nil\n }\n \n@@ -340,17 +370,8 @@ func (e *Extractor) Zip(ctx context.Context, body io.Reader, location string, re\n \t\t}\n \t}\n \n-\t// Now we make another pass creating the links\n-\tfor _, link := range links {\n-\t\tselect {\n-\t\tcase <-ctx.Done():\n-\t\t\treturn errors.New(\"interrupted\")\n-\t\tdefault:\n-\t\t}\n-\t\t_ = e.FS.Remove(link.Path)\n-\t\tif err := e.FS.Symlink(link.Name, link.Path); err != nil {\n-\t\t\treturn errors.Annotatef(err, \"Create link %s\", link.Path)\n-\t\t}\n+\tif err := e.extractSymlinks(ctx, links); err != nil {\n+\t\treturn err\n \t}\n \n \treturn nil"
        },
        {
          "filename": "extractor_test.go",
          "status": "modified",
          "additions": 166,
          "deletions": 5,
          "patch": "@@ -1,6 +1,8 @@\n package extract_test\n \n import (\n+\t\"archive/tar\"\n+\t\"archive/zip\"\n \t\"bytes\"\n \t\"context\"\n \t\"fmt\"\n@@ -65,7 +67,7 @@ func testArchive(t *testing.T, archivePath *paths.Path) {\n }\n \n func TestZipSlipHardening(t *testing.T) {\n-\t{\n+\tt.Run(\"ZipTraversal\", func(t *testing.T) {\n \t\tlogger := &LoggingFS{}\n \t\textractor := extract.Extractor{FS: logger}\n \t\tdata, err := os.Open(\"testdata/zipslip/evil.zip\")\n@@ -74,8 +76,9 @@ func TestZipSlipHardening(t *testing.T) {\n \t\trequire.NoError(t, data.Close())\n \t\tfmt.Print(logger)\n \t\trequire.Empty(t, logger.Journal)\n-\t}\n-\t{\n+\t})\n+\n+\tt.Run(\"TarTraversal\", func(t *testing.T) {\n \t\tlogger := &LoggingFS{}\n \t\textractor := extract.Extractor{FS: logger}\n \t\tdata, err := os.Open(\"testdata/zipslip/evil.tar\")\n@@ -84,9 +87,23 @@ func TestZipSlipHardening(t *testing.T) {\n \t\trequire.NoError(t, data.Close())\n \t\tfmt.Print(logger)\n \t\trequire.Empty(t, logger.Journal)\n-\t}\n+\t})\n+\n+\tt.Run(\"TarLinkTraversal\", func(t *testing.T) {\n+\t\tlogger := &LoggingFS{}\n+\t\textractor := extract.Extractor{FS: logger}\n+\t\tdata, err := os.Open(\"testdata/zipslip/evil-link-traversal.tar\")\n+\t\trequire.NoError(t, err)\n+\t\trequire.NoError(t, extractor.Tar(context.Background(), data, \"/tmp/test\", nil))\n+\t\trequire.NoError(t, data.Close())\n+\t\tfmt.Print(logger)\n+\t\trequire.Empty(t, logger.Journal)\n+\t})\n \n-\tif runtime.GOOS == \"windows\" {\n+\tt.Run(\"WindowsTarTraversal\", func(t *testing.T) {\n+\t\tif runtime.GOOS != \"windows\" {\n+\t\t\tt.Skip(\"Skipped on non-Windows host\")\n+\t\t}\n \t\tlogger := &LoggingFS{}\n \t\textractor := extract.Extractor{FS: logger}\n \t\tdata, err := os.Open(\"testdata/zipslip/evil-win.tar\")\n@@ -95,7 +112,151 @@ func TestZipSlipHardening(t *testing.T) {\n \t\trequire.NoError(t, data.Close())\n \t\tfmt.Print(logger)\n \t\trequire.Empty(t, logger.Journal)\n+\t})\n+}\n+\n+func mkTempDir(t *testing.T) *paths.Path {\n+\ttmp, err := paths.MkTempDir(\"\", \"test\")\n+\trequire.NoError(t, err)\n+\tt.Cleanup(func() { tmp.RemoveAll() })\n+\treturn tmp\n+}\n+\n+func TestSymLinkMazeHardening(t *testing.T) {\n+\taddTarSymlink := func(t *testing.T, tw *tar.Writer, new, old string) {\n+\t\terr := tw.WriteHeader(&tar.Header{\n+\t\t\tMode: 0o0777, Typeflag: tar.TypeSymlink, Name: new, Linkname: old,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t}\n+\taddZipSymlink := func(t *testing.T, zw *zip.Writer, new, old string) {\n+\t\th := &zip.FileHeader{Name: new, Method: zip.Deflate}\n+\t\th.SetMode(os.ModeSymlink)\n+\t\tw, err := zw.CreateHeader(h)\n+\t\trequire.NoError(t, err)\n+\t\t_, err = w.Write([]byte(old))\n+\t\trequire.NoError(t, err)\n \t}\n+\n+\tt.Run(\"TarWithSymlinkToAbsPath\", func(t *testing.T) {\n+\t\t// Create target dir\n+\t\ttmp := mkTempDir(t)\n+\t\ttargetDir := tmp.Join(\"test\")\n+\t\trequire.NoError(t, targetDir.Mkdir())\n+\n+\t\t// Make a tar archive with symlink maze\n+\t\toutputTar := bytes.NewBuffer(nil)\n+\t\ttw := tar.NewWriter(outputTar)\n+\t\taddTarSymlink(t, tw, \"aaa\", tmp.String())\n+\t\taddTarSymlink(t, tw, \"aaa/sym\", \"something\")\n+\t\trequire.NoError(t, tw.Close())\n+\n+\t\t// Run extract\n+\t\textractor := extract.Extractor{FS: &LoggingFS{}}\n+\t\trequire.Error(t, extractor.Tar(context.Background(), outputTar, targetDir.String(), nil))\n+\t\trequire.NoFileExists(t, tmp.Join(\"sym\").String())\n+\t})\n+\n+\tt.Run(\"ZipWithSymlinkToAbsPath\", func(t *testing.T) {\n+\t\t// Create target dir\n+\t\ttmp := mkTempDir(t)\n+\t\ttargetDir := tmp.Join(\"test\")\n+\t\trequire.NoError(t, targetDir.Mkdir())\n+\n+\t\t// Make a zip archive with symlink maze\n+\t\toutputZip := bytes.NewBuffer(nil)\n+\t\tzw := zip.NewWriter(outputZip)\n+\t\taddZipSymlink(t, zw, \"aaa\", tmp.String())\n+\t\taddZipSymlink(t, zw, \"aaa/sym\", \"something\")\n+\t\trequire.NoError(t, zw.Close())\n+\n+\t\t// Run extract\n+\t\textractor := extract.Extractor{FS: &LoggingFS{}}\n+\t\terr := extractor.Zip(context.Background(), outputZip, targetDir.String(), nil)\n+\t\trequire.NoFileExists(t, tmp.Join(\"sym\").String())\n+\t\trequire.Error(t, err)\n+\t})\n+\n+\tt.Run(\"TarWithSymlinkToRelativeExternalPath\", func(t *testing.T) {\n+\t\t// Create target dir\n+\t\ttmp := mkTempDir(t)\n+\t\ttargetDir := tmp.Join(\"test\")\n+\t\trequire.NoError(t, targetDir.Mkdir())\n+\t\tcheckDir := tmp.Join(\"secret\")\n+\t\trequire.NoError(t, checkDir.MkdirAll())\n+\n+\t\t// Make a tar archive with regular symlink maze\n+\t\toutputTar := bytes.NewBuffer(nil)\n+\t\ttw := tar.NewWriter(outputTar)\n+\t\taddTarSymlink(t, tw, \"aaa\", \"../secret\")\n+\t\taddTarSymlink(t, tw, \"aaa/sym\", \"something\")\n+\t\trequire.NoError(t, tw.Close())\n+\n+\t\textractor := extract.Extractor{FS: &LoggingFS{}}\n+\t\trequire.Error(t, extractor.Tar(context.Background(), outputTar, targetDir.String(), nil))\n+\t\trequire.NoFileExists(t, checkDir.Join(\"sym\").String())\n+\t})\n+\n+\tt.Run(\"TarWithSymlinkToInternalPath\", func(t *testing.T) {\n+\t\t// Create target dir\n+\t\ttmp := mkTempDir(t)\n+\t\ttargetDir := tmp.Join(\"test\")\n+\t\trequire.NoError(t, targetDir.Mkdir())\n+\n+\t\t// Make a tar archive with regular symlink maze\n+\t\toutputTar := bytes.NewBuffer(nil)\n+\t\ttw := tar.NewWriter(outputTar)\n+\t\trequire.NoError(t, tw.WriteHeader(&tar.Header{Mode: 0o0777, Typeflag: tar.TypeDir, Name: \"tmp\"}))\n+\t\taddTarSymlink(t, tw, \"aaa\", \"tmp\")\n+\t\taddTarSymlink(t, tw, \"aaa/sym\", \"something\")\n+\t\trequire.NoError(t, tw.Close())\n+\n+\t\textractor := extract.Extractor{FS: &LoggingFS{}}\n+\t\trequire.Error(t, extractor.Tar(context.Background(), outputTar, targetDir.String(), nil))\n+\t\trequire.NoFileExists(t, targetDir.Join(\"tmp\", \"sym\").String())\n+\t})\n+\n+\tt.Run(\"TarWithDoubleSymlinkToExternalPath\", func(t *testing.T) {\n+\t\t// Create target dir\n+\t\ttmp := mkTempDir(t)\n+\t\ttargetDir := tmp.Join(\"test\")\n+\t\trequire.NoError(t, targetDir.Mkdir())\n+\t\tfmt.Println(\"TMP:\", tmp)\n+\t\tfmt.Println(\"TARGET DIR:\", targetDir)\n+\n+\t\t// Make a tar archive with regular symlink maze\n+\t\toutputTar := bytes.NewBuffer(nil)\n+\t\ttw := tar.NewWriter(outputTar)\n+\t\ttw.WriteHeader(&tar.Header{Name: \"fake\", Mode: 0777, Typeflag: tar.TypeDir})\n+\t\taddTarSymlink(t, tw, \"sym-maze\", tmp.String())\n+\t\taddTarSymlink(t, tw, \"sym-maze\", \"fake\")\n+\t\taddTarSymlink(t, tw, \"sym-maze/oops\", \"/tmp/something\")\n+\t\trequire.NoError(t, tw.Close())\n+\n+\t\textractor := extract.Extractor{FS: &LoggingFS{}}\n+\t\trequire.Error(t, extractor.Tar(context.Background(), outputTar, targetDir.String(), nil))\n+\t\trequire.NoFileExists(t, tmp.Join(\"oops\").String())\n+\t})\n+\n+\tt.Run(\"TarWithSymlinkToExternalPathWithoutMazing\", func(t *testing.T) {\n+\t\t// Create target dir\n+\t\ttmp := mkTempDir(t)\n+\t\ttargetDir := tmp.Join(\"test\")\n+\t\trequire.NoError(t, targetDir.Mkdir())\n+\n+\t\t// Make a tar archive with valid symlink maze\n+\t\toutputTar := bytes.NewBuffer(nil)\n+\t\ttw := tar.NewWriter(outputTar)\n+\t\trequire.NoError(t, tw.WriteHeader(&tar.Header{Mode: 0o0777, Typeflag: tar.TypeDir, Name: \"tmp\"}))\n+\t\taddTarSymlink(t, tw, \"aaa\", \"../tmp\")\n+\t\trequire.NoError(t, tw.Close())\n+\n+\t\textractor := extract.Extractor{FS: &LoggingFS{}}\n+\t\trequire.NoError(t, extractor.Tar(context.Background(), outputTar, targetDir.String(), nil))\n+\t\tst, err := targetDir.Join(\"aaa\").Lstat()\n+\t\trequire.NoError(t, err)\n+\t\trequire.Equal(t, \"aaa\", st.Name())\n+\t})\n }\n \n // MockDisk is a disk that chroots to a directory"
        },
        {
          "filename": "loggingfs_test.go",
          "status": "modified",
          "additions": 43,
          "deletions": 18,
          "patch": "@@ -17,59 +17,84 @@ type LoggedOp struct {\n \tOldPath string\n \tMode    os.FileMode\n \tFlags   int\n+\tErr     error\n }\n \n func (op *LoggedOp) String() string {\n+\tres := \"\"\n \tswitch op.Op {\n \tcase \"link\":\n-\t\treturn fmt.Sprintf(\"link     %s -> %s\", op.Path, op.OldPath)\n+\t\tres += fmt.Sprintf(\"link     %s -> %s\", op.Path, op.OldPath)\n \tcase \"symlink\":\n-\t\treturn fmt.Sprintf(\"symlink  %s -> %s\", op.Path, op.OldPath)\n+\t\tres += fmt.Sprintf(\"symlink  %s -> %s\", op.Path, op.OldPath)\n \tcase \"mkdirall\":\n-\t\treturn fmt.Sprintf(\"mkdirall %v %s\", op.Mode, op.Path)\n+\t\tres += fmt.Sprintf(\"mkdirall %v %s\", op.Mode, op.Path)\n \tcase \"open\":\n-\t\treturn fmt.Sprintf(\"open     %v %s (flags=%04x)\", op.Mode, op.Path, op.Flags)\n+\t\tres += fmt.Sprintf(\"open     %v %s (flags=%04x)\", op.Mode, op.Path, op.Flags)\n \tcase \"remove\":\n-\t\treturn fmt.Sprintf(\"remove   %v\", op.Path)\n+\t\tres += fmt.Sprintf(\"remove   %v\", op.Path)\n+\tdefault:\n+\t\tpanic(\"unknown LoggedOP \" + op.Op)\n+\t}\n+\tif op.Err != nil {\n+\t\tres += \" error: \" + op.Err.Error()\n+\t} else {\n+\t\tres += \" success\"\n \t}\n-\tpanic(\"unknown LoggedOP \" + op.Op)\n+\treturn res\n }\n \n func (m *LoggingFS) Link(oldname, newname string) error {\n-\tm.Journal = append(m.Journal, &LoggedOp{\n+\terr := os.Link(oldname, newname)\n+\top := &LoggedOp{\n \t\tOp:      \"link\",\n \t\tOldPath: oldname,\n \t\tPath:    newname,\n-\t})\n-\treturn os.Link(oldname, newname)\n+\t\tErr:     err,\n+\t}\n+\tm.Journal = append(m.Journal, op)\n+\tfmt.Println(\"FS>\", op)\n+\treturn err\n }\n \n func (m *LoggingFS) MkdirAll(path string, perm os.FileMode) error {\n-\tm.Journal = append(m.Journal, &LoggedOp{\n+\terr := os.MkdirAll(path, perm)\n+\top := &LoggedOp{\n \t\tOp:   \"mkdirall\",\n \t\tPath: path,\n \t\tMode: perm,\n-\t})\n-\treturn os.MkdirAll(path, perm)\n+\t\tErr:  err,\n+\t}\n+\tm.Journal = append(m.Journal, op)\n+\tfmt.Println(\"FS>\", op)\n+\treturn err\n }\n \n func (m *LoggingFS) Symlink(oldname, newname string) error {\n-\tm.Journal = append(m.Journal, &LoggedOp{\n+\terr := os.Symlink(oldname, newname)\n+\top := &LoggedOp{\n \t\tOp:      \"symlink\",\n \t\tOldPath: oldname,\n \t\tPath:    newname,\n-\t})\n-\treturn os.Symlink(oldname, newname)\n+\t\tErr:     err,\n+\t}\n+\tm.Journal = append(m.Journal, op)\n+\tfmt.Println(\"FS>\", op)\n+\treturn err\n }\n \n func (m *LoggingFS) OpenFile(name string, flags int, perm os.FileMode) (*os.File, error) {\n-\tm.Journal = append(m.Journal, &LoggedOp{\n+\tf, err := os.OpenFile(name, flags, perm)\n+\top := &LoggedOp{\n \t\tOp:    \"open\",\n \t\tPath:  name,\n \t\tMode:  perm,\n \t\tFlags: flags,\n-\t})\n-\treturn os.OpenFile(os.DevNull, flags, perm)\n+\t\tErr:   err,\n+\t}\n+\tm.Journal = append(m.Journal, op)\n+\tfmt.Println(\"FS>\", op)\n+\treturn f, err\n }\n \n func (m *LoggingFS) Remove(path string) error {"
        },
        {
          "filename": "testdata/zipslip/evil-link-traversal.tar",
          "status": "added",
          "additions": 0,
          "deletions": 0,
          "patch": null
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 3,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "eaeff3236ebe82039553f39bc285ee5c79caae3c",
            "date": "2024-08-08T14:04:05Z",
            "author_login": "cmaglie"
          },
          {
            "sha": "99941958763c7206dd70d4aeed084d36acab7633",
            "date": "2024-08-08T13:52:19Z",
            "author_login": "cmaglie"
          },
          {
            "sha": "432fe339b8ead04414187ad0a9088587c19145ab",
            "date": "2024-03-01T14:42:07Z",
            "author_login": "chrissawer"
          },
          {
            "sha": "eeefea2a5a4c0e58a56e159696a22b311afeeae1",
            "date": "2024-01-24T16:12:34Z",
            "author_login": "chrissawer"
          },
          {
            "sha": "b540998c0914d0d83c6ed73f9ee0a20e6309c163",
            "date": "2024-01-23T17:05:24Z",
            "author_login": "chrissawer"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-22",
    "description": "Extract is aA Go library to extract archives in zip, tar.gz or tar.bz2 formats. A maliciously crafted archive may allow an attacker to create a symlink outside the extraction target directory. This vulnerability is fixed in 4.0.0. If you're using the Extractor.FS interface, then upgrading to /v4 will require to implement the new methods that have been added.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-11T17:15:04.450",
    "last_modified": "2024-11-22T19:30:48.913",
    "fix_date": "2024-08-08T08:42:49Z"
  },
  "references": [
    {
      "url": "https://github.com/codeclysm/extract/commit/4a98568021b8e289345c7f526ccbd7ed732cf286",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/codeclysm/extract/security/advisories/GHSA-8rm2-93mq-jqhc",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.135362",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "extract",
    "owner": "codeclysm",
    "created_at": "2016-08-26T08:51:43Z",
    "updated_at": "2024-11-22T06:05:39Z",
    "pushed_at": "2024-08-08T14:55:51Z",
    "size": 191,
    "stars": 48,
    "forks": 19,
    "open_issues": 5,
    "watchers": 48,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Go": 51248
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:20:39.727745"
  }
}