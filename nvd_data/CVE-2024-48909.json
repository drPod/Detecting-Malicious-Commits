{
  "cve_id": "CVE-2024-48909",
  "github_data": {
    "repository": "authzed/spicedb",
    "fix_commit": "2f3cf77a7fcfcb478ef5a480a245842c96ac8853",
    "related_commits": [
      "2f3cf77a7fcfcb478ef5a480a245842c96ac8853"
    ],
    "patch_url": "https://github.com/authzed/spicedb/commit/2f3cf77a7fcfcb478ef5a480a245842c96ac8853.patch",
    "fix_commit_details": {
      "sha": "2f3cf77a7fcfcb478ef5a480a245842c96ac8853",
      "commit_date": "2024-10-03T18:37:22Z",
      "author": {
        "login": "josephschorr",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Ensure caveat context is sent to all LR2 dispatches",
        "length": 51,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 247,
        "additions": 224,
        "deletions": 23
      },
      "files": [
        {
          "filename": "internal/dispatch/graph/lookupresources2_test.go",
          "status": "modified",
          "additions": 78,
          "deletions": 6,
          "patch": "@@ -11,6 +11,7 @@ import (\n \t\"github.com/ccoveille/go-safecast\"\n \t\"github.com/stretchr/testify/require\"\n \t\"go.uber.org/goleak\"\n+\t\"google.golang.org/protobuf/types/known/structpb\"\n \n \t\"github.com/authzed/spicedb/internal/datastore/memdb\"\n \t\"github.com/authzed/spicedb/internal/dispatch\"\n@@ -339,12 +340,14 @@ func TestMaxDepthLookup2(t *testing.T) {\n \n func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \ttestCases := []struct {\n-\t\tname                string\n-\t\tschema              string\n-\t\trelationships       []*core.RelationTuple\n-\t\tpermission          *core.RelationReference\n-\t\tsubject             *core.ObjectAndRelation\n-\t\texpectedResourceIDs []string\n+\t\tname                  string\n+\t\tschema                string\n+\t\trelationships         []*core.RelationTuple\n+\t\tpermission            *core.RelationReference\n+\t\tsubject               *core.ObjectAndRelation\n+\t\toptionalCaveatContext map[string]any\n+\t\texpectedResourceIDs   []string\n+\t\texpectedMissingFields []string\n \t}{\n \t\t{\n \t\t\t\"basic union\",\n@@ -361,7 +364,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 1510),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"basic exclusion\",\n@@ -375,7 +380,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\tgenTuples(\"document\", \"viewer\", \"user\", \"tom\", 1010),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 1010),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"basic intersection\",\n@@ -392,7 +399,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 510),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"union and excluded union\",\n@@ -411,7 +420,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 2450),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"basic caveats\",\n@@ -428,7 +439,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\tgenTuplesWithCaveat(\"document\", \"viewer\", \"user\", \"tom\", \"somecaveat\", map[string]any{\"somecondition\": 42}, 0, 2450),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 2450),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"excluded items\",\n@@ -445,7 +458,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 1210),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"basic caveats with missing field\",\n@@ -462,7 +477,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\tgenTuplesWithCaveat(\"document\", \"viewer\", \"user\", \"tom\", \"somecaveat\", map[string]any{}, 0, 2450),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 2450),\n+\t\t\t[]string{\"somecondition\"},\n \t\t},\n \t\t{\n \t\t\t\"larger arrow dispatch\",\n@@ -482,7 +499,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 150),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"big\",\n@@ -499,7 +518,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 15100),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"arrow under intersection\",\n@@ -523,7 +544,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 510),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"all arrow\",\n@@ -563,7 +586,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t},\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\t[]string{\"doc0\", \"doc1\", \"doc4\"},\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"indirect intersection and exclusion\",\n@@ -583,7 +608,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 1410),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"indirect intersections\",\n@@ -611,7 +638,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 1410),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"indirect over arrow\",\n@@ -639,7 +668,9 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 1410),\n+\t\t\tnil,\n \t\t},\n \t\t{\n \t\t\t\"root indirect with intermediate shearing\",\n@@ -675,7 +706,40 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t),\n \t\t\tRR(\"document\", \"view\"),\n \t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tnil,\n \t\t\tgenResourceIds(\"document\", 2000),\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"indirect caveats\",\n+\t\t\t`caveat somecaveat(somevalue int) {\n+\t\t\t\tsomevalue == 42\n+\t\t\t}\n+\n+\t\t\tdefinition user {}\n+\n+\t\t\tdefinition container {\n+\t\t\t\trelation access: user with somecaveat \n+\t\t\t\tpermission accesses = access\n+\t\t\t}\n+\n+\t\t\tdefinition document {\n+\t\t\t\trelation container: container\n+\t\t\t\trelation viewer: user with somecaveat\n+\t\t\t\tpermission view = viewer & container->accesses\n+\t\t\t}`,\n+\t\t\tjoinTuples(\n+\t\t\t\t[]*core.RelationTuple{\n+\t\t\t\t\ttuple.MustParse(\"container:somecontainer#access@user:tom[somecaveat]\"),\n+\t\t\t\t},\n+\t\t\t\tgenTuplesWithCaveat(\"document\", \"viewer\", \"user\", \"tom\", \"somecaveat\", map[string]any{}, 0, 2450),\n+\t\t\t\tgenTuples(\"document\", \"container\", \"container\", \"somecontainer\", 2450),\n+\t\t\t),\n+\t\t\tRR(\"document\", \"view\"),\n+\t\t\tONR(\"user\", \"tom\", \"...\"),\n+\t\t\tmap[string]any{\"somevalue\": 42},\n+\t\t\tgenResourceIds(\"document\", 2450),\n+\t\t\tnil,\n \t\t},\n \t}\n \n@@ -706,6 +770,12 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t\t\t\tuintPageSize, err := safecast.ToUint32(pageSize)\n \t\t\t\t\t\trequire.NoError(err)\n \n+\t\t\t\t\t\tvar caveatContext *structpb.Struct\n+\t\t\t\t\t\tif tc.optionalCaveatContext != nil {\n+\t\t\t\t\t\t\tcaveatContext, err = structpb.NewStruct(tc.optionalCaveatContext)\n+\t\t\t\t\t\t\trequire.NoError(err)\n+\t\t\t\t\t\t}\n+\n \t\t\t\t\t\terr = dispatcher.DispatchLookupResources2(&v1.DispatchLookupResources2Request{\n \t\t\t\t\t\t\tResourceRelation: tc.permission,\n \t\t\t\t\t\t\tSubjectRelation:  RR(tc.subject.Namespace, \"...\"),\n@@ -717,6 +787,7 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t\tOptionalLimit:  uintPageSize,\n \t\t\t\t\t\t\tOptionalCursor: currentCursor,\n+\t\t\t\t\t\t\tContext:        caveatContext,\n \t\t\t\t\t\t}, stream)\n \t\t\t\t\t\trequire.NoError(err)\n \n@@ -727,6 +798,7 @@ func TestLookupResources2OverSchemaWithCursors(t *testing.T) {\n \t\t\t\t\t\tfoundChunks = append(foundChunks, stream.Results())\n \n \t\t\t\t\t\tfor _, result := range stream.Results() {\n+\t\t\t\t\t\t\trequire.ElementsMatch(tc.expectedMissingFields, result.Resource.MissingContextParams)\n \t\t\t\t\t\t\tfoundResourceIDs.Insert(result.Resource.ResourceId)\n \t\t\t\t\t\t\tcurrentCursor = result.AfterResponseCursor\n \t\t\t\t\t\t}"
        },
        {
          "filename": "internal/graph/lookupresources2.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -612,6 +612,7 @@ func (crr *CursoredLookupResources2) redispatchOrReport(\n \t\t\t\t\t},\n \t\t\t\t\tOptionalCursor: ci.currentCursor,\n \t\t\t\t\tOptionalLimit:  parentRequest.OptionalLimit,\n+\t\t\t\t\tContext:        parentRequest.Context,\n \t\t\t\t}, stream)\n \t\t\t}\n "
        },
        {
          "filename": "internal/graph/lr2streams.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -227,6 +227,7 @@ func (rdc *checkAndDispatchRunner) runDispatch(\n \t\t},\n \t\tOptionalCursor: updatedCi.currentCursor,\n \t\tOptionalLimit:  rdc.ci.limits.currentLimit,\n+\t\tContext:        rdc.parentRequest.Context,\n \t}, wrappedStream)\n }\n "
        },
        {
          "filename": "internal/services/integrationtesting/consistency_test.go",
          "status": "modified",
          "additions": 45,
          "deletions": 15,
          "patch": "@@ -360,6 +360,8 @@ func requireSubsetOf(t *testing.T, found []string, expected []string) {\n // validateLookupResources ensures that a lookup resources call returns the expected objects and\n // only those expected.\n func validateLookupResources(t *testing.T, vctx validationContext) {\n+\t// Run a lookup resources for each resource type and ensure that the returned objects are those\n+\t// that are accessible to the subject.\n \ttestForEachResourceType(t, vctx, \"validate_lookup_resources\",\n \t\tfunc(t *testing.T, resourceRelation *core.RelationReference) {\n \t\t\tfor _, subject := range vctx.accessibilitySet.AllSubjectsNoWildcards() {\n@@ -375,7 +377,7 @@ func validateLookupResources(t *testing.T, vctx validationContext) {\n \t\t\t\t\t\t\tvar currentCursor *v1.Cursor\n \t\t\t\t\t\t\tresolvedResources := map[string]*v1.LookupResourcesResponse{}\n \t\t\t\t\t\t\tfor i := 0; i < 100; i++ {\n-\t\t\t\t\t\t\t\tfoundResources, lastCursor, err := vctx.serviceTester.LookupResources(context.Background(), resourceRelation, subject, vctx.revision, currentCursor, pageSize)\n+\t\t\t\t\t\t\t\tfoundResources, lastCursor, err := vctx.serviceTester.LookupResources(context.Background(), resourceRelation, subject, vctx.revision, currentCursor, pageSize, nil)\n \t\t\t\t\t\t\t\trequire.NoError(t, err)\n \n \t\t\t\t\t\t\t\tif pageSize > 0 {\n@@ -676,45 +678,73 @@ func runAssertions(t *testing.T, vctx validationContext) {\n \t\t\t\t\t\t\trequire.NoError(t, err)\n \t\t\t\t\t\t\trequire.Equal(t, entry.expectedPermissionship, permissionship, \"Assertion `%s` returned %s; expected %s\", tuple.MustString(rel), permissionship, entry.expectedPermissionship)\n \n-\t\t\t\t\t\t\t// Ensure the assertion passes LookupResources.\n-\t\t\t\t\t\t\tresolvedResources, _, err := vctx.serviceTester.LookupResources(context.Background(), &core.RelationReference{\n+\t\t\t\t\t\t\t// Ensure the assertion passes LookupResources with context, directly.\n+\t\t\t\t\t\t\tresolvedDirectResources, _, err := vctx.serviceTester.LookupResources(context.Background(), &core.RelationReference{\n \t\t\t\t\t\t\t\tNamespace: rel.ResourceAndRelation.Namespace,\n \t\t\t\t\t\t\t\tRelation:  rel.ResourceAndRelation.Relation,\n-\t\t\t\t\t\t\t}, rel.Subject, vctx.revision, nil, 0)\n+\t\t\t\t\t\t\t}, rel.Subject, vctx.revision, nil, 0, assertion.CaveatContext)\n \t\t\t\t\t\t\trequire.NoError(t, err)\n \n-\t\t\t\t\t\t\tresolvedResourcesMap := map[string]*v1.LookupResourcesResponse{}\n-\t\t\t\t\t\t\tfor _, resource := range resolvedResources {\n-\t\t\t\t\t\t\t\tresolvedResourcesMap[resource.ResourceObjectId] = resource\n+\t\t\t\t\t\t\tresolvedDirectResourcesMap := map[string]*v1.LookupResourcesResponse{}\n+\t\t\t\t\t\t\tfor _, resource := range resolvedDirectResources {\n+\t\t\t\t\t\t\t\tresolvedDirectResourcesMap[resource.ResourceObjectId] = resource\n \t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tresolvedResourceIds := maps.Keys(resolvedResourcesMap)\n+\t\t\t\t\t\t\t// Ensure the assertion passes LookupResources without context, indirectly.\n+\t\t\t\t\t\t\tresolvedIndirectResources, _, err := vctx.serviceTester.LookupResources(context.Background(), &core.RelationReference{\n+\t\t\t\t\t\t\t\tNamespace: rel.ResourceAndRelation.Namespace,\n+\t\t\t\t\t\t\t\tRelation:  rel.ResourceAndRelation.Relation,\n+\t\t\t\t\t\t\t}, rel.Subject, vctx.revision, nil, 0, nil)\n+\t\t\t\t\t\t\trequire.NoError(t, err)\n+\n+\t\t\t\t\t\t\tresolvedIndirectResourcesMap := map[string]*v1.LookupResourcesResponse{}\n+\t\t\t\t\t\t\tfor _, resource := range resolvedIndirectResources {\n+\t\t\t\t\t\t\t\tresolvedIndirectResourcesMap[resource.ResourceObjectId] = resource\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t// Check the assertion was returned for a direct (with context) lookup.\n+\t\t\t\t\t\t\tresolvedDirectResourceIds := maps.Keys(resolvedDirectResourcesMap)\n+\t\t\t\t\t\t\tswitch permissionship {\n+\t\t\t\t\t\t\tcase v1.CheckPermissionResponse_PERMISSIONSHIP_NO_PERMISSION:\n+\t\t\t\t\t\t\t\trequire.NotContains(t, resolvedDirectResourceIds, rel.ResourceAndRelation.ObjectId, \"Found unexpected object %s in direct lookup for assertion %s\", rel.ResourceAndRelation, rel)\n+\n+\t\t\t\t\t\t\tcase v1.CheckPermissionResponse_PERMISSIONSHIP_HAS_PERMISSION:\n+\t\t\t\t\t\t\t\trequire.Contains(t, resolvedDirectResourceIds, rel.ResourceAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n+\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_HAS_PERMISSION, resolvedDirectResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n+\n+\t\t\t\t\t\t\tcase v1.CheckPermissionResponse_PERMISSIONSHIP_CONDITIONAL_PERMISSION:\n+\t\t\t\t\t\t\t\trequire.Contains(t, resolvedDirectResourceIds, rel.ResourceAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n+\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION, resolvedDirectResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t// Check the assertion was returned for an indirect (without context) lookup.\n+\t\t\t\t\t\t\tresolvedIndirectResourceIds := maps.Keys(resolvedIndirectResourcesMap)\n \t\t\t\t\t\t\taccessibility, _, _ := vctx.accessibilitySet.AccessibiliyAndPermissionshipFor(rel.ResourceAndRelation, rel.Subject)\n \n \t\t\t\t\t\t\tswitch permissionship {\n \t\t\t\t\t\t\tcase v1.CheckPermissionResponse_PERMISSIONSHIP_NO_PERMISSION:\n \t\t\t\t\t\t\t\t// If the caveat context given is empty, then the lookup result must not exist at all.\n \t\t\t\t\t\t\t\t// Otherwise, it *could* be caveated or not exist, depending on the context given.\n \t\t\t\t\t\t\t\tif len(assertion.CaveatContext) == 0 {\n-\t\t\t\t\t\t\t\t\trequire.NotContains(t, resolvedResourceIds, rel.ResourceAndRelation.ObjectId, \"Found unexpected object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n+\t\t\t\t\t\t\t\t\trequire.NotContains(t, resolvedIndirectResourceIds, rel.ResourceAndRelation.ObjectId, \"Found unexpected object %s in indirect lookup for assertion %s\", rel.ResourceAndRelation, rel)\n \t\t\t\t\t\t\t\t} else if accessibility == consistencytestutil.NotAccessible {\n-\t\t\t\t\t\t\t\t\tfound, ok := resolvedResourcesMap[rel.ResourceAndRelation.ObjectId]\n+\t\t\t\t\t\t\t\t\tfound, ok := resolvedIndirectResourcesMap[rel.ResourceAndRelation.ObjectId]\n \t\t\t\t\t\t\t\t\trequire.True(t, !ok || found.Permissionship != v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_HAS_PERMISSION) // LookupResources can be caveated, since we didn't rerun LookupResources with the context\n \t\t\t\t\t\t\t\t} else if accessibility != consistencytestutil.NotAccessibleDueToPrespecifiedCaveat {\n-\t\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION, resolvedResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n+\t\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION, resolvedIndirectResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n \t\t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tcase v1.CheckPermissionResponse_PERMISSIONSHIP_HAS_PERMISSION:\n-\t\t\t\t\t\t\t\trequire.Contains(t, resolvedResourceIds, rel.ResourceAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n+\t\t\t\t\t\t\t\trequire.Contains(t, resolvedIndirectResourceIds, rel.ResourceAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n \t\t\t\t\t\t\t\t// If the caveat context given is empty, then the lookup result must be fully permissioned.\n \t\t\t\t\t\t\t\t// Otherwise, it *could* be caveated or fully permissioned, depending on the context given.\n \t\t\t\t\t\t\t\tif len(assertion.CaveatContext) == 0 {\n-\t\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_HAS_PERMISSION, resolvedResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n+\t\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_HAS_PERMISSION, resolvedIndirectResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n \t\t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tcase v1.CheckPermissionResponse_PERMISSIONSHIP_CONDITIONAL_PERMISSION:\n-\t\t\t\t\t\t\t\trequire.Contains(t, resolvedResourceIds, rel.ResourceAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n-\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION, resolvedResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n+\t\t\t\t\t\t\t\trequire.Contains(t, resolvedIndirectResourceIds, rel.ResourceAndRelation.ObjectId, \"Missing object %s in lookup for assertion %s\", rel.ResourceAndRelation, rel)\n+\t\t\t\t\t\t\t\trequire.Equal(t, v1.LookupPermissionship_LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION, resolvedIndirectResourcesMap[rel.ResourceAndRelation.ObjectId].Permissionship)\n \n \t\t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\t\tpanic(\"unknown permissionship\")"
        },
        {
          "filename": "internal/services/integrationtesting/consistencytestutil/servicetester.go",
          "status": "modified",
          "additions": 12,
          "deletions": 2,
          "patch": "@@ -28,7 +28,7 @@ type ServiceTester interface {\n \tExpand(ctx context.Context, resource *core.ObjectAndRelation, atRevision datastore.Revision) (*core.RelationTupleTreeNode, error)\n \tWrite(ctx context.Context, relationship *core.RelationTuple) error\n \tRead(ctx context.Context, namespaceName string, atRevision datastore.Revision) ([]*core.RelationTuple, error)\n-\tLookupResources(ctx context.Context, resourceRelation *core.RelationReference, subject *core.ObjectAndRelation, atRevision datastore.Revision, cursor *v1.Cursor, limit uint32) ([]*v1.LookupResourcesResponse, *v1.Cursor, error)\n+\tLookupResources(ctx context.Context, resourceRelation *core.RelationReference, subject *core.ObjectAndRelation, atRevision datastore.Revision, cursor *v1.Cursor, limit uint32, caveatContext map[string]any) ([]*v1.LookupResourcesResponse, *v1.Cursor, error)\n \tLookupSubjects(ctx context.Context, resource *core.ObjectAndRelation, subjectRelation *core.RelationReference, atRevision datastore.Revision, caveatContext map[string]any) (map[string]*v1.LookupSubjectsResponse, error)\n \t// NOTE: ExperimentalService/BulkCheckPermission has been promoted to PermissionsService/CheckBulkPermissions\n \tBulkCheck(ctx context.Context, items []*v1.BulkCheckPermissionRequestItem, atRevision datastore.Revision) ([]*v1.BulkCheckPermissionPair, error)\n@@ -153,7 +153,16 @@ func (v1st v1ServiceTester) Read(_ context.Context, namespaceName string, atRevi\n \treturn tuples, nil\n }\n \n-func (v1st v1ServiceTester) LookupResources(_ context.Context, resourceRelation *core.RelationReference, subject *core.ObjectAndRelation, atRevision datastore.Revision, cursor *v1.Cursor, limit uint32) ([]*v1.LookupResourcesResponse, *v1.Cursor, error) {\n+func (v1st v1ServiceTester) LookupResources(_ context.Context, resourceRelation *core.RelationReference, subject *core.ObjectAndRelation, atRevision datastore.Revision, cursor *v1.Cursor, limit uint32, caveatContext map[string]any) ([]*v1.LookupResourcesResponse, *v1.Cursor, error) {\n+\tvar builtContext *structpb.Struct\n+\tif caveatContext != nil {\n+\t\tbuilt, err := structpb.NewStruct(caveatContext)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tbuiltContext = built\n+\t}\n+\n \tlookupResp, err := v1st.permClient.LookupResources(context.Background(), &v1.LookupResourcesRequest{\n \t\tResourceObjectType: resourceRelation.Namespace,\n \t\tPermission:         resourceRelation.Relation,\n@@ -171,6 +180,7 @@ func (v1st v1ServiceTester) LookupResources(_ context.Context, resourceRelation\n \t\t},\n \t\tOptionalLimit:  limit,\n \t\tOptionalCursor: cursor,\n+\t\tContext:        builtContext,\n \t})\n \tif err != nil {\n \t\treturn nil, nil, err"
        },
        {
          "filename": "internal/services/integrationtesting/testconfigs/caveatlr.yaml",
          "status": "added",
          "additions": 29,
          "deletions": 0,
          "patch": "@@ -0,0 +1,29 @@\n+---\n+schema: |+\n+  caveat unexpired(expires_at timestamp, now timestamp) {\n+    now < expires_at\n+  }\n+\n+  definition user {}\n+\n+  definition container {\n+    relation access: user with unexpired \n+    permission accesses = access\n+  }\n+\n+  definition resource {\n+    relation container: container\n+    relation viewer: user with unexpired\n+    permission viewers = viewer & container->accesses\n+  }\n+relationships: |-\n+  resource:someresource#container@container:somecontainer\n+  resource:someresource#viewer@user:tom[unexpired:{\"expires_at\":\"2024-10-03T14:16:30.776734Z\"}]\n+  container:somecontainer#access@user:fred[unexpired:{\"expires_at\":\"2024-01-01T00:00:00Z\"}]\n+  container:somecontainer#access@user:tom[unexpired:{\"expires_at\":\"2024-10-03T07:16:28.068632-07:00\"}]\n+  container:somecontainer#access@user:sarah[unexpired:{\"expires_at\":\"2024-10-03T07:16:28.068632-07:00\"}]\n+assertions:\n+  assertTrue:\n+    - 'resource:someresource#viewers@user:tom with {\"now\": \"2023-01-01T00:00:00Z\"}'\n+  assertFalse:\n+    - 'resource:someresource#viewers@user:tom with {\"now\": \"2025-01-01T00:00:00Z\"}'"
        },
        {
          "filename": "internal/services/integrationtesting/testconfigs/caveatunderarrow.yaml",
          "status": "added",
          "additions": 25,
          "deletions": 0,
          "patch": "@@ -0,0 +1,25 @@\n+---\n+schema: |+\n+  definition user {}\n+\n+  caveat some_caveat(somevalue int) {\n+    somevalue == 42\n+  }\n+\n+  definition team {\n+    relation member: user with some_caveat\n+  }\n+\n+  definition document {\n+    relation viewer: team#member with some_caveat\n+    permission view = viewer->member\n+  }\n+\n+relationships: |-\n+  team:first#member@user:tom[some_caveat]\n+  document:firstdoc#viewer@team:first#member[some_caveat]\n+assertions:\n+  assertTrue:\n+    - 'document:firstdoc#view@user:tom with {\"somevalue\": 42}'\n+  assertFalse:\n+    - 'document:firstdoc#view@user:tom with {\"somevalue\": 41}'"
        },
        {
          "filename": "internal/services/integrationtesting/testconfigs/caveatunderintersect.yaml",
          "status": "added",
          "additions": 33,
          "deletions": 0,
          "patch": "@@ -0,0 +1,33 @@\n+---\n+schema: |+\n+  definition user {}\n+\n+  caveat some_caveat(somevalue int) {\n+    somevalue == 42\n+  }\n+\n+  definition team {\n+    relation member: user with some_caveat\n+  }\n+\n+  definition document {\n+    relation viewer: team#member with some_caveat\n+    relation editor: team#member with some_caveat\n+    relation admin: team#member with some_caveat\n+\n+    permission inner_view = viewer & editor\n+    permission view = inner_view & admin\n+  }\n+\n+relationships: |-\n+  team:first#member@user:tom[some_caveat]\n+  team:second#member@user:tom[some_caveat]\n+  team:third#member@user:tom[some_caveat]\n+  document:firstdoc#viewer@team:first#member[some_caveat]\n+  document:firstdoc#editor@team:second#member[some_caveat]\n+  document:firstdoc#admin@team:third#member[some_caveat]\n+assertions:\n+  assertTrue:\n+    - 'document:firstdoc#view@user:tom with {\"somevalue\": 42}'\n+  assertFalse:\n+    - 'document:firstdoc#view@user:tom with {\"somevalue\": 41}'"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 3,
        "dependency_files": 0,
        "test_files": 6,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "db2cf0146d7b2a1bf7c8b838acf91cde019b9445",
            "date": "2025-01-14T18:25:51Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "75390a9b4c3492bbd14c1df2e50209e285be5831",
            "date": "2025-01-08T23:45:38Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "3bbf45766ed519c53ff802619a032e58e2af57a7",
            "date": "2025-01-13T22:44:38Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "3e257e6c4207721f8ae421ec1424f96c0c60279b",
            "date": "2025-01-11T22:06:12Z",
            "author_login": "josephschorr"
          },
          {
            "sha": "fabeff191dec15fae327c896a9f40e095fde5e49",
            "date": "2025-01-10T22:22:57Z",
            "author_login": "josephschorr"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 2.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-172",
    "description": "SpiceDB is an open source database for scalably storing and querying fine-grained authorization data. Starting in version 1.35.0 and prior to version 1.37.1, clients that have enabled `LookupResources2` and have caveats in the evaluation path for their requests can return a permissionship of `CONDITIONAL` with context marked as missing, even then the context was supplied. LookupResources2 is the new default in SpiceDB 1.37.0 and has been opt-in since SpiceDB 1.35.0. The bug is patched as part of SpiceDB 1.37.1. As a workaround, disable LookupResources2 via the `--enable-experimental-lookup-resources` flag by setting it to `false`.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-10-14T21:15:12.080",
    "last_modified": "2024-10-17T17:56:11.130",
    "fix_date": "2024-10-03T18:37:22Z"
  },
  "references": [
    {
      "url": "https://github.com/authzed/spicedb/commit/2f3cf77a7fcfcb478ef5a480a245842c96ac8853",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/authzed/spicedb/security/advisories/GHSA-3c32-4hq9-6wgj",
      "source": "security-advisories@github.com",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.145238",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "spicedb",
    "owner": "authzed",
    "created_at": "2021-08-16T15:32:09Z",
    "updated_at": "2025-01-14T00:07:27Z",
    "pushed_at": "2025-01-13T22:53:04Z",
    "size": 19045,
    "stars": 5286,
    "forks": 286,
    "open_issues": 107,
    "watchers": 5286,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 4522371,
      "JavaScript": 16612,
      "HTML": 3663,
      "Dockerfile": 1564
    },
    "commit_activity": {
      "total_commits_last_year": 625,
      "avg_commits_per_week": 12.01923076923077,
      "days_active_last_year": 208
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T12:56:47.808291"
  }
}