{
  "cve_id": "CVE-2024-49214",
  "github_data": {
    "repository": "haproxy/haproxy",
    "fix_commit": "f627b9272bd8ffca6f2f898bfafc6bf0b84b7d46",
    "related_commits": [
      "f627b9272bd8ffca6f2f898bfafc6bf0b84b7d46"
    ],
    "patch_url": "https://github.com/haproxy/haproxy/commit/f627b9272bd8ffca6f2f898bfafc6bf0b84b7d46.patch",
    "fix_commit_details": {
      "sha": "f627b9272bd8ffca6f2f898bfafc6bf0b84b7d46",
      "commit_date": "2024-08-30T13:38:54Z",
      "author": {
        "login": "haproxyFred",
        "type": "User",
        "stats": {
          "total_commits": 1229,
          "average_weekly_commits": 1.096342551293488,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 229
        }
      },
      "commit_message": {
        "title": "BUG/MEDIUM: quic: always validate sender address on 0-RTT",
        "length": 3737,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 157,
        "additions": 142,
        "deletions": 15
      },
      "files": [
        {
          "filename": "include/haproxy/quic_conn-t.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -445,6 +445,8 @@ struct quic_conn_closed {\n #define QUIC_FL_CONN_IPKTNS_DCD                  (1U << 15) /* Initial packet number space discarded  */\n #define QUIC_FL_CONN_HPKTNS_DCD                  (1U << 16) /* Handshake packet number space discarded  */\n #define QUIC_FL_CONN_PEER_VALIDATED_ADDR         (1U << 17) /* Peer address is considered as validated for this connection. */\n+#define QUIC_FL_CONN_NO_TOKEN_RCVD               (1U << 18) /* Client dit not send any token */\n+#define QUIC_FL_CONN_SEND_RETRY                  (1U << 19) /* A send retry packet must be sent */\n /* gap here */\n #define QUIC_FL_CONN_TO_KILL                     (1U << 24) /* Unusable connection, to be killed */\n #define QUIC_FL_CONN_TX_TP_RECEIVED              (1U << 25) /* Peer transport parameters have been received (used for the transmitting part) */"
        },
        {
          "filename": "src/quic_conn.c",
          "status": "modified",
          "additions": 60,
          "deletions": 5,
          "patch": "@@ -57,6 +57,7 @@\n #include <haproxy/quic_sock.h>\n #include <haproxy/quic_stats.h>\n #include <haproxy/quic_stream.h>\n+#include <haproxy/quic_token.h>\n #include <haproxy/quic_tp.h>\n #include <haproxy/quic_trace.h>\n #include <haproxy/quic_tx.h>\n@@ -479,6 +480,30 @@ int quic_build_post_handshake_frames(struct quic_conn *qc)\n \t\t}\n \n \t\tLIST_APPEND(&frm_list, &frm->list);\n+\n+#ifdef HAVE_SSL_0RTT_QUIC\n+\t\tif (qc->li->bind_conf->ssl_conf.early_data) {\n+\t\t\tsize_t new_token_frm_len;\n+\n+\t\t\tfrm = qc_frm_alloc(QUIC_FT_NEW_TOKEN);\n+\t\t\tif (!frm) {\n+\t\t\t\tTRACE_ERROR(\"frame allocation error\", QUIC_EV_CONN_IO_CB, qc);\n+\t\t\t\tgoto leave;\n+\t\t\t}\n+\n+\t\t\tnew_token_frm_len =\n+\t\t\t\tquic_generate_token(frm->new_token.data,\n+\t\t\t\t                    sizeof(frm->new_token.data), &qc->peer_addr);\n+\t\t\tif (!new_token_frm_len) {\n+\t\t\t\tTRACE_ERROR(\"token generation failed\", QUIC_EV_CONN_IO_CB, qc);\n+\t\t\t\tgoto leave;\n+\t\t\t}\n+\n+\t\t\tBUG_ON(new_token_frm_len != sizeof(frm->new_token.data));\n+\t\t\tfrm->new_token.len = new_token_frm_len;\n+\t\t\tLIST_APPEND(&frm_list, &frm->list);\n+\t\t}\n+#endif\n \t}\n \n \t/* Initialize <max> connection IDs minus one: there is\n@@ -761,6 +786,11 @@ struct task *quic_conn_io_cb(struct task *t, void *context, unsigned int state)\n \t\tHA_ATOMIC_AND(&tl->state, ~TASK_HEAVY);\n \t}\n \n+\tif (qc->flags & QUIC_FL_CONN_TO_KILL) {\n+\t\tTRACE_DEVEL(\"connection to be killed\", QUIC_EV_CONN_PHPKTS, qc);\n+\t\tgoto out;\n+\t}\n+\n \t/* Retranmissions */\n \tif (qc->flags & QUIC_FL_CONN_RETRANS_NEEDED) {\n \t\tTRACE_DEVEL(\"retransmission needed\", QUIC_EV_CONN_PHPKTS, qc);\n@@ -862,7 +892,25 @@ struct task *quic_conn_io_cb(struct task *t, void *context, unsigned int state)\n \t\tquic_nictx_free(qc);\n \t}\n \n-\tif ((qc->flags & QUIC_FL_CONN_CLOSING) && qc->mux_state != QC_MUX_READY) {\n+\tif (qc->flags & QUIC_FL_CONN_SEND_RETRY) {\n+\t\tstruct quic_counters *prx_counters;\n+\t\tstruct proxy *prx = qc->li->bind_conf->frontend;\n+\t\tstruct quic_rx_packet pkt = {\n+\t\t\t.scid = qc->dcid,\n+\t\t\t.dcid = qc->odcid,\n+\t\t};\n+\n+\t\tprx_counters = EXTRA_COUNTERS_GET(prx->extra_counters_fe, &quic_stats_module);\n+\t\tif (send_retry(qc->li->rx.fd, &qc->peer_addr, &pkt, qc->original_version)) {\n+\t\t\tTRACE_ERROR(\"Error during Retry generation\",\n+\t\t\t            QUIC_EV_CONN_LPKT, NULL, NULL, NULL, qc->original_version);\n+\t\t}\n+\t\telse\n+\t\t\tHA_ATOMIC_INC(&prx_counters->retry_sent);\n+\t}\n+\n+\tif ((qc->flags & (QUIC_FL_CONN_CLOSING|QUIC_FL_CONN_TO_KILL)) &&\n+\t    qc->mux_state != QC_MUX_READY) {\n \t\tquic_conn_release(qc);\n \t\tqc = NULL;\n \t}\n@@ -969,11 +1017,15 @@ struct task *qc_process_timer(struct task *task, void *ctx, unsigned int state)\n  * for QUIC servers (or haproxy listeners).\n  * <dcid> is the destination connection ID, <scid> is the source connection ID.\n  * This latter <scid> CID as the same value on the wire as the one for <conn_id>\n- * which is the first CID of this connection but a different internal representation used to build\n+ * which is the first CID of this connection but a different internal\n+ * representation used to build\n  * NEW_CONNECTION_ID frames. This is the responsibility of the caller to insert\n  * <conn_id> in the CIDs tree for this connection (qc->cids).\n- * <token> is the token found to be used for this connection with <token_len> as\n- * length. Endpoints addresses are specified via <local_addr> and <peer_addr>.\n+ * <token> is a boolean denoting if a token was received for this connection\n+ * from an Initial packet.\n+ * <token_odcid> is the original destination connection ID which was embedded\n+ * into the Retry token sent to the client before instantiated this connection.\n+ * Endpoints addresses are specified via <local_addr> and <peer_addr>.\n  * Returns the connection if succeeded, NULL if not.\n  */\n struct quic_conn *qc_new_conn(const struct quic_version *qv, int ipv4,\n@@ -1080,6 +1132,9 @@ struct quic_conn *qc_new_conn(const struct quic_version *qv, int ipv4,\n \t\tqc->prx_counters = EXTRA_COUNTERS_GET(prx->extra_counters_fe,\n \t\t                                      &quic_stats_module);\n \t\tqc->flags = QUIC_FL_CONN_LISTENER;\n+\t\t/* Mark this connection as having not received any token when 0-RTT is enabled. */\n+\t\tif (l->bind_conf->ssl_conf.early_data && !token)\n+\t\t\tqc->flags |= QUIC_FL_CONN_NO_TOKEN_RCVD;\n \t\tqc->state = QUIC_HS_ST_SERVER_INITIAL;\n \t\t/* Copy the client original DCID. */\n \t\tqc->odcid = *dcid;\n@@ -1102,7 +1157,7 @@ struct quic_conn *qc_new_conn(const struct quic_version *qv, int ipv4,\n \t/* If connection is instantiated due to an INITIAL packet with an\n \t * already checked token, consider the peer address as validated.\n \t */\n-\tif (token_odcid->len) {\n+\tif (token) {\n \t\tTRACE_STATE(\"validate peer address due to initial token\",\n \t\t            QUIC_EV_CONN_INIT, qc);\n \t\tqc->flags |= QUIC_FL_CONN_PEER_VALIDATED_ADDR;"
        },
        {
          "filename": "src/quic_retry.c",
          "status": "modified",
          "additions": 1,
          "deletions": 7,
          "patch": "@@ -258,17 +258,11 @@ int quic_retry_token_check(struct quic_rx_packet *pkt,\n \tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n \n \t/* The caller must ensure this. */\n-\tBUG_ON(!pkt->token_len);\n+\tBUG_ON(!pkt->token_len || *pkt->token != QUIC_TOKEN_FMT_RETRY);\n \n \tprx = l->bind_conf->frontend;\n \tprx_counters = EXTRA_COUNTERS_GET(prx->extra_counters_fe, &quic_stats_module);\n \n-\tif (*pkt->token != QUIC_TOKEN_FMT_RETRY) {\n-\t\t/* TODO: New token check */\n-\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n-\t\tgoto leave;\n-\t}\n-\n \tif (sizeof buf < tokenlen) {\n \t\tTRACE_ERROR(\"too short buffer\", QUIC_EV_CONN_LPKT, qc);\n \t\tgoto err;"
        },
        {
          "filename": "src/quic_rx.c",
          "status": "modified",
          "additions": 60,
          "deletions": 2,
          "patch": "@@ -27,6 +27,7 @@\n #include <haproxy/quic_stream.h>\n #include <haproxy/quic_ssl.h>\n #include <haproxy/quic_tls.h>\n+#include <haproxy/quic_token.h>\n #include <haproxy/quic_trace.h>\n #include <haproxy/quic_tx.h>\n #include <haproxy/ssl_sock.h>\n@@ -1522,6 +1523,47 @@ static inline int quic_padding_check(const unsigned char *pos,\n \treturn pos == end;\n }\n \n+/* Validate the token, retry or not (provided by NEW_TOKEN) parsed into\n+ * <pkt> RX packet from <dgram> datagram.\n+ * Return 1 if succeded, 0 if not.\n+ */\n+static inline int quic_token_validate(struct quic_rx_packet *pkt,\n+                                      struct quic_dgram *dgram,\n+                                      struct listener *l, struct quic_conn *qc,\n+                                      struct quic_cid *odcid)\n+{\n+\tint ret = 0;\n+\n+\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n+\n+\tswitch (*pkt->token) {\n+\tcase QUIC_TOKEN_FMT_RETRY:\n+\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n+\t\tbreak;\n+\tcase QUIC_TOKEN_FMT_NEW:\n+\t\tret = quic_token_check(pkt, dgram, qc);\n+\t\tif (!ret) {\n+\t\t\t/* Fallback to a retry token in case of any error. */\n+\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n+\t\t}\n+\t\tbreak;\n+\tdefault:\n+\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n+\t\tbreak;\n+\t}\n+\n+\tif (!ret)\n+\t\tgoto err;\n+\n+\tret = 1;\n+ leave:\n+\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n+\treturn ret;\n+ err:\n+\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n+\tgoto leave;\n+}\n+\n /* Find the associated connection to the packet <pkt> or create a new one if\n  * this is an Initial packet. <dgram> is the datagram containing the packet and\n  * <l> is the listener instance on which it was received.\n@@ -1581,9 +1623,25 @@ static struct quic_conn *quic_rx_pkt_retrieve_conn(struct quic_rx_packet *pkt,\n \t\t\t}\n \n \t\t\tif (pkt->token_len) {\n-\t\t\t\t/* Validate the token only when connection is unknown. */\n-\t\t\t\tif (!quic_retry_token_check(pkt, dgram, l, qc, &token_odcid))\n+\t\t\t\tTRACE_PROTO(\"Initial with token\", QUIC_EV_CONN_LPKT, NULL, NULL, NULL, pkt->version);\n+\t\t\t\t/* Validate the token, retry or not only when connection is unknown. */\n+\t\t\t\tif (!quic_token_validate(pkt, dgram, l, qc, &token_odcid)) {\n+\t\t\t\t\tif (dgram->flags & QUIC_DGRAM_FL_SEND_RETRY) {\n+\t\t\t\t\t\tif (send_retry(l->rx.fd, &dgram->saddr, pkt, pkt->version)) {\n+\t\t\t\t\t\t\tTRACE_ERROR(\"Error during Retry generation\",\n+\t\t\t\t\t\t\t            QUIC_EV_CONN_LPKT, NULL, NULL, NULL, pkt->version);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tHA_ATOMIC_INC(&prx_counters->retry_sent);\n+\n+\t\t\t\t\t\tgoto out;\n+\t\t\t\t\t}\n+\n \t\t\t\t\tgoto err;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tTRACE_PROTO(\"Initial without token\", QUIC_EV_CONN_LPKT, NULL, NULL, NULL, pkt->version);\n \t\t\t}\n \n \t\t\tif (!quic_init_exec_rules(l, dgram)) {"
        },
        {
          "filename": "src/quic_ssl.c",
          "status": "modified",
          "additions": 19,
          "deletions": 1,
          "patch": "@@ -353,6 +353,23 @@ static int ha_quic_add_handshake_data(SSL *ssl, enum ssl_encryption_level_t leve\n \n \tTRACE_ENTER(QUIC_EV_CONN_ADDDATA, qc);\n \n+\tTRACE_PROTO(\"ha_quic_add_handshake_data() called\", QUIC_EV_CONN_IO_CB, qc, NULL, ssl);\n+\n+#ifdef HAVE_SSL_0RTT_QUIC\n+\t/* Detect asap if some 0-RTT data were accepted for this connection.\n+\t * If this is the case and no token was provided, interrupt the useless\n+\t * secrets derivations. A Retry packet must be sent, and this connection\n+\t * must be killed.\n+\t * Note that QUIC_FL_CONN_NO_TOKEN_RCVD is possibly set only for when 0-RTT is\n+\t * enabled for the connection.\n+\t */\n+\tif ((qc->flags & QUIC_FL_CONN_NO_TOKEN_RCVD) && qc_ssl_eary_data_accepted(ssl)) {\n+\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n+\t\tqc->flags |= QUIC_FL_CONN_TO_KILL|QUIC_FL_CONN_SEND_RETRY;\n+\t\tgoto leave;\n+\t}\n+#endif\n+\n \tif (qc->flags & QUIC_FL_CONN_TO_KILL) {\n \t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n \t\tgoto out;\n@@ -533,9 +550,10 @@ static int qc_ssl_provide_quic_data(struct ncbuf *ncbuf,\n \tstate = qc->state;\n \tif (state < QUIC_HS_ST_COMPLETE) {\n \t\tssl_err = SSL_do_handshake(ctx->ssl);\n+\t\tTRACE_PROTO(\"SSL_do_handshake() called\", QUIC_EV_CONN_IO_CB, qc, NULL, ctx->ssl);\n \n \t\tif (qc->flags & QUIC_FL_CONN_TO_KILL) {\n-\t\t\tTRACE_DEVEL(\"connection to be killed\", QUIC_EV_CONN_IO_CB, qc);\n+\t\t\tTRACE_DEVEL(\"connection to be killed\", QUIC_EV_CONN_IO_CB, qc, &state, ctx->ssl);\n \t\t\tgoto leave;\n \t\t}\n "
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "8919a80da9391e348aa325b44fdae40a35f48dcf",
            "date": "2025-01-14T10:18:24Z",
            "author_login": "Darlelet"
          },
          {
            "sha": "f399dbf70c658107ab0a94a403c26547f6ecea15",
            "date": "2025-01-10T22:56:34Z",
            "author_login": "Darlelet"
          },
          {
            "sha": "4a5d82a97d9269eb17f9b92af6c8a9cd904705cd",
            "date": "2025-01-07T17:22:00Z",
            "author_login": "a-denoyelle"
          },
          {
            "sha": "a2c0c459a4b5e870b64ad6c6393fcd04c5529997",
            "date": "2025-01-07T17:29:23Z",
            "author_login": "a-denoyelle"
          },
          {
            "sha": "a50dd07c16fcca41e7491203aa2c9b20ed8f65b5",
            "date": "2025-01-07T16:57:54Z",
            "author_login": "a-denoyelle"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-290",
    "description": "QUIC in HAProxy 3.1.x before 3.1-dev7, 3.0.x before 3.0.5, and 2.9.x before 2.9.11 allows opening a 0-RTT session with a spoofed IP address. This can bypass the IP allow/block list functionality.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-14T04:15:05.853",
    "last_modified": "2024-10-29T16:35:14.877",
    "fix_date": "2024-08-30T13:38:54Z"
  },
  "references": [
    {
      "url": "https://github.com/haproxy/haproxy/commit/f627b9272bd8ffca6f2f898bfafc6bf0b84b7d46",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.haproxy.org/download/2.9/src/CHANGELOG",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.haproxy.org/download/3.0/src/CHANGELOG",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.haproxy.org/download/3.1/src/CHANGELOG",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.mail-archive.com/haproxy%40formilux.org/msg45291.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.mail-archive.com/haproxy%40formilux.org/msg45314.html",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://www.mail-archive.com/haproxy%40formilux.org/msg45315.html",
      "source": "cve@mitre.org",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:02.141039",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "haproxy",
    "owner": "haproxy",
    "created_at": "2018-04-09T15:17:42Z",
    "updated_at": "2025-01-14T10:41:36Z",
    "pushed_at": "2025-01-14T10:41:32Z",
    "size": 99581,
    "stars": 5154,
    "forks": 811,
    "open_issues": 287,
    "watchers": 5154,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "C": 12058913,
      "C++": 253639,
      "Shell": 108063,
      "Makefile": 68421,
      "Python": 20645,
      "Lua": 16599,
      "Vim Script": 7696,
      "GDB": 7397,
      "SmPL": 6462,
      "Perl": 5554,
      "HTML": 44
    },
    "commit_activity": {
      "total_commits_last_year": 2213,
      "avg_commits_per_week": 42.55769230769231,
      "days_active_last_year": 283
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:33:33.007336"
  }
}