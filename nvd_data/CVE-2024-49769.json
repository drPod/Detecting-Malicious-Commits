{
  "cve_id": "CVE-2024-49769",
  "github_data": {
    "repository": "Pylons/waitress",
    "fix_commit": "1ae4e894c9f76543bee06584001583fc6fa8c95c",
    "related_commits": [
      "1ae4e894c9f76543bee06584001583fc6fa8c95c"
    ],
    "patch_url": "https://github.com/Pylons/waitress/commit/1ae4e894c9f76543bee06584001583fc6fa8c95c.patch",
    "fix_commit_details": {
      "sha": "1ae4e894c9f76543bee06584001583fc6fa8c95c",
      "commit_date": "2024-06-08T21:51:06Z",
      "author": {
        "login": "digitalresistor",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #435 from Pylons/bugfix/remove-race-condition",
        "length": 117,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 185,
        "additions": 26,
        "deletions": 159
      },
      "files": [
        {
          "filename": "src/waitress/channel.py",
          "status": "modified",
          "additions": 1,
          "deletions": 8,
          "patch": "@@ -67,8 +67,7 @@ def __init__(self, server, sock, addr, adj, map=None):\n         self.outbuf_lock = threading.Condition()\n \n         wasyncore.dispatcher.__init__(self, sock, map=map)\n-\n-        # Don't let wasyncore.dispatcher throttle self.addr on us.\n+        self.connected = True\n         self.addr = addr\n         self.requests = []\n \n@@ -92,13 +91,7 @@ def handle_write(self):\n         # Precondition: there's data in the out buffer to be sent, or\n         # there's a pending will_close request\n \n-        if not self.connected:\n-            # we dont want to close the channel twice\n-\n-            return\n-\n         # try to flush any pending output\n-\n         if not self.requests:\n             # 1. There are no running tasks, so we don't need to try to lock\n             #    the outbuf before sending"
        },
        {
          "filename": "src/waitress/wasyncore.py",
          "status": "modified",
          "additions": 7,
          "deletions": 62,
          "patch": "@@ -297,22 +297,6 @@ def __init__(self, sock=None, map=None):\n             # get a socket from a blocking source.\n             sock.setblocking(0)\n             self.set_socket(sock, map)\n-            self.connected = True\n-            # The constructor no longer requires that the socket\n-            # passed be connected.\n-            try:\n-                self.addr = sock.getpeername()\n-            except OSError as err:\n-                if err.args[0] in (ENOTCONN, EINVAL):\n-                    # To handle the case where we got an unconnected\n-                    # socket.\n-                    self.connected = False\n-                else:\n-                    # The socket is broken in some unknown way, alert\n-                    # the user and remove it from the map (to prevent\n-                    # polling of broken sockets).\n-                    self.del_channel(map)\n-                    raise\n         else:\n             self.socket = None\n \n@@ -394,23 +378,6 @@ def bind(self, addr):\n         self.addr = addr\n         return self.socket.bind(addr)\n \n-    def connect(self, address):\n-        self.connected = False\n-        self.connecting = True\n-        err = self.socket.connect_ex(address)\n-        if (\n-            err in (EINPROGRESS, EALREADY, EWOULDBLOCK)\n-            or err == EINVAL\n-            and os.name == \"nt\"\n-        ):  # pragma: no cover\n-            self.addr = address\n-            return\n-        if err in (0, EISCONN):\n-            self.addr = address\n-            self.handle_connect_event()\n-        else:\n-            raise OSError(err, errorcode[err])\n-\n     def accept(self):\n         # XXX can return either an address pair or None\n         try:\n@@ -469,6 +436,8 @@ def close(self):\n                 if why.args[0] not in (ENOTCONN, EBADF):\n                     raise\n \n+            self.socket = None\n+\n     # log and log_info may be overridden to provide more sophisticated\n     # logging and warning methods. In general, log is for 'hit' logging\n     # and 'log_info' is for informational, warning and error logging.\n@@ -519,7 +488,11 @@ def handle_expt_event(self):\n         # handle_expt_event() is called if there might be an error on the\n         # socket, or if there is OOB data\n         # check for the error condition first\n-        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n+        err = (\n+            self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n+            if self.socket is not None\n+            else 1\n+        )\n         if err != 0:\n             # we can get here when select.select() says that there is an\n             # exceptional condition on the socket\n@@ -572,34 +545,6 @@ def handle_close(self):\n         self.close()\n \n \n-# ---------------------------------------------------------------------------\n-# adds simple buffered output capability, useful for simple clients.\n-# [for more sophisticated usage use asynchat.async_chat]\n-# ---------------------------------------------------------------------------\n-\n-\n-class dispatcher_with_send(dispatcher):\n-    def __init__(self, sock=None, map=None):\n-        dispatcher.__init__(self, sock, map)\n-        self.out_buffer = b\"\"\n-\n-    def initiate_send(self):\n-        num_sent = 0\n-        num_sent = dispatcher.send(self, self.out_buffer[:65536])\n-        self.out_buffer = self.out_buffer[num_sent:]\n-\n-    handle_write = initiate_send\n-\n-    def writable(self):\n-        return (not self.connected) or len(self.out_buffer)\n-\n-    def send(self, data):\n-        if self.debug:  # pragma: no cover\n-            self.log_info(\"sending %s\" % repr(data))\n-        self.out_buffer = self.out_buffer + data\n-        self.initiate_send()\n-\n-\n def close_all(map=None, ignore_all=False):\n     if map is None:  # pragma: no cover\n         map = socket_map"
        },
        {
          "filename": "tests/test_wasyncore.py",
          "status": "modified",
          "additions": 18,
          "deletions": 89,
          "patch": "@@ -1,6 +1,7 @@\n import _thread as thread\n import contextlib\n import errno\n+from errno import EALREADY, EINPROGRESS, EINVAL, EISCONN, EWOULDBLOCK, errorcode\n import functools\n import gc\n from io import BytesIO\n@@ -641,62 +642,6 @@ def test_strerror(self):\n         self.assertTrue(err != \"\")\n \n \n-class dispatcherwithsend_noread(asyncore.dispatcher_with_send):  # pragma: no cover\n-    def readable(self):\n-        return False\n-\n-    def handle_connect(self):\n-        pass\n-\n-\n-class DispatcherWithSendTests(unittest.TestCase):\n-    def setUp(self):\n-        pass\n-\n-    def tearDown(self):\n-        asyncore.close_all()\n-\n-    @reap_threads\n-    def test_send(self):\n-        evt = threading.Event()\n-        sock = socket.socket()\n-        sock.settimeout(3)\n-        port = bind_port(sock)\n-\n-        cap = BytesIO()\n-        args = (evt, cap, sock)\n-        t = threading.Thread(target=capture_server, args=args)\n-        t.start()\n-        try:\n-            # wait a little longer for the server to initialize (it sometimes\n-            # refuses connections on slow machines without this wait)\n-            time.sleep(0.2)\n-\n-            data = b\"Suppose there isn't a 16-ton weight?\"\n-            d = dispatcherwithsend_noread()\n-            d.create_socket()\n-            d.connect((HOST, port))\n-\n-            # give time for socket to connect\n-            time.sleep(0.1)\n-\n-            d.send(data)\n-            d.send(data)\n-            d.send(b\"\\n\")\n-\n-            n = 1000\n-\n-            while d.out_buffer and n > 0:  # pragma: no cover\n-                asyncore.poll()\n-                n -= 1\n-\n-            evt.wait()\n-\n-            self.assertEqual(cap.getvalue(), data * 2)\n-        finally:\n-            join_thread(t, timeout=TIMEOUT)\n-\n-\n @unittest.skipUnless(\n     hasattr(asyncore, \"file_wrapper\"), \"asyncore.file_wrapper required\"\n )\n@@ -839,6 +784,23 @@ def __init__(self, family, address):\n         self.create_socket(family)\n         self.connect(address)\n \n+    def connect(self, address):\n+        self.connected = False\n+        self.connecting = True\n+        err = self.socket.connect_ex(address)\n+        if (\n+            err in (EINPROGRESS, EALREADY, EWOULDBLOCK)\n+            or err == EINVAL\n+            and os.name == \"nt\"\n+        ):  # pragma: no cover\n+            self.addr = address\n+            return\n+        if err in (0, EISCONN):\n+            self.addr = address\n+            self.handle_connect_event()\n+        else:\n+            raise OSError(err, errorcode[err])\n+\n     def handle_connect(self):\n         pass\n \n@@ -1454,17 +1416,6 @@ def _makeOne(self, sock=None, map=None):\n \n         return dispatcher(sock=sock, map=map)\n \n-    def test_unexpected_getpeername_exc(self):\n-        sock = dummysocket()\n-\n-        def getpeername():\n-            raise OSError(errno.EBADF)\n-\n-        map = {}\n-        sock.getpeername = getpeername\n-        self.assertRaises(socket.error, self._makeOne, sock=sock, map=map)\n-        self.assertEqual(map, {})\n-\n     def test___repr__accepting(self):\n         sock = dummysocket()\n         map = {}\n@@ -1500,13 +1451,6 @@ def setsockopt(*arg, **kw):\n         inst.set_reuse_addr()\n         self.assertTrue(sock.errored)\n \n-    def test_connect_raise_socket_error(self):\n-        sock = dummysocket()\n-        map = {}\n-        sock.connect_ex = lambda *arg: 1\n-        inst = self._makeOne(sock=sock, map=map)\n-        self.assertRaises(socket.error, inst.connect, 0)\n-\n     def test_accept_raise_TypeError(self):\n         sock = dummysocket()\n         map = {}\n@@ -1675,21 +1619,6 @@ def test_handle_accepted(self):\n         self.assertTrue(sock.closed)\n \n \n-class Test_dispatcher_with_send(unittest.TestCase):\n-    def _makeOne(self, sock=None, map=None):\n-        from waitress.wasyncore import dispatcher_with_send\n-\n-        return dispatcher_with_send(sock=sock, map=map)\n-\n-    def test_writable(self):\n-        sock = dummysocket()\n-        map = {}\n-        inst = self._makeOne(sock=sock, map=map)\n-        inst.out_buffer = b\"123\"\n-        inst.connected = True\n-        self.assertTrue(inst.writable())\n-\n-\n class Test_close_all(unittest.TestCase):\n     def _callFUT(self, map=None, ignore_all=False):\n         from waitress.wasyncore import close_all"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fc592e804a1aed87654c1ad21337dad86582c71f",
            "date": "2024-11-25T01:07:27Z",
            "author_login": "mmerickel"
          },
          {
            "sha": "7a19337321c43b81076da20bc9c4e2e077a7e01c",
            "date": "2024-11-24T19:55:09Z",
            "author_login": "kgaughan"
          },
          {
            "sha": "2a1524a9b5786459786a4b86e5b2f09d1041e53d",
            "date": "2024-11-23T19:40:01Z",
            "author_login": "kgaughan"
          },
          {
            "sha": "b11ae729cc51ca2998a1ad9b4992b34f34ac95e7",
            "date": "2024-11-16T19:46:41Z",
            "author_login": "digitalresistor"
          },
          {
            "sha": "38ffad094b785168aba197f6b6d8df5de713cc2b",
            "date": "2024-11-16T19:39:00Z",
            "author_login": "digitalresistor"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-772",
    "description": "Waitress is a Web Server Gateway Interface server for Python 2 and 3. When a remote client closes the connection before waitress has had the opportunity to call getpeername() waitress won't correctly clean up the connection leading to the main thread attempting to write to a socket that no longer exists, but not removing it from the list of sockets to attempt to process. This leads to a busy-loop calling the write function. A remote attacker could run waitress out of available sockets with very little resources required. Waitress 3.0.1 contains fixes that remove the race condition.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-10-29T15:15:12.030",
    "last_modified": "2024-11-21T09:41:49.443",
    "fix_date": "2024-06-08T21:51:06Z"
  },
  "references": [
    {
      "url": "https://github.com/Pylons/waitress/commit/1ae4e894c9f76543bee06584001583fc6fa8c95c",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/issues/418",
      "source": "security-advisories@github.com",
      "tags": [
        "Issue Tracking"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/pull/435",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/Pylons/waitress/security/advisories/GHSA-3f84-rpwh-47g6",
      "source": "security-advisories@github.com",
      "tags": [
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2024/11/msg00012.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:27.106524",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "waitress",
    "owner": "Pylons",
    "created_at": "2011-12-17T06:58:21Z",
    "updated_at": "2025-01-11T21:17:13Z",
    "pushed_at": "2024-11-25T01:07:27Z",
    "size": 1868,
    "stars": 1467,
    "forks": 178,
    "open_issues": 16,
    "watchers": 1467,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 495340
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:00:04.687602"
  }
}