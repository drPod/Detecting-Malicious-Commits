{
  "cve_id": "CVE-2024-50346",
  "github_data": {
    "repository": "taoso/webfeed",
    "fix_commit": "a2d1c1c3a98f30e0bd7a1bbcb746fae484985e6d",
    "related_commits": [
      "a2d1c1c3a98f30e0bd7a1bbcb746fae484985e6d"
    ],
    "patch_url": "https://github.com/taoso/webfeed/commit/a2d1c1c3a98f30e0bd7a1bbcb746fae484985e6d.patch",
    "fix_commit_details": {
      "sha": "a2d1c1c3a98f30e0bd7a1bbcb746fae484985e6d",
      "commit_date": "2024-11-02T10:27:45Z",
      "author": {
        "login": "taoso",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 248,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 107,
        "additions": 40,
        "deletions": 67
      },
      "files": [
        {
          "filename": "js/list.js",
          "status": "modified",
          "additions": 5,
          "deletions": 13,
          "patch": "@@ -29,23 +29,15 @@ async function listEntries(last = 0) {\n     const content = template.content.cloneNode(true);\n     let $ = content.querySelector.bind(content);\n \n-    $(\"article>h2\").innerHTML = entry.title;\n-    $(\"article>.meta time\").innerHTML = entry.updated.toLocaleString();\n+    $(\"article>h2\").innerText = utils.html2txt(entry.title);\n+    $(\"article>.meta time\").innerText = entry.updated.toLocaleString();\n+    $(\"article>div\").innerText = utils.html2txt(entry.summary);\n     $(\"article>.meta a.link\").href = entry.link;\n \n-    let sum = $(\"article>div\");\n-    sum.innerHTML = entry.summary;\n-\n-    // drop duplicate read more link in content\n-    let a = $(`article>.summary a[href=\"${entry.link}\"]`);\n-    if (a) a.outerHTML = '';\n-\n-    utils.html2txt(sum);\n-\n     let showUrl = browser.runtime.getURL(`show.html?url=${encodeURI(entry.site)}`)\n     let site = utils.getSiteTitle(entry.site);\n     $(\"article>.meta a.site\").href = showUrl;\n-    $(\"article>.meta a.site\").innerHTML = site;\n+    $(\"article>.meta a.site\").innerText = site;\n     let $img = $(\"article>.meta img.icon\");\n     store.getIcon(site).then(src => $img.src = src);\n \n@@ -75,7 +67,7 @@ async function listEntries(last = 0) {\n   let more = document.querySelector(\"#more\")\n   if (num > 0) {\n     more.dataset.done = true;\n-    more.innerHTML = \"There is no more feeds to load.\";\n+    more.innerText = \"There is no more feeds to load.\";\n   }\n \n   return firstId;"
        },
        {
          "filename": "js/logs.js",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -73,12 +73,13 @@ or caused by a small timeout option.<p>\n     let info = infos[type];\n \n     $('.type').innerText = info.title;\n-    $('.error').innerHTML = info.desc;\n+    $('.error').innerHTML = info.desc; // none user input, safe to use\n     let ol = $('.urls');\n     for (const url of urls) {\n       let li = document.createElement('li');\n       let showUrl = browser.runtime.getURL(`show.html?url=${encodeURI(url)}`);\n-      li.innerHTML = `<a href=\"${showUrl}\" target=\"_blank\">${url}</a>`;\n+      li.innerHTML = `<a href=\"${showUrl}\" target=\"_blank\"></a>`;\n+      li.querySelector('a').innerText = url;\n       ol.appendChild(li);\n     }\n "
        },
        {
          "filename": "js/popup.js",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -2,7 +2,7 @@\n \n let browser = self.browser || self.chrome;\n \n-import { findParent } from './utils.js';\n+import * as utils from './utils.js';\n \n const feeds = JSON.parse(\n   decodeURIComponent(window.location.search.substr(7))\n@@ -16,7 +16,7 @@ const types = {\n };\n \n document.addEventListener(\"click\", e => {\n-  const el = findParent(e.target, \".items__item-link\");\n+  const el = utils.findParent(e.target, \".items__item-link\");\n   if (!el) return;\n   e.preventDefault();\n \n@@ -46,7 +46,7 @@ const items = feeds.map(feed => {\n   }\n \n   link.innerHTML =\n-    (feed.title || feed.url) +\n+    utils.html2txt(feed.title || feed.url) +\n       (types[feed.type]\n         ? ` <span style=\"opacity:0.6;\">(${types[feed.type]})</span>`\n         : \"\");"
        },
        {
          "filename": "js/show.js",
          "status": "modified",
          "additions": 22,
          "deletions": 39,
          "patch": "@@ -8,13 +8,13 @@ import * as store from './store.js';\n async function renderHTML(feed, resp) {\n   let header = document.querySelector('body header');\n \n-  header.querySelector('h1').innerHTML = feed.title;\n+  header.querySelector('h1').innerText = utils.html2txt(feed.title);\n   let h1 = header.querySelector('#site-link')\n   h1.href = feed.link;\n-  h1.innerHTML = utils.getSiteTitle(feed.link);\n+  h1.innerText = utils.getSiteTitle(feed.link);\n \n   let img = header.querySelector('#site-icon');\n-  img.src = await store.getIcon(h1.innerHTML);\n+  img.src = await store.getIcon(h1.innerText);\n \n   let button = header.querySelector('subscribe-button')\n   button.dataset.url = feed.url\n@@ -23,14 +23,14 @@ async function renderHTML(feed, resp) {\n \n   let bs = await browser.bookmarks.search({url:document.URL});\n   if (bs.length > 0) {\n-    button.innerHTML = \"Unsubscribe\";\n+    button.innerText = \"Unsubscribe\";\n   } else {\n     if (resp.redirected) {\n       let url = browser.runtime.getURL(`show.html?url=${encodeURI(resp.url)}`);\n       document.location.href = url;\n       return;\n     }\n-    button.innerHTML = \"Subscribe\";\n+    button.innerText = \"Subscribe\";\n   }\n   button.style.display = \"inline\";\n \n@@ -41,55 +41,32 @@ async function renderHTML(feed, resp) {\n       alert(\"invalid feed\");\n       return;\n     }\n-    if (button.innerHTML == \"Subscribe\") {\n+    if (button.innerText == \"Subscribe\") {\n       await store.subscribe(e.target.dataset);\n       await store.saveEntries(feed.url, feed.entries);\n-      button.innerHTML = \"Unsubscribe\";\n+      button.innerText = \"Unsubscribe\";\n     } else {\n       let bs = await browser.bookmarks.search({url:document.URL});\n       await browser.bookmarks.remove(bs[0].id);\n       await store.removeEntries(feed.url);\n-      button.innerHTML = \"Subscribe\";\n+      button.innerText = \"Subscribe\";\n     }\n   };\n \n   const template = document.getElementById(\"feed-item\");\n \n   feed.entries.forEach(entry => {\n     const content = template.content.cloneNode(true);\n+    let $ = content.querySelector.bind(content);\n \n     if (isNaN(entry.updated)) {\n       invalid = true;\n     }\n \n-    content.querySelector(\"article>h2\").innerHTML = entry.title;\n-    content.querySelector(\"article>time\").innerHTML = entry.updated.toLocaleString();\n-\n-    let sum = content.querySelector(\"article>div\");\n-    sum.innerHTML = entry.summary;\n-\n-    utils.html2txt(sum);\n-\n-    let link = utils.fixLink(entry.link, feed.url);\n-    content.querySelector(\"article>a\").href = link;\n-\n-    // drop duplicate read more link in content\n-    let a = sum.querySelector(`a[href=\"${link}\"]`);\n-    if (a) a.outerHTML = '';\n-\n-    content.querySelectorAll(\"article>div img\").forEach(img => {\n-      if (img.dataset.src) {\n-        img.src = img.dataset.src;\n-      }\n-      img.src = utils.fixLink(img.src, feed.url);\n-      img.onerror = (e) => {\n-        img.style.display = 'none';\n-      };\n-    });\n-\n-    content.querySelectorAll(\"article>div a\").forEach(a => {\n-      a.href = utils.fixLink(a.href, feed.url);\n-    });\n+    $(\"article>h2\").innerText = utils.html2txt(entry.title);\n+    $(\"article>time\").innerText = entry.updated.toLocaleString();\n+    $(\"article>div\").innerText = utils.html2txt(entry.summary);\n+    $(\"article>a\").href = utils.fixLink(entry.link, feed.url);\n \n     document.querySelector(\".items\").appendChild(content);\n   });\n@@ -120,12 +97,18 @@ async function main() {\n     error.innerHTML = `\n <div>\n   <p>Error while fetching feed</p>\n-  <p style=\"color:red;\">${e}</p>\n-  <p><pre>${e.stack}</pre></p>\n+  <p class=\"error\" style=\"color:red;\"></p>\n+  <p><pre></pre></p>\n   <p>You may go to the site to find the latest feed and unsubscribe this one.</p>\n-  <a href=\"${url}\">${url}</a>\n+  <a href=\"#\"></a>\n </div>\n `;\n+    let $ = error.querySelector.bind(error);\n+    $('p.error').innerText = e.message;\n+    $('pre').innerText = e.stack;\n+    $('a').href = url;\n+    $('a').innerText = url;\n+\n     document.body.appendChild(error);\n     return;\n   }"
        },
        {
          "filename": "js/utils.js",
          "status": "modified",
          "additions": 7,
          "deletions": 10,
          "patch": "@@ -194,16 +194,13 @@ export async function syncAll() {\n   }\n }\n \n-// publisher may embed html code in <pre> or <code>\n-// this should convert to text recursively.\n-export async function html2txt(e) {\n-  for (let i = 0; i < 10; i++) {\n-    if (e.children) {\n-      e.innerHTML = e.innerText;\n-    } else {\n-      break;\n-    }\n-  }\n+// The return value may include html tags, so do not\n+// assign it to innerHTML directly!\n+export function html2txt(content) {\n+  let e = document.createElement('div');\n+  e.innerHTML = content;\n+\n+  return e.innerText;\n }\n \n export function getSiteTitle(link) {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 1,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d1636b69b5beb8e96635d7c0dd1e7baa4b39a259",
            "date": "2024-12-20T03:17:13Z",
            "author_login": "taoso"
          },
          {
            "sha": "9d6d3428b508d028c1f37ae853fdd74189cf1ce9",
            "date": "2024-12-20T02:38:54Z",
            "author_login": "taoso"
          },
          {
            "sha": "046d9d6ae4a950cb1a337491f0eb0575685b047e",
            "date": "2024-12-19T17:02:08Z",
            "author_login": "taoso"
          },
          {
            "sha": "8517934477126852cecdb2cfb2186764b9cf4bec",
            "date": "2024-12-19T16:51:02Z",
            "author_login": "taoso"
          },
          {
            "sha": "6b8c9291fbd88aee3eaae227c781888569317654",
            "date": "2024-12-17T10:17:54Z",
            "author_login": "taoso"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-79",
    "description": "WebFeed is a lightweight web feed reader extension for Firefox/Chrome. Multiple HTML injection vulnerabilities in WebFeed can lead to CSRF and UI spoofing attacks. A remote attacker can provide malicious RSS feeds and attract the victim user to visit it using WebFeed. The attacker can then inject malicious HTML into the extension page and fool the victim into sending out HTTP requests to arbitrary sites with the victim's credentials. Users are vulnerable to CSRF attacks when visiting malicious RSS feeds via WebFeed. Unwanted actions could be executed on the user's behalf on arbitrary websites. This issue has been addressed in release version 0.9.2. All users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-05T00:15:04.510",
    "last_modified": "2024-11-05T16:04:26.053",
    "fix_date": "2024-11-02T10:27:45Z"
  },
  "references": [
    {
      "url": "https://github.com/taoso/webfeed/commit/a2d1c1c3a98f30e0bd7a1bbcb746fae484985e6d",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/taoso/webfeed/security/advisories/GHSA-mrc7-2q3w-48j8",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:29.206292",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "webfeed",
    "owner": "taoso",
    "created_at": "2022-04-16T11:56:30Z",
    "updated_at": "2025-01-14T16:46:07Z",
    "pushed_at": "2024-12-23T03:08:44Z",
    "size": 787,
    "stars": 41,
    "forks": 1,
    "open_issues": 0,
    "watchers": 41,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 48395,
      "CSS": 34516,
      "HTML": 6908,
      "Makefile": 593
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T22:34:26.926934"
  }
}