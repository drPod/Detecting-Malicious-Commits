{
  "cve_id": "CVE-2024-52010",
  "github_data": {
    "repository": "tobychui/zoraxy",
    "fix_commit": "2e9bc77a5d832bff1093058d42ce7a61382e4bc6",
    "related_commits": [
      "2e9bc77a5d832bff1093058d42ce7a61382e4bc6",
      "c07d5f85dfc37bd32819358ed7d4bc32c604e8f0"
    ],
    "patch_url": "https://github.com/tobychui/zoraxy/commit/2e9bc77a5d832bff1093058d42ce7a61382e4bc6.patch",
    "fix_commit_details": {
      "sha": "2e9bc77a5d832bff1093058d42ce7a61382e4bc6",
      "commit_date": "2024-11-10T05:57:01Z",
      "author": {
        "login": "tobychui",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 50,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 159,
        "additions": 136,
        "deletions": 23
      },
      "files": [
        {
          "filename": "src/mod/sshprox/sshprox.go",
          "status": "modified",
          "additions": 11,
          "deletions": 15,
          "patch": "@@ -50,21 +50,6 @@ func NewSSHProxyManager() *Manager {\n \t}\n }\n \n-// Get the next free port in the list\n-func (m *Manager) GetNextPort() int {\n-\tnextPort := m.StartingPort\n-\toccupiedPort := make(map[int]bool)\n-\tfor _, instance := range m.Instances {\n-\t\toccupiedPort[instance.AssignedPort] = true\n-\t}\n-\tfor {\n-\t\tif !occupiedPort[nextPort] {\n-\t\t\treturn nextPort\n-\t\t}\n-\t\tnextPort++\n-\t}\n-}\n-\n func (m *Manager) HandleHttpByInstanceId(instanceId string, w http.ResponseWriter, r *http.Request) {\n \ttargetInstance, err := m.GetInstanceById(instanceId)\n \tif err != nil {\n@@ -168,6 +153,17 @@ func (i *Instance) CreateNewConnection(listenPort int, username string, remoteIp\n \tif username != \"\" {\n \t\tconnAddr = username + \"@\" + remoteIpAddr\n \t}\n+\n+\t//Trim the space in the username and remote address\n+\tusername = strings.TrimSpace(username)\n+\tremoteIpAddr = strings.TrimSpace(remoteIpAddr)\n+\n+\t//Validate the username and remote address\n+\terr := ValidateUsernameAndRemoteAddr(username, remoteIpAddr)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \tconfigPath := filepath.Join(filepath.Dir(i.ExecPath), \".gotty\")\n \ttitle := username + \"@\" + remoteIpAddr\n \tif remotePort != 22 {"
        },
        {
          "filename": "src/mod/sshprox/sshprox_test.go",
          "status": "added",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -0,0 +1,66 @@\n+package sshprox\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestInstance_Destroy(t *testing.T) {\n+\tmanager := NewSSHProxyManager()\n+\tinstance, err := manager.NewSSHProxy(\"/tmp\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create new SSH proxy: %v\", err)\n+\t}\n+\n+\tinstance.Destroy()\n+\n+\tif len(manager.Instances) != 0 {\n+\t\tt.Errorf(\"Expected Instances to be empty, got %d\", len(manager.Instances))\n+\t}\n+}\n+\n+func TestInstance_ValidateUsernameAndRemoteAddr(t *testing.T) {\n+\ttests := []struct {\n+\t\tusername    string\n+\t\tremoteAddr  string\n+\t\texpectError bool\n+\t}{\n+\t\t{\"validuser\", \"127.0.0.1\", false},\n+\t\t{\"valid.user\", \"example.com\", false},\n+\t\t{\"; bash ;\", \"example.com\", true},\n+\t\t{\"valid-user\", \"example.com\", false},\n+\t\t{\"invalid user\", \"127.0.0.1\", true},\n+\t\t{\"validuser\", \"invalid address\", true},\n+\t\t{\"invalid@user\", \"127.0.0.1\", true},\n+\t\t{\"validuser\", \"invalid@address\", true},\n+\t\t{\"injection; rm -rf /\", \"127.0.0.1\", true},\n+\t\t{\"validuser\", \"127.0.0.1; rm -rf /\", true},\n+\t\t{\"$(reboot)\", \"127.0.0.1\", true},\n+\t\t{\"validuser\", \"$(reboot)\", true},\n+\t\t{\"validuser\", \"127.0.0.1; $(reboot)\", true},\n+\t\t{\"validuser\", \"127.0.0.1 | ls\", true},\n+\t\t{\"validuser\", \"127.0.0.1 & ls\", true},\n+\t\t{\"validuser\", \"127.0.0.1 && ls\", true},\n+\t\t{\"validuser\", \"127.0.0.1 |& ls\", true},\n+\t\t{\"validuser\", \"127.0.0.1 ; ls\", true},\n+\t\t{\"validuser\", \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", false},\n+\t\t{\"validuser\", \"2001:db8::ff00:42:8329\", false},\n+\t\t{\"validuser\", \"2001:db8:0:1234:0:567:8:1\", false},\n+\t\t{\"validuser\", \"2001:db8::1234:0:567:8:1\", false},\n+\t\t{\"validuser\", \"2001:db8:0:0:0:0:2:1\", false},\n+\t\t{\"validuser\", \"2001:db8::2:1\", false},\n+\t\t{\"validuser\", \"2001:db8:0:0:8:800:200c:417a\", false},\n+\t\t{\"validuser\", \"2001:db8::8:800:200c:417a\", false},\n+\t\t{\"validuser\", \"2001:db8:0:0:8:800:200c:417a; rm -rf /\", true},\n+\t\t{\"validuser\", \"2001:db8::8:800:200c:417a; rm -rf /\", true},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\terr := ValidateUsernameAndRemoteAddr(test.username, test.remoteAddr)\n+\t\tif test.expectError && err == nil {\n+\t\t\tt.Errorf(\"Expected error for username %s and remoteAddr %s, but got none\", test.username, test.remoteAddr)\n+\t\t}\n+\t\tif !test.expectError && err != nil {\n+\t\t\tt.Errorf(\"Did not expect error for username %s and remoteAddr %s, but got %v\", test.username, test.remoteAddr, err)\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "src/mod/sshprox/utils.go",
          "status": "modified",
          "additions": 57,
          "deletions": 6,
          "patch": "@@ -1,9 +1,11 @@\n package sshprox\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"net\"\n \t\"net/url\"\n+\t\"regexp\"\n \t\"runtime\"\n \t\"strings\"\n \t\"time\"\n@@ -34,6 +36,21 @@ func IsWebSSHSupported() bool {\n \treturn true\n }\n \n+// Get the next free port in the list\n+func (m *Manager) GetNextPort() int {\n+\tnextPort := m.StartingPort\n+\toccupiedPort := make(map[int]bool)\n+\tfor _, instance := range m.Instances {\n+\t\toccupiedPort[instance.AssignedPort] = true\n+\t}\n+\tfor {\n+\t\tif !occupiedPort[nextPort] {\n+\t\t\treturn nextPort\n+\t\t}\n+\t\tnextPort++\n+\t}\n+}\n+\n // Check if a given domain and port is a valid ssh server\n func IsSSHConnectable(ipOrDomain string, port int) bool {\n \ttimeout := time.Second * 3\n@@ -60,13 +77,47 @@ func IsSSHConnectable(ipOrDomain string, port int) bool {\n \treturn string(buf[:7]) == \"SSH-2.0\"\n }\n \n-// Check if the port is used by other process or application\n-func isPortInUse(port int) bool {\n-\taddress := fmt.Sprintf(\":%d\", port)\n-\tlistener, err := net.Listen(\"tcp\", address)\n-\tif err != nil {\n+// Validate the username and remote address to prevent injection\n+func ValidateUsernameAndRemoteAddr(username string, remoteIpAddr string) error {\n+\t// Validate and sanitize the username to prevent ssh injection\n+\tvalidUsername := regexp.MustCompile(`^[a-zA-Z0-9._-]+$`)\n+\tif !validUsername.MatchString(username) {\n+\t\treturn errors.New(\"invalid username, only alphanumeric characters, dots, underscores and dashes are allowed\")\n+\t}\n+\n+\t//Check if the remoteIpAddr is a valid ipv4 or ipv6 address\n+\tif net.ParseIP(remoteIpAddr) != nil {\n+\t\t//A valid IP address do not need further validation\n+\t\treturn nil\n+\t}\n+\n+\t// Validate and sanitize the remote domain to prevent injection\n+\tvalidRemoteAddr := regexp.MustCompile(`^[a-zA-Z0-9._-]+$`)\n+\tif !validRemoteAddr.MatchString(remoteIpAddr) {\n+\t\treturn errors.New(\"invalid remote address, only alphanumeric characters, dots, underscores and dashes are allowed\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Check if the given ip or domain is a loopback address\n+// or resolves to a loopback address\n+func IsLoopbackIPOrDomain(ipOrDomain string) bool {\n+\tif strings.EqualFold(strings.TrimSpace(ipOrDomain), \"localhost\") || strings.TrimSpace(ipOrDomain) == \"127.0.0.1\" {\n \t\treturn true\n \t}\n-\tlistener.Close()\n+\n+\t//Check if the ipOrDomain resolves to a loopback address\n+\tips, err := net.LookupIP(ipOrDomain)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\n+\tfor _, ip := range ips {\n+\t\tif ip.IsLoopback() {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n \treturn false\n }"
        },
        {
          "filename": "src/webssh.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -42,7 +42,7 @@ func HandleCreateProxySession(w http.ResponseWriter, r *http.Request) {\n \n \tif !*allowSshLoopback {\n \t\t//Not allow loopback connections\n-\t\tif strings.EqualFold(strings.TrimSpace(ipaddr), \"localhost\") || strings.TrimSpace(ipaddr) == \"127.0.0.1\" {\n+\t\tif sshprox.IsLoopbackIPOrDomain(ipaddr) {\n \t\t\t//Request target is loopback\n \t\t\tutils.SendErrorResponse(w, \"loopback web ssh connection is not enabled on this host\")\n \t\t\treturn\n@@ -74,7 +74,7 @@ func HandleCreateProxySession(w http.ResponseWriter, r *http.Request) {\n \tutils.SendJSONResponse(w, string(js))\n }\n \n-//Check if the host support ssh, or if the target domain (and port, optional) support ssh\n+// Check if the host support ssh, or if the target domain (and port, optional) support ssh\n func HandleWebSshSupportCheck(w http.ResponseWriter, r *http.Request) {\n \tdomain, err := utils.PostPara(r, \"domain\")\n \tif err != nil {"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d1e5581eea1b047d07496b672b017c93c774a47d",
            "date": "2024-12-31T13:49:41Z",
            "author_login": "tobychui"
          },
          {
            "sha": "be5797c8a54fa4b3e5cb4cbf33b0eacc02c105ce",
            "date": "2024-12-31T13:47:19Z",
            "author_login": "tobychui"
          },
          {
            "sha": "ebd316a7f100896266d62e7be47194baf0348259",
            "date": "2024-12-31T13:14:37Z",
            "author_login": "tobychui"
          },
          {
            "sha": "84aec4387af5198b7dbd82c9a69b8d621f24ed4b",
            "date": "2024-12-31T12:30:36Z",
            "author_login": "tobychui"
          },
          {
            "sha": "30dfb9cb6551497ca107f778dd2d0448dc18d919",
            "date": "2024-12-30T13:41:15Z",
            "author_login": "tobychui"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-78",
    "description": "Zoraxy is a general purpose HTTP reverse proxy and forwarding tool. A command injection vulnerability in the Web SSH feature allows an authenticated attacker to execute arbitrary commands as root on the host. Zoraxy has a Web SSH terminal feature that allows authenticated users to connect to SSH servers from their browsers. In HandleCreateProxySession the request to create an SSH session is handled. An attacker can exploit the username variable to escape from the bash command and inject arbitrary commands into sshCommand. This is possible, because, unlike hostname and port, the username is not validated or sanitized.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-12T17:15:10.370",
    "last_modified": "2024-11-21T17:15:23.350",
    "fix_date": "2024-11-10T05:57:01Z"
  },
  "references": [
    {
      "url": "https://github.com/tobychui/zoraxy/commit/2e9bc77a5d832bff1093058d42ce7a61382e4bc6",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/tobychui/zoraxy/commit/c07d5f85dfc37bd32819358ed7d4bc32c604e8f0",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/tobychui/zoraxy/security/advisories/GHSA-7hpf-g48v-hw3j",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:29.286888",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "zoraxy",
    "owner": "tobychui",
    "created_at": "2022-11-01T02:52:21Z",
    "updated_at": "2025-01-14T12:36:29Z",
    "pushed_at": "2024-12-31T14:56:56Z",
    "size": 68865,
    "stars": 3323,
    "forks": 195,
    "open_issues": 69,
    "watchers": 3323,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "HTML": 2413724,
      "CSS": 1747582,
      "JavaScript": 1541233,
      "Go": 795956,
      "Shell": 2859,
      "Dockerfile": 1794,
      "Makefile": 1776
    },
    "commit_activity": {
      "total_commits_last_year": 249,
      "avg_commits_per_week": 4.788461538461538,
      "days_active_last_year": 127
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T13:34:48.688541"
  }
}