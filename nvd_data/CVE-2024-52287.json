{
  "cve_id": "CVE-2024-52287",
  "github_data": {
    "repository": "goauthentik/authentik",
    "fix_commit": "e9c29e1644e9199b4ba58d2b10eb8c322138eea2",
    "related_commits": [
      "e9c29e1644e9199b4ba58d2b10eb8c322138eea2"
    ],
    "patch_url": "https://github.com/goauthentik/authentik/commit/e9c29e1644e9199b4ba58d2b10eb8c322138eea2.patch",
    "fix_commit_details": {
      "sha": "e9c29e1644e9199b4ba58d2b10eb8c322138eea2",
      "commit_date": "2024-11-21T13:22:46Z",
      "author": {
        "login": "BeryJu",
        "type": "User",
        "stats": {
          "total_commits": 8914,
          "average_weekly_commits": 27.597523219814242,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 278
        }
      },
      "commit_message": {
        "title": "security: fix CVE 2024 52287 (#12114)",
        "length": 261,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 129,
        "additions": 122,
        "deletions": 7
      },
      "files": [
        {
          "filename": "authentik/providers/oauth2/tests/test_token_cc_standard.py",
          "status": "modified",
          "additions": 43,
          "deletions": 1,
          "patch": "@@ -19,7 +19,7 @@\n     TOKEN_TYPE,\n )\n from authentik.providers.oauth2.errors import TokenError\n-from authentik.providers.oauth2.models import OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import AccessToken, OAuth2Provider, ScopeMapping\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -107,6 +107,48 @@ def test_permission_denied(self):\n             {\"error\": \"invalid_grant\", \"error_description\": TokenError.errors[\"invalid_grant\"]},\n         )\n \n+    def test_incorrect_scopes(self):\n+        \"\"\"test scope that isn't configured\"\"\"\n+        response = self.client.post(\n+            reverse(\"authentik_providers_oauth2:token\"),\n+            {\n+                \"grant_type\": GRANT_TYPE_CLIENT_CREDENTIALS,\n+                \"scope\": f\"{SCOPE_OPENID} {SCOPE_OPENID_EMAIL} {SCOPE_OPENID_PROFILE} extra_scope\",\n+                \"client_id\": self.provider.client_id,\n+                \"client_secret\": self.provider.client_secret,\n+            },\n+        )\n+        self.assertEqual(response.status_code, 200)\n+        body = loads(response.content.decode())\n+        self.assertEqual(body[\"token_type\"], TOKEN_TYPE)\n+        token = AccessToken.objects.filter(\n+            provider=self.provider, token=body[\"access_token\"]\n+        ).first()\n+        self.assertSetEqual(\n+            set(token.scope), {SCOPE_OPENID, SCOPE_OPENID_EMAIL, SCOPE_OPENID_PROFILE}\n+        )\n+        _, alg = self.provider.jwt_key\n+        jwt = decode(\n+            body[\"access_token\"],\n+            key=self.provider.signing_key.public_key,\n+            algorithms=[alg],\n+            audience=self.provider.client_id,\n+        )\n+        self.assertEqual(\n+            jwt[\"given_name\"], \"Autogenerated user from application test (client credentials)\"\n+        )\n+        self.assertEqual(jwt[\"preferred_username\"], \"ak-test-client_credentials\")\n+        jwt = decode(\n+            body[\"id_token\"],\n+            key=self.provider.signing_key.public_key,\n+            algorithms=[alg],\n+            audience=self.provider.client_id,\n+        )\n+        self.assertEqual(\n+            jwt[\"given_name\"], \"Autogenerated user from application test (client credentials)\"\n+        )\n+        self.assertEqual(jwt[\"preferred_username\"], \"ak-test-client_credentials\")\n+\n     def test_successful(self):\n         \"\"\"test successful\"\"\"\n         response = self.client.post("
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_device.py",
          "status": "modified",
          "additions": 31,
          "deletions": 2,
          "patch": "@@ -9,8 +9,12 @@\n from authentik.core.models import Application\n from authentik.core.tests.utils import create_test_admin_user, create_test_cert, create_test_flow\n from authentik.lib.generators import generate_code_fixed_length, generate_id\n-from authentik.providers.oauth2.constants import GRANT_TYPE_DEVICE_CODE\n-from authentik.providers.oauth2.models import DeviceToken, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.constants import (\n+    GRANT_TYPE_DEVICE_CODE,\n+    SCOPE_OPENID,\n+    SCOPE_OPENID_EMAIL,\n+)\n+from authentik.providers.oauth2.models import AccessToken, DeviceToken, OAuth2Provider, ScopeMapping\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -80,3 +84,28 @@ def test_code(self):\n             },\n         )\n         self.assertEqual(res.status_code, 200)\n+\n+    def test_code_mismatched_scope(self):\n+        \"\"\"Test code with user (mismatched scopes)\"\"\"\n+        device_token = DeviceToken.objects.create(\n+            provider=self.provider,\n+            user_code=generate_code_fixed_length(),\n+            device_code=generate_id(),\n+            user=self.user,\n+            scope=[SCOPE_OPENID, SCOPE_OPENID_EMAIL],\n+        )\n+        res = self.client.post(\n+            reverse(\"authentik_providers_oauth2:token\"),\n+            data={\n+                \"client_id\": self.provider.client_id,\n+                \"grant_type\": GRANT_TYPE_DEVICE_CODE,\n+                \"device_code\": device_token.device_code,\n+                \"scope\": f\"{SCOPE_OPENID} {SCOPE_OPENID_EMAIL} invalid\",\n+            },\n+        )\n+        self.assertEqual(res.status_code, 200)\n+        body = loads(res.content)\n+        token = AccessToken.objects.filter(\n+            provider=self.provider, token=body[\"access_token\"]\n+        ).first()\n+        self.assertSetEqual(set(token.scope), {SCOPE_OPENID, SCOPE_OPENID_EMAIL})"
        },
        {
          "filename": "authentik/providers/oauth2/views/token.py",
          "status": "modified",
          "additions": 20,
          "deletions": 4,
          "patch": "@@ -59,6 +59,7 @@\n     DeviceToken,\n     OAuth2Provider,\n     RefreshToken,\n+    ScopeMapping,\n )\n from authentik.providers.oauth2.utils import TokenResponse, cors_allow, extract_client_auth\n from authentik.providers.oauth2.views.authorize import FORBIDDEN_URI_SCHEMES\n@@ -77,7 +78,7 @@ class TokenParams:\n     redirect_uri: str\n     grant_type: str\n     state: str\n-    scope: list[str]\n+    scope: set[str]\n \n     provider: OAuth2Provider\n \n@@ -112,11 +113,26 @@ def parse(\n             redirect_uri=request.POST.get(\"redirect_uri\", \"\"),\n             grant_type=request.POST.get(\"grant_type\", \"\"),\n             state=request.POST.get(\"state\", \"\"),\n-            scope=request.POST.get(\"scope\", \"\").split(),\n+            scope=set(request.POST.get(\"scope\", \"\").split()),\n             # PKCE parameter.\n             code_verifier=request.POST.get(\"code_verifier\"),\n         )\n \n+    def __check_scopes(self):\n+        allowed_scope_names = set(\n+            ScopeMapping.objects.filter(provider__in=[self.provider]).values_list(\n+                \"scope_name\", flat=True\n+            )\n+        )\n+        scopes_to_check = self.scope\n+        if not scopes_to_check.issubset(allowed_scope_names):\n+            LOGGER.info(\n+                \"Application requested scopes not configured, setting to overlap\",\n+                scope_allowed=allowed_scope_names,\n+                scope_given=self.scope,\n+            )\n+            self.scope = self.scope.intersection(allowed_scope_names)\n+\n     def __check_policy_access(self, app: Application, request: HttpRequest, **kwargs):\n         with start_span(\n             op=\"authentik.providers.oauth2.token.policy\",\n@@ -149,7 +165,7 @@ def __post_init__(self, raw_code: str, raw_token: str, request: HttpRequest):\n                     client_id=self.provider.client_id,\n                 )\n                 raise TokenError(\"invalid_client\")\n-\n+        self.__check_scopes()\n         if self.grant_type == GRANT_TYPE_AUTHORIZATION_CODE:\n             with start_span(\n                 op=\"authentik.providers.oauth2.post.parse.code\",\n@@ -710,7 +726,7 @@ def create_device_code_response(self) -> dict[str, Any]:\n             \"id_token\": access_token.id_token.to_jwt(self.provider),\n         }\n \n-        if SCOPE_OFFLINE_ACCESS in self.params.scope:\n+        if SCOPE_OFFLINE_ACCESS in self.params.device_code.scope:\n             refresh_token_expiry = now + timedelta_from_string(self.provider.refresh_token_validity)\n             refresh_token = RefreshToken(\n                 user=self.params.device_code.user,"
        },
        {
          "filename": "website/docs/security/cves/CVE-2024-52287.md",
          "status": "added",
          "additions": 27,
          "deletions": 0,
          "patch": "@@ -0,0 +1,27 @@\n+# CVE-2024-52287\n+\n+_Reported by [@matt1097](https://github.com/matt1097)_\n+\n+## Insufficient validation of OAuth scopes for client_credentials and device_code grants\n+\n+### Summary\n+\n+When using the `client_credentials` or `device_code` OAuth grants, it was possible for an attacker to get a token from authentik with scopes that haven't been configured in authentik.\n+\n+### Details\n+\n+With the `device_code` grant, it was possible to have a user authorize a set of permitted scopes, and then acquire a token with a different set of scopes, including scopes not configured. This token could potentially be used to send requests to another system which trusts tokens signed by authentik and execute malicious actions on behalf of the user.\n+\n+With the `client_credentials` grant, because there is no user authorization process, authentik would not validate the scopes requested for the token, allowing tokens to be issued with scopes not configured in authentik. These could similarly be used to execute malicious actions in other systems.\n+\n+There is no workaround for this issue; however this issue could only be exploited if an attacker possesses a valid set of OAuth2 `client_id` and `client_secret` credentials, and has the knowledge of another system that trusts tokens issued by authentik and what scopes it checks for.\n+\n+### Patches\n+\n+authentik 2024.8.5 and 2024.10.3 fix this issue.\n+\n+### For more information\n+\n+If you have any questions or comments about this advisory:\n+\n+-   Email us at [security@goauthentik.io](mailto:security@goauthentik.io)"
        },
        {
          "filename": "website/sidebars.js",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -658,6 +658,7 @@ export default {\n                             type: \"category\",\n                             label: \"2024\",\n                             items: [\n+                                \"security/cves/CVE-2024-52287\",\n                                 \"security/cves/CVE-2024-47077\",\n                                 \"security/cves/CVE-2024-47070\",\n                                 \"security/cves/CVE-2024-38371\","
        }
      ],
      "file_patterns": {
        "security_files": 4,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "09931bcbc20f4527acfcd9046fe1caeeda446c50",
            "date": "2025-01-14T14:56:03Z",
            "author_login": "BeryJu"
          },
          {
            "sha": "7a4293bf178ac7c6a2222593feef560053e16cbc",
            "date": "2025-01-14T12:40:25Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "6e569acd845bbcc79c50f40542bd729dd2243840",
            "date": "2025-01-14T12:40:17Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "02c69d767f02a9d887a9892128aa8e2e30011c38",
            "date": "2025-01-14T12:39:54Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "1863a9a12bf61d8649918f52354808ab0b2fe246",
            "date": "2025-01-14T05:05:58Z",
            "author_login": "SeeJayEmm"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-285",
    "description": "authentik is an open-source identity provider. When using the client_credentials or device_code OAuth grants, it was possible for an attacker to get a token from authentik with scopes that haven't been configured in authentik. authentik 2024.8.5 and 2024.10.3 fix this issue.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-21T18:15:11.570",
    "last_modified": "2024-11-21T18:15:11.570",
    "fix_date": "2024-11-21T13:22:46Z"
  },
  "references": [
    {
      "url": "https://github.com/goauthentik/authentik/commit/e9c29e1644e9199b4ba58d2b10eb8c322138eea2",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/goauthentik/authentik/security/advisories/GHSA-v6m7-8j37-8f4v",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.277468",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "authentik",
    "owner": "goauthentik",
    "created_at": "2019-12-30T09:19:48Z",
    "updated_at": "2025-01-14T12:40:29Z",
    "pushed_at": "2025-01-14T13:17:29Z",
    "size": 348330,
    "stars": 14458,
    "forks": 984,
    "open_issues": 728,
    "watchers": 14458,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 3995415,
      "TypeScript": 2892221,
      "Go": 308962,
      "MDX": 124483,
      "JavaScript": 69953,
      "HTML": 24617,
      "Rust": 22748,
      "CSS": 19762,
      "Dockerfile": 15501,
      "Makefile": 9222,
      "Shell": 7042,
      "PHP": 1149
    },
    "commit_activity": {
      "total_commits_last_year": 3169,
      "avg_commits_per_week": 60.94230769230769,
      "days_active_last_year": 295
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:32:32.687051"
  }
}