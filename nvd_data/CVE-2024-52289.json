{
  "cve_id": "CVE-2024-52289",
  "github_data": {
    "repository": "goauthentik/authentik",
    "fix_commit": "85bb638243c8d7ea42ddd3b15b3f51a90d2b8c54",
    "related_commits": [
      "85bb638243c8d7ea42ddd3b15b3f51a90d2b8c54"
    ],
    "patch_url": "https://github.com/goauthentik/authentik/commit/85bb638243c8d7ea42ddd3b15b3f51a90d2b8c54.patch",
    "fix_commit_details": {
      "sha": "85bb638243c8d7ea42ddd3b15b3f51a90d2b8c54",
      "commit_date": "2024-11-21T13:46:43Z",
      "author": {
        "login": "BeryJu",
        "type": "User",
        "stats": {
          "total_commits": 8916,
          "average_weekly_commits": 27.603715170278637,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 278
        }
      },
      "commit_message": {
        "title": "security: fix CVE 2024 52289 (#12113)",
        "length": 1011,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 887,
        "additions": 688,
        "deletions": 199
      },
      "files": [
        {
          "filename": "authentik/core/tests/test_applications_api.py",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -12,7 +12,7 @@\n from authentik.lib.generators import generate_id\n from authentik.policies.dummy.models import DummyPolicy\n from authentik.policies.models import PolicyBinding\n-from authentik.providers.oauth2.models import OAuth2Provider\n+from authentik.providers.oauth2.models import OAuth2Provider, RedirectURI, RedirectURIMatchingMode\n from authentik.providers.proxy.models import ProxyProvider\n from authentik.providers.saml.models import SAMLProvider\n \n@@ -24,7 +24,7 @@ def setUp(self) -> None:\n         self.user = create_test_admin_user()\n         self.provider = OAuth2Provider.objects.create(\n             name=\"test\",\n-            redirect_uris=\"http://some-other-domain\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://some-other-domain\")],\n             authorization_flow=create_test_flow(),\n         )\n         self.allowed: Application = Application.objects.create("
        },
        {
          "filename": "authentik/core/tests/test_transactional_applications_api.py",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -35,6 +35,7 @@ def test_create_transactional(self):\n                     \"name\": uid,\n                     \"authorization_flow\": str(create_test_flow().pk),\n                     \"invalidation_flow\": str(create_test_flow().pk),\n+                    \"redirect_uris\": [],\n                 },\n             },\n         )\n@@ -89,6 +90,7 @@ def test_create_transactional_bindings(self):\n                     \"name\": uid,\n                     \"authorization_flow\": str(authorization_flow.pk),\n                     \"invalidation_flow\": str(authorization_flow.pk),\n+                    \"redirect_uris\": [],\n                 },\n                 \"policy_bindings\": [{\"group\": group.pk, \"order\": 0}],\n             },\n@@ -120,6 +122,7 @@ def test_create_transactional_invalid(self):\n                     \"name\": uid,\n                     \"authorization_flow\": \"\",\n                     \"invalidation_flow\": \"\",\n+                    \"redirect_uris\": [],\n                 },\n             },\n         )"
        },
        {
          "filename": "authentik/crypto/tests.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -18,7 +18,7 @@\n from authentik.crypto.tasks import MANAGED_DISCOVERED, certificate_discovery\n from authentik.lib.config import CONFIG\n from authentik.lib.generators import generate_id, generate_key\n-from authentik.providers.oauth2.models import OAuth2Provider\n+from authentik.providers.oauth2.models import OAuth2Provider, RedirectURI, RedirectURIMatchingMode\n \n \n class TestCrypto(APITestCase):\n@@ -274,7 +274,7 @@ def test_used_by(self):\n             client_id=\"test\",\n             client_secret=generate_key(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=keypair,\n         )\n         response = self.client.get(\n@@ -306,7 +306,7 @@ def test_used_by_denied(self):\n             client_id=\"test\",\n             client_secret=generate_key(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=keypair,\n         )\n         response = self.client.get("
        },
        {
          "filename": "authentik/providers/oauth2/api/providers.py",
          "status": "modified",
          "additions": 31,
          "deletions": 3,
          "patch": "@@ -1,15 +1,18 @@\n \"\"\"OAuth2Provider API Views\"\"\"\n \n from copy import copy\n+from re import compile\n+from re import error as RegexError\n \n from django.urls import reverse\n from django.utils import timezone\n+from django.utils.translation import gettext_lazy as _\n from drf_spectacular.types import OpenApiTypes\n from drf_spectacular.utils import OpenApiParameter, OpenApiResponse, extend_schema\n from guardian.shortcuts import get_objects_for_user\n from rest_framework.decorators import action\n from rest_framework.exceptions import ValidationError\n-from rest_framework.fields import CharField\n+from rest_framework.fields import CharField, ChoiceField\n from rest_framework.generics import get_object_or_404\n from rest_framework.request import Request\n from rest_framework.response import Response\n@@ -20,13 +23,39 @@\n from authentik.core.api.utils import PassiveSerializer, PropertyMappingPreviewSerializer\n from authentik.core.models import Provider\n from authentik.providers.oauth2.id_token import IDToken\n-from authentik.providers.oauth2.models import AccessToken, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    AccessToken,\n+    OAuth2Provider,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.rbac.decorators import permission_required\n \n \n+class RedirectURISerializer(PassiveSerializer):\n+    \"\"\"A single allowed redirect URI entry\"\"\"\n+\n+    matching_mode = ChoiceField(choices=RedirectURIMatchingMode.choices)\n+    url = CharField()\n+\n+\n class OAuth2ProviderSerializer(ProviderSerializer):\n     \"\"\"OAuth2Provider Serializer\"\"\"\n \n+    redirect_uris = RedirectURISerializer(many=True, source=\"_redirect_uris\")\n+\n+    def validate_redirect_uris(self, data: list) -> list:\n+        for entry in data:\n+            if entry.get(\"matching_mode\") == RedirectURIMatchingMode.REGEX:\n+                url = entry.get(\"url\")\n+                try:\n+                    compile(url)\n+                except RegexError:\n+                    raise ValidationError(\n+                        _(\"Invalid Regex Pattern: {url}\".format(url=url))\n+                    ) from None\n+        return data\n+\n     class Meta:\n         model = OAuth2Provider\n         fields = ProviderSerializer.Meta.fields + [\n@@ -79,7 +108,6 @@ class OAuth2ProviderViewSet(UsedByMixin, ModelViewSet):\n         \"refresh_token_validity\",\n         \"include_claims_in_id_token\",\n         \"signing_key\",\n-        \"redirect_uris\",\n         \"sub_mode\",\n         \"property_mappings\",\n         \"issuer_mode\","
        },
        {
          "filename": "authentik/providers/oauth2/errors.py",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -7,7 +7,7 @@\n from authentik.events.models import Event, EventAction\n from authentik.lib.sentry import SentryIgnoredException\n from authentik.lib.views import bad_request_message\n-from authentik.providers.oauth2.models import GrantTypes\n+from authentik.providers.oauth2.models import GrantTypes, RedirectURI\n \n \n class OAuth2Error(SentryIgnoredException):\n@@ -46,9 +46,9 @@ class RedirectUriError(OAuth2Error):\n     )\n \n     provided_uri: str\n-    allowed_uris: list[str]\n+    allowed_uris: list[RedirectURI]\n \n-    def __init__(self, provided_uri: str, allowed_uris: list[str]) -> None:\n+    def __init__(self, provided_uri: str, allowed_uris: list[RedirectURI]) -> None:\n         super().__init__()\n         self.provided_uri = provided_uri\n         self.allowed_uris = allowed_uris"
        },
        {
          "filename": "authentik/providers/oauth2/migrations/0024_remove_oauth2provider_redirect_uris_and_more.py",
          "status": "added",
          "additions": 48,
          "deletions": 0,
          "patch": "@@ -0,0 +1,48 @@\n+# Generated by Django 5.0.9 on 2024-11-04 12:56\n+from django.apps.registry import Apps\n+\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+from django.db import migrations, models\n+\n+\n+def migrate_redirect_uris(apps: Apps, schema_editor: BaseDatabaseSchemaEditor):\n+    from authentik.providers.oauth2.models import RedirectURI, RedirectURIMatchingMode\n+\n+    OAuth2Provider = apps.get_model(\"authentik_providers_oauth2\", \"oauth2provider\")\n+\n+    db_alias = schema_editor.connection.alias\n+    for provider in OAuth2Provider.objects.using(db_alias).all():\n+        uris = []\n+        for old in provider.old_redirect_uris.split(\"\\n\"):\n+            mode = RedirectURIMatchingMode.STRICT\n+            if old == \"*\" or old == \".*\":\n+                mode = RedirectURIMatchingMode.REGEX\n+            uris.append(RedirectURI(mode, url=old))\n+        provider.redirect_uris = uris\n+        provider.save()\n+\n+\n+class Migration(migrations.Migration):\n+\n+    dependencies = [\n+        (\"authentik_providers_oauth2\", \"0023_alter_accesstoken_refreshtoken_use_hash_index\"),\n+    ]\n+\n+    operations = [\n+        migrations.RenameField(\n+            model_name=\"oauth2provider\",\n+            old_name=\"redirect_uris\",\n+            new_name=\"old_redirect_uris\",\n+        ),\n+        migrations.AddField(\n+            model_name=\"oauth2provider\",\n+            name=\"_redirect_uris\",\n+            field=models.JSONField(default=dict, verbose_name=\"Redirect URIs\"),\n+        ),\n+        migrations.RunPython(migrate_redirect_uris, lambda *args: ...),\n+        migrations.RemoveField(\n+            model_name=\"oauth2provider\",\n+            name=\"old_redirect_uris\",\n+        ),\n+    ]"
        },
        {
          "filename": "authentik/providers/oauth2/models.py",
          "status": "modified",
          "additions": 43,
          "deletions": 9,
          "patch": "@@ -3,7 +3,7 @@\n import base64\n import binascii\n import json\n-from dataclasses import asdict\n+from dataclasses import asdict, dataclass\n from functools import cached_property\n from hashlib import sha256\n from typing import Any\n@@ -12,6 +12,7 @@\n from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePrivateKey\n from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\n from cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes\n+from dacite import Config\n from dacite.core import from_dict\n from django.contrib.postgres.indexes import HashIndex\n from django.db import models\n@@ -77,11 +78,25 @@ class IssuerMode(models.TextChoices):\n     \"\"\"Configure how the `iss` field is created.\"\"\"\n \n     GLOBAL = \"global\", _(\"Same identifier is used for all providers\")\n-    PER_PROVIDER = \"per_provider\", _(\n-        \"Each provider has a different issuer, based on the application slug.\"\n+    PER_PROVIDER = (\n+        \"per_provider\",\n+        _(\"Each provider has a different issuer, based on the application slug.\"),\n     )\n \n \n+class RedirectURIMatchingMode(models.TextChoices):\n+    STRICT = \"strict\", _(\"Strict URL comparison\")\n+    REGEX = \"regex\", _(\"Regular Expression URL matching\")\n+\n+\n+@dataclass\n+class RedirectURI:\n+    \"\"\"A single redirect URI entry\"\"\"\n+\n+    matching_mode: RedirectURIMatchingMode\n+    url: str\n+\n+\n class ResponseTypes(models.TextChoices):\n     \"\"\"Response Type required by the client.\"\"\"\n \n@@ -156,11 +171,9 @@ class OAuth2Provider(WebfingerProvider, Provider):\n         verbose_name=_(\"Client Secret\"),\n         default=generate_client_secret,\n     )\n-    redirect_uris = models.TextField(\n-        default=\"\",\n-        blank=True,\n+    _redirect_uris = models.JSONField(\n+        default=dict,\n         verbose_name=_(\"Redirect URIs\"),\n-        help_text=_(\"Enter each URI on a new line.\"),\n     )\n \n     include_claims_in_id_token = models.BooleanField(\n@@ -271,12 +284,33 @@ def get_issuer(self, request: HttpRequest) -> str | None:\n         except Provider.application.RelatedObjectDoesNotExist:\n             return None\n \n+    @property\n+    def redirect_uris(self) -> list[RedirectURI]:\n+        uris = []\n+        for entry in self._redirect_uris:\n+            uris.append(\n+                from_dict(\n+                    RedirectURI,\n+                    entry,\n+                    config=Config(type_hooks={RedirectURIMatchingMode: RedirectURIMatchingMode}),\n+                )\n+            )\n+        return uris\n+\n+    @redirect_uris.setter\n+    def redirect_uris(self, value: list[RedirectURI]):\n+        cleansed = []\n+        for entry in value:\n+            cleansed.append(asdict(entry))\n+        self._redirect_uris = cleansed\n+\n     @property\n     def launch_url(self) -> str | None:\n         \"\"\"Guess launch_url based on first redirect_uri\"\"\"\n-        if self.redirect_uris == \"\":\n+        redirects = self.redirect_uris\n+        if len(redirects) < 1:\n             return None\n-        main_url = self.redirect_uris.split(\"\\n\", maxsplit=1)[0]\n+        main_url = redirects[0].url\n         try:\n             launch_url = urlparse(main_url)._replace(path=\"\")\n             return urlunparse(launch_url)"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_api.py",
          "status": "modified",
          "additions": 31,
          "deletions": 5,
          "patch": "@@ -10,7 +10,13 @@\n from authentik.blueprints.tests import apply_blueprint\n from authentik.core.models import Application\n from authentik.core.tests.utils import create_test_admin_user, create_test_flow\n-from authentik.providers.oauth2.models import OAuth2Provider, ScopeMapping\n+from authentik.lib.generators import generate_id\n+from authentik.providers.oauth2.models import (\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n \n \n class TestAPI(APITestCase):\n@@ -21,7 +27,7 @@ def setUp(self) -> None:\n         self.provider: OAuth2Provider = OAuth2Provider.objects.create(\n             name=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n         )\n         self.provider.property_mappings.set(ScopeMapping.objects.all())\n         self.app = Application.objects.create(name=\"test\", slug=\"test\", provider=self.provider)\n@@ -50,9 +56,29 @@ def test_setup_urls(self):\n     @skipUnless(version_info >= (3, 11, 4), \"This behaviour is only Python 3.11.4 and up\")\n     def test_launch_url(self):\n         \"\"\"Test launch_url\"\"\"\n-        self.provider.redirect_uris = (\n-            \"https://[\\\\d\\\\w]+.pr.test.goauthentik.io/source/oauth/callback/authentik/\\n\"\n-        )\n+        self.provider.redirect_uris = [\n+            RedirectURI(\n+                RedirectURIMatchingMode.REGEX,\n+                \"https://[\\\\d\\\\w]+.pr.test.goauthentik.io/source/oauth/callback/authentik/\",\n+            ),\n+        ]\n         self.provider.save()\n         self.provider.refresh_from_db()\n         self.assertIsNone(self.provider.launch_url)\n+\n+    def test_validate_redirect_uris(self):\n+        \"\"\"Test redirect_uris API\"\"\"\n+        response = self.client.post(\n+            reverse(\"authentik_api:oauth2provider-list\"),\n+            data={\n+                \"name\": generate_id(),\n+                \"authorization_flow\": create_test_flow().pk,\n+                \"invalidation_flow\": create_test_flow().pk,\n+                \"redirect_uris\": [\n+                    {\"matching_mode\": \"strict\", \"url\": \"http://goauthentik.io\"},\n+                    {\"matching_mode\": \"regex\", \"url\": \"**\"},\n+                ],\n+            },\n+        )\n+        self.assertJSONEqual(response.content, {\"redirect_uris\": [\"Invalid Regex Pattern: **\"]})\n+        self.assertEqual(response.status_code, 400)"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_authorize.py",
          "status": "modified",
          "additions": 17,
          "deletions": 15,
          "patch": "@@ -19,6 +19,8 @@\n     AuthorizationCode,\n     GrantTypes,\n     OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n     ScopeMapping,\n )\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n@@ -39,7 +41,7 @@ def test_invalid_grant_type(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid/Foo\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid/Foo\")],\n         )\n         with self.assertRaises(AuthorizeError):\n             request = self.factory.get(\n@@ -64,7 +66,7 @@ def test_request(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid/Foo\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid/Foo\")],\n         )\n         with self.assertRaises(AuthorizeError):\n             request = self.factory.get(\n@@ -84,7 +86,7 @@ def test_invalid_redirect_uri(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n         )\n         with self.assertRaises(RedirectUriError):\n             request = self.factory.get(\"/\", data={\"response_type\": \"code\", \"client_id\": \"test\"})\n@@ -106,7 +108,7 @@ def test_blocked_redirect_uri(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"data:local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"data:local.invalid\")],\n         )\n         with self.assertRaises(RedirectUriError):\n             request = self.factory.get(\n@@ -125,7 +127,7 @@ def test_invalid_redirect_uri_empty(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"\",\n+            redirect_uris=[],\n         )\n         with self.assertRaises(RedirectUriError):\n             request = self.factory.get(\"/\", data={\"response_type\": \"code\", \"client_id\": \"test\"})\n@@ -140,15 +142,15 @@ def test_invalid_redirect_uri_empty(self):\n         )\n         OAuthAuthorizationParams.from_request(request)\n         provider.refresh_from_db()\n-        self.assertEqual(provider.redirect_uris, \"+\")\n+        self.assertEqual(provider.redirect_uris, [RedirectURI(RedirectURIMatchingMode.STRICT, \"+\")])\n \n     def test_invalid_redirect_uri_regex(self):\n         \"\"\"test missing/invalid redirect URI\"\"\"\n         OAuth2Provider.objects.create(\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid?\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid?\")],\n         )\n         with self.assertRaises(RedirectUriError):\n             request = self.factory.get(\"/\", data={\"response_type\": \"code\", \"client_id\": \"test\"})\n@@ -170,7 +172,7 @@ def test_redirect_uri_invalid_regex(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"+\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"+\")],\n         )\n         with self.assertRaises(RedirectUriError):\n             request = self.factory.get(\"/\", data={\"response_type\": \"code\", \"client_id\": \"test\"})\n@@ -213,7 +215,7 @@ def test_response_type(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid/Foo\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid/Foo\")],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter(\n@@ -301,7 +303,7 @@ def test_full_code(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"foo://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"foo://localhost\")],\n             access_code_validity=\"seconds=100\",\n         )\n         Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n@@ -343,7 +345,7 @@ def test_full_implicit(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=self.keypair,\n         )\n         provider.property_mappings.set(\n@@ -420,7 +422,7 @@ def test_full_implicit_enc(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=self.keypair,\n             encryption_key=self.keypair,\n         )\n@@ -486,7 +488,7 @@ def test_full_fragment_code(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=self.keypair,\n         )\n         Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n@@ -541,7 +543,7 @@ def test_full_form_post_id_token(self):\n             name=generate_id(),\n             client_id=generate_id(),\n             authorization_flow=flow,\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=self.keypair,\n         )\n         provider.property_mappings.set(\n@@ -599,7 +601,7 @@ def test_full_form_post_code(self):\n             name=generate_id(),\n             client_id=generate_id(),\n             authorization_flow=flow,\n-            redirect_uris=\"http://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost\")],\n             signing_key=self.keypair,\n         )\n         app = Application.objects.create(name=generate_id(), slug=generate_id(), provider=provider)"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_introspect.py",
          "status": "modified",
          "additions": 10,
          "deletions": 3,
          "patch": "@@ -11,7 +11,14 @@\n from authentik.core.tests.utils import create_test_admin_user, create_test_cert, create_test_flow\n from authentik.lib.generators import generate_id\n from authentik.providers.oauth2.constants import ACR_AUTHENTIK_DEFAULT\n-from authentik.providers.oauth2.models import AccessToken, IDToken, OAuth2Provider, RefreshToken\n+from authentik.providers.oauth2.models import (\n+    AccessToken,\n+    IDToken,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    RefreshToken,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -23,7 +30,7 @@ def setUp(self) -> None:\n         self.provider: OAuth2Provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"\")],\n             signing_key=create_test_cert(),\n         )\n         self.app = Application.objects.create(\n@@ -118,7 +125,7 @@ def test_introspect_invalid_provider(self):\n         provider: OAuth2Provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"\")],\n             signing_key=create_test_cert(),\n         )\n         auth = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_jwks.py",
          "status": "modified",
          "additions": 6,
          "deletions": 6,
          "patch": "@@ -13,7 +13,7 @@\n from authentik.crypto.builder import PrivateKeyAlg\n from authentik.crypto.models import CertificateKeyPair\n from authentik.lib.generators import generate_id\n-from authentik.providers.oauth2.models import OAuth2Provider\n+from authentik.providers.oauth2.models import OAuth2Provider, RedirectURI, RedirectURIMatchingMode\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n TEST_CORDS_CERT = \"\"\"\n@@ -49,7 +49,7 @@ def test_rs256(self):\n             name=\"test\",\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=create_test_cert(),\n         )\n         app = Application.objects.create(name=\"test\", slug=\"test\", provider=provider)\n@@ -68,7 +68,7 @@ def test_hs256(self):\n             name=\"test\",\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n         )\n         app = Application.objects.create(name=\"test\", slug=\"test\", provider=provider)\n         response = self.client.get(\n@@ -82,7 +82,7 @@ def test_es256(self):\n             name=\"test\",\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=create_test_cert(PrivateKeyAlg.ECDSA),\n         )\n         app = Application.objects.create(name=\"test\", slug=\"test\", provider=provider)\n@@ -99,7 +99,7 @@ def test_enc(self):\n             name=\"test\",\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=create_test_cert(PrivateKeyAlg.ECDSA),\n             encryption_key=create_test_cert(PrivateKeyAlg.ECDSA),\n         )\n@@ -122,7 +122,7 @@ def test_ecdsa_coords_mismatched(self):\n             name=\"test\",\n             client_id=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=cert,\n         )\n         app = Application.objects.create(name=\"test\", slug=\"test\", provider=provider)"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_revoke.py",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -10,7 +10,14 @@\n from authentik.core.models import Application\n from authentik.core.tests.utils import create_test_admin_user, create_test_cert, create_test_flow\n from authentik.lib.generators import generate_id\n-from authentik.providers.oauth2.models import AccessToken, IDToken, OAuth2Provider, RefreshToken\n+from authentik.providers.oauth2.models import (\n+    AccessToken,\n+    IDToken,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    RefreshToken,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -22,7 +29,7 @@ def setUp(self) -> None:\n         self.provider: OAuth2Provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"\")],\n             signing_key=create_test_cert(),\n         )\n         self.app = Application.objects.create("
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token.py",
          "status": "modified",
          "additions": 10,
          "deletions": 8,
          "patch": "@@ -22,6 +22,8 @@\n     AccessToken,\n     AuthorizationCode,\n     OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n     RefreshToken,\n     ScopeMapping,\n )\n@@ -42,7 +44,7 @@ def test_request_auth_code(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://TestServer\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://TestServer\")],\n             signing_key=self.keypair,\n         )\n         header = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()\n@@ -69,7 +71,7 @@ def test_request_auth_code_invalid(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=self.keypair,\n         )\n         header = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()\n@@ -90,7 +92,7 @@ def test_request_refresh_token(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=self.keypair,\n         )\n         header = b64encode(f\"{provider.client_id}:{provider.client_secret}\".encode()).decode()\n@@ -118,7 +120,7 @@ def test_auth_code_view(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=self.keypair,\n         )\n         # Needs to be assigned to an application for iss to be set\n@@ -157,7 +159,7 @@ def test_auth_code_enc(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=self.keypair,\n             encryption_key=self.keypair,\n         )\n@@ -188,7 +190,7 @@ def test_refresh_token_view(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=self.keypair,\n         )\n         provider.property_mappings.set(\n@@ -250,7 +252,7 @@ def test_refresh_token_view_invalid_origin(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://local.invalid\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://local.invalid\")],\n             signing_key=self.keypair,\n         )\n         provider.property_mappings.set(\n@@ -308,7 +310,7 @@ def test_refresh_token_revoke(self):\n         provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=self.keypair,\n         )\n         provider.property_mappings.set("
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_cc_jwt_source.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -19,7 +19,12 @@\n     SCOPE_OPENID_PROFILE,\n     TOKEN_TYPE,\n )\n-from authentik.providers.oauth2.models import OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n from authentik.providers.oauth2.views.jwks import JWKSView\n from authentik.sources.oauth.models import OAuthSource\n@@ -54,7 +59,7 @@ def setUp(self) -> None:\n         self.provider: OAuth2Provider = OAuth2Provider.objects.create(\n             name=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=self.cert,\n         )\n         self.provider.jwks_sources.add(self.source)"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_cc_standard.py",
          "status": "modified",
          "additions": 8,
          "deletions": 2,
          "patch": "@@ -19,7 +19,13 @@\n     TOKEN_TYPE,\n )\n from authentik.providers.oauth2.errors import TokenError\n-from authentik.providers.oauth2.models import AccessToken, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    AccessToken,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -33,7 +39,7 @@ def setUp(self) -> None:\n         self.provider = OAuth2Provider.objects.create(\n             name=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=create_test_cert(),\n         )\n         self.provider.property_mappings.set(ScopeMapping.objects.all())"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_cc_standard_compat.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -20,7 +20,12 @@\n     TOKEN_TYPE,\n )\n from authentik.providers.oauth2.errors import TokenError\n-from authentik.providers.oauth2.models import OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -34,7 +39,7 @@ def setUp(self) -> None:\n         self.provider = OAuth2Provider.objects.create(\n             name=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=create_test_cert(),\n         )\n         self.provider.property_mappings.set(ScopeMapping.objects.all())"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_cc_user_pw.py",
          "status": "modified",
          "additions": 7,
          "deletions": 2,
          "patch": "@@ -19,7 +19,12 @@\n     TOKEN_TYPE,\n )\n from authentik.providers.oauth2.errors import TokenError\n-from authentik.providers.oauth2.models import OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -33,7 +38,7 @@ def setUp(self) -> None:\n         self.provider = OAuth2Provider.objects.create(\n             name=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=create_test_cert(),\n         )\n         self.provider.property_mappings.set(ScopeMapping.objects.all())"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_device.py",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -14,7 +14,14 @@\n     SCOPE_OPENID,\n     SCOPE_OPENID_EMAIL,\n )\n-from authentik.providers.oauth2.models import AccessToken, DeviceToken, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    AccessToken,\n+    DeviceToken,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -28,7 +35,7 @@ def setUp(self) -> None:\n         self.provider = OAuth2Provider.objects.create(\n             name=\"test\",\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"http://testserver\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://testserver\")],\n             signing_key=create_test_cert(),\n         )\n         self.provider.property_mappings.set(ScopeMapping.objects.all())"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_token_pkce.py",
          "status": "modified",
          "additions": 10,
          "deletions": 5,
          "patch": "@@ -10,7 +10,12 @@\n from authentik.core.tests.utils import create_test_admin_user, create_test_flow\n from authentik.lib.generators import generate_id\n from authentik.providers.oauth2.constants import GRANT_TYPE_AUTHORIZATION_CODE\n-from authentik.providers.oauth2.models import AuthorizationCode, OAuth2Provider\n+from authentik.providers.oauth2.models import (\n+    AuthorizationCode,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -30,7 +35,7 @@ def test_pkce_missing_in_authorize(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"foo://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"foo://localhost\")],\n             access_code_validity=\"seconds=100\",\n         )\n         Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n@@ -93,7 +98,7 @@ def test_pkce_missing_in_token(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"foo://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"foo://localhost\")],\n             access_code_validity=\"seconds=100\",\n         )\n         Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n@@ -154,7 +159,7 @@ def test_pkce_correct_s256(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"foo://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"foo://localhost\")],\n             access_code_validity=\"seconds=100\",\n         )\n         Application.objects.create(name=\"app\", slug=\"app\", provider=provider)\n@@ -210,7 +215,7 @@ def test_pkce_correct_plain(self):\n             name=generate_id(),\n             client_id=\"test\",\n             authorization_flow=flow,\n-            redirect_uris=\"foo://localhost\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"foo://localhost\")],\n             access_code_validity=\"seconds=100\",\n         )\n         Application.objects.create(name=\"app\", slug=\"app\", provider=provider)"
        },
        {
          "filename": "authentik/providers/oauth2/tests/test_userinfo.py",
          "status": "modified",
          "additions": 9,
          "deletions": 2,
          "patch": "@@ -11,7 +11,14 @@\n from authentik.core.tests.utils import create_test_admin_user, create_test_cert, create_test_flow\n from authentik.events.models import Event, EventAction\n from authentik.lib.generators import generate_id\n-from authentik.providers.oauth2.models import AccessToken, IDToken, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    AccessToken,\n+    IDToken,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from authentik.providers.oauth2.tests.utils import OAuthTestCase\n \n \n@@ -25,7 +32,7 @@ def setUp(self) -> None:\n         self.provider: OAuth2Provider = OAuth2Provider.objects.create(\n             name=generate_id(),\n             authorization_flow=create_test_flow(),\n-            redirect_uris=\"\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"\")],\n             signing_key=create_test_cert(),\n         )\n         self.provider.property_mappings.set(ScopeMapping.objects.all())"
        },
        {
          "filename": "authentik/providers/oauth2/views/authorize.py",
          "status": "modified",
          "additions": 29,
          "deletions": 28,
          "patch": "@@ -56,6 +56,8 @@\n     AuthorizationCode,\n     GrantTypes,\n     OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n     ResponseMode,\n     ResponseTypes,\n     ScopeMapping,\n@@ -187,40 +189,39 @@ def check_grant(self):\n \n     def check_redirect_uri(self):\n         \"\"\"Redirect URI validation.\"\"\"\n-        allowed_redirect_urls = self.provider.redirect_uris.split()\n+        allowed_redirect_urls = self.provider.redirect_uris\n         if not self.redirect_uri:\n             LOGGER.warning(\"Missing redirect uri.\")\n             raise RedirectUriError(\"\", allowed_redirect_urls)\n \n-        if self.provider.redirect_uris == \"\":\n+        if len(allowed_redirect_urls) < 1:\n             LOGGER.info(\"Setting redirect for blank redirect_uris\", redirect=self.redirect_uri)\n-            self.provider.redirect_uris = self.redirect_uri\n+            self.provider.redirect_uris = [\n+                RedirectURI(RedirectURIMatchingMode.STRICT, self.redirect_uri)\n+            ]\n             self.provider.save()\n-            allowed_redirect_urls = self.provider.redirect_uris.split()\n-\n-        if self.provider.redirect_uris == \"*\":\n-            LOGGER.info(\"Converting redirect_uris to regex\", redirect=self.redirect_uri)\n-            self.provider.redirect_uris = \".*\"\n-            self.provider.save()\n-            allowed_redirect_urls = self.provider.redirect_uris.split()\n-\n-        try:\n-            if not any(fullmatch(x, self.redirect_uri) for x in allowed_redirect_urls):\n-                LOGGER.warning(\n-                    \"Invalid redirect uri (regex comparison)\",\n-                    redirect_uri_given=self.redirect_uri,\n-                    redirect_uri_expected=allowed_redirect_urls,\n-                )\n-                raise RedirectUriError(self.redirect_uri, allowed_redirect_urls)\n-        except RegexError as exc:\n-            LOGGER.info(\"Failed to parse regular expression, checking directly\", exc=exc)\n-            if not any(x == self.redirect_uri for x in allowed_redirect_urls):\n-                LOGGER.warning(\n-                    \"Invalid redirect uri (strict comparison)\",\n-                    redirect_uri_given=self.redirect_uri,\n-                    redirect_uri_expected=allowed_redirect_urls,\n-                )\n-                raise RedirectUriError(self.redirect_uri, allowed_redirect_urls) from None\n+            allowed_redirect_urls = self.provider.redirect_uris\n+\n+        match_found = False\n+        for allowed in allowed_redirect_urls:\n+            if allowed.matching_mode == RedirectURIMatchingMode.STRICT:\n+                if self.redirect_uri == allowed.url:\n+                    match_found = True\n+                    break\n+            if allowed.matching_mode == RedirectURIMatchingMode.REGEX:\n+                try:\n+                    if fullmatch(allowed.url, self.redirect_uri):\n+                        match_found = True\n+                        break\n+                except RegexError as exc:\n+                    LOGGER.warning(\n+                        \"Failed to parse regular expression\",\n+                        exc=exc,\n+                        url=allowed.url,\n+                        provider=self.provider,\n+                    )\n+        if not match_found:\n+            raise RedirectUriError(self.redirect_uri, allowed_redirect_urls)\n         # Check against forbidden schemes\n         if urlparse(self.redirect_uri).scheme in FORBIDDEN_URI_SCHEMES:\n             raise RedirectUriError(self.redirect_uri, allowed_redirect_urls)"
        },
        {
          "filename": "authentik/providers/oauth2/views/provider.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -162,5 +162,5 @@ def dispatch(\n             OAuth2Provider, pk=application.provider_id\n         )\n         response = super().dispatch(request, *args, **kwargs)\n-        cors_allow(request, response, *self.provider.redirect_uris.split(\"\\n\"))\n+        cors_allow(request, response, *[x.url for x in self.provider.redirect_uris])\n         return response"
        },
        {
          "filename": "authentik/providers/oauth2/views/token.py",
          "status": "modified",
          "additions": 45,
          "deletions": 37,
          "patch": "@@ -58,6 +58,7 @@\n     ClientTypes,\n     DeviceToken,\n     OAuth2Provider,\n+    RedirectURIMatchingMode,\n     RefreshToken,\n     ScopeMapping,\n )\n@@ -195,42 +196,7 @@ def __post_init_code(self, raw_code: str, request: HttpRequest):\n             LOGGER.warning(\"Missing authorization code\")\n             raise TokenError(\"invalid_grant\")\n \n-        allowed_redirect_urls = self.provider.redirect_uris.split()\n-        # At this point, no provider should have a blank redirect_uri, in case they do\n-        # this will check an empty array and raise an error\n-        try:\n-            if not any(fullmatch(x, self.redirect_uri) for x in allowed_redirect_urls):\n-                LOGGER.warning(\n-                    \"Invalid redirect uri (regex comparison)\",\n-                    redirect_uri=self.redirect_uri,\n-                    expected=allowed_redirect_urls,\n-                )\n-                Event.new(\n-                    EventAction.CONFIGURATION_ERROR,\n-                    message=\"Invalid redirect URI used by provider\",\n-                    provider=self.provider,\n-                    redirect_uri=self.redirect_uri,\n-                    expected=allowed_redirect_urls,\n-                ).from_http(request)\n-                raise TokenError(\"invalid_client\")\n-        except RegexError as exc:\n-            LOGGER.info(\"Failed to parse regular expression, checking directly\", exc=exc)\n-            if not any(x == self.redirect_uri for x in allowed_redirect_urls):\n-                LOGGER.warning(\n-                    \"Invalid redirect uri (strict comparison)\",\n-                    redirect_uri=self.redirect_uri,\n-                    expected=allowed_redirect_urls,\n-                )\n-                Event.new(\n-                    EventAction.CONFIGURATION_ERROR,\n-                    message=\"Invalid redirect_uri configured\",\n-                    provider=self.provider,\n-                ).from_http(request)\n-                raise TokenError(\"invalid_client\") from None\n-\n-        # Check against forbidden schemes\n-        if urlparse(self.redirect_uri).scheme in FORBIDDEN_URI_SCHEMES:\n-            raise TokenError(\"invalid_request\")\n+        self.__check_redirect_uri(request)\n \n         self.authorization_code = AuthorizationCode.objects.filter(code=raw_code).first()\n         if not self.authorization_code:\n@@ -270,6 +236,48 @@ def __post_init_code(self, raw_code: str, request: HttpRequest):\n         if not self.authorization_code.code_challenge and self.code_verifier:\n             raise TokenError(\"invalid_grant\")\n \n+    def __check_redirect_uri(self, request: HttpRequest):\n+        allowed_redirect_urls = self.provider.redirect_uris\n+        # At this point, no provider should have a blank redirect_uri, in case they do\n+        # this will check an empty array and raise an error\n+\n+        match_found = False\n+        for allowed in allowed_redirect_urls:\n+            if allowed.matching_mode == RedirectURIMatchingMode.STRICT:\n+                if self.redirect_uri == allowed.url:\n+                    match_found = True\n+                    break\n+            if allowed.matching_mode == RedirectURIMatchingMode.REGEX:\n+                try:\n+                    if fullmatch(allowed.url, self.redirect_uri):\n+                        match_found = True\n+                        break\n+                except RegexError as exc:\n+                    LOGGER.warning(\n+                        \"Failed to parse regular expression\",\n+                        exc=exc,\n+                        url=allowed.url,\n+                        provider=self.provider,\n+                    )\n+                    Event.new(\n+                        EventAction.CONFIGURATION_ERROR,\n+                        message=\"Invalid redirect_uri configured\",\n+                        provider=self.provider,\n+                    ).from_http(request)\n+        if not match_found:\n+            Event.new(\n+                EventAction.CONFIGURATION_ERROR,\n+                message=\"Invalid redirect URI used by provider\",\n+                provider=self.provider,\n+                redirect_uri=self.redirect_uri,\n+                expected=allowed_redirect_urls,\n+            ).from_http(request)\n+            raise TokenError(\"invalid_client\")\n+\n+        # Check against forbidden schemes\n+        if urlparse(self.redirect_uri).scheme in FORBIDDEN_URI_SCHEMES:\n+            raise TokenError(\"invalid_request\")\n+\n     def __post_init_refresh(self, raw_token: str, request: HttpRequest):\n         if not raw_token:\n             LOGGER.warning(\"Missing refresh token\")\n@@ -513,7 +521,7 @@ def dispatch(self, request: HttpRequest, *args: Any, **kwargs: Any) -> HttpRespo\n         response = super().dispatch(request, *args, **kwargs)\n         allowed_origins = []\n         if self.provider:\n-            allowed_origins = self.provider.redirect_uris.split(\"\\n\")\n+            allowed_origins = [x.url for x in self.provider.redirect_uris]\n         cors_allow(self.request, response, *allowed_origins)\n         return response\n "
        },
        {
          "filename": "authentik/providers/oauth2/views/userinfo.py",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -108,7 +108,7 @@ def dispatch(self, request: HttpRequest, *args: Any, **kwargs: Any) -> HttpRespo\n         response = super().dispatch(request, *args, **kwargs)\n         allowed_origins = []\n         if self.token:\n-            allowed_origins = self.token.provider.redirect_uris.split(\"\\n\")\n+            allowed_origins = [x.url for x in self.token.provider.redirect_uris]\n         cors_allow(self.request, response, *allowed_origins)\n         return response\n "
        },
        {
          "filename": "authentik/providers/proxy/api.py",
          "status": "modified",
          "additions": 0,
          "deletions": 1,
          "patch": "@@ -121,7 +121,6 @@ class ProxyProviderViewSet(UsedByMixin, ModelViewSet):\n         \"basic_auth_password_attribute\": [\"iexact\"],\n         \"basic_auth_user_attribute\": [\"iexact\"],\n         \"mode\": [\"iexact\"],\n-        \"redirect_uris\": [\"iexact\"],\n         \"cookie_domain\": [\"iexact\"],\n     }\n     search_fields = [\"name\"]"
        },
        {
          "filename": "authentik/providers/proxy/models.py",
          "status": "modified",
          "additions": 14,
          "deletions": 7,
          "patch": "@@ -13,7 +13,13 @@\n from authentik.crypto.models import CertificateKeyPair\n from authentik.lib.models import DomainlessURLValidator\n from authentik.outposts.models import OutpostModel\n-from authentik.providers.oauth2.models import ClientTypes, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    ClientTypes,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n \n SCOPE_AK_PROXY = \"ak_proxy\"\n OUTPOST_CALLBACK_SIGNATURE = \"X-authentik-auth-callback\"\n@@ -24,14 +30,15 @@ def get_cookie_secret():\n     return \"\".join(SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(32))\n \n \n-def _get_callback_url(uri: str) -> str:\n-    return \"\\n\".join(\n-        [\n+def _get_callback_url(uri: str) -> list[RedirectURI]:\n+    return [\n+        RedirectURI(\n+            RedirectURIMatchingMode.STRICT,\n             urljoin(uri, \"outpost.goauthentik.io/callback\")\n             + f\"\\\\?{OUTPOST_CALLBACK_SIGNATURE}=true\",\n-            uri + f\"\\\\?{OUTPOST_CALLBACK_SIGNATURE}=true\",\n-        ]\n-    )\n+        ),\n+        RedirectURI(RedirectURIMatchingMode.STRICT, uri + f\"\\\\?{OUTPOST_CALLBACK_SIGNATURE}=true\"),\n+    ]\n \n \n class ProxyMode(models.TextChoices):"
        },
        {
          "filename": "blueprints/schema.json",
          "status": "modified",
          "additions": 24,
          "deletions": 3,
          "patch": "@@ -5570,9 +5570,30 @@\n                     \"description\": \"Key used to encrypt the tokens. When set, tokens will be encrypted and returned as JWEs.\"\n                 },\n                 \"redirect_uris\": {\n-                    \"type\": \"string\",\n-                    \"title\": \"Redirect URIs\",\n-                    \"description\": \"Enter each URI on a new line.\"\n+                    \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": \"object\",\n+                        \"properties\": {\n+                            \"matching_mode\": {\n+                                \"type\": \"string\",\n+                                \"enum\": [\n+                                    \"strict\",\n+                                    \"regex\"\n+                                ],\n+                                \"title\": \"Matching mode\"\n+                            },\n+                            \"url\": {\n+                                \"type\": \"string\",\n+                                \"minLength\": 1,\n+                                \"title\": \"Url\"\n+                            }\n+                        },\n+                        \"required\": [\n+                            \"matching_mode\",\n+                            \"url\"\n+                        ]\n+                    },\n+                    \"title\": \"Redirect uris\"\n                 },\n                 \"sub_mode\": {\n                     \"type\": \"string\","
        },
        {
          "filename": "schema.yml",
          "status": "modified",
          "additions": 39,
          "deletions": 14,
          "patch": "@@ -20224,10 +20224,6 @@ paths:\n             format: uuid\n         explode: true\n         style: form\n-      - in: query\n-        name: redirect_uris\n-        schema:\n-          type: string\n       - in: query\n         name: refresh_token_validity\n         schema:\n@@ -20643,10 +20639,6 @@ paths:\n             format: uuid\n         explode: true\n         style: form\n-      - in: query\n-        name: redirect_uris__iexact\n-        schema:\n-          type: string\n       - name: search\n         required: false\n         in: query\n@@ -44074,6 +44066,11 @@ components:\n       required:\n       - challenge\n       - name\n+    MatchingModeEnum:\n+      enum:\n+      - strict\n+      - regex\n+      type: string\n     Metadata:\n       type: object\n       description: Serializer for blueprint metadata\n@@ -44776,8 +44773,9 @@ components:\n           description: Key used to encrypt the tokens. When set, tokens will be encrypted\n             and returned as JWEs.\n         redirect_uris:\n-          type: string\n-          description: Enter each URI on a new line.\n+          type: array\n+          items:\n+            $ref: '#/components/schemas/RedirectURI'\n         sub_mode:\n           allOf:\n           - $ref: '#/components/schemas/SubModeEnum'\n@@ -44806,6 +44804,7 @@ components:\n       - meta_model_name\n       - name\n       - pk\n+      - redirect_uris\n       - verbose_name\n       - verbose_name_plural\n     OAuth2ProviderRequest:\n@@ -44877,8 +44876,9 @@ components:\n           description: Key used to encrypt the tokens. When set, tokens will be encrypted\n             and returned as JWEs.\n         redirect_uris:\n-          type: string\n-          description: Enter each URI on a new line.\n+          type: array\n+          items:\n+            $ref: '#/components/schemas/RedirectURIRequest'\n         sub_mode:\n           allOf:\n           - $ref: '#/components/schemas/SubModeEnum'\n@@ -44900,6 +44900,7 @@ components:\n       - authorization_flow\n       - invalidation_flow\n       - name\n+      - redirect_uris\n     OAuth2ProviderSetupURLs:\n       type: object\n       description: OAuth2 Provider Metadata serializer\n@@ -48898,8 +48899,9 @@ components:\n           description: Key used to encrypt the tokens. When set, tokens will be encrypted\n             and returned as JWEs.\n         redirect_uris:\n-          type: string\n-          description: Enter each URI on a new line.\n+          type: array\n+          items:\n+            $ref: '#/components/schemas/RedirectURIRequest'\n         sub_mode:\n           allOf:\n           - $ref: '#/components/schemas/SubModeEnum'\n@@ -52092,6 +52094,29 @@ components:\n           type: string\n       required:\n       - to\n+    RedirectURI:\n+      type: object\n+      description: A single allowed redirect URI entry\n+      properties:\n+        matching_mode:\n+          $ref: '#/components/schemas/MatchingModeEnum'\n+        url:\n+          type: string\n+      required:\n+      - matching_mode\n+      - url\n+    RedirectURIRequest:\n+      type: object\n+      description: A single allowed redirect URI entry\n+      properties:\n+        matching_mode:\n+          $ref: '#/components/schemas/MatchingModeEnum'\n+        url:\n+          type: string\n+          minLength: 1\n+      required:\n+      - matching_mode\n+      - url\n     Reputation:\n       type: object\n       description: Reputation Serializer"
        },
        {
          "filename": "tests/e2e/test_provider_oauth2_github.py",
          "status": "modified",
          "additions": 15,
          "deletions": 4,
          "patch": "@@ -12,7 +12,12 @@\n from authentik.lib.generators import generate_id, generate_key\n from authentik.policies.expression.models import ExpressionPolicy\n from authentik.policies.models import PolicyBinding\n-from authentik.providers.oauth2.models import ClientTypes, OAuth2Provider\n+from authentik.providers.oauth2.models import (\n+    ClientTypes,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+)\n from tests.e2e.utils import SeleniumTestCase, retry\n \n \n@@ -73,7 +78,9 @@ def test_authorization_consent_implied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             client_type=ClientTypes.CONFIDENTIAL,\n-            redirect_uris=\"http://localhost:3000/login/github\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/github\")\n+            ],\n             authorization_flow=authorization_flow,\n         )\n         Application.objects.create(\n@@ -128,7 +135,9 @@ def test_authorization_consent_explicit(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             client_type=ClientTypes.CONFIDENTIAL,\n-            redirect_uris=\"http://localhost:3000/login/github\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/github\")\n+            ],\n             authorization_flow=authorization_flow,\n         )\n         app = Application.objects.create(\n@@ -199,7 +208,9 @@ def test_denied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             client_type=ClientTypes.CONFIDENTIAL,\n-            redirect_uris=\"http://localhost:3000/login/github\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/github\")\n+            ],\n             authorization_flow=authorization_flow,\n         )\n         app = Application.objects.create("
        },
        {
          "filename": "tests/e2e/test_provider_oauth2_grafana.py",
          "status": "modified",
          "additions": 28,
          "deletions": 6,
          "patch": "@@ -19,7 +19,13 @@\n     SCOPE_OPENID_EMAIL,\n     SCOPE_OPENID_PROFILE,\n )\n-from authentik.providers.oauth2.models import ClientTypes, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    ClientTypes,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from tests.e2e.utils import SeleniumTestCase, retry\n \n \n@@ -82,7 +88,7 @@ def test_redirect_uri_error(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:3000/\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:3000/\")],\n             authorization_flow=authorization_flow,\n         )\n         provider.property_mappings.set(\n@@ -131,7 +137,11 @@ def test_authorization_consent_implied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:3000/login/generic_oauth\",\n+            redirect_uris=[\n+                RedirectURI(\n+                    RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/generic_oauth\"\n+                )\n+            ],\n             authorization_flow=authorization_flow,\n         )\n         provider.property_mappings.set(\n@@ -200,7 +210,11 @@ def test_authorization_logout(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:3000/login/generic_oauth\",\n+            redirect_uris=[\n+                RedirectURI(\n+                    RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/generic_oauth\"\n+                )\n+            ],\n             authorization_flow=authorization_flow,\n             invalidation_flow=invalidation_flow,\n         )\n@@ -275,7 +289,11 @@ def test_authorization_consent_explicit(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:3000/login/generic_oauth\",\n+            redirect_uris=[\n+                RedirectURI(\n+                    RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/generic_oauth\"\n+                )\n+            ],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter(\n@@ -355,7 +373,11 @@ def test_authorization_denied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:3000/login/generic_oauth\",\n+            redirect_uris=[\n+                RedirectURI(\n+                    RedirectURIMatchingMode.STRICT, \"http://localhost:3000/login/generic_oauth\"\n+                )\n+            ],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter("
        },
        {
          "filename": "tests/e2e/test_provider_oidc.py",
          "status": "modified",
          "additions": 17,
          "deletions": 5,
          "patch": "@@ -19,7 +19,13 @@\n     SCOPE_OPENID_EMAIL,\n     SCOPE_OPENID_PROFILE,\n )\n-from authentik.providers.oauth2.models import ClientTypes, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    ClientTypes,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from tests.e2e.utils import SeleniumTestCase, retry\n \n \n@@ -67,7 +73,7 @@ def test_redirect_uri_error(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/\")],\n             authorization_flow=authorization_flow,\n         )\n         provider.property_mappings.set(\n@@ -116,7 +122,9 @@ def test_authorization_consent_implied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/auth/callback\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/auth/callback\")\n+            ],\n             authorization_flow=authorization_flow,\n         )\n         provider.property_mappings.set(\n@@ -188,7 +196,9 @@ def test_authorization_consent_explicit(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/auth/callback\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/auth/callback\")\n+            ],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter(\n@@ -259,7 +269,9 @@ def test_authorization_denied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/auth/callback\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/auth/callback\")\n+            ],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter("
        },
        {
          "filename": "tests/e2e/test_provider_oidc_implicit.py",
          "status": "modified",
          "additions": 17,
          "deletions": 5,
          "patch": "@@ -19,7 +19,13 @@\n     SCOPE_OPENID_EMAIL,\n     SCOPE_OPENID_PROFILE,\n )\n-from authentik.providers.oauth2.models import ClientTypes, OAuth2Provider, ScopeMapping\n+from authentik.providers.oauth2.models import (\n+    ClientTypes,\n+    OAuth2Provider,\n+    RedirectURI,\n+    RedirectURIMatchingMode,\n+    ScopeMapping,\n+)\n from tests.e2e.utils import SeleniumTestCase, retry\n \n \n@@ -68,7 +74,7 @@ def test_redirect_uri_error(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/\",\n+            redirect_uris=[RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/\")],\n             authorization_flow=authorization_flow,\n         )\n         provider.property_mappings.set(\n@@ -117,7 +123,9 @@ def test_authorization_consent_implied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/implicit/\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/implicit/\")\n+            ],\n             authorization_flow=authorization_flow,\n         )\n         provider.property_mappings.set(\n@@ -170,7 +178,9 @@ def test_authorization_consent_explicit(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/implicit/\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/implicit/\")\n+            ],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter(\n@@ -238,7 +248,9 @@ def test_authorization_denied(self):\n             client_id=self.client_id,\n             client_secret=self.client_secret,\n             signing_key=create_test_cert(),\n-            redirect_uris=\"http://localhost:9009/implicit/\",\n+            redirect_uris=[\n+                RedirectURI(RedirectURIMatchingMode.STRICT, \"http://localhost:9009/implicit/\")\n+            ],\n         )\n         provider.property_mappings.set(\n             ScopeMapping.objects.filter("
        },
        {
          "filename": "web/src/admin/providers/oauth2/OAuth2ProviderForm.ts",
          "status": "modified",
          "additions": 37,
          "deletions": 8,
          "patch": "@@ -1,11 +1,16 @@\n import \"@goauthentik/admin/common/ak-crypto-certificate-search\";\n import \"@goauthentik/admin/common/ak-flow-search/ak-flow-search\";\n import { BaseProviderForm } from \"@goauthentik/admin/providers/BaseProviderForm\";\n+import {\n+    IRedirectURIInput,\n+    akOAuthRedirectURIInput,\n+} from \"@goauthentik/admin/providers/oauth2/OAuth2ProviderRedirectURI\";\n import { DEFAULT_CONFIG } from \"@goauthentik/common/api/config\";\n import { ascii_letters, digits, first, randomString } from \"@goauthentik/common/utils\";\n import \"@goauthentik/components/ak-radio-input\";\n import \"@goauthentik/components/ak-text-input\";\n import \"@goauthentik/components/ak-textarea-input\";\n+import \"@goauthentik/elements/ak-array-input.js\";\n import \"@goauthentik/elements/ak-dual-select/ak-dual-select-dynamic-selected-provider.js\";\n import \"@goauthentik/elements/ak-dual-select/ak-dual-select-provider.js\";\n import \"@goauthentik/elements/forms/FormGroup\";\n@@ -15,16 +20,18 @@ import \"@goauthentik/elements/forms/SearchSelect\";\n import \"@goauthentik/elements/utils/TimeDeltaHelp\";\n \n import { msg } from \"@lit/localize\";\n-import { TemplateResult, html } from \"lit\";\n+import { TemplateResult, css, html } from \"lit\";\n import { customElement, state } from \"lit/decorators.js\";\n import { ifDefined } from \"lit/directives/if-defined.js\";\n \n import {\n     ClientTypeEnum,\n     FlowsInstancesListDesignationEnum,\n     IssuerModeEnum,\n+    MatchingModeEnum,\n     OAuth2Provider,\n     ProvidersApi,\n+    RedirectURI,\n     SubModeEnum,\n } from \"@goauthentik/api\";\n \n@@ -98,13 +105,13 @@ export const issuerModeOptions = [\n \n const redirectUriHelpMessages = [\n     msg(\n-        \"Valid redirect URLs after a successful authorization flow. Also specify any origins here for Implicit flows.\",\n+        \"Valid redirect URIs after a successful authorization flow. Also specify any origins here for Implicit flows.\",\n     ),\n     msg(\n         \"If no explicit redirect URIs are specified, the first successfully used redirect URI will be saved.\",\n     ),\n     msg(\n-        'To allow any redirect URI, set this value to \".*\". Be aware of the possible security implications this can have.',\n+        'To allow any redirect URI, set the mode to Regex and the value to \".*\". Be aware of the possible security implications this can have.',\n     ),\n ];\n \n@@ -124,11 +131,23 @@ export class OAuth2ProviderFormPage extends BaseProviderForm<OAuth2Provider> {\n     @state()\n     showClientSecret = true;\n \n+    @state()\n+    redirectUris: RedirectURI[] = [];\n+\n+    static get styles() {\n+        return super.styles.concat(css`\n+            ak-array-input {\n+                width: 100%;\n+            }\n+        `);\n+    }\n+\n     async loadInstance(pk: number): Promise<OAuth2Provider> {\n         const provider = await new ProvidersApi(DEFAULT_CONFIG).providersOauth2Retrieve({\n             id: pk,\n         });\n         this.showClientSecret = provider.clientType === ClientTypeEnum.Confidential;\n+        this.redirectUris = provider.redirectUris;\n         return provider;\n     }\n \n@@ -203,13 +222,23 @@ export class OAuth2ProviderFormPage extends BaseProviderForm<OAuth2Provider> {\n                         ?hidden=${!this.showClientSecret}\n                     >\n                     </ak-text-input>\n-                    <ak-textarea-input\n+                    <ak-form-element-horizontal\n+                        label=${msg(\"Redirect URIs/Origins\")}\n+                        required\n                         name=\"redirectUris\"\n-                        label=${msg(\"Redirect URIs/Origins (RegEx)\")}\n-                        .value=${provider?.redirectUris}\n-                        .bighelp=${redirectUriHelp}\n                     >\n-                    </ak-textarea-input>\n+                        <ak-array-input\n+                            .items=${this.instance?.redirectUris ?? []}\n+                            .newItem=${() => ({ matchingMode: MatchingModeEnum.Strict, url: \"\" })}\n+                            .row=${(f?: RedirectURI) =>\n+                                akOAuthRedirectURIInput({\n+                                    \".redirectURI\": f,\n+                                    \"style\": \"width: 100%\",\n+                                } as unknown as IRedirectURIInput)}\n+                        >\n+                        </ak-array-input>\n+                        ${redirectUriHelp}\n+                    </ak-form-element-horizontal>\n \n                     <ak-form-element-horizontal label=${msg(\"Signing Key\")} name=\"signingKey\">\n                         <!-- NOTE: 'null' cast to 'undefined' on signingKey to satisfy Lit requirements -->"
        },
        {
          "filename": "web/src/admin/providers/oauth2/OAuth2ProviderRedirectURI.ts",
          "status": "added",
          "additions": 104,
          "deletions": 0,
          "patch": "@@ -0,0 +1,104 @@\n+import \"@goauthentik/admin/providers/oauth2/OAuth2ProviderRedirectURI\";\n+import { AkControlElement } from \"@goauthentik/elements/AkControlElement.js\";\n+import { type Spread } from \"@goauthentik/elements/types\";\n+import { spread } from \"@open-wc/lit-helpers\";\n+\n+import { msg } from \"@lit/localize\";\n+import { css, html } from \"lit\";\n+import { customElement, property, queryAll } from \"lit/decorators.js\";\n+import { ifDefined } from \"lit/directives/if-defined.js\";\n+\n+import PFFormControl from \"@patternfly/patternfly/components/FormControl/form-control.css\";\n+import PFInputGroup from \"@patternfly/patternfly/components/InputGroup/input-group.css\";\n+import PFBase from \"@patternfly/patternfly/patternfly-base.css\";\n+\n+import { MatchingModeEnum, RedirectURI } from \"@goauthentik/api\";\n+\n+export interface IRedirectURIInput {\n+    redirectURI: RedirectURI;\n+}\n+\n+@customElement(\"ak-provider-oauth2-redirect-uri\")\n+export class OAuth2ProviderRedirectURI extends AkControlElement<RedirectURI> {\n+    static get styles() {\n+        return [\n+            PFBase,\n+            PFInputGroup,\n+            PFFormControl,\n+            css`\n+                .pf-c-input-group select {\n+                    width: 10em;\n+                }\n+            `,\n+        ];\n+    }\n+\n+    @property({ type: Object, attribute: false })\n+    redirectURI: RedirectURI = {\n+        matchingMode: MatchingModeEnum.Strict,\n+        url: \"\",\n+    };\n+\n+    @queryAll(\".ak-form-control\")\n+    controls?: HTMLInputElement[];\n+\n+    json() {\n+        return Object.fromEntries(\n+            Array.from(this.controls ?? []).map((control) => [control.name, control.value]),\n+        ) as unknown as RedirectURI;\n+    }\n+\n+    get isValid() {\n+        return true;\n+    }\n+\n+    render() {\n+        const onChange = () => {\n+            this.dispatchEvent(new Event(\"change\", { composed: true, bubbles: true }));\n+        };\n+\n+        return html`<div class=\"pf-c-input-group\">\n+            <select\n+                name=\"matchingMode\"\n+                class=\"pf-c-form-control ak-form-control\"\n+                @change=${onChange}\n+            >\n+                <option\n+                    value=\"${MatchingModeEnum.Strict}\"\n+                    ?selected=${this.redirectURI.matchingMode === MatchingModeEnum.Strict}\n+                >\n+                    ${msg(\"Strict\")}\n+                </option>\n+                <option\n+                    value=\"${MatchingModeEnum.Regex}\"\n+                    ?selected=${this.redirectURI.matchingMode === MatchingModeEnum.Regex}\n+                >\n+                    ${msg(\"Regex\")}\n+                </option>\n+            </select>\n+            <input\n+                type=\"text\"\n+                @change=${onChange}\n+                value=\"${ifDefined(this.redirectURI.url ?? undefined)}\"\n+                class=\"pf-c-form-control ak-form-control\"\n+                required\n+                id=\"url\"\n+                placeholder=${msg(\"URL\")}\n+                name=\"href\"\n+                tabindex=\"1\"\n+            />\n+        </div>`;\n+    }\n+}\n+\n+export function akOAuthRedirectURIInput(properties: IRedirectURIInput) {\n+    return html`<ak-provider-oauth2-redirect-uri\n+        ${spread(properties as unknown as Spread)}\n+    ></ak-provider-oauth2-redirect-uri>`;\n+}\n+\n+declare global {\n+    interface HTMLElementTagNameMap {\n+        \"ak-provider-oauth2-redirect-uri\": OAuth2ProviderRedirectURI;\n+    }\n+}"
        },
        {
          "filename": "web/src/elements/forms/HorizontalFormElement.ts",
          "status": "modified",
          "additions": 13,
          "deletions": 3,
          "patch": "@@ -2,7 +2,7 @@ import { convertToSlug } from \"@goauthentik/common/utils\";\n import { AKElement } from \"@goauthentik/elements/Base\";\n import { FormGroup } from \"@goauthentik/elements/forms/FormGroup\";\n \n-import { msg } from \"@lit/localize\";\n+import { msg, str } from \"@lit/localize\";\n import { CSSResult, css } from \"lit\";\n import { TemplateResult, html } from \"lit\";\n import { customElement, property } from \"lit/decorators.js\";\n@@ -33,7 +33,7 @@ import PFBase from \"@patternfly/patternfly/patternfly-base.css\";\n  *    where the field isn't available for the user to view unless they explicitly request to be able\n  *    to see the content; otherwise, a dead password field is shown. There are 10 uses of this\n  *    feature.\n- * \n+ *\n  */\n \n const isAkControl = (el: unknown): boolean =>\n@@ -86,7 +86,7 @@ export class HorizontalFormElement extends AKElement {\n     writeOnlyActivated = false;\n \n     @property({ attribute: false })\n-    errorMessages: string[] = [];\n+    errorMessages: string[] | string[][] = [];\n \n     @property({ type: Boolean })\n     slugMode = false;\n@@ -183,6 +183,16 @@ export class HorizontalFormElement extends AKElement {\n                           </p>`\n                         : html``}\n                     ${this.errorMessages.map((message) => {\n+                        if (message instanceof Object) {\n+                            return html`${Object.entries(message).map(([field, errMsg]) => {\n+                                return html`<p\n+                                    class=\"pf-c-form__helper-text pf-m-error\"\n+                                    aria-live=\"polite\"\n+                                >\n+                                    ${msg(str`${field}: ${errMsg}`)}\n+                                </p>`;\n+                            })}`;\n+                        }\n                         return html`<p class=\"pf-c-form__helper-text pf-m-error\" aria-live=\"polite\">\n                             ${message}\n                         </p>`;"
        },
        {
          "filename": "website/docs/security/cves/CVE-2024-52289.md",
          "status": "added",
          "additions": 30,
          "deletions": 0,
          "patch": "@@ -0,0 +1,30 @@\n+# CVE-2024-52289\n+\n+_Reported by [@PontusHanssen](https://github.com/PontusHanssen)_\n+\n+## Insecure default configuration for OAuth2 Redirect URIs\n+\n+### Summary\n+\n+Redirect URIs in the OAuth2 provider in authentik are checked by RegEx comparison.\n+When no Redirect URIs are configured in a provider, authentik will automatically use the first `redirect_uri` value received as an allowed redirect URI, without escaping characters that have a special meaning in RegEx. Similarly, the documentation did not take this into consideration either.\n+\n+Given a provider with the Redirect URIs set to `https://foo.example.com`, an attacker can register a domain `fooaexample.com`, and it will correctly pass validation.\n+\n+### Patches\n+\n+authentik 2024.8.5 and 2024.10.3 fix this issue.\n+\n+The patched versions remedy this issue by changing the format that the Redirect URIs are saved in, allowing for the explicit configuration if the URL should be checked strictly or as a RegEx. This means that these patches include a backwards-incompatible database change and API change.\n+\n+Manual action _is required_ if any provider is intended to use RegEx for Redirect URIs because the migration will set the comparison type to strict for every Redirect URI.\n+\n+### Workarounds\n+\n+When configuring OAuth2 providers, make sure to escape any wildcard characters that are not intended to function as a wildcard, for example replace `.` with `\\.`.\n+\n+### For more information\n+\n+If you have any questions or comments about this advisory:\n+\n+-   Email us at [security@goauthentik.io](mailto:security@goauthentik.io)"
        },
        {
          "filename": "website/sidebars.js",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -659,6 +659,7 @@ export default {\n                             label: \"2024\",\n                             items: [\n                                 \"security/cves/CVE-2024-52307\",\n+                                \"security/cves/CVE-2024-52289\",\n                                 \"security/cves/CVE-2024-52287\",\n                                 \"security/cves/CVE-2024-47077\",\n                                 \"security/cves/CVE-2024-47070\","
        }
      ],
      "file_patterns": {
        "security_files": 31,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 20,
        "unique_directories": 15,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "336f6f0dc2067d12138f0992ab3cc4b3c47cf5ce",
            "date": "2025-01-14T21:42:56Z",
            "author_login": "itskagee"
          },
          {
            "sha": "c19a8873563a5d337bde6865a7a69d4bd1a6d83f",
            "date": "2025-01-14T19:15:02Z",
            "author_login": "BeryJu"
          },
          {
            "sha": "09931bcbc20f4527acfcd9046fe1caeeda446c50",
            "date": "2025-01-14T14:56:03Z",
            "author_login": "BeryJu"
          },
          {
            "sha": "7a4293bf178ac7c6a2222593feef560053e16cbc",
            "date": "2025-01-14T12:40:25Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "6e569acd845bbcc79c50f40542bd729dd2243840",
            "date": "2025-01-14T12:40:17Z",
            "author_login": "dependabot[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-185",
    "description": "authentik is an open-source identity provider. Redirect URIs in the OAuth2 provider in authentik are checked by RegEx comparison.\nWhen no Redirect URIs are configured in a provider, authentik will automatically use the first redirect_uri value received as an allowed redirect URI, without escaping characters that have a special meaning in RegEx. Similarly, the documentation did not take this into consideration either. Given a provider with the Redirect URIs set to https://foo.example.com, an attacker can register a domain fooaexample.com, and it will correctly pass validation. authentik 2024.8.5 and 2024.10.3 fix this issue. As a workaround, When configuring OAuth2 providers, make sure to escape any wildcard characters that are not intended to function as a wildcard, for example replace `.` with `\\.`.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-21T18:15:12.060",
    "last_modified": "2024-11-21T18:15:12.060",
    "fix_date": "2024-11-21T13:46:43Z"
  },
  "references": [
    {
      "url": "https://github.com/goauthentik/authentik/commit/85bb638243c8d7ea42ddd3b15b3f51a90d2b8c54",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/goauthentik/authentik/security/advisories/GHSA-3q5w-6m3x-64gj",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.277582",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "authentik",
    "owner": "goauthentik",
    "created_at": "2019-12-30T09:19:48Z",
    "updated_at": "2025-01-14T12:40:29Z",
    "pushed_at": "2025-01-14T13:17:29Z",
    "size": 348330,
    "stars": 14458,
    "forks": 984,
    "open_issues": 728,
    "watchers": 14458,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 3995415,
      "TypeScript": 2892221,
      "Go": 308962,
      "MDX": 124483,
      "JavaScript": 69953,
      "HTML": 24617,
      "Rust": 22748,
      "CSS": 19762,
      "Dockerfile": 15501,
      "Makefile": 9222,
      "Shell": 7042,
      "PHP": 1149
    },
    "commit_activity": {
      "total_commits_last_year": 3169,
      "avg_commits_per_week": 60.94230769230769,
      "days_active_last_year": 295
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:32:32.687051"
  }
}