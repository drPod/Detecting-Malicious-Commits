{
  "cve_id": "CVE-2024-52295",
  "github_data": {
    "repository": "dataease/dataease",
    "fix_commit": "e755248d59543bcd668ace495f293ff735fa82e9",
    "related_commits": [
      "e755248d59543bcd668ace495f293ff735fa82e9"
    ],
    "patch_url": "https://github.com/dataease/dataease/commit/e755248d59543bcd668ace495f293ff735fa82e9.patch",
    "fix_commit_details": {
      "sha": "e755248d59543bcd668ace495f293ff735fa82e9",
      "commit_date": "2024-09-29T09:20:16Z",
      "author": {
        "login": "fit2cloud-chenyw",
        "type": "User",
        "stats": {
          "total_commits": 3992,
          "average_weekly_commits": 5.17769130998703,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 186
        }
      },
      "commit_message": {
        "title": "perf: \u793e\u533a\u7248token\u673a\u5236",
        "length": 16,
        "has_description": false,
        "references_issue": false
      },
      "stats": {
        "total": 183,
        "additions": 169,
        "deletions": 14
      },
      "files": [
        {
          "filename": "core/core-backend/src/main/java/io/dataease/substitute/permissions/login/SubstituleLoginServer.java",
          "status": "modified",
          "additions": 24,
          "deletions": 6,
          "patch": "@@ -5,14 +5,17 @@\n import com.auth0.jwt.algorithms.Algorithm;\n import io.dataease.api.permissions.login.dto.PwdLoginDTO;\n import io.dataease.auth.bo.TokenUserBO;\n+import io.dataease.auth.config.SubstituleLoginConfig;\n import io.dataease.auth.vo.TokenVO;\n+import io.dataease.exception.DEException;\n+import io.dataease.i18n.Translator;\n import io.dataease.utils.LogUtil;\n+import io.dataease.utils.Md5Utils;\n+import io.dataease.utils.RsaUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.stereotype.Component;\n-import org.springframework.web.bind.annotation.GetMapping;\n-import org.springframework.web.bind.annotation.PostMapping;\n-import org.springframework.web.bind.annotation.RequestMapping;\n-import org.springframework.web.bind.annotation.RestController;\n+import org.springframework.web.bind.annotation.*;\n \n @Component\n @ConditionalOnMissingBean(name = \"loginServer\")\n@@ -21,11 +24,26 @@\n public class SubstituleLoginServer {\n \n     @PostMapping(\"/login/localLogin\")\n-    public TokenVO localLogin(PwdLoginDTO dto) {\n+    public TokenVO localLogin(@RequestBody PwdLoginDTO dto) {\n+\n+        String name = dto.getName();\n+        name = RsaUtils.decryptStr(name);\n+        String pwd = dto.getPwd();\n+        pwd = RsaUtils.decryptStr(pwd);\n+\n+        dto.setName(name);\n+        dto.setPwd(pwd);\n+\n+        if (!StringUtils.equals(\"admin\", name)) {\n+            DEException.throwException(\"\u4ec5admin\u8d26\u53f7\u53ef\u7528\");\n+        }\n+        if (!StringUtils.equals(pwd, SubstituleLoginConfig.getPwd())) {\n+            DEException.throwException(Translator.get(\"i18n_login_name_pwd_err\"));\n+        }\n         TokenUserBO tokenUserBO = new TokenUserBO();\n         tokenUserBO.setUserId(1L);\n         tokenUserBO.setDefaultOid(1L);\n-        String md5Pwd = \"83d923c9f1d8fcaa46cae0ed2aaa81b5\";\n+        String md5Pwd = Md5Utils.md5(pwd);\n         return generate(tokenUserBO, md5Pwd);\n     }\n "
        },
        {
          "filename": "de-xpack",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -1 +1 @@\n-Subproject commit f028be49a62cb21a53c11fa4f931946417381a55\n+Subproject commit 1aae01674cc0dd042bbb5eac7f1cc54f30b9d23d"
        },
        {
          "filename": "sdk/common/src/main/java/io/dataease/auth/config/SubstituleLoginConfig.java",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+package io.dataease.auth.config;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.dataease.utils.CommonBeanFactory;\n+import io.dataease.utils.LogUtil;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.env.Environment;\n+import org.springframework.core.io.ResourceLoader;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+@ConditionalOnMissingBean(name = \"loginServer\")\n+@Configuration\n+public class SubstituleLoginConfig {\n+\n+\n+    private static String jsonFilePath = \"classpath:substitule.json\";\n+\n+    private static String pwd;\n+\n+    private static boolean ready = false;\n+\n+\n+    @ConditionalOnMissingBean(name = \"loginServer\")\n+    @Bean\n+    public Map<String, Object> substituleLoginData(ResourceLoader resourceLoader) throws IOException {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        File jsonFile = new File(jsonFilePath);\n+        if (!jsonFile.exists()) {\n+            pwd = CommonBeanFactory.getBean(Environment.class).getProperty(\"dataease.default-pwd\", \"DataEase@123456\");\n+            modifyPwd(pwd);\n+        }\n+        return objectMapper.readValue(jsonFile, Map.class);\n+    }\n+\n+    public static String getPwd() {\n+        if (!ready) {\n+            ready = true;\n+            Object substituleLoginDataObject = CommonBeanFactory.getBean(\"substituleLoginData\");\n+            if (substituleLoginDataObject != null) {\n+                Map<String, Object> substituleLoginData = (Map<String, Object>) substituleLoginDataObject;\n+                if (ObjectUtils.isNotEmpty(substituleLoginData.get(\"pwd\"))) {\n+                    pwd = substituleLoginData.get(\"pwd\").toString();\n+                    return substituleLoginData.get(\"pwd\").toString();\n+                }\n+            }\n+        }\n+        return pwd;\n+    }\n+\n+    public static void modifyPwd(String pwd) {\n+        File file = new File(jsonFilePath);\n+        Map<String, String> myObject = new HashMap<>();\n+        myObject.put(\"pwd\", pwd);\n+        SubstituleLoginConfig.pwd = pwd;\n+        ObjectMapper mapper = new ObjectMapper();\n+        try (FileOutputStream fos = new FileOutputStream(file)) {\n+            // \u5c06\u5bf9\u8c61\u5199\u5165\u6587\u4ef6\n+            mapper.writeValue(fos, myObject);\n+        } catch (IOException e) {\n+            LogUtil.error(e.getCause(), new Throwable(e));\n+        }\n+    }\n+}"
        },
        {
          "filename": "sdk/common/src/main/java/io/dataease/auth/filter/TokenFilter.java",
          "status": "modified",
          "additions": 40,
          "deletions": 6,
          "patch": "@@ -6,13 +6,22 @@\n import jakarta.servlet.FilterConfig;\n import jakarta.servlet.*;\n import jakarta.servlet.http.HttpServletRequest;\n+import jakarta.servlet.http.HttpServletResponse;\n import org.apache.commons.lang3.StringUtils;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.HttpStatusCode;\n+import org.springframework.http.ResponseEntity;\n \n import java.io.IOException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n import java.util.Objects;\n \n public class TokenFilter implements Filter {\n \n+    private static final String headName = \"DE-GATEWAY-FLAG\";\n+\n     @Override\n     public void init(FilterConfig filterConfig) throws ServletException {\n     }\n@@ -36,10 +45,6 @@ public void doFilter(ServletRequest servletRequest, ServletResponse servletRespo\n             filterChain.doFilter(servletRequest, servletResponse);\n             return;\n         }\n-        /*String refreshToken = null;\n-        if (StringUtils.isNotBlank(refreshToken = ServletUtils.request().getHeader(AuthConstant.REFRESH_TOKEN_KEY))) {\n-            ServletUtils.response().addHeader(AuthConstant.REFRESH_TOKEN_KEY, refreshToken);\n-        }*/\n         String executeVersion = null;\n         if (StringUtils.isNotBlank(executeVersion = VersionUtil.getRandomVersion())) {\n             Objects.requireNonNull(ServletUtils.response()).addHeader(AuthConstant.DE_EXECUTE_VERSION, executeVersion);\n@@ -52,12 +57,41 @@ public void doFilter(ServletRequest servletRequest, ServletResponse servletRespo\n             return;\n         }\n         String token = ServletUtils.getToken();\n-        TokenUserBO userBO = TokenUtils.validate(token);\n-        UserUtils.setUserInfo(userBO);\n+        TokenUserBO userBO = null;\n+        try {\n+            userBO = TokenUtils.validate(token);\n+            UserUtils.setUserInfo(userBO);\n+        } catch (Exception e) {\n+            HttpServletResponse res = (HttpServletResponse) servletResponse;\n+            LogUtil.error(e.getMessage(), e);\n+            HttpHeaders headers = new HttpHeaders();\n+            String msg = URLEncoder.encode(e.getMessage(), StandardCharsets.UTF_8).replace(\"+\", \"%20\");\n+            headers.add(headName, msg);\n+            sendResponseEntity(res, new ResponseEntity<>(e.getMessage(), headers, HttpStatus.UNAUTHORIZED));\n+            return;\n+        }\n         filterChain.doFilter(servletRequest, servletResponse);\n     }\n \n     @Override\n     public void destroy() {\n     }\n+\n+    private void sendResponseEntity(HttpServletResponse httpResponse, ResponseEntity<String> responseEntity) throws IOException {\n+        HttpHeaders headers = responseEntity.getHeaders();\n+        HttpStatusCode statusCode = responseEntity.getStatusCode();\n+\n+        // \u8bbe\u7f6e\u72b6\u6001\u7801\n+        httpResponse.setStatus(statusCode.value());\n+\n+        // \u8bbe\u7f6e\u54cd\u5e94\u5934\n+        if (headers != null) {\n+            for (String name : headers.keySet()) {\n+                httpResponse.setHeader(name, headers.getFirst(name));\n+            }\n+        }\n+\n+        // \u8bbe\u7f6e\u54cd\u5e94\u4f53\n+        httpResponse.getWriter().write(responseEntity.getBody());\n+    }\n }"
        },
        {
          "filename": "sdk/common/src/main/java/io/dataease/utils/TokenUtils.java",
          "status": "modified",
          "additions": 33,
          "deletions": 1,
          "patch": "@@ -1,11 +1,19 @@\n package io.dataease.utils;\n \n import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.auth0.jwt.interfaces.Verification;\n import io.dataease.auth.bo.TokenUserBO;\n+import io.dataease.auth.config.SubstituleLoginConfig;\n import io.dataease.exception.DEException;\n+import io.dataease.license.utils.LicenseUtil;\n import org.apache.commons.lang3.ObjectUtils;\n import org.apache.commons.lang3.StringUtils;\n+import org.springframework.util.ReflectionUtils;\n+\n+import java.lang.reflect.Method;\n \n public class TokenUtils {\n \n@@ -28,9 +36,33 @@ public static TokenUserBO validate(String token) {\n         if (StringUtils.length(token) < 100) {\n             DEException.throwException(\"token is invalid\");\n         }\n-        return userBOByToken(token);\n+        TokenUserBO userBO = userBOByToken(token);\n+        if (ObjectUtils.isEmpty(userBO) || LicenseUtil.licenseValid()) {\n+            return userBO;\n+        }\n+        Long userId = userBO.getUserId();\n+        String secret = null;\n+        if (ObjectUtils.isEmpty(CommonBeanFactory.getBean(\"loginServer\"))) {\n+            String pwd = SubstituleLoginConfig.getPwd();\n+            secret = Md5Utils.md5(pwd);\n+        } else {\n+            Object apisixTokenManage = CommonBeanFactory.getBean(\"apisixTokenManage\");\n+            Method method = DeReflectUtil.findMethod(apisixTokenManage.getClass(), \"userCacheBO\");\n+            Object o = ReflectionUtils.invokeMethod(method, apisixTokenManage, userId);\n+            Method pwdMethod = DeReflectUtil.findMethod(o.getClass(), \"getPwd\");\n+            Object pwdObj = ReflectionUtils.invokeMethod(pwdMethod, o);\n+            secret = pwdObj.toString();\n+        }\n+        Algorithm algorithm = Algorithm.HMAC256(secret);\n+        Verification verification = JWT.require(algorithm).withClaim(\"uid\", userId).withClaim(\"oid\", userBO.getDefaultOid());\n+        JWTVerifier verifier = verification.build();\n+        DecodedJWT decode = JWT.decode(token);\n+        algorithm.verify(decode);\n+        verifier.verify(token);\n+        return userBO;\n     }\n \n+\n     public static TokenUserBO validateLinkToken(String linkToken) {\n         if (StringUtils.isBlank(linkToken)) {\n             String uri = ServletUtils.request().getRequestURI();"
        }
      ],
      "file_patterns": {
        "security_files": 2,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 10
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "3d7dcc9e7523ab298dc57ba412989f659794c3e4",
            "date": "2025-01-14T10:19:36Z",
            "author_login": "dataeaseShu"
          },
          {
            "sha": "e6c5f45bb7e044fedbe2aa03daf01f3c330e73f5",
            "date": "2025-01-14T09:55:57Z",
            "author_login": "ulleo"
          },
          {
            "sha": "8a25535ecafdbca3d1d966ebffbee228a495d2cd",
            "date": "2025-01-14T09:50:53Z",
            "author_login": "dataeaseShu"
          },
          {
            "sha": "bb7be5c912c59408fcbc4c675d9db42e20d9e355",
            "date": "2025-01-14T09:50:29Z",
            "author_login": "dataeaseShu"
          },
          {
            "sha": "60b0f9c124f9d2fe13e2457f38dff16e7b4525b4",
            "date": "2025-01-14T09:18:10Z",
            "author_login": "ulleo"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-798",
    "description": "DataEase is an open source data visualization analysis tool. Prior to 2.10.2, DataEase allows attackers to forge jwt and take over services. The JWT secret is hardcoded in the code, and the UID and OID are hardcoded. The vulnerability has been fixed in v2.10.2.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-13T16:15:19.550",
    "last_modified": "2024-11-21T15:15:32.900",
    "fix_date": "2024-09-29T09:20:16Z"
  },
  "references": [
    {
      "url": "https://github.com/dataease/dataease/commit/e755248d59543bcd668ace495f293ff735fa82e9",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/dataease/dataease/security/advisories/GHSA-45v9-gfcv-xcq6",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:29.291593",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "dataease",
    "owner": "dataease",
    "created_at": "2021-02-02T04:10:21Z",
    "updated_at": "2025-01-14T14:38:02Z",
    "pushed_at": "2025-01-14T11:00:19Z",
    "size": 298499,
    "stars": 18879,
    "forks": 3405,
    "open_issues": 388,
    "watchers": 18879,
    "has_security_policy": false,
    "default_branch": "dev-v2",
    "protected_branches": [
      "dev"
    ],
    "languages": {
      "Java": 15120013,
      "Vue": 3999652,
      "Shell": 26817,
      "Lua": 22086,
      "Less": 12316,
      "Dockerfile": 952
    },
    "commit_activity": {
      "total_commits_last_year": 7385,
      "avg_commits_per_week": 142.01923076923077,
      "days_active_last_year": 278
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-3.0"
    },
    "collected_at": "2025-01-14T15:09:59.807295"
  }
}