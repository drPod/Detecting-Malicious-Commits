{
  "cve_id": "CVE-2024-52581",
  "github_data": {
    "repository": "litestar-org/litestar",
    "fix_commit": "53c1473b5ff7502816a9a339ffc90731bb0c2138",
    "related_commits": [
      "53c1473b5ff7502816a9a339ffc90731bb0c2138"
    ],
    "patch_url": "https://github.com/litestar-org/litestar/commit/53c1473b5ff7502816a9a339ffc90731bb0c2138.patch",
    "fix_commit_details": {
      "sha": "53c1473b5ff7502816a9a339ffc90731bb0c2138",
      "commit_date": "2024-11-20T15:09:41Z",
      "author": {
        "login": "provinzkraut",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 133,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 454,
        "additions": 387,
        "deletions": 67
      },
      "files": [
        {
          "filename": "docs/usage/requests.rst",
          "status": "modified",
          "additions": 49,
          "deletions": 0,
          "patch": "@@ -160,3 +160,52 @@ The example below illustrates how to implement custom request class for the whol\n    class on multiple layers, the layer closest to the route handler will take precedence.\n \n    You can read more about this in the :ref:`usage/applications:layered architecture` section\n+\n+\n+Limits\n+-------\n+\n+Body size\n+^^^^^^^^^^\n+\n+A limit for the allowed request body size can be set on all layers via the\n+``request_max_body_size`` parameter and defaults to 10MB. If a request body exceeds this\n+limit, a ``413 - Request Entity Too Large``\n+response will be returned. This limit applies to all methods of consuming the request\n+body, including requesting it via the ``body`` parameter in a route handler and\n+consuming it through a manually constructed :class:`~litestar.connection.Request`\n+instance, e.g. in a middleware.\n+\n+To disable this limit for a specific handler / router / controller, it can be set to\n+:obj:`None`.\n+\n+.. danger::\n+    Setting ``request_max_body_size=None`` is strongly discouraged as it exposes the\n+    application to a denial of service (DoS) attack by sending arbitrarily large\n+    request bodies to the affected endpoint. Because Litestar has to read the whole body\n+    to perform certain actions, such as parsing JSON, it will fill up all the available\n+    memory / swap until the application / server crashes, should no outside limits be\n+    imposed.\n+\n+    This is generally only recommended in environments where the application is running\n+    behind a reverse proxy such as NGINX, where a size limit is already set.\n+\n+\n+.. danger::\n+    Since ``request_max_body_size`` is handled on a per-request basis, it won't affect\n+    middlewares or ASGI handlers when they try to access the request body via the raw\n+    ASGI events. To avoid this, middlewares and ASGI handlers should construct a\n+    :class:`~litestar.connection.Request` instance and use the regular\n+    :meth:`~litestar.connection.Request.stream` /\n+    :meth:`~litestar.connection.Request.body` or content-appropriate method to consume\n+    the request body in a safe manner.\n+\n+\n+.. tip::\n+    For requests that define a ``Content-Length`` header, Litestar will not attempt to\n+    read the request body should the header value exceed the ``request_max_body_size``.\n+\n+    If the header value is within the allowed bounds, Litestar will verify during the\n+    streaming of the request body that it does not exceed the size specified in the\n+    header. Should the request exceed this size, it will abort the request with a\n+    ``400 - Bad Request``."
        },
        {
          "filename": "litestar/app.py",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -202,6 +202,7 @@ def __init__(\n         path: str | None = None,\n         plugins: Sequence[PluginProtocol] | None = None,\n         request_class: type[Request] | None = None,\n+        request_max_body_size: int | None = 10_000_000,\n         response_cache_config: ResponseCacheConfig | None = None,\n         response_class: type[Response] | None = None,\n         response_cookies: ResponseCookies | None = None,\n@@ -286,6 +287,8 @@ def __init__(\n             pdb_on_exception: Drop into the PDB when an exception occurs.\n             plugins: Sequence of plugins.\n             request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded, a\n+                '413 - Request Entity Too Large' error response is returned.\n             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n                 response.\n             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n@@ -361,6 +364,7 @@ def __init__(\n             pdb_on_exception=pdb_on_exception,\n             plugins=self._get_default_plugins(list(plugins or [])),\n             request_class=request_class,\n+            request_max_body_size=request_max_body_size,\n             response_cache_config=response_cache_config or ResponseCacheConfig(),\n             response_class=response_class,\n             response_cookies=response_cookies or [],\n@@ -464,6 +468,7 @@ def __init__(\n             parameters=config.parameters,\n             path=config.path,\n             request_class=self.request_class,\n+            request_max_body_size=request_max_body_size,\n             response_class=config.response_class,\n             response_cookies=config.response_cookies,\n             response_headers=config.response_headers,"
        },
        {
          "filename": "litestar/config/app.py",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -163,6 +163,9 @@ class AppConfig:\n     \"\"\"List of :class:`SerializationPluginProtocol <.plugins.SerializationPluginProtocol>`.\"\"\"\n     request_class: type[Request] | None = field(default=None)\n     \"\"\"An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\"\"\"\n+    request_max_body_size: int | None | EmptyType = Empty\n+    \"\"\"Maximum allowed size of the request body in bytes. If this size is exceeded, a '413 - Request Entity Too Large'\n+    error response is returned.\"\"\"\n     response_class: type[Response] | None = field(default=None)\n     \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the app's default response.\"\"\"\n     response_cookies: ResponseCookies = field(default_factory=list)"
        },
        {
          "filename": "litestar/connection/request.py",
          "status": "modified",
          "additions": 61,
          "deletions": 5,
          "patch": "@@ -1,7 +1,8 @@\n from __future__ import annotations\n \n+import math\n import warnings\n-from typing import TYPE_CHECKING, Any, AsyncGenerator, Generic\n+from typing import TYPE_CHECKING, Any, AsyncGenerator, Generic, cast\n \n from litestar._multipart import parse_content_header, parse_multipart_form\n from litestar._parsers import parse_url_encoded_form_data\n@@ -17,12 +18,14 @@\n from litestar.datastructures.multi_dicts import FormMultiDict\n from litestar.enums import ASGIExtension, RequestEncodingType\n from litestar.exceptions import (\n+    ClientException,\n     InternalServerException,\n     LitestarException,\n     LitestarWarning,\n )\n+from litestar.exceptions.http_exceptions import RequestEntityTooLarge\n from litestar.serialization import decode_json, decode_msgpack\n-from litestar.types import Empty\n+from litestar.types import Empty, HTTPReceiveMessage\n \n __all__ = (\"Request\",)\n \n@@ -52,6 +55,7 @@ class Request(Generic[UserT, AuthT, StateT], ASGIConnection[\"HTTPRouteHandler\",\n         \"_msgpack\",\n         \"_content_type\",\n         \"_accept\",\n+        \"_content_length\",\n         \"is_connected\",\n         \"supports_push_promise\",\n     )\n@@ -79,6 +83,7 @@ def __init__(self, scope: Scope, receive: Receive = empty_receive, send: Send =\n         self._msgpack: Any = Empty\n         self._content_type: tuple[str, dict[str, str]] | EmptyType = Empty\n         self._accept: Accept | EmptyType = Empty\n+        self._content_length: int | None | EmptyType = Empty\n         self.supports_push_promise = ASGIExtension.SERVER_PUSH in self._server_extensions\n \n     @property\n@@ -152,6 +157,21 @@ async def msgpack(self) -> Any:\n                 )\n         return self._msgpack\n \n+    @property\n+    def content_length(self) -> int | None:\n+        cached_content_length = self._content_length\n+        if cached_content_length is not Empty:\n+            return cached_content_length\n+\n+        content_length_header = self.headers.get(\"content-length\")\n+        try:\n+            content_length = self._content_length = (\n+                int(content_length_header) if content_length_header is not None else None\n+            )\n+        except ValueError:\n+            raise ClientException(f\"Invalid content-length: {content_length_header!r}\") from None\n+        return content_length\n+\n     async def stream(self) -> AsyncGenerator[bytes, None]:\n         \"\"\"Return an async generator that streams chunks of bytes.\n \n@@ -164,10 +184,46 @@ async def stream(self) -> AsyncGenerator[bytes, None]:\n         if self._body is Empty:\n             if not self.is_connected:\n                 raise InternalServerException(\"stream consumed\")\n-            while event := await self.receive():\n+\n+            announced_content_length = self.content_length\n+            # setting this to 'math.inf' as a micro-optimisation; Comparing against a\n+            # float is slightly faster than checking if a value is 'None' and then\n+            # comparing it to an int. since we expect a limit to be set most of the\n+            # time, this is a bit more efficient\n+            max_content_length = self.route_handler.resolve_request_max_body_size() or math.inf\n+\n+            # if the 'content-length' header is set, and exceeds the limit, we can bail\n+            # out early before reading anything\n+            if announced_content_length is not None and announced_content_length > max_content_length:\n+                raise RequestEntityTooLarge\n+\n+            total_bytes_streamed: int = 0\n+            while event := cast(\"HTTPReceiveMessage\", await self.receive()):\n                 if event[\"type\"] == \"http.request\":\n-                    if event[\"body\"]:\n-                        yield event[\"body\"]\n+                    body = event[\"body\"]\n+                    if body:\n+                        total_bytes_streamed += len(body)\n+\n+                        # if a 'content-length' header was set, check if we have\n+                        # received more bytes than specified. in most cases this should\n+                        # be caught before it hits the application layer and an ASGI\n+                        # server (e.g. uvicorn) will not allow this, but since it's not\n+                        # forbidden according to the HTTP or ASGI spec, we err on the\n+                        # side of caution and still perform this check.\n+                        #\n+                        # uvicorn documented behaviour for this case:\n+                        # https://github.com/encode/uvicorn/blob/fe3910083e3990695bc19c2ef671dd447262ae18/docs/server-behavior.md?plain=1#L11\n+                        if announced_content_length:\n+                            if total_bytes_streamed > announced_content_length:\n+                                raise ClientException(\"Malformed request\")\n+\n+                        # we don't have a 'content-length' header, likely a chunked\n+                        # transfer. we don't really care and simply check if we have\n+                        # received more bytes than allowed\n+                        elif total_bytes_streamed > max_content_length:\n+                            raise RequestEntityTooLarge\n+\n+                        yield body\n \n                     if not event.get(\"more_body\", False):\n                         break"
        },
        {
          "filename": "litestar/controller.py",
          "status": "modified",
          "additions": 10,
          "deletions": 0,
          "patch": "@@ -64,6 +64,7 @@ class Controller:\n         \"parameters\",\n         \"path\",\n         \"request_class\",\n+        \"request_max_body_size\",\n         \"response_class\",\n         \"response_cookies\",\n         \"response_headers\",\n@@ -136,6 +137,11 @@ class Controller:\n     \"\"\"A custom subclass of :class:`Request <.connection.Request>` to be used as the default request for all route\n     handlers under the controller.\n     \"\"\"\n+    request_max_body_size: int | None | EmptyType\n+    \"\"\"\n+    Maximum allowed size of the request body in bytes. If this size is exceeded, a '413 - Request Entity Too Large'\n+    error response is returned.\"\"\"\n+\n     response_class: type[Response] | None\n     \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the default response for all route\n     handlers under the controller.\n@@ -191,6 +197,9 @@ def __init__(self, owner: Router) -> None:\n         if not hasattr(self, \"include_in_schema\"):\n             self.include_in_schema = Empty\n \n+        if not hasattr(self, \"request_max_body_size\"):\n+            self.request_max_body_size = Empty\n+\n         self.signature_namespace = add_types_to_signature_namespace(\n             getattr(self, \"signature_types\", []), getattr(self, \"signature_namespace\", {})\n         )\n@@ -235,6 +244,7 @@ def as_router(self) -> Router:\n             type_encoders=self.type_encoders,\n             type_decoders=self.type_decoders,\n             websocket_class=self.websocket_class,\n+            request_max_body_size=self.request_max_body_size,\n         )\n         router.owner = self.owner\n         return router"
        },
        {
          "filename": "litestar/exceptions/http_exceptions.py",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -10,6 +10,7 @@\n     HTTP_403_FORBIDDEN,\n     HTTP_404_NOT_FOUND,\n     HTTP_405_METHOD_NOT_ALLOWED,\n+    HTTP_413_REQUEST_ENTITY_TOO_LARGE,\n     HTTP_429_TOO_MANY_REQUESTS,\n     HTTP_500_INTERNAL_SERVER_ERROR,\n     HTTP_503_SERVICE_UNAVAILABLE,\n@@ -119,6 +120,11 @@ class MethodNotAllowedException(ClientException):\n     status_code = HTTP_405_METHOD_NOT_ALLOWED\n \n \n+class RequestEntityTooLarge(ClientException):\n+    status_code = HTTP_413_REQUEST_ENTITY_TOO_LARGE\n+    detail = \"Request Entity Too Large\"\n+\n+\n class TooManyRequestsException(ClientException):\n     \"\"\"Request limits have been exceeded.\"\"\"\n "
        },
        {
          "filename": "litestar/handlers/http_handlers/base.py",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -82,6 +82,7 @@ class HTTPRouteHandler(BaseRouteHandler):\n         \"_resolved_request_class\",\n         \"_resolved_tags\",\n         \"_resolved_security\",\n+        \"_resolved_request_max_body_size\",\n         \"after_request\",\n         \"after_response\",\n         \"background\",\n@@ -113,6 +114,7 @@ class HTTPRouteHandler(BaseRouteHandler):\n         \"sync_to_thread\",\n         \"tags\",\n         \"template_name\",\n+        \"request_max_body_size\",\n     )\n \n     has_sync_callable: bool\n@@ -139,6 +141,7 @@ def __init__(\n         name: str | None = None,\n         opt: Mapping[str, Any] | None = None,\n         request_class: type[Request] | None = None,\n+        request_max_body_size: int | None | EmptyType = Empty,\n         response_class: type[Response] | None = None,\n         response_cookies: ResponseCookies | None = None,\n         response_headers: ResponseHeaders | None = None,\n@@ -204,6 +207,8 @@ def __init__(\n                 :class:`ASGI Scope <.types.Scope>`.\n             request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's\n                 default request.\n+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,\n+                a '413 - Request Entity Too Large' error response is returned.\n             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's\n                 default response.\n             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.\n@@ -272,6 +277,7 @@ def __init__(\n         self.response_class = response_class\n         self.response_cookies: Sequence[Cookie] | None = narrow_response_cookies(response_cookies)\n         self.response_headers: Sequence[ResponseHeader] | None = narrow_response_headers(response_headers)\n+        self.request_max_body_size = request_max_body_size\n \n         self.sync_to_thread = sync_to_thread\n         # OpenAPI related attributes\n@@ -297,6 +303,7 @@ def __init__(\n         self._resolved_request_class: type[Request] | EmptyType = Empty\n         self._resolved_security: list[SecurityRequirement] | EmptyType = Empty\n         self._resolved_tags: list[str] | EmptyType = Empty\n+        self._resolved_request_max_body_size: int | EmptyType | None = Empty\n \n     def __call__(self, fn: AnyCallable) -> HTTPRouteHandler:\n         \"\"\"Replace a function with itself.\"\"\"\n@@ -473,6 +480,25 @@ def resolve_tags(self) -> list[str]:\n \n         return self._resolved_tags\n \n+    def resolve_request_max_body_size(self) -> int | None:\n+        if (resolved_limits := self._resolved_request_max_body_size) is not Empty:\n+            return resolved_limits\n+\n+        max_body_size = self._resolved_request_max_body_size = next(  # pyright: ignore\n+            (\n+                max_body_size\n+                for layer in reversed(self.ownership_layers)\n+                if (max_body_size := layer.request_max_body_size) is not Empty\n+            ),\n+            Empty,\n+        )\n+        if max_body_size is Empty:\n+            raise ImproperlyConfiguredException(\n+                \"'request_max_body_size' set to 'Empty' on all layers. To omit a limit, \"\n+                \"set 'request_max_body_size=None'\"\n+            )\n+        return max_body_size\n+\n     def get_response_handler(self, is_response_type_data: bool = False) -> Callable[[Any], Awaitable[ASGIApp]]:\n         \"\"\"Resolve the response_handler function for the route handler.\n "
        },
        {
          "filename": "litestar/handlers/http_handlers/decorators.py",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -628,6 +628,7 @@ def __init__(\n         name: str | None = None,\n         opt: Mapping[str, Any] | None = None,\n         request_class: type[Request] | None = None,\n+        request_max_body_size: int | None | EmptyType = Empty,\n         response_class: type[Response] | None = None,\n         response_cookies: ResponseCookies | None = None,\n         response_headers: ResponseHeaders | None = None,\n@@ -692,6 +693,8 @@ def __init__(\n                 wherever you have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <.types.Scope>`.\n             request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's\n                 default request.\n+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,\n+                a '413 - Request Entity Too Large' error response is returned.\n             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's\n                 default response.\n             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.\n@@ -755,6 +758,7 @@ def __init__(\n             path=path,\n             raises=raises,\n             request_class=request_class,\n+            request_max_body_size=request_max_body_size,\n             response_class=response_class,\n             response_cookies=response_cookies,\n             response_description=response_description,\n@@ -803,6 +807,7 @@ def __init__(\n         name: str | None = None,\n         opt: Mapping[str, Any] | None = None,\n         request_class: type[Request] | None = None,\n+        request_max_body_size: int | None | EmptyType = Empty,\n         response_class: type[Response] | None = None,\n         response_cookies: ResponseCookies | None = None,\n         response_headers: ResponseHeaders | None = None,\n@@ -867,6 +872,8 @@ def __init__(\n                 wherever you have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <.types.Scope>`.\n             request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's\n                 default request.\n+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,\n+                a '413 - Request Entity Too Large' error response is returned.\n             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's\n                 default response.\n             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.\n@@ -930,6 +937,7 @@ def __init__(\n             path=path,\n             raises=raises,\n             request_class=request_class,\n+            request_max_body_size=request_max_body_size,\n             response_class=response_class,\n             response_cookies=response_cookies,\n             response_description=response_description,\n@@ -978,6 +986,7 @@ def __init__(\n         name: str | None = None,\n         opt: Mapping[str, Any] | None = None,\n         request_class: type[Request] | None = None,\n+        request_max_body_size: int | None | EmptyType = Empty,\n         response_class: type[Response] | None = None,\n         response_cookies: ResponseCookies | None = None,\n         response_headers: ResponseHeaders | None = None,\n@@ -1042,6 +1051,8 @@ def __init__(\n                 wherever you have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <.types.Scope>`.\n             request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's\n                 default request.\n+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,\n+                a '413 - Request Entity Too Large' error response is returned.\n             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's\n                 default response.\n             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.\n@@ -1105,6 +1116,7 @@ def __init__(\n             path=path,\n             raises=raises,\n             request_class=request_class,\n+            request_max_body_size=request_max_body_size,\n             response_class=response_class,\n             response_cookies=response_cookies,\n             response_description=response_description,"
        },
        {
          "filename": "litestar/router.py",
          "status": "modified",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -68,6 +68,7 @@ class Router:\n         \"path\",\n         \"registered_route_handler_ids\",\n         \"request_class\",\n+        \"request_max_body_size\",\n         \"response_class\",\n         \"response_cookies\",\n         \"response_headers\",\n@@ -111,6 +112,7 @@ def __init__(\n         type_decoders: TypeDecodersSequence | None = None,\n         type_encoders: TypeEncodersMap | None = None,\n         websocket_class: type[WebSocket] | None = None,\n+        request_max_body_size: int | None | EmptyType = Empty,\n     ) -> None:\n         \"\"\"Initialize a ``Router``.\n \n@@ -143,6 +145,8 @@ def __init__(\n                 with the router instance.\n             request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as the default for\n                 all route handlers, controllers and other routers associated with the router instance.\n+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,\n+                a '413 - Request Entity Too Large\" error response is returned.\n             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the default for\n                 all route handlers, controllers and other routers associated with the router instance.\n             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.\n@@ -197,6 +201,7 @@ def __init__(\n         self.type_encoders = dict(type_encoders) if type_encoders is not None else None\n         self.type_decoders = list(type_decoders) if type_decoders is not None else None\n         self.websocket_class = websocket_class\n+        self.request_max_body_size = request_max_body_size\n \n         for route_handler in route_handlers or []:\n             self.register(value=route_handler)"
        },
        {
          "filename": "tests/conftest.py",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -216,6 +216,7 @@ def inner(\n             \"route_handler\": route_handler,\n             \"user\": user,\n             \"session\": session,\n+            \"headers\": [],\n             **kwargs,\n         }\n         return cast(\"Scope\", scope)"
        },
        {
          "filename": "tests/unit/test_connection/test_connection_caching.py",
          "status": "modified",
          "additions": 10,
          "deletions": 2,
          "patch": "@@ -5,7 +5,7 @@\n \n import pytest\n \n-from litestar import Request\n+from litestar import Request, post\n from litestar.testing import RequestFactory\n from litestar.types import Empty, HTTPReceiveMessage, Scope\n from litestar.utils.scope.state import ScopeState\n@@ -17,11 +17,15 @@ async def test_multiple_request_object_data_caching(create_scope: Callable[...,\n     https://github.com/litestar-org/litestar/issues/2727\n     \"\"\"\n \n+    @post(\"/\", request_max_body_size=None)\n+    async def handler() -> None:\n+        pass\n+\n     async def test_receive() -> HTTPReceiveMessage:\n         mock()\n         return {\"type\": \"http.request\", \"body\": b\"abc\", \"more_body\": False}\n \n-    scope = create_scope()\n+    scope = create_scope(route_handler=handler)\n     request_1 = Request[Any, Any, Any](scope, test_receive)\n     request_2 = Request[Any, Any, Any](scope, test_receive)\n     assert (await request_1.body()) == b\"abc\"\n@@ -121,6 +125,8 @@ def check_get_mock() -> None:\n             get_mock.assert_has_calls([call(state_key), call(\"headers\")])\n         elif state_key == \"form\":\n             get_mock.assert_has_calls([call(state_key), call(\"content_type\")])\n+        elif state_key == \"body\":\n+            get_mock.assert_has_calls([call(state_key), call(\"headers\")])\n         else:\n             get_mock.assert_called_once_with(state_key)\n \n@@ -136,6 +142,8 @@ def check_set_mock() -> None:\n             set_mock.assert_has_calls([call(\"content_type\", ANY), call(state_key, ANY)])\n         elif state_key in {\"accept\", \"cookies\", \"content_type\"}:\n             set_mock.assert_has_calls([call(\"headers\", ANY), call(state_key, ANY)])\n+        elif state_key == \"body\":\n+            set_mock.assert_has_calls([call(\"headers\", ANY), call(state_key, ANY)])\n         else:\n             set_mock.assert_called_once_with(state_key, ANY)\n "
        },
        {
          "filename": "tests/unit/test_connection/test_request.py",
          "status": "modified",
          "additions": 133,
          "deletions": 60,
          "patch": "@@ -11,7 +11,7 @@\n \n import pytest\n \n-from litestar import MediaType, Request, asgi, get, post\n+from litestar import MediaType, Request, get, post\n from litestar.connection.base import AuthT, StateT, UserT, empty_send\n from litestar.datastructures import Address, Cookie, State\n from litestar.exceptions import (\n@@ -24,6 +24,7 @@\n from litestar.response.base import ASGIResponse\n from litestar.serialization import encode_json, encode_msgpack\n from litestar.static_files.config import StaticFilesConfig\n+from litestar.status_codes import HTTP_400_BAD_REQUEST, HTTP_413_REQUEST_ENTITY_TOO_LARGE\n from litestar.testing import TestClient, create_test_client\n \n if TYPE_CHECKING:\n@@ -32,7 +33,7 @@\n     from litestar.types import ASGIApp, Receive, Scope, Send\n \n \n-@get(\"/\", sync_to_thread=False)\n+@get(\"/\", sync_to_thread=False, request_max_body_size=None)\n def _route_handler() -> None:\n     pass\n \n@@ -230,56 +231,51 @@ def test_request_client(\n \n \n def test_request_body() -> None:\n-    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n-        request = Request[Any, Any, State](scope, receive)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n         body = await request.body()\n-        response = ASGIResponse(body=encode_json({\"body\": body.decode()}))\n-        await response(scope, receive, send)\n-\n-    client = TestClient(app)\n+        return encode_json({\"body\": body.decode()})\n \n-    response = client.get(\"/\")\n-    assert response.json() == {\"body\": \"\"}\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\")\n+        assert response.json() == {\"body\": \"\"}\n \n-    response = client.post(\"/\", json={\"a\": \"123\"})\n-    assert response.json() == {\"body\": '{\"a\": \"123\"}'}\n+        response = client.post(\"/\", json={\"a\": \"123\"})\n+        assert response.json() == {\"body\": '{\"a\": \"123\"}'}\n \n-    response = client.post(\"/\", content=\"abc\")\n-    assert response.json() == {\"body\": \"abc\"}\n+        response = client.post(\"/\", content=\"abc\")\n+        assert response.json() == {\"body\": \"abc\"}\n \n \n def test_request_stream() -> None:\n-    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n-        request = Request[Any, Any, State](scope, receive)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n         body = b\"\"\n         async for chunk in request.stream():\n             body += chunk\n-        response = ASGIResponse(body=encode_json({\"body\": body.decode()}))\n-        await response(scope, receive, send)\n+        return encode_json({\"body\": body.decode()})\n \n-    client = TestClient(app)\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\")\n+        assert response.json() == {\"body\": \"\"}\n \n-    response = client.get(\"/\")\n-    assert response.json() == {\"body\": \"\"}\n-\n-    response = client.post(\"/\", json={\"a\": \"123\"})\n-    assert response.json() == {\"body\": '{\"a\": \"123\"}'}\n+        response = client.post(\"/\", json={\"a\": \"123\"})\n+        assert response.json() == {\"body\": '{\"a\": \"123\"}'}\n \n-    response = client.post(\"/\", content=\"abc\")\n-    assert response.json() == {\"body\": \"abc\"}\n+        response = client.post(\"/\", content=\"abc\")\n+        assert response.json() == {\"body\": \"abc\"}\n \n \n def test_request_form_urlencoded() -> None:\n-    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n-        request = Request[Any, Any, State](scope, receive)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n         form = await request.form()\n-        response = ASGIResponse(body=encode_json({\"form\": dict(form)}))\n-        await response(scope, receive, send)\n \n-    client = TestClient(app)\n+        return encode_json({\"form\": dict(form)})\n \n-    response = client.post(\"/\", data={\"abc\": \"123 @\"})\n-    assert response.json() == {\"form\": {\"abc\": \"123 @\"}}\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\", data={\"abc\": \"123 @\"})\n+        assert response.json() == {\"form\": {\"abc\": \"123 @\"}}\n \n \n def test_request_form_urlencoded_multi_keys() -> None:\n@@ -301,19 +297,17 @@ async def handler(request: Request) -> int:\n \n \n def test_request_body_then_stream() -> None:\n-    async def app(scope: Any, receive: Receive, send: Send) -> None:\n-        request = Request[Any, Any, State](scope, receive)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n         body = await request.body()\n         chunks = b\"\"\n         async for chunk in request.stream():\n             chunks += chunk\n-        response = ASGIResponse(body=encode_json({\"body\": body.decode(), \"stream\": chunks.decode()}))\n-        await response(scope, receive, send)\n-\n-    client = TestClient(app)\n+        return encode_json({\"body\": body.decode(), \"stream\": chunks.decode()})\n \n-    response = client.post(\"/\", content=\"abc\")\n-    assert response.json() == {\"body\": \"abc\", \"stream\": \"abc\"}\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\", content=\"abc\")\n+        assert response.json() == {\"body\": \"abc\", \"stream\": \"abc\"}\n \n \n def test_request_stream_then_body() -> None:\n@@ -329,19 +323,27 @@ async def app(scope: Scope, receive: Receive, send: Send) -> None:\n         response = ASGIResponse(body=encode_json({\"body\": body.decode(), \"stream\": chunks.decode()}))\n         await response(scope, receive, send)\n \n-    client = TestClient(app)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n+        chunks = b\"\"\n+        async for chunk in request.stream():\n+            chunks += chunk\n+        try:\n+            body = await request.body()\n+        except InternalServerException:\n+            body = b\"<stream consumed>\"\n+        return encode_json({\"body\": body.decode(), \"stream\": chunks.decode()})\n \n-    response = client.post(\"/\", content=\"abc\")\n-    assert response.json() == {\"body\": \"<stream consumed>\", \"stream\": \"abc\"}\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\", content=\"abc\")\n+        assert response.json() == {\"body\": \"<stream consumed>\", \"stream\": \"abc\"}\n \n \n def test_request_json() -> None:\n-    @asgi(\"/\")\n-    async def handler(scope: Scope, receive: Receive, send: Send) -> None:\n-        request = Request[Any, Any, State](scope, receive)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n         data = await request.json()\n-        response = ASGIResponse(body=encode_json({\"json\": data}))\n-        await response(scope, receive, send)\n+        return encode_json({\"json\": data})\n \n     with create_test_client(handler) as client:\n         response = client.post(\"/\", json={\"a\": \"123\"})\n@@ -361,10 +363,11 @@ async def app(scope: Scope, receive: Receive, send: Send) -> None:\n     assert response.text == \"/he/llo, b'/he%2Fllo'\"\n \n \n-def test_request_without_setting_receive() -> None:\n+def test_request_without_setting_receive(create_scope: Callable[..., Scope]) -> None:\n     \"\"\"If Request is instantiated without the 'receive' channel, then .body() is not available.\"\"\"\n \n     async def app(scope: Scope, receive: Receive, send: Send) -> None:\n+        scope.update(create_scope(route_handler=_route_handler))  # type: ignore[typeddict-item]\n         request = Request[Any, Any, State](scope)\n         try:\n             data = await request.json()\n@@ -431,20 +434,19 @@ async def app(scope: Scope, receive: Receive, send: Send) -> None:\n \n \n def test_chunked_encoding() -> None:\n-    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n-        request = Request[Any, Any, State](scope, receive)\n+    @post(\"/\")\n+    async def handler(request: Request) -> bytes:\n         body = await request.body()\n-        response = ASGIResponse(body=encode_json({\"body\": body.decode()}))\n-        await response(scope, receive, send)\n+        return encode_json({\"body\": body.decode()})\n \n-    client = TestClient(app)\n+    with create_test_client([handler]) as client:\n \n-    def post_body() -> Generator[bytes, None, None]:\n-        yield b\"foo\"\n-        yield b\"bar\"\n+        def post_body() -> Generator[bytes, None, None]:\n+            yield b\"foo\"\n+            yield b\"bar\"\n \n-    response = client.post(\"/\", content=post_body())\n-    assert response.json() == {\"body\": \"foobar\"}\n+        response = client.post(\"/\", content=post_body())\n+        assert response.json() == {\"body\": \"foobar\"}\n \n \n def test_request_send_push_promise() -> None:\n@@ -548,3 +550,74 @@ async def get_state(request: Request[Any, Any, State]) -> dict[str, str]:\n     ) as client:\n         response = client.get(\"/\")\n         assert response.json() == {\"state\": 2}\n+\n+\n+def test_request_body_exceeds_content_length() -> None:\n+    @post(\"/\")\n+    def handler(body: bytes) -> None:\n+        pass\n+\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\", headers={\"content-length\": \"1\"}, content=b\"ab\")\n+        assert response.status_code == HTTP_400_BAD_REQUEST\n+        assert response.json() == {\"status_code\": 400, \"detail\": \"Malformed request\"}\n+\n+\n+def test_request_body_exceeds_max_request_body_size() -> None:\n+    @post(\"/one\", request_max_body_size=1)\n+    async def handler_one(request: Request) -> None:\n+        await request.body()\n+\n+    @post(\"/two\", request_max_body_size=1)\n+    async def handler_two(body: bytes) -> None:\n+        pass\n+\n+    with create_test_client([handler_one, handler_two]) as client:\n+        response = client.post(\"/one\", headers={\"content-length\": \"2\"}, content=b\"ab\")\n+        assert response.status_code == HTTP_413_REQUEST_ENTITY_TOO_LARGE\n+\n+        response = client.post(\"/two\", headers={\"content-length\": \"2\"}, content=b\"ab\")\n+        assert response.status_code == HTTP_413_REQUEST_ENTITY_TOO_LARGE\n+\n+\n+def test_request_body_exceeds_max_request_body_size_chunked() -> None:\n+    @post(\"/one\", request_max_body_size=1)\n+    async def handler_one(request: Request) -> None:\n+        assert request.headers[\"transfer-encoding\"] == \"chunked\"\n+        await request.body()\n+\n+    @post(\"/two\", request_max_body_size=1)\n+    async def handler_two(body: bytes, request: Request) -> None:\n+        assert request.headers[\"transfer-encoding\"] == \"chunked\"\n+        await request.body()\n+\n+    def generator() -> Generator[bytes, None, None]:\n+        yield b\"1\"\n+        yield b\"2\"\n+\n+    with create_test_client([handler_one, handler_two]) as client:\n+        response = client.post(\"/one\", content=generator())\n+        assert response.status_code == HTTP_413_REQUEST_ENTITY_TOO_LARGE\n+\n+        response = client.post(\"/two\", content=generator())\n+        assert response.status_code == HTTP_413_REQUEST_ENTITY_TOO_LARGE\n+\n+\n+def test_request_content_length() -> None:\n+    @post(\"/\")\n+    def handler(request: Request) -> dict:\n+        return {\"content-length\": request.content_length}\n+\n+    with create_test_client([handler]) as client:\n+        assert client.post(\"/\", content=b\"1\").json() == {\"content-length\": 1}\n+\n+\n+def test_request_invalid_content_length() -> None:\n+    @post(\"/\")\n+    def handler(request: Request) -> dict:\n+        return {\"content-length\": request.content_length}\n+\n+    with create_test_client([handler]) as client:\n+        response = client.post(\"/\", content=b\"1\", headers={\"content-length\": \"a\"})\n+        assert response.status_code == HTTP_400_BAD_REQUEST\n+        assert response.json() == {\"detail\": \"Invalid content-length: 'a'\", \"status_code\": 400}"
        },
        {
          "filename": "tests/unit/test_handlers/test_http_handlers/test_resolution.py",
          "status": "added",
          "additions": 66,
          "deletions": 0,
          "patch": "@@ -0,0 +1,66 @@\n+import pytest\n+\n+from litestar import Controller, Litestar, Router, post\n+from litestar.exceptions import ImproperlyConfiguredException\n+from litestar.types import Empty\n+\n+\n+def test_resolve_request_max_body_size() -> None:\n+    @post(\"/1\")\n+    def router_handler() -> None:\n+        pass\n+\n+    @post(\"/2\")\n+    def app_handler() -> None:\n+        pass\n+\n+    class MyController(Controller):\n+        request_max_body_size = 2\n+\n+        @post(\"/3\")\n+        def controller_handler(self) -> None:\n+            pass\n+\n+    router = Router(\"/\", route_handlers=[router_handler], request_max_body_size=1)\n+    app = Litestar(route_handlers=[app_handler, router, MyController], request_max_body_size=3)\n+    assert router_handler.resolve_request_max_body_size() == 1\n+    assert app_handler.resolve_request_max_body_size() == 3\n+    assert (\n+        next(r for r in app.routes if r.path == \"/3\").route_handler_map[\"POST\"][0].resolve_request_max_body_size() == 2  # type: ignore[union-attr]\n+    )\n+\n+\n+def test_resolve_request_max_body_size_none() -> None:\n+    @post(\"/1\", request_max_body_size=None)\n+    def router_handler() -> None:\n+        pass\n+\n+    Litestar([router_handler])\n+    assert router_handler.resolve_request_max_body_size() is None\n+\n+\n+def test_resolve_request_max_body_size_app_default() -> None:\n+    @post(\"/\")\n+    def router_handler() -> None:\n+        pass\n+\n+    app = Litestar(route_handlers=[router_handler])\n+\n+    assert router_handler.resolve_request_max_body_size() == app.request_max_body_size == 10_000_000\n+\n+\n+def test_resolve_request_max_body_size_empty_on_all_layers_raises() -> None:\n+    @post(\"/\")\n+    def handler_one() -> None:\n+        pass\n+\n+    Litestar([handler_one], request_max_body_size=Empty)  # type: ignore[arg-type]\n+    with pytest.raises(ImproperlyConfiguredException):\n+        handler_one.resolve_request_max_body_size()\n+\n+    @post(\"/\")\n+    def handler_two() -> None:\n+        pass\n+\n+    with pytest.raises(ImproperlyConfiguredException):\n+        handler_two.resolve_request_max_body_size()"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 12,
        "unique_directories": 9,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "b140afb8ef8f60cab8a89c5d2afeb67cb3fbeb0b",
            "date": "2025-01-13T07:16:12Z",
            "author_login": "euri10"
          },
          {
            "sha": "2db1f4d2131d9902af15e00312e1673d0b3d0a61",
            "date": "2025-01-11T19:24:15Z",
            "author_login": "provinzkraut"
          },
          {
            "sha": "a814224eaeebae7511ec4ae5ad90559c6e26c6e1",
            "date": "2025-01-10T03:58:19Z",
            "author_login": "JacobCoffee"
          },
          {
            "sha": "79827933ac01fe0d8a0ad44498b173ae14023b0d",
            "date": "2025-01-10T02:56:10Z",
            "author_login": "cofin"
          },
          {
            "sha": "b09a549c4f0564cb19ff97cc2410b11afea297da",
            "date": "2025-01-10T02:47:15Z",
            "author_login": "cofin"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-770",
    "description": "Litestar is an Asynchronous Server Gateway Interface (ASGI) framework. Prior to version 2.13.0, the multipart form parser shipped with litestar expects the entire request body as a single byte string and there is no default limit for the total size of the request body. This allows an attacker to upload arbitrary large files wrapped in a `multipart/form-data` request and cause excessive memory consumption on the server. The multipart form parser in affected versions is vulnerable to this type of attack by design. The public method signature as well as its implementation both expect the entire request body to be available as a single byte string. It is not possible to accept large file uploads in a safe way using this parser. This may be a regression, as a variation of this issue was already reported in CVE-2023-25578. Limiting the part number is not sufficient to prevent out-of-memory errors on the server. A patch is available in version 2.13.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-11-20T21:15:08.320",
    "last_modified": "2024-11-25T14:15:07.077",
    "fix_date": "2024-11-20T15:09:41Z"
  },
  "references": [
    {
      "url": "https://github.com/litestar-org/litestar/blob/main/litestar/_multipart.py#L97",
      "source": "security-advisories@github.com",
      "tags": [
        "Product"
      ]
    },
    {
      "url": "https://github.com/litestar-org/litestar/commit/53c1473b5ff7502816a9a339ffc90731bb0c2138",
      "source": "security-advisories@github.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/litestar-org/litestar/security/advisories/GHSA-gjcc-jvgw-wvwj",
      "source": "security-advisories@github.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://github.com/litestar-org/litestar/security/advisories/GHSA-p24m-863f-fm6q",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.274278",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "litestar",
    "owner": "litestar-org",
    "created_at": "2021-12-06T19:43:06Z",
    "updated_at": "2025-01-14T16:47:30Z",
    "pushed_at": "2025-01-13T18:57:11Z",
    "size": 127636,
    "stars": 5810,
    "forks": 390,
    "open_issues": 195,
    "watchers": 5810,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main",
      "release-1.51",
      "release-2.9.1",
      "release-2.10.0",
      "release-2.11.0",
      "v3.0"
    ],
    "languages": {
      "Python": 3474135,
      "Makefile": 5351,
      "HTML": 1855,
      "CSS": 1830,
      "JavaScript": 920,
      "Lua": 848,
      "Dockerfile": 689
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:06:23.650164"
  }
}