{
  "cve_id": "CVE-2024-52809",
  "github_data": {
    "repository": "intlify/vue-i18n",
    "fix_commit": "72f0d323006fc7363b18cab62d4522dadd874411",
    "related_commits": [
      "72f0d323006fc7363b18cab62d4522dadd874411",
      "9f20909ef8c9232a1072d7818e12ed6d6451024d"
    ],
    "patch_url": "https://github.com/intlify/vue-i18n/commit/72f0d323006fc7363b18cab62d4522dadd874411.patch",
    "fix_commit_details": {
      "sha": "72f0d323006fc7363b18cab62d4522dadd874411",
      "commit_date": "2024-11-28T04:17:29Z",
      "author": {
        "login": "kazupon",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge commit from fork",
        "length": 179,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 883,
        "additions": 839,
        "deletions": 44
      },
      "files": [
        {
          "filename": "e2e/hotfix.spec.ts",
          "status": "added",
          "additions": 11,
          "deletions": 0,
          "patch": "@@ -0,0 +1,11 @@\n+import { getText } from './helper'\n+\n+describe('CVE-2024-52809', () => {\n+  beforeAll(async () => {\n+    await page.goto(`http://localhost:8080/e2e/hotfix/CVE-2024-52809.html`)\n+  })\n+\n+  test('fix', async () => {\n+    expect(await getText(page, 'p')).toMatch('hello world!')\n+  })\n+})"
        },
        {
          "filename": "e2e/hotfix/CVE-2024-52809.html",
          "status": "added",
          "additions": 69,
          "deletions": 0,
          "patch": "@@ -0,0 +1,69 @@\n+<!doctype html>\n+<html>\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <title>vue-i18n XSS</title>\n+    <script src=\"../../node_modules/vue/dist/vue.global.js\"></script>\n+    <script src=\"../../packages/vue-i18n/dist/vue-i18n.global.js\"></script>\n+    <!-- Scripts that perform prototype contamination, such as being distributed from malicious hosting sites or injected through supply chain attacks, etc. -->\n+    <script>\n+      /**\n+       * Prototype pollution vulnerability with `Object.prototype`.\n+       * The 'static' property is part of the optimized AST generated by the vue-i18n message compiler.\n+       * About details of special properties, see https://github.com/intlify/vue-i18n/blob/master/packages/message-compiler/src/nodes.ts\n+       *\n+       * In general, the locale messages of vue-i18n are optimized during production builds using `@intlify/unplugin-vue-i18n`,\n+       * so there is always a property that is attached during optimization like this time.\n+       * But if you are using a locale message AST in development or your own, there is a possibility of XSS if a third party injects prototype pollution code.\n+       */\n+      Object.defineProperty(Object.prototype, 'static', {\n+        configurable: true,\n+        get() {\n+          alert('prototype polluted!')\n+          return 'prototype pollution'\n+        }\n+      })\n+    </script>\n+  </head>\n+  <body>\n+    <div id=\"app\">\n+      <p>{{ t('hello') }}</p>\n+    </div>\n+    <script>\n+      const { createApp } = Vue\n+      const { createI18n, useI18n } = VueI18n\n+\n+      // AST style locale message, which build by `@intlify/unplugin-vue-i18n`\n+      const en = {\n+        hello: {\n+          type: 0,\n+          body: {\n+            items: [\n+              {\n+                type: 3,\n+                value: 'hello world!'\n+              }\n+            ]\n+          }\n+        }\n+      }\n+\n+      const i18n = createI18n({\n+        legacy: false,\n+        locale: 'en',\n+        messages: {\n+          en\n+        }\n+      })\n+\n+      const app = createApp({\n+        setup() {\n+          const { t } = useI18n()\n+          return { t }\n+        }\n+      })\n+      app.use(i18n)\n+      app.mount('#app')\n+    </script>\n+  </body>\n+</html>"
        },
        {
          "filename": "packages/core-base/src/compilation.ts",
          "status": "modified",
          "additions": 17,
          "deletions": 6,
          "patch": "@@ -3,13 +3,21 @@ import {\n   defaultOnError,\n   detectHtmlTag\n } from '@intlify/message-compiler'\n-import { format, isBoolean, isObject, isString, warn } from '@intlify/shared'\n-import { format as formatMessage } from './format'\n+import {\n+  format,\n+  hasOwn,\n+  isBoolean,\n+  isObject,\n+  isString,\n+  warn\n+} from '@intlify/shared'\n+import { format as formatMessage, resolveType } from './format'\n \n import type {\n   CompileError,\n   CompileOptions,\n   CompilerResult,\n+  Node,\n   ResourceNode\n } from '@intlify/message-compiler'\n import type { MessageCompilerContext } from './context'\n@@ -30,10 +38,13 @@ export function clearCompileCache(): void {\n   compileCache = Object.create(null)\n }\n \n-export const isMessageAST = (val: unknown): val is ResourceNode =>\n-  isObject(val) &&\n-  (val.t === 0 || val.type === 0) &&\n-  ('b' in val || 'body' in val)\n+export function isMessageAST(val: unknown): val is ResourceNode {\n+  return (\n+    isObject(val) &&\n+    resolveType(val as Node) === 0 &&\n+    (hasOwn(val, 'b') || hasOwn(val, 'body'))\n+  )\n+}\n \n function baseCompile(\n   message: string,"
        },
        {
          "filename": "packages/core-base/src/errors.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,6 +1,6 @@\n import {\n-  createCompileError,\n-  COMPILE_ERROR_CODES_EXTEND_POINT\n+  COMPILE_ERROR_CODES_EXTEND_POINT,\n+  createCompileError\n } from '@intlify/message-compiler'\n \n import type { BaseError } from '@intlify/shared'"
        },
        {
          "filename": "packages/core-base/src/format.ts",
          "status": "modified",
          "additions": 141,
          "deletions": 33,
          "patch": "@@ -1,23 +1,21 @@\n import { NodeTypes } from '@intlify/message-compiler'\n+import { hasOwn, isNumber } from '@intlify/shared'\n \n import type {\n-  Node,\n-  TextNode,\n-  LiteralNode,\n+  LinkedModifierNode,\n+  LinkedNode,\n   ListNode,\n   MessageNode,\n   NamedNode,\n-  LinkedNode,\n-  LinkedKeyNode,\n-  LinkedModifierNode,\n+  Node,\n   PluralNode,\n   ResourceNode\n } from '@intlify/message-compiler'\n import type {\n   MessageContext,\n   MessageFunction,\n-  MessageType,\n-  MessageFunctionReturn\n+  MessageFunctionReturn,\n+  MessageType\n } from './runtime'\n \n export function format<Message = string>(\n@@ -28,14 +26,18 @@ export function format<Message = string>(\n   return msg\n }\n \n-function formatParts<Message = string>(\n+export function formatParts<Message = string>(\n   ctx: MessageContext<Message>,\n   ast: ResourceNode\n ): MessageFunctionReturn<Message> {\n-  const body = ast.b || ast.body\n-  if ((body.t || body.type) === NodeTypes.Plural) {\n+  const body = resolveBody(ast)\n+  if (body == null) {\n+    throw createUnhandleNodeError(NodeTypes.Resource)\n+  }\n+  const type = resolveType(body)\n+  if (type === NodeTypes.Plural) {\n     const plural = body as PluralNode\n-    const cases = plural.c || plural.cases\n+    const cases = resolveCases(plural)\n     return ctx.plural(\n       cases.reduce(\n         (messages, c) =>\n@@ -51,64 +53,170 @@ function formatParts<Message = string>(\n   }\n }\n \n-function formatMessageParts<Message = string>(\n+const PROPS_BODY = ['b', 'body']\n+\n+function resolveBody(node: ResourceNode) {\n+  return resolveProps<MessageNode | PluralNode>(node, PROPS_BODY)\n+}\n+\n+const PROPS_CASES = ['c', 'cases']\n+\n+function resolveCases(node: PluralNode) {\n+  return resolveProps<PluralNode['cases'], PluralNode['cases']>(\n+    node,\n+    PROPS_CASES,\n+    []\n+  )\n+}\n+\n+export function formatMessageParts<Message = string>(\n   ctx: MessageContext<Message>,\n   node: MessageNode\n ): MessageFunctionReturn<Message> {\n-  const _static = node.s || node.static\n-  if (_static != null) {\n+  const static_ = resolveStatic(node)\n+  if (static_ != null) {\n     return ctx.type === 'text'\n-      ? (_static as MessageFunctionReturn<Message>)\n-      : ctx.normalize([_static] as MessageType<Message>[])\n+      ? (static_ as MessageFunctionReturn<Message>)\n+      : ctx.normalize([static_] as MessageType<Message>[])\n   } else {\n-    const messages = (node.i || node.items).reduce(\n+    const messages = resolveItems(node).reduce(\n       (acm, c) => [...acm, formatMessagePart(ctx, c)],\n       [] as MessageType<Message>[]\n     )\n     return ctx.normalize(messages) as MessageFunctionReturn<Message>\n   }\n }\n \n-function formatMessagePart<Message = string>(\n+const PROPS_STATIC = ['s', 'static']\n+\n+function resolveStatic(node: MessageNode) {\n+  return resolveProps(node, PROPS_STATIC)\n+}\n+\n+const PROPS_ITEMS = ['i', 'items']\n+\n+function resolveItems(node: MessageNode) {\n+  return resolveProps<MessageNode['items'], MessageNode['items']>(\n+    node,\n+    PROPS_ITEMS,\n+    []\n+  )\n+}\n+\n+type NodeValue<Message> = {\n+  v?: MessageType<Message>\n+  value?: MessageType<Message>\n+}\n+\n+export function formatMessagePart<Message = string>(\n   ctx: MessageContext<Message>,\n   node: Node\n ): MessageType<Message> {\n-  const type = node.t || node.type\n+  const type = resolveType(node)\n   switch (type) {\n     case NodeTypes.Text: {\n-      const text = node as TextNode\n-      return (text.v || text.value) as MessageType<Message>\n+      return resolveValue<Message>(node as NodeValue<Message>, type)\n     }\n     case NodeTypes.Literal: {\n-      const literal = node as LiteralNode\n-      return (literal.v || literal.value) as MessageType<Message>\n+      return resolveValue<Message>(node as NodeValue<Message>, type)\n     }\n     case NodeTypes.Named: {\n       const named = node as NamedNode\n-      return ctx.interpolate(ctx.named(named.k || named.key))\n+      if (hasOwn(named, 'k') && named.k) {\n+        return ctx.interpolate(ctx.named(named.k))\n+      }\n+      if (hasOwn(named, 'key') && named.key) {\n+        return ctx.interpolate(ctx.named(named.key))\n+      }\n+      throw createUnhandleNodeError(type)\n     }\n     case NodeTypes.List: {\n       const list = node as ListNode\n-      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index))\n+      if (hasOwn(list, 'i') && isNumber(list.i)) {\n+        return ctx.interpolate(ctx.list(list.i))\n+      }\n+      if (hasOwn(list, 'index') && isNumber(list.index)) {\n+        return ctx.interpolate(ctx.list(list.index))\n+      }\n+      throw createUnhandleNodeError(type)\n     }\n     case NodeTypes.Linked: {\n       const linked = node as LinkedNode\n-      const modifier = linked.m || linked.modifier\n+      const modifier = resolveLinkedModifier(linked)\n+      const key = resolveLinkedKey(linked)\n       return ctx.linked(\n-        formatMessagePart(ctx, linked.k || linked.key) as string,\n+        formatMessagePart(ctx, key!) as string,\n         modifier ? (formatMessagePart(ctx, modifier) as string) : undefined,\n         ctx.type\n       )\n     }\n     case NodeTypes.LinkedKey: {\n-      const linkedKey = node as LinkedKeyNode\n-      return (linkedKey.v || linkedKey.value) as MessageType<Message>\n+      return resolveValue<Message>(node as NodeValue<Message>, type)\n     }\n     case NodeTypes.LinkedModifier: {\n-      const linkedModifier = node as LinkedModifierNode\n-      return (linkedModifier.v || linkedModifier.value) as MessageType<Message>\n+      return resolveValue<Message>(node as NodeValue<Message>, type)\n     }\n     default:\n-      throw new Error(`unhandled node type on format message part: ${type}`)\n+      throw new Error(`unhandled node on format message part: ${type}`)\n+  }\n+}\n+\n+const PROPS_TYPE = ['t', 'type']\n+\n+export function resolveType(node: Node) {\n+  return resolveProps<NodeTypes>(node, PROPS_TYPE)\n+}\n+\n+const PROPS_VALUE = ['v', 'value']\n+\n+function resolveValue<Message = string>(\n+  node: { v?: MessageType<Message>; value?: MessageType<Message> },\n+  type: NodeTypes\n+): MessageType<Message> {\n+  const resolved = resolveProps<Message>(\n+    node as Node,\n+    PROPS_VALUE\n+  ) as MessageType<Message>\n+  if (resolved) {\n+    return resolved\n+  } else {\n+    throw createUnhandleNodeError(type)\n+  }\n+}\n+\n+const PROPS_MODIFIER = ['m', 'modifier']\n+\n+function resolveLinkedModifier(node: LinkedNode) {\n+  return resolveProps<LinkedModifierNode>(node, PROPS_MODIFIER)\n+}\n+\n+const PROPS_KEY = ['k', 'key']\n+\n+function resolveLinkedKey(node: LinkedNode) {\n+  const resolved = resolveProps<LinkedNode['key']>(node, PROPS_KEY)\n+  if (resolved) {\n+    return resolved\n+  } else {\n+    throw createUnhandleNodeError(NodeTypes.Linked)\n   }\n }\n+\n+function resolveProps<T = string, Default = undefined>(\n+  node: Node,\n+  props: string[],\n+  defaultValue?: Default\n+): T | Default {\n+  for (let i = 0; i < props.length; i++) {\n+    const prop = props[i]\n+    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+    if (hasOwn(node, prop) && (node as any)[prop] != null) {\n+      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+      return (node as any)[prop] as T\n+    }\n+  }\n+  return defaultValue as Default\n+}\n+\n+function createUnhandleNodeError(type: NodeTypes) {\n+  return new Error(`unhandled node type: ${type}`)\n+}"
        },
        {
          "filename": "packages/core-base/test/format.test.ts",
          "status": "modified",
          "additions": 472,
          "deletions": 2,
          "patch": "@@ -1,7 +1,24 @@\n-import { baseCompile as compile } from '@intlify/message-compiler'\n-import { format } from '../src/format'\n+import { baseCompile as compile, NodeTypes } from '@intlify/message-compiler'\n+import {\n+  format,\n+  formatMessagePart,\n+  formatMessageParts,\n+  formatParts\n+} from '../src/format'\n import { createMessageContext as context } from '../src/runtime'\n \n+import type {\n+  LinkedKeyNode,\n+  LinkedModifierNode,\n+  LinkedNode,\n+  ListNode,\n+  LiteralNode,\n+  MessageNode,\n+  NamedNode,\n+  ResourceNode,\n+  TextNode\n+} from '@intlify/message-compiler'\n+\n describe('features', () => {\n   test('text: hello world', () => {\n     const { ast } = compile('hello world', { jit: true })\n@@ -143,3 +160,456 @@ describe('edge cases', () => {\n     expect(msg(ctx)).toBe('')\n   })\n })\n+\n+describe('formatParts', () => {\n+  test('prop: body', () => {\n+    const node: ResourceNode = {\n+      type: NodeTypes.Resource,\n+      body: {\n+        type: NodeTypes.Message,\n+        items: [\n+          {\n+            type: NodeTypes.Text,\n+            value: 'hello world'\n+          }\n+        ]\n+      }\n+    }\n+\n+    const ctx = context()\n+    expect(formatParts(ctx, node)).toBe('hello world')\n+  })\n+\n+  test('prop: b', () => {\n+    const node: ResourceNode = {\n+      type: NodeTypes.Resource,\n+      body: {\n+        type: NodeTypes.Message,\n+        items: [\n+          {\n+            type: NodeTypes.Text,\n+            value: 'hello world'\n+          }\n+        ]\n+      }\n+    }\n+\n+    const ctx = context()\n+    expect(formatParts(ctx, node)).toBe('hello world')\n+  })\n+\n+  test(`body has plural prop cases`, () => {\n+    const node: ResourceNode = {\n+      type: NodeTypes.Resource,\n+      body: {\n+        type: NodeTypes.Plural,\n+        cases: [\n+          {\n+            type: NodeTypes.Message,\n+            items: [\n+              {\n+                type: NodeTypes.Text,\n+                value: 'hello'\n+              }\n+            ]\n+          },\n+          {\n+            type: NodeTypes.Message,\n+            items: [\n+              {\n+                type: NodeTypes.Text,\n+                value: 'world'\n+              }\n+            ]\n+          }\n+        ]\n+      }\n+    }\n+\n+    const ctx = context({\n+      pluralIndex: 2\n+    })\n+    expect(formatParts(ctx, node)).toBe('world')\n+  })\n+\n+  test(`body has plural prop c`, () => {\n+    const node: ResourceNode = {\n+      type: NodeTypes.Resource,\n+      // @ts-ignore\n+      body: {\n+        type: NodeTypes.Plural,\n+        c: [\n+          {\n+            type: NodeTypes.Message,\n+            items: [\n+              {\n+                type: NodeTypes.Text,\n+                value: 'hello'\n+              }\n+            ]\n+          },\n+          {\n+            type: NodeTypes.Message,\n+            items: [\n+              {\n+                type: NodeTypes.Text,\n+                value: 'world'\n+              }\n+            ]\n+          }\n+        ]\n+      }\n+    }\n+\n+    const ctx = context({\n+      pluralIndex: 1\n+    })\n+    expect(formatParts(ctx, node)).toBe('hello')\n+  })\n+\n+  test('not found prop body', () => {\n+    // @ts-ignore\n+    const node: ResourceNode = {\n+      type: NodeTypes.Resource\n+    }\n+\n+    const ctx = context()\n+    expect(() => formatParts(ctx, node)).toThrow(\n+      `unhandled node type: ${NodeTypes.Resource}`\n+    )\n+  })\n+})\n+\n+describe('formatMessageParts', () => {\n+  test('prop: static', () => {\n+    const node: MessageNode = {\n+      type: NodeTypes.Message,\n+      static: 'hello world',\n+      items: []\n+    }\n+    const ctx = context()\n+    expect(formatMessageParts(ctx, node)).toBe('hello world')\n+  })\n+\n+  test('prop: s', () => {\n+    const node: MessageNode = {\n+      type: NodeTypes.Message,\n+      s: 'hello world',\n+      items: []\n+    }\n+    const ctx = context()\n+    expect(formatMessageParts(ctx, node)).toBe('hello world')\n+  })\n+\n+  test('prop: items', () => {\n+    const node: MessageNode = {\n+      type: NodeTypes.Message,\n+      items: [\n+        {\n+          type: NodeTypes.Text,\n+          value: 'hello'\n+        },\n+        {\n+          type: NodeTypes.Text,\n+          value: 'world'\n+        }\n+      ]\n+    }\n+    const ctx = context()\n+    expect(formatMessageParts(ctx, node)).toEqual('helloworld')\n+  })\n+\n+  test('prop: i', () => {\n+    // @ts-ignore\n+    const node: MessageNode = {\n+      type: NodeTypes.Message,\n+      i: [\n+        {\n+          type: NodeTypes.Text,\n+          value: 'hello'\n+        },\n+        {\n+          type: NodeTypes.Text,\n+          value: 'world'\n+        }\n+      ]\n+    }\n+    const ctx = context()\n+    expect(formatMessageParts(ctx, node)).toEqual('helloworld')\n+  })\n+})\n+\n+describe('formatMessagePart', () => {\n+  describe('text node', () => {\n+    test('prop: value', () => {\n+      const node: TextNode = {\n+        type: NodeTypes.Text,\n+        value: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test('prop: v', () => {\n+      const node: TextNode = {\n+        type: NodeTypes.Text,\n+        v: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test(`prop 'value' and 'v' not found`, () => {\n+      const node: TextNode = {\n+        type: NodeTypes.Text\n+      }\n+      const ctx = context()\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.Text}`\n+      )\n+    })\n+  })\n+\n+  describe('literal node', () => {\n+    test('prop: value', () => {\n+      const node: LiteralNode = {\n+        type: NodeTypes.Literal,\n+        value: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test('prop: v', () => {\n+      const node: LiteralNode = {\n+        type: NodeTypes.Literal,\n+        v: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test(`prop 'value' and 'v' not found`, () => {\n+      const node: LiteralNode = {\n+        type: NodeTypes.Literal\n+      }\n+      const ctx = context()\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.Literal}`\n+      )\n+    })\n+  })\n+\n+  describe('named node', () => {\n+    test('prop: key', () => {\n+      const node: NamedNode = {\n+        type: NodeTypes.Named,\n+        key: 'key'\n+      }\n+      const ctx = context({\n+        named: { key: 'hello world' }\n+      })\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test('prop: k', () => {\n+      // @ts-ignore\n+      const node: NamedNode = {\n+        type: NodeTypes.Named,\n+        k: 'key'\n+      }\n+      const ctx = context({\n+        named: { key: 'hello world' }\n+      })\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test(`prop 'key' and 'k' not found`, () => {\n+      // @ts-ignore\n+      const node: NamedNode = {\n+        type: NodeTypes.Named\n+      }\n+      const ctx = context()\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.Named}`\n+      )\n+    })\n+  })\n+\n+  describe('list node', () => {\n+    test('prop: index', () => {\n+      const node: ListNode = {\n+        type: NodeTypes.List,\n+        index: 0\n+      }\n+      const ctx = context({\n+        list: ['hello world']\n+      })\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test('prop: i', () => {\n+      // @ts-ignore\n+      const node: ListNode = {\n+        type: NodeTypes.List,\n+        i: 0\n+      }\n+      const ctx = context({\n+        list: ['hello world']\n+      })\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test(`prop 'index' and 'i' not found`, () => {\n+      // @ts-ignore\n+      const node: ListNode = {\n+        type: NodeTypes.List\n+      }\n+      const ctx = context()\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.List}`\n+      )\n+    })\n+  })\n+\n+  describe('linked key node', () => {\n+    test('prop: value', () => {\n+      const node: LinkedKeyNode = {\n+        type: NodeTypes.LinkedKey,\n+        value: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test('prop: v', () => {\n+      // @ts-ignore\n+      const node: LinkedKeyNode = {\n+        type: NodeTypes.LinkedKey,\n+        v: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test(`prop 'value' and 'v' not found`, () => {\n+      // @ts-ignore\n+      const node: LinkedKeyNode = {\n+        type: NodeTypes.LinkedKey\n+      }\n+      const ctx = context()\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.LinkedKey}`\n+      )\n+    })\n+  })\n+\n+  describe('linked modifier node', () => {\n+    test('prop: value', () => {\n+      const node: LinkedModifierNode = {\n+        type: NodeTypes.LinkedModifier,\n+        value: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test('prop: v', () => {\n+      // @ts-ignore\n+      const node: LinkedModifierNode = {\n+        type: NodeTypes.LinkedModifier,\n+        v: 'hello world'\n+      }\n+      const ctx = context()\n+      expect(formatMessagePart(ctx, node)).toBe('hello world')\n+    })\n+\n+    test(`prop 'value' and 'v' not found`, () => {\n+      // @ts-ignore\n+      const node: LinkedModifierNode = {\n+        type: NodeTypes.LinkedModifier\n+      }\n+      const ctx = context()\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.LinkedModifier}`\n+      )\n+    })\n+  })\n+\n+  describe('linked node', () => {\n+    test('prop: modifier, key', () => {\n+      const node: LinkedNode = {\n+        type: NodeTypes.Linked,\n+        modifier: {\n+          type: NodeTypes.LinkedModifier,\n+          value: 'upper'\n+        },\n+        key: {\n+          type: NodeTypes.LinkedKey,\n+          value: 'name'\n+        }\n+      }\n+      const ctx = context({\n+        modifiers: {\n+          upper: (val: string) => val.toUpperCase()\n+        },\n+        messages: {\n+          name: () => 'kazupon'\n+        }\n+      })\n+      expect(formatMessagePart(ctx, node)).toBe('KAZUPON')\n+    })\n+\n+    test('prop: m, k', () => {\n+      // @ts-ignore\n+      const node: LinkedNode = {\n+        type: NodeTypes.Linked,\n+        m: {\n+          type: NodeTypes.LinkedModifier,\n+          value: 'upper'\n+        },\n+        k: {\n+          type: NodeTypes.LinkedKey,\n+          value: 'name'\n+        }\n+      }\n+      const ctx = context({\n+        modifiers: {\n+          upper: (val: string) => val.toUpperCase()\n+        },\n+        messages: {\n+          name: () => 'kazupon'\n+        }\n+      })\n+      expect(formatMessagePart(ctx, node)).toBe('KAZUPON')\n+    })\n+\n+    test(`prop 'key' not found`, () => {\n+      // @ts-ignore\n+      const node: LinkedNode = {\n+        type: NodeTypes.Linked\n+      }\n+      const ctx = context({\n+        modifiers: {\n+          upper: (val: string) => val.toUpperCase()\n+        },\n+        messages: {\n+          name: () => 'kazupon'\n+        }\n+      })\n+      expect(() => formatMessagePart(ctx, node)).toThrow(\n+        `unhandled node type: ${NodeTypes.Linked}`\n+      )\n+    })\n+  })\n+\n+  test('unhandled node', () => {\n+    const node = {\n+      type: -1\n+    }\n+    const ctx = context()\n+    expect(() => formatMessagePart(ctx, node)).toThrow(\n+      `unhandled node on format message part: -1`\n+    )\n+  })\n+})"
        },
        {
          "filename": "packages/core-base/test/issues.test.ts",
          "status": "added",
          "additions": 58,
          "deletions": 0,
          "patch": "@@ -0,0 +1,58 @@\n+import { format } from '../src/format'\n+import { createMessageContext as context } from '../src/runtime'\n+\n+import { NodeTypes, ResourceNode } from '@intlify/message-compiler'\n+\n+describe('CVE-2024-52809', () => {\n+  function attackGetter() {\n+    return 'polluted'\n+  }\n+\n+  afterEach(() => {\n+    // @ts-ignore -- initialize polluted property\n+    delete Object.prototype.static\n+  })\n+\n+  test('success', () => {\n+    Object.defineProperty(Object.prototype, 'static', {\n+      configurable: true,\n+      get: attackGetter\n+    })\n+    const ast: ResourceNode = {\n+      type: NodeTypes.Resource,\n+      body: {\n+        type: NodeTypes.Message,\n+        static: 'hello world',\n+        items: [\n+          {\n+            type: NodeTypes.Text\n+          }\n+        ]\n+      }\n+    }\n+    const msg = format(ast)\n+    const ctx = context()\n+    expect(msg(ctx)).toEqual('hello world')\n+  })\n+\n+  test('error', () => {\n+    Object.defineProperty(Object.prototype, 'static', {\n+      configurable: true,\n+      get: attackGetter\n+    })\n+    const ast: ResourceNode = {\n+      type: NodeTypes.Resource,\n+      body: {\n+        type: NodeTypes.Message,\n+        items: [\n+          {\n+            type: NodeTypes.Text\n+          }\n+        ]\n+      }\n+    }\n+    const msg = format(ast)\n+    const ctx = context()\n+    expect(() => msg(ctx)).toThrow(`unhandled node type: ${NodeTypes.Text}`)\n+  })\n+})"
        },
        {
          "filename": "packages/vue-i18n-core/test/issues.test.ts",
          "status": "modified",
          "additions": 69,
          "deletions": 1,
          "patch": "@@ -1406,7 +1406,7 @@ test('#1912', async () => {\n   expect(el?.innerHTML).include(`No apples found`)\n })\n \n-test('#1972', async () => {\n+test('#1972', () => {\n   const i18n = createI18n({\n     legacy: false,\n     locale: 'en',\n@@ -1418,3 +1418,71 @@ test('#1972', async () => {\n   })\n   expect(i18n.global.t('test', 0)).toEqual('')\n })\n+\n+describe('CVE-2024-52809', () => {\n+  function attackGetter() {\n+    return 'polluted'\n+  }\n+\n+  afterEach(() => {\n+    // @ts-ignore -- initialize polluted property\n+    delete Object.prototype.static\n+  })\n+\n+  test('success', () => {\n+    Object.defineProperty(Object.prototype, 'static', {\n+      configurable: true,\n+      get: attackGetter\n+    })\n+    const en = {\n+      hello: {\n+        type: 0,\n+        body: {\n+          type: 2,\n+          static: 'hello world',\n+          items: [\n+            {\n+              type: 3\n+            }\n+          ]\n+        }\n+      }\n+    }\n+    const i18n = createI18n({\n+      legacy: false,\n+      locale: 'en',\n+      messages: {\n+        en\n+      }\n+    })\n+    expect(i18n.global.t('hello')).toEqual('hello world')\n+  })\n+\n+  test('error', () => {\n+    Object.defineProperty(Object.prototype, 'static', {\n+      configurable: true,\n+      get: attackGetter\n+    })\n+    const en = {\n+      hello: {\n+        type: 0,\n+        body: {\n+          type: 2,\n+          items: [\n+            {\n+              type: 3\n+            }\n+          ]\n+        }\n+      }\n+    }\n+    const i18n = createI18n({\n+      legacy: false,\n+      locale: 'en',\n+      messages: {\n+        en\n+      }\n+    })\n+    expect(() => i18n.global.t('hello')).toThrow(`unhandled node type: 3`)\n+  })\n+})"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 3,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "ea48c465bcb7e43ac0aad097c87345d151c27d97",
            "date": "2025-01-07T15:18:51Z",
            "author_login": "kazupon"
          },
          {
            "sha": "255ae031490695b2325af916de773ed9c494fdf5",
            "date": "2025-01-07T15:08:35Z",
            "author_login": "kazupon"
          },
          {
            "sha": "453f50b2855b13b072f3bd31df17ce0d89e19a4e",
            "date": "2025-01-07T03:15:38Z",
            "author_login": "kazupon"
          },
          {
            "sha": "71b36cad4de462d3ca4d95f50b90ee9a09a12a41",
            "date": "2025-01-07T03:09:54Z",
            "author_login": "kazupon"
          },
          {
            "sha": "2d5a6ba2bfe1980552a368ceddadd4166b9432f1",
            "date": "2025-01-07T01:10:34Z",
            "author_login": "renovate[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-79",
    "description": "vue-i18n  is an internationalization plugin for Vue.js. In affected versions vue-i18n can be passed locale messages to `createI18n` or `useI18n`. When locale message ASTs are generated in development mode there is a possibility of Cross-site Scripting attack. This issue has been addressed in versions 9.14.2, and 10.0.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-11-29T19:15:09.030",
    "last_modified": "2024-11-29T19:15:09.030",
    "fix_date": "2024-11-28T04:17:29Z"
  },
  "references": [
    {
      "url": "https://github.com/intlify/vue-i18n/commit/72f0d323006fc7363b18cab62d4522dadd874411",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/intlify/vue-i18n/commit/9f20909ef8c9232a1072d7818e12ed6d6451024d",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/intlify/vue-i18n/security/advisories/GHSA-9r9m-ffp6-9x4v",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:31.317711",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "vue-i18n",
    "owner": "intlify",
    "created_at": "2020-01-05T17:38:06Z",
    "updated_at": "2025-01-10T07:51:31Z",
    "pushed_at": "2025-01-14T13:00:02Z",
    "size": 27606,
    "stars": 2265,
    "forks": 342,
    "open_issues": 142,
    "watchers": 2265,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "TypeScript": 1000975,
      "JavaScript": 59192,
      "Vue": 15341,
      "HTML": 3408,
      "Shell": 1228
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T15:32:07.407428"
  }
}