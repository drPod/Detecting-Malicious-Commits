{
  "cve_id": "CVE-2024-54152",
  "github_data": {
    "repository": "peerigon/angular-expressions",
    "fix_commit": "97f7ad94006156eeb97fc942332578b6cfbf8eef",
    "related_commits": [
      "97f7ad94006156eeb97fc942332578b6cfbf8eef"
    ],
    "patch_url": "https://github.com/peerigon/angular-expressions/commit/97f7ad94006156eeb97fc942332578b6cfbf8eef.patch",
    "fix_commit_details": {
      "sha": "97f7ad94006156eeb97fc942332578b6cfbf8eef",
      "commit_date": "2024-12-10T13:18:04Z",
      "author": {
        "login": "edi9999",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix CVE-2024-54152",
        "length": 18,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 141,
        "additions": 132,
        "deletions": 9
      },
      "files": [
        {
          "filename": "CHANGELOG.md",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -1,3 +1,15 @@\n+### 1.4.3\n+\n+Disallow access to prototype chain (CVE-2024-54152) when using compile with locals (two arguments in the called function) :\n+\n+```js\n+compile(\"__proto__\")({}, {});\n+```\n+\n+=> This now returns undefined, previously it would give you the `__proto__` instance which would allow Remote Code Execution.\n+\n+Thanks to [@JorianWoltjer](https://github.com/JorianWoltjer) who found the vulnerability and reported it.\n+\n ### 1.4.2\n \n Make `handleThis` the default if you use the `Lexer` and `Parser` directly, and you don't use `.compile`."
        },
        {
          "filename": "lib/parse.js",
          "status": "modified",
          "additions": 51,
          "deletions": 7,
          "patch": "@@ -42,6 +42,17 @@ if (\"I\".toLowerCase() !== \"i\") {\n \tlowercase = manualLowercase;\n }\n \n+// Run a function and disallow temporarly the use of the Function constructor\n+// This makes arbitrary code generation attacks way more complicated.\n+function runWithFunctionConstructorProtection(fn) {\n+\tvar originalFunctionConstructor = Function.prototype.constructor;\n+\tdelete Function.prototype.constructor;\n+\tvar result = fn();\n+\t// eslint-disable-next-line no-extend-native\n+\tFunction.prototype.constructor = originalFunctionConstructor;\n+\treturn result;\n+}\n+\n var jqLite, // delay binding since jQuery could be loaded after us.\n \ttoString = Object.prototype.toString,\n \tgetPrototypeOf = Object.getPrototypeOf,\n@@ -1690,15 +1701,28 @@ ASTCompiler.prototype = {\n \t\t\textra +\n \t\t\tthis.watchFns() +\n \t\t\t\"return fn;\";\n+\n \t\t// eslint-disable-next-line no-new-func\n-\t\tvar fn = new Function(\n+\t\tvar wrappedFn = new Function(\n \t\t\t\"$filter\",\n \t\t\t\"getStringValue\",\n \t\t\t\"ifDefined\",\n \t\t\t\"plus\",\n \t\t\tfnString\n \t\t)(this.$filter, getStringValue, ifDefined, plusFn);\n \n+\t\tvar fn = function (s, l, a, i) {\n+\t\t\treturn runWithFunctionConstructorProtection(function () {\n+\t\t\t\treturn wrappedFn(s, l, a, i);\n+\t\t\t});\n+\t\t};\n+\t\tfn.assign = function (s, v, l) {\n+\t\t\treturn runWithFunctionConstructorProtection(function () {\n+\t\t\t\treturn wrappedFn.assign(s, v, l);\n+\t\t\t});\n+\t\t};\n+\t\tfn.inputs = wrappedFn.inputs;\n+\n \t\tthis.state = this.stage = undefined;\n \t\tfn.ast = ast;\n \t\tfn.literal = isLiteral(ast);\n@@ -1892,7 +1916,12 @@ ASTCompiler.prototype = {\n \t\t\t\t\t\t);\n \t\t\t\t\t},\n \t\t\t\t\tintoId &&\n-\t\t\t\t\t\tself.lazyAssign(intoId, self.nonComputedMember(\"l\", ast.name))\n+\t\t\t\t\t\tfunction () {\n+\t\t\t\t\t\t\tself.if_(\n+\t\t\t\t\t\t\t\tself.hasOwnProperty_(\"l\", ast.name),\n+\t\t\t\t\t\t\t\tself.lazyAssign(intoId, self.nonComputedMember(\"l\", ast.name))\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t}\n \t\t\t\t);\n \t\t\t\trecursionFn(intoId);\n \t\t\t\tbreak;\n@@ -2166,7 +2195,7 @@ ASTCompiler.prototype = {\n \t},\n \n \tfilter: function (filterName) {\n-\t\tif (!this.state.filters.hasOwnProperty(filterName)) {\n+\t\tif (!hasOwnProperty.call(this.state.filters, filterName)) {\n \t\t\tthis.state.filters[filterName] = this.nextId(true);\n \t\t}\n \t\treturn this.state.filters[filterName];\n@@ -2258,7 +2287,7 @@ ASTCompiler.prototype = {\n \t\t\tleft +\n \t\t\t\"[\" +\n \t\t\tright +\n-\t\t\t\"] : null)\"\n+\t\t\t\"] : undefined)\"\n \t\t);\n \t},\n \n@@ -2375,7 +2404,7 @@ ASTInterpreter.prototype = {\n \t\tforEach(ast.body, function (expression) {\n \t\t\texpressions.push(self.recurse(expression.expression));\n \t\t});\n-\t\tvar fn =\n+\t\tvar wrappedFn =\n \t\t\tast.body.length === 0\n \t\t\t\t? noop\n \t\t\t\t: ast.body.length === 1\n@@ -2389,10 +2418,22 @@ ASTInterpreter.prototype = {\n \t\t\t\t\t\t};\n \n \t\tif (assign) {\n-\t\t\tfn.assign = function (scope, value, locals) {\n+\t\t\twrappedFn.assign = function (scope, value, locals) {\n \t\t\t\treturn assign(scope, locals, value);\n \t\t\t};\n \t\t}\n+\n+\t\tvar fn = function (scope, locals) {\n+\t\t\treturn runWithFunctionConstructorProtection(function () {\n+\t\t\t\treturn wrappedFn(scope, locals);\n+\t\t\t});\n+\t\t};\n+\t\tfn.assign = function (scope, value, locals) {\n+\t\t\treturn runWithFunctionConstructorProtection(function () {\n+\t\t\t\treturn wrappedFn.assign(scope, value, locals);\n+\t\t\t});\n+\t\t};\n+\n \t\tif (inputs) {\n \t\t\tfn.inputs = inputs;\n \t\t}\n@@ -2720,7 +2761,10 @@ ASTInterpreter.prototype = {\n \t\t\tif (create && create !== 1 && base && base[name] == null) {\n \t\t\t\tbase[name] = {};\n \t\t\t}\n-\t\t\tvar value = base ? base[name] : undefined;\n+\t\t\tvar value;\n+\t\t\tif (base && hasOwnProperty.call(base, name)) {\n+\t\t\t\tvalue = base ? base[name] : undefined;\n+\t\t\t}\n \t\t\tif (context) {\n \t\t\t\treturn { context: base, name: name, value: value };\n \t\t\t}"
        },
        {
          "filename": "test/main.test.js",
          "status": "modified",
          "additions": 69,
          "deletions": 2,
          "patch": "@@ -226,13 +226,40 @@ describe(\"expressions\", function () {\n \t\t\t\texpect(result).to.equal(undefined);\n \t\t\t});\n \n+\t\t\tit(\"should not leak indirectly with string concatenation with locals\", function () {\n+\t\t\t\tevaluate = compile(\n+\t\t\t\t\t\"a = null; a = ''['c'+'onstructor']['c'+'onstructor']; a = a('return process;'); a();\",\n+\t\t\t\t\t{ csp: true }\n+\t\t\t\t);\n+\t\t\t\tconst result = evaluate({}, {});\n+\t\t\t\texpect(result).to.equal(undefined);\n+\t\t\t});\n+\n \t\t\tit(\"should not leak indirectly with literal string\", function () {\n \t\t\t\tevaluate = compile(\n \t\t\t\t\t\"a = null; a = ''['constructor']['constructor']; a = a('return process;'); a();\"\n \t\t\t\t);\n \t\t\t\tconst result = evaluate({});\n \t\t\t\texpect(result).to.equal(undefined);\n \t\t\t});\n+\n+\t\t\tit(\"should not be able to rewrite hasOwnProperty\", function () {\n+\t\t\t\tconst scope = {\n+\t\t\t\t\t// Pre-condition: any function in scope that returns a truthy value\n+\t\t\t\t\tfunc: function () {\n+\t\t\t\t\t\treturn \"anything truthy\";\n+\t\t\t\t\t},\n+\t\t\t\t};\n+\t\t\t\tconst options = {\n+\t\t\t\t\t// Force to use ASTInterpreter\n+\t\t\t\t\tcsp: true,\n+\t\t\t\t};\n+\t\t\t\tconst result = expressions.compile(\n+\t\t\t\t\t\"hasOwnProperty = func; constructor.getPrototypeOf(toString).constructor('return process')()\",\n+\t\t\t\t\toptions\n+\t\t\t\t)(scope, scope);\n+\t\t\t\texpect(result).to.equal(undefined);\n+\t\t\t});\n \t\t});\n \n \t\tdescribe(\"when evaluating dot-notated assignments\", function () {\n@@ -676,6 +703,13 @@ describe(\"expressions\", function () {\n \t\t\t});\n \t\t\texpect(evaluate(scope)).to.equal(\"myval\");\n \t\t});\n+\n+\t\tit(\"should be possible to calc this+this+this\", function () {\n+\t\t\tconst evaluate = compile(\"this+this+this\", {\n+\t\t\t\tcsp: false,\n+\t\t\t});\n+\t\t\texpect(evaluate(1)).to.equal(3);\n+\t\t});\n \t});\n \n \tdescribe(\"Equality\", function () {\n@@ -756,7 +790,7 @@ describe(\"expressions\", function () {\n \n \t\tit(\"should not leak with computed prop\", function () {\n \t\t\tevaluate = compile(\"a['split']\");\n-\t\t\texpect(evaluate({ a: \"\" })).to.eql(null);\n+\t\t\texpect(evaluate({ a: \"\" })).to.eql(undefined);\n \t\t});\n \n \t\tit(\"should allow to read string length\", function () {\n@@ -782,11 +816,44 @@ describe(\"expressions\", function () {\n \t\t\t);\n \t\t});\n \n-\t\tit(\"should work with __proto__\", function () {\n+\t\tit(\"should not show value of __proto__\", function () {\n \t\t\tevaluate = compile(\"__proto__\");\n \t\t\texpect(evaluate({})).to.eql(undefined);\n \t\t});\n \n+\t\tit(\"should not show value of __proto__ if passing context (second argument) with csp = false\", function () {\n+\t\t\tevaluate = compile(\"__proto__\");\n+\t\t\texpect(evaluate({}, {})).to.eql(undefined);\n+\t\t});\n+\n+\t\tit(\"should not show value of __proto__ if passing context (second argument) with csp = true\", function () {\n+\t\t\tevaluate = compile(\"__proto__\", {\n+\t\t\t\tcsp: true,\n+\t\t\t});\n+\t\t\texpect(evaluate({}, {})).to.eql(undefined);\n+\t\t});\n+\n+\t\tit(\"should not show value of constructor if passing context (second argument) with csp = true\", function () {\n+\t\t\tevaluate = compile(\"constructor\", {\n+\t\t\t\tcsp: true,\n+\t\t\t});\n+\t\t\texpect(evaluate({}, {})).to.eql(undefined);\n+\t\t});\n+\n+\t\tit(\"should not show value of this['__proto__'] if passing context (second argument) with csp = true\", function () {\n+\t\t\tevaluate = compile(\"this['__proto' + '__']\", {\n+\t\t\t\tcsp: true,\n+\t\t\t});\n+\t\t\texpect(evaluate({}, {})).to.eql(undefined);\n+\t\t});\n+\n+\t\tit(\"should not show value of this['__proto__'] if passing context (second argument) with csp = false\", function () {\n+\t\t\tevaluate = compile(\"this['__proto' + '__']\", {\n+\t\t\t\tcsp: false,\n+\t\t\t});\n+\t\t\texpect(evaluate({}, {})).to.eql(undefined);\n+\t\t});\n+\n \t\tit(\"should work with toString\", function () {\n \t\t\tevaluate = compile(\"toString\");\n \t\t\texpect(evaluate({ toString: 10 })).to.eql(10);"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "bcc88ba5f0c677a9c5c341ac2723ff10c0b4b67d",
            "date": "2024-12-13T20:09:41Z",
            "author_login": "edi9999"
          },
          {
            "sha": "f7f0d99f8b6c9ff7ac546269546d2ad4ac88a86a",
            "date": "2024-12-13T20:08:44Z",
            "author_login": "edi9999"
          },
          {
            "sha": "e422a8c9abd22c7c450131f89283515f68893daa",
            "date": "2024-12-10T13:20:59Z",
            "author_login": "edi9999"
          },
          {
            "sha": "97f7ad94006156eeb97fc942332578b6cfbf8eef",
            "date": "2024-12-10T13:18:04Z",
            "author_login": "edi9999"
          },
          {
            "sha": "c0bf5433d88b4527b4670153ff258378f3ef4ff3",
            "date": "2024-11-25T21:06:14Z",
            "author_login": "edi9999"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-94",
    "description": "Angular Expressions provides expressions for the Angular.JS web framework as a standalone module. Prior to version 1.4.3, an attacker can write a malicious expression that escapes the sandbox to execute arbitrary code on the system. With a more complex (undisclosed) payload, one can get full access to Arbitrary code execution on the system. The problem has been patched in version 1.4.3 of Angular Expressions. Two possible workarounds are available. One may either disable access to `__proto__` globally or make sure that one uses the function with just one argument.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-12-10T16:15:23.947",
    "last_modified": "2024-12-10T16:15:23.947",
    "fix_date": "2024-12-10T13:18:04Z"
  },
  "references": [
    {
      "url": "https://github.com/peerigon/angular-expressions/commit/97f7ad94006156eeb97fc942332578b6cfbf8eef",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/peerigon/angular-expressions/security/advisories/GHSA-5462-4vcx-jh7j",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:33.114892",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "angular-expressions",
    "owner": "peerigon",
    "created_at": "2014-03-12T00:01:12Z",
    "updated_at": "2024-12-13T20:09:53Z",
    "pushed_at": "2024-12-13T20:09:49Z",
    "size": 1032,
    "stars": 95,
    "forks": 23,
    "open_issues": 2,
    "watchers": 95,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "JavaScript": 107601,
      "Shell": 1864,
      "TypeScript": 1016
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "unlicense"
    },
    "collected_at": "2025-01-14T17:07:55.969867"
  }
}