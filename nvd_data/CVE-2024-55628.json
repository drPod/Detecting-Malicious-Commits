{
  "cve_id": "CVE-2024-55628",
  "github_data": {
    "repository": "OISF/suricata",
    "fix_commit": "19cf0f81335d9f787d587450f7105ad95a648951",
    "related_commits": [
      "19cf0f81335d9f787d587450f7105ad95a648951",
      "37f4c52b22fcdde4adf9b479cb5700f89d00768d",
      "3a5671739f5b25e5dd973a74ca5fd8ea40e1ae2d"
    ],
    "patch_url": "https://github.com/OISF/suricata/commit/19cf0f81335d9f787d587450f7105ad95a648951.patch",
    "fix_commit_details": {
      "sha": "19cf0f81335d9f787d587450f7105ad95a648951",
      "commit_date": "2024-11-01T17:39:23Z",
      "author": {
        "login": "jasonish",
        "type": "User",
        "stats": {
          "total_commits": 1524,
          "average_weekly_commits": 1.7720930232558139,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 330
        }
      },
      "commit_message": {
        "title": "dns: provide events for recoverable parse errors",
        "length": 837,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 203,
        "additions": 142,
        "deletions": 61
      },
      "files": [
        {
          "filename": "rules/dns-events.rules",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -8,3 +8,12 @@ alert dns any any -> any any (msg:\"SURICATA DNS Not a response\"; flow:to_client;\n # Z flag (reserved) not 0\n alert dns any any -> any any (msg:\"SURICATA DNS Z flag set\"; app-layer-event:dns.z_flag_set; classtype:protocol-command-decode; sid:2240006; rev:2;)\n alert dns any any -> any any (msg:\"SURICATA DNS Invalid opcode\"; app-layer-event:dns.invalid_opcode; classtype:protocol-command-decode; sid:2240007; rev:1;)\n+\n+# A resource name was too long (over 1025 chars)\n+alert dns any any -> any any (msg:\"SURICATA DNS Name too long\"; app-layer-event:dns.name_too_long; classtype:protocol-command-decode; sid:224008; rev:1;)\n+\n+# An infinite loop was found while decoding a DNS resource name.\n+alert dns any any -> any any (msg:\"SURICATA DNS Infinite loop\"; app-layer-event:dns.infinite_loop; classtype:protocol-command-decode; sid:224009; rev:1;)\n+\n+# Suricata's maximum number of DNS name labels was reached while parsing a resource name.\n+alert dns any any -> any any (msg:\"SURICATA DNS Too many labels\"; app-layer-event:dns.too_many_labels; classtype:protocol-command-decode; sid:224010; rev:1;)"
        },
        {
          "filename": "rust/src/dns/dns.rs",
          "status": "modified",
          "additions": 35,
          "deletions": 3,
          "patch": "@@ -129,6 +129,12 @@ pub enum DNSEvent {\n     NotResponse,\n     ZFlagSet,\n     InvalidOpcode,\n+    /// A DNS resource name was exessively long and was truncated.\n+    NameTooLong,\n+    /// An infinite loop was found while parsing a name.\n+    InfiniteLoop,\n+    /// Too many labels were found.\n+    TooManyLabels,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -383,7 +389,7 @@ pub(crate) fn dns_parse_request(input: &[u8]) -> Result<DNSTransaction, DNSParse\n     };\n \n     match parser::dns_parse_body(body, input, header) {\n-        Ok((_, request)) => {\n+        Ok((_, (request, parse_flags))) => {\n             if request.header.flags & 0x8000 != 0 {\n                 SCLogDebug!(\"DNS message is not a request\");\n                 return Err(DNSParseError::NotRequest);\n@@ -399,10 +405,23 @@ pub(crate) fn dns_parse_request(input: &[u8]) -> Result<DNSTransaction, DNSParse\n                 SCLogDebug!(\"Z-flag set on DNS request\");\n                 tx.set_event(DNSEvent::ZFlagSet);\n             }\n+\n             if opcode >= 7 {\n                 tx.set_event(DNSEvent::InvalidOpcode);\n             }\n \n+            if parse_flags.contains(DNSNameFlags::TRUNCATED) {\n+                tx.set_event(DNSEvent::NameTooLong);\n+            }\n+\n+            if parse_flags.contains(DNSNameFlags::INFINITE_LOOP) {\n+                tx.set_event(DNSEvent::InfiniteLoop);\n+            }\n+\n+            if parse_flags.contains(DNSNameFlags::LABEL_LIMIT) {\n+                tx.set_event(DNSEvent::TooManyLabels);\n+            }\n+\n             return Ok(tx);\n         }\n         Err(Err::Incomplete(_)) => {\n@@ -426,7 +445,7 @@ pub(crate) fn dns_parse_response(input: &[u8]) -> Result<DNSTransaction, DNSPars\n     };\n \n     match parser::dns_parse_body(body, input, header) {\n-        Ok((_, response)) => {\n+        Ok((_, (response, parse_flags))) => {\n             SCLogDebug!(\"Response header flags: {}\", response.header.flags);\n             let z_flag = response.header.flags & 0x0040 != 0;\n             let opcode = ((response.header.flags >> 11) & 0xf) as u8;\n@@ -444,10 +463,23 @@ pub(crate) fn dns_parse_response(input: &[u8]) -> Result<DNSTransaction, DNSPars\n                 SCLogDebug!(\"Z-flag set on DNS response\");\n                 tx.set_event(DNSEvent::ZFlagSet);\n             }\n+\n             if opcode >= 7 {\n                 tx.set_event(DNSEvent::InvalidOpcode);\n             }\n \n+            if parse_flags.contains(DNSNameFlags::TRUNCATED) {\n+                tx.set_event(DNSEvent::NameTooLong);\n+            }\n+\n+            if parse_flags.contains(DNSNameFlags::INFINITE_LOOP) {\n+                tx.set_event(DNSEvent::InfiniteLoop);\n+            }\n+\n+            if parse_flags.contains(DNSNameFlags::LABEL_LIMIT) {\n+                tx.set_event(DNSEvent::TooManyLabels);\n+            }\n+\n             return Ok(tx);\n         }\n         Err(Err::Incomplete(_)) => {\n@@ -778,7 +810,7 @@ fn probe(input: &[u8], dlen: usize) -> (bool, bool, bool) {\n \n     match parser::dns_parse_header(input) {\n         Ok((body, header)) => match parser::dns_parse_body(body, input, header) {\n-            Ok((_, request)) => probe_header_validity(&request.header, dlen),\n+            Ok((_, (request, _flags))) => probe_header_validity(&request.header, dlen),\n             Err(Err::Incomplete(_)) => (false, false, true),\n             Err(_) => (false, false, false),\n         },"
        },
        {
          "filename": "rust/src/dns/parser.rs",
          "status": "modified",
          "additions": 98,
          "deletions": 58,
          "patch": "@@ -60,7 +60,9 @@ static MAX_NAME_LEN: usize = 1025;\n /// Parameters:\n ///   start: the start of the name\n ///   message: the complete message that start is a part of with the DNS header\n-fn dns_parse_name<'b>(start: &'b [u8], message: &'b [u8]) -> IResult<&'b [u8], DNSName> {\n+fn dns_parse_name<'b>(\n+    start: &'b [u8], message: &'b [u8], parse_flags: &mut DNSNameFlags,\n+) -> IResult<&'b [u8], DNSName> {\n     let mut pos = start;\n     let mut pivot = start;\n     let mut name: Vec<u8> = Vec::with_capacity(32);\n@@ -145,6 +147,8 @@ fn dns_parse_name<'b>(start: &'b [u8], message: &'b [u8]) -> IResult<&'b [u8], D\n         }\n     }\n \n+    parse_flags.insert(flags);\n+\n     // If we followed a pointer we return the position after the first\n     // pointer followed. Is there a better way to see if these slices\n     // diverged from each other?  A straight up comparison would\n@@ -167,7 +171,7 @@ fn dns_parse_name<'b>(start: &'b [u8], message: &'b [u8]) -> IResult<&'b [u8], D\n /// multi-string TXT entry as a single quote string, similar to the\n /// output of dig. Something to consider for a future version.\n fn dns_parse_answer<'a>(\n-    slice: &'a [u8], message: &'a [u8], count: usize,\n+    slice: &'a [u8], message: &'a [u8], count: usize, flags: &mut DNSNameFlags,\n ) -> IResult<&'a [u8], Vec<DNSAnswerEntry>> {\n     let mut answers = Vec::new();\n     let mut input = slice;\n@@ -180,8 +184,10 @@ fn dns_parse_answer<'a>(\n         data: &'a [u8],\n     }\n \n-    fn subparser<'a>(i: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], Answer<'a>> {\n-        let (i, name) = dns_parse_name(i, message)?;\n+    fn subparser<'a>(\n+        i: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+    ) -> IResult<&'a [u8], Answer<'a>> {\n+        let (i, name) = dns_parse_name(i, message, flags)?;\n         let (i, rrtype) = be_u16(i)?;\n         let (i, rrclass) = be_u16(i)?;\n         let (i, ttl) = be_u32(i)?;\n@@ -197,7 +203,7 @@ fn dns_parse_answer<'a>(\n     }\n \n     for _ in 0..count {\n-        match subparser(input, message) {\n+        match subparser(input, message, flags) {\n             Ok((rem, val)) => {\n                 let n = match val.rrtype {\n                     DNS_RECORD_TYPE_TXT => {\n@@ -227,8 +233,11 @@ fn dns_parse_answer<'a>(\n                     input = rem;\n                     continue;\n                 }\n-                let result: IResult<&'a [u8], Vec<DNSRData>> =\n-                    many_m_n(1, n, complete(|b| dns_parse_rdata(b, message, val.rrtype)))(val.data);\n+                let result: IResult<&'a [u8], Vec<DNSRData>> = many_m_n(\n+                    1,\n+                    n,\n+                    complete(|b| dns_parse_rdata(b, message, val.rrtype, flags)),\n+                )(val.data);\n                 match result {\n                     Ok((_, rdatas)) => {\n                         for rdata in rdatas {\n@@ -261,9 +270,11 @@ fn dns_parse_answer<'a>(\n /// Arguments are suitable for using with call!:\n ///\n ///    call!(complete_dns_message_buffer)\n-fn dns_parse_query<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSQueryEntry> {\n+fn dns_parse_query<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSQueryEntry> {\n     let i = input;\n-    let (i, name) = dns_parse_name(i, message)?;\n+    let (i, name) = dns_parse_name(i, message, flags)?;\n     let (i, rrtype) = be_u16(i)?;\n     let (i, rrclass) = be_u16(i)?;\n     Ok((\n@@ -284,22 +295,30 @@ fn dns_parse_rdata_aaaa(input: &[u8]) -> IResult<&[u8], DNSRData> {\n     rest(input).map(|(input, data)| (input, DNSRData::AAAA(data.to_vec())))\n }\n \n-fn dns_parse_rdata_cname<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSRData> {\n-    dns_parse_name(input, message).map(|(input, name)| (input, DNSRData::CNAME(name)))\n+fn dns_parse_rdata_cname<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSRData> {\n+    dns_parse_name(input, message, flags).map(|(input, name)| (input, DNSRData::CNAME(name)))\n }\n \n-fn dns_parse_rdata_ns<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSRData> {\n-    dns_parse_name(input, message).map(|(input, name)| (input, DNSRData::NS(name)))\n+fn dns_parse_rdata_ns<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSRData> {\n+    dns_parse_name(input, message, flags).map(|(input, name)| (input, DNSRData::NS(name)))\n }\n \n-fn dns_parse_rdata_ptr<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSRData> {\n-    dns_parse_name(input, message).map(|(input, name)| (input, DNSRData::PTR(name)))\n+fn dns_parse_rdata_ptr<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSRData> {\n+    dns_parse_name(input, message, flags).map(|(input, name)| (input, DNSRData::PTR(name)))\n }\n \n-fn dns_parse_rdata_soa<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSRData> {\n+fn dns_parse_rdata_soa<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSRData> {\n     let i = input;\n-    let (i, mname) = dns_parse_name(i, message)?;\n-    let (i, rname) = dns_parse_name(i, message)?;\n+    let (i, mname) = dns_parse_name(i, message, flags)?;\n+    let (i, rname) = dns_parse_name(i, message, flags)?;\n     let (i, serial) = be_u32(i)?;\n     let (i, refresh) = be_u32(i)?;\n     let (i, retry) = be_u32(i)?;\n@@ -319,20 +338,24 @@ fn dns_parse_rdata_soa<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u\n     ))\n }\n \n-fn dns_parse_rdata_mx<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSRData> {\n+fn dns_parse_rdata_mx<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSRData> {\n     // For MX we skip over the preference field before\n     // parsing out the name.\n     let (i, _) = be_u16(input)?;\n-    let (i, name) = dns_parse_name(i, message)?;\n+    let (i, name) = dns_parse_name(i, message, flags)?;\n     Ok((i, DNSRData::MX(name)))\n }\n \n-fn dns_parse_rdata_srv<'a>(input: &'a [u8], message: &'a [u8]) -> IResult<&'a [u8], DNSRData> {\n+fn dns_parse_rdata_srv<'a>(\n+    input: &'a [u8], message: &'a [u8], flags: &mut DNSNameFlags,\n+) -> IResult<&'a [u8], DNSRData> {\n     let i = input;\n     let (i, priority) = be_u16(i)?;\n     let (i, weight) = be_u16(i)?;\n     let (i, port) = be_u16(i)?;\n-    let (i, target) = dns_parse_name(i, message)?;\n+    let (i, target) = dns_parse_name(i, message, flags)?;\n     Ok((\n         i,\n         DNSRData::SRV(DNSRDataSRV {\n@@ -389,20 +412,20 @@ fn dns_parse_rdata_unknown(input: &[u8]) -> IResult<&[u8], DNSRData> {\n }\n \n fn dns_parse_rdata<'a>(\n-    input: &'a [u8], message: &'a [u8], rrtype: u16,\n+    input: &'a [u8], message: &'a [u8], rrtype: u16, flags: &mut DNSNameFlags,\n ) -> IResult<&'a [u8], DNSRData> {\n     match rrtype {\n         DNS_RECORD_TYPE_A => dns_parse_rdata_a(input),\n         DNS_RECORD_TYPE_AAAA => dns_parse_rdata_aaaa(input),\n-        DNS_RECORD_TYPE_CNAME => dns_parse_rdata_cname(input, message),\n-        DNS_RECORD_TYPE_PTR => dns_parse_rdata_ptr(input, message),\n-        DNS_RECORD_TYPE_SOA => dns_parse_rdata_soa(input, message),\n-        DNS_RECORD_TYPE_MX => dns_parse_rdata_mx(input, message),\n-        DNS_RECORD_TYPE_NS => dns_parse_rdata_ns(input, message),\n+        DNS_RECORD_TYPE_CNAME => dns_parse_rdata_cname(input, message, flags),\n+        DNS_RECORD_TYPE_PTR => dns_parse_rdata_ptr(input, message, flags),\n+        DNS_RECORD_TYPE_SOA => dns_parse_rdata_soa(input, message, flags),\n+        DNS_RECORD_TYPE_MX => dns_parse_rdata_mx(input, message, flags),\n+        DNS_RECORD_TYPE_NS => dns_parse_rdata_ns(input, message, flags),\n         DNS_RECORD_TYPE_TXT => dns_parse_rdata_txt(input),\n         DNS_RECORD_TYPE_NULL => dns_parse_rdata_null(input),\n         DNS_RECORD_TYPE_SSHFP => dns_parse_rdata_sshfp(input),\n-        DNS_RECORD_TYPE_SRV => dns_parse_rdata_srv(input, message),\n+        DNS_RECORD_TYPE_SRV => dns_parse_rdata_srv(input, message, flags),\n         DNS_RECORD_TYPE_OPT => dns_parse_rdata_opt(input),\n         _ => dns_parse_rdata_unknown(input),\n     }\n@@ -431,20 +454,27 @@ pub fn dns_parse_header(i: &[u8]) -> IResult<&[u8], DNSHeader> {\n \n pub fn dns_parse_body<'a>(\n     i: &'a [u8], message: &'a [u8], header: DNSHeader,\n-) -> IResult<&'a [u8], DNSMessage> {\n-    let (i, queries) = count(|b| dns_parse_query(b, message), header.questions as usize)(i)?;\n-    let (i, answers) = dns_parse_answer(i, message, header.answer_rr as usize)?;\n-    let (i, authorities) = dns_parse_answer(i, message, header.authority_rr as usize)?;\n-    let (i, additionals) = dns_parse_answer(i, message, header.additional_rr as usize)?;\n+) -> IResult<&'a [u8], (DNSMessage, DNSNameFlags)> {\n+    let mut flags = DNSNameFlags::default();\n+    let (i, queries) = count(\n+        |b| dns_parse_query(b, message, &mut flags),\n+        header.questions as usize,\n+    )(i)?;\n+    let (i, answers) = dns_parse_answer(i, message, header.answer_rr as usize, &mut flags)?;\n+    let (i, authorities) = dns_parse_answer(i, message, header.authority_rr as usize, &mut flags)?;\n+    let (i, additionals) = dns_parse_answer(i, message, header.additional_rr as usize, &mut flags)?;\n     Ok((\n         i,\n-        DNSMessage {\n-            header,\n-            queries,\n-            answers,\n-            authorities,\n-            additionals,\n-        },\n+        (\n+            DNSMessage {\n+                header,\n+                queries,\n+                answers,\n+                authorities,\n+                additionals,\n+            },\n+            flags,\n+        ),\n     ))\n }\n \n@@ -464,7 +494,8 @@ mod tests {\n             0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, /* .com.... */\n         ];\n         let expected_remainder: &[u8] = &[0x00, 0x01, 0x00];\n-        let (remainder, name) = dns_parse_name(buf, buf).unwrap();\n+        let mut flags = DNSNameFlags::default();\n+        let (remainder, name) = dns_parse_name(buf, buf, &mut flags).unwrap();\n         assert_eq!(\"client-cf.dropbox.com\".as_bytes(), &name.value[..]);\n         assert_eq!(remainder, expected_remainder);\n     }\n@@ -498,7 +529,8 @@ mod tests {\n \n         // The name at offset 54 is the complete name.\n         let start1 = &buf[54..];\n-        let res1 = dns_parse_name(start1, message);\n+        let mut flags = DNSNameFlags::default();\n+        let res1 = dns_parse_name(start1, message, &mut flags);\n         assert_eq!(\n             res1,\n             Ok((\n@@ -513,7 +545,8 @@ mod tests {\n         // The second name starts at offset 80, but is just a pointer\n         // to the first.\n         let start2 = &buf[80..];\n-        let res2 = dns_parse_name(start2, message);\n+        let mut flags = DNSNameFlags::default();\n+        let res2 = dns_parse_name(start2, message, &mut flags);\n         assert_eq!(\n             res2,\n             Ok((\n@@ -528,7 +561,8 @@ mod tests {\n         // The third name starts at offset 94, but is a pointer to a\n         // portion of the first.\n         let start3 = &buf[94..];\n-        let res3 = dns_parse_name(start3, message);\n+        let mut flags = DNSNameFlags::default();\n+        let res3 = dns_parse_name(start3, message, &mut flags);\n         assert_eq!(\n             res3,\n             Ok((\n@@ -543,7 +577,8 @@ mod tests {\n         // The fourth name starts at offset 110, but is a pointer to a\n         // portion of the first.\n         let start4 = &buf[110..];\n-        let res4 = dns_parse_name(start4, message);\n+        let mut flags = DNSNameFlags::default();\n+        let res4 = dns_parse_name(start4, message, &mut flags);\n         assert_eq!(\n             res4,\n             Ok((\n@@ -584,7 +619,8 @@ mod tests {\n         // packet).\n         let start: &[u8] = &buf[100..];\n \n-        let res = dns_parse_name(start, message);\n+        let mut flags = DNSNameFlags::default();\n+        let res = dns_parse_name(start, message, &mut flags);\n         assert_eq!(\n             res,\n             Ok((\n@@ -612,7 +648,7 @@ mod tests {\n \n         let (body, header) = dns_parse_header(pkt).unwrap();\n         let res = dns_parse_body(body, pkt, header);\n-        let (rem, request) = res.unwrap();\n+        let (rem, (request, _flags)) = res.unwrap();\n         // The request should be fully parsed.\n         assert!(rem.is_empty());\n \n@@ -674,7 +710,7 @@ mod tests {\n \n         let (body, header) = dns_parse_header(pkt).unwrap();\n         let res = dns_parse_body(body, pkt, header);\n-        let (rem, request) = res.unwrap();\n+        let (rem, (request, _flags)) = res.unwrap();\n \n         assert!(rem.is_empty());\n         assert_eq!(\n@@ -726,7 +762,7 @@ mod tests {\n     }\n \n     /// Parse a DNS response.\n-    fn dns_parse_response(message: &[u8]) -> IResult<&[u8], DNSMessage> {\n+    fn dns_parse_response(message: &[u8]) -> IResult<&[u8], (DNSMessage, DNSNameFlags)> {\n         let i = message;\n         let (i, header) = dns_parse_header(i)?;\n         dns_parse_body(i, message, header)\n@@ -751,7 +787,7 @@ mod tests {\n             0x00, 0x04, 0xc0, 0x00, 0x4e, 0x19, /* ....N. */\n         ];\n \n-        let (rem, response) = dns_parse_response(pkt).unwrap();\n+        let (rem, (response, _flags)) = dns_parse_response(pkt).unwrap();\n         // The response should be full parsed.\n         assert_eq!(rem.len(), 0);\n \n@@ -839,7 +875,7 @@ mod tests {\n             0x00, 0x00, 0x00, 0x00, /* .... */\n         ];\n \n-        let (rem, response) = dns_parse_response(pkt).unwrap();\n+        let (rem, (response, _flags)) = dns_parse_response(pkt).unwrap();\n         // The response should be fully parsed.\n         assert!(rem.is_empty());\n \n@@ -916,7 +952,7 @@ mod tests {\n             0x44, 0x03, 0xc5, 0xe9, 0x01, /* D.... */\n         ];\n \n-        let (rem, response) = dns_parse_response(pkt).unwrap();\n+        let (rem, (response, _flags)) = dns_parse_response(pkt).unwrap();\n         // The response should be fully parsed.\n         assert_eq!(rem.len(), 0);\n \n@@ -1017,7 +1053,7 @@ mod tests {\n             0x67, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00,\n         ];\n \n-        let (rem, response) = dns_parse_response(pkt).unwrap();\n+        let (rem, (response, _flags)) = dns_parse_response(pkt).unwrap();\n         // The data should be fully parsed.\n         assert_eq!(rem.len(), 0);\n \n@@ -1060,7 +1096,8 @@ mod tests {\n             }\n         }\n \n-        let (rem, name) = dns_parse_name(&buf, &buf).unwrap();\n+        let mut flags = DNSNameFlags::default();\n+        let (rem, name) = dns_parse_name(&buf, &buf, &mut flags).unwrap();\n         assert_eq!(name.value.len(), MAX_NAME_LEN);\n         assert!(name.flags.contains(DNSNameFlags::TRUNCATED));\n         assert!(rem.is_empty());\n@@ -1077,7 +1114,8 @@ mod tests {\n         // This should fail as we've hit the segment limit without a\n         // pointer, we'd need to keep parsing more segments to figure\n         // out where the next data point lies.\n-        assert!(dns_parse_name(&buf, &buf).is_err());\n+        let mut flags = DNSNameFlags::default();\n+        assert!(dns_parse_name(&buf, &buf, &mut flags).is_err());\n     }\n \n     #[test]\n@@ -1097,7 +1135,8 @@ mod tests {\n         buf.push(0b1100_0000);\n         buf.push(0b000_0000);\n \n-        let (_rem, name) = dns_parse_name(&buf[4..], &buf).unwrap();\n+        let mut flags = DNSNameFlags::default();\n+        let (_rem, name) = dns_parse_name(&buf[4..], &buf, &mut flags).unwrap();\n         assert_eq!(name.value.len(), 255);\n         assert!(name.flags.contains(DNSNameFlags::TRUNCATED));\n     }\n@@ -1107,6 +1146,7 @@ mod tests {\n         let mut buf = vec![];\n         buf.push(0b1100_0000);\n         buf.push(0b0000_0000);\n-        assert!(dns_parse_name(&buf, &buf).is_err());\n+        let mut flags = DNSNameFlags::default();\n+        assert!(dns_parse_name(&buf, &buf, &mut flags).is_err());\n     }\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "637708acb476cdae526b870e4301e22197da1869",
            "date": "2025-01-13T12:39:21Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "a92212d6e504b535c63ce8d234bf4804c7b8dcca",
            "date": "2025-01-10T16:27:55Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "eab212b0be760daa2689bcb6e2d05c12fd708682",
            "date": "2025-01-10T15:57:51Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "ae1a4ef757583e4307d3322130f893db4b716a59",
            "date": "2024-11-11T06:26:11Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "e6be049c5dc2859a833fc21321bc7bfd15be2904",
            "date": "2024-11-11T06:21:03Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-405",
    "description": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to version 7.0.8, DNS resource name compression can lead to small DNS messages containing very large hostnames which can be costly to decode, and lead to very large DNS log records. While there are limits in place, they were too generous. The issue has been addressed in Suricata 7.0.8.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2025-01-06T18:15:22.947",
    "last_modified": "2025-01-06T18:15:22.947",
    "fix_date": "2024-11-01T17:39:23Z"
  },
  "references": [
    {
      "url": "https://github.com/OISF/suricata/commit/19cf0f81335d9f787d587450f7105ad95a648951",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OISF/suricata/commit/37f4c52b22fcdde4adf9b479cb5700f89d00768d",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OISF/suricata/commit/3a5671739f5b25e5dd973a74ca5fd8ea40e1ae2d",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-96w4-jqwf-qx2j",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/7280",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.978450",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "OISF",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-14T12:53:46Z",
    "pushed_at": "2025-01-14T06:40:06Z",
    "size": 74648,
    "stars": 4847,
    "forks": 1483,
    "open_issues": 74,
    "watchers": 4847,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 13993560,
      "Rust": 3470702,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45461,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1056,
      "avg_commits_per_week": 20.307692307692307,
      "days_active_last_year": 254
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:41:46.043023"
  }
}