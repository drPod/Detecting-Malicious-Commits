{
  "cve_id": "CVE-2024-55629",
  "github_data": {
    "repository": "OISF/suricata",
    "fix_commit": "6882bcb3e51bd3cf509fb6569cc30f48d7bb53d7",
    "related_commits": [
      "6882bcb3e51bd3cf509fb6569cc30f48d7bb53d7",
      "779f9d8ba35c3f9b5abfa327d3a4209861bd2eb8"
    ],
    "patch_url": "https://github.com/OISF/suricata/commit/6882bcb3e51bd3cf509fb6569cc30f48d7bb53d7.patch",
    "fix_commit_details": {
      "sha": "6882bcb3e51bd3cf509fb6569cc30f48d7bb53d7",
      "commit_date": "2024-10-10T14:12:09Z",
      "author": {
        "login": "victorjulien",
        "type": "User",
        "stats": {
          "total_commits": 7714,
          "average_weekly_commits": 8.969767441860466,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 725
        }
      },
      "commit_message": {
        "title": "stream: add TCP urgent handling options",
        "length": 1479,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 219,
        "additions": 196,
        "deletions": 23
      },
      "files": [
        {
          "filename": "etc/schema.json",
          "status": "modified",
          "additions": 15,
          "deletions": 3,
          "patch": "@@ -1129,7 +1129,8 @@\n                     \"$ref\": \"#/$defs/dns.additionals\"\n                 },\n                 \"query\": {\n-                    \"$comment\": \"EVE DNS v2 style query logging; as of Suricata 8 only used in DNS records when v2 logging is enabled, not used for DNS records logged as part of an event.\",\n+                    \"$comment\":\n+                            \"EVE DNS v2 style query logging; as of Suricata 8 only used in DNS records when v2 logging is enabled, not used for DNS records logged as part of an event.\",\n                     \"type\": \"array\",\n                     \"minItems\": 1,\n                     \"items\": {\n@@ -5185,6 +5186,11 @@\n                                             \"Number of packets dropped due to stream reassembly exception policy\",\n                                     \"type\": \"integer\"\n                                 },\n+                                \"stream_urgent\": {\n+                                    \"description\":\n+                                            \"Number of packets dropped due to TCP urgent flag\",\n+                                    \"type\": \"integer\"\n+                                },\n                                 \"nfq_error\": {\n                                     \"description\":\n                                             \"Number of packets dropped due to no NFQ verdict\",\n@@ -6072,7 +6078,8 @@\n                             \"type\": \"integer\"\n                         },\n                         \"get_used\": {\n-                            \"description\": \"Number of reused flows from the hash table in case memcap was reached and spare pool was empty\",\n+                            \"description\":\n+                                    \"Number of reused flows from the hash table in case memcap was reached and spare pool was empty\",\n                             \"type\": \"integer\"\n                         },\n                         \"get_used_eval\": {\n@@ -6125,7 +6132,8 @@\n                             \"type\": \"integer\"\n                         },\n                         \"tcp_reuse\": {\n-                            \"description\": \"Number of TCP flows that were reused as they seemed to share the same flow tuple\",\n+                            \"description\":\n+                                    \"Number of TCP flows that were reused as they seemed to share the same flow tuple\",\n                             \"type\": \"integer\"\n                         },\n                         \"total\": {\n@@ -6550,6 +6558,10 @@\n                         \"urg\": {\n                             \"description\": \"Number of TCP packets with the urgent flag set\",\n                             \"type\": \"integer\"\n+                        },\n+                        \"urgent_oob_data\": {\n+                            \"description\": \"Number of OOB bytes tracked in TCP urgent handling\",\n+                            \"type\": \"integer\"\n                         }\n                     },\n                     \"additionalProperties\": false"
        },
        {
          "filename": "rules/stream-events.rules",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -109,5 +109,7 @@ alert tcp any any -> any any (msg:\"SURICATA STREAM FIN SYN reuse\"; stream-event:\n # Depth setting reached for a stream. Very common in normal traffic, so disable by default.\n #alert tcp any any -> any any (msg:\"SURICATA STREAM reassembly depth reached\"; stream-event:reassembly_depth_reached; classtype:protocol-command-decode; sid:2210062; rev:1;)\n \n-# next sid 2210066\n+alert tcp any any -> any any (msg:\"SURICATA STREAM urgent OOB limit reached\";  stream-event:reassembly_urgent_oob_limit_reached; classtype:protocol-command-decode; sid:2210066; rev:1;)\n+\n+# next sid 2210067\n "
        },
        {
          "filename": "src/app-layer.c",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -735,6 +735,7 @@ int AppLayerHandleTCPData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, Packet\n     /* If a gap notification, relay the notification on to the\n      * app-layer if known. */\n     if (flags & STREAM_GAP) {\n+        SCLogDebug(\"GAP of size %u\", data_len);\n         if (alproto == ALPROTO_UNKNOWN) {\n             StreamTcpSetStreamFlagAppProtoDetectionCompleted(*stream);\n             SCLogDebug(\"ALPROTO_UNKNOWN flow %p, due to GAP in stream start\", f);"
        },
        {
          "filename": "src/decode-events.c",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -872,6 +872,10 @@ const struct DecodeEvents_ DEvents[] = {\n             \"stream.reassembly_insert_invalid\",\n             STREAM_REASSEMBLY_INSERT_INVALID,\n     },\n+    {\n+            \"stream.reassembly_urgent_oob_limit_reached\",\n+            STREAM_REASSEMBLY_URGENT_OOB_LIMIT_REACHED,\n+    },\n \n     /* ARP EVENTS */\n     {"
        },
        {
          "filename": "src/decode-events.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -296,6 +296,7 @@ enum {\n     STREAM_REASSEMBLY_INSERT_MEMCAP,\n     STREAM_REASSEMBLY_INSERT_LIMIT,\n     STREAM_REASSEMBLY_INSERT_INVALID,\n+    STREAM_REASSEMBLY_URGENT_OOB_LIMIT_REACHED,\n \n     /* ARP EVENTS */\n     ARP_PKT_TOO_SMALL,         /**< arp packet smaller than minimum size */"
        },
        {
          "filename": "src/decode.c",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -889,6 +889,8 @@ const char *PacketDropReasonToString(enum PacketDropReason r)\n             return \"stream memcap\";\n         case PKT_DROP_REASON_STREAM_MIDSTREAM:\n             return \"stream midstream\";\n+        case PKT_DROP_REASON_STREAM_URG:\n+            return \"stream urgent\";\n         case PKT_DROP_REASON_STREAM_REASSEMBLY:\n             return \"stream reassembly\";\n         case PKT_DROP_REASON_APPLAYER_ERROR:\n@@ -929,6 +931,8 @@ static const char *PacketDropReasonToJsonString(enum PacketDropReason r)\n             return \"ips.drop_reason.stream_memcap\";\n         case PKT_DROP_REASON_STREAM_MIDSTREAM:\n             return \"ips.drop_reason.stream_midstream\";\n+        case PKT_DROP_REASON_STREAM_URG:\n+            return \"ips.drop_reason.stream_urgent\";\n         case PKT_DROP_REASON_STREAM_REASSEMBLY:\n             return \"ips.drop_reason.stream_reassembly\";\n         case PKT_DROP_REASON_APPLAYER_ERROR:"
        },
        {
          "filename": "src/decode.h",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -371,6 +371,7 @@ enum PacketDropReason {\n     PKT_DROP_REASON_STREAM_MEMCAP,\n     PKT_DROP_REASON_STREAM_MIDSTREAM,\n     PKT_DROP_REASON_STREAM_REASSEMBLY,\n+    PKT_DROP_REASON_STREAM_URG,\n     PKT_DROP_REASON_NFQ_ERROR,    /**< no nfq verdict, must be error */\n     PKT_DROP_REASON_INNER_PACKET, /**< drop issued by inner (tunnel) packet */\n     PKT_DROP_REASON_MAX,"
        },
        {
          "filename": "src/stream-tcp-list.c",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -632,8 +632,7 @@ static void StreamTcpSegmentAddPacketData(\n  *  In case of error, this function returns the segment to the pool\n  */\n int StreamTcpReassembleInsertSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n-        TcpStream *stream, TcpSegment *seg, Packet *p,\n-        uint8_t *pkt_data, uint16_t pkt_datalen)\n+        TcpStream *stream, TcpSegment *seg, Packet *p, uint8_t *pkt_data, uint16_t pkt_datalen)\n {\n     SCEnter();\n "
        },
        {
          "filename": "src/stream-tcp-private.h",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -288,6 +288,8 @@ typedef struct TcpSession_ {\n     int8_t data_first_seen_dir;\n     /** track all the tcp flags we've seen */\n     uint8_t tcp_packet_flags;\n+    uint16_t urg_offset_ts;            /**< SEQ offset from accepted OOB urg bytes */\n+    uint16_t urg_offset_tc;            /**< SEQ offset from accepted OOB urg bytes */\n     /* coccinelle: TcpSession:flags:STREAMTCP_FLAG */\n     uint32_t flags;\n     uint32_t reassembly_depth; /**< reassembly depth for the stream */"
        },
        {
          "filename": "src/stream-tcp-reassemble.c",
          "status": "modified",
          "additions": 72,
          "deletions": 17,
          "patch": "@@ -28,10 +28,12 @@\n \n #include \"suricata-common.h\"\n #include \"suricata.h\"\n+#include \"packet.h\"\n #include \"detect.h\"\n #include \"flow.h\"\n #include \"threads.h\"\n #include \"conf.h\"\n+#include \"action-globals.h\"\n \n #include \"flow-util.h\"\n \n@@ -604,6 +606,15 @@ void StreamTcpReassembleFreeThreadCtx(TcpReassemblyThreadCtx *ra_ctx)\n     SCReturn;\n }\n \n+static void StreamTcpReassembleExceptionPolicyStatsIncr(\n+        ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, enum ExceptionPolicy policy)\n+{\n+    uint16_t id = ra_ctx->counter_tcp_reas_eps.eps_id[policy];\n+    if (likely(tv && id > 0)) {\n+        StatsIncr(tv, id);\n+    }\n+}\n+\n /**\n  *  \\brief check if stream in pkt direction has depth reached\n  *\n@@ -757,12 +768,65 @@ int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThre\n         SCReturnInt(0);\n     }\n \n+    uint16_t *urg_offset;\n+    if (PKT_IS_TOSERVER(p)) {\n+        urg_offset = &ssn->urg_offset_ts;\n+    } else {\n+        urg_offset = &ssn->urg_offset_tc;\n+    }\n+\n     const TCPHdr *tcph = PacketGetTCP(p);\n+    /* segment sequence number, offset by previously accepted\n+     * URG OOB data. */\n+    uint32_t seg_seq = TCP_GET_RAW_SEQ(tcph) - (*urg_offset);\n+    uint8_t urg_data = 0;\n+\n+    /* if stream_config.urgent_policy == TCP_STREAM_URGENT_DROP, we won't get here */\n+    if (tcph->th_flags & TH_URG) {\n+        const uint16_t urg_ptr = SCNtohs(tcph->th_urp);\n+        if (urg_ptr > 0 && urg_ptr <= p->payload_len &&\n+                (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB ||\n+                        stream_config.urgent_policy == TCP_STREAM_URGENT_GAP)) {\n+            /* track up to 64k out of band URG bytes. Fall back to inline\n+             * when that budget is exceeded. */\n+            if ((*urg_offset) < UINT16_MAX) {\n+                if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB)\n+                    (*urg_offset)++;\n+\n+                if ((*urg_offset) == UINT16_MAX) {\n+                    StreamTcpSetEvent(p, STREAM_REASSEMBLY_URGENT_OOB_LIMIT_REACHED);\n+                }\n+            } else {\n+                /* OOB limit DROP is handled here */\n+                if (stream_config.urgent_oob_limit_policy == TCP_STREAM_URGENT_DROP) {\n+                    PacketDrop(p, ACTION_DROP, PKT_DROP_REASON_STREAM_URG);\n+                    SCReturnInt(0);\n+                }\n+            }\n+            urg_data = 1; /* only treat last 1 byte as out of band. */\n+            if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB) {\n+                StatsIncr(tv, ra_ctx->counter_tcp_urgent_oob);\n+            }\n+\n+            /* depending on hitting the OOB limit, update urg_data or not */\n+            if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB &&\n+                    (*urg_offset) == UINT16_MAX &&\n+                    stream_config.urgent_oob_limit_policy == TCP_STREAM_URGENT_INLINE) {\n+                urg_data = 0;\n+            } else {\n+                if (urg_ptr == 1 && p->payload_len == 1) {\n+                    SCLogDebug(\"no non-URG data\");\n+                    SCReturnInt(0);\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t payload_len = p->payload_len - urg_data;\n \n     /* If we have reached the defined depth for either of the stream, then stop\n        reassembling the TCP session */\n-    uint32_t size =\n-            StreamTcpReassembleCheckDepth(ssn, stream, TCP_GET_RAW_SEQ(tcph), p->payload_len);\n+    uint32_t size = StreamTcpReassembleCheckDepth(ssn, stream, seg_seq, payload_len);\n     SCLogDebug(\"ssn %p: check depth returned %\"PRIu32, ssn, size);\n \n     if (stream->flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) {\n@@ -776,9 +840,9 @@ int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThre\n         SCReturnInt(0);\n     }\n \n-    DEBUG_VALIDATE_BUG_ON(size > p->payload_len);\n-    if (size > p->payload_len)\n-        size = p->payload_len;\n+    DEBUG_VALIDATE_BUG_ON(size > payload_len);\n+    if (size > payload_len)\n+        size = payload_len;\n \n     TcpSegment *seg = StreamTcpGetSegment(tv, ra_ctx);\n     if (seg == NULL) {\n@@ -790,7 +854,8 @@ int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThre\n \n     DEBUG_VALIDATE_BUG_ON(size > UINT16_MAX);\n     TCP_SEG_LEN(seg) = (uint16_t)size;\n-    seg->seq = TCP_GET_RAW_SEQ(tcph);\n+    /* set SEQUENCE number, adjusted to any URG pointer offset */\n+    seg->seq = seg_seq;\n \n     /* HACK: for TFO SYN packets the seq for data starts at + 1 */\n     if (TCP_HAS_TFO(p) && p->payload_len && (tcph->th_flags & TH_SYN))\n@@ -804,8 +869,7 @@ int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThre\n                 APPLAYER_PROTO_DETECTION_SKIPPED);\n     }\n \n-    int r = StreamTcpReassembleInsertSegment(\n-            tv, ra_ctx, stream, seg, p, p->payload, p->payload_len);\n+    int r = StreamTcpReassembleInsertSegment(tv, ra_ctx, stream, seg, p, p->payload, payload_len);\n     if (r < 0) {\n         if (r == -SC_ENOMEM) {\n             ssn->flags |= STREAMTCP_FLAG_LOSSY_BE_LIBERAL;\n@@ -1933,15 +1997,6 @@ static int StreamTcpReassembleHandleSegmentUpdateACK (ThreadVars *tv,\n     SCReturnInt(0);\n }\n \n-static void StreamTcpReassembleExceptionPolicyStatsIncr(\n-        ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx, enum ExceptionPolicy policy)\n-{\n-    uint16_t id = ra_ctx->counter_tcp_reas_eps.eps_id[policy];\n-    if (likely(tv && id > 0)) {\n-        StatsIncr(tv, id);\n-    }\n-}\n-\n int StreamTcpReassembleHandleSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n         TcpSession *ssn, TcpStream *stream, Packet *p)\n {"
        },
        {
          "filename": "src/stream-tcp-reassemble.h",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -83,6 +83,9 @@ typedef struct TcpReassemblyThreadCtx_ {\n \n     uint16_t counter_tcp_reass_data_normal_fail;\n     uint16_t counter_tcp_reass_data_overlap_fail;\n+\n+    /** count OOB bytes */\n+    uint16_t counter_tcp_urgent_oob;\n } TcpReassemblyThreadCtx;\n \n #define OS_POLICY_DEFAULT   OS_POLICY_BSD"
        },
        {
          "filename": "src/stream-tcp.c",
          "status": "modified",
          "additions": 74,
          "deletions": 0,
          "patch": "@@ -438,6 +438,17 @@ static inline bool StreamTcpInlineDropInvalid(void)\n             && (stream_config.flags & STREAMTCP_INIT_FLAG_DROP_INVALID));\n }\n \n+/** \\internal\n+ *  \\brief See if stream engine is dropping URG packets in inline mode\n+ *  \\retval false no\n+ *  \\retval true yes\n+ */\n+static inline bool StreamTcpInlineDropUrg(void)\n+{\n+    return ((stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) &&\n+            stream_config.urgent_policy == TCP_STREAM_URGENT_DROP);\n+}\n+\n /* hack: stream random range code expects random values in range of 0-RAND_MAX,\n  * but we can get both <0 and >RAND_MAX values from RandomGet\n  */\n@@ -452,6 +463,22 @@ static int RandomGetWrap(void)\n     return r % RAND_MAX;\n }\n \n+static const char *UrgentPolicyToString(enum TcpStreamUrgentHandling pol)\n+{\n+    switch (pol) {\n+        case TCP_STREAM_URGENT_OOB:\n+            return \"oob\";\n+        case TCP_STREAM_URGENT_INLINE:\n+            return \"inline\";\n+        case TCP_STREAM_URGENT_DROP:\n+            return \"drop\";\n+        case TCP_STREAM_URGENT_GAP:\n+            return \"gap\";\n+    }\n+    return NULL;\n+}\n+\n+\n /** \\brief          To initialize the stream global configuration data\n  *\n  *  \\param  quiet   It tells the mode of operation, if it is true nothing will\n@@ -601,6 +628,46 @@ void StreamTcpInitConfig(bool quiet)\n         stream_config.flags |= STREAMTCP_INIT_FLAG_DROP_INVALID;\n     }\n \n+    const char *temp_urgpol = NULL;\n+    if (ConfGet(\"stream.reassembly.urgent.policy\", &temp_urgpol) == 1 && temp_urgpol != NULL) {\n+        if (strcmp(temp_urgpol, \"inline\") == 0) {\n+            stream_config.urgent_policy = TCP_STREAM_URGENT_INLINE;\n+        } else if (strcmp(temp_urgpol, \"drop\") == 0) {\n+            stream_config.urgent_policy = TCP_STREAM_URGENT_DROP;\n+        } else if (strcmp(temp_urgpol, \"oob\") == 0) {\n+            stream_config.urgent_policy = TCP_STREAM_URGENT_OOB;\n+        } else if (strcmp(temp_urgpol, \"gap\") == 0) {\n+            stream_config.urgent_policy = TCP_STREAM_URGENT_GAP;\n+        } else {\n+            FatalError(\"stream.reassembly.urgent.policy: invalid value '%s'\", temp_urgpol);\n+        }\n+    } else {\n+        stream_config.urgent_policy = TCP_STREAM_URGENT_DEFAULT;\n+    }\n+    if (!quiet) {\n+        SCLogConfig(\"stream.reassembly.urgent.policy\\\": %s\", UrgentPolicyToString(stream_config.urgent_policy));\n+    }\n+    if (stream_config.urgent_policy == TCP_STREAM_URGENT_OOB) {\n+        const char *temp_urgoobpol = NULL;\n+        if (ConfGet(\"stream.reassembly.urgent.oob-limit-policy\", &temp_urgoobpol) == 1 &&\n+                temp_urgoobpol != NULL) {\n+            if (strcmp(temp_urgoobpol, \"inline\") == 0) {\n+                stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_INLINE;\n+            } else if (strcmp(temp_urgoobpol, \"drop\") == 0) {\n+                stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_DROP;\n+            } else if (strcmp(temp_urgoobpol, \"gap\") == 0) {\n+                stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_GAP;\n+            } else {\n+                FatalError(\"stream.reassembly.urgent.oob-limit-policy: invalid value '%s'\", temp_urgoobpol);\n+            }\n+        } else {\n+            stream_config.urgent_oob_limit_policy = TCP_STREAM_URGENT_DEFAULT;\n+        }\n+        if (!quiet) {\n+            SCLogConfig(\"stream.reassembly.urgent.oob-limit-policy\\\": %s\", UrgentPolicyToString(stream_config.urgent_oob_limit_policy));\n+        }\n+    }\n+\n     if ((ConfGetInt(\"stream.max-syn-queued\", &value)) == 1) {\n         if (value >= 0 && value <= 255) {\n             stream_config.max_syn_queued = (uint8_t)value;\n@@ -5532,6 +5599,12 @@ int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n         StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n     }\n \n+    if ((tcph->th_flags & TH_URG) && StreamTcpInlineDropUrg()) {\n+        PacketDrop(p, ACTION_DROP, PKT_DROP_REASON_STREAM_URG);\n+        SCLogDebug(\"dropping urgent packet\");\n+        SCReturnInt(0);\n+    }\n+\n     /* If we are on IPS mode, and got a drop action triggered from\n      * the IP only module, or from a reassembled msg and/or from an\n      * applayer detection, then drop the rest of the packets of the\n@@ -5996,6 +6069,7 @@ TmEcode StreamTcpThreadInit(ThreadVars *tv, void *initdata, void **data)\n \n     stt->ra_ctx->counter_tcp_reass_data_normal_fail = StatsRegisterCounter(\"tcp.insert_data_normal_fail\", tv);\n     stt->ra_ctx->counter_tcp_reass_data_overlap_fail = StatsRegisterCounter(\"tcp.insert_data_overlap_fail\", tv);\n+    stt->ra_ctx->counter_tcp_urgent_oob = StatsRegisterCounter(\"tcp.urgent_oob_data\", tv);\n \n     SCLogDebug(\"StreamTcp thread specific ctx online at %p, reassembly ctx %p\",\n                 stt, stt->ra_ctx);"
        },
        {
          "filename": "src/stream-tcp.h",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -39,6 +39,16 @@\n #define STREAMTCP_INIT_FLAG_DROP_INVALID           BIT_U8(1)\n #define STREAMTCP_INIT_FLAG_BYPASS                 BIT_U8(2)\n #define STREAMTCP_INIT_FLAG_INLINE                 BIT_U8(3)\n+/** flag to drop packets with URG flag set */\n+#define STREAMTCP_INIT_FLAG_DROP_URG BIT_U8(4)\n+\n+enum TcpStreamUrgentHandling {\n+    TCP_STREAM_URGENT_INLINE, /**< treat as inline data */\n+#define TCP_STREAM_URGENT_DEFAULT TCP_STREAM_URGENT_INLINE\n+    TCP_STREAM_URGENT_DROP, /**< drop TCP packet with URG flag */\n+    TCP_STREAM_URGENT_OOB,  /**< treat 1 byte of URG data as OOB */\n+    TCP_STREAM_URGENT_GAP,  /**< treat 1 byte of URG data as GAP */\n+};\n \n /*global flow data*/\n typedef struct TcpStreamCnf_ {\n@@ -70,6 +80,8 @@ typedef struct TcpStreamCnf_ {\n     enum ExceptionPolicy ssn_memcap_policy;\n     enum ExceptionPolicy reassembly_memcap_policy;\n     enum ExceptionPolicy midstream_policy;\n+    enum TcpStreamUrgentHandling urgent_policy;\n+    enum TcpStreamUrgentHandling urgent_oob_limit_policy;\n \n     /* default to \"LINUX\" timestamp behavior if true*/\n     bool liberal_timestamps;"
        },
        {
          "filename": "suricata.yaml.in",
          "status": "modified",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -1615,6 +1615,9 @@ stream:\n   #midstream-policy: ignore\n   inline: auto                  # auto will use inline mode in IPS mode, yes or no set it statically\n   reassembly:\n+    urgent:\n+      policy: oob              # drop, inline, oob (1 byte, see RFC 6093, 3.1), gap\n+      oob-limit-policy: drop\n     memcap: 256 MiB\n     #memcap-policy: ignore\n     depth: 1 MiB                # reassemble 1 MiB into a stream"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 4,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "637708acb476cdae526b870e4301e22197da1869",
            "date": "2025-01-13T12:39:21Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "a92212d6e504b535c63ce8d234bf4804c7b8dcca",
            "date": "2025-01-10T16:27:55Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "eab212b0be760daa2689bcb6e2d05c12fd708682",
            "date": "2025-01-10T15:57:51Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "ae1a4ef757583e4307d3322130f893db4b716a59",
            "date": "2024-11-11T06:26:11Z",
            "author_login": "catenacyber"
          },
          {
            "sha": "e6be049c5dc2859a833fc21321bc7bfd15be2904",
            "date": "2024-11-11T06:21:03Z",
            "author_login": "catenacyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
    "cwe_id": "CWE-437",
    "description": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to 7.0.8, TCP streams with TCP urgent data (out of band data) can lead to Suricata analyzing data differently than the applications at the TCP endpoints, leading to possible evasions. Suricata 7.0.8 includes options to allow users to configure how to handle TCP urgent data. In IPS mode, you can use a rule such as drop tcp any any -> any any (sid:1; tcp.flags:U*;) to drop all the packets with urgent flag set.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2025-01-06T18:15:23.130",
    "last_modified": "2025-01-06T18:15:23.130",
    "fix_date": "2024-10-10T14:12:09Z"
  },
  "references": [
    {
      "url": "https://github.com/OISF/suricata/commit/6882bcb3e51bd3cf509fb6569cc30f48d7bb53d7",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OISF/suricata/commit/779f9d8ba35c3f9b5abfa327d3a4209861bd2eb8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/OISF/suricata/security/advisories/GHSA-69wr-vhwg-84h2",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://redmine.openinfosecfoundation.org/issues/7411",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.978947",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "suricata",
    "owner": "OISF",
    "created_at": "2012-08-14T08:30:06Z",
    "updated_at": "2025-01-14T12:53:46Z",
    "pushed_at": "2025-01-14T06:40:06Z",
    "size": 74648,
    "stars": 4847,
    "forks": 1483,
    "open_issues": 74,
    "watchers": 4847,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "main-7.0.x",
      "master",
      "master-3.2.x",
      "master-4.0.x",
      "master-4.1.x",
      "master-5.0.x",
      "master-6.0.x"
    ],
    "languages": {
      "C": 13993560,
      "Rust": 3470702,
      "M4": 118208,
      "Python": 103285,
      "Shell": 46705,
      "Makefile": 45461,
      "Perl": 36748,
      "SmPL": 5503,
      "Lua": 1583,
      "Dockerfile": 1044
    },
    "commit_activity": {
      "total_commits_last_year": 1056,
      "avg_commits_per_week": 20.307692307692307,
      "days_active_last_year": 254
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": false,
      "allow_forking": true,
      "is_template": false,
      "license": "gpl-2.0"
    },
    "collected_at": "2025-01-14T14:41:46.043023"
  }
}