{
  "cve_id": "CVE-2024-55949",
  "github_data": {
    "repository": "minio/minio",
    "fix_commit": "580d9db85e04f1b63cc2909af50f0ed08afa965f",
    "related_commits": [
      "580d9db85e04f1b63cc2909af50f0ed08afa965f",
      "f246c9053f9603e610d98439799bdd2a6b293427"
    ],
    "patch_url": "https://github.com/minio/minio/commit/580d9db85e04f1b63cc2909af50f0ed08afa965f.patch",
    "fix_commit_details": {
      "sha": "580d9db85e04f1b63cc2909af50f0ed08afa965f",
      "commit_date": "2022-06-23T16:25:15Z",
      "author": {
        "login": "poornas",
        "type": "User",
        "stats": {
          "total_commits": 518,
          "average_weekly_commits": 0.9700374531835206,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 260
        }
      },
      "commit_message": {
        "title": "Add APIs to import/export IAM data (#15014)",
        "length": 43,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 701,
        "additions": 696,
        "deletions": 5
      },
      "files": [
        {
          "filename": "cmd/admin-bucket-handlers.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -804,7 +804,7 @@ func (a adminAPIHandlers) ImportBucketMetadataHandler(w http.ResponseWriter, r *\n \tfor _, file := range zr.File {\n \t\treader, err := file.Open()\n \t\tif err != nil {\n-\t\t\twriteErrorResponse(ctx, w, importError(ctx, err, file.Name, bucket), r.URL)\n+\t\t\twriteErrorResponse(ctx, w, importError(ctx, err, file.Name, \"\"), r.URL)\n \t\t\treturn\n \t\t}\n \t\tsz := file.FileInfo().Size()"
        },
        {
          "filename": "cmd/admin-handler-utils.go",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -240,3 +240,11 @@ func importError(ctx context.Context, err error, fname, entity string) APIError\n \t}\n \treturn toAPIError(ctx, fmt.Errorf(\"error importing %s from %s with: %w\", entity, fname, err))\n }\n+\n+// wraps import error for more context\n+func importErrorWithAPIErr(ctx context.Context, apiErr APIErrorCode, err error, fname, entity string) APIError {\n+\tif entity == \"\" {\n+\t\treturn errorCodes.ToAPIErrWithErr(apiErr, fmt.Errorf(\"error importing %s with: %w\", fname, err))\n+\t}\n+\treturn errorCodes.ToAPIErrWithErr(apiErr, fmt.Errorf(\"error importing %s from %s with: %w\", entity, fname, err))\n+}"
        },
        {
          "filename": "cmd/admin-handlers-users.go",
          "status": "modified",
          "additions": 678,
          "deletions": 1,
          "patch": "@@ -24,9 +24,12 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net/http\"\n+\t\"os\"\n \t\"sort\"\n+\t\"time\"\n \n \t\"github.com/gorilla/mux\"\n+\t\"github.com/klauspost/compress/zip\"\n \t\"github.com/minio/madmin-go\"\n \t\"github.com/minio/minio/internal/auth\"\n \t\"github.com/minio/minio/internal/config/dns\"\n@@ -629,7 +632,7 @@ func (a adminAPIHandlers) AddServiceAccount(w http.ResponseWriter, r *http.Reque\n \t\t\topts.claims[k] = v\n \t\t}\n \t} else {\n-\t\t// Need permission if we are creating a service acccount for a\n+\t\t// Need permission if we are creating a service account for a\n \t\t// user <> to the request sender\n \t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n \t\t\tAccountName:     requestorUser,\n@@ -1512,3 +1515,677 @@ func (a adminAPIHandlers) SetPolicyForUserOrGroup(w http.ResponseWriter, r *http\n \t\treturn\n \t}\n }\n+\n+const (\n+\tallPoliciesFile            = \"policies.json\"\n+\tallUsersFile               = \"users.json\"\n+\tallGroupsFile              = \"groups.json\"\n+\tallSvcAcctsFile            = \"svcaccts.json\"\n+\tuserPolicyMappingsFile     = \"user_mappings.json\"\n+\tgroupPolicyMappingsFile    = \"group_mappings.json\"\n+\tstsUserPolicyMappingsFile  = \"stsuser_mappings.json\"\n+\tstsGroupPolicyMappingsFile = \"stsgroup_mappings.json\"\n+)\n+\n+// ExportIAMHandler - exports all iam info as a zipped file\n+func (a adminAPIHandlers) ExportIAM(w http.ResponseWriter, r *http.Request) {\n+\tctx := newContext(r, w, \"ExportIAM\")\n+\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n+\n+\t// Get current object layer instance.\n+\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ExportIAMAction)\n+\tif objectAPI == nil {\n+\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n+\t\treturn\n+\t}\n+\t// Initialize a zip writer which will provide a zipped content\n+\t// of bucket metadata\n+\tzipWriter := zip.NewWriter(w)\n+\tdefer zipWriter.Close()\n+\trawDataFn := func(r io.Reader, filename string, sz int) error {\n+\t\theader, zerr := zip.FileInfoHeader(dummyFileInfo{\n+\t\t\tname:    filename,\n+\t\t\tsize:    int64(sz),\n+\t\t\tmode:    0o600,\n+\t\t\tmodTime: time.Now(),\n+\t\t\tisDir:   false,\n+\t\t\tsys:     nil,\n+\t\t})\n+\t\tif zerr != nil {\n+\t\t\tlogger.LogIf(ctx, zerr)\n+\t\t\treturn nil\n+\t\t}\n+\t\theader.Method = zip.Deflate\n+\t\tzwriter, zerr := zipWriter.CreateHeader(header)\n+\t\tif zerr != nil {\n+\t\t\tlogger.LogIf(ctx, zerr)\n+\t\t\treturn nil\n+\t\t}\n+\t\tif _, err := io.Copy(zwriter, r); err != nil {\n+\t\t\tlogger.LogIf(ctx, err)\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tiamFiles := []string{\n+\t\tallPoliciesFile,\n+\t\tallUsersFile,\n+\t\tallGroupsFile,\n+\t\tallSvcAcctsFile,\n+\t\tuserPolicyMappingsFile,\n+\t\tgroupPolicyMappingsFile,\n+\t\tstsUserPolicyMappingsFile,\n+\t\tstsGroupPolicyMappingsFile,\n+\t}\n+\tfor _, iamFile := range iamFiles {\n+\t\tswitch iamFile {\n+\t\tcase allPoliciesFile:\n+\t\t\tallPolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n+\t\t\tif err != nil {\n+\t\t\t\tlogger.LogIf(ctx, err)\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tpoliciesData, err := json.Marshal(allPolicies)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = rawDataFn(bytes.NewReader(policiesData), iamFile, len(policiesData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase allUsersFile:\n+\t\t\tuserCreds := make(map[string]auth.Credentials)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadUsers(ctx, regUser, userCreds)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tuserAccounts := make(map[string]madmin.AddOrUpdateUserReq)\n+\t\t\tfor u, cred := range userCreds {\n+\t\t\t\tstatus := madmin.AccountDisabled\n+\t\t\t\tif cred.IsValid() {\n+\t\t\t\t\tstatus = madmin.AccountEnabled\n+\t\t\t\t}\n+\t\t\t\tuserAccounts[u] = madmin.AddOrUpdateUserReq{\n+\t\t\t\t\tSecretKey: cred.SecretKey,\n+\t\t\t\t\tStatus:    status,\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tuserData, err := json.Marshal(userAccounts)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err = rawDataFn(bytes.NewReader(userData), iamFile, len(userData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase allGroupsFile:\n+\t\t\tgroups := make(map[string]GroupInfo)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadGroups(ctx, groups)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgroupData, err := json.Marshal(groups)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err = rawDataFn(bytes.NewReader(groupData), iamFile, len(groupData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase allSvcAcctsFile:\n+\t\t\tserviceAccounts := make(map[string]auth.Credentials)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadUsers(ctx, svcUser, serviceAccounts)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tsvcAccts := make(map[string]madmin.SRSvcAccCreate)\n+\t\t\tfor user, acc := range serviceAccounts {\n+\t\t\t\tif user == siteReplicatorSvcAcc {\n+\t\t\t\t\t// skip the site replicate svc account as it should be created automatically if\n+\t\t\t\t\t// site replication is enabled.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tclaims, err := globalIAMSys.GetClaimsForSvcAcc(ctx, acc.AccessKey)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\t_, policy, err := globalIAMSys.GetServiceAccount(ctx, acc.AccessKey)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tvar policyJSON []byte\n+\t\t\t\tif policy != nil {\n+\t\t\t\t\tpolicyJSON, err = json.Marshal(policy)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tsvcAccts[user] = madmin.SRSvcAccCreate{\n+\t\t\t\t\tParent:        acc.ParentUser,\n+\t\t\t\t\tAccessKey:     user,\n+\t\t\t\t\tSecretKey:     acc.SecretKey,\n+\t\t\t\t\tGroups:        acc.Groups,\n+\t\t\t\t\tClaims:        claims,\n+\t\t\t\t\tSessionPolicy: json.RawMessage(policyJSON),\n+\t\t\t\t\tStatus:        acc.Status,\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tsvcAccData, err := json.Marshal(svcAccts)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err = rawDataFn(bytes.NewReader(svcAccData), iamFile, len(svcAccData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase userPolicyMappingsFile:\n+\t\t\tuserPolicyMap := make(map[string]MappedPolicy)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, regUser, false, userPolicyMap)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tuserPolData, err := json.Marshal(userPolicyMap)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err = rawDataFn(bytes.NewReader(userPolData), iamFile, len(userPolData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase groupPolicyMappingsFile:\n+\t\t\tgroupPolicyMap := make(map[string]MappedPolicy)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, regUser, true, groupPolicyMap)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgrpPolData, err := json.Marshal(groupPolicyMap)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err = rawDataFn(bytes.NewReader(grpPolData), iamFile, len(grpPolData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase stsUserPolicyMappingsFile:\n+\t\t\tuserPolicyMap := make(map[string]MappedPolicy)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, stsUser, false, userPolicyMap)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tuserPolData, err := json.Marshal(userPolicyMap)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = rawDataFn(bytes.NewReader(userPolData), iamFile, len(userPolData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase stsGroupPolicyMappingsFile:\n+\t\t\tgroupPolicyMap := make(map[string]MappedPolicy)\n+\t\t\tglobalIAMSys.store.rlock()\n+\t\t\terr := globalIAMSys.store.loadMappedPolicies(ctx, stsUser, true, groupPolicyMap)\n+\t\t\tglobalIAMSys.store.runlock()\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgrpPolData, err := json.Marshal(groupPolicyMap)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = rawDataFn(bytes.NewReader(grpPolData), iamFile, len(grpPolData)); err != nil {\n+\t\t\t\twriteErrorResponse(ctx, w, exportError(ctx, err, iamFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// ImportIAM - imports all IAM info into MinIO\n+func (a adminAPIHandlers) ImportIAM(w http.ResponseWriter, r *http.Request) {\n+\tctx := newContext(r, w, \"ImportIAM\")\n+\n+\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n+\n+\t// Get current object layer instance.\n+\tobjectAPI := newObjectLayerFn()\n+\tif objectAPI == nil || globalNotificationSys == nil {\n+\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n+\t\treturn\n+\t}\n+\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n+\tif s3Err != ErrNone {\n+\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n+\t\treturn\n+\t}\n+\tdata, err := ioutil.ReadAll(r.Body)\n+\tif err != nil {\n+\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n+\t\treturn\n+\t}\n+\treader := bytes.NewReader(data)\n+\tzr, err := zip.NewReader(reader, int64(len(data)))\n+\tif err != nil {\n+\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n+\t\treturn\n+\t}\n+\t// import policies first\n+\t{\n+\t\tf, err := zr.Open(allPoliciesFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allPoliciesFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar allPolicies map[string]iampolicy.Policy\n+\t\t\tdata, err = ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allPoliciesFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = json.Unmarshal(data, &allPolicies)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allPoliciesFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor policyName, policy := range allPolicies {\n+\t\t\t\tif policy.IsEmpty() {\n+\t\t\t\t\terr = globalIAMSys.DeletePolicy(ctx, policyName, true)\n+\t\t\t\t} else {\n+\t\t\t\t\terr = globalIAMSys.SetPolicy(ctx, policyName, policy)\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allPoliciesFile, policyName), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import users\n+\t{\n+\t\tf, err := zr.Open(allUsersFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allUsersFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar userAccts map[string]madmin.AddOrUpdateUserReq\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allUsersFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\terr = json.Unmarshal(data, &userAccts)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allUsersFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor accessKey, ureq := range userAccts {\n+\t\t\t\t// Not allowed to add a user with same access key as root credential\n+\t\t\t\tif owner && accessKey == cred.AccessKey {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tuserCred, exists := globalIAMSys.GetUser(ctx, accessKey)\n+\t\t\t\tif exists && (userCred.IsTemp() || userCred.IsServiceAccount()) {\n+\t\t\t\t\t// Updating STS credential is not allowed, and this API does not\n+\t\t\t\t\t// support updating service accounts.\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n+\t\t\t\t\t// Incoming access key matches parent user then we should\n+\t\t\t\t\t// reject password change requests.\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAddUserInvalidArgument, err, allUsersFile, accessKey), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if accessKey has beginning and end space characters, this only applies to new users.\n+\t\t\t\tif !exists && hasSpaceBE(accessKey) {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminResourceInvalidArgument, err, allUsersFile, accessKey), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t\tcheckDenyOnly := false\n+\t\t\t\tif accessKey == cred.AccessKey {\n+\t\t\t\t\t// Check that there is no explicit deny - otherwise it's allowed\n+\t\t\t\t\t// to change one's own password.\n+\t\t\t\t\tcheckDenyOnly = true\n+\t\t\t\t}\n+\n+\t\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n+\t\t\t\t\tAccountName:     cred.AccessKey,\n+\t\t\t\t\tGroups:          cred.Groups,\n+\t\t\t\t\tAction:          iampolicy.CreateUserAdminAction,\n+\t\t\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n+\t\t\t\t\tIsOwner:         owner,\n+\t\t\t\t\tClaims:          claims,\n+\t\t\t\t\tDenyOnly:        checkDenyOnly,\n+\t\t\t\t}) {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAccessDenied, err, allUsersFile, accessKey), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif err = globalIAMSys.CreateUser(ctx, accessKey, ureq); err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, toAdminAPIErrCode(ctx, err), err, allUsersFile, accessKey), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import groups\n+\t{\n+\t\tf, err := zr.Open(allGroupsFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allGroupsFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar grpInfos map[string]GroupInfo\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allGroupsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = json.Unmarshal(data, &grpInfos); err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allGroupsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor group, grpInfo := range grpInfos {\n+\t\t\t\t// Check if group already exists\n+\t\t\t\tif _, gerr := globalIAMSys.GetGroupDescription(group); gerr != nil {\n+\t\t\t\t\t// If group does not exist, then check if the group has beginning and end space characters\n+\t\t\t\t\t// we will reject such group names.\n+\t\t\t\t\tif errors.Is(gerr, errNoSuchGroup) && hasSpaceBE(group) {\n+\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminResourceInvalidArgument, err, allGroupsFile, group), r.URL)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif gerr := globalIAMSys.AddUsersToGroup(ctx, group, grpInfo.Members); gerr != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allGroupsFile, group), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import service accounts\n+\t{\n+\t\tf, err := zr.Open(allSvcAcctsFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allSvcAcctsFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar serviceAcctReqs map[string]madmin.SRSvcAccCreate\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, allSvcAcctsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = json.Unmarshal(data, &serviceAcctReqs); err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, allSvcAcctsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor user, svcAcctReq := range serviceAcctReqs {\n+\t\t\t\tvar sp *iampolicy.Policy\n+\t\t\t\tvar err error\n+\t\t\t\tif len(svcAcctReq.SessionPolicy) > 0 {\n+\t\t\t\t\tsp, err = iampolicy.ParseConfig(bytes.NewReader(svcAcctReq.SessionPolicy))\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// service account access key cannot have space characters beginning and end of the string.\n+\t\t\t\tif hasSpaceBE(svcAcctReq.AccessKey) {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminResourceInvalidArgument), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n+\t\t\t\t\tAccountName:     svcAcctReq.AccessKey,\n+\t\t\t\t\tGroups:          svcAcctReq.Groups,\n+\t\t\t\t\tAction:          iampolicy.CreateServiceAccountAdminAction,\n+\t\t\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n+\t\t\t\t\tIsOwner:         owner,\n+\t\t\t\t\tClaims:          claims,\n+\t\t\t\t}) {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAccessDenied, err, allSvcAcctsFile, user), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tupdateReq := true\n+\t\t\t\t_, _, err = globalIAMSys.GetServiceAccount(ctx, svcAcctReq.AccessKey)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif !errors.Is(err, errNoSuchServiceAccount) {\n+\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tupdateReq = false\n+\t\t\t\t}\n+\t\t\t\tif updateReq {\n+\t\t\t\t\topts := updateServiceAccountOpts{\n+\t\t\t\t\t\tsecretKey:     svcAcctReq.SecretKey,\n+\t\t\t\t\t\tstatus:        svcAcctReq.Status,\n+\t\t\t\t\t\tsessionPolicy: sp,\n+\t\t\t\t\t}\n+\t\t\t\t\terr = globalIAMSys.UpdateServiceAccount(ctx, svcAcctReq.AccessKey, opts)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\topts := newServiceAccountOpts{\n+\t\t\t\t\taccessKey:     user,\n+\t\t\t\t\tsecretKey:     svcAcctReq.SecretKey,\n+\t\t\t\t\tsessionPolicy: sp,\n+\t\t\t\t\tclaims:        svcAcctReq.Claims,\n+\t\t\t\t}\n+\n+\t\t\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n+\t\t\t\t// query their groups:\n+\t\t\t\tif globalLDAPConfig.Enabled {\n+\t\t\t\t\topts.claims[ldapUserN] = svcAcctReq.AccessKey // simple username\n+\t\t\t\t\ttargetUser, _, err := globalLDAPConfig.LookupUserDN(svcAcctReq.AccessKey)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\topts.claims[ldapUser] = targetUser // username DN\n+\t\t\t\t}\n+\n+\t\t\t\tif _, err = globalIAMSys.NewServiceAccount(ctx, svcAcctReq.Parent, svcAcctReq.Groups, opts); err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, allSvcAcctsFile, user), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import user policy mappings\n+\t{\n+\t\tf, err := zr.Open(userPolicyMappingsFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, userPolicyMappingsFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar userPolicyMap map[string]MappedPolicy\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, userPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = json.Unmarshal(data, &userPolicyMap); err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, userPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor u, pm := range userPolicyMap {\n+\t\t\t\t// disallow setting policy mapping if user is a temporary user\n+\t\t\t\tok, _, err := globalIAMSys.IsTempUser(u)\n+\t\t\t\tif err != nil && err != errNoSuchUser {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, userPolicyMappingsFile, u), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif ok {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, errIAMActionNotAllowed, userPolicyMappingsFile, u), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif err := globalIAMSys.PolicyDBSet(ctx, u, pm.Policies, false); err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, userPolicyMappingsFile, u), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import group policy mappings\n+\t{\n+\t\tf, err := zr.Open(groupPolicyMappingsFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, groupPolicyMappingsFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar grpPolicyMap map[string]MappedPolicy\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, groupPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = json.Unmarshal(data, &grpPolicyMap); err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, groupPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor g, pm := range grpPolicyMap {\n+\t\t\t\tif err := globalIAMSys.PolicyDBSet(ctx, g, pm.Policies, true); err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, groupPolicyMappingsFile, g), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import sts user policy mappings\n+\t{\n+\t\tf, err := zr.Open(stsUserPolicyMappingsFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar userPolicyMap map[string]MappedPolicy\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = json.Unmarshal(data, &userPolicyMap); err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, stsUserPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor u, pm := range userPolicyMap {\n+\t\t\t\t// disallow setting policy mapping if user is a temporary user\n+\t\t\t\tok, _, err := globalIAMSys.IsTempUser(u)\n+\t\t\t\tif err != nil && err != errNoSuchUser {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsUserPolicyMappingsFile, u), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif ok {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, errIAMActionNotAllowed, stsUserPolicyMappingsFile, u), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif err := globalIAMSys.PolicyDBSet(ctx, u, pm.Policies, false); err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsUserPolicyMappingsFile, u), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// import sts group policy mappings\n+\t{\n+\t\tf, err := zr.Open(stsGroupPolicyMappingsFile)\n+\t\tswitch {\n+\t\tcase errors.Is(err, os.ErrNotExist):\n+\t\tcase err != nil:\n+\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\tdefer f.Close()\n+\t\t\tvar grpPolicyMap map[string]MappedPolicy\n+\t\t\tdata, err := ioutil.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrInvalidRequest, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err = json.Unmarshal(data, &grpPolicyMap); err != nil {\n+\t\t\t\twriteErrorResponseJSON(ctx, w, importErrorWithAPIErr(ctx, ErrAdminConfigBadJSON, err, stsGroupPolicyMappingsFile, \"\"), r.URL)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfor g, pm := range grpPolicyMap {\n+\t\t\t\tif err := globalIAMSys.PolicyDBSet(ctx, g, pm.Policies, true); err != nil {\n+\t\t\t\t\twriteErrorResponseJSON(ctx, w, importError(ctx, err, stsGroupPolicyMappingsFile, g), r.URL)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"
        },
        {
          "filename": "cmd/admin-router.go",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -170,6 +170,12 @@ func registerAdminRouter(router *mux.Router, enableConfigOps bool) {\n \t\t// Set Group Status\n \t\tadminRouter.Methods(http.MethodPut).Path(adminVersion+\"/set-group-status\").HandlerFunc(gz(httpTraceHdrs(adminAPI.SetGroupStatus))).Queries(\"group\", \"{group:.*}\").Queries(\"status\", \"{status:.*}\")\n \n+\t\t// Export IAM info to zipped file\n+\t\tadminRouter.Methods(http.MethodGet).Path(adminVersion + \"/export-iam\").HandlerFunc(httpTraceHdrs(adminAPI.ExportIAM))\n+\n+\t\t// Import IAM info\n+\t\tadminRouter.Methods(http.MethodPut).Path(adminVersion + \"/import-iam\").HandlerFunc(httpTraceHdrs(adminAPI.ImportIAM))\n+\n \t\t// GetBucketQuotaConfig\n \t\tadminRouter.Methods(http.MethodGet).Path(adminVersion+\"/get-bucket-quota\").HandlerFunc(\n \t\t\tgz(httpTraceHdrs(adminAPI.GetBucketQuotaConfigHandler))).Queries(\"bucket\", \"{bucket:.*}\")"
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -50,7 +50,7 @@ require (\n \tgithub.com/minio/kes v0.19.2\n \tgithub.com/minio/madmin-go v1.3.14\n \tgithub.com/minio/minio-go/v7 v7.0.29\n-\tgithub.com/minio/pkg v1.1.25\n+\tgithub.com/minio/pkg v1.1.26\n \tgithub.com/minio/selfupdate v0.4.0\n \tgithub.com/minio/sha256-simd v1.0.0\n \tgithub.com/minio/simdjson-go v0.4.2"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -636,8 +636,8 @@ github.com/minio/minio-go/v7 v7.0.23/go.mod h1:ei5JjmxwHaMrgsMrn4U/+Nmg+d8MKS1U2\n github.com/minio/minio-go/v7 v7.0.29 h1:7md6lIq1s6zPzUiDRX1BVLHolA4pDM8RMQqIszaJbY0=\n github.com/minio/minio-go/v7 v7.0.29/go.mod h1:x81+AX5gHSfCSqw7jxRKHvxUXMlE5uKX0Vb75Xk5yYg=\n github.com/minio/pkg v1.1.20/go.mod h1:Xo7LQshlxGa9shKwJ7NzQbgW4s8T/Wc1cOStR/eUiMY=\n-github.com/minio/pkg v1.1.25 h1:QYLzmTFUV5D3bY9qXKzDj7eW2C+HOPcdtIZft9q2Azo=\n-github.com/minio/pkg v1.1.25/go.mod h1:z9PfmEI804KFkF6eY4LoGe8IDVvTCsYGVuaf58Dr0WI=\n+github.com/minio/pkg v1.1.26 h1:a8x4sHNBxCiHEkxZ/0EBTLqvV3nMtM2G/A6lXNfXN3U=\n+github.com/minio/pkg v1.1.26/go.mod h1:z9PfmEI804KFkF6eY4LoGe8IDVvTCsYGVuaf58Dr0WI=\n github.com/minio/selfupdate v0.4.0 h1:A7t07pN4Ch1tBTIRStW0KhUVyykz+2muCqFsITQeEW8=\n github.com/minio/selfupdate v0.4.0/go.mod h1:mcDkzMgq8PRcpCRJo/NlPY7U45O5dfYl2Y0Rg7IustY=\n github.com/minio/sha256-simd v0.1.1/go.mod h1:B5e1o+1/KgNmWrSQK08Y6Z1Vb5pwIktudl0J58iy0KM="
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "00b2ef29323e786a8958bf0bedced133cb06245f",
            "date": "2025-01-08T11:09:24Z",
            "author_login": "vadmeste"
          },
          {
            "sha": "4536ecfaa4d81dd3f648616094a4936162089db8",
            "date": "2025-01-06T15:51:54Z",
            "author_login": "klauspost"
          },
          {
            "sha": "43a74029685512ce9b1b76c053d48b43fc8d64fc",
            "date": "2025-01-03T05:34:47Z",
            "author_login": "harshavardhana"
          },
          {
            "sha": "330dca9a354cdf445d71979170bbe3d27971d127",
            "date": "2024-12-21T04:24:45Z",
            "author_login": "allanrogerr"
          },
          {
            "sha": "ddd137d31769185e6de4f27dfaba8de6498bb1ea",
            "date": "2024-12-19T18:21:46Z",
            "author_login": "klauspost"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-269",
    "description": "MinIO is a high-performance, S3 compatible object store, open sourced under GNU AGPLv3 license. Minio is subject to a privilege escalation in IAM import API, all users are impacted since MinIO commit `580d9db85e04f1b63cc2909af50f0ed08afa965f`. This issue has been addressed in commit `f246c9053f9603e610d98439799bdd2a6b293427` which is included in RELEASE.2024-12-13T22-19-12Z. There are no workarounds possible, all users are advised to upgrade immediately.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-12-16T20:15:13.683",
    "last_modified": "2024-12-16T20:15:13.683",
    "fix_date": "2022-06-23T16:25:15Z"
  },
  "references": [
    {
      "url": "https://github.com/minio/minio/commit/580d9db85e04f1b63cc2909af50f0ed08afa965f",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/minio/minio/commit/f246c9053f9603e610d98439799bdd2a6b293427",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/minio/minio/pull/20756",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/minio/minio/security/advisories/GHSA-cwq8-g58r-32hg",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.871224",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "minio",
    "owner": "minio",
    "created_at": "2015-01-14T19:23:58Z",
    "updated_at": "2025-01-14T10:52:24Z",
    "pushed_at": "2025-01-08T11:09:25Z",
    "size": 131770,
    "stars": 49440,
    "forks": 5609,
    "open_issues": 33,
    "watchers": 49440,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release"
    ],
    "languages": {
      "Go": 8661217,
      "Shell": 72203,
      "Makefile": 11634,
      "Mustache": 6628,
      "Smarty": 872,
      "Dockerfile": 229
    },
    "commit_activity": {
      "total_commits_last_year": 949,
      "avg_commits_per_week": 18.25,
      "days_active_last_year": 271
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "agpl-3.0"
    },
    "collected_at": "2025-01-14T12:53:58.932687"
  }
}