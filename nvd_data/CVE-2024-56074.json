{
  "cve_id": "CVE-2024-56074",
  "github_data": {
    "repository": "cyclotruc/gitingest",
    "fix_commit": "9996a06a94450497c1abb35997f5e6cbc9b571ff",
    "related_commits": [
      "9996a06a94450497c1abb35997f5e6cbc9b571ff"
    ],
    "patch_url": "https://github.com/cyclotruc/gitingest/commit/9996a06a94450497c1abb35997f5e6cbc9b571ff.patch",
    "fix_commit_details": {
      "sha": "9996a06a94450497c1abb35997f5e6cbc9b571ff",
      "commit_date": "2024-12-12T18:39:29Z",
      "author": {
        "login": "nollium",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fix file management and permissions issues (#23)",
        "length": 48,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 122,
        "additions": 118,
        "deletions": 4
      },
      "files": [
        {
          "filename": "Dockerfile",
          "status": "modified",
          "additions": 9,
          "deletions": 0,
          "patch": "@@ -2,9 +2,18 @@ FROM python:3.12\n \n WORKDIR /app\n \n+# Create a non-root user\n+RUN useradd -m -u 1000 appuser\n+\n COPY src/ ./\n COPY requirements.txt ./\n \n RUN pip install -r requirements.txt\n \n+# Change ownership of the application files\n+RUN chown -R appuser:appuser /app\n+\n+# Switch to non-root user\n+USER appuser\n+\n CMD [\"uvicorn\", \"main:app\", \"--reload\"]"
        },
        {
          "filename": "requirements.txt",
          "status": "modified",
          "additions": 2,
          "deletions": 1,
          "patch": "@@ -1,4 +1,5 @@\n fastapi[standard]\n uvicorn\n fastapi-analytics\n-slowapi\n\\ No newline at end of file\n+slowapi\n+tokencost\n\\ No newline at end of file"
        },
        {
          "filename": "src/ingest.py",
          "status": "modified",
          "additions": 107,
          "deletions": 3,
          "patch": "@@ -4,6 +4,10 @@\n from tokencost import count_string_tokens\n from typing import Dict, List, Union\n \n+MAX_DIRECTORY_DEPTH = 10  # Maximum depth of directory traversal\n+MAX_FILES = 10000  # Maximum number of files to process\n+MAX_TOTAL_SIZE_BYTES = 100 * 1024 * 1024  # 100MB total size limit\n+\n def should_ignore(path: str, base_path: str, ignore_patterns: List[str]) -> bool:\n     \"\"\"Checks if a file or directory should be ignored based on patterns.\"\"\"\n     name = os.path.basename(path)\n@@ -15,6 +19,19 @@ def should_ignore(path: str, base_path: str, ignore_patterns: List[str]) -> bool\n             return True\n     return False\n \n+def is_safe_symlink(symlink_path: str, base_path: str) -> bool:\n+    \"\"\"Check if a symlink points to a location within the base directory.\"\"\"\n+    try:\n+        # Get the absolute path of the symlink target\n+        target_path = os.path.realpath(symlink_path)\n+        # Get the absolute path of the base directory\n+        base_path = os.path.realpath(base_path)\n+        # Check if the target path starts with the base path\n+        return os.path.commonpath([target_path]) == os.path.commonpath([target_path, base_path])\n+    except (OSError, ValueError):\n+        # If there's any error resolving the paths, consider it unsafe\n+        return False\n+\n def is_text_file(file_path: str) -> bool:\n     \"\"\"Determines if a file is likely a text file based on its content.\"\"\"\n     try:\n@@ -32,8 +49,34 @@ def read_file_content(file_path: str) -> str:\n     except Exception as e:\n         return f\"Error reading file: {str(e)}\"\n     \n-def scan_directory(path: str, ignore_patterns: List[str], base_path: str) -> Dict:\n-    \"\"\"Recursively analyzes a directory and its contents.\"\"\"\n+def scan_directory(path: str, ignore_patterns: List[str], base_path: str, seen_paths: set = None, depth: int = 0, stats: Dict = None) -> Dict:\n+    \"\"\"Recursively analyzes a directory and its contents with safety limits.\"\"\"\n+    if seen_paths is None:\n+        seen_paths = set()\n+    if stats is None:\n+        stats = {\"total_files\": 0, \"total_size\": 0}\n+        \n+    # Check depth limit\n+    if depth > MAX_DIRECTORY_DEPTH:\n+        print(f\"Skipping deep directory: {path} (max depth {MAX_DIRECTORY_DEPTH} reached)\")\n+        return None\n+        \n+    # Check total files limit\n+    if stats[\"total_files\"] >= MAX_FILES:\n+        print(f\"Skipping further processing: maximum file limit ({MAX_FILES}) reached\")\n+        return None\n+        \n+    # Check total size limit\n+    if stats[\"total_size\"] >= MAX_TOTAL_SIZE_BYTES:\n+        print(f\"Skipping further processing: maximum total size ({MAX_TOTAL_SIZE_BYTES/1024/1024:.1f}MB) reached\")\n+        return None\n+        \n+    real_path = os.path.realpath(path)\n+    if real_path in seen_paths:\n+        print(f\"Skipping already visited path: {path}\")\n+        return None\n+    seen_paths.add(real_path)\n+    \n     result = {\n         \"name\": os.path.basename(path),\n         \"type\": \"directory\",\n@@ -51,8 +94,69 @@ def scan_directory(path: str, ignore_patterns: List[str], base_path: str) -> Dic\n             if should_ignore(item_path, base_path, ignore_patterns):\n                 continue\n \n+            # Handle symlinks\n+            if os.path.islink(item_path):\n+                if not is_safe_symlink(item_path, base_path):\n+                    print(f\"Skipping symlink that points outside base directory: {item_path}\")\n+                    continue\n+                real_path = os.path.realpath(item_path)\n+                if real_path in seen_paths:\n+                    print(f\"Skipping already visited symlink target: {item_path}\")\n+                    continue\n+                \n+                if os.path.isfile(real_path):\n+                    file_size = os.path.getsize(real_path)\n+                    # Check if adding this file would exceed total size limit\n+                    if stats[\"total_size\"] + file_size > MAX_TOTAL_SIZE_BYTES:\n+                        print(f\"Skipping file {item_path}: would exceed total size limit\")\n+                        continue\n+                        \n+                    stats[\"total_files\"] += 1\n+                    stats[\"total_size\"] += file_size\n+                    \n+                    if stats[\"total_files\"] > MAX_FILES:\n+                        print(f\"Maximum file limit ({MAX_FILES}) reached\")\n+                        return result\n+                        \n+                    is_text = is_text_file(real_path)\n+                    content = read_file_content(real_path) if is_text else \"[Non-text file]\"\n+                    \n+                    child = {\n+                        \"name\": item,\n+                        \"type\": \"file\",\n+                        \"size\": file_size,\n+                        \"content\": content,\n+                        \"path\": item_path\n+                    }\n+                    result[\"children\"].append(child)\n+                    result[\"size\"] += file_size\n+                    result[\"file_count\"] += 1\n+                    \n+                elif os.path.isdir(real_path):\n+                    subdir = scan_directory(real_path, ignore_patterns, base_path, seen_paths, depth + 1, stats)\n+                    if subdir:\n+                        subdir[\"name\"] = item\n+                        subdir[\"path\"] = item_path\n+                        result[\"children\"].append(subdir)\n+                        result[\"size\"] += subdir[\"size\"]\n+                        result[\"file_count\"] += subdir[\"file_count\"]\n+                        result[\"dir_count\"] += 1 + subdir[\"dir_count\"]\n+                continue\n+\n             if os.path.isfile(item_path):\n                 file_size = os.path.getsize(item_path)\n+                # Check if adding this file would exceed total size limit\n+                if stats[\"total_size\"] + file_size > MAX_TOTAL_SIZE_BYTES:\n+                    print(f\"Skipping file {item_path}: would exceed total size limit\")\n+                    continue\n+                    \n+                stats[\"total_files\"] += 1\n+                stats[\"total_size\"] += file_size\n+                \n+                if stats[\"total_files\"] > MAX_FILES:\n+                    print(f\"Maximum file limit ({MAX_FILES}) reached\")\n+                    return result\n+                    \n                 is_text = is_text_file(item_path)\n                 content = read_file_content(item_path) if is_text else \"[Non-text file]\"\n                 \n@@ -68,7 +172,7 @@ def scan_directory(path: str, ignore_patterns: List[str], base_path: str) -> Dic\n                 result[\"file_count\"] += 1\n                 \n             elif os.path.isdir(item_path):\n-                subdir = scan_directory(item_path, ignore_patterns, base_path)\n+                subdir = scan_directory(item_path, ignore_patterns, base_path, seen_paths, depth + 1, stats)\n                 if subdir:\n                     result[\"children\"].append(subdir)\n                     result[\"size\"] += subdir[\"size\"]"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 1,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "afd8e5a538314bdd6f237ea4b24819854405c0a8",
            "date": "2025-01-14T16:28:28Z",
            "author_login": "filipchristiansen"
          },
          {
            "sha": "60391143f668dc19ea9d4614ff092ea65898077d",
            "date": "2025-01-13T20:51:00Z",
            "author_login": "filipchristiansen"
          },
          {
            "sha": "dd8f1e0aaca864836f935c6f50bbd306688b1700",
            "date": "2025-01-13T04:46:29Z",
            "author_login": "filipchristiansen"
          },
          {
            "sha": "0fd16bae18d533cd0030f2078c22fc088fa4dcca",
            "date": "2025-01-13T04:44:14Z",
            "author_login": "cyclotruc"
          },
          {
            "sha": "25f101fa1468e0b961ea6b7f3f0246306e67688e",
            "date": "2025-01-13T04:42:04Z",
            "author_login": "cyclotruc"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:L",
    "cwe_id": "CWE-59",
    "description": "gitingest before 9996a06 mishandles symbolic links that point outside of the base directory.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-12-15T04:15:05.360",
    "last_modified": "2024-12-16T16:15:09.250",
    "fix_date": "2024-12-12T18:39:29Z"
  },
  "references": [
    {
      "url": "https://github.com/cyclotruc/gitingest/blob/9996a06a94450497c1abb35997f5e6cbc9b571ff/src/ingest.py#L22-L30",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/cyclotruc/gitingest/blob/9996a06a94450497c1abb35997f5e6cbc9b571ff/src/ingest.py#L99-L100",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/cyclotruc/gitingest/commit/9996a06a94450497c1abb35997f5e6cbc9b571ff",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://github.com/cyclotruc/gitingest/pull/23",
      "source": "cve@mitre.org",
      "tags": []
    },
    {
      "url": "https://gitingest.com/",
      "source": "cve@mitre.org",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:33.141671",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "gitingest",
    "owner": "cyclotruc",
    "created_at": "2024-11-29T08:27:18Z",
    "updated_at": "2025-01-14T20:49:34Z",
    "pushed_at": "2025-01-14T16:51:10Z",
    "size": 402,
    "stars": 4698,
    "forks": 373,
    "open_issues": 35,
    "watchers": 4698,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Python": 130438,
      "Jinja": 34588,
      "JavaScript": 6807,
      "Dockerfile": 1096
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T21:14:09.566304"
  }
}