{
  "cve_id": "CVE-2024-56358",
  "github_data": {
    "repository": "gristlabs/grist-core",
    "fix_commit": "a792bdc43b456dbdd6fdc50d8747f4c349fab2f4",
    "related_commits": [
      "a792bdc43b456dbdd6fdc50d8747f4c349fab2f4"
    ],
    "patch_url": "https://github.com/gristlabs/grist-core/commit/a792bdc43b456dbdd6fdc50d8747f4c349fab2f4.patch",
    "fix_commit_details": {
      "sha": "a792bdc43b456dbdd6fdc50d8747f4c349fab2f4",
      "commit_date": "2024-12-13T21:10:33Z",
      "author": {
        "login": "georgegevoian",
        "type": "User",
        "stats": {
          "total_commits": 328,
          "average_weekly_commits": 1.3442622950819672,
          "total_additions": 89288,
          "total_deletions": 36480,
          "weeks_active": 142
        }
      },
      "commit_message": {
        "title": "(core) Fix attachment and hyperlink vulnerabilities",
        "length": 777,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1021,
        "additions": 956,
        "deletions": 65
      },
      "files": [
        {
          "filename": "app/client/components/WidgetFrame.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -5,14 +5,15 @@ import {GristDoc} from 'app/client/components/GristDoc';\n import {hooks} from 'app/client/Hooks';\n import {get as getBrowserGlobals} from 'app/client/lib/browserGlobals';\n import {makeTestId} from 'app/client/lib/domUtils';\n+import {sanitizeHttpUrl} from 'app/client/lib/sanitizeUrl';\n import {ColumnRec, ViewSectionRec} from 'app/client/models/DocModel';\n import {reportError} from 'app/client/models/errors';\n import {gristThemeObs} from 'app/client/ui2018/theme';\n import {AccessLevel, ICustomWidget, isSatisfied, matchWidget} from 'app/common/CustomWidget';\n import {DisposableWithEvents} from 'app/common/DisposableWithEvents';\n import {BulkColValues, fromTableDataAction, RowRecord} from 'app/common/DocActions';\n import {extractInfoFromColType, reencodeAsAny} from 'app/common/gristTypes';\n-import {getGristConfig, sanitizeUrl} from 'app/common/urlUtils';\n+import {getGristConfig} from 'app/common/urlUtils';\n import {\n   AccessTokenOptions, CursorPos, CustomSectionAPI, FetchSelectedOptions, GristDocAPI, GristView,\n   InteractionOptionsRequest, WidgetAPI, WidgetColumnMap\n@@ -242,7 +243,7 @@ export class WidgetFrame extends DisposableWithEvents {\n     // Append user and document preferences to query string.\n     const settingsParams = new URLSearchParams(this._options.preferences);\n     settingsParams.forEach((value, key) => urlObj.searchParams.append(key, value));\n-    return sanitizeUrl(urlObj.href);\n+    return sanitizeHttpUrl(urlObj.href);\n   }\n \n   private _getEmptyWidgetPage(): string {"
        },
        {
          "filename": "app/client/lib/sanitizeUrl.ts",
          "status": "added",
          "additions": 42,
          "deletions": 0,
          "patch": "@@ -0,0 +1,42 @@\n+import DOMPurify from \"dompurify\";\n+\n+// Export dependencies for stubbing in tests.\n+export const Deps = { DOMPurify };\n+\n+/**\n+ * Returns the provided URL if it is valid and safe to use in\n+ * HTTP-only contexts, such as form redirects and custom widget\n+ * URLs.\n+ *\n+ * Returns `null` if the URL is invalid or unsafe.\n+ *\n+ * For sanitizing hyperlink URLs, such as those used by `a`\n+ * elements, see `sanitizeLinkUrl`.\n+ */\n+export function sanitizeHttpUrl(url: string): string | null {\n+  try {\n+    const parsedUrl = new URL(url);\n+    if (![\"http:\", \"https:\"].includes(parsedUrl.protocol)) {\n+      return null;\n+    }\n+\n+    return parsedUrl.href;\n+  } catch (e) {\n+    return null;\n+  }\n+}\n+\n+/**\n+ * Returns the provided URL if it is valid and safe to use for hyperlinks,\n+ * such as those used by `a` elements. This includes URLs prefixed with\n+ * `http[s]:`, `mailto:`, and `tel:`, and excludes URLs prefixed with\n+ * `javascript:`.\n+ *\n+ * Returns `null` if the URL is invalid or unsafe.\n+ *\n+ * For sanitizing HTTP-only URLs, such as those used for redirects, see\n+ * `sanitizeHttpUrl`.\n+ */\n+export function sanitizeLinkUrl(url: string): string | null {\n+  return Deps.DOMPurify.isValidAttribute(\"a\", \"href\", url) ? url : null;\n+}"
        },
        {
          "filename": "app/client/ui/FormPage.ts",
          "status": "modified",
          "additions": 3,
          "deletions": 2,
          "patch": "@@ -1,14 +1,15 @@\n import {FormRenderer} from 'app/client/components/FormRenderer';\n import {handleSubmit, TypedFormData} from 'app/client/lib/formUtils';\n import {makeT} from 'app/client/lib/localization';\n+import {sanitizeHttpUrl} from 'app/client/lib/sanitizeUrl';\n import {FormModel, FormModelImpl} from 'app/client/models/FormModel';\n import {buildFormFooter} from 'app/client/ui/FormContainer';\n import {FormErrorPage} from 'app/client/ui/FormErrorPage';\n import {FormSuccessPage} from 'app/client/ui/FormSuccessPage';\n import {colors} from 'app/client/ui2018/cssVars';\n import {ApiError} from 'app/common/ApiError';\n import {getPageTitleSuffix} from 'app/common/gristUrls';\n-import {getGristConfig, sanitizeUrl} from 'app/common/urlUtils';\n+import {getGristConfig} from 'app/common/urlUtils';\n import {Disposable, dom, makeTestId, Observable, styled, subscribe} from 'grainjs';\n \n const t = makeT('FormPage');\n@@ -90,7 +91,7 @@ export class FormPage extends Disposable {\n \n     const {successURL} = formLayout;\n     if (successURL) {\n-      const url = sanitizeUrl(successURL);\n+      const url = sanitizeHttpUrl(successURL);\n       if (url) {\n         window.location.href = url;\n       }"
        },
        {
          "filename": "app/client/ui/sanitizeHTML.ts",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -24,10 +24,10 @@ function handleSanitizeAttribute(node: Element) {\n   node.setAttribute('target', '_blank');\n }\n \n-function handleSanitizeTutorialElement(node: Element, data: createDOMPurifier.SanitizeElementHookEvent) {\n+function handleSanitizeTutorialElement(node: Node, data: createDOMPurifier.UponSanitizeElementHookEvent) {\n   if (data.tagName !== 'iframe') { return; }\n \n-  const src = node.getAttribute('src');\n+  const src = (node as Element).getAttribute('src');\n   if (src?.startsWith('https://www.youtube.com/embed/')) {\n     return;\n   }"
        },
        {
          "filename": "app/client/widgets/HyperLinkTextBox.ts",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -1,3 +1,4 @@\n+import { sanitizeLinkUrl } from 'app/client/lib/sanitizeUrl';\n import { DataRowModel } from 'app/client/models/DataRowModel';\n import { ViewFieldRec } from 'app/client/models/entities/ViewFieldRec';\n import { constructUrl } from 'app/client/models/gristUrlState';\n@@ -20,7 +21,10 @@ export class HyperLinkTextBox extends NTextBox {\n \n   public buildDom(row: DataRowModel) {\n     const value = row.cells[this.field.colId()];\n-    const url = Computed.create(null, (use) => constructUrl(use(value)));\n+    const url = Computed.create(\n+      null,\n+      (use) => sanitizeLinkUrl(constructUrl(use(value))) ?? \"about:blank\"\n+    );\n     return cssFieldClip(\n       dom.autoDispose(url),\n       dom.style('text-align', this.alignment),"
        },
        {
          "filename": "app/common/urlUtils.ts",
          "status": "modified",
          "additions": 0,
          "deletions": 17,
          "patch": "@@ -79,20 +79,3 @@ export function fetchFromHome(path: string, opts: RequestInit): Promise<Response\n   const baseUrl = addCurrentOrgToPath(getGristConfig().homeUrl!);\n   return window.fetch(`${baseUrl}${path}`, opts);\n }\n-\n-/**\n- * Returns the provided URL if it has a valid protocol (`http:` or `https:`), or\n- * `null` otherwise.\n- */\n-export function sanitizeUrl(url: string): string | null {\n-  try {\n-    const parsedUrl = new URL(url);\n-    if (![\"http:\", \"https:\"].includes(parsedUrl.protocol)) {\n-      return null;\n-    }\n-\n-    return parsedUrl.href;\n-  } catch (e) {\n-    return null;\n-  }\n-}"
        },
        {
          "filename": "app/server/lib/DocWorker.ts",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -61,6 +61,7 @@ export class DocWorker {\n         .type(ext)\n         .set('Content-Disposition', contentDispHeader)\n         .set('Cache-Control', 'private, max-age=3600')\n+        .set(\"Content-Security-Policy\", \"sandbox; default-src: 'none'\")\n         .send(data);\n     } catch (err) {\n       res.status(404).send({error: err.toString()});"
        },
        {
          "filename": "package.json",
          "status": "modified",
          "additions": 1,
          "deletions": 2,
          "patch": "@@ -49,7 +49,6 @@\n     \"@types/chai-as-promised\": \"7.1.0\",\n     \"@types/content-disposition\": \"0.5.2\",\n     \"@types/diff-match-patch\": \"1.0.32\",\n-    \"@types/dompurify\": \"3.0.5\",\n     \"@types/double-ended-queue\": \"2.1.0\",\n     \"@types/express\": \"4.17.17\",\n     \"@types/form-data\": \"2.2.1\",\n@@ -139,7 +138,7 @@\n     \"csv\": \"6.3.8\",\n     \"currency-symbol-map\": \"5.1.0\",\n     \"diff-match-patch\": \"1.0.5\",\n-    \"dompurify\": \"3.0.6\",\n+    \"dompurify\": \"3.2.3\",\n     \"double-ended-queue\": \"2.1.0-0\",\n     \"engine.io\": \"^6.5.4\",\n     \"engine.io-client\": \"^6.5.3\","
        },
        {
          "filename": "test/client/lib/sanitizeUrl.ts",
          "status": "added",
          "additions": 71,
          "deletions": 0,
          "patch": "@@ -0,0 +1,71 @@\n+import {\n+  Deps,\n+  sanitizeHttpUrl,\n+  sanitizeLinkUrl,\n+} from \"app/client/lib/sanitizeUrl\";\n+import { assert } from \"chai\";\n+import DOMPurify from \"dompurify\";\n+import { JSDOM } from \"jsdom\";\n+import * as sinon from \"sinon\";\n+\n+describe(\"sanitizeUrl\", function () {\n+  let sandbox: sinon.SinonSandbox;\n+\n+  beforeEach(function () {\n+    // These grainjs browserGlobals are needed for using dom() in tests.\n+    const jsdomDoc = new JSDOM(\"<!doctype html><html><body></body></html>\");\n+    sandbox = sinon.createSandbox();\n+    sandbox.stub(Deps, \"DOMPurify\").value(DOMPurify(jsdomDoc.window));\n+  });\n+\n+  afterEach(function () {\n+    sandbox.restore();\n+  });\n+\n+  describe(\"sanitizeHttpUrl\", function () {\n+    it(\"returns the provided URL if valid\", function () {\n+      assert.equal(\n+        sanitizeHttpUrl(\"https://example.com\"),\n+        \"https://example.com/\"\n+      );\n+      assert.equal(\n+        sanitizeHttpUrl(\"http://example.com\"),\n+        \"http://example.com/\"\n+      );\n+    });\n+\n+    it(\"returns null if the provided URL is invalid\", function () {\n+      assert.isNull(sanitizeHttpUrl(\"www.example.com\"));\n+      assert.isNull(sanitizeHttpUrl(\"\"));\n+      assert.isNull(sanitizeHttpUrl(\"invalid\"));\n+      assert.isNull(sanitizeHttpUrl(\"mailto:support@getgrist.com\"));\n+      assert.isNull(sanitizeHttpUrl(\"ftp://getgrist.com/path\"));\n+      assert.isNull(sanitizeHttpUrl(\"javascript:alert()\"));\n+    });\n+  });\n+\n+  describe(\"sanitizeLinkUrl\", function () {\n+    it(\"returns the provided URL if valid\", function () {\n+      assert.equal(\n+        sanitizeLinkUrl(\"https://example.com\"),\n+        \"https://example.com\"\n+      );\n+      assert.equal(sanitizeLinkUrl(\"http://example.com\"), \"http://example.com\");\n+      assert.equal(sanitizeLinkUrl(\"www.example.com\"), \"www.example.com\");\n+      assert.equal(sanitizeLinkUrl(\"\"), \"\");\n+      assert.equal(\n+        sanitizeLinkUrl(\"mailto:support@getgrist.com\"),\n+        \"mailto:support@getgrist.com\"\n+      );\n+      assert.equal(sanitizeLinkUrl(\"tel:0123456789\"), \"tel:0123456789\");\n+      assert.equal(\n+        sanitizeLinkUrl(\"ftp://getgrist.com/path\"),\n+        \"ftp://getgrist.com/path\"\n+      );\n+    });\n+\n+    it(\"returns null if the provided URL is unsafe\", function () {\n+      assert.isNull(sanitizeLinkUrl(\"javascript:alert()\"));\n+    });\n+  });\n+});"
        },
        {
          "filename": "test/common/urlUtils.ts",
          "status": "removed",
          "additions": 0,
          "deletions": 24,
          "patch": "@@ -1,24 +0,0 @@\n-import { sanitizeUrl } from \"app/common/urlUtils\";\n-import { assert } from \"chai\";\n-\n-describe(\"urlUtils\", function () {\n-  describe(\"sanitizeUrl\", function () {\n-    it(\"returns the provided URL if the scheme is http[s]\", function () {\n-      assert.equal(sanitizeUrl(\"https://example.com\"), \"https://example.com/\");\n-      assert.equal(sanitizeUrl(\"http://example.com\"), \"http://example.com/\");\n-      assert.equal(sanitizeUrl(\"https://example.com\"), \"https://example.com/\");\n-    });\n-\n-    it(\"returns null if the provided URL is invalid\", function () {\n-      assert.isNull(sanitizeUrl(\"www.example.com\"));\n-      assert.isNull(sanitizeUrl(\"\"));\n-      assert.isNull(sanitizeUrl(\"invalid\"));\n-    });\n-\n-    it(\"returns null if the provided URL's scheme is not http[s]\", function () {\n-      assert.isNull(sanitizeUrl(\"mailto:support@getgrist.com.com\"));\n-      assert.isNull(sanitizeUrl(\"ftp://getgrist.com/path\"));\n-      assert.isNull(sanitizeUrl(\"javascript:alert()\"));\n-    });\n-  });\n-});"
        },
        {
          "filename": "test/fixtures/uploads/image_with_script.svg",
          "status": "added",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -0,0 +1,6 @@\n+<svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n+  <polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/>\n+  <script type=\"text/javascript\">\n+    alert('I should not appear');\n+  </script>\n+</svg>"
        },
        {
          "filename": "test/nbrowser/AttachmentsWidget.ts",
          "status": "added",
          "additions": 548,
          "deletions": 0,
          "patch": "@@ -0,0 +1,548 @@\n+import {\n+  assert,\n+  driver,\n+  Key,\n+  stackWrapFunc,\n+  WebElement,\n+} from \"mocha-webdriver\";\n+import fetch from \"node-fetch\";\n+import * as gu from \"test/nbrowser/gristUtils\";\n+import { server, setupTestSuite } from \"test/nbrowser/testUtils\";\n+\n+describe(\"AttachmentsWidget\", function () {\n+  this.timeout(20000);\n+  setupTestSuite();\n+  let docId: string;\n+\n+  before(async function () {\n+    docId = (\n+      await gu.importFixturesDoc(\n+        \"chimpy\",\n+        \"nasa\",\n+        \"Horizon\",\n+        \"Hello.grist\",\n+        false\n+      )\n+    ).id;\n+    await server.simulateLogin(\"Chimpy\", \"chimpy@getgrist.com\", \"nasa\");\n+    await gu.loadDoc(`/o/nasa/doc/${docId}`);\n+  });\n+\n+  afterEach(async function () {\n+    await gu.checkForErrors();\n+  });\n+\n+  after(async function () {\n+    // Close any open cell/attachments editor, to avoid an unload alert that would interfere with\n+    // the next test suite.\n+    await driver.sendKeys(Key.ESCAPE);\n+  });\n+\n+  // Returns the 'title' attributes of all attachments in the given cell. These should be the\n+  // names of the attached files.\n+  const getCellThumbnailTitles = stackWrapFunc(async function (\n+    cell: WebElement\n+  ) {\n+    return await cell.findAll(\".test-pw-thumbnail\", (el) =>\n+      el.getAttribute(\"title\")\n+    );\n+  });\n+\n+  it(\"should include a functioning attachment widget\", async function () {\n+    await gu.toggleSidePanel(\"right\", \"open\");\n+    await driver.find(\".test-right-tab-field\").click();\n+\n+    // Move to first column\n+    await gu.getCell(0, 1).click();\n+\n+    // Change type to Attachment.\n+    await gu.setType(/Attachment/);\n+    await driver.findWait(\".test-type-transform-apply\", 1000).click();\n+    await gu.waitForServer();\n+    assert.equal(\n+      await gu.getCell(0, 2).find(\".test-attachment-widget\").isDisplayed(),\n+      true\n+    );\n+  });\n+\n+  it(\"should include a functioning upload button\", async function () {\n+    // Put 'foo1' in a cell, then replace it immediately with 'foo2'.\n+    // This is just setting up for testing undo behaviour below.\n+    await gu.getCell(1, 2).click();\n+    await driver.sendKeys(\"foo1\", Key.ENTER);\n+    await gu.getCell(1, 2).click();\n+    await driver.sendKeys(\"foo2\", Key.ENTER);\n+\n+    await gu.getCell(0, 2).click();\n+    await driver.sendKeys(Key.ENTER);\n+\n+    await gu.fileDialogUpload(\"uploads/sample.pdf,uploads/grist.png\", () =>\n+      driver.find(\".test-pw-add\").click()\n+    );\n+    await driver.findContentWait(\".test-pw-counter\", /of 2/, 3000);\n+\n+    const href: string = await driver\n+      .findWait(\".test-pw-download\", 2000)\n+      .getAttribute(\"href\");\n+    assert.include(href.split(\"name=\")[1], \"sample.pdf\");\n+    assert.equal(await driver.find(\".test-pw-counter\").getText(), \"1 of 2\");\n+    await driver.find(\".test-modal-dialog .test-pw-close\").click();\n+    await gu.waitForServer();\n+\n+    // Check that title attributes are set to file names.\n+    assert.deepEqual(await getCellThumbnailTitles(gu.getCell(0, 2)), [\n+      \"sample.pdf\",\n+      \"grist.png\",\n+    ]);\n+\n+    // Check that in the absence of a thumbnail we show the extension.\n+    assert.deepEqual(\n+      await gu\n+        .getCell(0, 2)\n+        .findAll(\".test-pw-thumbnail\", (el) => el.getText()),\n+      [\"PDF\", \"\"]\n+    );\n+\n+    async function checkState(expectedCells: string[], isSoftDeleted: boolean) {\n+      assert.deepEqual(\n+        await gu.getVisibleGridCells({ cols: [0, 1], rowNums: [2] }),\n+        expectedCells\n+      );\n+\n+      // Previously, undo would remove the uploaded attachment metadata completely,\n+      // which could lead to hard deleting the file data and leaving broken attachments after redo.\n+      // Here we check that after checking for unused attachments and removing expired ones\n+      // (as should happen automatically every hour)\n+      // the metadata records (and thus files) are still there, but appropriately marked as soft deleted.\n+      const headers = { Authorization: \"Bearer api_key_for_chimpy\" };\n+      const url = server.getUrl(\"nasa\", `/api/docs/${docId}`);\n+      let resp = await fetch(\n+        url + \"/attachments/removeUnused?verifyfiles=1&expiredonly=1\",\n+        { headers, method: \"POST\" }\n+      );\n+      assert.equal(resp.status, 200);\n+      resp = await fetch(url + \"/tables/_grist_Attachments/records\", {\n+        headers,\n+      });\n+      const data = await resp.json();\n+      assert.lengthOf(data.records, 2);\n+      for (const record of data.records) {\n+        assert.equal(Boolean(record.fields.timeDeleted), isSoftDeleted);\n+      }\n+    }\n+\n+    // Check current state before testing undo/redo\n+    assert.deepEqual(\n+      await gu.getVisibleGridCells({ cols: [0, 1], rowNums: [2] }),\n+      [\"PDF\", \"foo2\"]\n+    );\n+    await checkState([\"PDF\", \"foo2\"], false);\n+\n+    // Check that undo once removes the attachments we just added to the cell\n+    await gu.undo();\n+    await checkState([\"\", \"foo2\"], true); // true: attachment metadata marked as soft deleted\n+\n+    // Check that undo again undoes the thing we did before attaching: changing foo1 to foo2\n+    // (previously it would undo creating the attachment metadata, which was invisible)\n+    await gu.undo();\n+    await checkState([\"\", \"foo1\"], true);\n+\n+    // Check that redoing twice restores things as expected\n+    await gu.redo();\n+    await checkState([\"\", \"foo2\"], true);\n+    await gu.redo();\n+    await checkState([\"PDF\", \"foo2\"], false); // false: attachment metadata un-deleted\n+  });\n+\n+  it(\"should allow resizing thumbnails\", async function () {\n+    const slider = await driver.find(\".test-pw-thumbnail-size\");\n+    assert.equal(\n+      (await driver.findWait(\".test-pw-thumbnail:last-child\", 1000).getRect())\n+        .height,\n+      36\n+    );\n+    for (let i = 0; i < 5; i++) {\n+      await slider.sendKeys(Key.RIGHT);\n+    }\n+    assert.equal(\n+      (await driver.find(\".test-pw-thumbnail:last-child\").getRect()).height,\n+      41\n+    );\n+    for (let i = 0; i < 3; i++) {\n+      await slider.sendKeys(Key.LEFT);\n+    }\n+    assert.equal(\n+      (await driver.find(\".test-pw-thumbnail:last-child\").getRect()).height,\n+      38\n+    );\n+    // Wait to ensure the new setting is saved.\n+    await driver.sleep(300);\n+\n+    // Thumbnail size setting should persist across refresh\n+    await driver.navigate().refresh();\n+    await gu.waitForServer(10000);\n+    assert.equal(\n+      (await driver.findWait(\".test-pw-thumbnail:last-child\", 1000).getRect())\n+        .height,\n+      38\n+    );\n+  });\n+\n+  it(\"should get correct headers from the server\", async function () {\n+    const cell: any = gu.getCell(0, 2);\n+    await cell.click();\n+    await driver.sendKeys(Key.ENTER);\n+\n+    const fetchOptions = {\n+      headers: { Authorization: \"Bearer api_key_for_chimpy\" },\n+    };\n+    const hrefDownload = await driver\n+      .findWait(\".test-pw-download\", 500)\n+      .getAttribute(\"href\");\n+    const respDownload = await fetch(hrefDownload, fetchOptions);\n+    assert.equal(\n+      respDownload.headers.get(\"Content-Disposition\"),\n+      'attachment; filename=\"sample.pdf\"'\n+    );\n+    assert.equal(\n+      respDownload.headers.get(\"Content-Security-Policy\"),\n+      \"sandbox; default-src: 'none'\"\n+    );\n+\n+    const hrefInline = await driver\n+      .find(\".test-pw-attachment-content\")\n+      .getAttribute(\"data\");\n+    const respInline = await fetch(hrefInline, fetchOptions);\n+    assert.equal(\n+      respInline.headers.get(\"Content-Disposition\"),\n+      'inline; filename=\"sample.pdf\"'\n+    );\n+\n+    // Attach an html file and ensure it doesn't get served inline.\n+    await gu.fileDialogUpload(\"uploads/htmlfile.html\", () =>\n+      driver.findWait(\".test-pw-add\", 500).click()\n+    );\n+    await driver.findContentWait(\".test-pw-counter\", /of 3/, 3000);\n+\n+    const hrefLinkHtml = await driver\n+      .findWait(\".test-pw-download\", 2000)\n+      .getAttribute(\"href\");\n+    const respLinkHtml = await fetch(hrefLinkHtml, fetchOptions);\n+    // Note that the disposition here is NOT \"inline\" (that would be bad).\n+    assert.equal(\n+      respLinkHtml.headers.get(\"Content-Disposition\"),\n+      'attachment; filename=\"htmlfile.html\"'\n+    );\n+    await driver.find(\".test-modal-dialog .test-pw-close\").click();\n+  });\n+\n+  it(\"should allow editing the attachments list\", async function () {\n+    let cell = gu.getCell(0, 2);\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"sample.pdf\",\n+      \"grist.png\",\n+      \"htmlfile.html\",\n+    ]);\n+\n+    // Open an image preview.\n+    await driver.withActions((a) =>\n+      a.doubleClick(driver.find(\".test-pw-thumbnail\"))\n+    );\n+\n+    assert.equal(\n+      await driver.findWait(\".test-pw-counter\", 500).getText(),\n+      \"1 of 3\"\n+    );\n+\n+    // Assert that the attachment filename can be changed.\n+    await driver\n+      .find(\".test-pw-name\")\n+      .doClick()\n+      .sendKeys(\"renamed.pdf\", Key.ENTER);\n+    // Wait for doc name input to lose focus, indicating that the save call completed.\n+    await driver.findWait(\".test-bc-doc:not(:focus)\", 2000);\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"renamed.pdf\");\n+\n+    // Assert that the attachment has the correct download link.\n+    const href = await driver.find(\".test-pw-download\").getAttribute(\"href\");\n+    assert.include(href, \"attId=1\");\n+    assert.include(href, \"name=renamed.pdf\");\n+\n+    // Assert that other previews can be viewed without closing the modal.\n+    await driver.find(\".test-pw-right\").click();\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"grist.png\");\n+    await driver.find(\".test-pw-left\").click();\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"renamed.pdf\");\n+    await driver.sendKeys(Key.RIGHT, Key.RIGHT);\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"htmlfile.html\");\n+\n+    // Assert that the attachment can be removed from the cell.\n+    assert.equal(await driver.find(\".test-pw-counter\").getText(), \"3 of 3\");\n+    await driver.find(\".test-pw-remove\").click();\n+    await gu.waitForServer();\n+    assert.equal(await driver.find(\".test-pw-counter\").getText(), \"2 of 2\");\n+    await driver.find(\".test-modal-dialog .test-pw-close\").click();\n+    cell = gu.getCell(0, 2);\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+    ]);\n+  });\n+\n+  it(\"should allow uploading to the add row\", async function () {\n+    assert.equal(await gu.getCell({ col: 0, rowNum: 6 }).isPresent(), false);\n+    const cell = await gu.getCell({ col: 0, rowNum: 5 });\n+\n+    await gu.fileDialogUpload(\"uploads/grist.png\", () =>\n+      cell.find(\".test-attachment-icon\").click()\n+    );\n+    await gu.waitToPass(async () =>\n+      assert.lengthOf(\n+        await gu.getCell({ col: 0, rowNum: 5 }).findAll(\".test-pw-thumbnail\"),\n+        1\n+      )\n+    );\n+\n+    assert.deepEqual(\n+      await getCellThumbnailTitles(gu.getCell({ col: 0, rowNum: 5 })),\n+      [\"grist.png\"]\n+    );\n+    // Assert that a row is added\n+    assert.equal(await gu.getCell({ col: 0, rowNum: 6 }).isPresent(), true);\n+  });\n+\n+  it(\"should not initialize as invalid when a row is added\", async function () {\n+    // The first cell is invalid, just to check that the assert is correct.\n+    let cell = gu.getCell({ col: 0, rowNum: 1 });\n+    assert.equal(await cell.getText(), \"hello\");\n+    assert.equal(await cell.find(\".field_clip\").matches(\".invalid\"), true);\n+    await cell.click();\n+    // Add a new row and ensure it's NOT invalid.\n+    await driver\n+      .find(\"body\")\n+      .sendKeys(Key.chord(await gu.modKey(), Key.SHIFT, Key.ENTER));\n+    await gu.waitForServer();\n+    cell = gu.getCell({ col: 0, rowNum: 1 });\n+    assert.equal(await cell.getText(), \"\");\n+    assert.equal(await cell.find(\".field_clip\").matches(\".invalid\"), false);\n+    await gu.undo();\n+  });\n+\n+  it(\"should open preview to double-clicked attachment\", async function () {\n+    const cell = gu.getCell({ col: 0, rowNum: 2 });\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+    ]);\n+\n+    // Double-click the first attachment.\n+    await driver.withActions((a) =>\n+      a.doubleClick(cell.find(\".test-pw-thumbnail[title*=pdf]\"))\n+    );\n+    assert.equal(\n+      await driver.findWait(\".test-pw-counter\", 500).getText(),\n+      \"1 of 2\"\n+    );\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"renamed.pdf\");\n+    await driver.sendKeys(Key.ESCAPE);\n+\n+    // Double-click the second attachment.\n+    await driver.withActions((a) =>\n+      a.doubleClick(cell.find(\".test-pw-thumbnail[title*=png]\"))\n+    );\n+    assert.equal(\n+      await driver.findWait(\".test-pw-counter\", 500).getText(),\n+      \"2 of 2\"\n+    );\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"grist.png\");\n+    await driver.sendKeys(Key.ESCAPE);\n+  });\n+\n+  it(\"should render various types of files appropriately\", async function () {\n+    const cell = gu.getCell({ col: 0, rowNum: 2 });\n+    await cell.click();\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+    ]);\n+    await gu.fileDialogUpload(\n+      \"uploads/file1.mov,uploads/file2.mp3,uploads/file3.zip,uploads/simple_array.json\",\n+      () => cell.find(\".test-attachment-icon\").click()\n+    );\n+    await gu.waitToPass(async () =>\n+      assert.lengthOf(await cell.findAll(\".test-pw-thumbnail\"), 6)\n+    );\n+    await gu.waitForServer();\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+      \"file1.mov\",\n+      \"file2.mp3\",\n+      \"file3.zip\",\n+      \"simple_array.json\",\n+    ]);\n+    await driver.sendKeys(Key.ENTER);\n+    assert.equal(\n+      await driver.findWait(\".test-pw-counter\", 500).getText(),\n+      \"1 of 6\"\n+    );\n+\n+    // For various recognized file types, see that a suitable element is created.\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"renamed.pdf\");\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getTagName(),\n+      \"object\"\n+    );\n+    assert.match(\n+      await driver.find(\".test-pw-attachment-content\").getAttribute(\"data\"),\n+      /name=renamed.pdf&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=1&inline=1/\n+    );\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getAttribute(\"type\"),\n+      \"application/pdf\"\n+    );\n+\n+    await driver.sendKeys(Key.RIGHT);\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"grist.png\");\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getTagName(),\n+      \"img\"\n+    );\n+    assert.match(\n+      await driver.find(\".test-pw-attachment-content\").getAttribute(\"src\"),\n+      /name=grist.png&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=2/\n+    );\n+\n+    await driver.sendKeys(Key.RIGHT);\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"file1.mov\");\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getTagName(),\n+      \"video\"\n+    );\n+    assert.match(\n+      await driver.find(\".test-pw-attachment-content\").getAttribute(\"src\"),\n+      /name=file1.mov&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=5&inline=1/\n+    );\n+\n+    await driver.sendKeys(Key.RIGHT);\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"file2.mp3\");\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getTagName(),\n+      \"audio\"\n+    );\n+    assert.match(\n+      await driver.find(\".test-pw-attachment-content\").getAttribute(\"src\"),\n+      /name=file2.mp3&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=6&inline=1/\n+    );\n+\n+    // Test that for an unsupported file, the extension is shown along with a message.\n+    await driver.sendKeys(Key.RIGHT);\n+    assert.equal(await driver.find(\".test-pw-name\").value(), \"file3.zip\");\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getTagName(),\n+      \"object\"\n+    );\n+    assert.match(\n+      await driver.find(\".test-pw-attachment-content\").getAttribute(\"data\"),\n+      /name=file3.zip&rowId=2&colId=A&tableId=Table1&maybeNew=1&attId=7&inline=1/\n+    );\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getText(),\n+      \"ZIP\\nPreview not available.\"\n+    );\n+\n+    // Test the same for a text/json file that we also don't currently render.\n+    await driver.sendKeys(Key.RIGHT);\n+    assert.equal(\n+      await driver.find(\".test-pw-name\").value(),\n+      \"simple_array.json\"\n+    );\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getTagName(),\n+      \"div\"\n+    );\n+    assert.equal(\n+      await driver.find(\".test-pw-attachment-content\").getText(),\n+      \"JSON\\nPreview not available.\"\n+    );\n+    await driver.sendKeys(Key.ESCAPE);\n+\n+    // Undo.\n+    await gu.undo();\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+    ]);\n+  });\n+\n+  const checkClosing = stackWrapFunc(async function (\n+    shouldSave: boolean,\n+    trigger: () => Promise<void>\n+  ) {\n+    let cell = gu.getCell({ col: 0, rowNum: 2 });\n+    await cell.click();\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+    ]);\n+\n+    // Open attachments editor.\n+    await driver.sendKeys(Key.ENTER);\n+    await driver.findWait(\".test-pw-attachment-content\", 500);\n+\n+    // Close using the given trigger. No actions should be emitted.\n+    await gu.userActionsCollect();\n+    await trigger();\n+    await gu.userActionsVerify([]);\n+\n+    // Open editor and delete a file.\n+    await driver.sendKeys(Key.ENTER);\n+    await driver.findWait(\".test-pw-attachment-content\", 500);\n+    await driver.find(\".test-pw-remove\").click();\n+    await gu.waitForServer();\n+\n+    // Close using the given trigger.\n+    await gu.userActionsCollect();\n+    await trigger();\n+    await gu.waitForServer();\n+    cell = gu.getCell({ col: 0, rowNum: 2 });\n+    if (shouldSave) {\n+      // If shouldSave is set, files should reflect the change. Check it and undo.\n+      await gu.userActionsCollect(false);\n+      assert.deepEqual(await getCellThumbnailTitles(cell), [\"grist.png\"]);\n+      await gu.undo();\n+    } else {\n+      // If shouldSave is false, there should be no actions.\n+      await gu.userActionsVerify([]);\n+    }\n+    assert.deepEqual(await getCellThumbnailTitles(cell), [\n+      \"renamed.pdf\",\n+      \"grist.png\",\n+    ]);\n+  });\n+\n+  it(\"should not save on Escape\", async function () {\n+    await checkClosing(false, () => driver.sendKeys(Key.ESCAPE));\n+  });\n+\n+  it(\"should save on Enter\", async function () {\n+    await checkClosing(true, () => driver.sendKeys(Key.ENTER));\n+  });\n+\n+  it(\"should save on close button\", async function () {\n+    await checkClosing(true, () =>\n+      driver.find(\".test-modal-dialog .test-pw-close\").click()\n+    );\n+  });\n+\n+  it(\"should preview images properly\", async function () {\n+    const cell = await gu.getCell({ col: 0, rowNum: 2 });\n+    await cell.click();\n+    await gu.fileDialogUpload(\"uploads/image_with_script.svg\", () =>\n+      cell.find(\".test-attachment-icon\").click()\n+    );\n+    await driver.withActions((a) => a.doubleClick(cell));\n+    await driver.findWait(\".test-pw-attachment-content\", 1000);\n+    assert.isFalse(await gu.isAlertShown());\n+  });\n+});"
        },
        {
          "filename": "test/nbrowser/CellFormat.ts",
          "status": "added",
          "additions": 264,
          "deletions": 0,
          "patch": "@@ -0,0 +1,264 @@\n+import {assert, driver, Key} from 'mocha-webdriver';\n+import * as gu from 'test/nbrowser/gristUtils';\n+import {server, setupTestSuite} from 'test/nbrowser/testUtils';\n+import {DocCreationInfo} from \"app/common/DocListAPI\";\n+\n+describe('CellFormat', function() {\n+  this.timeout(20000);\n+  const cleanup = setupTestSuite();\n+  let session: gu.Session, doc: DocCreationInfo, api;\n+\n+  // Checks that a bug where alignment settings did not survive doc reload is gone.\n+  it('saves alignment settings', async function() {\n+    session = await gu.session().login();\n+    doc = await session.tempDoc(cleanup, 'Hello.grist');\n+    await gu.toggleSidePanel('right', 'open');\n+    await driver.findWait('.test-right-tab-field', 3000).click();\n+\n+    // Alignment should be left.\n+    assert.equal(await driver.find(`.test-alignment-select .test-select-button:first-child`)\n+                 .matches('[class*=-selected]'), true);\n+\n+    // Click on center aligmment.\n+    await (await driver.findAll('.test-alignment-select .test-select-button'))[1].click();\n+    await gu.waitForServer();\n+\n+    // Alignment should no longer be left.\n+    assert.equal(await driver.find(`.test-alignment-select .test-select-button:first-child`)\n+                 .matches('[class*=-selected]'), false);\n+\n+    // Reload document.\n+    await session.loadDocMenu('/');\n+    await session.loadDoc(`/doc/${doc.id}`);\n+\n+    // Alignment should still not be left.\n+    assert.equal(await driver.find(`.test-alignment-select .test-select-button:first-child`)\n+                 .matches('[class*=-selected]'), false);\n+  });\n+\n+  it('should open hyperlinks in new tabs only when needed', async function () {\n+    api = session.createHomeApi();\n+    const currentUrl = await driver.getCurrentUrl();\n+    const urls = [\n+      // Different origin, must open in new tab.\n+      // The driver waits for the page to load so something that loads quickly is needed.\n+      'about:blank',\n+\n+      // Same origin, but still needs a new tab because it's not the current document\n+      server.getUrl(session.settings.orgDomain, '/'),\n+\n+      // Same URL but with a link key, needs a new tab\n+      currentUrl + \"?foo_=bar\",\n+\n+      // Shouldn't open a new tab\n+      currentUrl,\n+    ];\n+\n+    // Create and open a new table in the same document containing the above URLs\n+    await api.applyUserActions(doc.id, [\n+      ['AddTable', 'Links',\n+        [{id: 'Link', type: 'Text'}]],\n+      ...urls.map(url => ['AddRecord', 'Links', null, {Link: url}]),\n+    ]);\n+    await gu.getPageItem(/Links/).click();\n+\n+    // Confirm that we are on a different page from before (i.e. `currentUrl`)\n+    // which we will be returning to\n+    const newUrl = await driver.getCurrentUrl();\n+    assert.isTrue(newUrl.endsWith('/p/2'));\n+    assert.isFalse(currentUrl.endsWith('/p/2'));\n+\n+    // Convert the column to hyperlink format\n+    await gu.getCell({rowNum: 1, col: 0}).click();\n+    await gu.setFieldWidgetType('HyperLink');\n+\n+    // There should only be one tab open for the following checks to make sense\n+    assert.equal((await driver.getAllWindowHandles()).length, 1);\n+\n+    async function checkExternalLink(rowNum: number) {\n+      const cell = gu.getCell({rowNum, col: 0});\n+      const url = await cell.getText();\n+      await cell.find('.test-tb-link').click();\n+\n+      // Check that we opened the URL in the cell in a new tab\n+      const handles = await driver.getAllWindowHandles();\n+      assert.equal(handles.length, 2);\n+      // Use gu.switchToWindow to handle occasional selenium flakage here.\n+      await gu.switchToWindow(handles[1]);\n+      assert.equal(await driver.getCurrentUrl(), url);\n+      assert.equal(urls[rowNum - 1], url);\n+      await driver.close();\n+\n+      // Return to the original tab with our document\n+      const [originalWindow] = await driver.getAllWindowHandles();\n+      await driver.switchTo().window(originalWindow);\n+    }\n+\n+    await checkExternalLink(1);\n+    await checkExternalLink(2);\n+    await checkExternalLink(3);\n+\n+    const cell = gu.getCell({rowNum: 4, col: 0});\n+    const url = await cell.getText();\n+    await cell.find('.test-tb-link').click();\n+    const handles = await driver.getAllWindowHandles();\n+\n+    // This time no new tab should have opened,\n+    // but we're back to the previous page\n+    assert.equal(handles.length, 1);\n+    assert.equal(await driver.getCurrentUrl(), url);\n+    assert.equal(currentUrl, url);\n+  });\n+\n+  it('can display Markdown-formatted text', async function() {\n+    await gu.getCell(0, 1).click();\n+    await gu.setFieldWidgetType('TextBox');\n+    await gu.sendKeys(\n+      Key.ENTER,\n+      await gu.selectAllKey(),\n+      Key.DELETE,\n+      '# Heading',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      '## Subheading',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      '1. Item 1',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      '2. Item 2',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      'A paragraph with **bold** and *italicized* text.',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      '[Link with label](https://example.com/#1)',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      'Link: https://example.com/#2',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      'HTML is <span style=\"color: red;\">escaped</span>.',\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      Key.chord(Key.SHIFT, Key.ENTER),\n+      \"![Images too](https://example.com)\",\n+      Key.ENTER\n+    );\n+    await gu.waitForServer();\n+    assert.equal(\n+      await gu.getCell(0, 1).getText(),\n+      `# Heading\n+\n+## Subheading\n+\n+1. Item 1\n+2. Item 2\n+\n+A paragraph with **bold** and *italicized* text.\n+\n+[Link with label](\n+)\n+\n+Link: \\nhttps://example.com/#2\n+\n+HTML is <span style=\"color: red;\">escaped</span>.\n+\n+![Images too](\n+)`\n+    );\n+    assert.isFalse(await gu.getCell(0, 1).findContent('h1', 'Heading').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('h2', 'Subheading').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('ol', 'Item 1').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('strong', 'bold').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('em', 'italicized').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('a + span', 'Link with label').isPresent());\n+    assert.isTrue(await gu.getCell(0, 1).find('a[href=\"https://example.com/#2\"]').isDisplayed());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('span', 'escaped').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).find('img').isPresent());\n+\n+    await gu.setFieldWidgetType('Markdown');\n+    await driver.find('.test-tb-wrap-text').click();\n+    await gu.waitForServer();\n+    assert.equal(\n+      await gu.getCell(0, 1).getText(),\n+      `Heading\n+Subheading\n+Item 1\n+Item 2\n+A paragraph with bold and italicized text.\n+Link with label\n+Link:\n+https://example.com/#2\n+HTML is <span style=\"color: red;\">escaped</span>.\n+![Images too](https://example.com)`\n+    );\n+    assert.isTrue(await gu.getCell(0, 1).findContent('h1', 'Heading').isDisplayed());\n+    assert.isTrue(await gu.getCell(0, 1).findContent('h2', 'Subheading').isDisplayed());\n+    assert.isTrue(await gu.getCell(0, 1).findContent('ol', 'Item 1').isDisplayed());\n+    assert.isTrue(await gu.getCell(0, 1).findContent('strong', 'bold').isDisplayed());\n+    assert.isTrue(await gu.getCell(0, 1).findContent('em', 'italicized').isDisplayed());\n+    assert.isTrue(await gu.getCell(0, 1)\n+      .findContent('a[href=\"https://example.com/#1\"] + span', 'Link with label').isDisplayed());\n+    assert.isTrue(await gu.getCell(0, 1).find('a[href=\"https://example.com/#2\"]').isDisplayed());\n+    assert.isFalse(await gu.getCell(0, 1).findContent('span', 'escaped').isPresent());\n+    assert.isFalse(await gu.getCell(0, 1).find('img').isPresent());\n+\n+    await gu.sendKeys(\n+      Key.ENTER,\n+      '> Editing works the same way as TextBox and HyperLink',\n+      Key.ENTER,\n+    );\n+    await gu.waitForServer();\n+    assert.equal(\n+      await gu.getCell(0, 2).getText(),\n+      'Editing works the same way as TextBox and HyperLink'\n+    );\n+\n+    await gu.setFieldWidgetType('TextBox');\n+    assert.equal(\n+      await gu.getCell(0, 1).getText(),\n+      `# Heading\n+\n+## Subheading\n+\n+1. Item 1\n+2. Item 2\n+\n+A paragraph with **bold** and *italicized* text.\n+\n+[Link with label](\n+)\n+\n+Link: \\nhttps://example.com/#2\n+\n+HTML is <span style=\"color: red;\">escaped</span>.\n+\n+![Images too](\n+)`\n+    );\n+    assert.equal(\n+      await gu.getCell(0, 2).getText(),\n+      '> Editing works the same way as TextBox and HyperLink'\n+    );\n+  });\n+\n+  it('treats URLs in Markdown and HyperLink cells as absolute URLs', async function() {\n+    // Previously, URLs in Markdown cells were treated as being relative to\n+    // the document origin if they were missing a scheme. This was inconsistent\n+    // with how HyperLink cells treated such URLs (with `http://` inferred).\n+    await gu.setFieldWidgetType('Markdown');\n+    await gu.getCell(0, 3).click();\n+    await gu.sendKeys(Key.ENTER, '[Google](google.com)', Key.ENTER);\n+    assert.equal(await gu.getCell(0, 3).find('a').getAttribute('href'), 'https://google.com/');\n+\n+    await gu.setFieldWidgetType('HyperLink');\n+    await gu.getCell(0, 3).click();\n+    await gu.sendKeys(Key.ENTER, await gu.selectAllKey(), Key.DELETE, 'Google google.com', Key.ENTER);\n+    assert.equal(await gu.getCell(0, 3).find('a').getAttribute('href'), 'https://google.com/');\n+  });\n+\n+  it('handles invalid URLs in HyperLink cells as \"about:blank\"', async function() {\n+    await gu.getCell(0, 3).click();\n+    await gu.sendKeys(Key.ENTER, await gu.selectAllKey(), Key.DELETE, '[Up to no good] javascript:alert()', Key.ENTER);\n+    assert.equal(await gu.getCell(0, 3).find('a').getAttribute('href'), 'about:blank');\n+  });\n+});"
        },
        {
          "filename": "yarn.lock",
          "status": "modified",
          "additions": 10,
          "deletions": 15,
          "patch": "@@ -828,13 +828,6 @@\n   resolved \"https://registry.npmjs.org/@types/diff-match-patch/-/diff-match-patch-1.0.32.tgz\"\n   integrity sha512-bPYT5ECFiblzsVzyURaNhljBH2Gh1t9LowgUwciMrNAhFewLkHT2H0Mto07Y4/3KCOGZHRQll3CTtQZ0X11D/A==\n \n-\"@types/dompurify@3.0.5\":\n-  version \"3.0.5\"\n-  resolved \"https://registry.yarnpkg.com/@types/dompurify/-/dompurify-3.0.5.tgz#02069a2fcb89a163bacf1a788f73cb415dd75cb7\"\n-  integrity sha512-1Wg0g3BtQF7sSb27fJQAKck1HECM6zV1EB66j8JH9i3LCjYabJa0FSdiSgsD5K/RbrsR0SiraKacLB+T8ZVYAg==\n-  dependencies:\n-    \"@types/trusted-types\" \"*\"\n-\n \"@types/double-ended-queue@2.1.0\":\n   version \"2.1.0\"\n   resolved \"https://registry.npmjs.org/@types/double-ended-queue/-/double-ended-queue-2.1.0.tgz\"\n@@ -1163,10 +1156,10 @@\n   resolved \"https://registry.npmjs.org/@types/tough-cookie/-/tough-cookie-4.0.2.tgz\"\n   integrity sha512-Q5vtl1W5ue16D+nIaW8JWebSSraJVlK+EthKn7e7UcD4KWsaSJ8BqGPXNaPghgtcn/fhvrN17Tv8ksUsQpiplw==\n \n-\"@types/trusted-types@*\":\n-  version \"2.0.3\"\n-  resolved \"https://registry.yarnpkg.com/@types/trusted-types/-/trusted-types-2.0.3.tgz#a136f83b0758698df454e328759dbd3d44555311\"\n-  integrity sha512-NfQ4gyz38SL8sDNrSixxU2Os1a5xcdFxipAFxYEuLUlvU2uDwS4NUpsImcf1//SlWItCVMMLiylsxbmNMToV/g==\n+\"@types/trusted-types@^2.0.7\":\n+  version \"2.0.7\"\n+  resolved \"https://registry.yarnpkg.com/@types/trusted-types/-/trusted-types-2.0.7.tgz#baccb07a970b91707df3a3e8ba6896c57ead2d11\"\n+  integrity sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==\n \n \"@types/underscore@*\":\n   version \"1.11.0\"\n@@ -3238,10 +3231,12 @@ domain-browser@~1.1.0:\n   resolved \"https://registry.npmjs.org/domain-browser/-/domain-browser-1.1.7.tgz\"\n   integrity sha1-hnqksJP6oF8d4IwG9NeyH9+GmLw=\n \n-dompurify@3.0.6:\n-  version \"3.0.6\"\n-  resolved \"https://registry.yarnpkg.com/dompurify/-/dompurify-3.0.6.tgz#925ebd576d54a9531b5d76f0a5bef32548351dae\"\n-  integrity sha512-ilkD8YEnnGh1zJ240uJsW7AzE+2qpbOUYjacomn3AvJ6J4JhKGSZ2nh4wUIXPZrEPppaCLx5jFe8T89Rk8tQ7w==\n+dompurify@3.2.3:\n+  version \"3.2.3\"\n+  resolved \"https://registry.yarnpkg.com/dompurify/-/dompurify-3.2.3.tgz#05dd2175225324daabfca6603055a09b2382a4cd\"\n+  integrity sha512-U1U5Hzc2MO0oW3DF+G9qYN0aT7atAou4AgI0XjWz061nyBPbdxkfdhfy5uMgGn6+oLFCfn44ZGbdDqCzVmlOWA==\n+  optionalDependencies:\n+    \"@types/trusted-types\" \"^2.0.7\"\n \n dot-prop@^5.2.0:\n   version \"5.2.0\""
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 1,
        "dependency_files": 1,
        "test_files": 5,
        "unique_directories": 11,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d6b95121b0678644ad56db44e7a26a1b5adf7f07",
            "date": "2025-01-14T21:29:08Z",
            "author_login": "paulfitz"
          },
          {
            "sha": "e0772fe15e7a201e9c091eee8e9e41d812be9bc8",
            "date": "2025-01-14T21:04:16Z",
            "author_login": "fflorent"
          },
          {
            "sha": "e5bba90b782572a2c6322fe693c246020bb3c7b5",
            "date": "2025-01-14T18:56:03Z",
            "author_login": "audez"
          },
          {
            "sha": "bf1585a987fa527898c110f442694db75fbd765d",
            "date": "2025-01-14T00:49:02Z",
            "author_login": "berhalak"
          },
          {
            "sha": "d03d87ea02af1b66eb5e8feb9d11019b3d4b9003",
            "date": "2025-01-13T17:37:38Z",
            "author_login": "jordigh"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "cwe_id": "CWE-79",
    "description": "grist-core is a spreadsheet hosting server. A user visiting a malicious document and previewing an attachment could have their account compromised, because JavaScript in an SVG file would be evaluated in the context of their current page. This issue has been patched in version 1.3.2. Users are advised to upgrade. Users unable to upgrade should avoid previewing attachments in documents prepared by people they do not trust.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-12-20T21:15:10.673",
    "last_modified": "2024-12-20T21:15:10.673",
    "fix_date": "2024-12-13T21:10:33Z"
  },
  "references": [
    {
      "url": "https://github.com/gristlabs/grist-core/commit/a792bdc43b456dbdd6fdc50d8747f4c349fab2f4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/gristlabs/grist-core/security/advisories/GHSA-jvfm-gf4f-33q3",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.900727",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "grist-core",
    "owner": "gristlabs",
    "created_at": "2020-05-22T06:16:02Z",
    "updated_at": "2025-01-14T15:54:19Z",
    "pushed_at": "2025-01-14T06:31:17Z",
    "size": 32790,
    "stars": 7502,
    "forks": 341,
    "open_issues": 461,
    "watchers": 7502,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "TypeScript": 9719662,
      "Python": 1741433,
      "JavaScript": 1069390,
      "CSS": 146584,
      "Shell": 17346,
      "HTML": 9284,
      "Dockerfile": 8424,
      "Makefile": 1019
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T16:19:11.406908"
  }
}