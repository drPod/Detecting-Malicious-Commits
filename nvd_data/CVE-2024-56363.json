{
  "cve_id": "CVE-2024-56363",
  "github_data": {
    "repository": "APTRS/APTRS",
    "fix_commit": "9f6b6e4a56a9119eb12126a4909441e83b6d7c11",
    "related_commits": [
      "9f6b6e4a56a9119eb12126a4909441e83b6d7c11"
    ],
    "patch_url": "https://github.com/APTRS/APTRS/commit/9f6b6e4a56a9119eb12126a4909441e83b6d7c11.patch",
    "fix_commit_details": {
      "sha": "9f6b6e4a56a9119eb12126a4909441e83b6d7c11",
      "commit_date": "2024-12-22T16:57:52Z",
      "author": {
        "login": "Anof-cyber",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Fixed SSTI",
        "length": 10,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 167,
        "additions": 62,
        "deletions": 105
      },
      "files": [
        {
          "filename": "APTRS/lib/htmldocx.py",
          "status": "modified",
          "additions": 21,
          "deletions": 13,
          "patch": "@@ -21,7 +21,8 @@\n import urllib.request\n from urllib.parse import urlparse\n from html.parser import HTMLParser\n-\n+import requests\n+from requests.packages.urllib3.exceptions import InsecureRequestWarning\n import docx, docx.table\n from docx import Document\n from docx.shared import RGBColor, Pt, Inches\n@@ -52,20 +53,25 @@ def is_url(url):\n     care if it's a url or a file path, and they're pretty distinguishable\n     \"\"\"\n     parts = urlparse(url)\n+    print(all([parts.scheme, parts.netloc, parts.path]))\n     return all([parts.scheme, parts.netloc, parts.path])\n \n-def fetch_image(url):\n+def fetch_image(url, headers, base_url):\n     \"\"\"\n     Attempts to fetch an image from a url. \n     If successful returns a bytes object, else returns None\n \n     :return:\n     \"\"\"\n-    try:\n-        with urllib.request.urlopen(url) as response:\n-            # security flaw?\n-            return io.BytesIO(response.read())\n-    except urllib.error.URLError:\n+    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n+    full_url = base_url + url\n+    headers = {\n+        \"Authorization\": f\"Bearer {headers}\"\n+    }\n+    response = requests.get(full_url, headers=headers,verify=False)\n+    if response.status_code == 200:\n+        return io.BytesIO(response.content)\n+    else:\n         return None\n \n def remove_last_occurence(ls, x):\n@@ -183,7 +189,7 @@ def __init__(self):\n         self.table_style = DEFAULT_TABLE_STYLE\n         self.paragraph_style = DEFAULT_PARAGRAPH_STYLE\n \n-    def set_initial_attrs(self, document=None):\n+    def set_initial_attrs(self, document=None, headers=None, base_url=None):\n         self.tags = {\n             'span': [],\n             'list': [],\n@@ -192,6 +198,8 @@ def set_initial_attrs(self, document=None):\n             self.doc = document\n         else:\n             self.doc = Document()\n+        self.headers = headers\n+        self.base_url = base_url\n         self.bs = self.options['fix-html'] # whether or not to clean with BeautifulSoup\n         self.document = self.doc\n         self.include_tables = True #TODO add this option back in?\n@@ -307,10 +315,10 @@ def handle_img(self, current_attrs):\n             return\n         src = current_attrs['src']\n         # fetch image\n-        src_is_url = is_url(src)\n+        src_is_url = True #is_url(self.base_url + src) APTRS does not support local images\n         if src_is_url:\n             try:\n-                image = fetch_image(src)\n+                image = fetch_image(src,self.headers, self.base_url)\n             except urllib.error.URLError:\n                 image = None\n         else:\n@@ -319,7 +327,7 @@ def handle_img(self, current_attrs):\n         if image:\n             try:\n                 if isinstance(self.doc, docx.document.Document):\n-                    self.doc.add_picture(image)\n+                    self.doc.add_picture(image,width=Inches(6.69291), height=Inches(4.2244094))\n                 else:\n                     self.add_image_to_cell(self.doc, image)\n             except FileNotFoundError:\n@@ -629,12 +637,12 @@ def run_process(self, html):\n             self.get_tables()\n         self.feed(html)\n \n-    def add_html_to_document(self, html, document):\n+    def add_html_to_document(self, html, document,headers, base_url):\n         if not isinstance(html, str):\n             raise ValueError('First argument needs to be a %s' % str)\n         elif not isinstance(document, docx.document.Document) and not isinstance(document, docx.table._Cell):\n             raise ValueError('Second argument needs to be a %s' % docx.document.Document)\n-        self.set_initial_attrs(document)\n+        self.set_initial_attrs(document,headers, base_url)\n         self.run_process(html)\n \n     def add_html_to_cell(self, html, cell):"
        },
        {
          "filename": "APTRS/project/report.py",
          "status": "modified",
          "additions": 4,
          "deletions": 8,
          "patch": "@@ -18,7 +18,7 @@\n from docxtpl import DocxTemplate,RichText\n from django.shortcuts import get_object_or_404\n from datetime import datetime\n-import jinja2\n+from jinja2.sandbox import SandboxedEnvironment\n import html\n import traceback\n \n@@ -36,18 +36,14 @@\n token = None\n \n \n-def CheckReport(Report_format,Report_type,pk,url,standard,request):\n+def CheckReport(Report_format,Report_type,pk,url,standard,request,access_token):\n     global base_url\n     base_url = url\n     if Report_format == \"excel\":\n         response =  CreateExcel(pk)\n \n     global token\n-    auth_header = request.headers.get('Authorization')\n-    if auth_header:\n-        token = auth_header.split(' ')[1] if auth_header.startswith('Bearer ') else None\n-    else:\n-        token = request.cookies.get('access_token')\n+    token = access_token\n     if Report_format == \"docx\":\n         response = generate_vulnerability_document(pk,Report_type,standard)\n     if Report_format == \"pdf\":\n@@ -107,7 +103,7 @@ def generate_vulnerability_document(pk,Report_type,standard):\n                 'standard':standard,'totalvulnerability':totalvulnerability,'totalretest':totalretest,'projectscope':projectscope,\n                 'page_break': RichText('\\f'),'new_line': RichText('\\n')\n                 }\n-        jinja_env = jinja2.Environment()\n+        jinja_env = SandboxedEnvironment(autoescape=True)\n         jinja_env.trim_blocks = True\n         jinja_env.lstrip_blocks = True\n         doc.render(context,jinja_env)"
        },
        {
          "filename": "APTRS/project/views/project.py",
          "status": "modified",
          "additions": 5,
          "deletions": 3,
          "patch": "@@ -5,7 +5,7 @@\n from django.core.cache import cache\n from django.utils.decorators import method_decorator\n from django.views.decorators.cache import cache_page\n-\n+from rest_framework_simplejwt.tokens import RefreshToken\n from rest_framework import status, views\n from rest_framework.decorators import (api_view, permission_classes)\n from rest_framework.permissions import IsAuthenticated,IsAdminUser\n@@ -266,6 +266,8 @@ def project_report(request, pk):\n     except ValueError as e:\n         logging.error(f\"Error: {e}\")\n         return Response({\"Status\": \"Failed\", \"Message\": \"Report Standards are not provided\"})\n-        \n-    output = CheckReport(report_format,report_type,pk,url,standard,request)\n+    \n+    refresh = RefreshToken.for_user(request.user) # generate new token for user to access auth protected images for report, user token in request might be close to expiry, so refreshing it to have new 30 mins token\n+    access_token = refresh.access_token\n+    output = CheckReport(report_format,report_type,pk,url,standard,request,access_token)\n     return output"
        },
        {
          "filename": "APTRS/utils/doc_style.py",
          "status": "modified",
          "additions": 3,
          "deletions": 26,
          "patch": "@@ -3,8 +3,9 @@\n from docx import Document\n import io\n from lib.htmldocx import HtmlToDocx\n-from utils.image_parsing import find_images\n+import logging\n \n+logger = logging.getLogger(__name__)\n \n def apply_font_style(element, font_name, font_size):\n     if hasattr(element, 'font'):\n@@ -27,22 +28,8 @@ def get_subdoc(doc,raw_html, headers, base_url):\n     temp_parser = HtmlToDocx()\n \n     if raw_html is not None:\n-\n-        images = find_images(raw_html, headers, base_url)\n-        '''\n-        CKEDITOR HTML allow images like POC images, html imc tag will have src=/api/project/getimage/?filename=img-uuid.jpg\n-        The use of API allow to handle both case in case images stored on cloud bucket or locally\n-        with that images are mostly POC and contain senstive info, its easy to prevent direct access to image as /api/* need auth token.\n-        This also fix, ckeditor html direclty stored in db, if s3 url used in case of s3 allowed, having signed url in src would fail to load images if signed url expired \n-\n-        Adding fix for docxtpl , instead of url for src replacing it with image byte \n-        '''\n-        # Convert image src paths - doctpl does not support loading img over url, adding image full path\n-        for i, img in enumerate(images):\n-            raw_html = raw_html.replace(img['html_tag'], f\"{{{{img{i}}}}}\")\n-\n         # Convert HTML to temporary DOCX\n-        temp_parser.add_html_to_document(raw_html, temp_doc)\n+        temp_parser.add_html_to_document(raw_html, temp_doc,headers, base_url)\n \n         # Resize images in the temporary DOCX\n         ## https://stackoverflow.com/questions/76571366/resizing-all-images-in-a-word-document-using-python\n@@ -83,18 +70,8 @@ def get_subdoc(doc,raw_html, headers, base_url):\n         sub_docxtpl = DocxTemplate(subdoc_tmp)\n         context = {}\n \n-        # handle image bytes and place image byte as inline imaage in doc\n-        for i, img in enumerate(images):\n-            img_obj = InlineImage(sub_docxtpl, img['bytes'],width=Inches(6.69291), height=Inches(4.2244094))\n-            context[f\"img{i}\"] = img_obj\n-\n-        sub_docxtpl.render(context)\n         sub_docxtpl.save(subdoc_tmp)\n         subdoc_tmp.seek(0)\n-\n-\n-\n-\n         # Create docxtpl subdoc object\n         subdoc = doc.new_subdoc(subdoc_tmp)\n         return subdoc"
        },
        {
          "filename": "APTRS/utils/image_parsing.py",
          "status": "removed",
          "additions": 0,
          "deletions": 43,
          "patch": "@@ -1,43 +0,0 @@\n-import requests\n-from io import BytesIO\n-import re\n-from requests.packages.urllib3.exceptions import InsecureRequestWarning\n-\n-def fetch_image_bytes(image_url_or_path, headers, base_url):\n-    \"\"\"Fetch image bytes from a URL (S3) or from the local file system.\"\"\"\n-\n-    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n-\n-    image_url = base_url + image_url_or_path\n-    token_headers = {\n-                \"Authorization\": f\"Bearer {headers}\"\n-            }\n-    response = requests.get(image_url, headers=token_headers, verify=False)\n-    if response.status_code == 200:\n-        return BytesIO(response.content)\n-    else:\n-        raise Exception(f\"Failed to retrieve image from {image_url}, status code {response.status_code}\")\n-\n-def find_images(raw_html, headers, base_url):\n-    \"\"\"Find all <img> tags in raw HTML and replace with jinja2 placeholders.\"\"\"\n-    regex = r'<img.*?>'\n-    images = []\n-\n-    for cnt, match in enumerate(re.finditer(regex, raw_html)):\n-        image_metadata = {\n-            'id': cnt,\n-            'html_tag': match.group()\n-        }\n-\n-        # Extract image URL or path from the src attribute\n-        src_match = re.search(r'src=\"([^\"]+)\"', image_metadata['html_tag'])\n-        if src_match:\n-            image_url_or_path = src_match.group(1)\n-            image_metadata['image_url_or_path'] = image_url_or_path\n-\n-            # Fetch image bytes from the URL or local file system\n-            image_metadata['bytes'] = fetch_image_bytes(image_url_or_path, headers,base_url)\n-\n-        images.append(image_metadata)\n-\n-    return images"
        },
        {
          "filename": "APTRS/utils/validators.py",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -4,6 +4,8 @@\n from django.conf import settings\n from django.core.exceptions import ValidationError\n from django.utils.translation import gettext as _\n+from jinja2.sandbox import SandboxedEnvironment\n+from docxtpl import InlineImage\n \n ALLOWED_TAGS = settings.ALLOWED_TAGS\n \n@@ -121,4 +123,4 @@ def get_base_url(request=None):\n             base_url = f\"{request.scheme}://{request.get_host()}\"\n         else:\n             raise Exception(\"Request is required when not using Docker.\")\n-    return base_url\n\\ No newline at end of file\n+    return base_url"
        },
        {
          "filename": "README.md",
          "status": "modified",
          "additions": 26,
          "deletions": 11,
          "patch": "@@ -25,19 +25,10 @@ APTRS (Automated Penetration Testing Reporting System) is a Python and Django-ba\n ![GitHub contributors from allcontributors.org](https://img.shields.io/github/all-contributors/aptrs/aptrs)\n \n \n-**Support APTRS**\n-\n-\n-<a href=\"https://github.com/sponsors/APTRS\"><img src=\"https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=%23fe8e86\" alt=\"Sponsor APTRS\" width=\"230\" height=\"50\"></a>\n-<br/><br/>\n-\n-If you've found APTRS helpful and valuable, your support through donations is greatly appreciated.\n-\n-\n ## Documentation\n \n-> [!WARNING]  \n-> Please ensure to review the Deployment Guide for configuration and security instructions from the documentation.\n+> [!Note]  \n+> Please ensure to review the Installation and Deployment Guide from the documentation.\n \n \n \n@@ -50,7 +41,18 @@ If you've found APTRS helpful and valuable, your support through donations is gr\n > [!NOTE]  \n > Default creds are sourav.kalal@aptrs.com & I-am-Weak-Password-Please-Change-Me\n \n+Quick Installation\n+\n+> [!Warning]  \n+> Please ensure to review the documentation for Security Configuration for ENV and other Installation methods.\n \n+```bash\n+git clone https://github.com/APTRS/APTRS\n+cd APTRS\n+cp env.docker .env\n+nano .env\n+docker-compose up \n+```\n \n \n \n@@ -68,6 +70,19 @@ If you've found APTRS helpful and valuable, your support through donations is gr\n - Manage Project Status, Schedules and Retest\n \n \n+## Support APTRS\n+\n+If you've found APTRS helpful and valuable, please consider supporting the project. Your donations are crucial in helping maintain and improve APTRS, which is primarily maintained by a single dedicated developer. Your support will ensure the continued development of new features, timely updates, and the overall sustainability of the project. Every contribution, no matter how small, makes a significant difference and is greatly appreciated. Thank you for your generosity and support!\n+<div style=\"display: flex; flex-direction: column; align-items: center; border: 1px solid #000; padding: 10px; width: 350px;\"><b>Bitcoin</b>\n+  <img src=\"https://raw.githubusercontent.com/APTRS/APTRS-Changelog/refs/heads/main/images/BTC.png\" alt=\"BTC Wallet QR Code\" width=\"200\" height=\"200\">\n+  <p style=\"margin-top: 10px; text-align: center;\">bc1qusxngf2w5gl2g8hw82ggct59227k4963f9fwhm</p>\n+</div>\n+<br/><br/>\n+<a href=\"https://github.com/sponsors/APTRS\"><img src=\"https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=%23fe8e86\" alt=\"Sponsor APTRS\" width=\"230\" height=\"50\"></a>\n+<br/><br/>\n+\n+\n+\n ## Sponsor\n \n <p>This project is supported by:</p>"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 5,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "43276c8ef17158686ae146a4190376e68ea7e9be",
            "date": "2024-12-27T12:56:59Z",
            "author_login": "allcontributors[bot]"
          },
          {
            "sha": "b327a87bbfcb5640763434a94124ed949b092a45",
            "date": "2024-12-27T12:53:16Z",
            "author_login": "0xdeviner"
          },
          {
            "sha": "3c9f926de2a0f32126e72b3c7cc630a27ffafe7b",
            "date": "2024-12-27T12:26:22Z",
            "author_login": "Anof-cyber"
          },
          {
            "sha": "1e462a2dedd9247487ea324ef67dd03aab04888c",
            "date": "2024-12-27T07:03:26Z",
            "author_login": "Anof-cyber"
          },
          {
            "sha": "5792ced2a9095cd77c826f9b232dfc5fa05af9af",
            "date": "2024-12-26T15:44:42Z",
            "author_login": "Anof-cyber"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
    "cwe_id": "CWE-97",
    "description": "APTRS (Automated Penetration Testing Reporting System) is a Python and Django-based automated reporting tool designed for penetration testers and security organizations. In 1.0, there is a vulnerability in the web application's handling of user-supplied input that is incorporated into a Jinja2 template. Specifically, when user input is improperly sanitized or validated, an attacker can inject Jinja2 syntax into the template, causing the server to execute arbitrary code. For example, an attacker might be able to inject expressions like {{ config }}, {{ self.class.mro[1].subclasses() }}, or more dangerous payloads that trigger execution of arbitrary Python code. The vulnerability can be reproduced by submitting crafted input to all the template fields handled by ckeditor, that are passed directly to a Jinja2 template. If the input is rendered without sufficient sanitization, it results in the execution of malicious Jinja2 code on the server.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-12-23T18:15:07.767",
    "last_modified": "2024-12-23T18:15:07.767",
    "fix_date": "2024-12-22T16:57:52Z"
  },
  "references": [
    {
      "url": "https://github.com/APTRS/APTRS/commit/9f6b6e4a56a9119eb12126a4909441e83b6d7c11",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/APTRS/APTRS/security/advisories/GHSA-h4w2-hvcg-938j",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.905789",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "APTRS",
    "owner": "APTRS",
    "created_at": "2022-10-28T16:15:37Z",
    "updated_at": "2025-01-12T22:06:16Z",
    "pushed_at": "2024-12-27T12:56:59Z",
    "size": 10746,
    "stars": 821,
    "forks": 98,
    "open_issues": 10,
    "watchers": 821,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "API",
      "main"
    ],
    "languages": {
      "TypeScript": 372371,
      "Python": 229118,
      "CSS": 165410,
      "JavaScript": 42966,
      "HTML": 15916,
      "Shell": 1544
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T13:06:38.128620"
  }
}