{
  "cve_id": "CVE-2024-5642",
  "github_data": {
    "repository": "python/cpython",
    "fix_commit": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "related_commits": [
      "39258d3595300bc7b952854c915f63ae2d4b9c3e",
      "39258d3595300bc7b952854c915f63ae2d4b9c3e"
    ],
    "patch_url": "https://github.com/python/cpython/commit/39258d3595300bc7b952854c915f63ae2d4b9c3e.patch",
    "fix_commit_details": {
      "sha": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
      "commit_date": "2021-04-17T09:36:35Z",
      "author": {
        "login": "tiran",
        "type": "User",
        "stats": {
          "total_commits": 1757,
          "average_weekly_commits": 0.9771968854282537,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 208
        }
      },
      "commit_message": {
        "title": "bpo-43669: PEP 644: Require OpenSSL 1.1.1 or newer (GH-23014)",
        "length": 953,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 13750,
        "additions": 5310,
        "deletions": 8440
      },
      "files": [
        {
          "filename": ".github/workflows/build.yml",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -177,7 +177,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        openssl_ver: [1.0.2u, 1.1.0l, 1.1.1k, 3.0.0-alpha14]\n+        openssl_ver: [1.1.1k, 3.0.0-alpha14]\n     env:\n       OPENSSL_VER: ${{ matrix.openssl_ver }}\n       MULTISSL_DIR: ${{ github.workspace }}/multissl"
        },
        {
          "filename": "Doc/using/unix.rst",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -135,6 +135,7 @@ some Unices may not have the :program:`env` command, so you may need to hardcode\n \n To use shell commands in your Python scripts, look at the :mod:`subprocess` module.\n \n+.. _unix_custom_openssl:\n \n Custom OpenSSL\n =============="
        },
        {
          "filename": "Doc/whatsnew/3.10.rst",
          "status": "modified",
          "additions": 5,
          "deletions": 1,
          "patch": "@@ -65,6 +65,7 @@ Summary -- Release highlights\n \n .. PEP-sized items next.\n \n+* :pep:`644`, require OpenSSL 1.1.1 or newer\n \n \n New Features\n@@ -1438,6 +1439,10 @@ CPython bytecode changes\n Build Changes\n =============\n \n+* :pep:`644`: Python now requires OpenSSL 1.1.1 or newer. OpenSSL 1.0.2 is no\n+  longer supported.\n+  (Contributed by Christian Heimes in :issue:`43669`.)\n+\n * The C99 functions :c:func:`snprintf` and :c:func:`vsnprintf` are now required\n   to build Python.\n   (Contributed by Victor Stinner in :issue:`36020`.)\n@@ -1483,7 +1488,6 @@ Build Changes\n   (Contributed by Christian Heimes in :issue:`43466`.)\n \n \n-\n C API Changes\n =============\n "
        },
        {
          "filename": "Lib/ssl.py",
          "status": "modified",
          "additions": 2,
          "deletions": 8,
          "patch": "@@ -909,15 +909,12 @@ def selected_npn_protocol(self):\n         \"\"\"Return the currently selected NPN protocol as a string, or ``None``\n         if a next protocol was not negotiated or if NPN is not supported by one\n         of the peers.\"\"\"\n-        if _ssl.HAS_NPN:\n-            return self._sslobj.selected_npn_protocol()\n \n     def selected_alpn_protocol(self):\n         \"\"\"Return the currently selected ALPN protocol as a string, or ``None``\n         if a next protocol was not negotiated or if ALPN is not supported by one\n         of the peers.\"\"\"\n-        if _ssl.HAS_ALPN:\n-            return self._sslobj.selected_alpn_protocol()\n+        return self._sslobj.selected_alpn_protocol()\n \n     def cipher(self):\n         \"\"\"Return the currently selected cipher as a 3-tuple ``(name,\n@@ -1126,10 +1123,7 @@ def getpeercert(self, binary_form=False):\n     @_sslcopydoc\n     def selected_npn_protocol(self):\n         self._checkClosed()\n-        if self._sslobj is None or not _ssl.HAS_NPN:\n-            return None\n-        else:\n-            return self._sslobj.selected_npn_protocol()\n+        return None\n \n     @_sslcopydoc\n     def selected_alpn_protocol(self):"
        },
        {
          "filename": "Lib/test/test_ssl.py",
          "status": "modified",
          "additions": 26,
          "deletions": 93,
          "patch": "@@ -40,7 +40,6 @@\n PROTOCOLS = sorted(ssl._PROTOCOL_NAMES)\n HOST = socket_helper.HOST\n IS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')\n-IS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)\n IS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)\n IS_OPENSSL_3_0_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)\n PY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')\n@@ -270,18 +269,6 @@ def handle_error(prefix):\n     if support.verbose:\n         sys.stdout.write(prefix + exc_format)\n \n-def can_clear_options():\n-    # 0.9.8m or higher\n-    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n-\n-def no_sslv2_implies_sslv3_hello():\n-    # 0.9.7h or higher\n-    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n-\n-def have_verify_flags():\n-    # 0.9.8 or higher\n-    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)\n-\n def _have_secp_curves():\n     if not ssl.HAS_ECDH:\n         return False\n@@ -372,17 +359,15 @@ def test_constants(self):\n         ssl.OP_SINGLE_DH_USE\n         if ssl.HAS_ECDH:\n             ssl.OP_SINGLE_ECDH_USE\n-        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n-            ssl.OP_NO_COMPRESSION\n+        ssl.OP_NO_COMPRESSION\n         self.assertIn(ssl.HAS_SNI, {True, False})\n         self.assertIn(ssl.HAS_ECDH, {True, False})\n         ssl.OP_NO_SSLv2\n         ssl.OP_NO_SSLv3\n         ssl.OP_NO_TLSv1\n         ssl.OP_NO_TLSv1_3\n-        if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):\n-            ssl.OP_NO_TLSv1_1\n-            ssl.OP_NO_TLSv1_2\n+        ssl.OP_NO_TLSv1_1\n+        ssl.OP_NO_TLSv1_2\n         self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)\n \n     def test_private_init(self):\n@@ -1161,7 +1146,6 @@ def test_python_ciphers(self):\n             self.assertNotIn(\"RC4\", name)\n             self.assertNotIn(\"3DES\", name)\n \n-    @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')\n     def test_get_ciphers(self):\n         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n         ctx.set_ciphers('AESGCM')\n@@ -1181,15 +1165,11 @@ def test_options(self):\n         self.assertEqual(default, ctx.options)\n         ctx.options |= ssl.OP_NO_TLSv1\n         self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)\n-        if can_clear_options():\n-            ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)\n-            self.assertEqual(default, ctx.options)\n-            ctx.options = 0\n-            # Ubuntu has OP_NO_SSLv3 forced on by default\n-            self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)\n-        else:\n-            with self.assertRaises(ValueError):\n-                ctx.options = 0\n+        ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)\n+        self.assertEqual(default, ctx.options)\n+        ctx.options = 0\n+        # Ubuntu has OP_NO_SSLv3 forced on by default\n+        self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)\n \n     def test_verify_mode_protocol(self):\n         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n@@ -1327,8 +1307,6 @@ def test_security_level(self):\n         }\n         self.assertIn(ctx.security_level, security_level_range)\n \n-    @unittest.skipUnless(have_verify_flags(),\n-                         \"verify_flags need OpenSSL > 0.9.8\")\n     def test_verify_flags(self):\n         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n         # default value\n@@ -1797,7 +1775,6 @@ class MySSLObject(ssl.SSLObject):\n         obj = ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO())\n         self.assertIsInstance(obj, MySSLObject)\n \n-    @unittest.skipUnless(IS_OPENSSL_1_1_1, \"Test requires OpenSSL 1.1.1\")\n     def test_num_tickest(self):\n         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n         self.assertEqual(ctx.num_tickets, 2)\n@@ -2956,8 +2933,6 @@ def test_getpeercert(self):\n                 after = ssl.cert_time_to_seconds(cert['notAfter'])\n                 self.assertLess(before, after)\n \n-    @unittest.skipUnless(have_verify_flags(),\n-                        \"verify_flags need OpenSSL > 0.9.8\")\n     def test_crl_check(self):\n         if support.verbose:\n             sys.stdout.write(\"\\n\")\n@@ -3859,12 +3834,7 @@ def test_version_basic(self):\n                 self.assertIs(s.version(), None)\n                 self.assertIs(s._sslobj, None)\n                 s.connect((HOST, server.port))\n-                if IS_OPENSSL_1_1_1 and has_tls_version('TLSv1_3'):\n-                    self.assertEqual(s.version(), 'TLSv1.3')\n-                elif ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):\n-                    self.assertEqual(s.version(), 'TLSv1.2')\n-                else:  # 0.9.8 to 1.0.1\n-                    self.assertIn(s.version(), ('TLSv1', 'TLSv1.2'))\n+                self.assertEqual(s.version(), 'TLSv1.3')\n             self.assertIs(s._sslobj, None)\n             self.assertIs(s.version(), None)\n \n@@ -3966,8 +3936,6 @@ def test_default_ecdh_curve(self):\n         # explicitly using the 'ECCdraft' cipher alias.  Otherwise,\n         # our default cipher list should prefer ECDH-based ciphers\n         # automatically.\n-        if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):\n-            context.set_ciphers(\"ECCdraft:ECDH\")\n         with ThreadedEchoServer(context=context) as server:\n             with context.wrap_socket(socket.socket()) as s:\n                 s.connect((HOST, server.port))\n@@ -4099,15 +4067,11 @@ def test_ecdh_curve(self):\n         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n         try:\n-            stats = server_params_test(client_context, server_context,\n-                                       chatty=True, connectionchatty=True,\n-                                       sni_name=hostname)\n+            server_params_test(client_context, server_context,\n+                               chatty=True, connectionchatty=True,\n+                               sni_name=hostname)\n         except ssl.SSLError:\n-            pass\n-        else:\n-            # OpenSSL 1.0.2 does not fail although it should.\n-            if IS_OPENSSL_1_1_0:\n-                self.fail(\"mismatch curve did not fail\")\n+            self.fail(\"mismatch curve did not fail\")\n \n     def test_selected_alpn_protocol(self):\n         # selected_alpn_protocol() is None unless ALPN is used.\n@@ -4117,7 +4081,6 @@ def test_selected_alpn_protocol(self):\n                                    sni_name=hostname)\n         self.assertIs(stats['client_alpn_protocol'], None)\n \n-    @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support required\")\n     def test_selected_alpn_protocol_if_server_uses_alpn(self):\n         # selected_alpn_protocol() is None unless ALPN is used by the client.\n         client_context, server_context, hostname = testing_context()\n@@ -4127,7 +4090,6 @@ def test_selected_alpn_protocol_if_server_uses_alpn(self):\n                                    sni_name=hostname)\n         self.assertIs(stats['client_alpn_protocol'], None)\n \n-    @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support needed for this test\")\n     def test_alpn_protocols(self):\n         server_protocols = ['foo', 'bar', 'milkshake']\n         protocol_tests = [\n@@ -4150,22 +4112,17 @@ def test_alpn_protocols(self):\n             except ssl.SSLError as e:\n                 stats = e\n \n-            if (expected is None and IS_OPENSSL_1_1_0\n-                    and ssl.OPENSSL_VERSION_INFO < (1, 1, 0, 6)):\n-                # OpenSSL 1.1.0 to 1.1.0e raises handshake error\n-                self.assertIsInstance(stats, ssl.SSLError)\n-            else:\n-                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n-                    \"was expecting %s, but got %%s from the %%s\" \\\n-                        % (str(server_protocols), str(client_protocols),\n-                            str(expected))\n-                client_result = stats['client_alpn_protocol']\n-                self.assertEqual(client_result, expected,\n-                                 msg % (client_result, \"client\"))\n-                server_result = stats['server_alpn_protocols'][-1] \\\n-                    if len(stats['server_alpn_protocols']) else 'nothing'\n-                self.assertEqual(server_result, expected,\n-                                 msg % (server_result, \"server\"))\n+            msg = \"failed trying %s (s) and %s (c).\\n\" \\\n+                \"was expecting %s, but got %%s from the %%s\" \\\n+                    % (str(server_protocols), str(client_protocols),\n+                        str(expected))\n+            client_result = stats['client_alpn_protocol']\n+            self.assertEqual(client_result, expected,\n+                             msg % (client_result, \"client\"))\n+            server_result = stats['server_alpn_protocols'][-1] \\\n+                if len(stats['server_alpn_protocols']) else 'nothing'\n+            self.assertEqual(server_result, expected,\n+                             msg % (server_result, \"server\"))\n \n     def test_selected_npn_protocol(self):\n         # selected_npn_protocol() is None unless NPN is used\n@@ -4175,31 +4132,8 @@ def test_selected_npn_protocol(self):\n                                    sni_name=hostname)\n         self.assertIs(stats['client_npn_protocol'], None)\n \n-    @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n     def test_npn_protocols(self):\n-        server_protocols = ['http/1.1', 'spdy/2']\n-        protocol_tests = [\n-            (['http/1.1', 'spdy/2'], 'http/1.1'),\n-            (['spdy/2', 'http/1.1'], 'http/1.1'),\n-            (['spdy/2', 'test'], 'spdy/2'),\n-            (['abc', 'def'], 'abc')\n-        ]\n-        for client_protocols, expected in protocol_tests:\n-            client_context, server_context, hostname = testing_context()\n-            server_context.set_npn_protocols(server_protocols)\n-            client_context.set_npn_protocols(client_protocols)\n-            stats = server_params_test(client_context, server_context,\n-                                       chatty=True, connectionchatty=True,\n-                                       sni_name=hostname)\n-            msg = \"failed trying %s (s) and %s (c).\\n\" \\\n-                  \"was expecting %s, but got %%s from the %%s\" \\\n-                      % (str(server_protocols), str(client_protocols),\n-                         str(expected))\n-            client_result = stats['client_npn_protocol']\n-            self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n-            server_result = stats['server_npn_protocols'][-1] \\\n-                if len(stats['server_npn_protocols']) else 'nothing'\n-            self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n+        assert not ssl.HAS_NPN\n \n     def sni_contexts(self):\n         server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n@@ -4369,8 +4303,7 @@ def test_session(self):\n         self.assertGreater(session.time, 0)\n         self.assertGreater(session.timeout, 0)\n         self.assertTrue(session.has_ticket)\n-        if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):\n-            self.assertGreater(session.ticket_lifetime_hint, 0)\n+        self.assertGreater(session.ticket_lifetime_hint, 0)\n         self.assertFalse(stats['session_reused'])\n         sess_stat = server_context.session_stats()\n         self.assertEqual(sess_stat['accept'], 1)"
        },
        {
          "filename": "Misc/NEWS.d/next/Build/2021-03-30-14-19-39.bpo-43669.lWMUYx.rst",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Implement :pep:`644`. Python now requires OpenSSL 1.1.1 or newer."
        },
        {
          "filename": "Modules/Setup",
          "status": "modified",
          "additions": 17,
          "deletions": 5,
          "patch": "@@ -207,11 +207,23 @@ _symtable symtablemodule.c\n #_socket socketmodule.c\n \n # Socket module helper for SSL support; you must comment out the other\n-# socket line above, and possibly edit the SSL variable:\n-#SSL=/usr/local/ssl\n-#_ssl _ssl.c \\\n-#\t-DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \\\n-#\t-L$(SSL)/lib -lssl -lcrypto\n+# socket line above, and edit the OPENSSL variable:\n+# OPENSSL=/path/to/openssl/directory\n+# _ssl _ssl.c \\\n+#     -I$(OPENSSL)/include -L$(OPENSSL)/lib \\\n+#     -lssl -lcrypto\n+#_hashlib _hashopenssl.c \\\n+#     -I$(OPENSSL)/include -L$(OPENSSL)/lib \\\n+#     -lcrypto\n+\n+# To statically link OpenSSL:\n+# _ssl _ssl.c \\\n+#     -I$(OPENSSL)/include -L$(OPENSSL)/lib \\\n+#     -l:libssl.a -Wl,--exclude-libs,libssl.a \\\n+#     -l:libcrypto.a -Wl,--exclude-libs,libcrypto.a\n+#_hashlib _hashopenssl.c \\\n+#     -I$(OPENSSL)/include -L$(OPENSSL)/lib \\\n+#     -l:libcrypto.a -Wl,--exclude-libs,libcrypto.a\n \n # The crypt module is now disabled by default because it breaks builds\n # on many systems (where -lcrypt is needed), e.g. Linux (I believe)."
        },
        {
          "filename": "Modules/_hashopenssl.c",
          "status": "modified",
          "additions": 3,
          "deletions": 63,
          "patch": "@@ -38,51 +38,12 @@\n #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"\n #endif\n \n-#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n-/* OpenSSL < 1.1.0 */\n-#define EVP_MD_CTX_new EVP_MD_CTX_create\n-#define EVP_MD_CTX_free EVP_MD_CTX_destroy\n-\n-HMAC_CTX *\n-HMAC_CTX_new(void)\n-{\n-    HMAC_CTX *ctx = OPENSSL_malloc(sizeof(HMAC_CTX));\n-    if (ctx != NULL) {\n-        memset(ctx, 0, sizeof(HMAC_CTX));\n-        HMAC_CTX_init(ctx);\n-    }\n-    return ctx;\n-}\n-\n-void\n-HMAC_CTX_free(HMAC_CTX *ctx)\n-{\n-    if (ctx != NULL) {\n-        HMAC_CTX_cleanup(ctx);\n-        OPENSSL_free(ctx);\n-    }\n-}\n-\n-const EVP_MD *\n-HMAC_CTX_get_md(const HMAC_CTX *ctx)\n-{\n-    return ctx->md;\n-}\n-#endif\n-\n #define MUNCH_SIZE INT_MAX\n \n-#ifdef NID_sha3_224\n+#define PY_OPENSSL_HAS_SCRYPT 1\n #define PY_OPENSSL_HAS_SHA3 1\n-#endif\n-\n-#if defined(EVP_MD_FLAG_XOF) && defined(NID_shake128)\n #define PY_OPENSSL_HAS_SHAKE 1\n-#endif\n-\n-#if defined(NID_blake2b512) && !defined(OPENSSL_NO_BLAKE2)\n #define PY_OPENSSL_HAS_BLAKE2 1\n-#endif\n \n static PyModuleDef _hashlibmodule;\n \n@@ -1252,8 +1213,7 @@ pbkdf2_hmac_impl(PyObject *module, const char *hash_name,\n     return key_obj;\n }\n \n-#if OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER)\n-#define PY_SCRYPT 1\n+#ifdef PY_OPENSSL_HAS_SCRYPT\n \n /* XXX: Parameters salt, n, r and p should be required keyword-only parameters.\n    They are optional in the Argument Clinic declaration only due to a\n@@ -1376,7 +1336,7 @@ _hashlib_scrypt_impl(PyObject *module, Py_buffer *password, Py_buffer *salt,\n     }\n     return key_obj;\n }\n-#endif\n+#endif  /* PY_OPENSSL_HAS_SCRYPT */\n \n /* Fast HMAC for hmac.digest()\n  */\n@@ -1844,12 +1804,6 @@ hashlib_md_meth_names(PyObject *module)\n     return 0;\n }\n \n-/* LibreSSL doesn't support FIPS:\n-   https://marc.info/?l=openbsd-misc&m=139819485423701&w=2\n-\n-   Ted Unangst wrote: \"I figured I should mention our current libressl policy\n-   wrt FIPS mode.  It's gone and it's not coming back.\" */\n-#ifndef LIBRESSL_VERSION_NUMBER\n /*[clinic input]\n _hashlib.get_fips_mode -> int\n \n@@ -1887,7 +1841,6 @@ _hashlib_get_fips_mode_impl(PyObject *module)\n     return result;\n #endif\n }\n-#endif  // !LIBRESSL_VERSION_NUMBER\n \n \n static int\n@@ -2067,17 +2020,6 @@ hashlib_free(void *m)\n }\n \n /* Py_mod_exec functions */\n-static int\n-hashlib_openssl_legacy_init(PyObject *module)\n-{\n-#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n-    /* Load all digest algorithms and initialize cpuid */\n-    OPENSSL_add_all_algorithms_noconf();\n-    ERR_load_crypto_strings();\n-#endif\n-    return 0;\n-}\n-\n static int\n hashlib_init_evptype(PyObject *module)\n {\n@@ -2200,8 +2142,6 @@ hashlib_exception(PyObject *module)\n \n \n static PyModuleDef_Slot hashlib_slots[] = {\n-    /* OpenSSL 1.0.2 and LibreSSL */\n-    {Py_mod_exec, hashlib_openssl_legacy_init},\n     {Py_mod_exec, hashlib_init_evptype},\n     {Py_mod_exec, hashlib_init_evpxoftype},\n     {Py_mod_exec, hashlib_init_hmactype},"
        },
        {
          "filename": "Modules/_ssl.c",
          "status": "modified",
          "additions": 10,
          "deletions": 527,
          "patch": "@@ -29,9 +29,9 @@\n #define _PySSL_FIX_ERRNO\n \n #define PySSL_BEGIN_ALLOW_THREADS_S(save) \\\n-    do { if (_ssl_locks_count>0) { (save) = PyEval_SaveThread(); } } while (0)\n+    do { (save) = PyEval_SaveThread(); } while(0)\n #define PySSL_END_ALLOW_THREADS_S(save) \\\n-    do { if (_ssl_locks_count>0) { PyEval_RestoreThread(save); } _PySSL_FIX_ERRNO; } while (0)\n+    do { PyEval_RestoreThread(save); _PySSL_FIX_ERRNO; } while(0)\n #define PySSL_BEGIN_ALLOW_THREADS { \\\n             PyThreadState *_save = NULL;  \\\n             PySSL_BEGIN_ALLOW_THREADS_S(_save);\n@@ -62,16 +62,6 @@ static PySocketModule_APIObject PySocketModule;\n #include \"openssl/bio.h\"\n #include \"openssl/dh.h\"\n \n-#ifndef HAVE_X509_VERIFY_PARAM_SET1_HOST\n-#  ifdef LIBRESSL_VERSION_NUMBER\n-#    error \"LibreSSL is missing X509_VERIFY_PARAM_set1_host(), see https://github.com/libressl-portable/portable/issues/381\"\n-#  elif OPENSSL_VERSION_NUMBER > 0x1000200fL\n-#    define HAVE_X509_VERIFY_PARAM_SET1_HOST\n-#  else\n-#    error \"libssl is too old and does not support X509_VERIFY_PARAM_set1_host()\"\n-#  endif\n-#endif\n-\n #ifndef OPENSSL_THREADS\n #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"\n #endif\n@@ -142,15 +132,7 @@ static void _PySSLFixErrno(void) {\n #include \"_ssl_data.h\"\n #endif\n \n-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n-#  define OPENSSL_VERSION_1_1 1\n-#  define PY_OPENSSL_1_1_API 1\n-#endif\n-\n-/* OpenSSL API 1.1.0+ does not include version methods. Define the methods\n- * unless OpenSSL is compiled without the methods. It's the easiest way to\n- * make 1.0.2, 1.1.0, 1.1.1, and 3.0.0 happy without deprecation warnings.\n- */\n+/* OpenSSL API 1.1.0+ does not include version methods */\n #ifndef OPENSSL_NO_TLS1_METHOD\n extern const SSL_METHOD *TLSv1_method(void);\n #endif\n@@ -161,129 +143,12 @@ extern const SSL_METHOD *TLSv1_1_method(void);\n extern const SSL_METHOD *TLSv1_2_method(void);\n #endif\n \n-/* LibreSSL 2.7.0 provides necessary OpenSSL 1.1.0 APIs */\n-#if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x2070000fL\n-#  define PY_OPENSSL_1_1_API 1\n-#endif\n-\n-/* SNI support (client- and server-side) appeared in OpenSSL 1.0.0 and 0.9.8f\n- * This includes the SSL_set_SSL_CTX() function.\n- */\n-#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n-# define HAVE_SNI 1\n-#else\n-# define HAVE_SNI 0\n-#endif\n-\n-#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n-# define HAVE_ALPN 1\n-#else\n-# define HAVE_ALPN 0\n-#endif\n-\n-/* We cannot rely on OPENSSL_NO_NEXTPROTONEG because LibreSSL 2.6.1 dropped\n- * NPN support but did not set OPENSSL_NO_NEXTPROTONEG for compatibility\n- * reasons. The check for TLSEXT_TYPE_next_proto_neg works with\n- * OpenSSL 1.0.1+ and LibreSSL.\n- * OpenSSL 1.1.1-pre1 dropped NPN but still has TLSEXT_TYPE_next_proto_neg.\n- */\n-#ifdef OPENSSL_NO_NEXTPROTONEG\n-# define HAVE_NPN 0\n-#elif (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)\n-# define HAVE_NPN 0\n-#elif defined(TLSEXT_TYPE_next_proto_neg)\n-# define HAVE_NPN 1\n-#else\n-# define HAVE_NPN 0\n-#endif\n-\n-#if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)\n-#define HAVE_OPENSSL_KEYLOG 1\n-#endif\n-\n #ifndef INVALID_SOCKET /* MS defines this */\n #define INVALID_SOCKET (-1)\n #endif\n \n-/* OpenSSL 1.0.2 and LibreSSL needs extra code for locking */\n-#ifndef OPENSSL_VERSION_1_1\n-#define HAVE_OPENSSL_CRYPTO_LOCK\n-#endif\n-\n-#if defined(OPENSSL_VERSION_1_1) && !defined(OPENSSL_NO_SSL2)\n+/* OpenSSL 1.1 does not have SSL 2.0 */\n #define OPENSSL_NO_SSL2\n-#endif\n-\n-#ifndef PY_OPENSSL_1_1_API\n-/* OpenSSL 1.1 API shims for OpenSSL < 1.1.0 and LibreSSL < 2.7.0 */\n-\n-#define TLS_method SSLv23_method\n-#define TLS_client_method SSLv23_client_method\n-#define TLS_server_method SSLv23_server_method\n-#define ASN1_STRING_get0_data ASN1_STRING_data\n-#define X509_get0_notBefore X509_get_notBefore\n-#define X509_get0_notAfter X509_get_notAfter\n-#define OpenSSL_version_num SSLeay\n-#define OpenSSL_version SSLeay_version\n-#define OPENSSL_VERSION SSLEAY_VERSION\n-\n-static int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne)\n-{\n-    return ne->set;\n-}\n-\n-#ifndef OPENSSL_NO_COMP\n-/* LCOV_EXCL_START */\n-static int COMP_get_type(const COMP_METHOD *meth)\n-{\n-    return meth->type;\n-}\n-/* LCOV_EXCL_STOP */\n-#endif\n-\n-static pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx)\n-{\n-    return ctx->default_passwd_callback;\n-}\n-\n-static void *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx)\n-{\n-    return ctx->default_passwd_callback_userdata;\n-}\n-\n-static int X509_OBJECT_get_type(X509_OBJECT *x)\n-{\n-    return x->type;\n-}\n-\n-static X509 *X509_OBJECT_get0_X509(X509_OBJECT *x)\n-{\n-    return x->data.x509;\n-}\n-\n-static int BIO_up_ref(BIO *b)\n-{\n-    CRYPTO_add(&b->references, 1, CRYPTO_LOCK_BIO);\n-    return 1;\n-}\n-\n-static STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *store) {\n-    return store->objs;\n-}\n-\n-static int\n-SSL_SESSION_has_ticket(const SSL_SESSION *s)\n-{\n-    return (s->tlsext_ticklen > 0) ? 1 : 0;\n-}\n-\n-static unsigned long\n-SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *s)\n-{\n-    return s->tlsext_tick_lifetime_hint;\n-}\n-\n-#endif /* OpenSSL < 1.1.0 or LibreSSL < 2.7.0 */\n \n /* Default cipher suites */\n #ifndef PY_SSL_DEFAULT_CIPHERS\n@@ -395,24 +260,10 @@ enum py_proto_version {\n #endif\n };\n \n-\n-/* serves as a flag to see whether we've initialized the SSL thread support. */\n-/* 0 means no, greater than 0 means yes */\n-\n-static unsigned int _ssl_locks_count = 0;\n-\n /* SSL socket object */\n \n #define X509_NAME_MAXLEN 256\n \n-/* SSL_CTX_clear_options() and SSL_clear_options() were first added in\n- * OpenSSL 0.9.8m but do not appear in some 0.9.9-dev versions such the\n- * 0.9.9 from \"May 2008\" that NetBSD 5.0 uses. */\n-#if OPENSSL_VERSION_NUMBER >= 0x009080dfL && OPENSSL_VERSION_NUMBER != 0x00909000L\n-# define HAVE_SSL_CTX_CLEAR_OPTIONS\n-#else\n-# undef HAVE_SSL_CTX_CLEAR_OPTIONS\n-#endif\n \n /* In case of 'tls-unique' it will be 12 bytes for TLS, 36 bytes for\n  * older SSL, but let's be safe */\n@@ -422,17 +273,9 @@ static unsigned int _ssl_locks_count = 0;\n typedef struct {\n     PyObject_HEAD\n     SSL_CTX *ctx;\n-#if HAVE_NPN\n-    unsigned char *npn_protocols;\n-    int npn_protocols_len;\n-#endif\n-#if HAVE_ALPN\n     unsigned char *alpn_protocols;\n     unsigned int alpn_protocols_len;\n-#endif\n-#ifndef OPENSSL_NO_TLSEXT\n     PyObject *set_sni_cb;\n-#endif\n     int check_hostname;\n     /* OpenSSL has no API to get hostflags from X509_VERIFY_PARAM* struct.\n      * We have to maintain our own copy. OpenSSL's hostflags default to 0.\n@@ -443,10 +286,8 @@ typedef struct {\n     int post_handshake_auth;\n #endif\n     PyObject *msg_cb;\n-#ifdef HAVE_OPENSSL_KEYLOG\n     PyObject *keylog_filename;\n     BIO *keylog_bio;\n-#endif\n } PySSLContext;\n \n typedef struct {\n@@ -652,23 +493,18 @@ fill_and_set_sslerror(PySSLSocket *sslsock, PyObject *type, int ssl_errno,\n         }\n \n         switch (verify_code) {\n-#ifdef X509_V_ERR_HOSTNAME_MISMATCH\n-        /* OpenSSL >= 1.0.2, LibreSSL >= 2.5.3 */\n         case X509_V_ERR_HOSTNAME_MISMATCH:\n             verify_obj = PyUnicode_FromFormat(\n                 \"Hostname mismatch, certificate is not valid for '%S'.\",\n                 sslsock->server_hostname\n             );\n             break;\n-#endif\n-#ifdef X509_V_ERR_IP_ADDRESS_MISMATCH\n         case X509_V_ERR_IP_ADDRESS_MISMATCH:\n             verify_obj = PyUnicode_FromFormat(\n                 \"IP address mismatch, certificate is not valid for '%S'.\",\n                 sslsock->server_hostname\n             );\n             break;\n-#endif\n         default:\n             verify_str = X509_verify_cert_error_string(verify_code);\n             if (verify_str != NULL) {\n@@ -1995,7 +1831,6 @@ cipher_to_tuple(const SSL_CIPHER *cipher)\n     return NULL;\n }\n \n-#if OPENSSL_VERSION_NUMBER >= 0x10002000UL\n static PyObject *\n cipher_to_dict(const SSL_CIPHER *cipher)\n {\n@@ -2004,10 +1839,8 @@ cipher_to_dict(const SSL_CIPHER *cipher)\n     unsigned long cipher_id;\n     int alg_bits, strength_bits, len;\n     char buf[512] = {0};\n-#if OPENSSL_VERSION_1_1\n     int aead, nid;\n     const char *skcipher = NULL, *digest = NULL, *kx = NULL, *auth = NULL;\n-#endif\n \n     /* can be NULL */\n     cipher_name = SSL_CIPHER_get_name(cipher);\n@@ -2020,7 +1853,6 @@ cipher_to_dict(const SSL_CIPHER *cipher)\n         buf[len-1] = '\\0';\n     strength_bits = SSL_CIPHER_get_bits(cipher, &alg_bits);\n \n-#if OPENSSL_VERSION_1_1\n     aead = SSL_CIPHER_is_aead(cipher);\n     nid = SSL_CIPHER_get_cipher_nid(cipher);\n     skcipher = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n@@ -2030,30 +1862,24 @@ cipher_to_dict(const SSL_CIPHER *cipher)\n     kx = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n     nid = SSL_CIPHER_get_auth_nid(cipher);\n     auth = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;\n-#endif\n \n     return Py_BuildValue(\n         \"{sksssssssisi\"\n-#if OPENSSL_VERSION_1_1\n         \"sOssssssss\"\n-#endif\n         \"}\",\n         \"id\", cipher_id,\n         \"name\", cipher_name,\n         \"protocol\", cipher_protocol,\n         \"description\", buf,\n         \"strength_bits\", strength_bits,\n         \"alg_bits\", alg_bits\n-#if OPENSSL_VERSION_1_1\n         ,\"aead\", aead ? Py_True : Py_False,\n         \"symmetric\", skcipher,\n         \"digest\", digest,\n         \"kea\", kx,\n         \"auth\", auth\n-#endif\n        );\n }\n-#endif\n \n /*[clinic input]\n _ssl._SSLSocket.shared_ciphers\n@@ -2124,28 +1950,6 @@ _ssl__SSLSocket_version_impl(PySSLSocket *self)\n     return PyUnicode_FromString(version);\n }\n \n-#if HAVE_NPN\n-/*[clinic input]\n-_ssl._SSLSocket.selected_npn_protocol\n-[clinic start generated code]*/\n-\n-static PyObject *\n-_ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self)\n-/*[clinic end generated code: output=b91d494cd207ecf6 input=c28fde139204b826]*/\n-{\n-    const unsigned char *out;\n-    unsigned int outlen;\n-\n-    SSL_get0_next_proto_negotiated(self->ssl,\n-                                   &out, &outlen);\n-\n-    if (out == NULL)\n-        Py_RETURN_NONE;\n-    return PyUnicode_FromStringAndSize((char *)out, outlen);\n-}\n-#endif\n-\n-#if HAVE_ALPN\n /*[clinic input]\n _ssl._SSLSocket.selected_alpn_protocol\n [clinic start generated code]*/\n@@ -2163,7 +1967,6 @@ _ssl__SSLSocket_selected_alpn_protocol_impl(PySSLSocket *self)\n         Py_RETURN_NONE;\n     return PyUnicode_FromStringAndSize((char *)out, outlen);\n }\n-#endif\n \n /*[clinic input]\n _ssl._SSLSocket.compression\n@@ -2200,11 +2003,6 @@ static int PySSL_set_context(PySSLSocket *self, PyObject *value,\n                                    void *closure) {\n \n     if (PyObject_TypeCheck(value, PySSLContext_Type)) {\n-#if !HAVE_SNI\n-        PyErr_SetString(PyExc_NotImplementedError, \"setting a socket's \"\n-                        \"context is not supported by your OpenSSL library\");\n-        return -1;\n-#else\n         Py_INCREF(value);\n         Py_SETREF(self->ctx, (PySSLContext *)value);\n         SSL_set_SSL_CTX(self->ssl, self->ctx->ctx);\n@@ -2213,7 +2011,6 @@ static int PySSL_set_context(PySSLSocket *self, PyObject *value,\n             self->ssl,\n             self->ctx->msg_cb ? _PySSL_msg_callback : NULL\n         );\n-#endif\n     } else {\n         PyErr_SetString(PyExc_TypeError, \"The value must be a SSLContext\");\n         return -1;\n@@ -2840,8 +2637,6 @@ _ssl__SSLSocket_verify_client_post_handshake_impl(PySSLSocket *self)\n #endif\n }\n \n-#ifdef OPENSSL_VERSION_1_1\n-\n static SSL_SESSION*\n _ssl_session_dup(SSL_SESSION *session) {\n     SSL_SESSION *newsession = NULL;\n@@ -2882,7 +2677,6 @@ _ssl_session_dup(SSL_SESSION *session) {\n     }\n     return NULL;\n }\n-#endif\n \n static PyObject *\n PySSL_get_session(PySSLSocket *self, void *closure) {\n@@ -2891,7 +2685,6 @@ PySSL_get_session(PySSLSocket *self, void *closure) {\n     PySSLSession *pysess;\n     SSL_SESSION *session;\n \n-#ifdef OPENSSL_VERSION_1_1\n     /* duplicate session as workaround for session bug in OpenSSL 1.1.0,\n      * https://github.com/openssl/openssl/issues/1550 */\n     session = SSL_get0_session(self->ssl);  /* borrowed reference */\n@@ -2901,12 +2694,10 @@ PySSL_get_session(PySSLSocket *self, void *closure) {\n     if ((session = _ssl_session_dup(session)) == NULL) {\n         return NULL;\n     }\n-#else\n     session = SSL_get1_session(self->ssl);\n     if (session == NULL) {\n         Py_RETURN_NONE;\n     }\n-#endif\n     pysess = PyObject_GC_New(PySSLSession, PySSLSession_Type);\n     if (pysess == NULL) {\n         SSL_SESSION_free(session);\n@@ -2925,9 +2716,7 @@ static int PySSL_set_session(PySSLSocket *self, PyObject *value,\n                              void *closure)\n                               {\n     PySSLSession *pysess;\n-#ifdef OPENSSL_VERSION_1_1\n     SSL_SESSION *session;\n-#endif\n     int result;\n \n     if (!PySSLSession_Check(value)) {\n@@ -2951,17 +2740,13 @@ static int PySSL_set_session(PySSLSocket *self, PyObject *value,\n                         \"Cannot set session after handshake.\");\n         return -1;\n     }\n-#ifdef OPENSSL_VERSION_1_1\n     /* duplicate session */\n     if ((session = _ssl_session_dup(pysess->session)) == NULL) {\n         return -1;\n     }\n     result = SSL_set_session(self->ssl, session);\n     /* free duplicate, SSL_set_session() bumps ref count */\n     SSL_SESSION_free(session);\n-#else\n-    result = SSL_set_session(self->ssl, pysess->session);\n-#endif\n     if (result == 0) {\n         _setSSLError(NULL, 0, __FILE__, __LINE__);\n         return -1;\n@@ -3012,7 +2797,6 @@ static PyMethodDef PySSLMethods[] = {\n     _SSL__SSLSOCKET_CIPHER_METHODDEF\n     _SSL__SSLSOCKET_SHARED_CIPHERS_METHODDEF\n     _SSL__SSLSOCKET_VERSION_METHODDEF\n-    _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF\n     _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF\n     _SSL__SSLSOCKET_COMPRESSION_METHODDEF\n     _SSL__SSLSOCKET_SHUTDOWN_METHODDEF\n@@ -3089,9 +2873,6 @@ _ssl__SSLContext_impl(PyTypeObject *type, int proto_version)\n     SSL_CTX *ctx = NULL;\n     X509_VERIFY_PARAM *params;\n     int result;\n-#if defined(SSL_MODE_RELEASE_BUFFERS)\n-    unsigned long libver;\n-#endif\n \n     PySSL_BEGIN_ALLOW_THREADS\n     switch(proto_version) {\n@@ -3156,19 +2937,10 @@ _ssl__SSLContext_impl(PyTypeObject *type, int proto_version)\n     self->hostflags = X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;\n     self->protocol = proto_version;\n     self->msg_cb = NULL;\n-#ifdef HAVE_OPENSSL_KEYLOG\n     self->keylog_filename = NULL;\n     self->keylog_bio = NULL;\n-#endif\n-#if HAVE_NPN\n-    self->npn_protocols = NULL;\n-#endif\n-#if HAVE_ALPN\n     self->alpn_protocols = NULL;\n-#endif\n-#ifndef OPENSSL_NO_TLSEXT\n     self->set_sni_cb = NULL;\n-#endif\n     /* Don't check host name by default */\n     if (proto_version == PY_SSL_VERSION_TLS_CLIENT) {\n         self->check_hostname = 1;\n@@ -3230,49 +3002,19 @@ _ssl__SSLContext_impl(PyTypeObject *type, int proto_version)\n         return NULL;\n     }\n \n-#if defined(SSL_MODE_RELEASE_BUFFERS)\n     /* Set SSL_MODE_RELEASE_BUFFERS. This potentially greatly reduces memory\n-       usage for no cost at all. However, don't do this for OpenSSL versions\n-       between 1.0.1 and 1.0.1h or 1.0.0 and 1.0.0m, which are affected by CVE\n-       2014-0198. I can't find exactly which beta fixed this CVE, so be\n-       conservative and assume it wasn't fixed until release. We do this check\n-       at runtime to avoid problems from the dynamic linker.\n-       See #25672 for more on this. */\n-    libver = OpenSSL_version_num();\n-    if (!(libver >= 0x10001000UL && libver < 0x1000108fUL) &&\n-        !(libver >= 0x10000000UL && libver < 0x100000dfUL)) {\n-        SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);\n-    }\n-#endif\n-\n-\n-#if !defined(OPENSSL_NO_ECDH) && !defined(OPENSSL_VERSION_1_1)\n-    /* Allow automatic ECDH curve selection (on OpenSSL 1.0.2+), or use\n-       prime256v1 by default.  This is Apache mod_ssl's initialization\n-       policy, so we should be safe. OpenSSL 1.1 has it enabled by default.\n-     */\n-#if defined(SSL_CTX_set_ecdh_auto)\n-    SSL_CTX_set_ecdh_auto(self->ctx, 1);\n-#else\n-    {\n-        EC_KEY *key = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n-        SSL_CTX_set_tmp_ecdh(self->ctx, key);\n-        EC_KEY_free(key);\n-    }\n-#endif\n-#endif\n+       usage for no cost at all. */\n+    SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);\n \n #define SID_CTX \"Python\"\n     SSL_CTX_set_session_id_context(self->ctx, (const unsigned char *) SID_CTX,\n                                    sizeof(SID_CTX));\n #undef SID_CTX\n \n     params = SSL_CTX_get0_param(self->ctx);\n-#ifdef X509_V_FLAG_TRUSTED_FIRST\n     /* Improve trust chain building when cross-signed intermediate\n        certificates are present. See https://bugs.python.org/issue23476. */\n     X509_VERIFY_PARAM_set_flags(params, X509_V_FLAG_TRUSTED_FIRST);\n-#endif\n     X509_VERIFY_PARAM_set_hostflags(params, self->hostflags);\n \n #ifdef TLS1_3_VERSION\n@@ -3286,29 +3028,23 @@ _ssl__SSLContext_impl(PyTypeObject *type, int proto_version)\n static int\n context_traverse(PySSLContext *self, visitproc visit, void *arg)\n {\n-#ifndef OPENSSL_NO_TLSEXT\n     Py_VISIT(self->set_sni_cb);\n-#endif\n     Py_VISIT(self->msg_cb);\n     return 0;\n }\n \n static int\n context_clear(PySSLContext *self)\n {\n-#ifndef OPENSSL_NO_TLSEXT\n     Py_CLEAR(self->set_sni_cb);\n-#endif\n     Py_CLEAR(self->msg_cb);\n-#ifdef HAVE_OPENSSL_KEYLOG\n     Py_CLEAR(self->keylog_filename);\n     if (self->keylog_bio != NULL) {\n         PySSL_BEGIN_ALLOW_THREADS\n         BIO_free_all(self->keylog_bio);\n         PySSL_END_ALLOW_THREADS\n         self->keylog_bio = NULL;\n     }\n-#endif\n     return 0;\n }\n \n@@ -3320,12 +3056,7 @@ context_dealloc(PySSLContext *self)\n     PyObject_GC_UnTrack(self);\n     context_clear(self);\n     SSL_CTX_free(self->ctx);\n-#if HAVE_NPN\n-    PyMem_Free(self->npn_protocols);\n-#endif\n-#if HAVE_ALPN\n-    PyMem_Free(self->alpn_protocols);\n-#endif\n+    PyMem_FREE(self->alpn_protocols);\n     Py_TYPE(self)->tp_free(self);\n     Py_DECREF(tp);\n }\n@@ -3353,7 +3084,6 @@ _ssl__SSLContext_set_ciphers_impl(PySSLContext *self, const char *cipherlist)\n     Py_RETURN_NONE;\n }\n \n-#if OPENSSL_VERSION_NUMBER >= 0x10002000UL\n /*[clinic input]\n _ssl._SSLContext.get_ciphers\n [clinic start generated code]*/\n@@ -3396,10 +3126,8 @@ _ssl__SSLContext_get_ciphers_impl(PySSLContext *self)\n     return result;\n \n }\n-#endif\n \n \n-#if HAVE_NPN || HAVE_ALPN\n static int\n do_protocol_selection(int alpn, unsigned char **out, unsigned char *outlen,\n                       const unsigned char *server_protocols, unsigned int server_protocols_len,\n@@ -3423,77 +3151,7 @@ do_protocol_selection(int alpn, unsigned char **out, unsigned char *outlen,\n \n     return SSL_TLSEXT_ERR_OK;\n }\n-#endif\n-\n-#if HAVE_NPN\n-/* this callback gets passed to SSL_CTX_set_next_protos_advertise_cb */\n-static int\n-_advertiseNPN_cb(SSL *s,\n-                 const unsigned char **data, unsigned int *len,\n-                 void *args)\n-{\n-    PySSLContext *ssl_ctx = (PySSLContext *) args;\n-\n-    if (ssl_ctx->npn_protocols == NULL) {\n-        *data = (unsigned char *)\"\";\n-        *len = 0;\n-    } else {\n-        *data = ssl_ctx->npn_protocols;\n-        *len = ssl_ctx->npn_protocols_len;\n-    }\n \n-    return SSL_TLSEXT_ERR_OK;\n-}\n-/* this callback gets passed to SSL_CTX_set_next_proto_select_cb */\n-static int\n-_selectNPN_cb(SSL *s,\n-              unsigned char **out, unsigned char *outlen,\n-              const unsigned char *server, unsigned int server_len,\n-              void *args)\n-{\n-    PySSLContext *ctx = (PySSLContext *)args;\n-    return do_protocol_selection(0, out, outlen, server, server_len,\n-                                 ctx->npn_protocols, ctx->npn_protocols_len);\n-}\n-#endif\n-\n-/*[clinic input]\n-_ssl._SSLContext._set_npn_protocols\n-    protos: Py_buffer\n-    /\n-[clinic start generated code]*/\n-\n-static PyObject *\n-_ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,\n-                                         Py_buffer *protos)\n-/*[clinic end generated code: output=72b002c3324390c6 input=319fcb66abf95bd7]*/\n-{\n-#if HAVE_NPN\n-    PyMem_Free(self->npn_protocols);\n-    self->npn_protocols = PyMem_Malloc(protos->len);\n-    if (self->npn_protocols == NULL)\n-        return PyErr_NoMemory();\n-    memcpy(self->npn_protocols, protos->buf, protos->len);\n-    self->npn_protocols_len = (int) protos->len;\n-\n-    /* set both server and client callbacks, because the context can\n-     * be used to create both types of sockets */\n-    SSL_CTX_set_next_protos_advertised_cb(self->ctx,\n-                                          _advertiseNPN_cb,\n-                                          self);\n-    SSL_CTX_set_next_proto_select_cb(self->ctx,\n-                                     _selectNPN_cb,\n-                                     self);\n-\n-    Py_RETURN_NONE;\n-#else\n-    PyErr_SetString(PyExc_NotImplementedError,\n-                    \"The NPN extension requires OpenSSL 1.0.1 or later.\");\n-    return NULL;\n-#endif\n-}\n-\n-#if HAVE_ALPN\n static int\n _selectALPN_cb(SSL *s,\n               const unsigned char **out, unsigned char *outlen,\n@@ -3505,7 +3163,6 @@ _selectALPN_cb(SSL *s,\n                                  ctx->alpn_protocols, ctx->alpn_protocols_len,\n                                  client_protocols, client_protocols_len);\n }\n-#endif\n \n /*[clinic input]\n _ssl._SSLContext._set_alpn_protocols\n@@ -3518,7 +3175,6 @@ _ssl__SSLContext__set_alpn_protocols_impl(PySSLContext *self,\n                                           Py_buffer *protos)\n /*[clinic end generated code: output=87599a7f76651a9b input=9bba964595d519be]*/\n {\n-#if HAVE_ALPN\n     if ((size_t)protos->len > UINT_MAX) {\n         PyErr_Format(PyExc_OverflowError,\n             \"protocols longer than %u bytes\", UINT_MAX);\n@@ -3537,11 +3193,6 @@ _ssl__SSLContext__set_alpn_protocols_impl(PySSLContext *self,\n     SSL_CTX_set_alpn_select_cb(self->ctx, _selectALPN_cb, self);\n \n     Py_RETURN_NONE;\n-#else\n-    PyErr_SetString(PyExc_NotImplementedError,\n-                    \"The ALPN extension requires OpenSSL 1.0.2 or later.\");\n-    return NULL;\n-#endif\n }\n \n static PyObject *\n@@ -3617,9 +3268,6 @@ set_verify_flags(PySSLContext *self, PyObject *arg, void *c)\n }\n \n /* Getter and setter for protocol version */\n-#if defined(SSL_CTRL_GET_MAX_PROTO_VERSION)\n-\n-\n static int\n set_min_max_proto_version(PySSLContext *self, PyObject *arg, int what)\n {\n@@ -3714,9 +3362,8 @@ set_maximum_version(PySSLContext *self, PyObject *arg, void *c)\n {\n     return set_min_max_proto_version(self, arg, 1);\n }\n-#endif /* SSL_CTRL_GET_MAX_PROTO_VERSION */\n \n-#if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)\n+#ifdef TLS1_3_VERSION\n static PyObject *\n get_num_tickets(PySSLContext *self, void *c)\n {\n@@ -3747,16 +3394,14 @@ set_num_tickets(PySSLContext *self, PyObject *arg, void *c)\n \n PyDoc_STRVAR(PySSLContext_num_tickets_doc,\n \"Control the number of TLSv1.3 session tickets\");\n-#endif /* OpenSSL 1.1.1 */\n+#endif /* TLS1_3_VERSION */\n \n-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n static PyObject *\n get_security_level(PySSLContext *self, void *c)\n {\n     return PyLong_FromLong(SSL_CTX_get_security_level(self->ctx));\n }\n PyDoc_STRVAR(PySSLContext_security_level_doc, \"The current security level\");\n-#endif /* OpenSSL 1.1.0 */\n \n static PyObject *\n get_options(PySSLContext *self, void *c)\n@@ -3774,13 +3419,7 @@ set_options(PySSLContext *self, PyObject *arg, void *c)\n     clear = opts & ~new_opts;\n     set = ~opts & new_opts;\n     if (clear) {\n-#ifdef HAVE_SSL_CTX_CLEAR_OPTIONS\n         SSL_CTX_clear_options(self->ctx, clear);\n-#else\n-        PyErr_SetString(PyExc_ValueError,\n-                        \"can't clear options before OpenSSL 0.9.8m\");\n-        return -1;\n-#endif\n     }\n     if (set)\n         SSL_CTX_set_options(self->ctx, set);\n@@ -4468,7 +4107,6 @@ _ssl__SSLContext_set_default_verify_paths_impl(PySSLContext *self)\n     Py_RETURN_NONE;\n }\n \n-#ifndef OPENSSL_NO_ECDH\n /*[clinic input]\n _ssl._SSLContext.set_ecdh_curve\n     name: object\n@@ -4503,9 +4141,7 @@ _ssl__SSLContext_set_ecdh_curve(PySSLContext *self, PyObject *name)\n     EC_KEY_free(key);\n     Py_RETURN_NONE;\n }\n-#endif\n \n-#if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)\n static int\n _servername_callback(SSL *s, int *al, void *args)\n {\n@@ -4609,7 +4245,6 @@ _servername_callback(SSL *s, int *al, void *args)\n     PyGILState_Release(gstate);\n     return ret;\n }\n-#endif\n \n static PyObject *\n get_sni_callback(PySSLContext *self, void *c)\n@@ -4630,7 +4265,6 @@ set_sni_callback(PySSLContext *self, PyObject *arg, void *c)\n                         \"sni_callback cannot be set on TLS_CLIENT context\");\n         return -1;\n     }\n-#if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)\n     Py_CLEAR(self->set_sni_cb);\n     if (arg == Py_None) {\n         SSL_CTX_set_tlsext_servername_callback(self->ctx, NULL);\n@@ -4648,13 +4282,6 @@ set_sni_callback(PySSLContext *self, PyObject *arg, void *c)\n         SSL_CTX_set_tlsext_servername_arg(self->ctx, self);\n     }\n     return 0;\n-#else\n-    PyErr_SetString(PyExc_NotImplementedError,\n-                    \"The TLS extension servername callback, \"\n-                    \"SSL_CTX_set_tlsext_servername_callback, \"\n-                    \"is not in the current OpenSSL library.\");\n-    return -1;\n-#endif\n }\n \n PyDoc_STRVAR(PySSLContext_sni_callback_doc,\n@@ -4779,21 +4406,17 @@ static PyGetSetDef context_getsetlist[] = {\n                        (setter) set_check_hostname, NULL},\n     {\"_host_flags\", (getter) get_host_flags,\n                     (setter) set_host_flags, NULL},\n-#if SSL_CTRL_GET_MAX_PROTO_VERSION\n     {\"minimum_version\", (getter) get_minimum_version,\n                         (setter) set_minimum_version, NULL},\n     {\"maximum_version\", (getter) get_maximum_version,\n                         (setter) set_maximum_version, NULL},\n-#endif\n-#ifdef HAVE_OPENSSL_KEYLOG\n     {\"keylog_filename\", (getter) _PySSLContext_get_keylog_filename,\n                         (setter) _PySSLContext_set_keylog_filename, NULL},\n-#endif\n     {\"_msg_callback\", (getter) _PySSLContext_get_msg_callback,\n                       (setter) _PySSLContext_set_msg_callback, NULL},\n     {\"sni_callback\", (getter) get_sni_callback,\n                      (setter) set_sni_callback, PySSLContext_sni_callback_doc},\n-#if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)\n+#ifdef TLS1_3_VERSION\n     {\"num_tickets\", (getter) get_num_tickets,\n                     (setter) set_num_tickets, PySSLContext_num_tickets_doc},\n #endif\n@@ -4812,10 +4435,8 @@ static PyGetSetDef context_getsetlist[] = {\n                      (setter) set_verify_flags, NULL},\n     {\"verify_mode\", (getter) get_verify_mode,\n                     (setter) set_verify_mode, NULL},\n-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n     {\"security_level\", (getter) get_security_level,\n                        NULL, PySSLContext_security_level_doc},\n-#endif\n     {NULL},            /* sentinel */\n };\n \n@@ -4824,7 +4445,6 @@ static struct PyMethodDef context_methods[] = {\n     _SSL__SSLCONTEXT__WRAP_BIO_METHODDEF\n     _SSL__SSLCONTEXT_SET_CIPHERS_METHODDEF\n     _SSL__SSLCONTEXT__SET_ALPN_PROTOCOLS_METHODDEF\n-    _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF\n     _SSL__SSLCONTEXT_LOAD_CERT_CHAIN_METHODDEF\n     _SSL__SSLCONTEXT_LOAD_DH_PARAMS_METHODDEF\n     _SSL__SSLCONTEXT_LOAD_VERIFY_LOCATIONS_METHODDEF\n@@ -5281,11 +4901,7 @@ PySSL_RAND(int len, int pseudo)\n     if (bytes == NULL)\n         return NULL;\n     if (pseudo) {\n-#ifdef PY_OPENSSL_1_1_API\n         ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);\n-#else\n-        ok = RAND_pseudo_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);\n-#endif\n         if (ok == 0 || ok == 1)\n             return Py_BuildValue(\"NO\", bytes, ok == 1 ? Py_True : Py_False);\n     }\n@@ -5840,92 +5456,6 @@ static PyMethodDef PySSL_methods[] = {\n };\n \n \n-#ifdef HAVE_OPENSSL_CRYPTO_LOCK\n-\n-/* an implementation of OpenSSL threading operations in terms\n- * of the Python C thread library\n- * Only used up to 1.0.2. OpenSSL 1.1.0+ has its own locking code.\n- */\n-\n-static PyThread_type_lock *_ssl_locks = NULL;\n-\n-#if OPENSSL_VERSION_NUMBER >= 0x10000000\n-/* use new CRYPTO_THREADID API. */\n-static void\n-_ssl_threadid_callback(CRYPTO_THREADID *id)\n-{\n-    CRYPTO_THREADID_set_numeric(id, PyThread_get_thread_ident());\n-}\n-#else\n-/* deprecated CRYPTO_set_id_callback() API. */\n-static unsigned long\n-_ssl_thread_id_function (void) {\n-    return PyThread_get_thread_ident();\n-}\n-#endif\n-\n-static void _ssl_thread_locking_function\n-    (int mode, int n, const char *file, int line) {\n-    /* this function is needed to perform locking on shared data\n-       structures. (Note that OpenSSL uses a number of global data\n-       structures that will be implicitly shared whenever multiple\n-       threads use OpenSSL.) Multi-threaded applications will\n-       crash at random if it is not set.\n-\n-       locking_function() must be able to handle up to\n-       CRYPTO_num_locks() different mutex locks. It sets the n-th\n-       lock if mode & CRYPTO_LOCK, and releases it otherwise.\n-\n-       file and line are the file number of the function setting the\n-       lock. They can be useful for debugging.\n-    */\n-\n-    if ((_ssl_locks == NULL) ||\n-        (n < 0) || ((unsigned)n >= _ssl_locks_count))\n-        return;\n-\n-    if (mode & CRYPTO_LOCK) {\n-        PyThread_acquire_lock(_ssl_locks[n], 1);\n-    } else {\n-        PyThread_release_lock(_ssl_locks[n]);\n-    }\n-}\n-\n-static int _setup_ssl_threads(void) {\n-\n-    unsigned int i;\n-\n-    if (_ssl_locks == NULL) {\n-        _ssl_locks_count = CRYPTO_num_locks();\n-        _ssl_locks = PyMem_Calloc(_ssl_locks_count,\n-                                  sizeof(PyThread_type_lock));\n-        if (_ssl_locks == NULL) {\n-            PyErr_NoMemory();\n-            return 0;\n-        }\n-        for (i = 0;  i < _ssl_locks_count;  i++) {\n-            _ssl_locks[i] = PyThread_allocate_lock();\n-            if (_ssl_locks[i] == NULL) {\n-                unsigned int j;\n-                for (j = 0;  j < i;  j++) {\n-                    PyThread_free_lock(_ssl_locks[j]);\n-                }\n-                PyMem_Free(_ssl_locks);\n-                return 0;\n-            }\n-        }\n-        CRYPTO_set_locking_callback(_ssl_thread_locking_function);\n-#if OPENSSL_VERSION_NUMBER >= 0x10000000\n-        CRYPTO_THREADID_set_callback(_ssl_threadid_callback);\n-#else\n-        CRYPTO_set_id_callback(_ssl_thread_id_function);\n-#endif\n-    }\n-    return 1;\n-}\n-\n-#endif  /* HAVE_OPENSSL_CRYPTO_LOCK for OpenSSL < 1.1.0 */\n-\n static int\n sslmodule_init_types(PyObject *module)\n {\n@@ -6205,10 +5735,8 @@ sslmodule_init_constants(PyObject *m)\n                             X509_V_FLAG_X509_STRICT);\n     PyModule_AddIntConstant(m, \"VERIFY_ALLOW_PROXY_CERTS\",\n                             X509_V_FLAG_ALLOW_PROXY_CERTS);\n-#ifdef X509_V_FLAG_TRUSTED_FIRST\n     PyModule_AddIntConstant(m, \"VERIFY_X509_TRUSTED_FIRST\",\n                             X509_V_FLAG_TRUSTED_FIRST);\n-#endif\n \n     /* Alert Descriptions from ssl.h */\n     /* note RESERVED constants no longer intended for use have been removed */\n@@ -6365,31 +5893,11 @@ sslmodule_init_constants(PyObject *m)\n         PyModule_AddObject((m), (key), bool_obj); \\\n     } while (0)\n \n-#if HAVE_SNI\n     addbool(m, \"HAS_SNI\", 1);\n-#else\n-    addbool(m, \"HAS_SNI\", 0);\n-#endif\n-\n     addbool(m, \"HAS_TLS_UNIQUE\", 1);\n-\n-#ifndef OPENSSL_NO_ECDH\n     addbool(m, \"HAS_ECDH\", 1);\n-#else\n-    addbool(m, \"HAS_ECDH\", 0);\n-#endif\n-\n-#if HAVE_NPN\n-    addbool(m, \"HAS_NPN\", 1);\n-#else\n     addbool(m, \"HAS_NPN\", 0);\n-#endif\n-\n-#if HAVE_ALPN\n     addbool(m, \"HAS_ALPN\", 1);\n-#else\n-    addbool(m, \"HAS_ALPN\", 0);\n-#endif\n \n #if defined(SSL2_VERSION) && !defined(OPENSSL_NO_SSL2)\n     addbool(m, \"HAS_SSLv2\", 1);\n@@ -6430,29 +5938,6 @@ sslmodule_init_constants(PyObject *m)\n     return 0;\n }\n \n-static int\n-sslmodule_legacy(PyObject *module)\n-{\n-#ifndef OPENSSL_VERSION_1_1\n-    /* Load all algorithms and initialize cpuid */\n-    OPENSSL_add_all_algorithms_noconf();\n-    /* Init OpenSSL */\n-    SSL_load_error_strings();\n-    SSL_library_init();\n-#endif\n-\n-#ifdef HAVE_OPENSSL_CRYPTO_LOCK\n-    /* note that this will start threading if not already started */\n-    if (!_setup_ssl_threads()) {\n-        return 0;\n-    }\n-#elif OPENSSL_VERSION_1_1\n-    /* OpenSSL 1.1.0 builtin thread support is enabled */\n-    _ssl_locks_count++;\n-#endif\n-    return 0;\n-}\n-\n PyDoc_STRVAR(module_doc,\n \"Implementation module for SSL socket operations.  See the socket module\\n\\\n for documentation.\");\n@@ -6491,8 +5976,6 @@ PyInit__ssl(void)\n         return NULL;\n     if (sslmodule_init_versioninfo(m) != 0)\n         return NULL;\n-    if (sslmodule_legacy(m) != 0)\n-        return NULL;\n \n     return m;\n }"
        },
        {
          "filename": "Modules/_ssl/debughelpers.c",
          "status": "modified",
          "additions": 0,
          "deletions": 4,
          "patch": "@@ -114,8 +114,6 @@ _PySSLContext_set_msg_callback(PySSLContext *self, PyObject *arg, void *c) {\n     return 0;\n }\n \n-#ifdef HAVE_OPENSSL_KEYLOG\n-\n static void\n _PySSL_keylog_callback(const SSL *ssl, const char *line)\n {\n@@ -219,5 +217,3 @@ _PySSLContext_set_keylog_filename(PySSLContext *self, PyObject *arg, void *c) {\n     SSL_CTX_set_keylog_callback(self->ctx, _PySSL_keylog_callback);\n     return 0;\n }\n-\n-#endif"
        },
        {
          "filename": "Modules/clinic/_hashopenssl.c.h",
          "status": "modified",
          "additions": 3,
          "deletions": 11,
          "patch": "@@ -950,7 +950,7 @@ pbkdf2_hmac(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject\n     return return_value;\n }\n \n-#if (OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER))\n+#if defined(PY_OPENSSL_HAS_SCRYPT)\n \n PyDoc_STRVAR(_hashlib_scrypt__doc__,\n \"scrypt($module, /, password, *, salt=None, n=None, r=None, p=None,\\n\"\n@@ -1068,7 +1068,7 @@ _hashlib_scrypt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObj\n     return return_value;\n }\n \n-#endif /* (OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER)) */\n+#endif /* defined(PY_OPENSSL_HAS_SCRYPT) */\n \n PyDoc_STRVAR(_hashlib_hmac_singleshot__doc__,\n \"hmac_digest($module, /, key, msg, digest)\\n\"\n@@ -1275,8 +1275,6 @@ _hashlib_HMAC_hexdigest(HMACobject *self, PyObject *Py_UNUSED(ignored))\n     return _hashlib_HMAC_hexdigest_impl(self);\n }\n \n-#if !defined(LIBRESSL_VERSION_NUMBER)\n-\n PyDoc_STRVAR(_hashlib_get_fips_mode__doc__,\n \"get_fips_mode($module, /)\\n\"\n \"--\\n\"\n@@ -1312,8 +1310,6 @@ _hashlib_get_fips_mode(PyObject *module, PyObject *Py_UNUSED(ignored))\n     return return_value;\n }\n \n-#endif /* !defined(LIBRESSL_VERSION_NUMBER) */\n-\n PyDoc_STRVAR(_hashlib_compare_digest__doc__,\n \"compare_digest($module, a, b, /)\\n\"\n \"--\\n\"\n@@ -1389,8 +1385,4 @@ _hashlib_compare_digest(PyObject *module, PyObject *const *args, Py_ssize_t narg\n #ifndef _HASHLIB_SCRYPT_METHODDEF\n     #define _HASHLIB_SCRYPT_METHODDEF\n #endif /* !defined(_HASHLIB_SCRYPT_METHODDEF) */\n-\n-#ifndef _HASHLIB_GET_FIPS_MODE_METHODDEF\n-    #define _HASHLIB_GET_FIPS_MODE_METHODDEF\n-#endif /* !defined(_HASHLIB_GET_FIPS_MODE_METHODDEF) */\n-/*[clinic end generated code: output=980087de1b03ad42 input=a9049054013a1b77]*/\n+/*[clinic end generated code: output=162369cb9d43f1cc input=a9049054013a1b77]*/"
        },
        {
          "filename": "Modules/clinic/_ssl.c.h",
          "status": "modified",
          "additions": 1,
          "deletions": 86,
          "patch": "@@ -139,29 +139,6 @@ _ssl__SSLSocket_version(PySSLSocket *self, PyObject *Py_UNUSED(ignored))\n     return _ssl__SSLSocket_version_impl(self);\n }\n \n-#if (HAVE_NPN)\n-\n-PyDoc_STRVAR(_ssl__SSLSocket_selected_npn_protocol__doc__,\n-\"selected_npn_protocol($self, /)\\n\"\n-\"--\\n\"\n-\"\\n\");\n-\n-#define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF    \\\n-    {\"selected_npn_protocol\", (PyCFunction)_ssl__SSLSocket_selected_npn_protocol, METH_NOARGS, _ssl__SSLSocket_selected_npn_protocol__doc__},\n-\n-static PyObject *\n-_ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self);\n-\n-static PyObject *\n-_ssl__SSLSocket_selected_npn_protocol(PySSLSocket *self, PyObject *Py_UNUSED(ignored))\n-{\n-    return _ssl__SSLSocket_selected_npn_protocol_impl(self);\n-}\n-\n-#endif /* (HAVE_NPN) */\n-\n-#if (HAVE_ALPN)\n-\n PyDoc_STRVAR(_ssl__SSLSocket_selected_alpn_protocol__doc__,\n \"selected_alpn_protocol($self, /)\\n\"\n \"--\\n\"\n@@ -179,8 +156,6 @@ _ssl__SSLSocket_selected_alpn_protocol(PySSLSocket *self, PyObject *Py_UNUSED(ig\n     return _ssl__SSLSocket_selected_alpn_protocol_impl(self);\n }\n \n-#endif /* (HAVE_ALPN) */\n-\n PyDoc_STRVAR(_ssl__SSLSocket_compression__doc__,\n \"compression($self, /)\\n\"\n \"--\\n\"\n@@ -452,8 +427,6 @@ _ssl__SSLContext_set_ciphers(PySSLContext *self, PyObject *arg)\n     return return_value;\n }\n \n-#if (OPENSSL_VERSION_NUMBER >= 0x10002000UL)\n-\n PyDoc_STRVAR(_ssl__SSLContext_get_ciphers__doc__,\n \"get_ciphers($self, /)\\n\"\n \"--\\n\"\n@@ -471,44 +444,6 @@ _ssl__SSLContext_get_ciphers(PySSLContext *self, PyObject *Py_UNUSED(ignored))\n     return _ssl__SSLContext_get_ciphers_impl(self);\n }\n \n-#endif /* (OPENSSL_VERSION_NUMBER >= 0x10002000UL) */\n-\n-PyDoc_STRVAR(_ssl__SSLContext__set_npn_protocols__doc__,\n-\"_set_npn_protocols($self, protos, /)\\n\"\n-\"--\\n\"\n-\"\\n\");\n-\n-#define _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF    \\\n-    {\"_set_npn_protocols\", (PyCFunction)_ssl__SSLContext__set_npn_protocols, METH_O, _ssl__SSLContext__set_npn_protocols__doc__},\n-\n-static PyObject *\n-_ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,\n-                                         Py_buffer *protos);\n-\n-static PyObject *\n-_ssl__SSLContext__set_npn_protocols(PySSLContext *self, PyObject *arg)\n-{\n-    PyObject *return_value = NULL;\n-    Py_buffer protos = {NULL, NULL};\n-\n-    if (PyObject_GetBuffer(arg, &protos, PyBUF_SIMPLE) != 0) {\n-        goto exit;\n-    }\n-    if (!PyBuffer_IsContiguous(&protos, 'C')) {\n-        _PyArg_BadArgument(\"_set_npn_protocols\", \"argument\", \"contiguous buffer\", arg);\n-        goto exit;\n-    }\n-    return_value = _ssl__SSLContext__set_npn_protocols_impl(self, &protos);\n-\n-exit:\n-    /* Cleanup for protos */\n-    if (protos.obj) {\n-       PyBuffer_Release(&protos);\n-    }\n-\n-    return return_value;\n-}\n-\n PyDoc_STRVAR(_ssl__SSLContext__set_alpn_protocols__doc__,\n \"_set_alpn_protocols($self, protos, /)\\n\"\n \"--\\n\"\n@@ -829,8 +764,6 @@ _ssl__SSLContext_set_default_verify_paths(PySSLContext *self, PyObject *Py_UNUSE\n     return _ssl__SSLContext_set_default_verify_paths_impl(self);\n }\n \n-#if !defined(OPENSSL_NO_ECDH)\n-\n PyDoc_STRVAR(_ssl__SSLContext_set_ecdh_curve__doc__,\n \"set_ecdh_curve($self, name, /)\\n\"\n \"--\\n\"\n@@ -839,8 +772,6 @@ PyDoc_STRVAR(_ssl__SSLContext_set_ecdh_curve__doc__,\n #define _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF    \\\n     {\"set_ecdh_curve\", (PyCFunction)_ssl__SSLContext_set_ecdh_curve, METH_O, _ssl__SSLContext_set_ecdh_curve__doc__},\n \n-#endif /* !defined(OPENSSL_NO_ECDH) */\n-\n PyDoc_STRVAR(_ssl__SSLContext_cert_store_stats__doc__,\n \"cert_store_stats($self, /)\\n\"\n \"--\\n\"\n@@ -1420,22 +1351,6 @@ _ssl_enum_crls(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObje\n \n #endif /* defined(_MSC_VER) */\n \n-#ifndef _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF\n-    #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF\n-#endif /* !defined(_SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF) */\n-\n-#ifndef _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF\n-    #define _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF\n-#endif /* !defined(_SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF) */\n-\n-#ifndef _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF\n-    #define _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF\n-#endif /* !defined(_SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF) */\n-\n-#ifndef _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF\n-    #define _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF\n-#endif /* !defined(_SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF) */\n-\n #ifndef _SSL_RAND_EGD_METHODDEF\n     #define _SSL_RAND_EGD_METHODDEF\n #endif /* !defined(_SSL_RAND_EGD_METHODDEF) */\n@@ -1447,4 +1362,4 @@ _ssl_enum_crls(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObje\n #ifndef _SSL_ENUM_CRLS_METHODDEF\n     #define _SSL_ENUM_CRLS_METHODDEF\n #endif /* !defined(_SSL_ENUM_CRLS_METHODDEF) */\n-/*[clinic end generated code: output=2bb53a80040c9b35 input=a9049054013a1b77]*/\n+/*[clinic end generated code: output=9468e58904a565a2 input=a9049054013a1b77]*/"
        },
        {
          "filename": "Tools/ssl/multissltests.py",
          "status": "modified",
          "additions": 1,
          "deletions": 5,
          "patch": "@@ -43,21 +43,17 @@\n log = logging.getLogger(\"multissl\")\n \n OPENSSL_OLD_VERSIONS = [\n-    \"1.0.2u\",\n-    \"1.1.0l\",\n ]\n \n OPENSSL_RECENT_VERSIONS = [\n     \"1.1.1k\",\n-    # \"3.0.0-alpha14\"\n+    \"3.0.0-alpha14\"\n ]\n \n LIBRESSL_OLD_VERSIONS = [\n-    \"2.9.2\",\n ]\n \n LIBRESSL_RECENT_VERSIONS = [\n-    \"3.2.4\",\n ]\n \n # store files in ../multissl"
        },
        {
          "filename": "configure",
          "status": "modified",
          "additions": 5225,
          "deletions": 7570,
          "patch": null
        },
        {
          "filename": "configure.ac",
          "status": "modified",
          "additions": 0,
          "deletions": 36,
          "patch": "@@ -5781,42 +5781,6 @@ ac_includes_default=\"$save_includes_default\"\n # Check for usable OpenSSL\n AX_CHECK_OPENSSL([have_openssl=yes],[have_openssl=no])\n \n-if test \"$have_openssl\" = yes; then\n-    AC_MSG_CHECKING([for X509_VERIFY_PARAM_set1_host in libssl])\n-\n-    save_LIBS=\"$LIBS\"\n-    save_LDFLAGS=\"$LDFLAGS\"\n-    save_CPPFLAGS=\"$CPPFLAGS\"\n-    LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"\n-    LIBS=\"$OPENSSL_LIBS $LIBS\"\n-    CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"\n-\n-    AC_LINK_IFELSE([AC_LANG_PROGRAM([\n-        [#include <openssl/x509_vfy.h>]\n-    ], [\n-        [X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();]\n-        [X509_VERIFY_PARAM_set1_host(p, \"localhost\", 0);]\n-        [X509_VERIFY_PARAM_set1_ip_asc(p, \"127.0.0.1\");]\n-        [X509_VERIFY_PARAM_set_hostflags(p, 0);]\n-    ])\n-    ],\n-    [\n-        ac_cv_has_x509_verify_param_set1_host=yes\n-    ],\n-    [\n-        ac_cv_has_x509_verify_param_set1_host=no\n-    ])\n-    AC_MSG_RESULT($ac_cv_has_x509_verify_param_set1_host)\n-    if test \"$ac_cv_has_x509_verify_param_set1_host\" = \"yes\"; then\n-        AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1,\n-        [Define if libssl has X509_VERIFY_PARAM_set1_host and related function])\n-    fi\n-\n-    CPPFLAGS=\"$save_CPPFLAGS\"\n-    LDFLAGS=\"$save_LDFLAGS\"\n-    LIBS=\"$save_LIBS\"\n-fi\n-\n # rpath to libssl and libcrypto\n AC_MSG_CHECKING(for --with-openssl-rpath)\n AC_ARG_WITH(openssl-rpath,"
        },
        {
          "filename": "pyconfig.h.in",
          "status": "modified",
          "additions": 0,
          "deletions": 3,
          "patch": "@@ -1356,9 +1356,6 @@\n /* Define to 1 if you have the `writev' function. */\n #undef HAVE_WRITEV\n \n-/* Define if libssl has X509_VERIFY_PARAM_set1_host and related function */\n-#undef HAVE_X509_VERIFY_PARAM_SET1_HOST\n-\n /* Define if the zlib library has inflateCopy */\n #undef HAVE_ZLIB_COPY\n "
        },
        {
          "filename": "setup.py",
          "status": "modified",
          "additions": 14,
          "deletions": 27,
          "patch": "@@ -551,10 +551,7 @@ def print_three_column(lst):\n                for l in (self.missing, self.failed, self.failed_on_import)):\n             print()\n             print(\"Could not build the ssl module!\")\n-            print(\"Python requires an OpenSSL 1.0.2 or 1.1 compatible \"\n-                  \"libssl with X509_VERIFY_PARAM_set1_host().\")\n-            print(\"LibreSSL 2.6.4 and earlier do not provide the necessary \"\n-                  \"APIs, https://github.com/libressl-portable/portable/issues/381\")\n+            print(\"Python requires a OpenSSL 1.1.1 or newer\")\n             if sysconfig.get_config_var(\"OPENSSL_LDFLAGS\"):\n                 print(\"Custom linker flags may require --with-openssl-rpath=auto\")\n             print()\n@@ -2431,13 +2428,13 @@ def split_var(name, sep):\n             self.missing.extend(['_ssl', '_hashlib'])\n             return None, None\n \n-        # OpenSSL 1.0.2 uses Kerberos for KRB5 ciphers\n-        krb5_h = find_file(\n-            'krb5.h', self.inc_dirs,\n-            ['/usr/kerberos/include']\n+        self.add(Extension(\n+            '_ssl', ['_ssl.c'],\n+            include_dirs=openssl_includes,\n+            library_dirs=openssl_libdirs,\n+            libraries=openssl_libs,\n+            depends=['socketmodule.h', '_ssl/debughelpers.c'])\n         )\n-        if krb5_h:\n-            ssl_incs.extend(krb5_h)\n \n         if openssl_rpath == 'auto':\n             runtime_library_dirs = openssl_libdirs[:]\n@@ -2468,24 +2465,14 @@ def split_var(name, sep):\n             # don't link OpenSSL shared libraries.\n             openssl_extension_kwargs[\"libraries\"] = []\n \n-        if config_vars.get(\"HAVE_X509_VERIFY_PARAM_SET1_HOST\"):\n-            self.add(\n-                Extension(\n-                    '_ssl',\n-                    ['_ssl.c'],\n-                    depends=[\n-                        'socketmodule.h',\n-                        '_ssl/debughelpers.c',\n-                        '_ssl_data.h',\n-                        '_ssl_data_111.h',\n-                        '_ssl_data_300.h',\n-                    ],\n-                    **openssl_extension_kwargs\n-                )\n+        self.add(\n+            Extension(\n+                '_ssl',\n+                ['_ssl.c'],\n+                depends=['socketmodule.h', '_ssl/debughelpers.c'],\n+                **openssl_extension_kwargs\n             )\n-        else:\n-            self.missing.append('_ssl')\n-\n+        )\n         self.add(\n             Extension(\n                 '_hashlib',"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 4,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 11,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d906bde250d59c396d8dab92285b832c66cdec27",
            "date": "2025-01-14T16:07:37Z",
            "author_login": "picnixz"
          },
          {
            "sha": "d786ac7f584f23c3206f4c86032bdabe83c17b51",
            "date": "2025-01-14T15:31:13Z",
            "author_login": "vstinner"
          },
          {
            "sha": "43ef9587ae869fd11711a3bb126e65afe9177342",
            "date": "2025-01-14T15:29:21Z",
            "author_login": "vstinner"
          },
          {
            "sha": "1598e18a659ef3a533caa0a79a489a3ed1d80bdd",
            "date": "2025-01-14T15:17:24Z",
            "author_login": "rffontenelle"
          },
          {
            "sha": "7fc0f86098c162e0230d5ef5ea62a883e41f9411",
            "date": "2025-01-14T15:12:21Z",
            "author_login": "hugovk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L",
    "cwe_id": null,
    "description": "CPython 3.9 and earlier doesn't disallow configuring an empty list (\"[]\") for SSLContext.set_npn_protocols() which is an invalid value for the underlying OpenSSL API. This results in a buffer over-read when NPN is used (see CVE-2024-5535 for OpenSSL). This vulnerability is of low severity due to NPN being not widely used and specifying an empty list likely being uncommon in-practice (typically a protocol name would be configured).",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-06-27T21:15:16.070",
    "last_modified": "2024-11-21T09:48:04.713",
    "fix_date": "2021-04-17T09:36:35Z"
  },
  "references": [
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/06/28/4",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/39258d3595300bc7b952854c915f63ae2d4b9c3e",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/issues/121227",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/pull/23014",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://jbp.io/2024/06/27/cve-2024-5535-openssl-memory-safety.html",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://mail.python.org/archives/list/security-announce@python.org/thread/PLP2JI3PJY33YG6P5BZYSSNU66HASXBQ/",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240726-0005/",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/06/28/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/39258d3595300bc7b952854c915f63ae2d4b9c3e",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/issues/121227",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/pull/23014",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://jbp.io/2024/06/27/cve-2024-5535-openssl-memory-safety.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://mail.python.org/archives/list/security-announce@python.org/thread/PLP2JI3PJY33YG6P5BZYSSNU66HASXBQ/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240726-0005/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:28.869042",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cpython",
    "owner": "python",
    "created_at": "2017-02-10T19:23:51Z",
    "updated_at": "2025-01-14T11:40:35Z",
    "pushed_at": "2025-01-14T11:26:26Z",
    "size": 657526,
    "stars": 64721,
    "forks": 30871,
    "open_issues": 8974,
    "watchers": 64721,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "3.13",
      "main"
    ],
    "languages": {
      "Python": 35947988,
      "C": 20215174,
      "C++": 463381,
      "M4": 257753,
      "HTML": 206335,
      "Batchfile": 78178,
      "Shell": 71664,
      "Roff": 45666,
      "Makefile": 36295,
      "Objective-C": 33051,
      "Common Lisp": 24579,
      "PLSQL": 22886,
      "PowerShell": 20323,
      "Rich Text Format": 6905,
      "JavaScript": 4245,
      "Kotlin": 3800,
      "Assembly": 2552,
      "DTrace": 2196,
      "CSS": 1325,
      "XSLT": 1174,
      "CMake": 327,
      "VBScript": 70
    },
    "commit_activity": {
      "total_commits_last_year": 5718,
      "avg_commits_per_week": 109.96153846153847,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:09:03.245623"
  }
}