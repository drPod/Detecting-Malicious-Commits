{
  "cve_id": "CVE-2024-56513",
  "github_data": {
    "repository": "karmada-io/karmada",
    "fix_commit": "2c82055c4c7f469411b1ba48c4dba4841df04831",
    "related_commits": [
      "2c82055c4c7f469411b1ba48c4dba4841df04831"
    ],
    "patch_url": "https://github.com/karmada-io/karmada/commit/2c82055c4c7f469411b1ba48c4dba4841df04831.patch",
    "fix_commit_details": {
      "sha": "2c82055c4c7f469411b1ba48c4dba4841df04831",
      "commit_date": "2024-11-20T09:22:56Z",
      "author": {
        "login": "karmada-bot",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Merge pull request #5793 from zhzhuang-zju/register",
        "length": 108,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 1218,
        "additions": 722,
        "deletions": 496
      },
      "files": [
        {
          "filename": "artifacts/deploy/bootstrap-token-configuration.yaml",
          "status": "modified",
          "additions": 60,
          "deletions": 256,
          "patch": "@@ -13,6 +13,7 @@ data:\n     kind: Config\n \n ---\n+# Define a role with permission to get the cluster-info configmap\n apiVersion: rbac.authorization.k8s.io/v1\n kind: Role\n metadata:\n@@ -31,6 +32,8 @@ rules:\n   - get\n \n ---\n+# An anonymous user can get `cluster-info` configmap, which is used to obtain the control plane API server's server\n+# address and `certificate-authority-data` during the `karmadactl register` process.\n apiVersion: rbac.authorization.k8s.io/v1\n kind: RoleBinding\n metadata:\n@@ -48,6 +51,8 @@ subjects:\n   name: system:anonymous\n \n ---\n+# Group `system:bootstrappers:karmada:default-cluster-token` is the user group of the bootstrap token\n+# used by `karmadactl register` when registering a new pull mode cluster.\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n@@ -64,6 +69,26 @@ subjects:\n   name: system:bootstrappers:karmada:default-cluster-token\n \n ---\n+# Define a ClusterRole with permissions to automatically approve the agent CSRs when the agentcsrapproving controller is enabled by karmada-controller-manager.\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRole\n+metadata:\n+  labels:\n+    karmada.io/bootstrapping: rbac-defaults\n+  name: system:karmada:certificatesigningrequest:autoapprover\n+rules:\n+  - apiGroups:\n+      - certificates.k8s.io\n+    resources:\n+      - certificatesigningrequests/clusteragent\n+    verbs:\n+      - create\n+\n+---\n+# Group `system:bootstrappers:karmada:default-cluster-token` is the user group of the bootstrap token\n+# used by `karmadactl register` when registering a new pull mode cluster.\n+# When the `agentcsrapproving` controller is enabled by the karmada-controller-manager,\n+# it can automatically approve the agent CSRs requested by the user group system:bootstrappers:karmada:default-cluster-token.\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n@@ -73,13 +98,33 @@ metadata:\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient\n+  name: system:karmada:certificatesigningrequest:autoapprover\n subjects:\n - apiGroup: rbac.authorization.k8s.io\n   kind: Group\n   name: system:bootstrappers:karmada:default-cluster-token\n \n ---\n+# Define a ClusterRole with permissions to automatically approve the agent CSRs\n+# where the user name and group of requester match those in the CSRs when the agentcsrapproving controller is enabled by karmada-controller-manager.\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRole\n+metadata:\n+  labels:\n+    karmada.io/bootstrapping: rbac-defaults\n+  name: system:karmada:certificatesigningrequest:selfautoapprover\n+rules:\n+  - apiGroups:\n+      - certificates.k8s.io\n+    resources:\n+      - certificatesigningrequests/selfclusteragent\n+    verbs:\n+      - create\n+\n+---\n+# Group `system:karmada:agents` is the user group used by the karmada-agent to access the Karmada API server.\n+# When the agentcsrapproving controller is enabled by the karmada-controller-manager, it can automatically approve\n+# the agent CSRs(csr.Subject.CommonName = agent username) requested by the user group system:karmada:agents.\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n@@ -89,280 +134,39 @@ metadata:\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient\n+  name: system:karmada:certificatesigningrequest:selfautoapprover\n subjects:\n - apiGroup: rbac.authorization.k8s.io\n   kind: Group\n-  name: system:nodes\n+  name: system:karmada:agents\n \n ---\n+# ClusterRole `system:karmada:agent-rbac-generator` is not used for the connection between the karmada-agent and the control plane,\n+# but is used by karmadactl register to generate the RBAC resources required by the karmada-agent.\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRole\n metadata:\n   labels:\n     karmada.io/bootstrapping: rbac-defaults\n-  name: system:karmada:agent\n+  name: system:karmada:agent-rbac-generator\n rules:\n-- apiGroups:\n-  - cluster.karmada.io\n-  resources:\n-  - clusters\n-  verbs:\n-  - create\n-  - get\n-  - list\n-  - watch\n-  - delete\n-- apiGroups:\n-  - cluster.karmada.io\n-  resources:\n-  - clusters/status\n-  verbs:\n-  - update\n-- apiGroups:\n-  - work.karmada.io\n-  resources:\n-  - works\n-  verbs:\n-  - create\n-  - get\n-  - list\n-  - watch\n-  - update\n-  - delete\n-- apiGroups:\n-  - work.karmada.io\n-  resources:\n-  - works/status\n-  verbs:\n-  - patch\n-  - update\n-- apiGroups:\n-  - config.karmada.io\n-  resources:\n-  - resourceinterpreterwebhookconfigurations\n-  - resourceinterpretercustomizations\n-  verbs:\n-  - get\n-  - list\n-  - watch\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - namespaces\n-  verbs:\n-  - get\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - secrets\n-  verbs:\n-  - get\n-  - create\n-  - patch\n-- apiGroups:\n-  - coordination.k8s.io\n-  resources:\n-  - leases\n-  verbs:\n-  - create\n-  - get\n-  - update\n-- apiGroups:\n-  - certificates.k8s.io\n-  resources:\n-  - certificatesigningrequests\n-  verbs:\n-  - create\n-  - get\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - events\n-  verbs:\n-  - create\n-  - patch\n-  - update\n+  - apiGroups: ['*']\n+    resources: ['*']\n+    verbs: ['*']\n \n ---\n+# User `system:karmada:agent:rbac-generator` is specifically used during the `karmadactl register` process to generate restricted RBAC resources for the `karmada-agent`.\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n   labels:\n     karmada.io/bootstrapping: rbac-defaults\n-  name: system:karmada:agent\n+  name: system:karmada:agent-rbac-generator\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: system:karmada:agent\n+  name: system:karmada:agent-rbac-generator\n subjects:\n-- apiGroup: rbac.authorization.k8s.io\n-  kind: Group\n-  name: system:nodes\n-\n-# To ensure the agent has the minimal RBAC permissions, the ideal approach is to\n-# use different RBAC configurations for different agents of member clusters with pull mode.\n-# Below is the minimal set of RBAC permissions required for a single pull mode member cluster.\n-# Here are the definitions of the variables used:\n-#\n-# - clustername: the name of the member cluster.\n-# - cluster_namespace: the namespace where the member cluster secrets are stored, default to karmada-cluster.\n-#\n-# ---\n-# apiVersion: rbac.authorization.k8s.io/v1\n-# kind: ClusterRole\n-# metadata:\n-#   name: system:karmada:agent\n-# rules:\n-# - apiGroups:\n-#   - cluster.karmada.io\n-#   resources:\n-#   - clusters\n-#   resourceNames:\n-#   - {{clustername}}\n-#   verbs:\n-#   - create\n-#   - get\n-#   - delete\n-# - apiGroups:\n-#   - cluster.karmada.io\n-#   resources:\n-#   - clusters\n-#   verbs:\n-#   - list\n-#   - watch\n-# - apiGroups:\n-#   - cluster.karmada.io\n-#   resources:\n-#   - clusters/status\n-#   resourceNames:\n-#   - {{clustername}}\n-#   verbs:\n-#   - update\n-# - apiGroups:\n-#   - config.karmada.io\n-#   resources:\n-#   - resourceinterpreterwebhookconfigurations\n-#   - resourceinterpretercustomizations\n-#   verbs:\n-#   - get\n-#   - list\n-#   - watch\n-# - apiGroups:\n-#   - \"\"\n-#   resources:\n-#   - namespaces\n-#   verbs:\n-#   - get\n-# - apiGroups:\n-#   - coordination.k8s.io\n-#   resources:\n-#   - leases\n-#   verbs:\n-#   - create\n-#   - get\n-#   - update\n-# - apiGroups:\n-#   - certificates.k8s.io\n-#   resources:\n-#   - certificatesigningrequests\n-#   verbs:\n-#   - create\n-#   - get\n-# - apiGroups:\n-#   - \"\"\n-#   resources:\n-#   - events\n-#   verbs:\n-#   - create\n-#   - patch\n-#   - update\n-#\n-# ---\n-# apiVersion: rbac.authorization.k8s.io/v1\n-# kind: ClusterRoleBinding\n-# metadata:\n-#   name: system:karmada:agent\n-# roleRef:\n-#   apiGroup: rbac.authorization.k8s.io\n-#   kind: ClusterRole\n-#   name: system:karmada:agent\n-# subjects:\n-# - apiGroup: rbac.authorization.k8s.io\n-#   kind: Group\n-#   name: system:nodes\n-#\n-# ---\n-# apiVersion: rbac.authorization.k8s.io/v1\n-# kind: Role\n-# metadata:\n-#   name: system:karmada:agent-secret\n-#   namespace: \"{{cluster_namespace}}\"\n-# rules:\n-# - apiGroups:\n-#   - \"\"\n-#   resources:\n-#   - secrets\n-#   resourceNames:\n-#   - {{clustername}}-impersonator\n-#   - {{clustername}}\n-#   verbs:\n-#   - get\n-#   - create\n-#   - patch\n-#\n-# ---\n-# apiVersion: rbac.authorization.k8s.io/v1\n-# kind: RoleBinding\n-# metadata:\n-#   name: system:karmada:agent-secret\n-#   namespace: \"{{cluster_namespace}}\"\n-# roleRef:\n-#   apiGroup: rbac.authorization.k8s.io\n-#   kind: Role\n-#   name: system:karmada:agent-secret\n-# subjects:\n-# - apiGroup: rbac.authorization.k8s.io\n-#   kind: Group\n-#   name: system:nodes\n-#\n-# ---\n-# apiVersion: rbac.authorization.k8s.io/v1\n-# kind: Role\n-# metadata:\n-#   name: system:karmada:agent-work\n-#   namespace: \"karmada-es-{{clustername}}\"\n-# rules:\n-# - apiGroups:\n-#   - work.karmada.io\n-#   resources:\n-#   - works\n-#   verbs:\n-#   - create\n-#   - get\n-#   - list\n-#   - watch\n-#   - update\n-#   - delete\n-# - apiGroups:\n-#   - work.karmada.io\n-#   resources:\n-#   - works/status\n-#   verbs:\n-#   - patch\n-#   - update\n-#\n-# ---\n-# apiVersion: rbac.authorization.k8s.io/v1\n-# kind: RoleBinding\n-# metadata:\n-#   name: system:karmada:agent-work\n-#   namespace: \"karmada-es-{{clustername}}\"\n-# roleRef:\n-#   apiGroup: rbac.authorization.k8s.io\n-#   kind: Role\n-#   name: system:karmada:agent-work\n-# subjects:\n-# - apiGroup: rbac.authorization.k8s.io\n-#   kind: Group\n-#   name: system:nodes\n+  - apiGroup: rbac.authorization.k8s.io\n+    kind: User\n+    name: system:karmada:agent:rbac-generator"
        },
        {
          "filename": "charts/karmada/templates/_karmada_bootstrap_token_configuration.tpl",
          "status": "modified",
          "additions": 43,
          "deletions": 103,
          "patch": "@@ -75,6 +75,22 @@ subjects:\n   name: system:bootstrappers:karmada:default-cluster-token\n ---\n apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRole\n+metadata:\n+  name: system:karmada:certificatesigningrequest:autoapprover\n+  {{- if \"karmada.commonLabels\" }}\n+  labels:\n+    {{- include \"karmada.commonLabels\" . | nindent 4 }}\n+  {{- end }}\n+rules:\n+- apiGroups:\n+  - certificates.k8s.io\n+  resources:\n+  - certificatesigningrequests/clusteragent\n+  verbs:\n+  - create\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n   name: system:karmada:agent-autoapprove-bootstrap\n@@ -85,13 +101,29 @@ metadata:\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient\n+  name: system:karmada:certificatesigningrequest:autoapprover\n subjects:\n - apiGroup: rbac.authorization.k8s.io\n   kind: Group\n   name: system:bootstrappers:karmada:default-cluster-token\n ---\n apiVersion: rbac.authorization.k8s.io/v1\n+kind: ClusterRole\n+metadata:\n+  name: system:karmada:certificatesigningrequest:selfautoapprover\n+  {{- if \"karmada.commonLabels\" }}\n+  labels:\n+    {{- include \"karmada.commonLabels\" . | nindent 4 }}\n+  {{- end }}\n+rules:\n+- apiGroups:\n+  - certificates.k8s.io\n+  resources:\n+  - certificatesigningrequests/selfclusteragent\n+  verbs:\n+  - create\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n   name: system:karmada:agent-autoapprove-certificate-rotation\n@@ -102,134 +134,42 @@ metadata:\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient\n+  name: system:karmada:certificatesigningrequest:selfautoapprover\n subjects:\n - apiGroup: rbac.authorization.k8s.io\n   kind: Group\n-  name: system:nodes\n+  name: system:karmada:agents\n ---\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRole\n metadata:\n-  name: system:karmada:agent\n+  name: system:karmada:agent-rbac-generator\n   {{- if \"karmada.commonLabels\" }}\n   labels:\n     {{- include \"karmada.commonLabels\" . | nindent 4 }}\n   {{- end }}\n rules:\n - apiGroups:\n-  - authentication.k8s.io\n-  resources:\n-  - tokenreviews\n-  verbs:\n-  - create\n-- apiGroups:\n-  - cluster.karmada.io\n-  resources:\n-  - clusters\n-  verbs:\n-  - create\n-  - get\n-  - list\n-  - watch\n-  - patch\n-  - update\n-  - delete\n-- apiGroups:\n-  - cluster.karmada.io\n-  resources:\n-  - clusters/status\n-  verbs:\n-  - patch\n-  - update\n-- apiGroups:\n-  - work.karmada.io\n+  - \"*\"\n   resources:\n-  - works\n+  - \"*\"\n   verbs:\n-  - create\n-  - get\n-  - list\n-  - watch\n-  - update\n-  - delete\n-- apiGroups:\n-  - work.karmada.io\n-  resources:\n-  - works/status\n-  verbs:\n-  - patch\n-  - update\n-- apiGroups:\n-  - config.karmada.io\n-  resources:\n-  - resourceinterpreterwebhookconfigurations\n-  - resourceinterpretercustomizations\n-  verbs:\n-  - get\n-  - list\n-  - watch\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - namespaces\n-  verbs:\n-  - get\n-  - list\n-  - watch\n-  - create\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - secrets\n-  verbs:\n-  - get\n-  - list\n-  - watch\n-  - create\n-  - patch\n-- apiGroups:\n-  - coordination.k8s.io\n-  resources:\n-  - leases\n-  verbs:\n-  - create\n-  - delete\n-  - get\n-  - patch\n-  - update\n-- apiGroups:\n-  - certificates.k8s.io\n-  resources:\n-  - certificatesigningrequests\n-  verbs:\n-  - create\n-  - get\n-  - list\n-  - watch\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - events\n-  verbs:\n-  - create\n-  - patch\n-  - update\n+  - \"*\"\n ---\n apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n-  name: system:karmada:agent\n+  name: system:karmada:agent-rbac-generator\n   {{- if \"karmada.commonLabels\" }}\n   labels:\n     {{- include \"karmada.commonLabels\" . | nindent 4 }}\n   {{- end }}\n roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n-  name: system:karmada:agent\n+  name: system:karmada:agent-rbac-generator\n subjects:\n - apiGroup: rbac.authorization.k8s.io\n-  kind: Group\n-  name: system:nodes\n+  kind: User\n+  name: system:karmada:agent:rbac-generator\n {{- end -}}"
        },
        {
          "filename": "pkg/karmadactl/cmdinit/bootstraptoken/agent/tlsbootstrap.go",
          "status": "modified",
          "additions": 26,
          "deletions": 4,
          "patch": "@@ -31,15 +31,15 @@ const (\n \t// KarmadaAgentBootstrap defines the name of the ClusterRoleBinding that lets Karmada Agent post CSRs\n \tKarmadaAgentBootstrap = \"system:karmada:agent-bootstrap\"\n \t// KarmadaAgentGroup defines the group of Karmada Agent\n-\tKarmadaAgentGroup = \"system:nodes\"\n+\tKarmadaAgentGroup = \"system:karmada:agents\"\n \t// KarmadaAgentAutoApproveBootstrapClusterRoleBinding defines the name of the ClusterRoleBinding that makes the csrapprover approve agent CSRs\n \tKarmadaAgentAutoApproveBootstrapClusterRoleBinding = \"system:karmada:agent-autoapprove-bootstrap\"\n \t// KarmadaAgentAutoApproveCertificateRotationClusterRoleBinding defines name of the ClusterRoleBinding that makes the csrapprover approve agent auto rotated CSRs\n \tKarmadaAgentAutoApproveCertificateRotationClusterRoleBinding = \"system:karmada:agent-autoapprove-certificate-rotation\"\n \t// CSRAutoApprovalClusterRoleName defines the name of the auto-bootstrapped ClusterRole for making the csrapprover controller auto-approve the CSR\n-\tCSRAutoApprovalClusterRoleName = \"system:certificates.k8s.io:certificatesigningrequests:nodeclient\"\n+\tCSRAutoApprovalClusterRoleName = \"system:karmada:certificatesigningrequest:autoapprover\"\n \t// KarmadaAgentSelfCSRAutoApprovalClusterRoleName is a role for automatic CSR approvals for automatically rotated agent certificates\n-\tKarmadaAgentSelfCSRAutoApprovalClusterRoleName = \"system:certificates.k8s.io:certificatesigningrequests:selfnodeclient\"\n+\tKarmadaAgentSelfCSRAutoApprovalClusterRoleName = \"system:karmada:certificatesigningrequest:selfautoapprover\"\n \t// KarmadaAgentBootstrapTokenAuthGroup specifies which group a Karmada Agent Bootstrap Token should be authenticated in\n \tKarmadaAgentBootstrapTokenAuthGroup = \"system:bootstrappers:karmada:default-cluster-token\"\n )\n@@ -60,7 +60,18 @@ func AllowBootstrapTokensToPostCSRs(clientSet kubernetes.Interface) error {\n \n // AutoApproveKarmadaAgentBootstrapTokens creates RBAC rules in a way that makes Karmada Agent Bootstrap Tokens' CSR auto-approved by the csrapprover controller\n func AutoApproveKarmadaAgentBootstrapTokens(clientSet kubernetes.Interface) error {\n-\tklog.Infoln(\"[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Karmada Agent Bootstrap Token\")\n+\tklog.Infoln(\"[bootstrap-token] configured RBAC rules to allow the agentcsrapproving controller automatically approve CSRs from a Karmada Agent Bootstrap Token\")\n+\tcsrAutoApprovalClusterRole := utils.ClusterRoleFromRules(CSRAutoApprovalClusterRoleName, []rbacv1.PolicyRule{\n+\t\t{\n+\t\t\tAPIGroups: []string{\"certificates.k8s.io\"},\n+\t\t\tResources: []string{\"certificatesigningrequests/clusteragent\"},\n+\t\t\tVerbs:     []string{\"create\"},\n+\t\t},\n+\t}, nil, nil)\n+\terr := cmdutil.CreateOrUpdateClusterRole(clientSet, csrAutoApprovalClusterRole)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n \tclusterRoleBinding := utils.ClusterRoleBindingFromSubjects(KarmadaAgentAutoApproveBootstrapClusterRoleBinding, CSRAutoApprovalClusterRoleName,\n \t\t[]rbacv1.Subject{\n@@ -75,6 +86,17 @@ func AutoApproveKarmadaAgentBootstrapTokens(clientSet kubernetes.Interface) erro\n // AutoApproveAgentCertificateRotation creates RBAC rules in a way that makes Agent certificate rotation CSR auto-approved by the csrapprover controller\n func AutoApproveAgentCertificateRotation(clientSet kubernetes.Interface) error {\n \tklog.Infoln(\"[bootstrap-token] configured RBAC rules to allow certificate rotation for all agent client certificates in the member cluster\")\n+\tkarmadaAgentSelfCSRAutoApprovalClusterRole := utils.ClusterRoleFromRules(KarmadaAgentSelfCSRAutoApprovalClusterRoleName, []rbacv1.PolicyRule{\n+\t\t{\n+\t\t\tAPIGroups: []string{\"certificates.k8s.io\"},\n+\t\t\tResources: []string{\"certificatesigningrequests/selfclusteragent\"},\n+\t\t\tVerbs:     []string{\"create\"},\n+\t\t},\n+\t}, nil, nil)\n+\terr := cmdutil.CreateOrUpdateClusterRole(clientSet, karmadaAgentSelfCSRAutoApprovalClusterRole)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n \tclusterRoleBinding := utils.ClusterRoleBindingFromSubjects(KarmadaAgentAutoApproveCertificateRotationClusterRoleBinding, KarmadaAgentSelfCSRAutoApprovalClusterRoleName,\n \t\t[]rbacv1.Subject{"
        },
        {
          "filename": "pkg/karmadactl/cmdinit/karmada/deploy.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -185,8 +185,8 @@ func createExtraResources(clientSet *kubernetes.Clientset, dir string) error {\n \t\treturn fmt.Errorf(\"error creating clusterinfo RBAC rules: %v\", err)\n \t}\n \n-\t// grant limited access permission to 'karmada-agent'\n-\tif err := grantAccessPermissionToAgent(clientSet); err != nil {\n+\t// grant access permission to 'karmada-agent-rbac-generator'\n+\tif err := grantAccessPermissionToAgentRBACGenerator(clientSet); err != nil {\n \t\treturn err\n \t}\n "
        },
        {
          "filename": "pkg/karmadactl/cmdinit/karmada/rbac.go",
          "status": "modified",
          "additions": 15,
          "deletions": 64,
          "patch": "@@ -26,10 +26,11 @@ import (\n )\n \n const (\n-\tkarmadaViewClusterRole        = \"karmada-view\"\n-\tkarmadaEditClusterRole        = \"karmada-edit\"\n-\tkarmadaAgentAccessClusterRole = \"system:karmada:agent\"\n-\tkarmadaAgentGroup             = \"system:nodes\"\n+\tkarmadaViewClusterRole                      = \"karmada-view\"\n+\tkarmadaEditClusterRole                      = \"karmada-edit\"\n+\tkarmadaAgentRBACGeneratorClusterRole        = \"system:karmada:agent-rbac-generator\"\n+\tkarmadaAgentRBACGeneratorClusterRoleBinding = \"system:karmada:agent-rbac-generator\"\n+\tagentRBACGenerator                          = \"system:karmada:agent:rbac-generator\"\n )\n \n // grantProxyPermissionToAdmin grants the proxy permission to \"system:admin\"\n@@ -62,78 +63,28 @@ func grantProxyPermissionToAdmin(clientSet kubernetes.Interface) error {\n \treturn nil\n }\n \n-// grantAccessPermissionToAgent grants the limited access permission to 'karmada-agent'\n-func grantAccessPermissionToAgent(clientSet kubernetes.Interface) error {\n-\tclusterRole := utils.ClusterRoleFromRules(karmadaAgentAccessClusterRole, []rbacv1.PolicyRule{\n+// grantAccessPermissionToAgentRBACGenerator grants the access permission to 'karmada-agent-rbac-generator'\n+func grantAccessPermissionToAgentRBACGenerator(clientSet kubernetes.Interface) error {\n+\tclusterRole := utils.ClusterRoleFromRules(karmadaAgentRBACGeneratorClusterRole, []rbacv1.PolicyRule{\n \t\t{\n-\t\t\tAPIGroups: []string{\"authentication.k8s.io\"},\n-\t\t\tResources: []string{\"tokenreviews\"},\n-\t\t\tVerbs:     []string{\"create\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"cluster.karmada.io\"},\n-\t\t\tResources: []string{\"clusters\"},\n-\t\t\tVerbs:     []string{\"create\", \"get\", \"list\", \"watch\", \"patch\", \"update\", \"delete\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"cluster.karmada.io\"},\n-\t\t\tResources: []string{\"clusters/status\"},\n-\t\t\tVerbs:     []string{\"patch\", \"update\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"work.karmada.io\"},\n-\t\t\tResources: []string{\"works\"},\n-\t\t\tVerbs:     []string{\"create\", \"get\", \"list\", \"watch\", \"update\", \"delete\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"work.karmada.io\"},\n-\t\t\tResources: []string{\"works/status\"},\n-\t\t\tVerbs:     []string{\"patch\", \"update\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"config.karmada.io\"},\n-\t\t\tResources: []string{\"resourceinterpreterwebhookconfigurations\", \"resourceinterpretercustomizations\"},\n-\t\t\tVerbs:     []string{\"get\", \"list\", \"watch\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"\"},\n-\t\t\tResources: []string{\"namespaces\"},\n-\t\t\tVerbs:     []string{\"get\", \"list\", \"watch\", \"create\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"\"},\n-\t\t\tResources: []string{\"secrets\"},\n-\t\t\tVerbs:     []string{\"get\", \"list\", \"watch\", \"create\", \"patch\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"coordination.k8s.io\"},\n-\t\t\tResources: []string{\"leases\"},\n-\t\t\tVerbs:     []string{\"create\", \"delete\", \"get\", \"patch\", \"update\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"certificates.k8s.io\"},\n-\t\t\tResources: []string{\"certificatesigningrequests\"},\n-\t\t\tVerbs:     []string{\"create\", \"get\", \"list\", \"watch\"},\n-\t\t},\n-\t\t{\n-\t\t\tAPIGroups: []string{\"\"},\n-\t\t\tResources: []string{\"events\"},\n-\t\t\tVerbs:     []string{\"create\", \"patch\", \"update\"},\n+\t\t\tAPIGroups: []string{\"*\"},\n+\t\t\tResources: []string{\"*\"},\n+\t\t\tVerbs:     []string{\"*\"},\n \t\t},\n \t}, nil, nil)\n \terr := cmdutil.CreateOrUpdateClusterRole(clientSet, clusterRole)\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\tclusterRoleBinding := utils.ClusterRoleBindingFromSubjects(karmadaAgentAccessClusterRole, karmadaAgentAccessClusterRole,\n+\tclusterRoleBinding := utils.ClusterRoleBindingFromSubjects(karmadaAgentRBACGeneratorClusterRoleBinding, karmadaAgentRBACGeneratorClusterRole,\n \t\t[]rbacv1.Subject{\n \t\t\t{\n-\t\t\t\tKind: rbacv1.GroupKind,\n-\t\t\t\tName: karmadaAgentGroup,\n+\t\t\t\tKind: rbacv1.UserKind,\n+\t\t\t\tName: agentRBACGenerator,\n \t\t\t}}, nil)\n \n-\tklog.V(1).Info(\"Grant the limited access permission to 'karmada-agent'\")\n+\tklog.V(1).Info(\"Grant the access permission to 'karmada-agent-rbac-generator'\")\n \terr = cmdutil.CreateOrUpdateClusterRoleBinding(clientSet, clusterRoleBinding)\n \tif err != nil {\n \t\treturn err"
        },
        {
          "filename": "pkg/karmadactl/cmdinit/karmada/rbac_test.go",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -31,8 +31,8 @@ func Test_grantProxyPermissionToAdmin(t *testing.T) {\n \n func Test_grantAccessPermissionToAgent(t *testing.T) {\n \tclient := fake.NewSimpleClientset()\n-\tif err := grantAccessPermissionToAgent(client); err != nil {\n-\t\tt.Errorf(\"grantAccessPermissionToAgent() expected no error, but got err: %v\", err)\n+\tif err := grantAccessPermissionToAgentRBACGenerator(client); err != nil {\n+\t\tt.Errorf(\"grantAccessPermissionToAgentRBACGenerator() expected no error, but got err: %v\", err)\n \t}\n }\n "
        },
        {
          "filename": "pkg/karmadactl/register/register.go",
          "status": "modified",
          "additions": 415,
          "deletions": 33,
          "patch": "@@ -51,7 +51,6 @@ import (\n \n \t\"github.com/karmada-io/karmada/pkg/apis/cluster/validation\"\n \tkarmadaclientset \"github.com/karmada-io/karmada/pkg/generated/clientset/versioned\"\n-\taddonutils \"github.com/karmada-io/karmada/pkg/karmadactl/addons/utils\"\n \t\"github.com/karmada-io/karmada/pkg/karmadactl/options\"\n \tcmdutil \"github.com/karmada-io/karmada/pkg/karmadactl/util\"\n \t\"github.com/karmada-io/karmada/pkg/karmadactl/util/apiclient\"\n@@ -82,9 +81,11 @@ const (\n \t// CACertPath defines default location of CA certificate on Linux\n \tCACertPath = \"/etc/karmada/pki/ca.crt\"\n \t// ClusterPermissionPrefix defines the common name of karmada agent certificate\n-\tClusterPermissionPrefix = \"system:node:\"\n+\tClusterPermissionPrefix = \"system:karmada:agent:\"\n \t// ClusterPermissionGroups defines the organization of karmada agent certificate\n-\tClusterPermissionGroups = \"system:nodes\"\n+\tClusterPermissionGroups = \"system:karmada:agents\"\n+\t// AgentRBACGenerator defines the common name of karmada agent rbac generator certificate\n+\tAgentRBACGenerator = \"system:karmada:agent:rbac-generator\"\n \t// KarmadaAgentBootstrapKubeConfigFileName defines the file name for the kubeconfig that the karmada-agent will use to do\n \t// the TLS bootstrap to get itself an unique credential\n \tKarmadaAgentBootstrapKubeConfigFileName = \"bootstrap-karmada-agent.conf\"\n@@ -97,8 +98,8 @@ const (\n \tKarmadaAgentName = \"karmada-agent\"\n \t// KarmadaAgentServiceAccountName is the name of karmada-agent serviceaccount\n \tKarmadaAgentServiceAccountName = \"karmada-agent-sa\"\n-\t// SignerName defines the signer name for csr, 'kubernetes.io/kube-apiserver-client-kubelet' can sign the csr automatically\n-\tSignerName = \"kubernetes.io/kube-apiserver-client-kubelet\"\n+\t// SignerName defines the signer name for csr, 'kubernetes.io/kube-apiserver-client' can sign the csr with `O=system:agents,CN=system:agent:` automatically if agentcsrapproving controller if enabled.\n+\tSignerName = \"kubernetes.io/kube-apiserver-client\"\n \t// BootstrapUserName defines bootstrap user name\n \tBootstrapUserName = \"token-bootstrap-client\"\n \t// DefaultClusterName defines the default cluster name\n@@ -260,6 +261,9 @@ type CommandRegisterOption struct {\n \n \tmemberClusterEndpoint string\n \tmemberClusterClient   *kubeclient.Clientset\n+\n+\t// rbacResources contains RBAC resources that grant the necessary permissions for pull mode cluster to access to Karmada control plane.\n+\trbacResources *RBACResources\n }\n \n // Complete ensures that options are valid and marshals them if necessary.\n@@ -288,6 +292,8 @@ func (o *CommandRegisterOption) Complete(args []string) error {\n \t\to.ClusterName = config.Contexts[config.CurrentContext].Cluster\n \t}\n \n+\to.rbacResources = GenerateRBACResources(o.ClusterName, o.ClusterNamespace)\n+\n \to.memberClusterEndpoint = restConfig.Host\n \n \to.memberClusterClient, err = apiclient.NewClientSet(restConfig)\n@@ -358,53 +364,107 @@ func (o *CommandRegisterOption) Run(parentCommand string) error {\n \t\treturn err\n \t}\n \n-\t// construct the final kubeconfig file used by karmada agent to connect to karmada apiserver\n-\tfmt.Println(\"[karmada-agent-start] Waiting to construct karmada-agent kubeconfig\")\n-\tkarmadaAgentCfg, err := o.constructKarmadaAgentConfig(bootstrapClient, karmadaClusterInfo)\n+\tvar rbacClient *kubeclient.Clientset\n+\tdefer func() {\n+\t\tif err != nil && rbacClient != nil {\n+\t\t\tfmt.Println(\"karmadactl register failed and started deleting the created resources\")\n+\t\t\terr = o.rbacResources.Delete(rbacClient)\n+\t\t\tif err != nil {\n+\t\t\t\tklog.Warningf(\"Failed to delete rbac resources: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\trbacClient, err = o.EnsureNecessaryResourcesExistInControlPlane(bootstrapClient, karmadaClusterInfo)\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\tfmt.Println(\"[karmada-agent-start] Waiting to check cluster exists\")\n-\tkarmadaClient, err := ToKarmadaClient(karmadaAgentCfg)\n+\terr = o.EnsureNecessaryResourcesExistInMemberCluster(bootstrapClient, karmadaClusterInfo)\n \tif err != nil {\n \t\treturn err\n \t}\n+\n+\tfmt.Printf(\"\\ncluster(%s) is joined successfully\\n\", o.ClusterName)\n+\n+\treturn nil\n+}\n+\n+// EnsureNecessaryResourcesExistInControlPlane ensures that all necessary resources are exist in Karmada control plane.\n+func (o *CommandRegisterOption) EnsureNecessaryResourcesExistInControlPlane(bootstrapClient *kubeclient.Clientset, karmadaClusterInfo *clientcmdapi.Cluster) (*kubeclient.Clientset, error) {\n+\tcsrName := \"agent-rbac-generator-\" + o.ClusterName + k8srand.String(5)\n+\trbacCfg, err := o.constructAgentRBACGeneratorConfig(bootstrapClient, karmadaClusterInfo, csrName)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tkubelient, err := ToClientSet(rbacCfg)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\terr = kubelient.CertificatesV1().CertificateSigningRequests().Delete(context.Background(), csrName, metav1.DeleteOptions{})\n+\t\tif err != nil {\n+\t\t\tklog.Warningf(\"Failed to delete CertificateSigningRequests %s: %v\", csrName, err)\n+\t\t}\n+\t}()\n+\n+\tfmt.Println(\"[karmada-agent-start] Waiting to check cluster exists\")\n+\tkarmadaClient, err := ToKarmadaClient(rbacCfg)\n+\tif err != nil {\n+\t\treturn kubelient, err\n+\t}\n \t_, exist, err := karmadautil.GetClusterWithKarmadaClient(karmadaClient, o.ClusterName)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn kubelient, err\n \t} else if exist {\n-\t\treturn fmt.Errorf(\"failed to register as cluster with name %s already exists\", o.ClusterName)\n+\t\treturn kubelient, fmt.Errorf(\"failed to register as cluster with name %s already exists\", o.ClusterName)\n+\t}\n+\n+\tfmt.Println(\"[karmada-agent-start] Assign the necessary RBAC permissions to the agent\")\n+\terr = o.ensureAgentRBACResourcesExistInControlPlane(kubelient)\n+\tif err != nil {\n+\t\treturn kubelient, err\n+\t}\n+\n+\treturn kubelient, nil\n+}\n+\n+// EnsureNecessaryResourcesExistInMemberCluster ensures that all necessary resources are exist in the registering cluster.\n+func (o *CommandRegisterOption) EnsureNecessaryResourcesExistInMemberCluster(bootstrapClient *kubeclient.Clientset, karmadaClusterInfo *clientcmdapi.Cluster) error {\n+\t// construct the final kubeconfig file used by karmada agent to connect to karmada apiserver\n+\tfmt.Println(\"[karmada-agent-start] Waiting to construct karmada-agent kubeconfig\")\n+\tkarmadaAgentCfg, err := o.constructKarmadaAgentConfig(bootstrapClient, karmadaClusterInfo)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \n \t// It's necessary to set the label of namespace to make sure that the namespace is created by Karmada.\n \tlabels := map[string]string{\n \t\tkarmadautil.KarmadaSystemLabel: karmadautil.KarmadaSystemLabelValue,\n \t}\n \t// ensure namespace where the karmada-agent resources be deployed exists in the member cluster\n-\tif _, err := karmadautil.EnsureNamespaceExistWithLabels(o.memberClusterClient, o.Namespace, o.DryRun, labels); err != nil {\n+\tif _, err = karmadautil.EnsureNamespaceExistWithLabels(o.memberClusterClient, o.Namespace, o.DryRun, labels); err != nil {\n \t\treturn err\n \t}\n \n \t// create the necessary secret and RBAC in the member cluster\n \tfmt.Println(\"[karmada-agent-start] Waiting the necessary secret and RBAC\")\n-\tif err := o.createSecretAndRBACInMemberCluster(karmadaAgentCfg); err != nil {\n+\tif err = o.createSecretAndRBACInMemberCluster(karmadaAgentCfg); err != nil {\n \t\treturn err\n \t}\n \n \t// create karmada-agent Deployment in the member cluster\n \tfmt.Println(\"[karmada-agent-start] Waiting karmada-agent Deployment\")\n \tKarmadaAgentDeployment := o.makeKarmadaAgentDeployment()\n-\tif _, err := o.memberClusterClient.AppsV1().Deployments(o.Namespace).Create(context.TODO(), KarmadaAgentDeployment, metav1.CreateOptions{}); err != nil {\n+\tif _, err = o.memberClusterClient.AppsV1().Deployments(o.Namespace).Create(context.TODO(), KarmadaAgentDeployment, metav1.CreateOptions{}); err != nil {\n \t\treturn err\n \t}\n \n-\tif err := addonutils.WaitForDeploymentRollout(o.memberClusterClient, KarmadaAgentDeployment, int(o.Timeout)); err != nil {\n+\tif err = cmdutil.WaitForDeploymentRollout(o.memberClusterClient, KarmadaAgentDeployment, int(o.Timeout)); err != nil {\n \t\treturn err\n \t}\n \n-\tfmt.Printf(\"\\ncluster(%s) is joined successfully\\n\", o.ClusterName)\n-\n \treturn nil\n }\n \n@@ -505,11 +565,316 @@ func (o *CommandRegisterOption) discoveryBootstrapConfigAndClusterInfo(bootstrap\n \treturn bootstrapClient, clusterinfo, nil\n }\n \n-// constructKarmadaAgentConfig construct the final kubeconfig used by karmada-agent\n-func (o *CommandRegisterOption) constructKarmadaAgentConfig(bootstrapClient *kubeclient.Clientset, karmadaClusterInfo *clientcmdapi.Cluster) (*clientcmdapi.Config, error) {\n+// ensureAgentRBACResourcesExistInControlPlane ensures that necessary RBAC resources for karmada-agent are exist in control plane.\n+func (o *CommandRegisterOption) ensureAgentRBACResourcesExistInControlPlane(client kubeclient.Interface) error {\n+\tfor i := range o.rbacResources.ClusterRoles {\n+\t\t_, err := karmadautil.CreateClusterRole(client, o.rbacResources.ClusterRoles[i])\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tfor i := range o.rbacResources.ClusterRoleBindings {\n+\t\t_, err := karmadautil.CreateClusterRoleBinding(client, o.rbacResources.ClusterRoleBindings[i])\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tfor i := range o.rbacResources.Roles {\n+\t\troleNamespace := &corev1.Namespace{\n+\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\tName: o.rbacResources.Roles[i].GetNamespace(),\n+\t\t\t\tLabels: map[string]string{\n+\t\t\t\t\tkarmadautil.KarmadaSystemLabel: karmadautil.KarmadaSystemLabelValue,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\t_, err := karmadautil.CreateNamespace(client, roleNamespace)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t_, err = karmadautil.CreateRole(client, o.rbacResources.Roles[i])\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tfor i := range o.rbacResources.RoleBindings {\n+\t\t_, err := karmadautil.CreateRoleBinding(client, o.rbacResources.RoleBindings[i])\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// RBACResources defines the list of rbac resources.\n+type RBACResources struct {\n+\tClusterRoles        []*rbacv1.ClusterRole\n+\tClusterRoleBindings []*rbacv1.ClusterRoleBinding\n+\tRoles               []*rbacv1.Role\n+\tRoleBindings        []*rbacv1.RoleBinding\n+}\n+\n+// GenerateRBACResources generates rbac resources.\n+func GenerateRBACResources(clusterName, clusterNamespace string) *RBACResources {\n+\treturn &RBACResources{\n+\t\tClusterRoles:        []*rbacv1.ClusterRole{GenerateClusterRole(clusterName)},\n+\t\tClusterRoleBindings: []*rbacv1.ClusterRoleBinding{GenerateClusterRoleBinding(clusterName)},\n+\t\tRoles:               []*rbacv1.Role{GenerateSecretAccessRole(clusterName, clusterNamespace), GenerateWorkAccessRole(clusterName)},\n+\t\tRoleBindings:        []*rbacv1.RoleBinding{GenerateSecretAccessRoleBinding(clusterName, clusterNamespace), GenerateWorkAccessRoleBinding(clusterName)},\n+\t}\n+}\n+\n+// List return the list of rbac resources.\n+func (r *RBACResources) List() []Obj {\n+\tvar obj []Obj\n+\tfor i := range r.ClusterRoles {\n+\t\tobj = append(obj, Obj{Kind: \"ClusterRole\", Name: r.ClusterRoles[i].GetName()})\n+\t}\n+\tfor i := range r.ClusterRoleBindings {\n+\t\tobj = append(obj, Obj{Kind: \"ClusterRoleBinding\", Name: r.ClusterRoleBindings[i].GetName()})\n+\t}\n+\tfor i := range r.Roles {\n+\t\tobj = append(obj, Obj{Kind: \"Role\", Name: r.Roles[i].GetName(), Namespace: r.Roles[i].GetNamespace()})\n+\t}\n+\tfor i := range r.RoleBindings {\n+\t\tobj = append(obj, Obj{Kind: \"RoleBinding\", Name: r.RoleBindings[i].GetName(), Namespace: r.RoleBindings[i].GetNamespace()})\n+\t}\n+\treturn obj\n+}\n+\n+// ToString returns a list of RBAC resources in string format.\n+func (r *RBACResources) ToString() string {\n+\tvar resources []string\n+\tfor i := range r.List() {\n+\t\tresources = append(resources, r.List()[i].ToString())\n+\t}\n+\treturn strings.Join(resources, \"\\n\")\n+}\n+\n+// Delete deletes RBAC resources.\n+func (r *RBACResources) Delete(client kubeclient.Interface) error {\n+\tvar err error\n+\tfor _, resource := range r.List() {\n+\t\tswitch resource.Kind {\n+\t\tcase \"ClusterRole\":\n+\t\t\terr = karmadautil.DeleteClusterRole(client, resource.Name)\n+\t\tcase \"ClusterRoleBinding\":\n+\t\t\terr = karmadautil.DeleteClusterRoleBinding(client, resource.Name)\n+\t\tcase \"Role\":\n+\t\t\terr = karmadautil.DeleteRole(client, resource.Namespace, resource.Name)\n+\t\tcase \"RoleBinding\":\n+\t\t\terr = karmadautil.DeleteRoleBinding(client, resource.Namespace, resource.Name)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Obj defines the struct which contains the information of kind, name and namespace.\n+type Obj struct{ Kind, Name, Namespace string }\n+\n+// ToString returns a string that concatenates kind, name, and namespace using \"/\".\n+func (o *Obj) ToString() string {\n+\tif o.Namespace == \"\" {\n+\t\treturn fmt.Sprintf(\"%s/%s\", o.Kind, o.Name)\n+\t}\n+\treturn fmt.Sprintf(\"%s/%s/%s\", o.Kind, o.Namespace, o.Name)\n+}\n+\n+// GenerateClusterRole generates the clusterRole that karmada-agent needed.\n+func GenerateClusterRole(clusterName string) *rbacv1.ClusterRole {\n+\tclusterRoleName := fmt.Sprintf(\"system:karmada:%s:agent\", clusterName)\n+\treturn &rbacv1.ClusterRole{\n+\t\tTypeMeta: metav1.TypeMeta{\n+\t\t\tAPIVersion: rbacv1.SchemeGroupVersion.String(),\n+\t\t\tKind:       \"ClusterRole\",\n+\t\t},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName: clusterRoleName,\n+\t\t},\n+\t\tRules: []rbacv1.PolicyRule{\n+\t\t\t{\n+\t\t\t\tAPIGroups:     []string{\"cluster.karmada.io\"},\n+\t\t\t\tResources:     []string{\"clusters\"},\n+\t\t\t\tResourceNames: []string{clusterName},\n+\t\t\t\tVerbs:         []string{\"get\", \"delete\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"cluster.karmada.io\"},\n+\t\t\t\tResources: []string{\"clusters\"},\n+\t\t\t\tVerbs:     []string{\"create\", \"list\", \"watch\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups:     []string{\"cluster.karmada.io\"},\n+\t\t\t\tResources:     []string{\"clusters/status\"},\n+\t\t\t\tResourceNames: []string{clusterName},\n+\t\t\t\tVerbs:         []string{\"update\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"config.karmada.io\"},\n+\t\t\t\tResources: []string{\"resourceinterpreterwebhookconfigurations\", \"resourceinterpretercustomizations\"},\n+\t\t\t\tVerbs:     []string{\"get\", \"list\", \"watch\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"\"},\n+\t\t\t\tResources: []string{\"namespaces\"},\n+\t\t\t\tVerbs:     []string{\"get\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"coordination.k8s.io\"},\n+\t\t\t\tResources: []string{\"leases\"},\n+\t\t\t\tVerbs:     []string{\"get\", \"create\", \"update\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"certificates.k8s.io\"},\n+\t\t\t\tResources: []string{\"certificatesigningrequests\"},\n+\t\t\t\tVerbs:     []string{\"get\", \"create\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"\"},\n+\t\t\t\tResources: []string{\"services\"},\n+\t\t\t\tVerbs:     []string{\"list\", \"watch\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tAPIGroups: []string{\"\"},\n+\t\t\t\tResources: []string{\"events\"},\n+\t\t\t\tVerbs:     []string{\"patch\", \"create\", \"update\"},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+// GenerateClusterRoleBinding generates the clusterRoleBinding that karmada-agent needed.\n+func GenerateClusterRoleBinding(clusterName string) *rbacv1.ClusterRoleBinding {\n+\treturn &rbacv1.ClusterRoleBinding{\n+\t\tTypeMeta: metav1.TypeMeta{\n+\t\t\tAPIVersion: \"rbac.authorization.k8s.io/v1\",\n+\t\t\tKind:       \"ClusterRoleBinding\",\n+\t\t},\n+\t\tObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf(\"system:karmada:%s:agent\", clusterName)},\n+\t\tSubjects: []rbacv1.Subject{\n+\t\t\t{\n+\t\t\t\tAPIGroup: \"rbac.authorization.k8s.io\",\n+\t\t\t\tKind:     \"User\",\n+\t\t\t\tName:     generateAgentUserName(clusterName),\n+\t\t\t},\n+\t\t},\n+\t\tRoleRef: rbacv1.RoleRef{\n+\t\t\tAPIGroup: \"rbac.authorization.k8s.io\",\n+\t\t\tKind:     \"ClusterRole\",\n+\t\t\tName:     fmt.Sprintf(\"system:karmada:%s:agent\", clusterName),\n+\t\t},\n+\t}\n+}\n+\n+// GenerateSecretAccessRole generates the secret-related Role that karmada-agent needed.\n+func GenerateSecretAccessRole(clusterName, clusterNamespace string) *rbacv1.Role {\n+\tsecretAccessRoleName := fmt.Sprintf(\"system:karmada:%s:agent-secret\", clusterName)\n+\treturn &rbacv1.Role{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      secretAccessRoleName,\n+\t\t\tNamespace: clusterNamespace,\n+\t\t},\n+\t\tRules: []rbacv1.PolicyRule{\n+\t\t\t{\n+\t\t\t\tVerbs:         []string{\"get\", \"patch\"},\n+\t\t\t\tAPIGroups:     []string{\"\"},\n+\t\t\t\tResources:     []string{\"secrets\"},\n+\t\t\t\tResourceNames: []string{clusterName, clusterName + \"-impersonator\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tVerbs:     []string{\"create\"},\n+\t\t\t\tAPIGroups: []string{\"\"},\n+\t\t\t\tResources: []string{\"secrets\"},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+// GenerateSecretAccessRoleBinding generates the secret-related RoleBinding that karmada-agent needed.\n+func GenerateSecretAccessRoleBinding(clusterName, clusterNamespace string) *rbacv1.RoleBinding {\n+\treturn &rbacv1.RoleBinding{\n+\t\tTypeMeta: metav1.TypeMeta{\n+\t\t\tAPIVersion: \"rbac.authorization.k8s.io/v1\",\n+\t\t\tKind:       \"RoleBinding\",\n+\t\t},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      fmt.Sprintf(\"system:karmada:%s:agent-secret\", clusterName),\n+\t\t\tNamespace: clusterNamespace,\n+\t\t},\n+\t\tSubjects: []rbacv1.Subject{\n+\t\t\t{\n+\t\t\t\tAPIGroup: \"rbac.authorization.k8s.io\",\n+\t\t\t\tKind:     \"User\",\n+\t\t\t\tName:     generateAgentUserName(clusterName),\n+\t\t\t},\n+\t\t},\n+\t\tRoleRef: rbacv1.RoleRef{\n+\t\t\tAPIGroup: \"rbac.authorization.k8s.io\",\n+\t\t\tKind:     \"Role\",\n+\t\t\tName:     fmt.Sprintf(\"system:karmada:%s:agent-secret\", clusterName),\n+\t\t},\n+\t}\n+}\n+\n+// GenerateWorkAccessRole generates the work-related Role that karmada-agent needed.\n+func GenerateWorkAccessRole(clusterName string) *rbacv1.Role {\n+\tworkAccessRoleName := fmt.Sprintf(\"system:karmada:%s:agent-work\", clusterName)\n+\treturn &rbacv1.Role{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      workAccessRoleName,\n+\t\t\tNamespace: \"karmada-es-\" + clusterName,\n+\t\t},\n+\t\tRules: []rbacv1.PolicyRule{\n+\t\t\t{\n+\t\t\t\tVerbs:     []string{\"get\", \"create\", \"list\", \"watch\", \"update\", \"delete\"},\n+\t\t\t\tAPIGroups: []string{\"work.karmada.io\"},\n+\t\t\t\tResources: []string{\"works\"},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tVerbs:     []string{\"patch\", \"update\"},\n+\t\t\t\tAPIGroups: []string{\"work.karmada.io\"},\n+\t\t\t\tResources: []string{\"works/status\"},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+// GenerateWorkAccessRoleBinding generates the work-related RoleBinding that karmada-agent needed.\n+func GenerateWorkAccessRoleBinding(clusterName string) *rbacv1.RoleBinding {\n+\treturn &rbacv1.RoleBinding{\n+\t\tTypeMeta: metav1.TypeMeta{\n+\t\t\tAPIVersion: \"rbac.authorization.k8s.io/v1\",\n+\t\t\tKind:       \"RoleBinding\",\n+\t\t},\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      fmt.Sprintf(\"system:karmada:%s:agent-work\", clusterName),\n+\t\t\tNamespace: \"karmada-es-\" + clusterName,\n+\t\t},\n+\t\tSubjects: []rbacv1.Subject{\n+\t\t\t{\n+\t\t\t\tAPIGroup: \"rbac.authorization.k8s.io\",\n+\t\t\t\tKind:     \"User\",\n+\t\t\t\tName:     generateAgentUserName(clusterName),\n+\t\t\t},\n+\t\t},\n+\t\tRoleRef: rbacv1.RoleRef{\n+\t\t\tAPIGroup: \"rbac.authorization.k8s.io\",\n+\t\t\tKind:     \"Role\",\n+\t\t\tName:     fmt.Sprintf(\"system:karmada:%s:agent-work\", clusterName),\n+\t\t},\n+\t}\n+}\n+\n+func (o *CommandRegisterOption) constructKubeConfig(bootstrapClient *kubeclient.Clientset, karmadaClusterInfo *clientcmdapi.Cluster, csrName, commonName string, organization []string) (*clientcmdapi.Config, error) {\n \tvar cert []byte\n \n-\tpk, csr, err := generateKeyAndCSR(o.ClusterName)\n+\tpk, csr, err := generateKeyAndCSR(commonName, organization)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -519,8 +884,6 @@ func (o *CommandRegisterOption) constructKarmadaAgentConfig(bootstrapClient *kub\n \t\treturn nil, err\n \t}\n \n-\tcsrName := o.ClusterName + \"-\" + k8srand.String(5)\n-\n \tcertificateSigningRequest := &certificatesv1.CertificateSigningRequest{\n \t\tObjectMeta: metav1.ObjectMeta{\n \t\t\tName: csrName,\n@@ -547,35 +910,45 @@ func (o *CommandRegisterOption) constructKarmadaAgentConfig(bootstrapClient *kub\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n-\tklog.V(1).Infof(\"Waiting for the client certificate to be issued\")\n+\tklog.V(1).Infof(fmt.Sprintf(\"Waiting for the client certificate %s to be issued\", csrName))\n \terr = wait.PollUntilContextTimeout(context.TODO(), 1*time.Second, o.Timeout, false, func(context.Context) (done bool, err error) {\n \t\tcsrOK, err := bootstrapClient.CertificatesV1().CertificateSigningRequests().Get(context.TODO(), csrName, metav1.GetOptions{})\n \t\tif err != nil {\n-\t\t\treturn false, fmt.Errorf(\"failed to get the cluster csr %s. err: %v\", o.ClusterName, err)\n+\t\t\treturn false, fmt.Errorf(\"failed to get the cluster csr %s. err: %v\", csrName, err)\n \t\t}\n \n \t\tif csrOK.Status.Certificate != nil {\n-\t\t\tklog.V(1).Infof(\"Signing certificate successfully\")\n+\t\t\tklog.V(1).Infof(fmt.Sprintf(\"Signing certificate of csr %s successfully\", csrName))\n \t\t\tcert = csrOK.Status.Certificate\n \t\t\treturn true, nil\n \t\t}\n \n-\t\tklog.V(1).Infof(\"Waiting for the client certificate to be issued\")\n+\t\tklog.V(1).Infof(fmt.Sprintf(\"Waiting for the client certificate of csr %s to be issued\", csrName))\n+\t\tklog.V(1).Infof(\"Approve the CSR %s manually by executing `kubectl certificate approve %s` on the control plane\", csrName, csrName)\n \t\treturn false, nil\n \t})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tkarmadaAgentCfg := CreateWithCert(\n+\treturn CreateWithCert(\n \t\tkarmadaClusterInfo.Server,\n \t\tDefaultClusterName,\n \t\to.ClusterName,\n \t\tkarmadaClusterInfo.CertificateAuthorityData,\n \t\tcert,\n \t\tpkData,\n-\t)\n+\t), nil\n+}\n+\n+// constructKarmadaAgentConfig constructs the final kubeconfig used by karmada-agent\n+func (o *CommandRegisterOption) constructKarmadaAgentConfig(bootstrapClient *kubeclient.Clientset, karmadaClusterInfo *clientcmdapi.Cluster) (*clientcmdapi.Config, error) {\n+\tcsrName := o.ClusterName + \"-\" + k8srand.String(5)\n+\n+\tkarmadaAgentCfg, err := o.constructKubeConfig(bootstrapClient, karmadaClusterInfo, csrName, generateAgentUserName(o.ClusterName), []string{ClusterPermissionGroups})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \n \tkubeConfigFile := filepath.Join(KarmadaDir, KarmadaAgentKubeConfigFileName)\n \n@@ -588,6 +961,11 @@ func (o *CommandRegisterOption) constructKarmadaAgentConfig(bootstrapClient *kub\n \treturn karmadaAgentCfg, nil\n }\n \n+// constructKarmadaAgentConfig constructs the kubeconfig to generate rbac config for karmada-agent.\n+func (o *CommandRegisterOption) constructAgentRBACGeneratorConfig(bootstrapClient *kubeclient.Clientset, karmadaClusterInfo *clientcmdapi.Cluster, csrName string) (*clientcmdapi.Config, error) {\n+\treturn o.constructKubeConfig(bootstrapClient, karmadaClusterInfo, csrName, AgentRBACGenerator, []string{ClusterPermissionGroups})\n+}\n+\n // createSecretAndRBACInMemberCluster create required secrets and rbac in member cluster\n func (o *CommandRegisterOption) createSecretAndRBACInMemberCluster(karmadaAgentCfg *clientcmdapi.Config) error {\n \tconfigBytes, err := clientcmd.Write(*karmadaAgentCfg)\n@@ -781,16 +1159,16 @@ func (o *CommandRegisterOption) makeKarmadaAgentDeployment() *appsv1.Deployment\n }\n \n // generateKeyAndCSR generate private key and csr\n-func generateKeyAndCSR(clusterName string) (*rsa.PrivateKey, []byte, error) {\n+func generateKeyAndCSR(commonName string, organization []string) (*rsa.PrivateKey, []byte, error) {\n \tpk, err := rsa.GenerateKey(rand.Reader, 3072)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n \n \tcsr, err := x509.CreateCertificateRequest(rand.Reader, &x509.CertificateRequest{\n \t\tSubject: pkix.Name{\n-\t\t\tCommonName:   ClusterPermissionPrefix + clusterName,\n-\t\t\tOrganization: []string{ClusterPermissionGroups},\n+\t\t\tCommonName:   commonName,\n+\t\t\tOrganization: organization,\n \t\t},\n \t}, pk)\n \tif err != nil {\n@@ -1070,3 +1448,7 @@ func ToKarmadaClient(config *clientcmdapi.Config) (*karmadaclientset.Clientset,\n \n \treturn karmadaClient, nil\n }\n+\n+func generateAgentUserName(clusterName string) string {\n+\treturn ClusterPermissionPrefix + clusterName\n+}"
        },
        {
          "filename": "pkg/karmadactl/unregister/unregister.go",
          "status": "modified",
          "additions": 57,
          "deletions": 32,
          "patch": "@@ -135,6 +135,9 @@ type CommandUnregisterOption struct {\n \n \t// MemberClusterClient member cluster client set\n \tMemberClusterClient kubeclient.Interface\n+\n+\t// rbacResources contains RBAC resources that grant the necessary permissions for the unregistering cluster to access to Karmada control plane.\n+\trbacResources *register.RBACResources\n }\n \n // AddFlags adds flags to the specified FlagSet.\n@@ -157,6 +160,8 @@ func (j *CommandUnregisterOption) Complete(args []string) error {\n \tif len(args) > 0 {\n \t\tj.ClusterName = args[0]\n \t}\n+\n+\tj.rbacResources = register.GenerateRBACResources(j.ClusterName, j.ClusterNamespace)\n \treturn nil\n }\n \n@@ -303,30 +308,67 @@ func (j *CommandUnregisterOption) getKarmadaAgentConfig(agent *appsv1.Deployment\n \treturn clientcmd.Load(agentConfigSecret.Data[fileName])\n }\n \n-type obj struct{ Kind, Name, Namespace string }\n-\n-func (o *obj) ToString() string {\n-\tif o.Namespace == \"\" {\n-\t\treturn fmt.Sprintf(\"%s/%s\", o.Kind, o.Name)\n-\t}\n-\treturn fmt.Sprintf(\"%s/%s/%s\", o.Kind, o.Namespace, o.Name)\n-}\n-\n // RunUnregisterCluster unregister the pull mode cluster from karmada.\n func (j *CommandUnregisterOption) RunUnregisterCluster() error {\n \tif j.DryRun {\n \t\treturn nil\n \t}\n \n-\t// 1. delete the cluster object from the Karmada control plane\n+\tstart := time.Now()\n+\t// 1. delete the work object from the Karmada control plane\n+\t// When deleting a cluster, the deletion triggers the removal of executionSpace, which can lead to the deletion of RBAC roles related to work.\n+\t// Therefore, the deletion of work should be performed before deleting the cluster.\n+\terr := cmdutil.EnsureWorksDeleted(j.ControlPlaneClient, names.GenerateExecutionSpaceName(j.ClusterName), j.Wait)\n+\tif err != nil {\n+\t\tklog.Errorf(\"Failed to delete works object. cluster name: %s, error: %v\", j.ClusterName, err)\n+\t\treturn err\n+\t}\n+\tj.Wait = j.Wait - time.Since(start)\n+\n+\t// 2. delete the cluster object from the Karmada control plane\n \t//TODO: add flag --force to implement force deletion.\n-\tif err := cmdutil.DeleteClusterObject(j.ControlPlaneKubeClient, j.ControlPlaneClient, j.ClusterName, j.Wait, j.DryRun, false); err != nil {\n+\tif err = cmdutil.DeleteClusterObject(j.ControlPlaneKubeClient, j.ControlPlaneClient, j.ClusterName, j.Wait, j.DryRun, false); err != nil {\n \t\tklog.Errorf(\"Failed to delete cluster object. cluster name: %s, error: %v\", j.ClusterName, err)\n \t\treturn err\n \t}\n \tklog.Infof(\"Successfully delete cluster object (%s) from control plane.\", j.ClusterName)\n \n-\t// 2. delete resource created by karmada in member cluster\n+\tif j.KarmadaConfig != \"\" {\n+\t\tif err = j.rbacResources.Delete(j.ControlPlaneKubeClient); err != nil {\n+\t\t\tklog.Errorf(\"Failed to delete karmada-agent RBAC resources from control plane. cluster name: %s, error: %v\", j.ClusterName, err)\n+\t\t\treturn err\n+\t\t}\n+\t\tklog.Infof(\"Successfully delete karmada-agent RBAC resources from control plane. cluster name: %s\", j.ClusterName)\n+\t} else {\n+\t\tklog.Warningf(\"The RBAC resources on the control plane need to be manually cleaned up, including the following resources:\\n%s\", j.rbacResources.ToString())\n+\t}\n+\n+\t// 3. delete resource created by karmada in member cluster\n+\tif err = j.cleanupMemberClusterResources(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// 4. delete local obsolete files generated by karmadactl\n+\tlocalObsoleteFiles := []register.Obj{\n+\t\t{Kind: \"File\", Name: filepath.Join(register.KarmadaDir, register.KarmadaAgentKubeConfigFileName)},\n+\t\t{Kind: \"File\", Name: register.CACertPath},\n+\t}\n+\tfor _, obj := range localObsoleteFiles {\n+\t\tif err = os.Remove(obj.Name); err != nil {\n+\t\t\tif os.IsNotExist(err) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tklog.Errorf(\"Failed to delete local file (%v) in current node: %+v.\", obj.Name, err)\n+\t\t\treturn err\n+\t\t}\n+\t\tklog.Infof(\"Successfully delete local file (%v) in current node.\", obj.Name)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// cleanupMemberClusterResources clean up the resources which created by karmada in member cluster\n+func (j *CommandUnregisterOption) cleanupMemberClusterResources() error {\n \tvar err error\n \tfor _, resource := range j.listMemberClusterResources() {\n \t\tswitch resource.Kind {\n@@ -350,29 +392,12 @@ func (j *CommandUnregisterOption) RunUnregisterCluster() error {\n \t\t}\n \t\tklog.Infof(\"Successfully delete resource (%v) from member cluster (%s).\", resource, j.ClusterName)\n \t}\n-\n-\t// 3. delete local obsolete files generated by karmadactl\n-\tlocalObsoleteFiles := []obj{\n-\t\t{Kind: \"File\", Name: filepath.Join(register.KarmadaDir, register.KarmadaAgentKubeConfigFileName)},\n-\t\t{Kind: \"File\", Name: register.CACertPath},\n-\t}\n-\tfor _, obj := range localObsoleteFiles {\n-\t\tif err = os.Remove(obj.Name); err != nil {\n-\t\t\tif os.IsNotExist(err) {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tklog.Errorf(\"Failed to delete local file (%v) in current node: %+v.\", obj.Name, err)\n-\t\t\treturn err\n-\t\t}\n-\t\tklog.Infof(\"Successfully delete local file (%v) in current node.\", obj.Name)\n-\t}\n-\n-\treturn nil\n+\treturn err\n }\n \n // listMemberClusterResources lists resources to be deleted which created by karmada in member cluster\n-func (j *CommandUnregisterOption) listMemberClusterResources() []obj {\n-\treturn []obj{\n+func (j *CommandUnregisterOption) listMemberClusterResources() []register.Obj {\n+\treturn []register.Obj{\n \t\t// the rbac resource prepared for karmada-controller-manager to access member cluster's kube-apiserver\n \t\t{Kind: \"ServiceAccount\", Namespace: j.ClusterNamespace, Name: names.GenerateServiceAccountName(j.ClusterName)},\n \t\t{Kind: \"ClusterRole\", Name: names.GenerateRoleName(names.GenerateServiceAccountName(j.ClusterName))},"
        },
        {
          "filename": "pkg/karmadactl/unregister/unregister_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -216,6 +216,7 @@ func TestCommandUnregisterOption_RunUnregisterCluster(t *testing.T) {\n \t\t\t}\n \t\t\tj.ControlPlaneClient = fakekarmadaclient.NewSimpleClientset(tt.clusterObject...)\n \t\t\tj.MemberClusterClient = fake.NewSimpleClientset(tt.clusterResources...)\n+\t\t\tj.rbacResources = register.GenerateRBACResources(j.ClusterName, j.ClusterNamespace)\n \t\t\terr := j.RunUnregisterCluster()\n \t\t\tif (err == nil && tt.wantErr) || (err != nil && !tt.wantErr) {\n \t\t\t\tt.Errorf(\"RunUnregisterCluster() error = %v, wantErr %v\", err, tt.wantErr)"
        },
        {
          "filename": "pkg/karmadactl/util/work.go",
          "status": "added",
          "additions": 55,
          "deletions": 0,
          "patch": "@@ -0,0 +1,55 @@\n+/*\n+Copyright 2024 The Karmada Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package util\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"time\"\n+\n+\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/util/wait\"\n+\n+\tkarmadaclientset \"github.com/karmada-io/karmada/pkg/generated/clientset/versioned\"\n+)\n+\n+// EnsureWorksDeleted ensures that all Work resources in the specified namespace are deleted.\n+func EnsureWorksDeleted(controlPlaneKarmadaClient karmadaclientset.Interface, namespace string,\n+\ttimeout time.Duration) error {\n+\t// make sure the works object under the given namespace has been deleted.\n+\terr := wait.PollUntilContextTimeout(context.TODO(), 1*time.Second, timeout, false, func(context.Context) (done bool, err error) {\n+\t\tlist, err := controlPlaneKarmadaClient.WorkV1alpha1().Works(namespace).List(context.TODO(), metav1.ListOptions{})\n+\t\tif err != nil {\n+\t\t\treturn false, fmt.Errorf(\"failed to list work in namespace %s\", namespace)\n+\t\t}\n+\n+\t\tif len(list.Items) == 0 {\n+\t\t\treturn true, nil\n+\t\t}\n+\t\tfor i := range list.Items {\n+\t\t\twork := &list.Items[i]\n+\t\t\terr = controlPlaneKarmadaClient.WorkV1alpha1().Works(namespace).Delete(context.TODO(), work.GetName(), metav1.DeleteOptions{})\n+\t\t\tif err != nil && !apierrors.IsNotFound(err) {\n+\t\t\t\treturn false, fmt.Errorf(\"failed to delete the work(%s/%s)\", namespace, work.GetName())\n+\t\t\t}\n+\t\t}\n+\t\treturn false, nil\n+\t})\n+\n+\treturn err\n+}"
        },
        {
          "filename": "pkg/util/rbac.go",
          "status": "modified",
          "additions": 46,
          "deletions": 0,
          "patch": "@@ -191,3 +191,49 @@ func GenerateImpersonationRules(subjects []rbacv1.Subject) []rbacv1.PolicyRule {\n \n \treturn rules\n }\n+\n+// CreateRole just try to create the Role.\n+func CreateRole(client kubeclient.Interface, roleObj *rbacv1.Role) (*rbacv1.Role, error) {\n+\tcreatedObj, err := client.RbacV1().Roles(roleObj.GetNamespace()).Create(context.TODO(), roleObj, metav1.CreateOptions{})\n+\tif err != nil {\n+\t\tif apierrors.IsAlreadyExists(err) {\n+\t\t\treturn roleObj, nil\n+\t\t}\n+\n+\t\treturn nil, err\n+\t}\n+\n+\treturn createdObj, nil\n+}\n+\n+// CreateRoleBinding just try to create the RoleBinding.\n+func CreateRoleBinding(client kubeclient.Interface, roleBindingObj *rbacv1.RoleBinding) (*rbacv1.RoleBinding, error) {\n+\tcreatedObj, err := client.RbacV1().RoleBindings(roleBindingObj.GetNamespace()).Create(context.TODO(), roleBindingObj, metav1.CreateOptions{})\n+\tif err != nil {\n+\t\tif apierrors.IsAlreadyExists(err) {\n+\t\t\treturn roleBindingObj, nil\n+\t\t}\n+\n+\t\treturn nil, err\n+\t}\n+\n+\treturn createdObj, nil\n+}\n+\n+// DeleteRole just try to delete the Role.\n+func DeleteRole(client kubeclient.Interface, namespace, name string) error {\n+\terr := client.RbacV1().Roles(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{})\n+\tif err != nil && !apierrors.IsNotFound(err) {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// DeleteRoleBinding just try to delete the RoleBinding.\n+func DeleteRoleBinding(client kubeclient.Interface, namespace, name string) error {\n+\terr := client.RbacV1().RoleBindings(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{})\n+\tif err != nil && !apierrors.IsNotFound(err) {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 2,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 8,
        "max_directory_depth": 5
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "446dbe9086f5389623877d2ca887597e9da3cdb3",
            "date": "2025-01-14T02:30:43Z",
            "author_login": "karmada-bot"
          },
          {
            "sha": "b743a3b92137cbd6f946515b5ad4e6a3c5c6d296",
            "date": "2025-01-01T23:00:33Z",
            "author_login": "jabellard"
          },
          {
            "sha": "43f29532f9ee61cf354df6e2cfe862aa16b7c181",
            "date": "2025-01-13T06:38:43Z",
            "author_login": "karmada-bot"
          },
          {
            "sha": "956f008785f10cc2b11cafbeb2dc7d2cc2eb7b30",
            "date": "2025-01-13T05:42:25Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "8313813f767aa6ebd81f7a30c6450f7ea21199d7",
            "date": "2025-01-10T09:46:40Z",
            "author_login": "karmada-bot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-266",
    "description": "Karmada is a Kubernetes management system that allows users to run cloud-native applications across multiple Kubernetes clusters and clouds. Prior to version 1.12.0, the PULL mode clusters registered with the `karmadactl register` command have excessive privileges to access control plane resources. By abusing these permissions, an attacker able to authenticate as the karmada-agent to a karmada cluster would be able to obtain administrative privileges over the entire federation system including all registered member clusters. Since Karmada v1.12.0, command `karmadactl register` restricts the access permissions of pull mode member clusters to control plane resources. This way, an attacker able to authenticate as the karmada-agent cannot control other member clusters in Karmada. As a workaround, one may restrict the access permissions of pull mode member clusters to control plane resources according to Karmada Component Permissions Docs.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2025-01-03T17:15:08.840",
    "last_modified": "2025-01-03T17:15:08.840",
    "fix_date": "2024-11-20T09:22:56Z"
  },
  "references": [
    {
      "url": "https://github.com/karmada-io/karmada/commit/2c82055c4c7f469411b1ba48c4dba4841df04831",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/karmada-io/karmada/pull/5793",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/karmada-io/karmada/security/advisories/GHSA-mg7w-c9x2-xh7r",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://karmada.io/docs/administrator/security/component-permission",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:52.951561",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "karmada",
    "owner": "karmada-io",
    "created_at": "2020-11-10T11:35:54Z",
    "updated_at": "2025-01-14T09:24:22Z",
    "pushed_at": "2025-01-14T02:30:43Z",
    "size": 66562,
    "stars": 4574,
    "forks": 907,
    "open_issues": 600,
    "watchers": 4574,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master",
      "release-1.0",
      "release-1.1",
      "release-1.2",
      "release-1.3",
      "release-1.4",
      "release-1.5",
      "release-1.6",
      "release-1.7",
      "release-1.8",
      "release-1.9",
      "release-1.10",
      "release-1.11",
      "release-1.12"
    ],
    "languages": {
      "Go": 8097818,
      "Shell": 210229,
      "Smarty": 25274,
      "Mustache": 19603,
      "Makefile": 4956,
      "Dockerfile": 1629
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T14:47:59.252036"
  }
}