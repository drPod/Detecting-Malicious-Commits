{
  "cve_id": "CVE-2024-6345",
  "github_data": {
    "repository": "pypa/setuptools",
    "fix_commit": "88807c7062788254f654ea8c03427adc859321f0",
    "related_commits": [
      "88807c7062788254f654ea8c03427adc859321f0",
      "88807c7062788254f654ea8c03427adc859321f0"
    ],
    "patch_url": "https://github.com/pypa/setuptools/commit/88807c7062788254f654ea8c03427adc859321f0.patch",
    "fix_commit_details": {
      "sha": "88807c7062788254f654ea8c03427adc859321f0",
      "commit_date": "2024-04-30T00:01:38Z",
      "author": {
        "login": "jaraco",
        "type": "User",
        "stats": {
          "total_commits": 6828,
          "average_weekly_commits": 5.013215859030837,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 489
        }
      },
      "commit_message": {
        "title": "Merge pull request #4332 from pypa/debt/package-index-vcs",
        "length": 95,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 204,
        "additions": 108,
        "deletions": 96
      },
      "files": [
        {
          "filename": "newsfragments/4332.feature.rst",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+Modernized and refactored VCS handling in package_index.\n\\ No newline at end of file"
        },
        {
          "filename": "setup.cfg",
          "status": "modified",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -76,6 +76,7 @@ testing =\n \ttomli\n \t# No Python 3.12 dependencies require importlib_metadata, but needed for type-checking since we import it directly\n \timportlib_metadata\n+\tpytest-subprocess\n \n \t# workaround for pypa/setuptools#4333\n \tpyproject-hooks!=1.1"
        },
        {
          "filename": "setuptools/package_index.py",
          "status": "modified",
          "additions": 80,
          "deletions": 66,
          "patch": "@@ -1,6 +1,7 @@\n \"\"\"PyPI and direct package downloading.\"\"\"\n \n import sys\n+import subprocess\n import os\n import re\n import io\n@@ -587,7 +588,7 @@ def download(self, spec, tmpdir):\n             scheme = URL_SCHEME(spec)\n             if scheme:\n                 # It's a url, download it to tmpdir\n-                found = self._download_url(scheme.group(1), spec, tmpdir)\n+                found = self._download_url(spec, tmpdir)\n                 base, fragment = egg_info_for_url(spec)\n                 if base.endswith('.py'):\n                     found = self.gen_setup(found, fragment, tmpdir)\n@@ -816,7 +817,7 @@ def open_url(self, url, warning=None):  # noqa: C901  # is too complex (12)\n             else:\n                 raise DistutilsError(\"Download error for %s: %s\" % (url, v)) from v\n \n-    def _download_url(self, scheme, url, tmpdir):\n+    def _download_url(self, url, tmpdir):\n         # Determine download filename\n         #\n         name, fragment = egg_info_for_url(url)\n@@ -831,19 +832,59 @@ def _download_url(self, scheme, url, tmpdir):\n \n         filename = os.path.join(tmpdir, name)\n \n-        # Download the file\n-        #\n-        if scheme == 'svn' or scheme.startswith('svn+'):\n-            return self._download_svn(url, filename)\n-        elif scheme == 'git' or scheme.startswith('git+'):\n-            return self._download_git(url, filename)\n-        elif scheme.startswith('hg+'):\n-            return self._download_hg(url, filename)\n-        elif scheme == 'file':\n-            return urllib.request.url2pathname(urllib.parse.urlparse(url)[2])\n-        else:\n-            self.url_ok(url, True)  # raises error if not allowed\n-            return self._attempt_download(url, filename)\n+        return self._download_vcs(url, filename) or self._download_other(url, filename)\n+\n+    @staticmethod\n+    def _resolve_vcs(url):\n+        \"\"\"\n+        >>> rvcs = PackageIndex._resolve_vcs\n+        >>> rvcs('git+http://foo/bar')\n+        'git'\n+        >>> rvcs('hg+https://foo/bar')\n+        'hg'\n+        >>> rvcs('git:myhost')\n+        'git'\n+        >>> rvcs('hg:myhost')\n+        >>> rvcs('http://foo/bar')\n+        \"\"\"\n+        scheme = urllib.parse.urlsplit(url).scheme\n+        pre, sep, post = scheme.partition('+')\n+        # svn and git have their own protocol; hg does not\n+        allowed = set(['svn', 'git'] + ['hg'] * bool(sep))\n+        return next(iter({pre} & allowed), None)\n+\n+    def _download_vcs(self, url, spec_filename):\n+        vcs = self._resolve_vcs(url)\n+        if not vcs:\n+            return\n+        if vcs == 'svn':\n+            raise DistutilsError(\n+                f\"Invalid config, SVN download is not supported: {url}\"\n+            )\n+\n+        filename, _, _ = spec_filename.partition('#')\n+        url, rev = self._vcs_split_rev_from_url(url)\n+\n+        self.info(f\"Doing {vcs} clone from {url} to {filename}\")\n+        subprocess.check_call([vcs, 'clone', '--quiet', url, filename])\n+\n+        co_commands = dict(\n+            git=[vcs, '-C', filename, 'checkout', '--quiet', rev],\n+            hg=[vcs, '--cwd', filename, 'up', '-C', '-r', rev, '-q'],\n+        )\n+        if rev is not None:\n+            self.info(f\"Checking out {rev}\")\n+            subprocess.check_call(co_commands[vcs])\n+\n+        return filename\n+\n+    def _download_other(self, url, filename):\n+        scheme = urllib.parse.urlsplit(url).scheme\n+        if scheme == 'file':  # pragma: no cover\n+            return urllib.request.url2pathname(urllib.parse.urlparse(url).path)\n+        # raise error if not allowed\n+        self.url_ok(url, True)\n+        return self._attempt_download(url, filename)\n \n     def scan_url(self, url):\n         self.process_url(url, True)\n@@ -859,64 +900,37 @@ def _invalid_download_html(self, url, headers, filename):\n         os.unlink(filename)\n         raise DistutilsError(f\"Unexpected HTML page found at {url}\")\n \n-    def _download_svn(self, url, _filename):\n-        raise DistutilsError(f\"Invalid config, SVN download is not supported: {url}\")\n-\n     @staticmethod\n-    def _vcs_split_rev_from_url(url, pop_prefix=False):\n-        scheme, netloc, path, query, frag = urllib.parse.urlsplit(url)\n+    def _vcs_split_rev_from_url(url):\n+        \"\"\"\n+        Given a possible VCS URL, return a clean URL and resolved revision if any.\n+\n+        >>> vsrfu = PackageIndex._vcs_split_rev_from_url\n+        >>> vsrfu('git+https://github.com/pypa/setuptools@v69.0.0#egg-info=setuptools')\n+        ('https://github.com/pypa/setuptools', 'v69.0.0')\n+        >>> vsrfu('git+https://github.com/pypa/setuptools#egg-info=setuptools')\n+        ('https://github.com/pypa/setuptools', None)\n+        >>> vsrfu('http://foo/bar')\n+        ('http://foo/bar', None)\n+        \"\"\"\n+        parts = urllib.parse.urlsplit(url)\n \n-        scheme = scheme.split('+', 1)[-1]\n+        clean_scheme = parts.scheme.split('+', 1)[-1]\n \n         # Some fragment identification fails\n-        path = path.split('#', 1)[0]\n-\n-        rev = None\n-        if '@' in path:\n-            path, rev = path.rsplit('@', 1)\n-\n-        # Also, discard fragment\n-        url = urllib.parse.urlunsplit((scheme, netloc, path, query, ''))\n-\n-        return url, rev\n-\n-    def _download_git(self, url, filename):\n-        filename = filename.split('#', 1)[0]\n-        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)\n-\n-        self.info(\"Doing git clone from %s to %s\", url, filename)\n-        os.system(\"git clone --quiet %s %s\" % (url, filename))\n-\n-        if rev is not None:\n-            self.info(\"Checking out %s\", rev)\n-            os.system(\n-                \"git -C %s checkout --quiet %s\"\n-                % (\n-                    filename,\n-                    rev,\n-                )\n-            )\n+        no_fragment_path, _, _ = parts.path.partition('#')\n \n-        return filename\n+        pre, sep, post = no_fragment_path.rpartition('@')\n+        clean_path, rev = (pre, post) if sep else (post, None)\n \n-    def _download_hg(self, url, filename):\n-        filename = filename.split('#', 1)[0]\n-        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)\n+        resolved = parts._replace(\n+            scheme=clean_scheme,\n+            path=clean_path,\n+            # discard the fragment\n+            fragment='',\n+        ).geturl()\n \n-        self.info(\"Doing hg clone from %s to %s\", url, filename)\n-        os.system(\"hg clone --quiet %s %s\" % (url, filename))\n-\n-        if rev is not None:\n-            self.info(\"Updating to %s\", rev)\n-            os.system(\n-                \"hg --cwd %s up -C -r %s -q\"\n-                % (\n-                    filename,\n-                    rev,\n-                )\n-            )\n-\n-        return filename\n+        return resolved, rev\n \n     def debug(self, msg, *args):\n         log.debug(msg, *args)"
        },
        {
          "filename": "setuptools/tests/test_packageindex.py",
          "status": "modified",
          "additions": 26,
          "deletions": 30,
          "patch": "@@ -3,7 +3,6 @@\n import urllib.error\n import http.client\n from inspect import cleandoc\n-from unittest import mock\n \n import pytest\n \n@@ -171,49 +170,46 @@ def test_egg_fragment(self):\n             assert dists[0].version == ''\n             assert dists[1].version == vc\n \n-    def test_download_git_with_rev(self, tmpdir):\n+    def test_download_git_with_rev(self, tmp_path, fp):\n         url = 'git+https://github.example/group/project@master#egg=foo'\n         index = setuptools.package_index.PackageIndex()\n \n-        with mock.patch(\"os.system\") as os_system_mock:\n-            result = index.download(url, str(tmpdir))\n+        expected_dir = tmp_path / 'project@master'\n+        fp.register([\n+            'git',\n+            'clone',\n+            '--quiet',\n+            'https://github.example/group/project',\n+            expected_dir,\n+        ])\n+        fp.register(['git', '-C', expected_dir, 'checkout', '--quiet', 'master'])\n \n-        os_system_mock.assert_called()\n+        result = index.download(url, tmp_path)\n \n-        expected_dir = str(tmpdir / 'project@master')\n-        expected = (\n-            'git clone --quiet ' 'https://github.example/group/project {expected_dir}'\n-        ).format(**locals())\n-        first_call_args = os_system_mock.call_args_list[0][0]\n-        assert first_call_args == (expected,)\n+        assert result == str(expected_dir)\n+        assert len(fp.calls) == 2\n \n-        tmpl = 'git -C {expected_dir} checkout --quiet master'\n-        expected = tmpl.format(**locals())\n-        assert os_system_mock.call_args_list[1][0] == (expected,)\n-        assert result == expected_dir\n-\n-    def test_download_git_no_rev(self, tmpdir):\n+    def test_download_git_no_rev(self, tmp_path, fp):\n         url = 'git+https://github.example/group/project#egg=foo'\n         index = setuptools.package_index.PackageIndex()\n \n-        with mock.patch(\"os.system\") as os_system_mock:\n-            result = index.download(url, str(tmpdir))\n-\n-        os_system_mock.assert_called()\n-\n-        expected_dir = str(tmpdir / 'project')\n-        expected = (\n-            'git clone --quiet ' 'https://github.example/group/project {expected_dir}'\n-        ).format(**locals())\n-        os_system_mock.assert_called_once_with(expected)\n-\n-    def test_download_svn(self, tmpdir):\n+        expected_dir = tmp_path / 'project'\n+        fp.register([\n+            'git',\n+            'clone',\n+            '--quiet',\n+            'https://github.example/group/project',\n+            expected_dir,\n+        ])\n+        index.download(url, tmp_path)\n+\n+    def test_download_svn(self, tmp_path):\n         url = 'svn+https://svn.example/project#egg=foo'\n         index = setuptools.package_index.PackageIndex()\n \n         msg = r\".*SVN download is not supported.*\"\n         with pytest.raises(distutils.errors.DistutilsError, match=msg):\n-            index.download(url, str(tmpdir))\n+            index.download(url, tmp_path)\n \n \n class TestContentCheckers:"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 4,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fb7f3d3cab98f2c00cbf18fe887ce73007f49e18",
            "date": "2025-01-09T18:24:19Z",
            "author_login": "abravalheri"
          },
          {
            "sha": "2226d6df6b62ad7c7b667b86308e1ca422d3f9ed",
            "date": "2025-01-09T18:03:45Z",
            "author_login": "cdce8p"
          },
          {
            "sha": "5c9d9809dec1b20e2a9da6b4a06355fd6f87a190",
            "date": "2025-01-08T17:45:19Z",
            "author_login": "abravalheri"
          },
          {
            "sha": "72c422261b40f2b95a8be6605cc7dd93cec81794",
            "date": "2025-01-08T17:15:33Z",
            "author_login": "abravalheri"
          },
          {
            "sha": "1c61d4799438677c7cfaaccf281312bfb1aee9b3",
            "date": "2025-01-08T17:13:27Z",
            "author_login": "abravalheri"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-94",
    "description": "A vulnerability in the package_index module of pypa/setuptools versions up to 69.1.1 allows for remote code execution via its download functions. These functions, which are used to download packages from URLs provided by users or retrieved from package index servers, are susceptible to code injection. If these functions are exposed to user-controlled inputs, such as package URLs, they can execute arbitrary commands on the system. The issue is fixed in version 70.0.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-07-15T01:15:01.730",
    "last_modified": "2024-11-21T09:49:28.170",
    "fix_date": "2024-04-30T00:01:38Z"
  },
  "references": [
    {
      "url": "https://github.com/pypa/setuptools/commit/88807c7062788254f654ea8c03427adc859321f0",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/d6362117-ad57-4e83-951f-b8141c6e7ca5",
      "source": "security@huntr.dev",
      "tags": []
    },
    {
      "url": "https://github.com/pypa/setuptools/commit/88807c7062788254f654ea8c03427adc859321f0",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://huntr.com/bounties/d6362117-ad57-4e83-951f-b8141c6e7ca5",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:31.482562",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "setuptools",
    "owner": "pypa",
    "created_at": "2016-03-29T14:02:33Z",
    "updated_at": "2025-01-13T05:35:19Z",
    "pushed_at": "2025-01-09T18:24:19Z",
    "size": 46967,
    "stars": 2569,
    "forks": 1237,
    "open_issues": 637,
    "watchers": 2569,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 3831019,
      "C": 36473,
      "HTML": 266,
      "CMake": 209
    },
    "commit_activity": {
      "total_commits_last_year": 1520,
      "avg_commits_per_week": 29.23076923076923,
      "days_active_last_year": 198
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:39:36.126277"
  }
}