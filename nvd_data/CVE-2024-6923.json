{
  "cve_id": "CVE-2024-6923",
  "github_data": {
    "repository": "python/cpython",
    "fix_commit": "06f28dc236708f72871c64d4bc4b4ea144c50147",
    "related_commits": [
      "06f28dc236708f72871c64d4bc4b4ea144c50147",
      "4766d1200fdf8b6728137aa2927a297e224d5fa7",
      "4aaa4259b5a6e664b7316a4d60bdec7ee0f124d0",
      "b158a76ce094897c870fb6b3de62887b7ccc33f1",
      "f7be505d137a22528cb0fc004422c0081d5d90e6",
      "f7c0f09e69e950cf3c5ada9dbde93898eb975533"
    ],
    "patch_url": "https://github.com/python/cpython/commit/06f28dc236708f72871c64d4bc4b4ea144c50147.patch",
    "fix_commit_details": {
      "sha": "06f28dc236708f72871c64d4bc4b4ea144c50147",
      "commit_date": "2024-09-04T15:38:31Z",
      "author": {
        "login": "ambv",
        "type": "User",
        "stats": {
          "total_commits": 417,
          "average_weekly_commits": 0.23192436040044495,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 134
        }
      },
      "commit_message": {
        "title": "[3.10] gh-121650: Encode newlines in headers, and verify headers are sound (GH-122233) (#122609)",
        "length": 928,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 166,
        "additions": 162,
        "deletions": 4
      },
      "files": [
        {
          "filename": "Doc/library/email.errors.rst",
          "status": "modified",
          "additions": 6,
          "deletions": 0,
          "patch": "@@ -59,6 +59,12 @@ The following exception classes are defined in the :mod:`email.errors` module:\n    :class:`~email.mime.image.MIMEImage`).\n \n \n+.. exception:: HeaderWriteError()\n+\n+   Raised when an error occurs when the :mod:`~email.generator` outputs\n+   headers.\n+\n+\n Here is the list of the defects that the :class:`~email.parser.FeedParser`\n can find while parsing messages.  Note that the defects are added to the message\n where the problem was found, so for example, if a message nested inside a"
        },
        {
          "filename": "Doc/library/email.policy.rst",
          "status": "modified",
          "additions": 18,
          "deletions": 0,
          "patch": "@@ -229,6 +229,24 @@ added matters.  To illustrate::\n \n       .. versionadded:: 3.6\n \n+\n+   .. attribute:: verify_generated_headers\n+\n+      If ``True`` (the default), the generator will raise\n+      :exc:`~email.errors.HeaderWriteError` instead of writing a header\n+      that is improperly folded or delimited, such that it would\n+      be parsed as multiple headers or joined with adjacent data.\n+      Such headers can be generated by custom header classes or bugs\n+      in the ``email`` module.\n+\n+      As it's a security feature, this defaults to ``True`` even in the\n+      :class:`~email.policy.Compat32` policy.\n+      For backwards compatible, but unsafe, behavior, it must be set to\n+      ``False`` explicitly.\n+\n+      .. versionadded:: 3.10.15\n+\n+\n    The following :class:`Policy` method is intended to be called by code using\n    the email library to create policy instances with custom settings:\n "
        },
        {
          "filename": "Doc/whatsnew/3.10.rst",
          "status": "modified",
          "additions": 12,
          "deletions": 0,
          "patch": "@@ -2372,3 +2372,15 @@ ipaddress\n \n * Fixed ``is_global`` and ``is_private`` behavior in ``IPv4Address``,\n   ``IPv6Address``, ``IPv4Network`` and ``IPv6Network``.\n+\n+email\n+-----\n+\n+* Headers with embedded newlines are now quoted on output.\n+\n+  The :mod:`~email.generator` will now refuse to serialize (write) headers\n+  that are improperly folded or delimited, such that they would be parsed as\n+  multiple headers or joined with adjacent data.\n+  If you need to turn this safety feature off,\n+  set :attr:`~email.policy.Policy.verify_generated_headers`.\n+  (Contributed by Bas Bloemsaat and Petr Viktorin in :gh:`121650`.)"
        },
        {
          "filename": "Lib/email/_header_value_parser.py",
          "status": "modified",
          "additions": 9,
          "deletions": 3,
          "patch": "@@ -92,6 +92,8 @@\n ASPECIALS = TSPECIALS | set(\"*'%\")\n ATTRIBUTE_ENDS = ASPECIALS | WSP\n EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set('%')\n+NLSET = {'\\n', '\\r'}\n+SPECIALSNL = SPECIALS | NLSET\n \n def quote_string(value):\n     return '\"'+str(value).replace('\\\\', '\\\\\\\\').replace('\"', r'\\\"')+'\"'\n@@ -2778,9 +2780,13 @@ def _refold_parse_tree(parse_tree, *, policy):\n             wrap_as_ew_blocked -= 1\n             continue\n         tstr = str(part)\n-        if part.token_type == 'ptext' and set(tstr) & SPECIALS:\n-            # Encode if tstr contains special characters.\n-            want_encoding = True\n+        if not want_encoding:\n+            if part.token_type == 'ptext':\n+                # Encode if tstr contains special characters.\n+                want_encoding = not SPECIALSNL.isdisjoint(tstr)\n+            else:\n+                # Encode if tstr contains newlines.\n+                want_encoding = not NLSET.isdisjoint(tstr)\n         try:\n             tstr.encode(encoding)\n             charset = encoding"
        },
        {
          "filename": "Lib/email/_policybase.py",
          "status": "modified",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -157,6 +157,13 @@ class Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     message_factory     -- the class to use to create new message objects.\n                            If the value is None, the default is Message.\n \n+    verify_generated_headers\n+                        -- if true, the generator verifies that each header\n+                           they are properly folded, so that a parser won't\n+                           treat it as multiple headers, start-of-body, or\n+                           part of another header.\n+                           This is a check against custom Header & fold()\n+                           implementations.\n     \"\"\"\n \n     raise_on_defect = False\n@@ -165,6 +172,7 @@ class Policy(_PolicyBase, metaclass=abc.ABCMeta):\n     max_line_length = 78\n     mangle_from_ = False\n     message_factory = None\n+    verify_generated_headers = True\n \n     def handle_defect(self, obj, defect):\n         \"\"\"Based on policy, either raise defect or call register_defect."
        },
        {
          "filename": "Lib/email/errors.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -29,6 +29,10 @@ class CharsetError(MessageError):\n     \"\"\"An illegal charset was given.\"\"\"\n \n \n+class HeaderWriteError(MessageError):\n+    \"\"\"Error while writing headers.\"\"\"\n+\n+\n # These are parsing defects which the parser was able to work around.\n class MessageDefect(ValueError):\n     \"\"\"Base class for a message defect.\"\"\""
        },
        {
          "filename": "Lib/email/generator.py",
          "status": "modified",
          "additions": 12,
          "deletions": 1,
          "patch": "@@ -14,12 +14,14 @@\n from copy import deepcopy\n from io import StringIO, BytesIO\n from email.utils import _has_surrogates\n+from email.errors import HeaderWriteError\n \n UNDERSCORE = '_'\n NL = '\\n'  # XXX: no longer used by the code below.\n \n NLCRE = re.compile(r'\\r\\n|\\r|\\n')\n fcre = re.compile(r'^From ', re.MULTILINE)\n+NEWLINE_WITHOUT_FWSP = re.compile(r'\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]')\n \n \n \f\n@@ -223,7 +225,16 @@ def _dispatch(self, msg):\n \n     def _write_headers(self, msg):\n         for h, v in msg.raw_items():\n-            self.write(self.policy.fold(h, v))\n+            folded = self.policy.fold(h, v)\n+            if self.policy.verify_generated_headers:\n+                linesep = self.policy.linesep\n+                if not folded.endswith(self.policy.linesep):\n+                    raise HeaderWriteError(\n+                        f'folded header does not end with {linesep!r}: {folded!r}')\n+                if NEWLINE_WITHOUT_FWSP.search(folded.removesuffix(linesep)):\n+                    raise HeaderWriteError(\n+                        f'folded header contains newline: {folded!r}')\n+            self.write(folded)\n         # A blank line always separates headers from body\n         self.write(self._NL)\n "
        },
        {
          "filename": "Lib/test/test_email/test_generator.py",
          "status": "modified",
          "additions": 62,
          "deletions": 0,
          "patch": "@@ -6,6 +6,7 @@\n from email.generator import Generator, BytesGenerator\n from email.headerregistry import Address\n from email import policy\n+import email.errors\n from test.test_email import TestEmailBase, parameterize\n \n \n@@ -216,6 +217,44 @@ def test_rfc2231_wrapping_switches_to_default_len_if_too_narrow(self):\n         g.flatten(msg)\n         self.assertEqual(s.getvalue(), self.typ(expected))\n \n+    def test_keep_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=80))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n+    def test_keep_long_encoded_newlines(self):\n+        msg = self.msgmaker(self.typ(textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject=?UTF-8?Q?=0A?=Bcc: injection@example.com\n+\n+            None\n+            \"\"\")))\n+        expected = textwrap.dedent(\"\"\"\\\n+            To: nobody\n+            Subject: Bad subject\n+             =?utf-8?q?=0A?=Bcc:\n+             injection@example.com\n+\n+            None\n+            \"\"\")\n+        s = self.ioclass()\n+        g = self.genclass(s, policy=self.policy.clone(max_line_length=30))\n+        g.flatten(msg)\n+        self.assertEqual(s.getvalue(), self.typ(expected))\n+\n \n class TestGenerator(TestGeneratorBase, TestEmailBase):\n \n@@ -224,6 +263,29 @@ class TestGenerator(TestGeneratorBase, TestEmailBase):\n     ioclass = io.StringIO\n     typ = str\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"gh-121650: by default the generator prevents header injection\"\"\"\n+        class LiteralHeader(str):\n+            name = 'Header'\n+            def fold(self, **kwargs):\n+                return self\n+\n+        for text in (\n+            'Value\\r\\nBad Injection\\r\\n',\n+            'NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=self.policy,\n+                )\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_string()\n+\n \n class TestBytesGenerator(TestGeneratorBase, TestEmailBase):\n "
        },
        {
          "filename": "Lib/test/test_email/test_policy.py",
          "status": "modified",
          "additions": 26,
          "deletions": 0,
          "patch": "@@ -26,6 +26,7 @@ class PolicyAPITests(unittest.TestCase):\n         'raise_on_defect':          False,\n         'mangle_from_':             True,\n         'message_factory':          None,\n+        'verify_generated_headers': True,\n         }\n     # These default values are the ones set on email.policy.default.\n     # If any of these defaults change, the docs must be updated.\n@@ -277,6 +278,31 @@ def test_short_maxlen_error(self):\n                 with self.assertRaises(email.errors.HeaderParseError):\n                     policy.fold(\"Subject\", subject)\n \n+    def test_verify_generated_headers(self):\n+        \"\"\"Turning protection off allows header injection\"\"\"\n+        policy = email.policy.default.clone(verify_generated_headers=False)\n+        for text in (\n+            'Header: Value\\r\\nBad: Injection\\r\\n',\n+            'Header: NoNewLine'\n+        ):\n+            with self.subTest(text=text):\n+                message = email.message_from_string(\n+                    \"Header: Value\\r\\n\\r\\nBody\",\n+                    policy=policy,\n+                )\n+                class LiteralHeader(str):\n+                    name = 'Header'\n+                    def fold(self, **kwargs):\n+                        return self\n+\n+                del message['Header']\n+                message['Header'] = LiteralHeader(text)\n+\n+                self.assertEqual(\n+                    message.as_string(),\n+                    f\"{text}\\nBody\",\n+                )\n+\n     # XXX: Need subclassing tests.\n     # For adding subclassed objects, make sure the usual rules apply (subclass\n     # wins), but that the order still works (right overrides left)."
        },
        {
          "filename": "Misc/NEWS.d/next/Library/2024-07-27-16-10-41.gh-issue-121650.nf6oc9.rst",
          "status": "added",
          "additions": 5,
          "deletions": 0,
          "patch": "@@ -0,0 +1,5 @@\n+:mod:`email` headers with embedded newlines are now quoted on output. The\n+:mod:`~email.generator` will now refuse to serialize (write) headers that\n+are unsafely folded or delimited; see\n+:attr:`~email.policy.Policy.verify_generated_headers`. (Contributed by Bas\n+Bloemsaat and Petr Viktorin in :gh:`121650`.)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 5,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "f7ceb317aec498823555885a4b7fed5e0244f300",
            "date": "2025-01-14T20:40:45Z",
            "author_login": "serhiy-storchaka"
          },
          {
            "sha": "b5ee0258bf5bb60a5a5a65c64717853e06b64808",
            "date": "2025-01-14T19:56:11Z",
            "author_login": "mpage"
          },
          {
            "sha": "1c13c56a34fc4c4d8969f0b6dc93d5208a50d61b",
            "date": "2025-01-14T19:43:42Z",
            "author_login": "nascheme"
          },
          {
            "sha": "d906bde250d59c396d8dab92285b832c66cdec27",
            "date": "2025-01-14T16:07:37Z",
            "author_login": "picnixz"
          },
          {
            "sha": "d786ac7f584f23c3206f4c86032bdabe83c17b51",
            "date": "2025-01-14T15:31:13Z",
            "author_login": "vstinner"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-94",
    "description": "There is a MEDIUM severity vulnerability affecting CPython.\n\nThe \nemail module didn\u2019t properly quote newlines for email headers when \nserializing an email message allowing for header injection when an email\n is serialized.",
    "attack_vector": "NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-08-01T14:15:03.647",
    "last_modified": "2025-01-11T15:15:08.587",
    "fix_date": "2024-09-04T15:38:31Z"
  },
  "references": [
    {
      "url": "https://github.com/python/cpython/commit/06f28dc236708f72871c64d4bc4b4ea144c50147",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/4766d1200fdf8b6728137aa2927a297e224d5fa7",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/4aaa4259b5a6e664b7316a4d60bdec7ee0f124d0",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/b158a76ce094897c870fb6b3de62887b7ccc33f1",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/f7be505d137a22528cb0fc004422c0081d5d90e6",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/f7c0f09e69e950cf3c5ada9dbde93898eb975533",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/issues/121650",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/pull/122233",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://mail.python.org/archives/list/security-announce@python.org/thread/QH3BUOE2DYQBWP7NAQ7UNHPPOELKISRW/",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/01/3",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/02/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://lists.debian.org/debian-lts-announce/2025/01/msg00005.html",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20240926-0003/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:34.518355",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cpython",
    "owner": "python",
    "created_at": "2017-02-10T19:23:51Z",
    "updated_at": "2025-01-14T11:40:35Z",
    "pushed_at": "2025-01-14T11:26:26Z",
    "size": 657526,
    "stars": 64721,
    "forks": 30871,
    "open_issues": 8974,
    "watchers": 64721,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "3.13",
      "main"
    ],
    "languages": {
      "Python": 35947988,
      "C": 20215174,
      "C++": 463381,
      "M4": 257753,
      "HTML": 206335,
      "Batchfile": 78178,
      "Shell": 71664,
      "Roff": 45666,
      "Makefile": 36295,
      "Objective-C": 33051,
      "Common Lisp": 24579,
      "PLSQL": 22886,
      "PowerShell": 20323,
      "Rich Text Format": 6905,
      "JavaScript": 4245,
      "Kotlin": 3800,
      "Assembly": 2552,
      "DTrace": 2196,
      "CSS": 1325,
      "XSLT": 1174,
      "CMake": 327,
      "VBScript": 70
    },
    "commit_activity": {
      "total_commits_last_year": 5718,
      "avg_commits_per_week": 109.96153846153847,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:09:03.245623"
  }
}