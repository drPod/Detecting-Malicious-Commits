{
  "cve_id": "CVE-2024-6984",
  "github_data": {
    "repository": "juju/juju",
    "fix_commit": "da929676853092a29ddf8d589468cf85ba3efaf2",
    "related_commits": [
      "da929676853092a29ddf8d589468cf85ba3efaf2",
      "da929676853092a29ddf8d589468cf85ba3efaf2"
    ],
    "patch_url": "https://github.com/juju/juju/commit/da929676853092a29ddf8d589468cf85ba3efaf2.patch",
    "fix_commit_details": {
      "sha": "da929676853092a29ddf8d589468cf85ba3efaf2",
      "commit_date": "2024-07-23T03:46:29Z",
      "author": {
        "login": "jujubot",
        "type": "User",
        "stats": {
          "total_commits": 15336,
          "average_weekly_commits": 21.908571428571427,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 539
        }
      },
      "commit_message": {
        "title": "Merge pull request #17788 from manadart/2.9-do-not-log-hook-context-id",
        "length": 1272,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 173,
        "additions": 155,
        "deletions": 18
      },
      "files": [
        {
          "filename": "worker/uniter/runner/runner.go",
          "status": "modified",
          "additions": 67,
          "deletions": 17,
          "patch": "@@ -108,11 +108,41 @@ type Runner interface {\n }\n \n // NewRunnerFunc returns a func used to create a Runner backed by the supplied context and paths.\n-type NewRunnerFunc func(context context.Context, paths context.Paths, remoteExecutor ExecFunc) Runner\n+type NewRunnerFunc func(context context.Context, paths context.Paths, remoteExecutor ExecFunc, options ...Option) Runner\n+\n+// Option is a functional option for NewRunner.\n+type Option func(*options)\n+\n+type options struct {\n+\ttokenGenerator TokenGenerator\n+}\n+\n+// WithTokenGenerator returns an Option that sets the token generator for the\n+// runner.\n+func WithTokenGenerator(tg TokenGenerator) Option {\n+\treturn func(o *options) {\n+\t\to.tokenGenerator = tg\n+\t}\n+}\n+\n+func newOptions() *options {\n+\treturn &options{\n+\t\ttokenGenerator: &tokenGenerator{},\n+\t}\n+}\n \n // NewRunner returns a Runner backed by the supplied context and paths.\n-func NewRunner(context context.Context, paths context.Paths, remoteExecutor ExecFunc) Runner {\n-\treturn &runner{context, paths, remoteExecutor}\n+func NewRunner(context context.Context, paths context.Paths, remoteExecutor ExecFunc, options ...Option) Runner {\n+\topts := newOptions()\n+\tfor _, option := range options {\n+\t\toption(opts)\n+\t}\n+\treturn &runner{\n+\t\tcontext:        context,\n+\t\tpaths:          paths,\n+\t\tremoteExecutor: remoteExecutor,\n+\t\ttokenGenerator: opts.tokenGenerator,\n+\t}\n }\n \n // ExecParams holds all the necessary parameters for ExecFunc.\n@@ -152,12 +182,21 @@ func execOnMachine(params ExecParams) (*utilexec.ExecResponse, error) {\n // ExecFunc is the exec func type.\n type ExecFunc func(ExecParams) (*utilexec.ExecResponse, error)\n \n+// TokenGenerator is the interface for generating tokens.\n+type TokenGenerator interface {\n+\t// Generate generates a token based on the remote flag.\n+\t// If remote is false, it returns an empty string. Otherwise, it returns a\n+\t// random token.\n+\tGenerate(remote bool) (string, error)\n+}\n+\n // runner implements Runner.\n type runner struct {\n \tcontext context.Context\n \tpaths   context.Paths\n \t// remoteExecutor executes commands on a remote workload pod for CAAS.\n \tremoteExecutor ExecFunc\n+\ttokenGenerator TokenGenerator\n }\n \n func (runner *runner) logger() loggo.Logger {\n@@ -207,14 +246,11 @@ func (runner *runner) RunCommands(commands string, runLocation RunLocation) (*ut\n // runCommandsWithTimeout is a helper to abstract common code between run commands and\n // juju-run as an action\n func (runner *runner) runCommandsWithTimeout(commands string, timeout time.Duration, clock clock.Clock, rMode runMode, abort <-chan struct{}) (*utilexec.ExecResponse, error) {\n-\tvar err error\n-\ttoken := \"\"\n-\tif rMode == runOnRemote {\n-\t\ttoken, err = utils.RandomPassword()\n-\t\tif err != nil {\n-\t\t\treturn nil, errors.Trace(err)\n-\t\t}\n+\ttoken, err := runner.tokenGenerator.Generate(rMode == runOnRemote)\n+\tif err != nil {\n+\t\treturn nil, errors.Trace(err)\n \t}\n+\n \tsrv, err := runner.startJujucServer(token, rMode)\n \tif err != nil {\n \t\treturn nil, err\n@@ -387,13 +423,11 @@ func (runner *runner) RunHook(hookName string) (HookHandlerType, error) {\n }\n \n func (runner *runner) runCharmHookWithLocation(hookName, charmLocation string, rMode runMode) (hookHandlerType HookHandlerType, err error) {\n-\ttoken := \"\"\n-\tif rMode == runOnRemote {\n-\t\ttoken, err = utils.RandomPassword()\n-\t\tif err != nil {\n-\t\t\treturn InvalidHookHandler, errors.Trace(err)\n-\t\t}\n+\ttoken, err := runner.tokenGenerator.Generate(rMode == runOnRemote)\n+\tif err != nil {\n+\t\treturn InvalidHookHandler, errors.Trace(err)\n \t}\n+\n \tsrv, err := runner.startJujucServer(token, rMode)\n \tif err != nil {\n \t\treturn InvalidHookHandler, errors.Trace(err)\n@@ -719,7 +753,7 @@ func (runner *runner) startJujucServer(token string, rMode runMode) (*jujuc.Serv\n \t// Prepare server.\n \tgetCmd := func(ctxId, cmdName string) (cmd.Command, error) {\n \t\tif ctxId != runner.context.Id() {\n-\t\t\treturn nil, errors.Errorf(\"expected context id %q, got %q\", runner.context.Id(), ctxId)\n+\t\t\treturn nil, errors.Errorf(\"wrong context ID; got %q\", ctxId)\n \t\t}\n \t\treturn jujuc.NewCommand(runner.context, cmdName)\n \t}\n@@ -789,3 +823,19 @@ type hookProcess struct {\n func (p hookProcess) Pid() int {\n \treturn p.Process.Pid\n }\n+\n+type tokenGenerator struct{}\n+\n+// Generate generates a token based on the remote flag.\n+// If remote is false, it returns an empty string. Otherwise, it returns a\n+// random token.\n+func (t *tokenGenerator) Generate(remote bool) (string, error) {\n+\tif !remote {\n+\t\treturn \"\", nil\n+\t}\n+\ttoken, err := utils.RandomPassword()\n+\tif err != nil {\n+\t\treturn \"\", errors.Trace(err)\n+\t}\n+\treturn token, nil\n+}"
        },
        {
          "filename": "worker/uniter/runner/runner_test.go",
          "status": "modified",
          "additions": 87,
          "deletions": 0,
          "patch": "@@ -21,10 +21,13 @@ import (\n \tgc \"gopkg.in/check.v1\"\n \n \t\"github.com/juju/juju/core/model\"\n+\t\"github.com/juju/juju/juju/sockets\"\n+\t\"github.com/juju/juju/testing\"\n \t\"github.com/juju/juju/worker/common/charmrunner\"\n \t\"github.com/juju/juju/worker/uniter/hook\"\n \t\"github.com/juju/juju/worker/uniter/runner\"\n \t\"github.com/juju/juju/worker/uniter/runner/context\"\n+\t\"github.com/juju/juju/worker/uniter/runner/jujuc\"\n \trunnertesting \"github.com/juju/juju/worker/uniter/runner/testing\"\n )\n \n@@ -227,6 +230,7 @@ func (s *RunHookSuite) TestRunHookDispatchingHookHandler(c *gc.C) {\n \n type MockContext struct {\n \tcontext.Context\n+\tid              string\n \tactionData      *context.ActionData\n \tactionDataErr   error\n \tactionParams    map[string]interface{}\n@@ -239,6 +243,10 @@ type MockContext struct {\n \tmodelType       model.ModelType\n }\n \n+func (ctx *MockContext) Id() string {\n+\treturn ctx.id\n+}\n+\n func (ctx *MockContext) GetLogger(module string) loggo.Logger {\n \treturn loggo.GetLogger(module)\n }\n@@ -322,6 +330,85 @@ func (s *RunMockContextSuite) assertRecordedPid(c *gc.C, expectPid int) {\n \tc.Assert(strings.TrimRight(string(content), \"\\r\\n\"), gc.Equals, expectContent)\n }\n \n+func (s *RunMockContextSuite) TestBadContextId(c *gc.C) {\n+\tparams := map[string]interface{}{\n+\t\t\"command\":          \"echo 1\",\n+\t\t\"timeout\":          0,\n+\t\t\"workload-context\": true,\n+\t}\n+\tctx := &MockContext{\n+\t\tid:        \"foo-context\",\n+\t\tmodelType: model.CAAS,\n+\t\tactionData: &context.ActionData{\n+\t\t\tParams: params,\n+\t\t},\n+\t\tactionParams:  params,\n+\t\tactionResults: map[string]interface{}{},\n+\t}\n+\tstart := make(chan struct{})\n+\tdone := make(chan struct{})\n+\tresult := make(chan error)\n+\texecCount := 0\n+\texecFunc := func(params runner.ExecParams) (*exec.ExecResponse, error) {\n+\t\texecCount++\n+\t\tswitch execCount {\n+\t\tcase 1:\n+\t\t\treturn &exec.ExecResponse{}, nil\n+\t\tcase 2:\n+\t\t\tclose(start)\n+\n+\t\t\tselect {\n+\t\t\tcase <-done:\n+\t\t\tcase <-time.After(testing.LongWait):\n+\t\t\t\tc.Fatalf(\"timed out waiting to complete\")\n+\t\t\t}\n+\t\t\treturn &exec.ExecResponse{}, nil\n+\t\t}\n+\t\treturn nil, nil\n+\t}\n+\tgo func() {\n+\t\tdefer close(done)\n+\t\tselect {\n+\t\tcase <-start:\n+\t\tcase <-time.After(testing.LongWait):\n+\t\t\tc.Fatalf(\"timed out waiting to start\")\n+\t\t}\n+\t\tsocket := s.paths.GetJujucServerSocket(false)\n+\n+\t\tclient, err := sockets.Dial(socket)\n+\t\tc.Assert(err, jc.ErrorIsNil)\n+\t\tdefer client.Close()\n+\n+\t\treq := jujuc.Request{\n+\t\t\tContextId:   \"whatever\",\n+\t\t\tDir:         c.MkDir(),\n+\t\t\tCommandName: \"remote\",\n+\t\t}\n+\n+\t\tvar resp exec.ExecResponse\n+\t\terr = client.Call(\"Jujuc.Main\", req, &resp)\n+\n+\t\tgo func() {\n+\t\t\tresult <- err\n+\t\t}()\n+\t}()\n+\t_, err := runner.NewRunner(ctx, s.paths, execFunc, runner.WithTokenGenerator(localTokenGenerator{})).RunAction(\"juju-run\")\n+\tc.Assert(err, jc.ErrorIsNil)\n+\n+\tselect {\n+\tcase err := <-result:\n+\t\tc.Assert(err, gc.ErrorMatches, `.*wrong context ID; got \"whatever\"`)\n+\tcase <-time.After(5 * time.Second):\n+\t\tc.Fatal(\"timed out waiting for jujuc to finish\")\n+\t}\n+}\n+\n+type localTokenGenerator struct{}\n+\n+func (localTokenGenerator) Generate(remote bool) (string, error) {\n+\treturn \"\", nil\n+}\n+\n func (s *RunMockContextSuite) TestRunHookFlushSuccess(c *gc.C) {\n \texpectErr := errors.New(\"pew pew pew\")\n \tctx := &MockContext{"
        },
        {
          "filename": "worker/uniter/util_test.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -551,7 +551,7 @@ func (s startUniter) step(c *gc.C, ctx *testContext) {\n \t\tMachineLock:          processLock,\n \t\tUpdateStatusSignal:   ctx.updateStatusHookTicker.ReturnTimer(),\n \t\tNewOperationExecutor: operationExecutor,\n-\t\tNewProcessRunner: func(context runnercontext.Context, paths runnercontext.Paths, remoteExecutor runner.ExecFunc) runner.Runner {\n+\t\tNewProcessRunner: func(context runnercontext.Context, paths runnercontext.Paths, remoteExecutor runner.ExecFunc, options ...runner.Option) runner.Runner {\n \t\t\tctx.runner.ctx = context\n \t\t\treturn ctx.runner\n \t\t},"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 2,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "2757ded48a1e6d715de65134a36f69d55ae209a9",
            "date": "2025-01-14T14:37:43Z",
            "author_login": "jujubot"
          },
          {
            "sha": "cf3bce85d3d5f327c7fd5ffc059b38f448d13237",
            "date": "2025-01-14T11:58:53Z",
            "author_login": "manadart"
          },
          {
            "sha": "ab6b3982912cc164d3f87650e702313453543fa6",
            "date": "2025-01-14T13:53:23Z",
            "author_login": "jujubot"
          },
          {
            "sha": "4e65e2f5162566534be13386bddb1930f8a2e1b4",
            "date": "2025-01-14T13:41:40Z",
            "author_login": "jujubot"
          },
          {
            "sha": "b58dd80a89635c0576e0001bd23134c28898d1e9",
            "date": "2025-01-14T10:34:20Z",
            "author_login": "jujubot"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
    "cwe_id": "CWE-209",
    "description": "An issue was discovered in Juju that resulted in the leak of the sensitive context ID, which allows a local unprivileged attacker to access other sensitive data or relation accessible to the local charm.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-07-29T14:15:04.477",
    "last_modified": "2024-11-21T09:50:41.767",
    "fix_date": "2024-07-23T03:46:29Z"
  },
  "references": [
    {
      "url": "https://github.com/juju/juju/commit/da929676853092a29ddf8d589468cf85ba3efaf2",
      "source": "security@ubuntu.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/juju/juju/security/advisories/GHSA-6vjm-54vp-mxhx",
      "source": "security@ubuntu.com",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.cve.org/CVERecord?id=CVE-2024-6984",
      "source": "security@ubuntu.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/juju/juju/commit/da929676853092a29ddf8d589468cf85ba3efaf2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/juju/juju/security/advisories/GHSA-6vjm-54vp-mxhx",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Exploit",
        "Vendor Advisory"
      ]
    },
    {
      "url": "https://www.cve.org/CVERecord?id=CVE-2024-6984",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:34.495321",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "juju",
    "owner": "juju",
    "created_at": "2014-06-03T14:28:10Z",
    "updated_at": "2025-01-14T14:37:48Z",
    "pushed_at": "2025-01-14T14:37:44Z",
    "size": 394731,
    "stars": 2412,
    "forks": 508,
    "open_issues": 42,
    "watchers": 2412,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "2.9",
      "3.1",
      "3.4",
      "3.5",
      "3.6",
      "increment-to-3.6.3",
      "main"
    ],
    "languages": {
      "Go": 36956807,
      "Shell": 461101,
      "Python": 83041,
      "Makefile": 34064,
      "Inno Setup": 8993,
      "Dockerfile": 1691,
      "C": 760,
      "HCL": 229
    },
    "commit_activity": {
      "total_commits_last_year": 5214,
      "avg_commits_per_week": 100.26923076923077,
      "days_active_last_year": 295
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T16:21:50.524069"
  }
}