{
  "cve_id": "CVE-2024-8088",
  "github_data": {
    "repository": "python/cpython",
    "fix_commit": "0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1",
    "related_commits": [
      "0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1",
      "2231286d78d328c2f575e0b05b16fe447d1656d6",
      "795f2597a4be988e2bb19b69ff9958e981cb894e",
      "7bc367e464ce50b956dd232c1dfa1cad4e7fb814",
      "7e8883a3f04d308302361aeffc73e0e9837f19d4",
      "8c7348939d8a3ecd79d630075f6be1b0c5b41f64",
      "95b073bddefa6243effa08e131e297c0383e7f6a",
      "962055268ed4f2ca1d717bfc8b6385de50a23ab7",
      "dcc5182f27c1500006a1ef78e10613bb45788dea",
      "e0264a61119d551658d9445af38323ba94fc16db",
      "fc0b8259e693caa8400fa8b6ac1e494e47ea7798"
    ],
    "patch_url": "https://github.com/python/cpython/commit/0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1.patch",
    "fix_commit_details": {
      "sha": "0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1",
      "commit_date": "2024-09-04T20:41:39Z",
      "author": {
        "login": "jaraco",
        "type": "User",
        "stats": {
          "total_commits": 296,
          "average_weekly_commits": 0.1646273637374861,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 128
        }
      },
      "commit_message": {
        "title": "[3.10] gh-123270: Replaced SanitizedNames with a more surgical fix. (GH-123354) (#123426)",
        "length": 307,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 148,
        "additions": 81,
        "deletions": 67
      },
      "files": [
        {
          "filename": "Lib/test/test_zipfile.py",
          "status": "modified",
          "additions": 70,
          "deletions": 6,
          "patch": "@@ -5,6 +5,7 @@\n import itertools\n import os\n import pathlib\n+import platform\n import posixpath\n import string\n import struct\n@@ -3282,7 +3283,11 @@ def test_extract_orig_with_implied_dirs(self, alpharep):\n \n     def test_malformed_paths(self):\n         \"\"\"\n-        Path should handle malformed paths.\n+        Path should handle malformed paths gracefully.\n+\n+        Paths with leading slashes are not visible.\n+\n+        Paths with dots are treated like regular files.\n         \"\"\"\n         data = io.BytesIO()\n         zf = zipfile.ZipFile(data, \"w\")\n@@ -3291,11 +3296,70 @@ def test_malformed_paths(self):\n         zf.writestr(\"../parent.txt\", b\"content\")\n         zf.filename = ''\n         root = zipfile.Path(zf)\n-        assert list(map(str, root.iterdir())) == [\n-            'one-slash.txt',\n-            'two-slash.txt',\n-            'parent.txt',\n-        ]\n+        assert list(map(str, root.iterdir())) == ['../']\n+        assert root.joinpath('..').joinpath('parent.txt').read_bytes() == b'content'\n+\n+    @unittest.skipIf(platform.system() == \"Windows\", \"GH-123693\")\n+    def test_unsupported_names(self):\n+        \"\"\"\n+        Path segments with special characters are readable.\n+\n+        On some platforms or file systems, characters like\n+        ``:`` and ``?`` are not allowed, but they are valid\n+        in the zip file.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(\"path?\", b\"content\")\n+        zf.writestr(\"V: NMS.flac\", b\"fLaC...\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        contents = root.iterdir()\n+        assert next(contents).name == 'path?'\n+        item = next(contents)\n+        assert item.name == 'V: NMS.flac', item.name\n+        assert root.joinpath('V: NMS.flac').read_bytes() == b\"fLaC...\"\n+\n+    @unittest.skipIf(platform.system() == \"Windows\", \"GH-123693\")\n+    def test_backslash_not_separator(self):\n+        \"\"\"\n+        In a zip file, backslashes are not separators.\n+        \"\"\"\n+        data = io.BytesIO()\n+        zf = zipfile.ZipFile(data, \"w\")\n+        zf.writestr(DirtyZipInfo.for_name(\"foo\\\\bar\", zf), b\"content\")\n+        zf.filename = ''\n+        root = zipfile.Path(zf)\n+        (first,) = root.iterdir()\n+        assert not first.is_dir()\n+        assert first.name == 'foo\\\\bar', first.name\n+\n+\n+class DirtyZipInfo(zipfile.ZipInfo):\n+    \"\"\"\n+    Bypass name sanitization.\n+    \"\"\"\n+\n+    def __init__(self, filename, *args, **kwargs):\n+        super().__init__(filename, *args, **kwargs)\n+        self.filename = filename\n+\n+    @classmethod\n+    def for_name(cls, name, archive):\n+        \"\"\"\n+        Construct the same way that ZipFile.writestr does.\n+\n+        TODO: extract this functionality and re-use\n+        \"\"\"\n+        self = cls(filename=name, date_time=time.localtime(time.time())[:6])\n+        self.compress_type = archive.compression\n+        self.compress_level = archive.compresslevel\n+        if self.filename.endswith('/'):  # pragma: no cover\n+            self.external_attr = 0o40775 << 16  # drwxrwxr-x\n+            self.external_attr |= 0x10  # MS-DOS directory flag\n+        else:\n+            self.external_attr = 0o600 << 16  # ?rw-------\n+        return self\n \n \n class StripExtraTests(unittest.TestCase):"
        },
        {
          "filename": "Lib/zipfile.py",
          "status": "modified",
          "additions": 8,
          "deletions": 61,
          "patch": "@@ -2152,7 +2152,7 @@ def _parents(path):\n def _ancestry(path):\n     \"\"\"\n     Given a path with elements separated by\n-    posixpath.sep, generate all elements of that path\n+    posixpath.sep, generate all elements of that path.\n \n     >>> list(_ancestry('b/d'))\n     ['b/d', 'b']\n@@ -2164,9 +2164,14 @@ def _ancestry(path):\n     ['b']\n     >>> list(_ancestry(''))\n     []\n+\n+    Multiple separators are treated like a single.\n+\n+    >>> list(_ancestry('//b//d///f//'))\n+    ['//b//d///f', '//b//d', '//b']\n     \"\"\"\n     path = path.rstrip(posixpath.sep)\n-    while path and path != posixpath.sep:\n+    while path.rstrip(posixpath.sep):\n         yield path\n         path, tail = posixpath.split(path)\n \n@@ -2183,65 +2188,7 @@ def _difference(minuend, subtrahend):\n     return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n \n \n-class SanitizedNames:\n-    \"\"\"\n-    ZipFile mix-in to ensure names are sanitized.\n-    \"\"\"\n-\n-    def namelist(self):\n-        return list(map(self._sanitize, super().namelist()))\n-\n-    @staticmethod\n-    def _sanitize(name):\n-        r\"\"\"\n-        Ensure a relative path with posix separators and no dot names.\n-        Modeled after\n-        https://github.com/python/cpython/blob/bcc1be39cb1d04ad9fc0bd1b9193d3972835a57c/Lib/zipfile/__init__.py#L1799-L1813\n-        but provides consistent cross-platform behavior.\n-        >>> san = SanitizedNames._sanitize\n-        >>> san('/foo/bar')\n-        'foo/bar'\n-        >>> san('//foo.txt')\n-        'foo.txt'\n-        >>> san('foo/.././bar.txt')\n-        'foo/bar.txt'\n-        >>> san('foo../.bar.txt')\n-        'foo../.bar.txt'\n-        >>> san('\\\\foo\\\\bar.txt')\n-        'foo/bar.txt'\n-        >>> san('D:\\\\foo.txt')\n-        'D/foo.txt'\n-        >>> san('\\\\\\\\server\\\\share\\\\file.txt')\n-        'server/share/file.txt'\n-        >>> san('\\\\\\\\?\\\\GLOBALROOT\\\\Volume3')\n-        '?/GLOBALROOT/Volume3'\n-        >>> san('\\\\\\\\.\\\\PhysicalDrive1\\\\root')\n-        'PhysicalDrive1/root'\n-        Retain any trailing slash.\n-        >>> san('abc/')\n-        'abc/'\n-        Raises a ValueError if the result is empty.\n-        >>> san('../..')\n-        Traceback (most recent call last):\n-        ...\n-        ValueError: Empty filename\n-        \"\"\"\n-\n-        def allowed(part):\n-            return part and part not in {'..', '.'}\n-\n-        # Remove the drive letter.\n-        # Don't use ntpath.splitdrive, because that also strips UNC paths\n-        bare = re.sub('^([A-Z]):', r'\\1', name, flags=re.IGNORECASE)\n-        clean = bare.replace('\\\\', '/')\n-        parts = clean.split('/')\n-        joined = '/'.join(filter(allowed, parts))\n-        if not joined:\n-            raise ValueError(\"Empty filename\")\n-        return joined + '/' * name.endswith('/')\n-\n-\n-class CompleteDirs(SanitizedNames, ZipFile):\n+class CompleteDirs(ZipFile):\n     \"\"\"\n     A ZipFile subclass that ensures that implied directories\n     are always included in the namelist."
        },
        {
          "filename": "Misc/NEWS.d/next/Library/2024-08-26-13-45-20.gh-issue-123270.gXHvNJ.rst",
          "status": "added",
          "additions": 3,
          "deletions": 0,
          "patch": "@@ -0,0 +1,3 @@\n+Applied a more surgical fix for malformed payloads in :class:`zipfile.Path`\n+causing infinite loops (gh-122905) without breaking contents using\n+legitimate characters."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 3,
        "max_directory_depth": 4
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "d786ac7f584f23c3206f4c86032bdabe83c17b51",
            "date": "2025-01-14T15:31:13Z",
            "author_login": "vstinner"
          },
          {
            "sha": "43ef9587ae869fd11711a3bb126e65afe9177342",
            "date": "2025-01-14T15:29:21Z",
            "author_login": "vstinner"
          },
          {
            "sha": "1598e18a659ef3a533caa0a79a489a3ed1d80bdd",
            "date": "2025-01-14T15:17:24Z",
            "author_login": "rffontenelle"
          },
          {
            "sha": "7fc0f86098c162e0230d5ef5ea62a883e41f9411",
            "date": "2025-01-14T15:12:21Z",
            "author_login": "hugovk"
          },
          {
            "sha": "aa805887cf23e5bff1598615d4f91369835f016f",
            "date": "2025-01-14T15:10:53Z",
            "author_login": "hugovk"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-835",
    "description": "There is a HIGH severity vulnerability affecting the CPython \"zipfile\"\nmodule affecting \"zipfile.Path\". Note that the more common API \"zipfile.ZipFile\" class is unaffected.\n\n\n\n\n\nWhen iterating over names of entries in a zip archive (for example, methods\nof \"zipfile.Path\" like \"namelist()\", \"iterdir()\", etc)\nthe process can be put into an infinite loop with a maliciously crafted\nzip archive. This defect applies when reading only metadata or extracting\nthe contents of the zip archive. Programs that are not handling\nuser-controlled zip archives are not affected.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2024-08-22T19:15:09.720",
    "last_modified": "2024-11-21T09:52:39.210",
    "fix_date": "2024-09-04T20:41:39Z"
  },
  "references": [
    {
      "url": "https://github.com/python/cpython/commit/0aa1ee22ab6e204e9d3d0e9dd63ea648ed691ef1",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/2231286d78d328c2f575e0b05b16fe447d1656d6",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/795f2597a4be988e2bb19b69ff9958e981cb894e",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/7bc367e464ce50b956dd232c1dfa1cad4e7fb814",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/7e8883a3f04d308302361aeffc73e0e9837f19d4",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/8c7348939d8a3ecd79d630075f6be1b0c5b41f64",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/95b073bddefa6243effa08e131e297c0383e7f6a",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/962055268ed4f2ca1d717bfc8b6385de50a23ab7",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/dcc5182f27c1500006a1ef78e10613bb45788dea",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/e0264a61119d551658d9445af38323ba94fc16db",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/commit/fc0b8259e693caa8400fa8b6ac1e494e47ea7798",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/issues/122905",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/issues/123270",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://github.com/python/cpython/pull/122906",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "https://mail.python.org/archives/list/security-announce@python.org/thread/GNFCKVI4TCATKQLALJ5SN4L4CSPSMILU/",
      "source": "cna@python.org",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/22/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/22/4",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/23/1",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "http://www.openwall.com/lists/oss-security/2024/08/23/2",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    },
    {
      "url": "https://security.netapp.com/advisory/ntap-20241011-0010/",
      "source": "af854a3a-2127-422b-91ae-364da2661108",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.386075",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "cpython",
    "owner": "python",
    "created_at": "2017-02-10T19:23:51Z",
    "updated_at": "2025-01-14T11:40:35Z",
    "pushed_at": "2025-01-14T11:26:26Z",
    "size": 657526,
    "stars": 64721,
    "forks": 30871,
    "open_issues": 8974,
    "watchers": 64721,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "3.13",
      "main"
    ],
    "languages": {
      "Python": 35947988,
      "C": 20215174,
      "C++": 463381,
      "M4": 257753,
      "HTML": 206335,
      "Batchfile": 78178,
      "Shell": 71664,
      "Roff": 45666,
      "Makefile": 36295,
      "Objective-C": 33051,
      "Common Lisp": 24579,
      "PLSQL": 22886,
      "PowerShell": 20323,
      "Rich Text Format": 6905,
      "JavaScript": 4245,
      "Kotlin": 3800,
      "Assembly": 2552,
      "DTrace": 2196,
      "CSS": 1325,
      "XSLT": 1174,
      "CMake": 327,
      "VBScript": 70
    },
    "commit_activity": {
      "total_commits_last_year": 5718,
      "avg_commits_per_week": 109.96153846153847,
      "days_active_last_year": 357
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T13:09:03.245623"
  }
}