{
  "cve_id": "CVE-2024-8367",
  "github_data": {
    "repository": "hmcts/probate-back-office",
    "fix_commit": "d90230d7cf575e5b0852d56660104c8bd2503c34",
    "related_commits": [
      "d90230d7cf575e5b0852d56660104c8bd2503c34"
    ],
    "patch_url": "https://github.com/hmcts/probate-back-office/commit/d90230d7cf575e5b0852d56660104c8bd2503c34.patch",
    "fix_commit_details": {
      "sha": "d90230d7cf575e5b0852d56660104c8bd2503c34",
      "commit_date": "2024-08-12T10:44:20Z",
      "author": {
        "login": "abbasiTahir",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "DTSPB-4180 fix markdown injection vulnerability  (#2614)",
        "length": 571,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 213,
        "additions": 204,
        "deletions": 9
      },
      "files": [
        {
          "filename": "src/integrationTest/java/uk/gov/hmcts/probate/service/NotificationServiceIT.java",
          "status": "modified",
          "additions": 73,
          "deletions": 0,
          "patch": "@@ -64,6 +64,7 @@\n \n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n@@ -136,6 +137,8 @@ class NotificationServiceIT {\n     private static final String PERSONALISATION_NOC_SUBMITTED_DATE = \"noc_date\";\n     private static final String PERSONALISATION_OLD_SOLICITOR_NAME = \"old_solicitor_name\";\n     private static final DateTimeFormatter NOC_DATE = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final String MARKDOWN_ERROR_MESSAGE\n+            = \"Markdown Link detected in case data, stop sending notification email.\";\n \n     @Autowired\n     private NotificationService notificationService;\n@@ -222,6 +225,8 @@ class NotificationServiceIT {\n     private CaveatData caveatData;\n     private CallbackRequest callbackRequest;\n     private CaveatDetails caveatStoppedCtscCaseData;\n+    private CaseDetails  markdownLinkCaseData;\n+    private CaveatDetails markdownLinkCaveatData;\n \n     @Mock\n     private RegistriesProperties registriesPropertiesMock;\n@@ -597,6 +602,23 @@ public void setUp() throws NotificationClientException, IOException {\n             .deceasedDateOfDeath(LocalDate.of(2000, 12, 12))\n             .build(), LAST_MODIFIED, ID);\n \n+        markdownLinkCaseData = new CaseDetails(CaseData.builder()\n+                .applicationType(PERSONAL)\n+                .registryLocation(\"Oxford\")\n+                .solsSOTName(\"SOTName\")\n+                .deceasedForenames(\"Some text [example](http://example.com)\")\n+                .primaryApplicantEmailAddress(\"primary@probate-test.com\")\n+                .deceasedDateOfDeath(LocalDate.of(2000, 12, 12))\n+                .build(), LAST_MODIFIED, ID);\n+\n+        markdownLinkCaveatData = new CaveatDetails(CaveatData.builder()\n+                .applicationType(PERSONAL)\n+                .registryLocation(\"Oxford\")\n+                .caveatorEmailAddress(\"caveator@probate-test.com\")\n+                .messageContent(\"Some text [example](http://example.com)\")\n+                .deceasedDateOfDeath(LocalDate.of(2000, 12, 12))\n+                .build(), LAST_MODIFIED, ID);\n+\n         CollectionMember<CaseMatch> caseMatchMember = new CollectionMember<>(CaseMatch.builder().build());\n         List<CollectionMember<CaseMatch>> caseMatch = new ArrayList<>();\n         caseMatch.add(caseMatchMember);\n@@ -2136,4 +2158,55 @@ void verifySendCaveatNocEmail()\n \n         verify(pdfManagementService).generateAndUpload(any(SentEmail.class), eq(SENT_EMAIL));\n     }\n+\n+    @Test\n+    void throwExceptionSendEmailWhenInvalidPersonalisationExists() {\n+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,\n+                () -> notificationService.sendEmail(CASE_STOPPED, markdownLinkCaseData));\n+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());\n+    }\n+\n+    @Test\n+    void throwExceptionSendExecutorEmailWhenInvalidPersonalisationExists() {\n+        ExecutorsApplyingNotification executorsApplyingNotification = ExecutorsApplyingNotification.builder()\n+                .name(personalCaseDataCtscRequestInformation.getData().getPrimaryApplicantFullName())\n+                .address(SolsAddress.builder()\n+                        .addressLine1(\"Addressline1\")\n+                        .postCode(\"postcode\")\n+                        .postTown(\"posttown\")\n+                        .build())\n+                .email(\"primary@probate-test.com\")\n+                .notification(\"Yes\").build();\n+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,\n+                () -> notificationService.sendEmail(CASE_STOPPED_REQUEST_INFORMATION,\n+                        markdownLinkCaseData, executorsApplyingNotification));\n+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());\n+    }\n+\n+    @Test\n+    void throwExceptionSendCaveatEmailWhenInvalidPersonalisationExists() {\n+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,\n+                () -> notificationService.sendCaveatEmail(GENERAL_CAVEAT_MESSAGE, markdownLinkCaveatData));\n+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());\n+    }\n+\n+    @Test\n+    void throwExceptionSendEmailWithDocumentAttachedWhenInvalidPersonalisationExists() {\n+        CollectionMember<Document> doc = new CollectionMember<>(Document.builder().build());\n+\n+        markdownLinkCaseData.getData().getProbateSotDocumentsGenerated().add(doc);\n+        ExecutorsApplyingNotification executorsApplyingNotification = ExecutorsApplyingNotification.builder()\n+                .name(markdownLinkCaseData.getData().getSolsSOTName())\n+                .address(SolsAddress.builder()\n+                        .addressLine1(\"Addressline1\")\n+                        .postCode(\"postcode\")\n+                        .postTown(\"posttown\")\n+                        .build())\n+                .email(\"primary@probate-test.com\")\n+                .notification(\"Yes\").build();\n+        NotificationClientException expectException =  assertThrows(NotificationClientException.class,\n+                () -> notificationService.sendEmailWithDocumentAttached(markdownLinkCaseData,\n+                        executorsApplyingNotification, REDECLARATION_SOT));\n+        assertEquals(MARKDOWN_ERROR_MESSAGE, expectException.getMessage());\n+    }\n }"
        },
        {
          "filename": "src/main/java/uk/gov/hmcts/probate/service/NotificationService.java",
          "status": "modified",
          "additions": 39,
          "deletions": 9,
          "patch": "@@ -37,6 +37,7 @@\n import uk.gov.hmcts.probate.service.notification.TemplateService;\n import uk.gov.hmcts.probate.service.template.pdf.PDFManagementService;\n import uk.gov.hmcts.probate.validator.EmailAddressNotifyValidationRule;\n+import uk.gov.hmcts.probate.validator.PersonalisationValidationRule;\n import uk.gov.hmcts.reform.authorisation.generators.AuthTokenGenerator;\n import uk.gov.hmcts.reform.probate.model.cases.RegistryLocation;\n import uk.gov.service.notify.NotificationClient;\n@@ -68,6 +69,9 @@ public class NotificationService {\n     private static final String PERSONALISATION_APPLICANT_NAME = \"applicant_name\";\n     private static final String PERSONALISATION_SOT_LINK = \"sot_link\";\n     private static final DateTimeFormatter RELEASE_DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    private static final String INVALID_PERSONALISATION_ERROR_MESSAGE =\n+            \"Markdown Link detected in case data, stop sending notification email.\";\n+\n     @Autowired\n     private final EmailAddresses emailAddresses;\n     private final NotificationTemplates notificationTemplates;\n@@ -85,6 +89,7 @@ public class NotificationService {\n     private final AuthTokenGenerator serviceAuthTokenGenerator;\n     private final NotificationClientService notificationClientService;\n     private final DocumentManagementService documentManagementService;\n+    private final PersonalisationValidationRule personalisationValidationRule;\n     @Autowired\n     private BusinessValidationMessageService businessValidationMessageService;\n     @Value(\"${notifications.grantDelayedNotificationPeriodDays}\")\n@@ -122,7 +127,12 @@ public Document sendEmail(State state, CaseDetails caseDetails, Optional<CaseOri\n         if (state == state.CASE_STOPPED_CAVEAT) {\n             personalisation = caveatPersonalisationService.getCaveatStopPersonalisation(personalisation, caseData);\n         }\n-\n+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);\n+        if (!invalidPersonalisation.isEmpty()) {\n+            log.error(\"Personalisation validation failed for case: {} fields: {}\",\n+                    caseDetails.getId(), invalidPersonalisation);\n+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);\n+        }\n         if (caseData.getApplicationType().equals(ApplicationType.SOLICITOR)) {\n             if (!StringUtils.isEmpty(caseData.getSolsSOTName())) {\n                 personalisation.replace(PERSONALISATION_APPLICANT_NAME, caseData.getSolsSOTName());\n@@ -159,7 +169,12 @@ public Document sendEmail(State state, CaseDetails caseDetails, ExecutorsApplyin\n         String emailReplyToId = registry.getEmailReplyToId();\n \n         personalisation.replace(PERSONALISATION_APPLICANT_NAME, executor.getName());\n-\n+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);\n+        if (!invalidPersonalisation.isEmpty()) {\n+            log.error(\"Personalisation validation failed for case: {} fields: {}\",\n+                    caseDetails.getId(), invalidPersonalisation);\n+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);\n+        }\n         SendEmailResponse response =\n             getSendEmailResponse(state, templateId, emailReplyToId, emailAddress, personalisation, reference,\n                 caseDetails.getId());\n@@ -233,7 +248,12 @@ public Document sendCaveatEmail(State state, CaveatDetails caveatDetails)\n         }\n \n         String reference = caveatDetails.getId().toString();\n-\n+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);\n+        if (!invalidPersonalisation.isEmpty()) {\n+            log.error(\"Personalisation validation failed for case: {} fields: {}\",\n+                    caveatDetails.getId(), invalidPersonalisation);\n+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);\n+        }\n         SendEmailResponse response;\n         response = notificationClientService.sendEmail(caveatDetails.getId(), templateId, emailAddress,\n             personalisation, reference);\n@@ -300,18 +320,22 @@ public Document sendEmailWithDocumentAttached(CaseDetails caseDetails, Executors\n         Registry registry =\n             registriesProperties.getRegistries().get(caseDetails.getData().getRegistryLocation().toLowerCase());\n \n-        String templateId = templateService.getTemplateId(state, caseDetails.getData().getApplicationType(),\n-            caseDetails.getData().getRegistryLocation(),\n-            caseDetails.getData().getLanguagePreference());\n-        String emailReplyToId = registry.getEmailReplyToId();\n-\n         Map<String, Object> personalisation =\n             grantOfRepresentationPersonalisationService.getPersonalisation(caseDetails, registry);\n         grantOfRepresentationPersonalisationService.addSingleAddressee(personalisation, executor.getName());\n \n         personalisation.put(PERSONALISATION_SOT_LINK, prepareUpload(sotDocument));\n-\n+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);\n+        if (!invalidPersonalisation.isEmpty()) {\n+            log.error(\"Personalisation validation failed for case: {} fields: {}\",\n+                    caseDetails.getId(), invalidPersonalisation);\n+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);\n+        }\n         String reference = caseDetails.getData().getSolsSolicitorAppReference();\n+        String templateId = templateService.getTemplateId(state, caseDetails.getData().getApplicationType(),\n+                caseDetails.getData().getRegistryLocation(),\n+                caseDetails.getData().getLanguagePreference());\n+        String emailReplyToId = registry.getEmailReplyToId();\n \n         SendEmailResponse response =\n             getSendEmailResponse(state, templateId, emailReplyToId, executor.getEmail(), personalisation, reference,\n@@ -365,6 +389,12 @@ private Document sendGrantNotificationEmail(ReturnedCaseDetails caseDetails, Str\n             registriesProperties.getRegistries().get(caseDetails.getData().getRegistryLocation().toLowerCase());\n         Map<String, Object> personalisation =\n             grantOfRepresentationPersonalisationService.getPersonalisation(caseDetails, registry);\n+        List<String> invalidPersonalisation = personalisationValidationRule.validatePersonalisation(personalisation);\n+        if (!invalidPersonalisation.isEmpty()) {\n+            log.error(\"Personalisation validation failed for case: {} fields: {}\",\n+                    caseDetails.getId(), invalidPersonalisation);\n+            throw new NotificationClientException(INVALID_PERSONALISATION_ERROR_MESSAGE);\n+        }\n         String reference = caseDetails.getData().getSolsSolicitorAppReference();\n         String emailAddress = caseDetails.getData().getApplicationType().equals(ApplicationType.PERSONAL)\n             ? caseDetails.getData().getPrimaryApplicantEmailAddress() : caseDetails.getData().getSolsSolicitorEmail();"
        },
        {
          "filename": "src/main/java/uk/gov/hmcts/probate/validator/PersonalisationValidationRule.java",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+package uk.gov.hmcts.probate.validator;\n+\n+import lombok.RequiredArgsConstructor;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+@Component\n+@RequiredArgsConstructor\n+public class PersonalisationValidationRule {\n+\n+    private final Pattern markdownLinkPattern =\n+            Pattern.compile(\"^\\\\[(.*?)]\\\\((https?:\\\\/\\\\/.*?)\\\\)$\", Pattern.CASE_INSENSITIVE);\n+\n+    public <T> List<String> validatePersonalisation(Map<String, T> personalisation) {\n+        List<String> invalidFields = new ArrayList<>();\n+        for (var entry : personalisation.entrySet()) {\n+            if (entry.getValue() != null) {\n+                String entryValue = entry.getValue().toString();\n+                int firstIndex = entryValue.indexOf('[');\n+                int secondIndex = entryValue.indexOf(')');\n+                if (firstIndex != -1 && secondIndex != -1 && firstIndex < secondIndex) {\n+                    String valueToValidate = entryValue.substring(firstIndex, secondIndex + 1);\n+                    if (!valueToValidate.isEmpty() && markdownLinkPattern.matcher(valueToValidate).find()) {\n+                        invalidFields.add(entry.getKey());\n+                    }\n+                }\n+            }\n+        }\n+        return invalidFields;\n+    }\n+}"
        },
        {
          "filename": "src/test/java/uk/gov/hmcts/probate/validator/PersonalisationValidationRuleTest.java",
          "status": "added",
          "additions": 57,
          "deletions": 0,
          "patch": "@@ -0,0 +1,57 @@\n+package uk.gov.hmcts.probate.validator;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PersonalisationValidationRuleTest {\n+\n+    @InjectMocks\n+    private PersonalisationValidationRule personalisationValidationRule;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.openMocks(this);\n+    }\n+\n+    @Test\n+    void shouldReturnFielNameWithHyperLinkWhereValidatePersonilization() {\n+        Map<String, Object> personalisation = new HashMap<>();\n+        personalisation.put(\"field1\", \"Some text [example](http://example.com)\");\n+        personalisation.put(\"field2\", \"Valid text\");\n+\n+        List<String> result = personalisationValidationRule.validatePersonalisation(personalisation);\n+\n+        assertEquals(1, result.size());\n+        assertTrue(result.contains(\"field1\"));\n+    }\n+\n+    @Test\n+    void shouldRetunEmptyListWhereNoMarkDownLink() {\n+        Map<String, Object> personalisation = new HashMap<>();\n+        personalisation.put(\"field1\", \"Some text\");\n+        personalisation.put(\"field2\", \"Another  text\");\n+\n+        List<String> result = personalisationValidationRule.validatePersonalisation(personalisation);\n+\n+        assertTrue(result.isEmpty());\n+    }\n+\n+    @Test\n+    void shouldRetunEmptyListForNullValid() {\n+        Map<String, Object> personalisation = new HashMap<>();\n+        personalisation.put(\"field1\", null);\n+\n+        List<String> result = personalisationValidationRule.validatePersonalisation(personalisation);\n+\n+        assertTrue(result.isEmpty());\n+    }\n+}\n\\ No newline at end of file"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 4,
        "max_directory_depth": 8
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "6707e098c37ad95f4af39040a9d76a350a98ae1a",
            "date": "2025-01-09T12:40:38Z",
            "author_login": "GEvans-HMCTS"
          },
          {
            "sha": "b4c37433367280bec125bd1902ec12854f19171c",
            "date": "2025-01-09T12:08:59Z",
            "author_login": "GEvans-HMCTS"
          },
          {
            "sha": "1bbf8e995e55677a67d6b6df8bba7b5b1ac2aec6",
            "date": "2025-01-09T10:29:35Z",
            "author_login": "IswaryaPepakayala"
          },
          {
            "sha": "066c983a252673cf99558be83ed77b7b9443c74b",
            "date": "2025-01-08T17:15:19Z",
            "author_login": "FeliTam"
          },
          {
            "sha": "7e9eca49067bb59c5d2ba478ef9ef13c2afddeea",
            "date": "2025-01-08T10:24:14Z",
            "author_login": "FeliTam"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.5,
    "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N",
    "cwe_id": "CWE-74",
    "description": "A vulnerability was found in HM Courts & Tribunals Service Probate Back Office up to c1afe0cdb2b2766d9e24872c4e827f8b82a6cd31. It has been classified as problematic. Affected is an unknown function of the file src/main/java/uk/gov/hmcts/probate/service/NotificationService.java of the component Markdown Handler. The manipulation leads to injection. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The patch is identified as d90230d7cf575e5b0852d56660104c8bd2503c34. It is recommended to apply a patch to fix this issue.",
    "attack_vector": "ADJACENT_NETWORK",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2024-09-01T04:15:14.107",
    "last_modified": "2024-09-03T12:59:02.453",
    "fix_date": "2024-08-12T10:44:20Z"
  },
  "references": [
    {
      "url": "https://github.com/hmcts/probate-back-office/commit/d90230d7cf575e5b0852d56660104c8bd2503c34",
      "source": "cna@vuldb.com",
      "tags": []
    },
    {
      "url": "https://github.com/hmcts/probate-back-office/pull/2614",
      "source": "cna@vuldb.com",
      "tags": []
    },
    {
      "url": "https://tools.hmcts.net/jira/browse/DTSPB-4180",
      "source": "cna@vuldb.com",
      "tags": []
    },
    {
      "url": "https://vuldb.com/?ctiid.276270",
      "source": "cna@vuldb.com",
      "tags": []
    },
    {
      "url": "https://vuldb.com/?id.276270",
      "source": "cna@vuldb.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:08:37.419703",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "probate-back-office",
    "owner": "hmcts",
    "created_at": "2018-04-06T11:50:57Z",
    "updated_at": "2025-01-09T12:40:45Z",
    "pushed_at": "2025-01-14T17:09:31Z",
    "size": 49713,
    "stars": 5,
    "forks": 10,
    "open_issues": 27,
    "watchers": 5,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "Java": 5528125,
      "HTML": 5324280,
      "JavaScript": 558808,
      "Shell": 117396,
      "CSS": 72670,
      "Groovy": 19800,
      "HCL": 3101,
      "Dockerfile": 1256
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T18:05:45.329429"
  }
}