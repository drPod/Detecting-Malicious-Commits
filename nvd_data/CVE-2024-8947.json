{
  "cve_id": "CVE-2024-8947",
  "github_data": {
    "repository": "micropython/micropython",
    "fix_commit": "4bed614e707c0644c06e117f848fa12605c711cd",
    "related_commits": [
      "4bed614e707c0644c06e117f848fa12605c711cd"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "4bed614e707c0644c06e117f848fa12605c711cd",
      "commit_date": "2024-02-12T22:24:36Z",
      "author": {
        "login": "projectgus",
        "type": "User",
        "stats": {
          "total_commits": 211,
          "average_weekly_commits": 0.3564189189189189,
          "total_additions": 0,
          "total_deletions": 0,
          "weeks_active": 71
        }
      },
      "commit_message": {
        "title": "py/objarray: Fix use-after-free if extending a bytearray from itself.",
        "length": 883,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 56,
        "additions": 45,
        "deletions": 11
      },
      "files": [
        {
          "filename": "py/objarray.c",
          "status": "modified",
          "additions": 16,
          "deletions": 4,
          "patch": "@@ -424,6 +424,13 @@ static mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n     if (self->free < len) {\n         self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n         self->free = 0;\n+\n+        if (self_in == arg_in) {\n+            // Get arg_bufinfo again in case self->items has moved\n+            //\n+            // (Note not possible to handle case that arg_in is a memoryview into self)\n+            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n+        }\n     } else {\n         self->free -= len;\n     }\n@@ -456,7 +463,8 @@ static mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value\n                 #if MICROPY_PY_ARRAY_SLICE_ASSIGN\n                 // Assign\n                 size_t src_len;\n-                void *src_items;\n+                uint8_t *src_items;\n+                size_t src_offs = 0;\n                 size_t item_sz = mp_binary_get_size('@', o->typecode & TYPECODE_MASK, NULL);\n                 if (mp_obj_is_obj(value) && MP_OBJ_TYPE_GET_SLOT_OR_NULL(((mp_obj_base_t *)MP_OBJ_TO_PTR(value))->type, subscr) == array_subscr) {\n                     // value is array, bytearray or memoryview\n@@ -469,7 +477,7 @@ static mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value\n                     src_items = src_slice->items;\n                     #if MICROPY_PY_BUILTINS_MEMORYVIEW\n                     if (mp_obj_is_type(value, &mp_type_memoryview)) {\n-                        src_items = (uint8_t *)src_items + (src_slice->memview_offset * item_sz);\n+                        src_offs = src_slice->memview_offset * item_sz;\n                     }\n                     #endif\n                 } else if (mp_obj_is_type(value, &mp_type_bytes)) {\n@@ -504,13 +512,17 @@ static mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value\n                         // TODO: alloc policy; at the moment we go conservative\n                         o->items = m_renew(byte, o->items, (o->len + o->free) * item_sz, (o->len + len_adj) * item_sz);\n                         o->free = len_adj;\n+                        // m_renew may have moved o->items\n+                        if (src_items == dest_items) {\n+                            src_items = o->items;\n+                        }\n                         dest_items = o->items;\n                     }\n                     mp_seq_replace_slice_grow_inplace(dest_items, o->len,\n-                        slice.start, slice.stop, src_items, src_len, len_adj, item_sz);\n+                        slice.start, slice.stop, src_items + src_offs, src_len, len_adj, item_sz);\n                 } else {\n                     mp_seq_replace_slice_no_grow(dest_items, o->len,\n-                        slice.start, slice.stop, src_items, src_len, item_sz);\n+                        slice.start, slice.stop, src_items + src_offs, src_len, item_sz);\n                     // Clear \"freed\" elements at the end of list\n                     // TODO: This is actually only needed for typecode=='O'\n                     mp_seq_clear(dest_items, o->len + len_adj, o->len, item_sz);"
        },
        {
          "filename": "tests/basics/bytearray_add.py",
          "status": "modified",
          "additions": 8,
          "deletions": 1,
          "patch": "@@ -15,4 +15,11 @@\n \n # this inplace add tests the code when the buffer doesn't need to be increased\n b = bytearray()\n-b += b''\n+b += b\"\"\n+\n+# extend a bytearray from itself\n+b = bytearray(b\"abcdefgh\")\n+for _ in range(4):\n+    c = bytearray(b)  # extra allocation, as above\n+    b.extend(b)\n+print(b)"
        },
        {
          "filename": "tests/basics/bytearray_add_self.py",
          "status": "added",
          "additions": 8,
          "deletions": 0,
          "patch": "@@ -0,0 +1,8 @@\n+# add a bytearray to itself\n+# This is not supported by CPython as of 3.11.18.\n+\n+b = bytearray(b\"123456789\")\n+for _ in range(4):\n+    c = bytearray(b)  # extra allocation increases chance 'b' has to relocate\n+    b += b\n+print(b)"
        },
        {
          "filename": "tests/basics/bytearray_add_self.py.exp",
          "status": "added",
          "additions": 1,
          "deletions": 0,
          "patch": "@@ -0,0 +1 @@\n+bytearray(b'123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789')"
        },
        {
          "filename": "tests/basics/bytearray_slice_assign.py",
          "status": "modified",
          "additions": 12,
          "deletions": 6,
          "patch": "@@ -18,7 +18,7 @@\n l[1:3] = bytearray()\n print(l)\n l = bytearray(x)\n-#del l[1:3]\n+# del l[1:3]\n print(l)\n \n l = bytearray(x)\n@@ -28,7 +28,7 @@\n l[:3] = bytearray()\n print(l)\n l = bytearray(x)\n-#del l[:3]\n+# del l[:3]\n print(l)\n \n l = bytearray(x)\n@@ -38,7 +38,7 @@\n l[:-3] = bytearray()\n print(l)\n l = bytearray(x)\n-#del l[:-3]\n+# del l[:-3]\n print(l)\n \n # slice assignment that extends the array\n@@ -61,8 +61,14 @@\n print(b)\n \n # Growth of bytearray via slice extension\n-b = bytearray(b'12345678')\n-b.append(57) # expand and add a bit of unused space at end of the bytearray\n+b = bytearray(b\"12345678\")\n+b.append(57)  # expand and add a bit of unused space at end of the bytearray\n for i in range(400):\n-    b[-1:] = b'ab' # grow slowly into the unused space\n+    b[-1:] = b\"ab\"  # grow slowly into the unused space\n+print(len(b), b)\n+\n+# Growth of bytearray via slice extension from itself\n+b = bytearray(b\"1234567\")\n+for i in range(3):\n+    b[-1:] = b\n print(len(b), b)"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 4,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "a4ab847688406bb31eb531e07155bf173a8785aa",
            "date": "2025-01-21T07:55:55Z",
            "author_login": "IhorNehrutsa"
          },
          {
            "sha": "865a4c8bf6868ce488347a76f5f3db8e0dabd11d",
            "date": "2025-01-21T06:48:25Z",
            "author_login": "IhorNehrutsa"
          },
          {
            "sha": "c69f0e4eeeb1058ac4a4b1b5b5d1896371e0ecd2",
            "date": "2023-10-19T09:54:37Z",
            "author_login": "ziceva"
          },
          {
            "sha": "70b95d8f9314ebcddee15e5ac2f4bdb03143846d",
            "date": "2023-03-23T05:20:46Z",
            "author_login": "graeme-winter"
          },
          {
            "sha": "1100aa63c908f60d03fa5b1d1b3abae3a53050f8",
            "date": "2025-01-16T06:09:43Z",
            "author_login": "dpgeorge"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L",
    "cwe_id": "CWE-416",
    "description": "A vulnerability was found in MicroPython 1.22.2. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file py/objarray.c. The manipulation leads to use after free. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 1.23.0 is able to address this issue. The identifier of the patch is 4bed614e707c0644c06e117f848fa12605c711cd. It is recommended to upgrade the affected component. In micropython objarray component, when a bytes object is resized and copied into itself, it may reference memory that has already been freed.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2024-09-17T19:15:29.483",
    "last_modified": "2024-09-24T13:17:52.397",
    "fix_date": "2024-02-12T22:24:36Z"
  },
  "references": [
    {
      "url": "https://github.com/micropython/micropython/commit/4bed614e707c0644c06e117f848fa12605c711cd",
      "source": "cna@vuldb.com",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://github.com/micropython/micropython/issues/13283",
      "source": "cna@vuldb.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micropython/micropython/issues/13283#issuecomment-1918479709",
      "source": "cna@vuldb.com",
      "tags": [
        "Exploit",
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://github.com/micropython/micropython/releases/tag/v1.23.0",
      "source": "cna@vuldb.com",
      "tags": [
        "Release Notes"
      ]
    },
    {
      "url": "https://vuldb.com/?ctiid.277765",
      "source": "cna@vuldb.com",
      "tags": [
        "Permissions Required"
      ]
    },
    {
      "url": "https://vuldb.com/?id.277765",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    },
    {
      "url": "https://vuldb.com/?submit.409316",
      "source": "cna@vuldb.com",
      "tags": [
        "Third Party Advisory"
      ]
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:00.126917",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "micropython",
    "owner": "micropython",
    "created_at": "2013-12-20T11:47:07Z",
    "updated_at": "2025-01-26T06:41:05Z",
    "pushed_at": "2025-01-24T12:57:20Z",
    "size": 65173,
    "stars": 19782,
    "forks": 7913,
    "open_issues": 1729,
    "watchers": 19782,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [
      "master"
    ],
    "languages": {
      "C": 20298400,
      "Python": 2084059,
      "Makefile": 247405,
      "CMake": 89440,
      "JavaScript": 57043,
      "Shell": 56412,
      "C++": 43811,
      "Assembly": 30591
    },
    "commit_activity": {
      "total_commits_last_year": 888,
      "avg_commits_per_week": 17.076923076923077,
      "days_active_last_year": 252
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-26T07:55:34.169775"
  }
}