{
  "cve_id": "CVE-2025-0218",
  "github_data": {
    "repository": "pgadmin-org/pgagent",
    "fix_commit": "1ecd193a2be3a3dc9e98f369495e1a792e6d508c",
    "related_commits": [
      "1ecd193a2be3a3dc9e98f369495e1a792e6d508c"
    ],
    "patch_url": "https://github.com/pgadmin-org/pgagent/commit/1ecd193a2be3a3dc9e98f369495e1a792e6d508c.patch",
    "fix_commit_details": {
      "sha": "1ecd193a2be3a3dc9e98f369495e1a792e6d508c",
      "commit_date": "2025-01-03T10:40:30Z",
      "author": {
        "login": "asheshv",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "Ensure the directory used for batch job step scripts is not predictable.",
        "length": 106,
        "has_description": true,
        "references_issue": false
      },
      "stats": {
        "total": 135,
        "additions": 65,
        "deletions": 70
      },
      "files": [
        {
          "filename": "include/misc.h",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -23,7 +23,7 @@ std::wstring  s2ws(const std::string &str);\n std::string   ws2s(const std::wstring &wstr);\n #endif\n std::string   generateRandomString(size_t length);\n-std::string   getTemporaryDirectoryPath();\n+bool          createUniqueTemporaryDirectory(const std::string &prefix, boost::filesystem::path &tempDir);\n \n class MutexLocker\n {"
        },
        {
          "filename": "job.cpp",
          "status": "modified",
          "additions": 36,
          "deletions": 39,
          "patch": "@@ -163,45 +163,41 @@ int Job::Execute()\n           LOG_DEBUG\n \t\t\t\t);\n \n-\t\t\t\t// Get a temporary filename, then reuse it to create an empty directory.\n-\t\t\t\tstd::string sDirectory = getTemporaryDirectoryPath();\n-\t\t\t\tstd::string sFilesName = std::string(\"\");\n-\t\t\t\tstd::string prefix = std::string(\"pga_\");\n-\n-\t\t\t\t// Generate random string of 6 characters long to make unique dir name\n-\t\t\t\tstd::string result = generateRandomString(7);\n-\t\t\t\tsFilesName = prefix + m_jobid + std::string(\"_\") + stepid + std::string(\"_\") + result;\n+\t\t\t\tnamespace fs = boost::filesystem;\n+\n+\t\t\t\t// Generate unique temporary directory\n+\t\t\t\tstd::string prefix = (\n+\t\t\t\t\tboost::format(\"pga_%s_%s_\") % m_jobid % stepid\n+\t\t\t\t).str();\n+\n+\t\t\t\tfs::path jobDir;\n+\t\t\t\tfs::path filepath((\n+\t\t\t\t\tboost::format(\"%s_%s.%s\") %\n+\t\t\t\t\tm_jobid % stepid %\n #if BOOST_OS_WINDOWS\n-\t\t\t\tstd::string sModel = (boost::format(\"%s\\\\%s\") % sDirectory % sFilesName).str();\n+\t\t\t\t\t\".bat\"\n #else\n-\t\t\t\tstd::string sModel = (boost::format(\"%s/%s\") % sDirectory % sFilesName).str();\n+\t\t\t\t\t\".scr\"\n #endif\n-\t\t\t\tstd::string dirname = sModel;\n+\t\t\t\t).str());\n+\t\t\t\tfs::path errorFilePath(\n+\t\t\t\t\t(boost::format(\"%s_%s_error.txt\") % m_jobid % stepid).str()\n+\t\t\t\t);\n \n-\t\t\t\tif (dirname == \"\")\n+\t\t\t\tif (!createUniqueTemporaryDirectory(prefix, jobDir))\n \t\t\t\t{\n \t\t\t\t\toutput = \"Couldn't get a temporary filename!\";\n \t\t\t\t\tLogMessage(output, LOG_WARNING);\n \t\t\t\t\trc = -1;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n \n-\t\t\t\tif (!boost::filesystem::create_directory(boost::filesystem::path(dirname)))\n-\t\t\t\t{\n-\t\t\t\t\tLogMessage(\n-\t\t\t\t\t\t\"Couldn't create temporary directory: \" + dirname, LOG_WARNING\n-\t\t\t\t\t);\n-\t\t\t\t\trc = -1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \n-#if BOOST_OS_WINDOWS\n-\t\t\t\tstd::string filename = dirname + \"\\\\\" + m_jobid + \"_\" + stepid + \".bat\";\n-\t\t\t\tstd::string errorFile = dirname + \"\\\\\" + m_jobid + \"_\" + stepid + \"_error.txt\";\n-#else\n-\t\t\t\tstd::string filename = dirname + \"/\" + m_jobid + \"_\" + stepid + \".scr\";\n-\t\t\t\tstd::string errorFile = dirname + \"/\" + m_jobid + \"_\" + stepid + \"_error.txt\";\n-#endif\n+\t\t\t\tfilepath = jobDir / filepath;\n+\t\t\t\terrorFilePath = jobDir / errorFilePath;\n+\n+\t\t\t\tstd::string filename = filepath.string();\n+\t\t\t\tstd::string errorFile = errorFilePath.string();\n \n \t\t\t\tstd::string code = steps->GetString(\"jstcode\");\n \n@@ -222,8 +218,8 @@ int Job::Execute()\n \t\t\t\t\t\tLOG_WARNING\n \t\t\t\t\t);\n \n-\t\t\t\t\tif (boost::filesystem::exists(dirname))\n-\t\t\t\t\t\tboost::filesystem::remove_all(dirname);\n+\t\t\t\t\tif (boost::filesystem::exists(jobDir))\n+\t\t\t\t\t\tboost::filesystem::remove_all(jobDir);\n \n \t\t\t\t\trc = -1;\n \t\t\t\t\tbreak;\n@@ -234,14 +230,17 @@ int Job::Execute()\n \t\t\t\t\tout_file.close();\n \n #if !BOOST_OS_WINDOWS\n-\t\t\t\t\t// change file permission to 700 for executable in linux\n-\t\t\t\t\tint ret = chmod((const char *)filename.c_str(), S_IRWXU);\n-\n-\t\t\t\t\tif (ret != 0)\n+\t\t\t\t\t// Change file permission to 700 for executable in linux\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tboost::filesystem::permissions(\n+\t\t\t\t\t\t\tfilepath, boost::filesystem::owner_all\n+\t\t\t\t\t\t);\n+\t\t\t\t\t} catch (const fs::filesystem_error &ex) {\n \t\t\t\t\t\tLogMessage(\n-\t\t\t\t\t\t\t\"Error setting executable permission to file: \" + filename,\n-\t\t\t\t\t\t\tLOG_DEBUG\n+\t\t\t\t\t\t\t\"Error setting executable permission to file: \" +\n+\t\t\t\t\t\t\tfilename, LOG_DEBUG\n \t\t\t\t\t\t);\n+\t\t\t\t\t}\n #endif\n \t\t\t\t}\n \n@@ -368,10 +367,8 @@ int Job::Execute()\n \t\t\t\t// output in the log, just throw warnings.\n \t\t\t\ttry\n \t\t\t\t{\n-\t\t\t\t\tboost::filesystem::path dir_path(dirname);\n-\n-\t\t\t\t\tif (boost::filesystem::exists(dir_path))\n-\t\t\t\t\t\tboost::filesystem::remove_all(dir_path);\n+\t\t\t\t\tif (boost::filesystem::exists(jobDir))\n+\t\t\t\t\t\tboost::filesystem::remove_all(jobDir);\n \t\t\t\t}\n \t\t\t\tcatch (boost::filesystem::filesystem_error const & e)\n \t\t\t\t{"
        },
        {
          "filename": "misc.cpp",
          "status": "modified",
          "additions": 28,
          "deletions": 30,
          "patch": "@@ -21,6 +21,8 @@\n \n #define APPVERSION_STR PGAGENT_VERSION\n \n+namespace fs = boost::filesystem;\n+\n // In unix.c or win32.c\n void usage(const std::string &executable);\n \n@@ -49,7 +51,7 @@ void printVersion()\n {\n \tprintf(\"PostgreSQL Scheduling Agent\\n\");\n \tprintf(\"Version: %s\\n\", APPVERSION_STR);\n-}\n+};\n \n void setOptions(int argc, char **argv, const std::string &executable)\n {\n@@ -192,41 +194,37 @@ std::string generateRandomString(size_t length)\n \treturn result;\n }\n \n-std::string getTemporaryDirectoryPath()\n+bool createUniqueTemporaryDirectory(const std::string &prefix, fs::path &uniqueDir)\n {\n+\tconst unsigned short MAX_ATTEMPTS = 100;\n+\tunsigned short attempts = 0;\n \n-#if BOOST_OS_WINDOWS\n-    std::wstring tmp_dir;\n+\ttry {\n+\t\tfs::path tempDir = fs::temp_directory_path();\n \n-    wchar_t wcharPath[MAX_PATH];\n+\t\tdo {\n+\t\t\tif (attempts++ >= MAX_ATTEMPTS)\n+\t\t\t\treturn false;\n \n-    if (GetTempPathW(MAX_PATH, wcharPath))\n-\t\t{\n-        tmp_dir = wcharPath;\n+\t\t\tuniqueDir = tempDir / fs::unique_path(\n+\t\t\t\tprefix + \"%%%%%%%%-%%%%-%%%%-%%%%-%%%%%%%%%%%%\"\n+\t\t\t);\n \n-\t\t\t\treturn ws2s(tmp_dir);\n-\t\t}\n-    return \"\";\n-#else\n-    // Read this environment variable (TMPDIR, TMP, TEMP, TEMPDIR) and if not found then use \"/tmp\"\n-    std::string tmp_dir = \"/tmp\";\n-    const char *s_tmp = getenv(\"TMPDIR\");\n+\t\t\t// Check if exists\n+\t\t\tif (boost::filesystem::is_directory(uniqueDir))\n+\t\t\t\tcontinue;\n \n-    if (s_tmp != NULL)\n-        return s_tmp;\n-\n-\t\ts_tmp = getenv(\"TMP\");\n-\t\tif (s_tmp != NULL)\n-\t\t\treturn s_tmp;\n-\n-\t\ts_tmp = getenv(\"TEMP\");\n-\t\tif (s_tmp != NULL)\n-\t\t\treturn s_tmp;\n+\t\t\t// Create the directory securely\n+\t\t\tif (!fs::create_directory(uniqueDir)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \n-\t\ts_tmp = getenv(\"TEMPDIR\");\n-\t\tif (s_tmp != NULL)\n-\t\t\treturn s_tmp;\n+\t\t\t// Set appropriate permissions (example: owner read/write/execute only)\n+\t\t\tfs::permissions(uniqueDir, boost::filesystem::owner_all);\n \n-\t\treturn tmp_dir;\n-#endif\n+\t\t\treturn true;\n+\t\t} while (true);\n+\t} catch (const fs::filesystem_error &ex) {\n+\t\treturn false;\n+\t}\n }"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 2,
        "max_directory_depth": 1
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "1ecd193a2be3a3dc9e98f369495e1a792e6d508c",
            "date": "2025-01-03T10:40:30Z",
            "author_login": "asheshv"
          },
          {
            "sha": "20e5de2f799fa342fc07e2010ea8b4de1977234e",
            "date": "2025-01-03T10:06:48Z",
            "author_login": "dpage"
          },
          {
            "sha": "739388dbd14109a2f54811e0850982b1c4818504",
            "date": "2025-01-03T10:00:30Z",
            "author_login": "asheshv"
          },
          {
            "sha": "23689bed812419cd7cd79688fbce4f876c235fb8",
            "date": "2024-12-16T15:01:22Z",
            "author_login": "dpage"
          },
          {
            "sha": "a9a17a89a58cccbd7ab2fbe23934fd8d80d6c82e",
            "date": "2024-12-16T14:54:31Z",
            "author_login": "dpage"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 5.5,
    "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "cwe_id": "CWE-340",
    "description": "When batch jobs are executed by pgAgent, a script is created in a temporary directory and then executed. In versions of pgAgent prior to 4.2.3, an insufficiently seeded random number generator is used when generating the directory name, leading to the possibility for a local attacker to pre-create the directory and thus prevent pgAgent from executing jobs, disrupting scheduled tasks.",
    "attack_vector": "LOCAL",
    "attack_complexity": "LOW"
  },
  "temporal_data": {
    "published_date": "2025-01-07T20:15:30.710",
    "last_modified": "2025-01-07T20:15:30.710",
    "fix_date": "2025-01-03T10:40:30Z"
  },
  "references": [
    {
      "url": "https://github.com/pgadmin-org/pgagent/commit/1ecd193a2be3a3dc9e98f369495e1a792e6d508c",
      "source": "f86ef6dc-4d3a-42ad-8f28-e6d5547a5007",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:58.224589",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "pgagent",
    "owner": "pgadmin-org",
    "created_at": "2010-08-18T10:48:17Z",
    "updated_at": "2025-01-03T10:42:38Z",
    "pushed_at": "2025-01-06T12:52:31Z",
    "size": 305,
    "stars": 109,
    "forks": 42,
    "open_issues": 10,
    "watchers": 109,
    "has_security_policy": false,
    "default_branch": "master",
    "protected_branches": [],
    "languages": {
      "PLpgSQL": 90730,
      "C++": 57861,
      "CMake": 40729,
      "C": 1177,
      "Makefile": 93
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "other"
    },
    "collected_at": "2025-01-14T15:18:53.965908"
  }
}