{
  "cve_id": "CVE-2025-22130",
  "github_data": {
    "repository": "charmbracelet/soft-serve",
    "fix_commit": "a8d1bf3f9349c138383b65079b7b8ad97fff78f4",
    "related_commits": [
      "a8d1bf3f9349c138383b65079b7b8ad97fff78f4"
    ],
    "patch_url": null,
    "fix_commit_details": {
      "sha": "a8d1bf3f9349c138383b65079b7b8ad97fff78f4",
      "commit_date": "2025-01-07T11:30:47Z",
      "author": {
        "login": "aymanbagabas",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: prevent path traversal attacks (#631)",
        "length": 330,
        "has_description": true,
        "references_issue": true
      },
      "stats": {
        "total": 44,
        "additions": 23,
        "deletions": 21
      },
      "files": [
        {
          "filename": "pkg/backend/repo.go",
          "status": "modified",
          "additions": 18,
          "deletions": 19,
          "patch": "@@ -10,6 +10,7 @@ import (\n \t\"path\"\n \t\"path/filepath\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"github.com/charmbracelet/soft-serve/git\"\n@@ -24,10 +25,6 @@ import (\n \t\"github.com/charmbracelet/soft-serve/pkg/webhook\"\n )\n \n-func (d *Backend) reposPath() string {\n-\treturn filepath.Join(d.cfg.DataPath, \"repos\")\n-}\n-\n // CreateRepository creates a new repository.\n //\n // It implements backend.Backend.\n@@ -37,8 +34,7 @@ func (d *Backend) CreateRepository(ctx context.Context, name string, user proto.\n \t\treturn nil, err\n \t}\n \n-\trepo := name + \".git\"\n-\trp := filepath.Join(d.reposPath(), repo)\n+\trp := filepath.Join(d.repoPath(name))\n \n \tvar userID int64\n \tif user != nil {\n@@ -78,7 +74,7 @@ func (d *Backend) CreateRepository(ctx context.Context, name string, user proto.\n \t\t\t}\n \t\t}\n \n-\t\treturn hooks.GenerateHooks(ctx, d.cfg, repo)\n+\t\treturn hooks.GenerateHooks(ctx, d.cfg, name)\n \t}); err != nil {\n \t\td.logger.Debug(\"failed to create repository in database\", \"err\", err)\n \t\terr = db.WrapError(err)\n@@ -100,8 +96,7 @@ func (d *Backend) ImportRepository(_ context.Context, name string, user proto.Us\n \t\treturn nil, err\n \t}\n \n-\trepo := name + \".git\"\n-\trp := filepath.Join(d.reposPath(), repo)\n+\trp := filepath.Join(d.repoPath(name))\n \n \ttid := \"import:\" + name\n \tif d.manager.Exists(tid) {\n@@ -217,8 +212,7 @@ func (d *Backend) ImportRepository(_ context.Context, name string, user proto.Us\n // It implements backend.Backend.\n func (d *Backend) DeleteRepository(ctx context.Context, name string) error {\n \tname = utils.SanitizeRepo(name)\n-\trepo := name + \".git\"\n-\trp := filepath.Join(d.reposPath(), repo)\n+\trp := filepath.Join(d.repoPath(name))\n \n \tuser := proto.UserFromContext(ctx)\n \tr, err := d.Repository(ctx, name)\n@@ -330,10 +324,8 @@ func (d *Backend) RenameRepository(ctx context.Context, oldName string, newName\n \t\treturn nil\n \t}\n \n-\toldRepo := oldName + \".git\"\n-\tnewRepo := newName + \".git\"\n-\top := filepath.Join(d.reposPath(), oldRepo)\n-\tnp := filepath.Join(d.reposPath(), newRepo)\n+\top := filepath.Join(d.repoPath(oldName))\n+\tnp := filepath.Join(d.repoPath(newName))\n \tif _, err := os.Stat(op); err != nil {\n \t\treturn proto.ErrRepoNotFound\n \t}\n@@ -389,7 +381,7 @@ func (d *Backend) Repositories(ctx context.Context) ([]proto.Repository, error)\n \t\tfor _, m := range ms {\n \t\t\tr := &repo{\n \t\t\t\tname: m.Name,\n-\t\t\t\tpath: filepath.Join(d.reposPath(), m.Name+\".git\"),\n+\t\t\t\tpath: filepath.Join(d.repoPath(m.Name)),\n \t\t\t\trepo: m,\n \t\t\t}\n \n@@ -418,7 +410,7 @@ func (d *Backend) Repository(ctx context.Context, name string) (proto.Repository\n \t\treturn r, nil\n \t}\n \n-\trp := filepath.Join(d.reposPath(), name+\".git\")\n+\trp := filepath.Join(d.repoPath(name))\n \tif _, err := os.Stat(rp); err != nil {\n \t\tif !errors.Is(err, fs.ErrNotExist) {\n \t\t\td.logger.Errorf(\"failed to stat repository path: %v\", err)\n@@ -552,7 +544,7 @@ func (d *Backend) SetHidden(ctx context.Context, name string, hidden bool) error\n // It implements backend.Backend.\n func (d *Backend) SetDescription(ctx context.Context, name string, desc string) error {\n \tname = utils.SanitizeRepo(name)\n-\trp := filepath.Join(d.reposPath(), name+\".git\")\n+\trp := filepath.Join(d.repoPath(name))\n \n \t// Delete cache\n \td.cache.Delete(name)\n@@ -572,7 +564,7 @@ func (d *Backend) SetDescription(ctx context.Context, name string, desc string)\n // It implements backend.Backend.\n func (d *Backend) SetPrivate(ctx context.Context, name string, private bool) error {\n \tname = utils.SanitizeRepo(name)\n-\trp := filepath.Join(d.reposPath(), name+\".git\")\n+\trp := filepath.Join(d.repoPath(name))\n \n \t// Delete cache\n \td.cache.Delete(name)\n@@ -636,6 +628,13 @@ func (d *Backend) SetProjectName(ctx context.Context, repo string, name string)\n \t)\n }\n \n+// repoPath returns the path to a repository.\n+func (d *Backend) repoPath(name string) string {\n+\tname = utils.SanitizeRepo(name)\n+\trn := strings.ReplaceAll(name, \"/\", string(os.PathSeparator))\n+\treturn filepath.Join(filepath.Join(d.cfg.DataPath, \"repos\"), rn+\".git\")\n+}\n+\n var _ proto.Repository = (*repo)(nil)\n \n // repo is a Git repository with metadata stored in a SQLite database."
        },
        {
          "filename": "pkg/ssh/cmd/cmd.go",
          "status": "modified",
          "additions": 1,
          "deletions": 1,
          "patch": "@@ -172,7 +172,7 @@ func checkIfAdmin(cmd *cobra.Command, args []string) error {\n func checkIfCollab(cmd *cobra.Command, args []string) error {\n \tvar repo string\n \tif len(args) > 0 {\n-\t\trepo = args[0]\n+\t\trepo = utils.SanitizeRepo(args[0])\n \t}\n \n \tctx := cmd.Context()"
        },
        {
          "filename": "pkg/utils/utils.go",
          "status": "modified",
          "additions": 4,
          "deletions": 1,
          "patch": "@@ -9,12 +9,15 @@ import (\n \n // SanitizeRepo returns a sanitized version of the given repository name.\n func SanitizeRepo(repo string) string {\n+\t// We need to use an absolute path for the path to be cleaned correctly.\n \trepo = strings.TrimPrefix(repo, \"/\")\n+\trepo = \"/\" + repo\n+\n \t// We're using path instead of filepath here because this is not OS dependent\n \t// looking at you Windows\n \trepo = path.Clean(repo)\n \trepo = strings.TrimSuffix(repo, \".git\")\n-\treturn repo\n+\treturn repo[1:]\n }\n \n // ValidateUsername returns an error if any of the given usernames are invalid."
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 0,
        "unique_directories": 3,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "cc93b27712e5438947b62a19b6cb00828cee0581",
            "date": "2025-01-23T08:16:28Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "eb15371689b00514b16f952c6eb3a5da8d36acbb",
            "date": "2025-01-22T13:22:20Z",
            "author_login": "dominicdoty"
          },
          {
            "sha": "b207cba864bbecbb88aa0b7bc75f39e3f3603ec5",
            "date": "2025-01-16T08:10:12Z",
            "author_login": "dependabot[bot]"
          },
          {
            "sha": "22d00e9db31e1f4d0c32beae1e8733883f4d80d8",
            "date": "2025-01-07T11:32:03Z",
            "author_login": "aymanbagabas"
          },
          {
            "sha": "a8d1bf3f9349c138383b65079b7b8ad97fff78f4",
            "date": "2025-01-07T11:30:47Z",
            "author_login": "aymanbagabas"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-22",
    "description": "Soft Serve is a self-hostable Git server for the command line. Prior to 0.8.2 , a path traversal attack allows existing non-admin users to access and take over other user's repositories. A malicious user then can modify, delete, and arbitrarily repositories as if they were an admin user without explicitly giving them permissions. This is patched in v0.8.2.",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2025-01-08T16:15:38.543",
    "last_modified": "2025-01-08T16:15:38.543",
    "fix_date": "2025-01-07T11:30:47Z"
  },
  "references": [
    {
      "url": "https://github.com/charmbracelet/soft-serve/commit/a8d1bf3f9349c138383b65079b7b8ad97fff78f4",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/charmbracelet/soft-serve/releases/tag/v0.8.2",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/charmbracelet/soft-serve/security/advisories/GHSA-j4jw-m6xr-fv6c",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:58.226982",
    "processing_status": "enhanced"
  },
  "repository_context": {
    "name": "soft-serve",
    "owner": "charmbracelet",
    "created_at": "2021-07-30T23:32:44Z",
    "updated_at": "2025-01-25T21:14:11Z",
    "pushed_at": "2025-01-23T08:16:30Z",
    "size": 2299,
    "stars": 5575,
    "forks": 146,
    "open_issues": 52,
    "watchers": 5575,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Go": 627618,
      "Dockerfile": 574,
      "Shell": 510
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-26T08:33:26.299501"
  }
}