{
  "cve_id": "CVE-2025-22149",
  "github_data": {
    "repository": "MicahParks/jwkset",
    "fix_commit": "01db49a90f7f20c7fb39a699a2f19a7a5f379ed3",
    "related_commits": [
      "01db49a90f7f20c7fb39a699a2f19a7a5f379ed3"
    ],
    "patch_url": "https://github.com/MicahParks/jwkset/commit/01db49a90f7f20c7fb39a699a2f19a7a5f379ed3.patch",
    "fix_commit_details": {
      "sha": "01db49a90f7f20c7fb39a699a2f19a7a5f379ed3",
      "commit_date": "2025-01-09T13:18:05Z",
      "author": {
        "login": "MicahParks",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "HTTP client only overwrites and appends JWK to local cache during refresh (#41)",
        "length": 79,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 180,
        "additions": 147,
        "deletions": 33
      },
      "files": [
        {
          "filename": "examples/storage_operations/go.mod",
          "status": "modified",
          "additions": 3,
          "deletions": 3,
          "patch": "@@ -5,8 +5,8 @@ go 1.21\n replace github.com/MicahParks/jwkset => ../..\n \n require (\n-\tgithub.com/MicahParks/jwkset v0.5.6\n-\tgithub.com/google/uuid v1.5.0\n+\tgithub.com/MicahParks/jwkset v0.6.0\n+\tgithub.com/google/uuid v1.6.0\n )\n \n-require golang.org/x/time v0.5.0 // indirect\n+require golang.org/x/time v0.9.0 // indirect"
        },
        {
          "filename": "examples/storage_operations/go.sum",
          "status": "modified",
          "additions": 4,
          "deletions": 4,
          "patch": "@@ -1,4 +1,4 @@\n-github.com/google/uuid v1.5.0 h1:1p67kYwdtXjb0gL0BPiP1Av9wiZPo5A8z2cWkTZ+eyU=\n-github.com/google/uuid v1.5.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\n-golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\n-golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\n+github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\n+github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\n+golang.org/x/time v0.9.0 h1:EsRrnYcQiGH+5FfbgvV4AP7qEZstoyrHB0DzarOQ4ZY=\n+golang.org/x/time v0.9.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM="
        },
        {
          "filename": "go.mod",
          "status": "modified",
          "additions": 3,
          "deletions": 1,
          "patch": "@@ -2,4 +2,6 @@ module github.com/MicahParks/jwkset\n \n go 1.21\n \n-require golang.org/x/time v0.5.0\n+require golang.org/x/time v0.9.0\n+\n+retract [v0.5.0, v0.5.15] // HTTP client only overwrites and appends JWK to local cache during refresh: https://github.com/MicahParks/jwkset/issues/40"
        },
        {
          "filename": "go.sum",
          "status": "modified",
          "additions": 2,
          "deletions": 2,
          "patch": "@@ -1,2 +1,2 @@\n-golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\n-golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\n+golang.org/x/time v0.9.0 h1:EsRrnYcQiGH+5FfbgvV4AP7qEZstoyrHB0DzarOQ4ZY=\n+golang.org/x/time v0.9.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM="
        },
        {
          "filename": "http_test.go",
          "status": "modified",
          "additions": 114,
          "deletions": 0,
          "patch": "@@ -5,6 +5,7 @@ import (\n \t\"context\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n+\t\"net/url\"\n \t\"strings\"\n \t\"sync\"\n \t\"testing\"\n@@ -144,6 +145,119 @@ func TestClient(t *testing.T) {\n \t}\n }\n \n+func TestClientCacheReplacement(t *testing.T) {\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\tkid := \"my-key-id\"\n+\tsecret := []byte(\"my-hmac-secret\")\n+\tserverStore := NewMemoryStorage()\n+\tmarshalOptions := JWKMarshalOptions{\n+\t\tPrivate: true,\n+\t}\n+\tmetadata := JWKMetadataOptions{\n+\t\tKID: kid,\n+\t}\n+\toptions := JWKOptions{\n+\t\tMarshal:  marshalOptions,\n+\t\tMetadata: metadata,\n+\t}\n+\tjwk, err := NewJWKFromKey(secret, options)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create a JWK from the given HMAC secret.\\nError: %s\", err)\n+\t}\n+\terr = serverStore.KeyWrite(ctx, jwk)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to write the given JWK to the store.\\nError: %s\", err)\n+\t}\n+\trawJWKS, err := serverStore.JSON(ctx)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to get the JSON.\\nError: %s\", err)\n+\t}\n+\n+\trawJWKSMux := sync.RWMutex{}\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\trawJWKSMux.RLock()\n+\t\tdefer rawJWKSMux.RUnlock()\n+\t\t_, _ = w.Write(rawJWKS)\n+\t}))\n+\n+\tu, err := url.ParseRequestURI(server.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to parse the URL.\\nError: %s\", err)\n+\t}\n+\n+\trefreshInterval := 50 * time.Millisecond\n+\thttpOptions := HTTPClientStorageOptions{\n+\t\tCtx:             ctx,\n+\t\tRefreshInterval: refreshInterval,\n+\t}\n+\tclientStore, err := NewStorageFromHTTP(u, httpOptions)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create a new HTTP client.\\nError: %s\", err)\n+\t}\n+\n+\tjwk, err = clientStore.KeyRead(ctx, kid)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to read the JWK.\\nError: %s\", err)\n+\t}\n+\n+\tif !bytes.Equal(jwk.Key().([]byte), secret) {\n+\t\tt.Fatalf(\"The key read from the HTTP client did not match the original key.\")\n+\t}\n+\n+\tjwks, err := clientStore.KeyReadAll(ctx)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to read all the JWKs.\\nError: %s\", err)\n+\t}\n+\tif len(jwks) != 1 {\n+\t\tt.Fatalf(\"Expected to read 1 JWK, but got %d.\", len(jwks))\n+\t}\n+\tif !bytes.Equal(jwks[0].Key().([]byte), secret) {\n+\t\tt.Fatalf(\"The key read from the HTTP client did not match the original key.\")\n+\t}\n+\n+\totherKeyID := myKeyID + \"2\"\n+\toptions.Metadata.KID = otherKeyID\n+\totherSecret := []byte(\"my-other-hmac-secret\")\n+\tjwk, err = NewJWKFromKey(otherSecret, options)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create a JWK from the given HMAC secret.\\nError: %s\", err)\n+\t}\n+\terr = serverStore.KeyWrite(ctx, jwk)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to write the given JWK to the store.\\nError: %s\", err)\n+\t}\n+\tok, err := serverStore.KeyDelete(ctx, kid)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to delete the given JWK from the store.\\nError: %s\", err)\n+\t}\n+\tif !ok {\n+\t\tt.Fatalf(\"Expected the key to be deleted.\")\n+\t}\n+\trawJWKSMux.Lock()\n+\trawJWKS, err = serverStore.JSON(ctx)\n+\trawJWKSMux.Unlock()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to get the JSON.\\nError: %s\", err)\n+\t}\n+\ttime.Sleep(2 * refreshInterval)\n+\n+\tjwks, err = clientStore.KeyReadAll(ctx)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to read the JWK.\\nError: %s\", err)\n+\t}\n+\tif len(jwks) != 1 {\n+\t\tt.Fatalf(\"Expected to read 1 JWK, but got %d.\", len(jwks))\n+\t}\n+\tif jwks[0].marshal.KID != otherKeyID {\n+\t\tt.Fatalf(\"The key read from the HTTP client did not match the original key.\")\n+\t}\n+\tif !bytes.Equal(jwks[0].Key().([]byte), otherSecret) {\n+\t\tt.Fatalf(\"The key read from the HTTP client did not match the original key.\")\n+\t}\n+}\n+\n func TestClientError(t *testing.T) {\n \t_, err := NewHTTPClient(HTTPClientOptions{})\n \tif err == nil {"
        },
        {
          "filename": "storage.go",
          "status": "modified",
          "additions": 21,
          "deletions": 23,
          "patch": "@@ -49,19 +49,19 @@ type Storage interface {\n \tMarshalWithOptions(ctx context.Context, marshalOptions JWKMarshalOptions, validationOptions JWKValidateOptions) (JWKSMarshal, error)\n }\n \n-var _ Storage = &memoryJWKSet{}\n+var _ Storage = &MemoryJWKSet{}\n \n-type memoryJWKSet struct {\n+type MemoryJWKSet struct {\n \tset []JWK\n \tmux sync.RWMutex\n }\n \n // NewMemoryStorage creates a new in-memory Storage implementation.\n-func NewMemoryStorage() Storage {\n-\treturn &memoryJWKSet{}\n+func NewMemoryStorage() *MemoryJWKSet {\n+\treturn &MemoryJWKSet{}\n }\n \n-func (m *memoryJWKSet) KeyDelete(_ context.Context, keyID string) (ok bool, err error) {\n+func (m *MemoryJWKSet) KeyDelete(_ context.Context, keyID string) (ok bool, err error) {\n \tm.mux.Lock()\n \tdefer m.mux.Unlock()\n \tfor i, jwk := range m.set {\n@@ -72,7 +72,12 @@ func (m *memoryJWKSet) KeyDelete(_ context.Context, keyID string) (ok bool, err\n \t}\n \treturn ok, nil\n }\n-func (m *memoryJWKSet) KeyRead(_ context.Context, keyID string) (JWK, error) {\n+func (m *MemoryJWKSet) KeyDeleteAll() {\n+\tm.mux.Lock()\n+\tdefer m.mux.Unlock()\n+\tm.set = make([]JWK, 0)\n+}\n+func (m *MemoryJWKSet) KeyRead(_ context.Context, keyID string) (JWK, error) {\n \tm.mux.RLock()\n \tdefer m.mux.RUnlock()\n \tfor _, jwk := range m.set {\n@@ -82,12 +87,12 @@ func (m *memoryJWKSet) KeyRead(_ context.Context, keyID string) (JWK, error) {\n \t}\n \treturn JWK{}, fmt.Errorf(\"%w: kid %q\", ErrKeyNotFound, keyID)\n }\n-func (m *memoryJWKSet) KeyReadAll(_ context.Context) ([]JWK, error) {\n+func (m *MemoryJWKSet) KeyReadAll(_ context.Context) ([]JWK, error) {\n \tm.mux.RLock()\n \tdefer m.mux.RUnlock()\n \treturn slices.Clone(m.set), nil\n }\n-func (m *memoryJWKSet) KeyWrite(_ context.Context, jwk JWK) error {\n+func (m *MemoryJWKSet) KeyWrite(_ context.Context, jwk JWK) error {\n \tm.mux.Lock()\n \tdefer m.mux.Unlock()\n \tfor i, j := range m.set {\n@@ -100,30 +105,30 @@ func (m *memoryJWKSet) KeyWrite(_ context.Context, jwk JWK) error {\n \treturn nil\n }\n \n-func (m *memoryJWKSet) JSON(ctx context.Context) (json.RawMessage, error) {\n+func (m *MemoryJWKSet) JSON(ctx context.Context) (json.RawMessage, error) {\n \tjwks, err := m.Marshal(ctx)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"failed to marshal JWK Set: %w\", err)\n \t}\n \treturn json.Marshal(jwks)\n }\n-func (m *memoryJWKSet) JSONPublic(ctx context.Context) (json.RawMessage, error) {\n+func (m *MemoryJWKSet) JSONPublic(ctx context.Context) (json.RawMessage, error) {\n \treturn m.JSONWithOptions(ctx, JWKMarshalOptions{}, JWKValidateOptions{})\n }\n-func (m *memoryJWKSet) JSONPrivate(ctx context.Context) (json.RawMessage, error) {\n+func (m *MemoryJWKSet) JSONPrivate(ctx context.Context) (json.RawMessage, error) {\n \tmarshalOptions := JWKMarshalOptions{\n \t\tPrivate: true,\n \t}\n \treturn m.JSONWithOptions(ctx, marshalOptions, JWKValidateOptions{})\n }\n-func (m *memoryJWKSet) JSONWithOptions(ctx context.Context, marshalOptions JWKMarshalOptions, validationOptions JWKValidateOptions) (json.RawMessage, error) {\n+func (m *MemoryJWKSet) JSONWithOptions(ctx context.Context, marshalOptions JWKMarshalOptions, validationOptions JWKValidateOptions) (json.RawMessage, error) {\n \tjwks, err := m.MarshalWithOptions(ctx, marshalOptions, validationOptions)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"failed to marshal JWK Set with options: %w\", err)\n \t}\n \treturn json.Marshal(jwks)\n }\n-func (m *memoryJWKSet) Marshal(ctx context.Context) (JWKSMarshal, error) {\n+func (m *MemoryJWKSet) Marshal(ctx context.Context) (JWKSMarshal, error) {\n \tkeys, err := m.KeyReadAll(ctx)\n \tif err != nil {\n \t\treturn JWKSMarshal{}, fmt.Errorf(\"failed to read snapshot of all keys from storage: %w\", err)\n@@ -134,7 +139,7 @@ func (m *memoryJWKSet) Marshal(ctx context.Context) (JWKSMarshal, error) {\n \t}\n \treturn jwks, nil\n }\n-func (m *memoryJWKSet) MarshalWithOptions(ctx context.Context, marshalOptions JWKMarshalOptions, validationOptions JWKValidateOptions) (JWKSMarshal, error) {\n+func (m *MemoryJWKSet) MarshalWithOptions(ctx context.Context, marshalOptions JWKMarshalOptions, validationOptions JWKValidateOptions) (JWKSMarshal, error) {\n \tjwks := JWKSMarshal{}\n \n \tkeys, err := m.KeyReadAll(ctx)\n@@ -203,11 +208,6 @@ type HTTPClientStorageOptions struct {\n \t// Provide the Ctx option to end the goroutine when it's no longer needed.\n \tRefreshInterval time.Duration\n \n-\t// Storage is the underlying storage implementation to use.\n-\t//\n-\t// This defaults to NewMemoryStorage().\n-\tStorage Storage\n-\n \t// ValidateOptions are the options to use when validating the JWKs.\n \tValidateOptions JWKValidateOptions\n }\n@@ -238,10 +238,7 @@ func NewStorageFromHTTP(u *url.URL, options HTTPClientStorageOptions) (Storage,\n \tif options.HTTPMethod == \"\" {\n \t\toptions.HTTPMethod = http.MethodGet\n \t}\n-\tstore := options.Storage\n-\tif store == nil {\n-\t\tstore = NewMemoryStorage()\n-\t}\n+\tstore := NewMemoryStorage()\n \n \trefresh := func(ctx context.Context) error {\n \t\treq, err := http.NewRequestWithContext(ctx, options.HTTPMethod, u.String(), nil)\n@@ -262,6 +259,7 @@ func NewStorageFromHTTP(u *url.URL, options HTTPClientStorageOptions) (Storage,\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"failed to decode JWK Set response: %w\", err)\n \t\t}\n+\t\tstore.KeyDeleteAll() // Clear local cache in case of key revocation.\n \t\tfor _, marshal := range jwks.Keys {\n \t\t\tmarshalOptions := JWKMarshalOptions{\n \t\t\t\tPrivate: true,"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 1,
        "unique_directories": 2,
        "max_directory_depth": 2
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "358331084d76c1d6857b3611730722b4b1bfae8a",
            "date": "2025-01-10T01:47:09Z",
            "author_login": "MicahParks"
          },
          {
            "sha": "c8d5ec73b1775084eb1e7861d8006ed96344992f",
            "date": "2025-01-10T01:24:02Z",
            "author_login": "MicahParks"
          },
          {
            "sha": "01db49a90f7f20c7fb39a699a2f19a7a5f379ed3",
            "date": "2025-01-09T13:18:05Z",
            "author_login": "MicahParks"
          },
          {
            "sha": "ce57ded280d99191ea54e3c4c5460c58207c3bbf",
            "date": "2024-12-14T16:00:23Z",
            "author_login": "MicahParks"
          },
          {
            "sha": "343575748f3587b06114abb82a3c997abfde07e9",
            "date": "2024-11-26T19:42:29Z",
            "author_login": "MicahParks"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": null,
    "cvss_vector": null,
    "cwe_id": "CWE-672",
    "description": "JWK Set (JSON Web Key Set) is a JWK and JWK Set Go implementation. Prior to 0.6.0, the project's provided HTTP client's local JWK Set cache should do a full replacement when the goroutine refreshes the remote JWK Set. The current behavior is to overwrite or append. This is a security issue for use cases that utilize the provided auto-caching HTTP client and where key removal from a JWK Set is equivalent to revocation. The affected auto-caching HTTP client was added in version v0.5.0 and fixed in v0.6.0. The only workaround would be to remove the provided auto-caching HTTP client and replace it with a custom implementation. This involves setting the HTTPClientStorageOptions.RefreshInterval to zero (or not specifying the value).",
    "attack_vector": null,
    "attack_complexity": null
  },
  "temporal_data": {
    "published_date": "2025-01-09T18:15:30.233",
    "last_modified": "2025-01-09T18:15:30.233",
    "fix_date": "2025-01-09T13:18:05Z"
  },
  "references": [
    {
      "url": "https://github.com/MicahParks/jwkset/commit/01db49a90f7f20c7fb39a699a2f19a7a5f379ed3",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/MicahParks/jwkset/issues/40",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/MicahParks/jwkset/security/advisories/GHSA-675f-rq2r-jw82",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:58.240758",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "jwkset",
    "owner": "MicahParks",
    "created_at": "2022-09-14T00:26:09Z",
    "updated_at": "2025-01-10T01:47:17Z",
    "pushed_at": "2025-01-10T01:47:14Z",
    "size": 799,
    "stars": 40,
    "forks": 13,
    "open_issues": 1,
    "watchers": 40,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [
      "main"
    ],
    "languages": {
      "Go": 183212,
      "JavaScript": 16901,
      "Shell": 1112,
      "Dockerfile": 348,
      "CSS": 59
    },
    "commit_activity": {
      "total_commits_last_year": 0,
      "avg_commits_per_week": 0,
      "days_active_last_year": 0
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": true,
      "has_wiki": true,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "apache-2.0"
    },
    "collected_at": "2025-01-14T18:56:58.379982"
  }
}