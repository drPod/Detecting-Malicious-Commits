{
  "cve_id": "CVE-2025-22151",
  "github_data": {
    "repository": "strawberry-graphql/strawberry",
    "fix_commit": "526eb82b70451c0e59d5a71ae9b7396f59974bd8",
    "related_commits": [
      "526eb82b70451c0e59d5a71ae9b7396f59974bd8"
    ],
    "patch_url": "https://github.com/strawberry-graphql/strawberry/commit/526eb82b70451c0e59d5a71ae9b7396f59974bd8.patch",
    "fix_commit_details": {
      "sha": "526eb82b70451c0e59d5a71ae9b7396f59974bd8",
      "commit_date": "2025-01-09T18:29:13Z",
      "author": {
        "login": "bellini666",
        "type": "User",
        "stats": null
      },
      "commit_message": {
        "title": "fix: Prevent a possible security issue when resolving a relay node with multiple possibilities (#3749)",
        "length": 102,
        "has_description": false,
        "references_issue": true
      },
      "stats": {
        "total": 206,
        "additions": 203,
        "deletions": 3
      },
      "files": [
        {
          "filename": "RELEASE.md",
          "status": "added",
          "additions": 21,
          "deletions": 0,
          "patch": "@@ -0,0 +1,21 @@\n+Release type: minor\n+\n+The common `node: Node` used to resolve relay nodes means we will be relying on\n+is_type_of to check if the returned object is in fact a subclass of the Node\n+interface.\n+\n+However, integrations such as Django, SQLAlchemy and Pydantic will not return\n+the type itself, but instead an alike object that is later resolved to the\n+expected type.\n+\n+In case there are more than one possible type defined for that model that is\n+being returned, the first one that replies True to `is_type_of` check would be\n+used in the resolution, meaning that when asking for `\"PublicUser:123\"`,\n+strawberry could end up returning `\"User:123\"`, which can lead to security\n+issues (such as data leakage).\n+\n+In here we are introducing a new `strawberry.cast`, which will be used to mark\n+an object with the already known type by us, and when asking for is_type_of that\n+mark will be used to check instead, ensuring we will return the correct type.\n+\n+That `cast` is already in place for the relay node resolution and pydantic."
        },
        {
          "filename": "strawberry/__init__.py",
          "status": "modified",
          "additions": 2,
          "deletions": 0,
          "patch": "@@ -13,6 +13,7 @@\n from .schema_directive import schema_directive\n from .types.arguments import argument\n from .types.auto import auto\n+from .types.cast import cast\n from .types.enum import enum, enum_value\n from .types.field import field\n from .types.info import Info\n@@ -36,6 +37,7 @@\n     \"argument\",\n     \"asdict\",\n     \"auto\",\n+    \"cast\",\n     \"directive\",\n     \"directive_field\",\n     \"enum\","
        },
        {
          "filename": "strawberry/experimental/pydantic/object_type.py",
          "status": "modified",
          "additions": 4,
          "deletions": 0,
          "patch": "@@ -29,6 +29,7 @@\n     get_private_fields,\n )\n from strawberry.types.auto import StrawberryAuto\n+from strawberry.types.cast import get_strawberry_type_cast\n from strawberry.types.field import StrawberryField\n from strawberry.types.object_type import _process_type, _wrap_dataclass\n from strawberry.types.type_resolver import _get_fields\n@@ -207,6 +208,9 @@ def wrap(cls: Any) -> builtins.type[StrawberryTypeFromPydantic[PydanticModel]]:\n         # pydantic objects (not the corresponding strawberry type)\n         @classmethod  # type: ignore\n         def is_type_of(cls: builtins.type, obj: Any, _info: GraphQLResolveInfo) -> bool:\n+            if (type_cast := get_strawberry_type_cast(obj)) is not None:\n+                return type_cast is cls\n+\n             return isinstance(obj, (cls, model))\n \n         namespace = {\"is_type_of\": is_type_of}"
        },
        {
          "filename": "strawberry/relay/fields.py",
          "status": "modified",
          "additions": 28,
          "deletions": 3,
          "patch": "@@ -37,6 +37,7 @@\n )\n from strawberry.types.arguments import StrawberryArgument, argument\n from strawberry.types.base import StrawberryList, StrawberryOptional\n+from strawberry.types.cast import cast as strawberry_cast\n from strawberry.types.field import _RESOLVER_TYPE, StrawberryField, field\n from strawberry.types.fields.resolver import StrawberryResolver\n from strawberry.types.lazy_type import LazyType\n@@ -88,12 +89,27 @@ def resolver(\n             info: Info,\n             id: Annotated[GlobalID, argument(description=\"The ID of the object.\")],\n         ) -> Union[Node, None, Awaitable[Union[Node, None]]]:\n-            return id.resolve_type(info).resolve_node(\n+            node_type = id.resolve_type(info)\n+            resolved_node = node_type.resolve_node(\n                 id.node_id,\n                 info=info,\n                 required=not is_optional,\n             )\n \n+            # We are using `strawberry_cast` here to cast the resolved node to make\n+            # sure `is_type_of` will not try to find its type again. Very important\n+            # when returning a non type (e.g. Django/SQLAlchemy/Pydantic model), as\n+            # we could end up resolving to a different type in case more than one\n+            # are registered.\n+            if inspect.isawaitable(resolved_node):\n+\n+                async def resolve() -> Any:\n+                    return strawberry_cast(node_type, await resolved_node)\n+\n+                return resolve()\n+\n+            return cast(Node, strawberry_cast(node_type, resolved_node))\n+\n         return resolver\n \n     def get_node_list_resolver(\n@@ -139,6 +155,14 @@ def resolver(\n                 if inspect.isasyncgen(nodes)\n             }\n \n+            # We are using `strawberry_cast` here to cast the resolved node to make\n+            # sure `is_type_of` will not try to find its type again. Very important\n+            # when returning a non type (e.g. Django/SQLAlchemy/Pydantic model), as\n+            # we could end up resolving to a different type in case more than one\n+            # are registered\n+            def cast_nodes(node_t: type[Node], nodes: Iterable[Any]) -> list[Node]:\n+                return [cast(Node, strawberry_cast(node_t, node)) for node in nodes]\n+\n             if awaitable_nodes or asyncgen_nodes:\n \n                 async def resolve(resolved: Any = resolved_nodes) -> list[Node]:\n@@ -161,7 +185,8 @@ async def resolve(resolved: Any = resolved_nodes) -> list[Node]:\n \n                     # Resolve any generator to lists\n                     resolved = {\n-                        node_t: list(nodes) for node_t, nodes in resolved.items()\n+                        node_t: cast_nodes(node_t, nodes)\n+                        for node_t, nodes in resolved.items()\n                     }\n                     return [\n                         resolved[index_map[gid][0]][index_map[gid][1]] for gid in ids\n@@ -171,7 +196,7 @@ async def resolve(resolved: Any = resolved_nodes) -> list[Node]:\n \n             # Resolve any generator to lists\n             resolved = {\n-                node_t: list(cast(Iterator[Node], nodes))\n+                node_t: cast_nodes(node_t, cast(Iterable[Node], nodes))\n                 for node_t, nodes in resolved_nodes.items()\n             }\n             return [resolved[index_map[gid][0]][index_map[gid][1]] for gid in ids]"
        },
        {
          "filename": "strawberry/schema/schema_converter.py",
          "status": "modified",
          "additions": 7,
          "deletions": 0,
          "patch": "@@ -58,6 +58,7 @@\n     get_object_definition,\n     has_object_definition,\n )\n+from strawberry.types.cast import get_strawberry_type_cast\n from strawberry.types.enum import EnumDefinition\n from strawberry.types.field import UNRESOLVED\n from strawberry.types.lazy_type import LazyType\n@@ -619,6 +620,9 @@ def _get_is_type_of() -> Optional[Callable[[Any, GraphQLResolveInfo], bool]]:\n             )\n \n             def is_type_of(obj: Any, _info: GraphQLResolveInfo) -> bool:\n+                if (type_cast := get_strawberry_type_cast(obj)) is not None:\n+                    return type_cast in possible_types\n+\n                 if object_type.concrete_of and (\n                     has_object_definition(obj)\n                     and obj.__strawberry_definition__.origin\n@@ -898,6 +902,9 @@ def _get_is_type_of(\n         if object_type.interfaces:\n \n             def is_type_of(obj: Any, _info: GraphQLResolveInfo) -> bool:\n+                if (type_cast := get_strawberry_type_cast(obj)) is not None:\n+                    return type_cast is object_type.origin\n+\n                 if object_type.concrete_of and (\n                     has_object_definition(obj)\n                     and obj.__strawberry_definition__.origin"
        },
        {
          "filename": "strawberry/types/cast.py",
          "status": "added",
          "additions": 35,
          "deletions": 0,
          "patch": "@@ -0,0 +1,35 @@\n+from __future__ import annotations\n+\n+from typing import Any, TypeVar, overload\n+\n+_T = TypeVar(\"_T\", bound=object)\n+\n+TYPE_CAST_ATTRIBUTE = \"__as_strawberry_type__\"\n+\n+\n+@overload\n+def cast(type_: type, obj: None) -> None: ...\n+\n+\n+@overload\n+def cast(type_: type, obj: _T) -> _T: ...\n+\n+\n+def cast(type_: type, obj: _T | None) -> _T | None:\n+    \"\"\"Cast an object to given type.\n+\n+    This is used to mark an object as a cast object, so that the type can be\n+    picked up when resolving unions/interfaces in case of ambiguity, which can\n+    happen when returning an alike object instead of an instance of the type\n+    (e.g. returning a Django, Pydantic or SQLAlchemy object)\n+    \"\"\"\n+    if obj is None:\n+        return None\n+\n+    setattr(obj, TYPE_CAST_ATTRIBUTE, type_)\n+    return obj\n+\n+\n+def get_strawberry_type_cast(obj: Any) -> type | None:\n+    \"\"\"Get the type of a cast object.\"\"\"\n+    return getattr(obj, TYPE_CAST_ATTRIBUTE, None)"
        },
        {
          "filename": "tests/relay/test_fields.py",
          "status": "modified",
          "additions": 78,
          "deletions": 0,
          "patch": "@@ -1,4 +1,8 @@\n+import dataclasses\n import textwrap\n+from collections.abc import Iterable\n+from typing import Optional, Union\n+from typing_extensions import Self\n \n import pytest\n from pytest_mock import MockerFixture\n@@ -1621,3 +1625,77 @@ def test_query_after_error():\n \n     assert result.errors is not None\n     assert \"Argument 'after' contains a non-existing value\" in str(result.errors)\n+\n+\n+@pytest.mark.parametrize(\n+    (\"type_name\", \"should_have_name\"),\n+    [(\"Fruit\", False), (\"PublicFruit\", True)],\n+)\n+@pytest.mark.django_db(transaction=True)\n+def test_correct_model_returned(type_name: str, should_have_name: bool):\n+    @dataclasses.dataclass\n+    class FruitModel:\n+        id: str\n+        name: str\n+\n+    fruits: dict[str, FruitModel] = {\"1\": FruitModel(id=\"1\", name=\"Strawberry\")}\n+\n+    @strawberry.type\n+    class Fruit(relay.Node):\n+        id: relay.NodeID[int]\n+\n+        @classmethod\n+        def resolve_nodes(\n+            cls,\n+            *,\n+            info: Optional[strawberry.Info] = None,\n+            node_ids: Iterable[str],\n+            required: bool = False,\n+        ) -> Iterable[Optional[Union[Self, FruitModel]]]:\n+            return [fruits[nid] if required else fruits.get(nid) for nid in node_ids]\n+\n+    @strawberry.type\n+    class PublicFruit(relay.Node):\n+        id: relay.NodeID[int]\n+        name: str\n+\n+        @classmethod\n+        def resolve_nodes(\n+            cls,\n+            *,\n+            info: Optional[strawberry.Info] = None,\n+            node_ids: Iterable[str],\n+            required: bool = False,\n+        ) -> Iterable[Optional[Union[Self, FruitModel]]]:\n+            return [fruits[nid] if required else fruits.get(nid) for nid in node_ids]\n+\n+    @strawberry.type\n+    class Query:\n+        node: relay.Node = relay.node()\n+\n+    schema = strawberry.Schema(query=Query, types=[Fruit, PublicFruit])\n+\n+    node_id = relay.to_base64(type_name, \"1\")\n+    result = schema.execute_sync(\n+        \"\"\"\n+        query NodeQuery($id: GlobalID!) {\n+          node(id: $id) {\n+            __typename\n+            id\n+            ... on PublicFruit {\n+              name\n+            }\n+          }\n+        }\n+    \"\"\",\n+        {\"id\": node_id},\n+    )\n+    assert result.errors is None\n+    assert isinstance(result.data, dict)\n+\n+    assert result.data[\"node\"][\"__typename\"] == type_name\n+    assert result.data[\"node\"][\"id\"] == node_id\n+    if should_have_name:\n+        assert result.data[\"node\"][\"name\"] == \"Strawberry\"\n+    else:\n+        assert \"name\" not in result.data[\"node\"]"
        },
        {
          "filename": "tests/types/test_cast.py",
          "status": "added",
          "additions": 28,
          "deletions": 0,
          "patch": "@@ -0,0 +1,28 @@\n+import strawberry\n+from strawberry.types.cast import get_strawberry_type_cast\n+\n+\n+def test_cast():\n+    @strawberry.type\n+    class SomeType: ...\n+\n+    class OtherType: ...\n+\n+    obj = OtherType\n+    assert get_strawberry_type_cast(obj) is None\n+\n+    cast_obj = strawberry.cast(SomeType, obj)\n+    assert cast_obj is obj\n+    assert get_strawberry_type_cast(cast_obj) is SomeType\n+\n+\n+def test_cast_none_obj():\n+    @strawberry.type\n+    class SomeType: ...\n+\n+    obj = None\n+    assert get_strawberry_type_cast(obj) is None\n+\n+    cast_obj = strawberry.cast(SomeType, obj)\n+    assert cast_obj is None\n+    assert get_strawberry_type_cast(obj) is None"
        }
      ],
      "file_patterns": {
        "security_files": 0,
        "config_files": 0,
        "dependency_files": 0,
        "test_files": 2,
        "unique_directories": 8,
        "max_directory_depth": 3
      },
      "context": {
        "surrounding_commits": [
          {
            "sha": "fa5c2d076ae8eea75dba83059bc1b9b41acecbb1",
            "date": "2025-01-12T10:05:35Z",
            "author_login": "botberry"
          },
          {
            "sha": "ef2787430fd0683e42fd316aff79eaa49163de9d",
            "date": "2025-01-12T10:04:04Z",
            "author_login": "bellini666"
          },
          {
            "sha": "1e0e1efe4b103f933fccc81961ec65db490d0058",
            "date": "2025-01-09T18:30:53Z",
            "author_login": "botberry"
          },
          {
            "sha": "526eb82b70451c0e59d5a71ae9b7396f59974bd8",
            "date": "2025-01-09T18:29:13Z",
            "author_login": "bellini666"
          },
          {
            "sha": "fc854f1d944a2ec31ca1df2cddef475073a2c61d",
            "date": "2025-01-08T18:17:05Z",
            "author_login": "pre-commit-ci[bot]"
          }
        ]
      }
    }
  },
  "vulnerability_details": {
    "cvss_score": 3.7,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N",
    "cwe_id": "CWE-843",
    "description": "Strawberry GraphQL is a library for creating GraphQL APIs. Starting in 0.182.0 and prior to version 0.257.0, a type confusion vulnerability exists in Strawberry GraphQL's relay integration that affects multiple ORM integrations (Django, SQLAlchemy, Pydantic). The vulnerability occurs when multiple GraphQL types are mapped to the same underlying model while using the relay node interface. When querying for a specific type using the global node field (e.g., FruitType:some-id), the resolver may incorrectly return an instance of a different type mapped to the same model (e.g., SpecialFruitType). This can lead to information disclosure if the alternate type exposes sensitive fields and potential privilege escalation if the alternate type contains data intended for restricted access. This vulnerability is fixed in 0.257.0.",
    "attack_vector": "NETWORK",
    "attack_complexity": "HIGH"
  },
  "temporal_data": {
    "published_date": "2025-01-09T19:15:20.410",
    "last_modified": "2025-01-09T19:15:20.410",
    "fix_date": "2025-01-09T18:29:13Z"
  },
  "references": [
    {
      "url": "https://github.com/strawberry-graphql/strawberry/commit/526eb82b70451c0e59d5a71ae9b7396f59974bd8",
      "source": "security-advisories@github.com",
      "tags": []
    },
    {
      "url": "https://github.com/strawberry-graphql/strawberry/security/advisories/GHSA-5xh2-23cc-5jc6",
      "source": "security-advisories@github.com",
      "tags": []
    }
  ],
  "collection_metadata": {
    "collected_at": "2025-01-11T23:09:58.241055",
    "processing_status": "raw"
  },
  "repository_context": {
    "name": "strawberry",
    "owner": "strawberry-graphql",
    "created_at": "2018-12-21T08:56:55Z",
    "updated_at": "2025-01-14T12:24:18Z",
    "pushed_at": "2025-01-14T18:45:37Z",
    "size": 14048,
    "stars": 4100,
    "forks": 541,
    "open_issues": 475,
    "watchers": 4100,
    "has_security_policy": false,
    "default_branch": "main",
    "protected_branches": [],
    "languages": {
      "Python": 2288173,
      "HTML": 6777,
      "TypeScript": 6577,
      "Dockerfile": 523,
      "Shell": 50
    },
    "commit_activity": {
      "total_commits_last_year": 313,
      "avg_commits_per_week": 6.019230769230769,
      "days_active_last_year": 114
    },
    "security_features": {
      "has_security_policy": false,
      "has_protected_branches": false,
      "has_wiki": false,
      "has_issues": true,
      "allow_forking": true,
      "is_template": false,
      "license": "mit"
    },
    "collected_at": "2025-01-14T20:20:46.606426"
  }
}